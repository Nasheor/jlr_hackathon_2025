{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CALIBRATION_DATA_SIZE 256\n#define VALID_CALIBRATION_CONTEXT_MAX_OFFSET 150\n\nstatic uint16_t g_system_calibrations_fixed[CALIBRATION_DATA_SIZE];\nstatic int16_t g_active_calibration_base_offset_fixed = 0;\n\nvoid init_calibration_system_fixed() {\n    memset(g_system_calibrations_fixed, 0xFF, sizeof(g_system_calibrations_fixed));\n    g_active_calibration_base_offset_fixed = 0;\n}\n\nvoid set_active_calibration_context_fixed(uint16_t context_id) {\n    switch (context_id) {\n        case 0x01: \n            g_active_calibration_base_offset_fixed = 0;\n            break;\n        case 0x02: \n            g_active_calibration_base_offset_fixed = 50;\n            break;\n        case 0x03: \n            g_active_calibration_base_offset_fixed = 100;\n            break;\n        case 0xFF: \n            g_active_calibration_base_offset_fixed = -1; \n            break;\n        default: \n            g_active_calibration_base_offset_fixed = 0; \n            break;\n    }\n}\n\nstatic void log_calibration_update_attempt_fixed(int32_t index, uint16_t value) {\n    volatile int32_t dummy_idx = index;\n    volatile uint16_t dummy_val = value;\n    (void)dummy_idx;\n    (void)dummy_val;\n}\n\nvoid modify_calibration_value_fixed(int16_t relative_index_within_context, uint16_t new_value) {\n    int32_t target_absolute_index = g_active_calibration_base_offset_fixed + relative_index_within_context;\n\n    if (target_absolute_index < 0 || target_absolute_index >= CALIBRATION_DATA_SIZE) {\n        log_calibration_update_attempt_fixed(-1, new_value);\n        return;\n    }\n\n    log_calibration_update_attempt_fixed(target_absolute_index, new_value);\n\n    g_system_calibrations_fixed[target_absolute_index] = new_value;\n}\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <new>\n\n// Represents the format of an incoming network/internal packet header for sensor data batches.\nstruct SensorBatchPacketHeader {\n    uint16_t packet_magic;\n    uint16_t num_readings;\n    uint32_t aggregate_data_payload_size; // Sum of all 'data_length' from individual readings in the packet\n};\n\n// Represents the format of an individual sensor reading entry as it appears in the raw packet\n// and how it's intended to be stored contiguously in the internal buffer.\nstruct RawSensorReadingEntry {\n    uint16_t sensor_id;\n    uint32_t timestamp;\n    uint16_t data_length; // The length of the actual data bytes for THIS reading (following this header)\n    // uint8_t data[]; // Variable length data conceptually follows this header\n};\n\nclass DynamicSensorDataLogger {\npublic:\n    DynamicSensorDataLogger() : m_storage_buffer(nullptr), m_allocated_capacity(0), m_current_size(0) {}\n\n    ~DynamicSensorDataLogger() {\n        if (m_storage_buffer) {\n            delete[] m_storage_buffer;\n        }\n    }\n\n    void clearBuffer() {\n        if (m_storage_buffer) {\n            delete[] m_storage_buffer;\n            m_storage_buffer = nullptr;\n        }\n        m_allocated_capacity = 0;\n        m_current_size = 0;\n    }\n\n    // Processes a raw packet containing a batch of sensor data readings.\n    // VULNERABILITY: Heap-based buffer overflow due to incorrect allocation size.\n    bool processSensorDataBatchVulnerable(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(SensorBatchPacketHeader)) {\n            return false;\n        }\n\n        const SensorBatchPacketHeader* batch_header = reinterpret_cast<const SensorBatchPacketHeader*>(raw_packet);\n\n        if (batch_header->packet_magic != 0xFEED) { // Validate magic number\n            return false;\n        }\n\n        // Check if the total payload size advertised in the header exceeds the provided packet length.\n        // This is a necessary boundary check for the incoming packet, but not sufficient for the heap allocation.\n        if (batch_header->aggregate_data_payload_size > (packet_length - sizeof(SensorBatchPacketHeader))) {\n            return false;\n        }\n\n        clearBuffer();\n\n        // VULNERABILITY:\n        // The internal storage buffer is allocated *only* based on 'aggregate_data_payload_size'\n        // from the batch header. This size is intended to cover only the variable-length data\n        // portions of all readings.\n        // However, each RawSensorReadingEntry also includes a fixed-size header (sensor_id, timestamp, data_length)\n        // which will also be copied into this buffer. This fixed-size header space is *not* accounted for in the allocation.\n        m_storage_buffer = new (std::nothrow) uint8_t[batch_header->aggregate_data_payload_size];\n        if (!m_storage_buffer && batch_header->aggregate_data_payload_size > 0) {\n            return false;\n        }\n        m_allocated_capacity = batch_header->aggregate_data_payload_size;\n        m_current_size = 0;\n\n        size_t current_packet_read_offset = sizeof(SensorBatchPacketHeader);\n\n        for (uint16_t i = 0; i < batch_header->num_readings; ++i) {\n            // Ensure there's enough packet data for at least an individual reading header.\n            if (current_packet_read_offset + sizeof(RawSensorReadingEntry) > packet_length) {\n                clearBuffer();\n                return false;\n            }\n\n            const RawSensorReadingEntry* reading_header = reinterpret_cast<const RawSensorReadingEntry*>(raw_packet + current_packet_read_offset);\n\n            // Calculate the total size of this single entry (fixed header + variable data payload).\n            size_t current_entry_total_size = sizeof(RawSensorReadingEntry) + reading_header->data_length;\n\n            // Check if the current entry's data extends beyond the remaining packet data.\n            if (current_packet_read_offset + current_entry_total_size > packet_length) {\n                clearBuffer();\n                return false;\n            }\n            \n            // Copy the entire RawSensorReadingEntry (its fixed header + its data payload)\n            // from the raw packet into the internal storage buffer.\n            // As 'm_current_size' accumulates 'current_entry_total_size' for each reading,\n            // it will quickly exceed 'm_allocated_capacity' because 'm_allocated_capacity'\n            // only accounts for the sum of 'data_length's, not also 'sizeof(RawSensorReadingEntry)' for each.\n            // This loop will write past the end of 'm_storage_buffer' if there are multiple readings.\n            for (size_t k = 0; k < current_entry_total_size; ++k) {\n                m_storage_buffer[m_current_size + k] = raw_packet[current_packet_read_offset + k];\n            }\n\n            // Advance offsets for the next reading.\n            m_current_size += current_entry_total_size; // Tracks bytes written to internal buffer\n            current_packet_read_offset += current_entry_total_size; // Tracks bytes consumed from source packet\n        }\n\n        return true;\n    }\n\n    const uint8_t* getStoredData() const { return m_storage_buffer; }\n    size_t getStoredDataSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_storage_buffer;\n    size_t   m_allocated_capacity;\n    size_t   m_current_size;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define CONFIG_STORAGE_BUFFER_SIZE 256\n#define MAX_CONFIG_PACKET_SIZE 128\n#define MAX_SUPPORTED_VALUE_LENGTH 64\n\ntypedef struct {\n    uint8_t key_id;\n    uint8_t value_type;\n    uint8_t value_length;\n} ConfigEntryHeader;\n\nstatic uint8_t g_configStorageBuffer[CONFIG_STORAGE_BUFFER_SIZE];\nstatic uint16_t g_currentStorageOffset = 0;\n\nvoid initConfigManager() {\n    memset(g_configStorageBuffer, 0, CONFIG_STORAGE_BUFFER_SIZE);\n    g_currentStorageOffset = 0;\n}\n\nint applyConfigUpdate(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len == 0 || packet_len > MAX_CONFIG_PACKET_SIZE) {\n        return -1;\n    }\n\n    uint16_t packet_parse_offset = 0;\n\n    while (packet_parse_offset < packet_len) {\n        if (packet_parse_offset + sizeof(ConfigEntryHeader) > packet_len) {\n            return -2;\n        }\n\n        const ConfigEntryHeader* current_header = (const ConfigEntryHeader*)(packet + packet_parse_offset);\n        uint8_t entry_value_len = current_header->value_length;\n\n        if (entry_value_len > MAX_SUPPORTED_VALUE_LENGTH) {\n            return -3;\n        }\n\n        if (packet_parse_offset + sizeof(ConfigEntryHeader) + entry_value_len > packet_len) {\n            return -4;\n        }\n\n        if (g_currentStorageOffset + entry_value_len > CONFIG_STORAGE_BUFFER_SIZE) {\n            return -5;\n        }\n\n        for (uint8_t i = 0; i < entry_value_len; ++i) {\n            g_configStorageBuffer[g_currentStorageOffset + i] = packet[packet_parse_offset + sizeof(ConfigEntryHeader) + i];\n        }\n\n        g_currentStorageOffset += entry_value_len;\n        packet_parse_offset += sizeof(ConfigEntryHeader) + entry_value_len;\n    }\n\n    return 0;\n}\n\nuint8_t getConfigByte(uint16_t offset) {\n    if (offset < CONFIG_STORAGE_BUFFER_SIZE) {\n        return g_configStorageBuffer[offset];\n    }\n    return 0xFF;\n}\n\nvoid simulateIncomingConfigPacket(const uint8_t* data, uint16_t len) {\n    applyConfigUpdate(data, len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_DATA_BUFFER_SIZE 512\n#define MAX_DIAG_FRAME_SIZE 256\n#define FRAME_LENGTH_INDICATOR_OFFSET_FROM_END 2\n\nstatic uint8_t g_diag_raw_buffer[DIAG_DATA_BUFFER_SIZE];\nstatic uint32_t g_diag_buffer_current_len = 0;\n\nvoid receiveDiagData(const uint8_t* data, uint32_t len) {\n    if (len > DIAG_DATA_BUFFER_SIZE - g_diag_buffer_current_len) {\n        len = DIAG_DATA_BUFFER_SIZE - g_diag_buffer_current_len;\n    }\n    if (len > 0) {\n        memcpy(g_diag_raw_buffer + g_diag_buffer_current_len, data, len);\n        g_diag_buffer_current_len += len;\n    }\n}\n\nvoid processDiagFrame(const uint8_t* frame_data, uint32_t frame_len) {\n    if (frame_data && frame_len > 0) {\n        volatile uint8_t check_byte = frame_data[0];\n        (void)check_byte;\n    }\n}\n\nvoid extractLastDiagFrame_Vulnerable() {\n    if (g_diag_buffer_current_len < FRAME_LENGTH_INDICATOR_OFFSET_FROM_END) {\n        return;\n    }\n\n    uint8_t frame_total_len_indicator = g_diag_raw_buffer[g_diag_buffer_current_len - FRAME_LENGTH_INDICATOR_OFFSET_FROM_END];\n\n    int start_idx_signed = (int)g_diag_buffer_current_len - frame_total_len_indicator;\n\n    uint8_t extracted_frame_buffer[MAX_DIAG_FRAME_SIZE];\n\n    if (frame_total_len_indicator > 0) {\n        g_diag_raw_buffer[start_idx_signed] = 0x00;\n    }\n\n    memcpy(extracted_frame_buffer, g_diag_raw_buffer + start_idx_signed, frame_total_len_indicator);\n    processDiagFrame(extracted_frame_buffer, frame_total_len_indicator);\n\n    g_diag_buffer_current_len -= frame_total_len_indicator;\n    if (g_diag_buffer_current_len < 0) g_diag_buffer_current_len = 0;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define EVENT_LOG_BUFFER_SIZE 32\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp_ms;\n    bool processed;\n    uint8_t severity;\n} VehicleEventLogEntry;\n\nstatic VehicleEventLogEntry g_event_log[EVENT_LOG_BUFFER_SIZE];\nstatic uint16_t g_log_write_ptr = 0;\nstatic uint16_t g_num_logged_events = 0;\n\nvoid init_event_log() {\n    for (int i = 0; i < EVENT_LOG_BUFFER_SIZE; ++i) {\n        memset(&g_event_log[i], 0, sizeof(VehicleEventLogEntry));\n        g_event_log[i].processed = false;\n    }\n    g_log_write_ptr = 0;\n    g_num_logged_events = 0;\n}\n\nvoid add_event_log_entry(uint16_t id, uint32_t timestamp, uint8_t severity) {\n    if (g_num_logged_events < EVENT_LOG_BUFFER_SIZE) {\n        g_num_logged_events++;\n    }\n    g_event_log[g_log_write_ptr].event_id = id;\n    g_event_log[g_log_write_ptr].timestamp_ms = timestamp;\n    g_event_log[g_log_write_ptr].processed = false;\n    g_event_log[g_log_write_ptr].severity = severity;\n    g_log_write_ptr = (g_log_write_ptr + 1) % EVENT_LOG_BUFFER_SIZE;\n}\n\nvoid mark_event_processed_fixed(uint16_t steps_back) {\n    if (g_num_logged_events == 0) {\n        return;\n    }\n\n    int last_event_idx = (g_log_write_ptr == 0) ? (EVENT_LOG_BUFFER_SIZE - 1) : (g_log_write_ptr - 1);\n\n    int target_raw_idx = last_event_idx - steps_back;\n\n    if (target_raw_idx < 0 || steps_back >= g_num_logged_events) {\n        return;\n    }\n\n    uint16_t actual_target_idx = (uint16_t)target_raw_idx;\n    \n    g_event_log[actual_target_idx].processed = true;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define LOG_BUFFER_MAX_SIZE 512\n#define EVENT_HEADER_BASE_SIZE 2\n\nstatic uint8_t g_eventLogBuffer[LOG_BUFFER_MAX_SIZE];\nstatic uint16_t g_logCurrentWriteOffset = 0;\n\nvoid initEventLogger() {\n    memset(g_eventLogBuffer, 0, LOG_BUFFER_MAX_SIZE);\n    g_logCurrentWriteOffset = 0;\n}\n\nint processIncomingEvent(const uint8_t* message_payload, uint16_t payload_len) {\n    if (message_payload == NULL || payload_len < EVENT_HEADER_BASE_SIZE) {\n        return -1;\n    }\n\n    uint8_t event_type = message_payload[0];\n    uint8_t data_len = message_payload[1];\n\n    if (EVENT_HEADER_BASE_SIZE + data_len > payload_len) {\n        return -2;\n    }\n\n    uint16_t total_entry_size = (uint16_t)EVENT_HEADER_BASE_SIZE + data_len;\n\n    if (g_logCurrentWriteOffset + total_entry_size > LOG_BUFFER_MAX_SIZE) {\n        return -3;\n    }\n\n    g_eventLogBuffer[g_logCurrentWriteOffset] = event_type;\n    g_logCurrentWriteOffset++;\n\n    g_eventLogBuffer[g_logCurrentWriteOffset] = data_len;\n    g_logCurrentWriteOffset++;\n\n    const uint8_t* event_data_ptr = message_payload + EVENT_HEADER_BASE_SIZE;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_eventLogBuffer[g_logCurrentWriteOffset + i] = event_data_ptr[i];\n    }\n    g_logCurrentWriteOffset += data_len;\n\n    return 0;\n}\n\nuint8_t getLogByte(uint16_t offset) {\n    if (offset < LOG_BUFFER_MAX_SIZE) {\n        return g_eventLogBuffer[offset];\n    }\n    return 0xFF;\n}\n\nvoid simulateEventReception(const uint8_t* msg, uint16_t len) {\n    processIncomingEvent(msg, len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\ntypedef struct {\n    uint16_t messageId;\n    uint16_t payloadType;\n    uint16_t payloadLength; \n    uint8_t payload[512]; \n} DiagnosticMessage;\n\nchar* processDiagnosticReport(const DiagnosticMessage* msg) {\n    if (!msg || msg->payloadLength == 0) {\n        return NULL;\n    }\n\n    char* hex_payload_str = (char*)malloc(msg->payloadLength + 1);\n\n    if (hex_payload_str == NULL) {\n        return NULL;\n    }\n\n    for (uint16_t i = 0; i < msg->payloadLength; ++i) {\n        sprintf(&hex_payload_str[i * 2], \"%02X\", msg->payload[i]);\n    }\n    hex_payload_str[msg->payloadLength * 2] = '\\0';\n\n    return hex_payload_str;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n#define MAX_GEAR_RATIOS 6\n#define MAX_SUSPENSION_SETTINGS 4\n#define MAX_DIAG_THRESHOLDS 8\n\ntypedef enum {\n    VEHICLE_ATTRIBUTE_GEAR_RATIOS = 0,\n    VEHICLE_ATTRIBUTE_SUSPENSION_SETTINGS,\n    VEHICLE_ATTRIBUTE_DIAGNOSTIC_THRESHOLDS,\n    VEHICLE_ATTRIBUTE_COUNT\n} VehicleAttributeType;\n\nstatic float g_gearRatios_fixed[MAX_GEAR_RATIOS];\nstatic float g_suspensionSettings_fixed[MAX_SUSPENSION_SETTINGS];\nstatic uint16_t g_diagThresholds_fixed[MAX_DIAG_THRESHOLDS];\n\ntypedef struct {\n    void*  buffer_ptr;\n    size_t element_size;\n    size_t max_elements;\n} AttributeInfo_fixed;\n\nstatic AttributeInfo_fixed g_attributeMap_fixed[VEHICLE_ATTRIBUTE_COUNT];\n\nvoid logVehicleError(const char* msg) {\n}\n\nvoid logVehicleEvent(const char* msg) {\n}\n\ntypedef struct {\n    VehicleAttributeType type;\n    uint16_t index;\n    uint32_t raw_value;\n} AttributeUpdateCommand_fixed;\n\nAttributeUpdateCommand_fixed receiveAttributeUpdateCommand_fixed() {\n    AttributeUpdateCommand_fixed cmd;\n    cmd.type = VEHICLE_ATTRIBUTE_GEAR_RATIOS;\n    cmd.index = MAX_GEAR_RATIOS;\n    cmd.raw_value = (uint32_t)(*(uint32_t*)(&(float){99.9f}));\n    return cmd;\n}\n\nvoid initializeVehicleAttributeSystem_fixed() {\n    g_attributeMap_fixed[VEHICLE_ATTRIBUTE_GEAR_RATIOS] = (AttributeInfo_fixed){\n        .buffer_ptr = g_gearRatios_fixed,\n        .element_size = sizeof(float),\n        .max_elements = MAX_GEAR_RATIOS\n    };\n    g_attributeMap_fixed[VEHICLE_ATTRIBUTE_SUSPENSION_SETTINGS] = (AttributeInfo_fixed){\n        .buffer_ptr = g_suspensionSettings_fixed,\n        .element_size = sizeof(float),\n        .max_elements = MAX_SUSPENSION_SETTINGS\n    };\n    g_attributeMap_fixed[VEHICLE_ATTRIBUTE_DIAGNOSTIC_THRESHOLDS] = (AttributeInfo_fixed){\n        .buffer_ptr = g_diagThresholds_fixed,\n        .element_size = sizeof(uint16_t),\n        .max_elements = MAX_DIAG_THRESHOLDS\n    };\n\n    for (int i = 0; i < MAX_GEAR_RATIOS; ++i) g_gearRatios_fixed[i] = 1.0f + i * 0.5f;\n    for (int i = 0; i < MAX_SUSPENSION_SETTINGS; ++i) g_suspensionSettings_fixed[i] = 10.0f + i * 1.0f;\n    for (int i = 0; i < MAX_DIAG_THRESHOLDS; ++i) g_diagThresholds_fixed[i] = 100 + i * 10;\n\n    logVehicleEvent(\"Vehicle attribute system initialized (fixed).\");\n}\n\nvoid updateVehicleAttribute_fixed(AttributeUpdateCommand_fixed cmd) {\n    if (cmd.type < VEHICLE_ATTRIBUTE_COUNT) {\n        AttributeInfo_fixed info = g_attributeMap_fixed[cmd.type];\n\n        if (info.buffer_ptr != NULL) {\n            if (cmd.index < info.max_elements) {\n                if (info.element_size == sizeof(float)) {\n                    ((float*)info.buffer_ptr)[cmd.index] = *(float*)&cmd.raw_value;\n                    logVehicleEvent(\"Float attribute updated (fixed).\");\n                } else if (info.element_size == sizeof(uint16_t)) {\n                    ((uint16_t*)info.buffer_ptr)[cmd.index] = (uint16_t)cmd.raw_value;\n                    logVehicleEvent(\"Uint16 attribute updated (fixed).\");\n                } else {\n                    logVehicleError(\"Unsupported element size for attribute buffer (fixed).\");\n                }\n            } else {\n                logVehicleError(\"Attribute update index out of bounds for its type (fixed).\");\n            }\n        } else {\n            logVehicleError(\"Attribute map entry buffer_ptr is null for valid type (fixed).\");\n        }\n    } else {\n        logVehicleError(\"Invalid vehicle attribute type received (fixed).\");\n    }\n}\n\nvoid vehicleConfigManager_fixed_main() {\n    initializeVehicleAttributeSystem_fixed();\n    AttributeUpdateCommand_fixed cmd = receiveAttributeUpdateCommand_fixed();\n    updateVehicleAttribute_fixed(cmd);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_LOG_ENTRIES 50\n#define DIAG_LOG_ENTRY_SIZE 8\n\ntypedef struct {\n    uint16_t eventId;\n    uint16_t subId;\n    uint32_t timestamp;\n} DiagnosticLogEntry;\n\nstatic DiagnosticLogEntry g_diagnosticLogBuffer[MAX_DIAG_LOG_ENTRIES];\nstatic uint16_t g_currentStoredLogCount = 0;\n\nvoid initDiagnosticLogger() {\n    memset(g_diagnosticLogBuffer, 0, sizeof(g_diagnosticLogBuffer));\n    g_currentStoredLogCount = 0;\n}\n\nint processAndStoreLogBlock(const uint8_t* raw_log_block, uint16_t block_byte_len) {\n    if (raw_log_block == NULL || block_byte_len == 0) {\n        return -1;\n    }\n\n    if (block_byte_len % DIAG_LOG_ENTRY_SIZE != 0) {\n        return -2;\n    }\n\n    uint16_t num_entries_to_process = block_byte_len / DIAG_LOG_ENTRY_SIZE;\n\n    for (uint16_t i = 0; i < num_entries_to_process; ++i) {\n        uint16_t target_log_idx = g_currentStoredLogCount + i;\n\n        g_diagnosticLogBuffer[target_log_idx].eventId = (raw_log_block[i * DIAG_LOG_ENTRY_SIZE] << 8) |\n                                                            raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 1];\n        g_diagnosticLogBuffer[target_log_idx].subId = (raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 2] << 8) |\n                                                          raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 3];\n        g_diagnosticLogBuffer[target_log_idx].timestamp = (raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 4] << 24) |\n                                                              (raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 5] << 16) |\n                                                              (raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 6] << 8) |\n                                                              raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 7];\n    }\n\n    g_currentStoredLogCount += num_entries_to_process;\n\n    return 0;\n}\n\nDiagnosticLogEntry getLogEntry(uint16_t index) {\n    if (index < MAX_DIAG_LOG_ENTRIES) {\n        return g_diagnosticLogBuffer[index];\n    }\n    DiagnosticLogEntry empty = {0,0,0};\n    return empty;\n}\n\nvoid simulateCanLogMessage(const uint8_t* data, uint16_t len) {\n    processAndStoreLogBlock(data, len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define CFG_GROUP_ENGINE_DIAG_FIXED       0\n#define CFG_GROUP_TRANSMISSION_CAL_FIXED  1\n#define CFG_GROUP_ADAS_SETTINGS_FIXED     2\n#define NUM_CFG_GROUPS_FIXED              3\n\n#define MAX_PARAMS_PER_GROUP_FIXED        10\n\ntypedef struct {\n    uint32_t value;\n    uint8_t  type;\n    bool     is_writable;\n} ConfigParameter_Fixed;\n\nstatic ConfigParameter_Fixed g_config_parameters_fixed[NUM_CFG_GROUPS_FIXED][MAX_PARAMS_PER_GROUP_FIXED];\n\nstatic const uint8_t g_actual_params_in_group_fixed[NUM_CFG_GROUPS_FIXED] = {\n    5,\n    8,\n    3\n};\n\nvoid log_config_system_error_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t group_id;\n    uint8_t param_index;\n} ConfigReadRequest_Fixed;\n\nConfigReadRequest_Fixed receive_config_read_request_fixed() {\n    ConfigReadRequest_Fixed req;\n    req.group_id = CFG_GROUP_ADAS_SETTINGS_FIXED;\n    req.param_index = 3;\n    return req;\n}\n\nvoid initialize_config_data_fixed() {\n    for (uint8_t i = 0; i < NUM_CFG_GROUPS_FIXED; ++i) {\n        for (uint8_t j = 0; j < g_actual_params_in_group_fixed[i]; ++j) {\n            g_config_parameters_fixed[i][j].value = (uint32_t)(i << 16) | j;\n            g_config_parameters_fixed[i][j].type = 0x01;\n            g_config_parameters_fixed[i][j].is_writable = true;\n        }\n        for (uint8_t j = g_actual_params_in_group_fixed[i]; j < MAX_PARAMS_PER_GROUP_FIXED; ++j) {\n             g_config_parameters_fixed[i][j].value = 0xFFFFFFFF;\n             g_config_parameters_fixed[i][j].type = 0xFF;\n             g_config_parameters_fixed[i][j].is_writable = false;\n        }\n    }\n    log_config_system_error_fixed(\"Configuration data initialized (fixed).\");\n}\n\nvoid read_config_parameter_fixed() {\n    ConfigReadRequest_Fixed req = receive_config_read_request_fixed();\n\n    if (req.group_id < NUM_CFG_GROUPS_FIXED) {\n        if (req.param_index < g_actual_params_in_group_fixed[req.group_id]) {\n            ConfigParameter_Fixed param = g_config_parameters_fixed[req.group_id][req.param_index];\n            log_config_system_error_fixed(\"Configuration parameter read successfully (fixed).\");\n        } else {\n            log_config_system_error_fixed(\"Configuration parameter index out of bounds for its specific group (fixed).\");\n        }\n    } else {\n        log_config_system_error_fixed(\"Configuration group ID out of bounds (fixed).\");\n    }\n}\n\nvoid config_manager_main_fixed() {\n    initialize_config_data_fixed();\n    read_config_parameter_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_ROUTES 5\n#define MAX_WAYPOINTS_PER_ROUTE 100\n\ntypedef struct {\n    float latitude;\n    float longitude;\n    uint16_t altitude;\n} Waypoint;\n\ntypedef struct {\n    uint8_t route_id;\n    uint8_t current_waypoint_idx; \n    uint16_t total_waypoints;\n    Waypoint waypoints[MAX_WAYPOINTS_PER_ROUTE];\n} RouteData;\n\nstatic RouteData g_vehicleRoutes_vulnerable[MAX_ROUTES];\n\nvoid vehicleLog_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t route_idx;\n    int16_t offset_from_current;\n} WaypointQuery_Vulnerable;\n\nWaypointQuery_Vulnerable receiveWaypointQuery_vulnerable() {\n    WaypointQuery_Vulnerable query;\n    query.route_idx = 0; \n    query.offset_from_current = -1; \n    return query;\n}\n\nvoid initializeRoutes_vulnerable() {\n    for (uint8_t i = 0; i < MAX_ROUTES; ++i) {\n        g_vehicleRoutes_vulnerable[i].route_id = i;\n        g_vehicleRoutes_vulnerable[i].current_waypoint_idx = 0; \n        g_vehicleRoutes_vulnerable[i].total_waypoints = (i + 1) * 10; \n        if (g_vehicleRoutes_vulnerable[i].total_waypoints > MAX_WAYPOINTS_PER_ROUTE) {\n            g_vehicleRoutes_vulnerable[i].total_waypoints = MAX_WAYPOINTS_PER_ROUTE;\n        }\n        for (uint16_t j = 0; j < g_vehicleRoutes_vulnerable[i].total_waypoints; ++j) {\n            g_vehicleRoutes_vulnerable[i].waypoints[j] = (Waypoint){ (float)(10.0 + i + j), (float)(20.0 + i + j), (uint16_t)(100 + j) };\n        }\n    }\n    vehicleLog_vulnerable(\"Vehicle routes initialized (vulnerable).\");\n}\n\nvoid processWaypointQuery_vulnerable() {\n    WaypointQuery_Vulnerable query = receiveWaypointQuery_vulnerable();\n\n    if (query.route_idx < MAX_ROUTES) {\n        RouteData* current_route = &g_vehicleRoutes_vulnerable[query.route_idx];\n\n        uint16_t effective_index = current_route->current_waypoint_idx + query.offset_from_current;\n\n        if (effective_index < current_route->total_waypoints) {\n            Waypoint requested_waypoint = current_route->waypoints[effective_index];\n            vehicleLog_vulnerable(\"Waypoint data retrieved (vulnerable).\");\n        } else {\n            vehicleLog_vulnerable(\"Requested waypoint index out of logical bounds for route (positive check only).\");\n        }\n    } else {\n        vehicleLog_vulnerable(\"Invalid route index received (vulnerable).\");\n    }\n}\n\nvoid navigationSystemMain_vulnerable() {\n    initializeRoutes_vulnerable();\n    processWaypointQuery_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_ENGINE_PARAMS 10\n#define MAX_CHASSIS_PARAMS 15\n#define MAX_INFOTAINMENT_PARAMS 5\n\n#define GLOBAL_MAX_PARAMETER_INDEX 100 \n\ntypedef enum {\n    MODULE_ENGINE = 0,\n    MODULE_CHASSIS,\n    MODULE_INFOTAINMENT,\n    NUM_VEHICLE_MODULES_FIXED\n} VehicleModuleType_Fixed;\n\ntypedef struct {\n    uint16_t id;\n    int32_t  value;\n    bool     is_calibrated;\n} ParameterData_Fixed;\n\nstatic ParameterData_Fixed g_engineParameters_Fixed[MAX_ENGINE_PARAMS];\nstatic ParameterData_Fixed g_chassisParameters_Fixed[MAX_CHASSIS_PARAMS];\nstatic ParameterData_Fixed g_infotainmentParameters_Fixed[MAX_INFOTAINMENT_PARAMS];\n\nstatic ParameterData_Fixed* g_moduleParameterArrays_Fixed[NUM_VEHICLE_MODULES_FIXED];\nstatic uint16_t g_moduleCapacities_Fixed[NUM_VEHICLE_MODULES_FIXED];\n\nvoid logVehicleState_Fixed(const char* msg) {\n    printf(\"FIXED_LOG: %s\\n\", msg);\n}\n\ntypedef struct {\n    VehicleModuleType_Fixed module_id;\n    uint16_t parameter_index;\n    int32_t new_value;\n} ParameterUpdateCommand_Fixed;\n\nParameterUpdateCommand_Fixed getIncomingParameterUpdate_Fixed() {\n    ParameterUpdateCommand_Fixed cmd;\n    cmd.module_id = MODULE_INFOTAINMENT;\n    cmd.parameter_index = 5;\n    cmd.new_value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeVehicleParameters_Fixed() {\n    g_moduleParameterArrays_Fixed[MODULE_ENGINE] = g_engineParameters_Fixed;\n    g_moduleCapacities_Fixed[MODULE_ENGINE] = MAX_ENGINE_PARAMS;\n\n    g_moduleParameterArrays_Fixed[MODULE_CHASSIS] = g_chassisParameters_Fixed;\n    g_moduleCapacities_Fixed[MODULE_CHASSIS] = MAX_CHASSIS_PARAMS;\n\n    g_moduleParameterArrays_Fixed[MODULE_INFOTAINMENT] = g_infotainmentParameters_Fixed;\n    g_moduleCapacities_Fixed[MODULE_INFOTAINMENT] = MAX_INFOTAINMENT_PARAMS;\n\n    for (int i = 0; i < NUM_VEHICLE_MODULES_FIXED; ++i) {\n        for (uint16_t j = 0; j < g_moduleCapacities_Fixed[i]; ++j) {\n            g_moduleParameterArrays_Fixed[i][j] = (ParameterData_Fixed){0, 0, false};\n        }\n    }\n    logVehicleState_Fixed(\"Vehicle parameters initialized.\");\n}\n\nvoid processParameterUpdate_Fixed() {\n    ParameterUpdateCommand_Fixed cmd = getIncomingParameterUpdate_Fixed();\n\n    if (cmd.module_id >= NUM_VEHICLE_MODULES_FIXED) {\n        logVehicleState_Fixed(\"Error: Invalid module ID received.\");\n        return;\n    }\n\n    if (cmd.parameter_index < g_moduleCapacities_Fixed[cmd.module_id]) {\n        ParameterData_Fixed* target_array = g_moduleParameterArrays_Fixed[cmd.module_id];\n        \n        target_array[cmd.parameter_index].value = cmd.new_value;\n        target_array[cmd.parameter_index].is_calibrated = true;\n        logVehicleState_Fixed(\"Parameter updated successfully.\");\n    } else {\n        logVehicleState_Fixed(\"Error: Parameter index out of bounds for the selected module.\");\n    }\n}\n\nvoid vehicleControlUnitMain_Fixed() {\n    initializeVehicleParameters_Fixed();\n    processParameterUpdate_Fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define ECU_STATE_LOG_BUFFER_SIZE 32\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t control_param_A;\n    uint16_t control_param_B;\n    uint32_t diagnostic_status_flags;\n} ECU_StateSnapshot;\n\nstatic ECU_StateSnapshot g_ecu_state_log[ECU_STATE_LOG_BUFFER_SIZE];\nstatic uint16_t g_log_next_idx = 0; \nstatic bool g_buffer_full = false; \n\nvoid init_ecu_log() {\n    memset(g_ecu_state_log, 0, sizeof(g_ecu_state_log));\n    g_log_next_idx = 0;\n    g_buffer_full = false;\n}\n\nvoid log_ecu_state(uint32_t ts, uint16_t paramA, uint16_t paramB, uint32_t flags) {\n    g_ecu_state_log[g_log_next_idx].timestamp = ts;\n    g_ecu_state_log[g_log_next_idx].control_param_A = paramA;\n    g_ecu_state_log[g_log_next_idx].control_param_B = paramB;\n    g_ecu_state_log[g_log_next_idx].diagnostic_status_flags = flags;\n\n    g_log_next_idx++;\n    if (g_log_next_idx >= ECU_STATE_LOG_BUFFER_SIZE) {\n        g_log_next_idx = 0;\n        g_buffer_full = true;\n    }\n}\n\nvoid adjust_snapshot_param_vulnerable(uint16_t relative_offset_from_latest, uint16_t new_param_A_value) {\n    if (!g_buffer_full && g_log_next_idx == 0) {\n        return;\n    }\n\n    uint16_t latest_entry_idx;\n    if (g_log_next_idx == 0 && g_buffer_full) {\n        latest_entry_idx = ECU_STATE_LOG_BUFFER_SIZE - 1;\n    } else if (g_log_next_idx > 0) {\n        latest_entry_idx = g_log_next_idx - 1;\n    } else {\n        return; \n    }\n\n    int32_t target_idx_conceptual = (int32_t)latest_entry_idx - relative_offset_from_latest;\n\n    g_ecu_state_log[target_idx_conceptual].control_param_A = new_param_A_value;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 256\n\nstatic uint8_t g_vehicle_config_data_fixed[VEHICLE_CONFIG_BUFFER_SIZE];\nstatic uint16_t g_active_config_segment_base_idx_fixed = 0;\n\nvoid init_vehicle_config_fixed() {\n    memset(g_vehicle_config_data_fixed, 0xFF, VEHICLE_CONFIG_BUFFER_SIZE);\n    g_active_config_segment_base_idx_fixed = 0;\n}\n\nbool set_active_config_segment_fixed(uint16_t segment_id) {\n    if (segment_id == 0x01) {\n        g_active_config_segment_base_idx_fixed = 0;\n    } else if (segment_id == 0x02) {\n        g_active_config_segment_base_idx_fixed = 50;\n    } else if (segment_id == 0x03) {\n        g_active_config_segment_base_idx_fixed = 120;\n    } else {\n        return false;\n    }\n    return true;\n}\n\nvoid update_config_segment_fixed(int16_t relative_start_offset, const uint8_t* data, uint16_t data_len) {\n    if (data == NULL || data_len == 0) {\n        return;\n    }\n\n    int32_t target_abs_idx = (int32_t)g_active_config_segment_base_idx_fixed + relative_start_offset;\n\n    if (target_abs_idx < 0 ||\n        target_abs_idx + data_len > VEHICLE_CONFIG_BUFFER_SIZE ||\n        data_len > VEHICLE_CONFIG_BUFFER_SIZE) {\n        return;\n    }\n\n    memcpy(&g_vehicle_config_data_fixed[target_abs_idx], data, data_len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdio.h>\n\n#define DIAG_REPORT_BUFFER_SIZE 64\n#define MAX_VIN_LENGTH 17\n\ntypedef struct {\n    uint16_t dtc_code;\n    uint32_t timestamp;\n    char component_id[5];\n    char vin[MAX_VIN_LENGTH + 1];\n} DiagnosticReportData;\n\nstatic char g_diagnosticReportBuffer[DIAG_REPORT_BUFFER_SIZE];\n\nstatic int append_to_report_buffer_safe(const char* str, uint32_t len, uint32_t* current_offset, uint32_t buffer_size) {\n    if (str == NULL || *current_offset >= buffer_size) {\n        return -1;\n    }\n\n    uint32_t remaining_space_for_data = 0;\n    if (buffer_size > *current_offset) {\n        remaining_space_for_data = buffer_size - *current_offset - 1; \n    }\n\n    uint32_t bytes_to_copy = len;\n    if (bytes_to_copy > remaining_space_for_data) {\n        bytes_to_copy = remaining_space_for_data;\n    }\n    \n    for (uint32_t i = 0; i < bytes_to_copy; ++i) {\n        g_diagnosticReportBuffer[*current_offset + i] = str[i];\n    }\n    *current_offset += bytes_to_copy;\n\n    return 0;\n}\n\nint generateDiagnosticReport(const DiagnosticReportData* data) {\n    if (data == NULL) {\n        return -1;\n    }\n\n    uint32_t current_pos = 0;\n    memset(g_diagnosticReportBuffer, 0, DIAG_REPORT_BUFFER_SIZE);\n\n    const char* prefix = ", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define EVENT_BUFFER_SIZE_BYTES 512\n#define MAX_EVENT_PAYLOAD_BYTES 250\n\nstatic uint8_t g_vehicle_event_buffer[EVENT_BUFFER_SIZE_BYTES];\nstatic uint16_t g_event_write_head_offset = 0;\nstatic uint16_t g_num_active_events = 0;\n\ntypedef struct {\n    uint8_t  status_flags;\n    uint8_t  event_type_id;\n    uint16_t payload_len;\n} EventHeader;\n\n#define EVENT_HEADER_BYTE_SIZE (sizeof(EventHeader))\n\nuint32_t calculate_data_crc_dummy(const uint8_t* data, uint16_t len) {\n    uint32_t crc = 0;\n    if (data == NULL) return 0;\n    for (uint16_t i = 0; i < len; ++i) {\n        crc += data[i];\n    }\n    return crc;\n}\n\nvoid event_buffer_init() {\n    memset(g_vehicle_event_buffer, 0, sizeof(g_vehicle_event_buffer));\n    g_event_write_head_offset = 0;\n    g_num_active_events = 0;\n}\n\nbool event_buffer_add_event(uint8_t type_id, const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len == 0 || payload_len > MAX_EVENT_PAYLOAD_BYTES) {\n        return false;\n    }\n\n    if (g_event_write_head_offset + EVENT_HEADER_BYTE_SIZE + payload_len > EVENT_BUFFER_SIZE_BYTES) {\n        g_event_write_head_offset = 0;\n        if (g_event_write_head_offset + EVENT_HEADER_BYTE_SIZE + payload_len > EVENT_BUFFER_SIZE_BYTES) {\n            return false;\n        }\n    }\n\n    EventHeader* header_ptr = (EventHeader*)(g_vehicle_event_buffer + g_event_write_head_offset);\n    header_ptr->status_flags = 0x01;\n    header_ptr->event_type_id = type_id;\n    header_ptr->payload_len = payload_len;\n\n    memcpy(g_vehicle_event_buffer + g_event_write_head_offset + EVENT_HEADER_BYTE_SIZE, payload, payload_len);\n\n    g_event_write_head_offset += (EVENT_HEADER_BYTE_SIZE + payload_len);\n    g_num_active_events++;\n    return true;\n}\n\nvoid mark_event_as_processed_vulnerable(uint16_t event_data_offset, uint8_t new_status) {\n    g_vehicle_event_buffer[event_data_offset - EVENT_HEADER_BYTE_SIZE] = new_status;\n}\n\nbool get_event_payload(uint16_t event_data_offset, uint8_t* buffer, uint16_t* len) {\n    if (event_data_offset >= EVENT_BUFFER_SIZE_BYTES) return false;\n\n    int32_t header_offset = (int32_t)event_data_offset - EVENT_HEADER_BYTE_SIZE;\n    if (header_offset < 0) return false;\n\n    EventHeader* header_ptr = (EventHeader*)(g_vehicle_event_buffer + header_offset);\n\n    if (header_offset + EVENT_HEADER_BYTE_SIZE + header_ptr->payload_len > EVENT_BUFFER_SIZE_BYTES) {\n        return false;\n    }\n\n    if (buffer && len) {\n        if (*len < header_ptr->payload_len) {\n            *len = header_ptr->payload_len;\n            return false;\n        }\n        memcpy(buffer, g_vehicle_event_buffer + event_data_offset, header_ptr->payload_len);\n        *len = header_ptr->payload_len;\n        return true;\n    }\n    return false;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_VEHICLE_SYSTEMS 3\n#define MAX_CALIBRATION_POINTS_ENGINE 10\n#define MAX_CALIBRATION_POINTS_TRANSMISSION 8\n#define MAX_CALIBRATION_POINTS_BRAKES 5\n\ntypedef union {\n    float float_val;\n    int32_t int_val;\n    uint16_t short_val;\n} CalibrationValue_vulnerable;\n\nstatic CalibrationValue_vulnerable g_engineCalibrations_vulnerable[MAX_CALIBRATION_POINTS_ENGINE];\nstatic CalibrationValue_vulnerable g_transmissionCalibrations_vulnerable[MAX_CALIBRATION_POINTS_TRANSMISSION];\nstatic CalibrationValue_vulnerable g_brakeCalibrations_vulnerable[MAX_CALIBRATION_POINTS_BRAKES];\n\ntypedef enum {\n    VEHICLE_SYSTEM_ENGINE_VULNERABLE = 0,\n    VEHICLE_SYSTEM_TRANSMISSION_VULNERABLE = 1,\n    VEHICLE_SYSTEM_BRAKES_VULNERABLE = 2,\n    VEHICLE_SYSTEM_INVALID_VULNERABLE = 3\n} VehicleSystemID_vulnerable;\n\nvoid logVehicleError_vulnerable(const char* msg) {}\n\ntypedef struct {\n    VehicleSystemID_vulnerable system_id;\n    uint8_t calibration_index;\n    uint8_t requested_type;\n} CalibrationReadRequest_vulnerable;\n\nCalibrationReadRequest_vulnerable getSimulatedCalibrationReadRequest_vulnerable() {\n    CalibrationReadRequest_vulnerable req;\n    req.system_id = VEHICLE_SYSTEM_ENGINE_VULNERABLE;\n    req.calibration_index = 12;\n    req.requested_type = 0;\n    return req;\n}\n\nvoid initializeCalibrationData_vulnerable() {\n    for (uint8_t i = 0; i < MAX_CALIBRATION_POINTS_ENGINE; ++i) {\n        g_engineCalibrations_vulnerable[i].float_val = (float)i * 1.5f;\n    }\n    for (uint8_t i = 0; i < MAX_CALIBRATION_POINTS_TRANSMISSION; ++i) {\n        g_transmissionCalibrations_vulnerable[i].int_val = (int32_t)(i * 100);\n    }\n    for (uint8_t i = 0; i < MAX_CALIBRATION_POINTS_BRAKES; ++i) {\n        g_brakeCalibrations_vulnerable[i].short_val = (uint16_t)(i * 5);\n    }\n}\n\nvoid handleCalibrationReadRequest_vulnerable(CalibrationReadRequest_vulnerable request) {\n    CalibrationValue_vulnerable retrieved_value;\n\n    if (request.system_id >= VEHICLE_SYSTEM_INVALID_VULNERABLE) {\n        logVehicleError_vulnerable(\"Invalid Vehicle System ID received.\");\n        return;\n    }\n\n    switch (request.system_id) {\n        case VEHICLE_SYSTEM_ENGINE_VULNERABLE:\n            retrieved_value = g_engineCalibrations_vulnerable[request.calibration_index];\n            break;\n        case VEHICLE_SYSTEM_TRANSMISSION_VULNERABLE:\n            retrieved_value = g_transmissionCalibrations_vulnerable[request.calibration_index];\n            break;\n        case VEHICLE_SYSTEM_BRAKES_VULNERABLE:\n            retrieved_value = g_brakeCalibrations_vulnerable[request.calibration_index];\n            break;\n        default:\n            logVehicleError_vulnerable(\"Unknown vehicle system ID. Should not happen.\");\n            return;\n    }\n\n    if (request.requested_type == 0) { /* use retrieved_value.float_val */ }\n    else if (request.requested_type == 1) { /* use retrieved_value.int_val */ }\n    else if (request.requested_type == 2) { /* use retrieved_value.short_val */ }\n    else { logVehicleError_vulnerable(\"Unknown requested type for calibration value.\"); }\n}\n\nvoid main_vulnerable() {\n    initializeCalibrationData_vulnerable();\n    CalibrationReadRequest_vulnerable req = getSimulatedCalibrationReadRequest_vulnerable();\n    handleCalibrationReadRequest_vulnerable(req);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#define MAX_SUBSYSTEMS 3\n#define MAX_PARAMS_PER_SUBSYSTEM 10\n\ntypedef struct {\n    unsigned int param_value;\n    unsigned char param_status;\n} ConfigParam;\n\nstatic ConfigParam g_subsystemConfigs[MAX_SUBSYSTEMS][MAX_PARAMS_PER_SUBSYSTEM];\n\nstatic unsigned char g_subsystemActualParamCounts[MAX_SUBSYSTEMS] = {\n    5, \n    8, \n    3  \n};\n\ntypedef struct {\n    unsigned char subsystem_id;\n    unsigned char parameter_offset;\n    unsigned int new_value;\n} ConfigUpdateCommand;\n\nvoid logError(const char* msg) {\n}\n\nConfigUpdateCommand receiveConfigUpdateCommand_vulnerable() {\n    ConfigUpdateCommand cmd;\n    cmd.subsystem_id = 0;\n    cmd.parameter_offset = 5;\n    cmd.new_value = 0xAAAA;\n    return cmd;\n}\n\nvoid initializeSubsystemConfigs_vulnerable() {\n    for (int i = 0; i < MAX_SUBSYSTEMS; ++i) {\n        for (int j = 0; j < MAX_PARAMS_PER_SUBSYSTEM; ++j) {\n            g_subsystemConfigs[i][j] = (ConfigParam){0, 0};\n        }\n    }\n}\n\nvoid processConfigUpdate_vulnerable() {\n    ConfigUpdateCommand cmd = receiveConfigUpdateCommand_vulnerable();\n\n    if (cmd.subsystem_id < MAX_SUBSYSTEMS) {\n        g_subsystemConfigs[cmd.subsystem_id][cmd.parameter_offset].param_value = cmd.new_value;\n    } else {\n        logError(\"Invalid subsystem ID received.\");\n    }\n}\n\nvoid systemMain_vulnerable() {\n    initializeSubsystemConfigs_vulnerable();\n    processConfigUpdate_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define SENSOR_DATA_BUFFER_SIZE 256 \n#define MAX_SENSOR_LOG_ENTRIES 10   \n\ntypedef struct {\n    uint16_t sensor_id;\n    uint16_t timestamp;\n    uint16_t data_length;      \n    uint16_t data_offset;     \n} SensorLogEntry;\n\nstatic uint8_t g_sensorDataBuffer[SENSOR_DATA_BUFFER_SIZE];\nstatic SensorLogEntry g_sensorLogEntries[MAX_SENSOR_LOG_ENTRIES];\n\nstatic uint8_t g_nextLogEntryIndex = 0;\nstatic uint16_t g_sensorDataWriteOffset = 0;\n\nvoid initSensorLogger() {\n    memset(g_sensorDataBuffer, 0, sizeof(g_sensorDataBuffer));\n    memset(g_sensorLogEntries, 0, sizeof(g_sensorLogEntries));\n    g_nextLogEntryIndex = 0;\n    g_sensorDataWriteOffset = 0;\n}\n\nint logSensorData(uint16_t sensor_id, uint16_t timestamp, const uint8_t* raw_data, uint16_t raw_data_len) {\n    if (raw_data == NULL || raw_data_len == 0) {\n        return -1; \n    }\n    \n    if (g_nextLogEntryIndex >= MAX_SENSOR_LOG_ENTRIES) {\n        return -2; \n    }\n\n    if (raw_data_len > SENSOR_DATA_BUFFER_SIZE) {\n        return -3; \n    }\n\n    if (g_sensorDataWriteOffset + raw_data_len > SENSOR_DATA_BUFFER_SIZE) {\n        return -4; \n    }\n\n    g_sensorLogEntries[g_nextLogEntryIndex].sensor_id = sensor_id;\n    g_sensorLogEntries[g_nextLogEntryIndex].timestamp = timestamp;\n    g_sensorLogEntries[g_nextLogEntryIndex].data_length = raw_data_len;\n    g_sensorLogEntries[g_nextLogEntryIndex].data_offset = g_sensorDataWriteOffset;\n\n    memcpy(g_sensorDataBuffer + g_sensorDataWriteOffset, raw_data, raw_data_len);\n\n    g_sensorDataWriteOffset += raw_data_len;\n\n    g_nextLogEntryIndex++;\n\n    return 0; \n}\n\nvoid simulateSensorDataReception(uint16_t id, uint16_t ts, const uint8_t* data, uint16_t len) {\n    logSensorData(id, ts, data, len);\n}\n\nuint8_t getLoggedSensorDataByte(uint16_t index) {\n    if (index < SENSOR_DATA_BUFFER_SIZE) {\n        return g_sensorDataBuffer[index];\n    }\n    return 0xFF;\n}\n\nconst SensorLogEntry* getSensorLogEntry(uint8_t index) {\n    if (index < g_nextLogEntryIndex) {\n        return &g_sensorLogEntries[index];\n    }\n    return NULL;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_CONFIG_BANKS 4\n#define CONFIG_BANK_SIZE 128\n\nstatic uint8_t g_vehicleConfigMemory[NUM_CONFIG_BANKS][CONFIG_BANK_SIZE];\n\ntypedef struct {\n    uint8_t* current_bank_ptr;\n    uint8_t  bank_index;\n    uint16_t total_banks_size;\n} ConfigManagerContext;\n\nstatic ConfigManagerContext g_configManager;\n\nvoid initConfigManager() {\n    memset(g_vehicleConfigMemory, 0, sizeof(g_vehicleConfigMemory));\n    g_configManager.current_bank_ptr = NULL;\n    g_configManager.bank_index = 0xFF;\n    g_configManager.total_banks_size = NUM_CONFIG_BANKS * CONFIG_BANK_SIZE;\n}\n\nint selectConfigBank(uint8_t bank_idx) {\n    if (bank_idx >= NUM_CONFIG_BANKS) {\n        g_configManager.current_bank_ptr = NULL;\n        g_configManager.bank_index = 0xFF;\n        return -1;\n    }\n    g_configManager.current_bank_ptr = g_vehicleConfigMemory[bank_idx];\n    g_configManager.bank_index = bank_idx;\n    return 0;\n}\n\nint updateConfigParameter(const uint8_t* raw_msg, uint16_t msg_len) {\n    if (g_configManager.current_bank_ptr == NULL || g_configManager.bank_index == 0xFF) {\n        return -1;\n    }\n\n    if (raw_msg == NULL || msg_len < 2) {\n        return -2;\n    }\n\n    uint8_t offset_in_bank = raw_msg[0];\n    uint8_t data_len = raw_msg[1];\n\n    if (data_len == 0) {\n        return 0;\n    }\n\n    if (msg_len < (2 + data_len)) {\n        return -3;\n    }\n\n    if (offset_in_bank >= CONFIG_BANK_SIZE) {\n        return -4;\n    }\n\n    const uint8_t* data_source = raw_msg + 2;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_configManager.current_bank_ptr[offset_in_bank + i] = data_source[i];\n    }\n\n    return 0;\n}\n\nvoid handleIncomingConfigMessage(uint8_t bank_id, const uint8_t* data, uint16_t len) {\n    if (selectConfigBank(bank_id) == 0) {\n        updateConfigParameter(data, len);\n    }\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t data_len;\n} LogEntryHeader;\n\nclass CircularLogBufferVulnerable {\npublic:\n    CircularLogBufferVulnerable(size_t capacity) :\n        m_buffer(nullptr),\n        m_capacity(capacity),\n        m_write_pos(0)\n    {\n        if (m_capacity > 0) {\n            m_buffer = (uint8_t*)malloc(m_capacity);\n        }\n    }\n\n    ~CircularLogBufferVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    bool appendEntryVulnerable(const uint8_t* entry_data, size_t data_packet_len) {\n        if (!entry_data || data_packet_len < sizeof(LogEntryHeader)) {\n            return false;\n        }\n\n        const LogEntryHeader* header = reinterpret_cast<const LogEntryHeader*>(entry_data);\n        uint16_t payload_len = header->data_len;\n\n        size_t total_entry_size = sizeof(LogEntryHeader) + payload_len;\n\n        if (data_packet_len < total_entry_size) {\n            return false;\n        }\n        \n        if (m_write_pos + total_entry_size > m_capacity) {\n            m_write_pos = 0;\n        }\n        \n        if (!m_buffer) {\n            return false;\n        }\n\n        for (size_t i = 0; i < total_entry_size; ++i) {\n            m_buffer[m_write_pos + i] = entry_data[i];\n        }\n\n        m_write_pos = (m_write_pos + total_entry_size) % m_capacity;\n\n        return true;\n    }\n\n    size_t getCurrentWritePosition() const {\n        return m_write_pos;\n    }\n\n    size_t getBufferCapacity() const {\n        return m_capacity;\n    }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_capacity;\n    size_t m_write_pos;\n};\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_SENSOR_READINGS 100\n\ntypedef struct {\n    uint16_t value;\n    uint16_t timestamp_ms;\n} SensorReading;\n\nstatic SensorReading g_sensor_readings_buffer[MAX_SENSOR_READINGS];\nstatic uint32_t g_num_readings_stored = 0;\n\nvoid init_sensor_buffer() {\n    memset(g_sensor_readings_buffer, 0, sizeof(g_sensor_readings_buffer));\n    g_num_readings_stored = 0;\n}\n\nvoid add_sensor_reading(uint16_t value, uint16_t timestamp) {\n    if (g_num_readings_stored < MAX_SENSOR_READINGS) {\n        g_sensor_readings_buffer[g_num_readings_stored].value = value;\n        g_sensor_readings_buffer[g_num_readings_stored].timestamp_ms = timestamp;\n        g_num_readings_stored++;\n    }\n}\n\nvoid process_reading(SensorReading* reading) {\n    if (reading != NULL) {\n        volatile uint16_t val = reading->value;\n        (void)val;\n    }\n}\n\nvoid invalidate_old_sensor_readings_fixed(uint32_t offset_from_end, uint32_t num_to_invalidate) {\n    if (g_num_readings_stored == 0 || num_to_invalidate == 0) {\n        return;\n    }\n\n    // Determine the actual starting index for invalidation.\n    // Ensure 'actual_start_idx' does not go below zero by clamping 'offset_from_end'.\n    uint32_t actual_start_idx;\n    if (offset_from_end >= g_num_readings_stored) {\n        actual_start_idx = 0; // If offset is too large, start from the very beginning of valid data.\n    } else {\n        actual_start_idx = g_num_readings_stored - offset_from_end; // Calculate valid start index.\n    }\n\n    // Determine the actual number of elements to invalidate from 'actual_start_idx'.\n    // This ensures we don't try to invalidate more elements than are available from 'actual_start_idx' to the end of valid data.\n    uint32_t available_from_start_idx = g_num_readings_stored - actual_start_idx;\n    uint32_t actual_num_to_invalidate = (num_to_invalidate > available_from_start_idx) ? available_from_start_idx : num_to_invalidate;\n\n    // Perform invalidation within the validated range.\n    for (uint32_t i = 0; i < actual_num_to_invalidate; ++i) {\n        // Access is now guaranteed to be within [0, g_num_readings_stored - 1],\n        // preventing buffer underwrite.\n        g_sensor_readings_buffer[actual_start_idx + i].value = 0xDEAD;       \n        g_sensor_readings_buffer[actual_start_idx + i].timestamp_ms = 0xDEFE;\n    }\n\n    // Adjust the number of stored readings to reflect the actual truncation.\n    g_num_readings_stored = actual_start_idx; \n\n    if (g_num_readings_stored > 0) {\n        process_reading(&g_sensor_readings_buffer[0]);\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define VEHICLE_EVENT_LOG_BUFFER_SIZE 1024 \n#define FIXED_RECORD_PAYLOAD_SIZE 32 \n#define LOG_RECORD_TOTAL_SIZE (sizeof(uint16_t) + FIXED_RECORD_PAYLOAD_SIZE) \n#define NUM_EVENT_LOG_TYPES 5 \n\nstatic uint8_t g_eventLogBuffer_vulnerable[VEHICLE_EVENT_LOG_BUFFER_SIZE];\n\ntypedef struct {\n    uint16_t start_byte_offset;   \n    uint16_t max_records;         \n    uint16_t current_record_idx;  \n} EventLogSegmentInfo_vulnerable;\n\nstatic EventLogSegmentInfo_vulnerable g_logSegmentTable_vulnerable[NUM_EVENT_LOG_TYPES];\n\nvoid vehicleSystemLog_vulnerable(const char* message) {\n}\n\ntypedef struct {\n    uint8_t  eventTypeID;\n    uint16_t timestamp;\n    uint8_t  payload[FIXED_RECORD_PAYLOAD_SIZE];\n} IncomingLogRequest_vulnerable;\n\nIncomingLogRequest_vulnerable simulateIncomingLogRequest_vulnerable() {\n    IncomingLogRequest_vulnerable req;\n    req.eventTypeID = 3; \n    req.timestamp = 0xABCD;\n    for (int i = 0; i < FIXED_RECORD_PAYLOAD_SIZE; ++i) {\n        req.payload[i] = (uint8_t)(0xAA + i);\n    }\n    return req;\n}\n\nvoid initializeEventLogSystem_vulnerable() {\n    g_logSegmentTable_vulnerable[0] = (EventLogSegmentInfo_vulnerable){0, 5, 0};\n    g_logSegmentTable_vulnerable[1] = (EventLogSegmentInfo_vulnerable){170, 10, 0};\n    g_logSegmentTable_vulnerable[2] = (EventLogSegmentInfo_vulnerable){510, 8, 0};\n    g_logSegmentTable_vulnerable[3] = (EventLogSegmentInfo_vulnerable){782, 3, 0};\n    g_logSegmentTable_vulnerable[4] = (EventLogSegmentInfo_vulnerable){884, 4, 0};\n\n    for (int i = 0; i < VEHICLE_EVENT_LOG_BUFFER_SIZE; ++i) {\n        g_eventLogBuffer_vulnerable[i] = 0;\n    }\n    vehicleSystemLog_vulnerable(\"Event log system initialized.\");\n}\n\nvoid processAndStoreEvent_vulnerable() {\n    IncomingLogRequest_vulnerable req = simulateIncomingLogRequest_vulnerable();\n\n    if (req.eventTypeID >= NUM_EVENT_LOG_TYPES) {\n        vehicleSystemLog_vulnerable(\"Received log request with invalid event type ID.\");\n        return;\n    }\n\n    EventLogSegmentInfo_vulnerable* segment = &g_logSegmentTable_vulnerable[req.eventTypeID];\n\n    uint16_t target_physical_offset = segment->start_byte_offset +\n                                     (segment->current_record_idx * LOG_RECORD_TOTAL_SIZE);\n\n    if ((target_physical_offset + LOG_RECORD_TOTAL_SIZE) <= VEHICLE_EVENT_LOG_BUFFER_SIZE) {\n        *(uint16_t*)(g_eventLogBuffer_vulnerable + target_physical_offset) = req.timestamp;\n        for (int i = 0; i < FIXED_RECORD_PAYLOAD_SIZE; ++i) {\n            g_eventLogBuffer_vulnerable[target_physical_offset + sizeof(uint16_t) + i] = req.payload[i];\n        }\n        segment->current_record_idx++; \n        vehicleSystemLog_vulnerable(\"Event log entry stored.\");\n    } else {\n        vehicleSystemLog_vulnerable(\"Error: Event log buffer exhausted or physical address invalid.\");\n    }\n}\n\nvoid vehicleMainLoop_vulnerable() {\n    initializeEventLogSystem_vulnerable();\n\n    processAndStoreEvent_vulnerable(); \n    processAndStoreEvent_vulnerable(); \n    processAndStoreEvent_vulnerable(); \n    processAndStoreEvent_vulnerable(); \n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SENSOR_DATA_BUFFER_SIZE 32\n#define MAX_SENSOR_VALUE 1023\n\ntypedef struct {\n    uint16_t value;\n    uint32_t timestamp_ms;\n    uint8_t  status_flags;\n} SensorSample;\n\nstatic SensorSample g_sensor_data_buffer[SENSOR_DATA_BUFFER_SIZE];\nstatic uint8_t g_next_write_idx = 0;\nstatic bool g_buffer_full = false;\n\nvoid init_sensor_data_buffer() {\n    memset(g_sensor_data_buffer, 0, sizeof(g_sensor_data_buffer));\n    g_next_write_idx = 0;\n    g_buffer_full = false;\n}\n\nvoid add_sensor_sample(uint16_t value, uint32_t timestamp, uint8_t flags) {\n    g_sensor_data_buffer[g_next_write_idx].value = value;\n    g_sensor_data_buffer[g_next_write_idx].timestamp_ms = timestamp;\n    g_sensor_data_buffer[g_next_write_idx].status_flags = flags;\n\n    g_next_write_idx = (g_next_write_idx + 1) % SENSOR_DATA_BUFFER_SIZE;\n    if (g_next_write_idx == 0) {\n        g_buffer_full = true;\n    }\n}\n\nvoid update_historical_sensor_value_vulnerable(int32_t sample_offset_from_last, uint16_t new_value) {\n    if (!g_buffer_full && g_next_write_idx == 0) {\n        return;\n    }\n\n    int32_t last_sample_idx = (g_next_write_idx == 0 && g_buffer_full) ?\n                              (SENSOR_DATA_BUFFER_SIZE - 1) :\n                              (g_next_write_idx - 1);\n\n    int32_t target_idx = last_sample_idx - sample_offset_from_last;\n\n    g_sensor_data_buffer[target_idx].value = new_value;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n\n// Represents a single firmware image entry within an update manifest\nstruct FirmwareImageEntry {\n    uint32_t image_id;\n    uint32_t image_size;\n    uint8_t  checksum[16];\n    char     version_string[32]; // Fixed-size string buffer for version\n};\n\n// Represents the header of a firmware update manifest packet\nstruct UpdateManifestHeader {\n    uint16_t manifest_version;\n    uint16_t num_firmware_images;   // Declared number of images - used for allocation\n    uint32_t total_payload_bytes;   // Total bytes of ALL image entries in the payload - used for loop bounds\n};\n\nclass FirmwareUpdaterVulnerable {\npublic:\n    FirmwareUpdaterVulnerable() : update_tasks(nullptr), num_tasks_allocated(0) {}\n\n    ~FirmwareUpdaterVulnerable() {\n        clearTasks();\n    }\n\n    void clearTasks() {\n        if (update_tasks) {\n            delete[] update_tasks;\n            update_tasks = nullptr;\n        }\n        num_tasks_allocated = 0;\n    }\n\n    // Processes a raw firmware update manifest packet\n    // Vulnerability: The allocation size (num_firmware_images) can be mismatched\n    // with the actual number of entries processed (derived from total_payload_bytes).\n    bool parseManifestVulnerable(const uint8_t* raw_manifest, size_t manifest_len) {\n        if (!raw_manifest || manifest_len < sizeof(UpdateManifestHeader)) {\n            return false;\n        }\n\n        const UpdateManifestHeader* header = reinterpret_cast<const UpdateManifestHeader*>(raw_manifest);\n\n        // Basic check: Ensure the reported total_payload_bytes does not exceed the actual packet length.\n        if (manifest_len < sizeof(UpdateManifestHeader) + header->total_payload_bytes) {\n            return false;\n        }\n\n        clearTasks(); // Clear any existing tasks before processing new manifest\n\n        // The heap allocation size is determined by 'num_firmware_images'.\n        // An attacker can set this to a small value (e.g., 1).\n        num_tasks_allocated = header->num_firmware_images;\n\n        // To avoid allocating 0 elements if num_firmware_images is 0, or excessive size.\n        static const uint16_t MAX_ALLOWED_IMAGES = 200;\n        if (num_tasks_allocated == 0 || num_tasks_allocated > MAX_ALLOWED_IMAGES) {\n            return false;\n        }\n\n        // Check for potential integer overflow in allocation size (though less likely with uint16_t and small struct size)\n        if ((size_t)num_tasks_allocated > (SIZE_MAX / sizeof(FirmwareImageEntry))) {\n            return false;\n        }\n\n        update_tasks = new (std::nothrow) FirmwareImageEntry[num_tasks_allocated];\n        if (!update_tasks) {\n            return false;\n        }\n\n        const uint8_t* current_payload_ptr = raw_manifest + sizeof(UpdateManifestHeader);\n        size_t bytes_processed_in_payload = 0;\n        uint16_t entry_count = 0;\n\n        // Vulnerability: The loop continues as long as there is enough data for another\n        // FirmwareImageEntry within the 'total_payload_bytes'.\n        // It DOES NOT check if 'entry_count' exceeds 'num_tasks_allocated'.\n        // An attacker can set header->num_firmware_images to a small number (e.g., 1) to get a small allocation,\n        // but craft header->total_payload_bytes to contain data for many more entries (e.g., 10 entries).\n        // This leads to 'update_tasks[entry_count]' writing past the allocated heap buffer.\n        while (bytes_processed_in_payload + sizeof(FirmwareImageEntry) <= header->total_payload_bytes) {\n\n            const FirmwareImageEntry* incoming_entry = reinterpret_cast<const FirmwareImageEntry*>(current_payload_ptr + bytes_processed_in_payload);\n            \n            // Heap-based Buffer Overflow occurs here if entry_count >= num_tasks_allocated\n            update_tasks[entry_count].image_id = incoming_entry->image_id;\n            update_tasks[entry_count].image_size = incoming_entry->image_size;\n            memcpy(update_tasks[entry_count].checksum, incoming_entry->checksum, sizeof(incoming_entry->checksum));\n            \n            // strncpy with null-termination is safe for individual string field, but the overall array access is vulnerable.\n            strncpy(update_tasks[entry_count].version_string, incoming_entry->version_string, sizeof(incoming_entry->version_string) - 1);\n            update_tasks[entry_count].version_string[sizeof(incoming_entry->version_string) - 1] = '\\0';\n\n            bytes_processed_in_payload += sizeof(FirmwareImageEntry);\n            entry_count++;\n        }\n\n        // Note: Even if total_payload_bytes is checked against manifest_len, and `num_firmware_images` is checked for max,\n        // the mismatch between `num_firmware_images` (allocation size) and `total_payload_bytes` (loop iteration count) remains.\n\n        return true;\n    }\n\n    const FirmwareImageEntry* getUpdateTasks() const { return update_tasks; }\n    uint16_t getNumTasksAllocated() const { return num_tasks_allocated; }\n\nprivate:\n    FirmwareImageEntry* update_tasks;\n    uint16_t            num_tasks_allocated;\n};\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRY_DESCRIPTION_LEN 256\n#define INITIAL_LOG_BUFFER_CAPACITY 1024\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t desc_length; \n} LogEntryHeader;\n\nclass DiagnosticLogBufferVulnerable {\npublic:\n    DiagnosticLogBufferVulnerable() :\n        log_buffer(nullptr),\n        current_data_size(0),\n        allocated_capacity(0)\n    {\n        log_buffer = (uint8_t*)malloc(INITIAL_LOG_BUFFER_CAPACITY);\n        if (log_buffer) {\n            allocated_capacity = INITIAL_LOG_BUFFER_CAPACITY;\n        }\n    }\n\n    ~DiagnosticLogBufferVulnerable() {\n        if (log_buffer) {\n            free(log_buffer);\n            log_buffer = nullptr;\n        }\n    }\n\n    bool addLogEntryVulnerable(uint32_t timestamp, uint16_t event_id, const char* description) {\n        if (!description) {\n            return false;\n        }\n\n        size_t actual_desc_len = strlen(description);\n        if (actual_desc_len >= MAX_LOG_ENTRY_DESCRIPTION_LEN) {\n            return false;\n        }\n\n        size_t required_entry_data_space = sizeof(LogEntryHeader) + actual_desc_len;\n\n        if (current_data_size + required_entry_data_space > allocated_capacity) {\n            size_t new_capacity = allocated_capacity * 2;\n            if (new_capacity <= allocated_capacity || new_capacity < current_data_size + required_entry_data_space) {\n                new_capacity = current_data_size + required_entry_data_space + INITIAL_LOG_BUFFER_CAPACITY;\n            }\n            \n            uint8_t* new_log_buffer = (uint8_t*)realloc(log_buffer, new_capacity);\n            if (!new_log_buffer) {\n                return false;\n            }\n            log_buffer = new_log_buffer;\n            allocated_capacity = new_capacity;\n        }\n\n        LogEntryHeader header;\n        header.timestamp = timestamp;\n        header.event_id = event_id;\n        header.desc_length = (uint16_t)actual_desc_len;\n\n        memcpy(log_buffer + current_data_size, &header, sizeof(LogEntryHeader));\n        \n        uint8_t* desc_dest_ptr = log_buffer + current_data_size + sizeof(LogEntryHeader);\n\n        for (size_t i = 0; i <= actual_desc_len; ++i) {\n            desc_dest_ptr[i] = description[i];\n        }\n\n        current_data_size += sizeof(LogEntryHeader) + actual_desc_len + 1;\n\n        return true;\n    }\n\n    const uint8_t* getRawLogBuffer() const {\n        return log_buffer;\n    n}\n\n    size_t getContainedDataSize() const {\n        return current_data_size;\n    }\n\nprivate:\n    uint8_t* log_buffer;\n    size_t current_data_size;\n    size_t allocated_capacity;\n};\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define SENSOR_DATA_BUFFER_SIZE 256 \n#define MAX_SENSOR_LOG_ENTRIES 10   \n\ntypedef struct {\n    uint16_t sensor_id;\n    uint16_t timestamp;\n    uint16_t data_length;      \n    uint16_t data_offset;     \n} SensorLogEntry;\n\nstatic uint8_t g_sensorDataBuffer[SENSOR_DATA_BUFFER_SIZE];\nstatic SensorLogEntry g_sensorLogEntries[MAX_SENSOR_LOG_ENTRIES];\n\nstatic uint8_t g_nextLogEntryIndex = 0;\nstatic uint16_t g_sensorDataWriteOffset = 0;\n\nvoid initSensorLogger() {\n    memset(g_sensorDataBuffer, 0, sizeof(g_sensorDataBuffer));\n    memset(g_sensorLogEntries, 0, sizeof(g_sensorLogEntries));\n    g_nextLogEntryIndex = 0;\n    g_sensorDataWriteOffset = 0;\n}\n\nint logSensorData(uint16_t sensor_id, uint16_t timestamp, const uint8_t* raw_data, uint16_t raw_data_len) {\n    if (raw_data == NULL || raw_data_len == 0) {\n        return -1; \n    }\n    \n    if (g_nextLogEntryIndex >= MAX_SENSOR_LOG_ENTRIES) {\n        return -2; \n    }\n\n    if (raw_data_len > SENSOR_DATA_BUFFER_SIZE) {\n        return -3; \n    }\n\n    g_sensorLogEntries[g_nextLogEntryIndex].sensor_id = sensor_id;\n    g_sensorLogEntries[g_nextLogEntryIndex].timestamp = timestamp;\n    g_sensorLogEntries[g_nextLogEntryIndex].data_length = raw_data_len;\n    g_sensorLogEntries[g_nextLogEntryIndex].data_offset = g_sensorDataWriteOffset;\n\n    memcpy(g_sensorDataBuffer + g_sensorDataWriteOffset, raw_data, raw_data_len);\n\n    g_sensorDataWriteOffset += raw_data_len;\n\n    g_nextLogEntryIndex++;\n\n    return 0; \n}\n\nvoid simulateSensorDataReception(uint16_t id, uint16_t ts, const uint8_t* data, uint16_t len) {\n    logSensorData(id, ts, data, len);\n}\n\nuint8_t getLoggedSensorDataByte(uint16_t index) {\n    if (index < SENSOR_DATA_BUFFER_SIZE) {\n        return g_sensorDataBuffer[index];\n    }\n    return 0xFF;\n}\n\nconst SensorLogEntry* getSensorLogEntry(uint8_t index) {\n    if (index < g_nextLogEntryIndex) {\n        return &g_sensorLogEntries[index];\n    }\n    return NULL;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct {\n    uint32_t id;\n    uint8_t data[8];\n    uint8_t dlc;\n} CanMessage;\n\ntypedef void (*RoutineHandler)(CanMessage* msg);\n\n#define MAX_DIAG_ROUTINES 10\n\nstatic RoutineHandler g_diagRoutineHandlers[MAX_DIAG_ROUTINES];\n\nvoid handleRoutineA(CanMessage* msg) {\n}\n\nvoid handleRoutineB(CanMessage* msg) {\n}\n\nvoid handleRoutineC(CanMessage* msg) {\n}\n\nvoid logDiagnosticEvent(const char* event) {\n}\n\nvoid initializeRoutineHandlers_vulnerable() {\n    g_diagRoutineHandlers[0] = handleRoutineA;\n    g_diagRoutineHandlers[1] = handleRoutineB;\n    g_diagRoutineHandlers[2] = handleRoutineC;\n    for (int i = 3; i < MAX_DIAG_ROUTINES; ++i) {\n        g_diagRoutineHandlers[i] = NULL;\n    }\n}\n\nCanMessage receiveDiagnosticCANMessage_vulnerable() {\n    CanMessage msg;\n    msg.id = 0x7E0;\n    msg.dlc = 8;\n    msg.data[0] = 10;\n    msg.data[1] = 0;\n    msg.data[2] = 0;\n    msg.data[3] = 0;\n    msg.data[4] = 0;\n    msg.data[5] = 0;\n    msg.data[6] = 0;\n    msg.data[7] = 0;\n    return msg;\n}\n\nvoid processDiagnosticCANMessage_vulnerable() {\n    CanMessage rx_msg = receiveDiagnosticCANMessage_vulnerable();\n\n    if (rx_msg.id == 0x7E0 && rx_msg.dlc >= 2) {\n        uint16_t routine_id = (uint16_t)rx_msg.data[0] | ((uint16_t)rx_msg.data[1] << 8);\n\n        if (g_diagRoutineHandlers[routine_id] != NULL) {\n            g_diagRoutineHandlers[routine_id](&rx_msg);\n        } else {\n            logDiagnosticEvent(\"Unknown or uninitialized diagnostic routine requested.\");\n        }\n    }\n}\n\nvoid diagnosticServiceMain_vulnerable() {\n    initializeRoutineHandlers_vulnerable();\n    processDiagnosticCANMessage_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_PARAM_LOG_ENTRIES_FIXED 64\n#define PARAM_ENTRY_SIZE_BYTES_FIXED 16\n\nstatic uint8_t g_param_log_buffer_fixed[MAX_PARAM_LOG_ENTRIES_FIXED * PARAM_ENTRY_SIZE_BYTES_FIXED];\nstatic int32_t g_current_active_log_idx_fixed = 0;\nstatic uint32_t g_total_logged_entries_fixed = 0;\n\nvoid init_param_logger_fixed() {\n    memset(g_param_log_buffer_fixed, 0, sizeof(g_param_log_buffer_fixed));\n    g_current_active_log_idx_fixed = 0;\n    g_total_logged_entries_fixed = 0;\n}\n\nbool log_param_entry_fixed(const uint8_t* param_data) {\n    if (g_total_logged_entries_fixed >= MAX_PARAM_LOG_ENTRIES_FIXED) {\n        return false;\n    }\n    memcpy(g_param_log_buffer_fixed + (g_total_logged_entries_fixed * PARAM_ENTRY_SIZE_BYTES_FIXED), param_data, PARAM_ENTRY_SIZE_BYTES_FIXED);\n    g_total_logged_entries_fixed++;\n    return true;\n}\n\nvoid set_active_log_entry_fixed(int32_t offset_from_current) {\n    int32_t new_idx = g_current_active_log_idx_fixed + offset_from_current;\n    if (new_idx < 0) {\n        new_idx = 0;\n    }\n    if (g_total_logged_entries_fixed > 0 && new_idx >= (int32_t)g_total_logged_entries_fixed) {\n        new_idx = g_total_logged_entries_fixed - 1;\n    } else if (g_total_logged_entries_fixed == 0 && new_idx > 0) {\n        new_idx = 0;\n    }\n    g_current_active_log_idx_fixed = new_idx;\n}\n\nvoid mark_active_entry_status_byte_fixed(uint8_t status_value, uint8_t relative_byte_offset) {\n    if (relative_byte_offset >= PARAM_ENTRY_SIZE_BYTES_FIXED) {\n        return;\n    }\n    int32_t byte_target_idx = (g_current_active_log_idx_fixed * PARAM_ENTRY_SIZE_BYTES_FIXED) + relative_byte_offset;\n    if (byte_target_idx < 0 || byte_target_idx >= (int32_t)(MAX_PARAM_LOG_ENTRIES_FIXED * PARAM_ENTRY_SIZE_BYTES_FIXED)) {\n        return;\n    }\n    g_param_log_buffer_fixed[byte_target_idx] = status_value;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#define MAX_DRIVER_PROFILES 3\n\ntypedef struct {\n    uint16_t throttle_response_map_id;\n    uint8_t  regen_braking_level;\n} PowertrainSettings;\n\ntypedef struct {\n    uint16_t damping_force_preset_id;\n    uint16_t ride_height_offset_mm;\n} SuspensionSettings;\n\ntypedef struct {\n    uint8_t  steering_assist_level;\n    bool     lane_keeping_active;\n} SteeringSettings;\n\ntypedef struct {\n    PowertrainSettings* powertrain_config;\n    SuspensionSettings* suspension_config;\n    SteeringSettings*   steering_config;\n} DriverProfileConfig;\n\nstatic PowertrainSettings g_powertrainProfiles_fixed[MAX_DRIVER_PROFILES];\nstatic SuspensionSettings g_suspensionProfiles_fixed[MAX_DRIVER_PROFILES];\nstatic SteeringSettings   g_steeringProfiles_fixed[MAX_DRIVER_PROFILES];\n\nstatic DriverProfileConfig g_driverProfileConfigs_fixed[MAX_DRIVER_PROFILES];\n\nstatic uint8_t g_activeProfileIndex_fixed;\n\nvoid automotiveLog_fixed(const char* message) {}\n\nuint8_t receiveProfileSelectionCommand_fixed() {\n    return MAX_DRIVER_PROFILES;\n}\n\nvoid initializeVehicleProfiles_fixed() {\n    g_powertrainProfiles_fixed[0] = (PowertrainSettings){100, 3};\n    g_powertrainProfiles_fixed[1] = (PowertrainSettings){200, 1};\n    g_powertrainProfiles_fixed[2] = (PowertrainSettings){150, 2};\n\n    g_suspensionProfiles_fixed[0] = (SuspensionSettings){1, 0};\n    g_suspensionProfiles_fixed[1] = (SuspensionSettings){3, -10};\n    g_suspensionProfiles_fixed[2] = (SuspensionSettings){2, 5};\n\n    g_steeringProfiles_fixed[0] = (SteeringSettings){1, true};\n    g_steeringProfiles_fixed[1] = (SteeringSettings){3, false};\n    g_steeringProfiles_fixed[2] = (SteeringSettings){2, true};\n\n    for (uint8_t i = 0; i < MAX_DRIVER_PROFILES; ++i) {\n        g_driverProfileConfigs_fixed[i].powertrain_config = &g_powertrainProfiles_fixed[i];\n        g_driverProfileConfigs_fixed[i].suspension_config = &g_suspensionProfiles_fixed[i];\n        g_driverProfileConfigs_fixed[i].steering_config = &g_steeringProfiles_fixed[i];\n    }\n\n    g_activeProfileIndex_fixed = 0;\n}\n\nvoid setActiveDriverProfile_fixed(uint8_t profile_id) {\n    if (profile_id < MAX_DRIVER_PROFILES) {\n        g_activeProfileIndex_fixed = profile_id;\n        automotiveLog_fixed(\"Driver profile selected successfully.\");\n    } else {\n        automotiveLog_fixed(\"Invalid driver profile ID received. Keeping current profile.\");\n    }\n}\n\nvoid applyActiveProfileToECUs_fixed() {\n    PowertrainSettings* current_pt_config = g_driverProfileConfigs_fixed[g_activeProfileIndex_fixed].powertrain_config;\n    SuspensionSettings* current_susp_config = g_driverProfileConfigs_fixed[g_activeProfileIndex_fixed].suspension_config;\n    SteeringSettings*   current_steer_config = g_driverProfileConfigs_fixed[g_activeProfileIndex_fixed].steering_config;\n\n    if (current_pt_config != NULL) {\n        automotiveLog_fixed(\"Powertrain settings applied.\");\n    }\n    if (current_susp_config != NULL) {\n        automotiveLog_fixed(\"Suspension settings applied.\");\n    }\n    if (current_steer_config != NULL) {\n        automotiveLog_fixed(\"Steering settings applied.\");\n    }\n    automotiveLog_fixed(\"Active profile settings applied to ECUs (fixed).\");\n}\n\nvoid vehicleMainLoop_fixed() {\n    initializeVehicleProfiles_fixed();\n\n    uint8_t cmd_profile_id = receiveProfileSelectionCommand_fixed();\n    setActiveDriverProfile_fixed(cmd_profile_id);\n\n    applyActiveProfileToECUs_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_FEATURES 10\n#define CONFIG_STORAGE_BUFFER_SIZE (MAX_CONFIG_FEATURES * sizeof(FeatureConfig))\n\n// Structure for a single feature configuration, representing a calibration or setting.\ntypedef struct {\n    uint16_t feature_id;\n    uint8_t  config_value;\n} FeatureConfig;\n\n// Global buffer to store parsed feature configurations for an ECU module.\nstatic FeatureConfig g_featureConfigStorage[MAX_CONFIG_FEATURES];\nstatic uint8_t g_currentFeatureCount = 0;\n\n// Initializes the feature configuration storage.\nvoid initFeatureConfigStorage() {\n    memset(g_featureConfigStorage, 0, CONFIG_STORAGE_BUFFER_SIZE);\n    g_currentFeatureCount = 0;\n}\n\n// Parses a received configuration data block from an external source (e.g., diagnostic tool or bootloader).\n// The format of 'raw_data_block' is expected to be:\n// [uint8_t magic_byte] [uint8_t num_entries] [entry1_id_high] [entry1_id_low] [entry1_value] ...\n// Each entry is 3 bytes (2 for ID, 1 for value).\nint parseConfigDataBlock(const uint8_t* raw_data_block, uint16_t block_len) {\n    if (raw_data_block == NULL || block_len < 2) {\n        return -1; // Invalid input: NULL block or too short for header\n    }\n\n    if (raw_data_block[0] != 0xAC) {\n        return -2; // Invalid magic byte: Not a recognized config block\n    }\n\n    uint8_t num_entries_from_stream = raw_data_block[1];\n\n    // FIX: Add bounds check for the number of entries against the internal buffer capacity.\n    // This prevents an attacker from causing an out-of-bounds write by specifying too many entries.\n    if (num_entries_from_stream > MAX_CONFIG_FEATURES) {\n        return -5; // Too many entries for internal storage capacity\n    }\n    \n    // Calculate the total expected length based on the number of entries declared in the stream.\n    uint16_t expected_data_len = 2 + (num_entries_from_stream * (sizeof(uint16_t) + sizeof(uint8_t)));\n\n    // Check if the provided 'block_len' is sufficient for the declared number of entries.\n    if (expected_data_len > block_len) {\n        return -3; // Data block too short for declared entries\n    }\n\n    uint16_t current_read_offset = 2; // Start reading data after magic byte and num_entries\n\n    // Reset current feature count for new block processing\n    g_currentFeatureCount = 0;\n\n    // Iterate through each declared entry in the data block.\n    // The loop bound 'num_entries_from_stream' is now guaranteed not to exceed MAX_CONFIG_FEATURES.\n    for (uint8_t i = 0; i < num_entries_from_stream; ++i) {\n        // Ensure there's enough remaining data in the block for the current entry.\n        if (current_read_offset + sizeof(FeatureConfig) > block_len) {\n            return -4; // Malformed data: insufficient bytes for an entry\n        }\n\n        // Read feature_id (uint16_t, assumed big-endian for simplicity).\n        g_featureConfigStorage[i].feature_id = ((uint16_t)raw_data_block[current_read_offset] << 8) | raw_data_block[current_read_offset + 1];\n        current_read_offset += 2;\n\n        // Read config_value (uint8_t).\n        g_featureConfigStorage[i].config_value = raw_data_block[current_read_offset];\n        current_read_offset += 1;\n\n        g_currentFeatureCount++; // Increment count of processed features\n    }\n\n    return 0; // Successfully processed the configuration block\n}\n\n// Example usage in an automotive context\nvoid loadVehicleSpecificConfigs(const uint8_t* config_stream, uint16_t stream_size) {\n    initFeatureConfigStorage();\n    parseConfigDataBlock(config_stream, stream_size);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_CONFIG_HISTORY 10\n\ntypedef struct {\n    uint32_t configId;\n    int32_t  paramA;\n    uint16_t paramB;\n} SensorConfiguration;\n\nstatic SensorConfiguration g_activeConfig;\nstatic SensorConfiguration g_configHistory[MAX_CONFIG_HISTORY];\nstatic int16_t g_latestConfigIdx = -1;\nstatic uint16_t g_numStoredConfigs = 0;\n\nvoid logSystemEvent(const char* msg) {\n    (void)msg;\n}\n\nvoid initializeConfigurationSystem() {\n    g_activeConfig = (SensorConfiguration){1001, 500, 100};\n    g_latestConfigIdx = 0;\n    g_configHistory[g_latestConfigIdx] = g_activeConfig;\n    g_numStoredConfigs = 1;\n    logSystemEvent(\"Configuration system initialized with default settings.\");\n}\n\nvoid applyAndStoreNewConfiguration(uint32_t newConfigId, int32_t newParamA, uint16_t newParamB) {\n    g_activeConfig = (SensorConfiguration){newConfigId, newParamA, newParamB};\n\n    g_latestConfigIdx = (g_latestConfigIdx + 1);\n    if (g_latestConfigIdx >= MAX_CONFIG_HISTORY) {\n        g_latestConfigIdx = 0;\n    }\n    g_configHistory[g_latestConfigIdx] = g_activeConfig;\n\n    if (g_numStoredConfigs < MAX_CONFIG_HISTORY) {\n        g_numStoredConfigs++;\n    }\n    logSystemEvent(\"New configuration applied and stored in history.\");\n}\n\nvoid revertConfigurationFromHistory_Vulnerable(int16_t steps_back) {\n    if (g_numStoredConfigs == 0) {\n        logSystemEvent(\"Cannot revert: Configuration history is empty.\");\n        return;\n    }\n\n    int16_t raw_target_idx = g_latestConfigIdx - steps_back;\n\n    g_activeConfig = g_configHistory[raw_target_idx];\n    logSystemEvent(\"Configuration reverted from history.\");\n}\n\nvoid vehicleConfigManager_Vulnerable() {\n    initializeConfigurationSystem();\n\n    applyAndStoreNewConfiguration(1002, 600, 110);\n\n    revertConfigurationFromHistory_Vulnerable(2);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE 256\n#define MAX_INCOMING_PACKET_SIZE 512\n\nstatic uint8_t g_telemetryStorageBuffer[MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE];\nstatic uint16_t g_currentStorageWriteOffset = 0;\n\nvoid initTelemetryStorage() {\n    memset(g_telemetryStorageBuffer, 0, MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE);\n    g_currentStorageWriteOffset = 0;\n}\n\nint processTelemetryDataPacket(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len == 0 || packet_len > MAX_INCOMING_PACKET_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_packet_read_offset = 0;\n\n    while (current_packet_read_offset < packet_len) {\n        if (current_packet_read_offset + 2 > packet_len) {\n            return -1;\n        }\n\n        uint8_t record_id = packet_data[current_packet_read_offset];\n        uint8_t data_len = packet_data[current_packet_read_offset + 1];\n\n        if (current_packet_read_offset + 2 + data_len > packet_len) {\n            return -1;\n        }\n\n        uint16_t record_storage_size = 2 + data_len;\n\n        if (g_currentStorageWriteOffset + record_storage_size > MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE) {\n            return -2;\n        }\n\n        const uint8_t* record_data_ptr = packet_data + current_packet_read_offset + 2;\n\n        g_telemetryStorageBuffer[g_currentStorageWriteOffset] = record_id;\n        g_currentStorageWriteOffset++;\n\n        g_telemetryStorageBuffer[g_currentStorageWriteOffset] = data_len;\n        g_currentStorageWriteOffset++;\n\n        for (int i = 0; i < data_len; ++i) {\n            g_telemetryStorageBuffer[g_currentStorageWriteOffset + i] = record_data_ptr[i];\n        }\n        g_currentStorageWriteOffset += data_len;\n\n        current_packet_read_offset += 2 + data_len;\n    }\n\n    return 0;\n}\n\nvoid systemReceiveTelemetry(const uint8_t* raw_telemetry_packet, uint16_t packet_size) {\n    if (g_currentStorageWriteOffset == 0) {\n        initTelemetryStorage();\n    }\n    processTelemetryDataPacket(raw_telemetry_packet, packet_size);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define CONFIG_TABLE_SIZE 256 \n\nstatic uint8_t g_configTable[CONFIG_TABLE_SIZE];\n\ntypedef enum {\n    CFG_TYPE_UINT8 = 0,\n    CFG_TYPE_UINT16,\n    CFG_TYPE_UINT32,\n    CFG_TYPE_MAX\n} ConfigDataType;\n\nstatic uint8_t getConfigTypeSize(ConfigDataType type) {\n    switch (type) {\n        case CFG_TYPE_UINT8:  return 1;\n        case CFG_TYPE_UINT16: return 2;\n        case CFG_TYPE_UINT32: return 4;\n        default: return 0;\n    }\n}\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t offset;\n    ConfigDataType data_type;\n} ConfigEntryDescriptor;\n\nstatic const ConfigEntryDescriptor g_cfgDescriptors[] = {\n    {0x1001, 0, CFG_TYPE_UINT16},\n    {0x1002, 2, CFG_TYPE_UINT8},\n    {0x1003, 3, CFG_TYPE_UINT32},\n    {0x1004, 7, CFG_TYPE_UINT16},\n    {0x2001, 250, CFG_TYPE_UINT8},\n    {0x2002, 255, CFG_TYPE_UINT16}\n};\n#define NUM_CFG_ENTRIES (sizeof(g_cfgDescriptors) / sizeof(ConfigEntryDescriptor))\n\nvoid initConfigTable() {\n    memset(g_configTable, 0, CONFIG_TABLE_SIZE);\n}\n\nint updateConfigEntryValue(uint16_t entry_id, const uint8_t* new_value_bytes, uint8_t max_value_len) {\n    if (new_value_bytes == NULL || max_value_len == 0) {\n        return -1;\n    }\n\n    const ConfigEntryDescriptor* target_entry = NULL;\n    for (int i = 0; i < NUM_CFG_ENTRIES; ++i) {\n        if (g_cfgDescriptors[i].entry_id == entry_id) {\n            target_entry = &g_cfgDescriptors[i];\n            break;\n        }\n    }\n\n    if (target_entry == NULL) {\n        return -2;\n    }\n\n    uint8_t required_size = getConfigTypeSize(target_entry->data_type);\n\n    if (required_size == 0 || required_size > max_value_len) {\n        return -3;\n    }\n\n    if ((uint32_t)target_entry->offset + required_size > CONFIG_TABLE_SIZE) {\n        return -5;\n    }\n\n    switch (target_entry->data_type) {\n        case CFG_TYPE_UINT8:\n            g_configTable[target_entry->offset] = new_value_bytes[0];\n            break;\n        case CFG_TYPE_UINT16:\n            *(uint16_t*)(g_configTable + target_entry->offset) = *(uint16_t*)new_value_bytes;\n            break;\n        case CFG_TYPE_UINT32:\n            *(uint32_t*)(g_configTable + target_entry->offset) = *(uint32_t*)new_value_bytes;\n            break;\n        default:\n            return -4;\n    }\n\n    return 0;\n}\n\nvoid simulateConfigUpdate(uint16_t id, const uint8_t* data, uint8_t len) {\n    updateConfigEntryValue(id, data, len);\n}\n\nuint8_t getConfigByte(uint16_t offset) {\n    if (offset < CONFIG_TABLE_SIZE) {\n        return g_configTable[offset];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DRIVER_MESSAGE_BUFFER_SIZE 32\n#define PROTOCOL_MAX_MESSAGE_LEN 64\n\nstatic char g_driverWelcomeMessage[DRIVER_MESSAGE_BUFFER_SIZE];\nstatic uint8_t g_messageLength = 0;\n\nvoid initDriverProfile() {\n    memset(g_driverWelcomeMessage, 0, sizeof(g_driverWelcomeMessage));\n    const char* default_msg = \"Hello Driver!\";\n    uint8_t default_len = strlen(default_msg);\n    if (default_len < DRIVER_MESSAGE_BUFFER_SIZE) {\n        strncpy(g_driverWelcomeMessage, default_msg, default_len);\n        g_driverWelcomeMessage[default_len] = '\\0';\n        g_messageLength = default_len;\n    } else {\n        strncpy(g_driverWelcomeMessage, default_msg, DRIVER_MESSAGE_BUFFER_SIZE - 1);\n        g_driverWelcomeMessage[DRIVER_MESSAGE_BUFFER_SIZE - 1] = '\\0';\n        g_messageLength = DRIVER_MESSAGE_BUFFER_SIZE - 1;\n    }\n}\n\nint updateDriverWelcomeMessage(const char* new_message, uint8_t message_len) {\n    if (new_message == NULL) {\n        return -1;\n    }\n\n    if (message_len > PROTOCOL_MAX_MESSAGE_LEN) {\n        return -2;\n    }\n\n    memcpy(g_driverWelcomeMessage, new_message, message_len);\n\n    if (message_len < DRIVER_MESSAGE_BUFFER_SIZE) {\n        g_driverWelcomeMessage[message_len] = '\\0';\n        g_messageLength = message_len;\n    } else {\n        g_driverWelcomeMessage[DRIVER_MESSAGE_BUFFER_SIZE - 1] = '\\0';\n        g_messageLength = DRIVER_MESSAGE_BUFFER_SIZE - 1;\n    }\n\n    return 0;\n}\n\nconst char* getDriverWelcomeMessage() {\n    return g_driverWelcomeMessage;\n}\n\nuint8_t getDriverWelcomeMessageLength() {\n    return g_messageLength;\n}\n\nvoid simulateCanMessage(const char* data, uint8_t len) {\n    updateDriverWelcomeMessage(data, len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct {\n    uint32_t id;\n    uint8_t data[8];\n    uint8_t dlc;\n} CanMessage;\n\ntypedef void (*RoutineHandler)(CanMessage* msg);\n\n#define MAX_DIAG_ROUTINES 10\n\nstatic RoutineHandler g_diagRoutineHandlers[MAX_DIAG_ROUTINES];\n\nvoid handleRoutineA(CanMessage* msg) {\n}\n\nvoid handleRoutineB(CanMessage* msg) {\n}\n\nvoid handleRoutineC(CanMessage* msg) {\n}\n\nvoid logDiagnosticEvent(const char* event) {\n}\n\nvoid initializeRoutineHandlers_fixed() {\n    g_diagRoutineHandlers[0] = handleRoutineA;\n    g_diagRoutineHandlers[1] = handleRoutineB;\n    g_diagRoutineHandlers[2] = handleRoutineC;\n    for (int i = 3; i < MAX_DIAG_ROUTINES; ++i) {\n        g_diagRoutineHandlers[i] = NULL;\n    }\n}\n\nCanMessage receiveDiagnosticCANMessage_fixed() {\n    CanMessage msg;\n    msg.id = 0x7E0;\n    msg.dlc = 8;\n    msg.data[0] = 10;\n    msg.data[1] = 0;\n    msg.data[2] = 0;\n    msg.data[3] = 0;\n    msg.data[4] = 0;\n    msg.data[5] = 0;\n    msg.data[6] = 0;\n    msg.data[7] = 0;\n    return msg;\n}\n\nvoid processDiagnosticCANMessage_fixed() {\n    CanMessage rx_msg = receiveDiagnosticCANMessage_fixed();\n\n    if (rx_msg.id == 0x7E0 && rx_msg.dlc >= 2) {\n        uint16_t routine_id = (uint16_t)rx_msg.data[0] | ((uint16_t)rx_msg.data[1] << 8);\n\n        if (routine_id < MAX_DIAG_ROUTINES) {\n            if (g_diagRoutineHandlers[routine_id] != NULL) {\n                g_diagRoutineHandlers[routine_id](&rx_msg);\n            } else {\n                logDiagnosticEvent(\"Requested diagnostic routine is uninitialized or not supported.\");\n            }\n        } else {\n            logDiagnosticEvent(\"Received diagnostic request with out-of-bounds Routine ID.\");\n        }\n    }\n}\n\nvoid diagnosticServiceMain_fixed() {\n    initializeRoutineHandlers_fixed();\n    processDiagnosticCANMessage_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CALIBRATION_BUFFER_SIZE_FIXED 256\n#define CALIBRATION_BLOCK_SIZE_FIXED 16\n\nstatic uint8_t g_calibration_data_fixed[CALIBRATION_BUFFER_SIZE_FIXED];\nstatic size_t g_num_active_blocks_fixed = 0;\n\nvoid init_calibration_store_fixed() {\n    memset(g_calibration_data_fixed, 0, CALIBRATION_BUFFER_SIZE_FIXED);\n    g_num_active_blocks_fixed = 0;\n}\n\nbool add_calibration_block_fixed(const uint8_t* block_data) {\n    if ((g_num_active_blocks_fixed + 1) * CALIBRATION_BLOCK_SIZE_FIXED > CALIBRATION_BUFFER_SIZE_FIXED) {\n        return false;\n    }\n    memcpy(g_calibration_data_fixed + (g_num_active_blocks_fixed * CALIBRATION_BLOCK_SIZE_FIXED), block_data, CALIBRATION_BLOCK_SIZE_FIXED);\n    g_num_active_blocks_fixed++;\n    return true;\n}\n\nvoid rearrange_calibration_block_fixed(uint16_t block_index_to_move, int16_t relative_shift_steps) {\n    if (block_index_to_move >= g_num_active_blocks_fixed) {\n        return; \n    }\n\n    int32_t source_byte_offset = (int32_t)block_index_to_move * CALIBRATION_BLOCK_SIZE_FIXED;\n    int32_t effective_destination_byte_offset = source_byte_offset + (relative_shift_steps * CALIBRATION_BLOCK_SIZE_FIXED);\n\n    // CRITICAL FIX: Validate the calculated destination offset to prevent buffer underwrite.\n    // Check if the destination starts before the buffer or extends beyond its valid size.\n    if (effective_destination_byte_offset < 0 || \n        (size_t)effective_destination_byte_offset + CALIBRATION_BLOCK_SIZE_FIXED > CALIBRATION_BUFFER_SIZE_FIXED) {\n        return; \n    }\n\n    uint8_t* source_ptr = g_calibration_data_fixed + source_byte_offset;\n    uint8_t* destination_ptr = g_calibration_data_fixed + effective_destination_byte_offset;\n\n    memmove(destination_ptr, source_ptr, CALIBRATION_BLOCK_SIZE_FIXED);\n}\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n\ntypedef struct {\n    uint16_t packet_id;\n    uint16_t num_sensor_readings; \n} TelemetryPacketHeader;\n\nclass TelemetryProcessor {\npublic:\n    TelemetryProcessor() : sensor_data_buffer(nullptr), buffer_size(0) {}\n\n    ~TelemetryProcessor() {\n        if (sensor_data_buffer) {\n            free(sensor_data_buffer);\n            sensor_data_buffer = nullptr;\n        }\n    }\n\n    bool processTelemetryPacketVulnerable(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(TelemetryPacketHeader)) {\n            return false;\n        }\n\n        const TelemetryPacketHeader* header = reinterpret_cast<const TelemetryPacketHeader*>(packet_data);\n        uint16_t num_readings = header->num_sensor_readings;\n\n        size_t expected_payload_size = (size_t)num_readings * sizeof(uint16_t);\n        size_t expected_total_packet_size = sizeof(TelemetryPacketHeader) + expected_payload_size;\n\n        if (packet_length < expected_total_packet_size) {\n            return false;\n        }\n\n        if (sensor_data_buffer) {\n            free(sensor_data_buffer);\n            sensor_data_buffer = nullptr;\n            buffer_size = 0;\n        }\n\n        sensor_data_buffer = (uint16_t*)malloc(expected_payload_size);\n        if (!sensor_data_buffer) {\n            return false;\n        }\n        buffer_size = expected_payload_size;\n\n        const uint8_t* data_ptr = packet_data + sizeof(TelemetryPacketHeader);\n\n        for (uint16_t i = 0; i <= num_readings; ++i) {\n            sensor_data_buffer[i] = (uint16_t)(data_ptr[i * 2] | (data_ptr[i * 2 + 1] << 8));\n        }\n\n        return true;\n    }\n\n    const uint16_t* getSensorData() const { return sensor_data_buffer; }\n    size_t getBufferSize() const { return buffer_size; }\n\nprivate:\n    uint16_t* sensor_data_buffer;\n    size_t buffer_size;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_TOTAL_PARAMETERS_FIXED 100\n#define MAX_SUBSYSTEMS_FIXED 3 \n\ntypedef uint16_t VehicleParameterValue_Fixed;\n\nstatic VehicleParameterValue_Fixed g_allVehicleParameters_fixed[MAX_TOTAL_PARAMETERS_FIXED];\n\nstatic uint8_t g_subsystemParameterOffsets_fixed[MAX_SUBSYSTEMS_FIXED];\nstatic uint8_t g_subsystemParameterCounts_fixed[MAX_SUBSYSTEMS_FIXED];\n\nvoid logVehicleStatus_fixed(const char* msg) {\n    printf(\"STATUS FIXED: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t subsystem_id;\n    uint8_t parameter_index;\n} StatusRequest_Fixed;\n\nStatusRequest_Fixed receiveStatusRequest_fixed() {\n    StatusRequest_Fixed req;\n    req.subsystem_id = 3; \n    req.parameter_index = 0; \n    return req;\n}\n\nvoid initializeVehicleParameters_fixed() {\n    for (int i = 0; i < MAX_TOTAL_PARAMETERS_FIXED; ++i) {\n        g_allVehicleParameters_fixed[i] = (uint16_t)(i * 100);\n    }\n\n    g_subsystemParameterOffsets_fixed[0] = 0;\n    g_subsystemParameterCounts_fixed[0] = 20;\n\n    g_subsystemParameterOffsets_fixed[1] = 20;\n    g_subsystemParameterCounts_fixed[1] = 15;\n\n    g_subsystemParameterOffsets_fixed[2] = 35;\n    g_subsystemParameterCounts_fixed[2] = 10;\n\n    logVehicleStatus_fixed(\"Vehicle parameters initialized.\");\n}\n\nuint16_t getVehicleParameter_fixed(uint8_t subsystem_id, uint8_t param_idx) {\n    logVehicleStatus_fixed(\"Attempting to get vehicle parameter.\");\n\n    if (subsystem_id >= MAX_SUBSYSTEMS_FIXED) {\n        logVehicleStatus_fixed(\"Error: Subsystem ID out of bounds. Request rejected.\");\n        return 0xFFFF;\n    }\n\n    uint8_t base_offset = g_subsystemParameterOffsets_fixed[subsystem_id];\n    uint8_t param_count = g_subsystemParameterCounts_fixed[subsystem_id];\n\n    if (param_idx < param_count) {\n        if (base_offset + param_idx < MAX_TOTAL_PARAMETERS_FIXED) {\n            uint16_t value = g_allVehicleParameters_fixed[base_offset + param_idx];\n            printf(\"STATUS FIXED: Read parameter [subsystem=%u, index=%u]: %u\\n\", subsystem_id, param_idx, value);\n            return value;\n        } else {\n            logVehicleStatus_fixed(\"Internal logic error: Calculated parameter index exceeds total capacity.\");\n            return 0xFFFF;\n        }\n    } else {\n        logVehicleStatus_fixed(\"Parameter index out of bounds for the specified subsystem.\");\n        return 0xFFFF;\n    }\n}\n\nvoid vehicleStatusModule_fixed_main() {\n    initializeVehicleParameters_fixed();\n    StatusRequest_Fixed req = receiveStatusRequest_fixed();\n    getVehicleParameter_fixed(req.subsystem_id, req.parameter_index);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_LIVE_DATA_GROUPS 5\n#define MAX_PARAMS_PER_GROUP 10\n#define DATA_VALUE_SIZE      2\n\ntypedef struct {\n    uint16_t param_id;\n    const char* name;\n    uint16_t min_val;\n    uint16_t max_val;\n} LiveDataParamDef;\n\ntypedef struct {\n    uint8_t group_id;\n    LiveDataParamDef* params_list;\n    uint8_t num_params;\n} LiveDataGroup;\n\nstatic LiveDataParamDef g_engineParams[5] = {\n    {0x0100, \"Engine RPM\", 0, 8000},\n    {0x0101, \"Vehicle Speed\", 0, 250},\n    {0x0102, \"Coolant Temp\", -40, 150},\n    {0x0103, \"Throttle Pos\", 0, 100},\n    {0x0104, \"Fuel Pressure\", 0, 1000}\n};\n\nstatic LiveDataParamDef g_brakesParams[3] = {\n    {0x0200, \"ABS Status\", 0, 1},\n    {0x0201, \"Brake Temp FL\", -20, 300},\n    {0x0202, \"Wheel Speed RL\", 0, 250}\n};\n\nstatic LiveDataParamDef g_transmissionParams[4] = {\n    {0x0300, \"Gear Pos\", 0, 6},\n    {0x0301, \"Trans Temp\", -30, 120},\n    {0x0302, \"Clutch Slip\", 0, 100},\n    {0x0303, \"Torque Conv Lock\", 0, 1}\n};\n\nstatic LiveDataGroup g_liveDataGroups_vulnerable[MAX_LIVE_DATA_GROUPS];\n\ntypedef struct {\n    uint8_t requested_group_id;\n    uint8_t requested_param_index;\n} DiagnosticLiveDataReaderRequest;\n\nDiagnosticLiveDataReaderRequest receiveDiagnosticLiveDataReaderRequest_vulnerable() {\n    DiagnosticLiveDataReaderRequest req;\n    req.requested_group_id = 0;\n    req.requested_param_index = 5;\n    return req;\n}\n\nvoid automotiveDiagLog_vulnerable(const char* msg) {\n}\n\nvoid initializeLiveDataSystem_vulnerable() {\n    for (uint8_t i = 0; i < MAX_LIVE_DATA_GROUPS; ++i) {\n        g_liveDataGroups_vulnerable[i].group_id = 0xFF;\n        g_liveDataGroups_vulnerable[i].params_list = NULL;\n        g_liveDataGroups_vulnerable[i].num_params = 0;\n    }\n\n    g_liveDataGroups_vulnerable[0].group_id = 0;\n    g_liveDataGroups_vulnerable[0].params_list = g_engineParams;\n    g_liveDataGroups_vulnerable[0].num_params = sizeof(g_engineParams) / sizeof(LiveDataParamDef);\n\n    g_liveDataGroups_vulnerable[1].group_id = 1;\n    g_liveDataGroups_vulnerable[1].params_list = g_brakesParams;\n    g_liveDataGroups_vulnerable[1].num_params = sizeof(g_brakesParams) / sizeof(LiveDataParamDef);\n\n    g_liveDataGroups_vulnerable[2].group_id = 2;\n    g_liveDataGroups_vulnerable[2].params_list = g_transmissionParams;\n    g_liveDataGroups_vulnerable[2].num_params = sizeof(g_transmissionParams) / sizeof(LiveDataParamDef);\n\n    automotiveDiagLog_vulnerable(\"Live Data System Initialized (Vulnerable).\");\n}\n\nvoid retrieveLiveDataParamDef_vulnerable() {\n    DiagnosticLiveDataReaderRequest req = receiveDiagnosticLiveDataReaderRequest_vulnerable();\n\n    if (req.requested_group_id < MAX_LIVE_DATA_GROUPS) {\n        LiveDataGroup* target_group = &g_liveDataGroups_vulnerable[req.requested_group_id];\n        LiveDataParamDef retrieved_def = target_group->params_list[req.requested_param_index];\n        automotiveDiagLog_vulnerable(\"Live data parameter definition retrieved (vulnerable).\");\n    } else {\n        automotiveDiagLog_vulnerable(\"Invalid live data group ID (vulnerable).\");\n    }\n}\n\nvoid diagnosticModuleMain_vulnerable() {\n    initializeLiveDataSystem_vulnerable();\n    retrieveLiveDataParamDef_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_SENSOR_DATA_ENTRIES 20\n#define MAX_CALIBRATION_CURVE_POINTS 15\n#define MAX_EVENT_LOG_ENTRIES 10\n\ntypedef struct {\n    uint16_t value_raw;\n    int16_t  value_processed;\n    uint8_t  sensor_status;\n} SensorDataType;\n\ntypedef struct {\n    float    coeff_a;\n    float    coeff_b;\n    uint32_t revision_id;\n} CalibrationCurvePointType;\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp;\n    uint8_t  severity_level;\n} EventLogEntryType;\n\nstatic SensorDataType g_sensorDataTable_vulnerable[MAX_SENSOR_DATA_ENTRIES];\nstatic CalibrationCurvePointType g_calibrationCurveTable_vulnerable[MAX_CALIBRATION_CURVE_POINTS];\nstatic EventLogEntryType g_eventLogTable_vulnerable[MAX_EVENT_LOG_ENTRIES];\n\ntypedef enum {\n    DATA_TYPE_SENSOR = 0,\n    DATA_TYPE_CALIBRATION,\n    DATA_TYPE_EVENT_LOG,\n    DATA_TYPE_COUNT\n} DataTypeId;\n\ntypedef struct {\n    DataTypeId data_type_id;\n    uint8_t    index;\n    uint32_t   update_value;\n} DataUpdateCommand;\n\nvoid automotiveSystemLog_vulnerable(const char* message) {\n}\n\nDataUpdateCommand receiveDataUpdateCommand_vulnerable() {\n    DataUpdateCommand cmd;\n    cmd.data_type_id = DATA_TYPE_CALIBRATION;\n    cmd.index = MAX_CALIBRATION_CURVE_POINTS; \n    cmd.update_value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeDataTables_vulnerable() {\n    for (int i = 0; i < MAX_SENSOR_DATA_ENTRIES; ++i) {\n        g_sensorDataTable_vulnerable[i] = (SensorDataType){0, 0, 0};\n    }\n    for (int i = 0; i < MAX_CALIBRATION_CURVE_POINTS; ++i) {\n        g_calibrationCurveTable_vulnerable[i] = (CalibrationCurvePointType){0.0f, 0.0f, 0};\n    }\n    for (int i = 0; i < MAX_EVENT_LOG_ENTRIES; ++i) {\n        g_eventLogTable_vulnerable[i] = (EventLogEntryType){0, 0, 0};\n    }\n}\n\nvoid processDataUpdateCommand_vulnerable() {\n    DataUpdateCommand cmd = receiveDataUpdateCommand_vulnerable();\n\n    switch (cmd.data_type_id) {\n        case DATA_TYPE_SENSOR:\n            g_sensorDataTable_vulnerable[cmd.index].sensor_status = (uint8_t)cmd.update_value;\n            automotiveSystemLog_vulnerable(\"Sensor data update attempted.\");\n            break;\n        case DATA_TYPE_CALIBRATION:\n            g_calibrationCurveTable_vulnerable[cmd.index].coeff_a = *(float*)&cmd.update_value;\n            automotiveSystemLog_vulnerable(\"Calibration curve point update attempted.\");\n            break;\n        case DATA_TYPE_EVENT_LOG:\n            g_eventLogTable_vulnerable[cmd.index].event_id = (uint16_t)cmd.update_value;\n            automotiveSystemLog_vulnerable(\"Event log entry update attempted.\");\n            break;\n        default:\n            automotiveSystemLog_vulnerable(\"Received command with invalid data type ID.\");\n            break;\n    }\n}\n\nvoid vehicleControlUnitMain_vulnerable() {\n    initializeDataTables_vulnerable();\n    processDataUpdateCommand_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_DATA_BUF_SIZE 32\n#define MAX_COMMAND_LEN 16\n\nstatic uint8_t g_diag_data_buffer[DIAG_DATA_BUF_SIZE];\nstatic uint8_t g_current_diag_data_len = 0;\n\nvoid diag_init_buffer() {\n    memset(g_diag_data_buffer, 0, DIAG_DATA_BUF_SIZE);\n    g_current_diag_data_len = 0;\n}\n\nbool diag_load_data(const uint8_t* data, uint8_t len) {\n    if (len > DIAG_DATA_BUF_SIZE) {\n        return false;\n    }\n    memcpy(g_diag_data_buffer, data, len);\n    g_current_diag_data_len = len;\n    return true;\n}\n\nvoid process_diagnostic_command_vulnerable(uint8_t command_id, int16_t arg1, uint8_t arg2_value) {\n    if (command_id == 0x05) { \n        int32_t target_index = (int32_t)g_current_diag_data_len - arg1;\n\n        g_diag_data_buffer[target_index] = arg2_value;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define CONFIG_TABLE_SIZE 256 \n\nstatic uint8_t g_configTable[CONFIG_TABLE_SIZE];\n\ntypedef enum {\n    CFG_TYPE_UINT8 = 0,\n    CFG_TYPE_UINT16,\n    CFG_TYPE_UINT32,\n    CFG_TYPE_MAX\n} ConfigDataType;\n\nstatic uint8_t getConfigTypeSize(ConfigDataType type) {\n    switch (type) {\n        case CFG_TYPE_UINT8:  return 1;\n        case CFG_TYPE_UINT16: return 2;\n        case CFG_TYPE_UINT32: return 4;\n        default: return 0;\n    }\n}\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t offset;\n    ConfigDataType data_type;\n} ConfigEntryDescriptor;\n\nstatic const ConfigEntryDescriptor g_cfgDescriptors[] = {\n    {0x1001, 0, CFG_TYPE_UINT16},\n    {0x1002, 2, CFG_TYPE_UINT8},\n    {0x1003, 3, CFG_TYPE_UINT32},\n    {0x1004, 7, CFG_TYPE_UINT16},\n    {0x2001, 200, CFG_TYPE_UINT8},\n    {0x2002, 250, CFG_TYPE_UINT16}\n};\n#define NUM_CFG_ENTRIES (sizeof(g_cfgDescriptors) / sizeof(ConfigEntryDescriptor))\n\nvoid initConfigTable() {\n    memset(g_configTable, 0, CONFIG_TABLE_SIZE);\n}\n\nint updateConfigEntryValue(uint16_t entry_id, const uint8_t* new_value_bytes, uint8_t max_value_len) {\n    if (new_value_bytes == NULL || max_value_len == 0) {\n        return -1;\n    }\n\n    const ConfigEntryDescriptor* target_entry = NULL;\n    for (int i = 0; i < NUM_CFG_ENTRIES; ++i) {\n        if (g_cfgDescriptors[i].entry_id == entry_id) {\n            target_entry = &g_cfgDescriptors[i];\n            break;\n        }\n    }\n\n    if (target_entry == NULL) {\n        return -2;\n    }\n\n    uint8_t required_size = getConfigTypeSize(target_entry->data_type);\n\n    if (required_size == 0 || required_size > max_value_len) {\n        return -3;\n    }\n\n    switch (target_entry->data_type) {\n        case CFG_TYPE_UINT8:\n            g_configTable[target_entry->offset] = new_value_bytes[0];\n            break;\n        case CFG_TYPE_UINT16:\n            // Vulnerability: If target_entry->offset + required_size (2) exceeds CONFIG_TABLE_SIZE,\n            // this direct pointer cast will write out of bounds. For example, if target_entry->offset is 255,\n            // and data_type is CFG_TYPE_UINT16, it attempts to write to g_configTable[255] and g_configTable[256],\n            // causing an overflow. The static definition g_cfgDescriptors includes such a case (0x2002).\n            *(uint16_t*)(g_configTable + target_entry->offset) = *(uint16_t*)new_value_bytes;\n            break;\n        case CFG_TYPE_UINT32:\n            *(uint32_t*)(g_configTable + target_entry->offset) = *(uint32_t*)new_value_bytes;\n            break;\n        default:\n            return -4;\n    }\n\n    return 0;\n}\n\nvoid simulateConfigUpdate(uint16_t id, const uint8_t* data, uint8_t len) {\n    updateConfigEntryValue(id, data, len);\n}\n\nuint8_t getConfigByte(uint16_t offset) {\n    if (offset < CONFIG_TABLE_SIZE) {\n        return g_configTable[offset];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define CALIBRATION_DATA_SIZE 1024\n#define MAX_CALIBRATION_PATCH_LEN 64\n\nstatic uint8_t g_vehicleCalibrationData[CALIBRATION_DATA_SIZE];\n\nvoid initCalibrationData() {\n    memset(g_vehicleCalibrationData, 0xAA, CALIBRATION_DATA_SIZE);\n}\n\nint applyCalibrationPatch(uint16_t offset, uint8_t length, const uint8_t* patch_data) {\n    if (patch_data == NULL || length == 0) {\n        return -1;\n    }\n\n    if (length > MAX_CALIBRATION_PATCH_LEN) {\n        return -2;\n    }\n\n    if (offset >= CALIBRATION_DATA_SIZE || (uint32_t)offset + length > CALIBRATION_DATA_SIZE) {\n        return -3;\n    }\n\n    for (uint8_t i = 0; i < length; ++i) {\n        g_vehicleCalibrationData[offset + i] = patch_data[i];\n    }\n\n    return 0;\n}\n\nvoid receiveCalibrationCommand(uint16_t offset, uint8_t length, const uint8_t* data) {\n    applyCalibrationPatch(offset, length, data);\n}\n\nuint8_t getCalibrationByte(uint16_t index) {\n    if (index < CALIBRATION_DATA_SIZE) {\n        return g_vehicleCalibrationData[index];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define TELEMETRY_BUFFER_CAPACITY 32\n#define TELEMETRY_PACKET_SIZE 16\n\ntypedef struct {\n    uint32_t timestamp;\n    uint8_t  packet_data[TELEMETRY_PACKET_SIZE - sizeof(uint32_t)];\n} TelemetryPacket;\n\nstatic TelemetryPacket g_telemetry_buffer_fixed[TELEMETRY_BUFFER_CAPACITY];\nstatic uint16_t g_telemetry_write_idx_fixed = 0;\nstatic uint16_t g_telemetry_count_fixed = 0;\n\nvoid init_telemetry_buffer_fixed() {\n    memset(g_telemetry_buffer_fixed, 0, sizeof(g_telemetry_buffer_fixed));\n    g_telemetry_write_idx_fixed = 0;\n    g_telemetry_count_fixed = 0;\n}\n\nvoid store_telemetry_packet_fixed(uint32_t timestamp, const uint8_t* data) {\n    if (data == NULL) return;\n\n    g_telemetry_buffer_fixed[g_telemetry_write_idx_fixed].timestamp = timestamp;\n    memcpy(g_telemetry_buffer_fixed[g_telemetry_write_idx_fixed].packet_data, data, TELEMETRY_PACKET_SIZE - sizeof(uint32_t));\n\n    g_telemetry_write_idx_fixed = (g_telemetry_write_idx_fixed + 1) % TELEMETRY_BUFFER_CAPACITY;\n    if (g_telemetry_count_fixed < TELEMETRY_BUFFER_CAPACITY) {\n        g_telemetry_count_fixed++;\n    }\n}\n\nvoid set_review_index_from_oldest_fixed(uint16_t num_steps_back) {\n    if (g_telemetry_count_fixed == 0) {\n        return;\n    }\n\n    uint16_t oldest_packet_logical_idx;\n    if (g_telemetry_count_fixed < TELEMETRY_BUFFER_CAPACITY) {\n        oldest_packet_logical_idx = 0;\n    } else {\n        oldest_packet_logical_idx = g_telemetry_write_idx_fixed;\n    }\n\n    int32_t target_idx_raw = (int32_t)oldest_packet_logical_idx - num_steps_back;\n\n    if (target_idx_raw < 0 || target_idx_raw >= TELEMETRY_BUFFER_CAPACITY || num_steps_back >= g_telemetry_count_fixed) {\n        return;\n    }\n    \n    g_telemetry_buffer_fixed[target_idx_raw].timestamp = 0xFFFFFFFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdio.h>\n#include <stdint.h>\n\n#define MAX_STORED_DTCS 5\n\ntypedef struct {\n    uint16_t dtcCode;\n    uint8_t  statusByte;\n    uint32_t eventCount;\n} DTC_Entry;\n\nstatic DTC_Entry g_storedDTCs[MAX_STORED_DTCS];\nstatic uint8_t g_currentDTC_count = 3;\n\nvoid logDiagnosticError(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t queryType;\n    uint8_t dtcIndex;\n} DiagnosticQuery;\n\nDiagnosticQuery receiveDiagnosticQuery_fixed() {\n    DiagnosticQuery query;\n    query.queryType = 0x01;\n    query.dtcIndex = 5;\n    return query;\n}\n\nvoid initializeDTCs_fixed() {\n    g_storedDTCs[0] = (DTC_Entry){0xC010, 0x01, 5};\n    g_storedDTCs[1] = (DTC_Entry){0xC021, 0x0A, 2};\n    g_storedDTCs[2] = (DTC_Entry){0xC035, 0x40, 1};\n}\n\nvoid processDTCQuery_fixed() {\n    DiagnosticQuery query = receiveDiagnosticQuery_fixed();\n\n    if (query.queryType == 0x01) {\n        if (query.dtcIndex < MAX_STORED_DTCS) {\n            DTC_Entry requestedDTC = g_storedDTCs[query.dtcIndex];\n        } else {\n            logDiagnosticError(\"Diagnostic DTC index out of bounds.\");\n        }\n    } else {\n        logDiagnosticError(\"Unsupported diagnostic query type.\");\n    n}\n}\n\nvoid main_fixed() {\n    initializeDTCs_fixed();\n    processDTCQuery_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DTC_METADATA_PROTO_MAX 60\n#define MAX_INTERNAL_DTC_METADATA_SIZE 30\n\n#define MAX_LOGGED_DTC_RECORDS 20\n#define DTC_RECORD_FIXED_SIZE (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t))\n#define SINGLE_DTC_RECORD_STORAGE_SIZE (DTC_RECORD_FIXED_SIZE + MAX_INTERNAL_DTC_METADATA_SIZE)\n#define DTC_LOG_BUFFER_TOTAL_SIZE (MAX_LOGGED_DTC_RECORDS * SINGLE_DTC_RECORD_STORAGE_SIZE)\n\ntypedef struct {\n    uint16_t dtc_id;\n    uint8_t status_byte;\n    uint8_t metadata_len;\n    uint8_t metadata[MAX_INTERNAL_DTC_METADATA_SIZE];\n} DTCRecord;\n\nstatic uint8_t g_dtc_log_buffer[DTC_LOG_BUFFER_TOTAL_SIZE];\nstatic uint16_t g_current_log_pos = 0;\n\nvoid initDTCLoggingSystem() {\n    memset(g_dtc_log_buffer, 0, DTC_LOG_BUFFER_TOTAL_SIZE);\n    g_current_log_pos = 0;\n}\n\nint addDTCRecord(uint16_t dtc_code, uint8_t status_byte, const uint8_t* metadata, uint8_t metadata_len) {\n    if (metadata == NULL && metadata_len > 0) {\n        return -1;\n    }\n\n    if (metadata_len > MAX_DTC_METADATA_PROTO_MAX) {\n        return -2;\n    }\n\n    DTCRecord temp_record;\n    temp_record.dtc_id = dtc_code;\n    temp_record.status_byte = status_byte;\n\n    uint8_t actual_copy_len = metadata_len;\n    if (actual_copy_len > MAX_INTERNAL_DTC_METADATA_SIZE) {\n        actual_copy_len = MAX_INTERNAL_DTC_METADATA_SIZE;\n    }\n    temp_record.metadata_len = actual_copy_len;\n    \n    memcpy(temp_record.metadata, metadata, actual_copy_len);\n\n    uint16_t record_effective_size = DTC_RECORD_FIXED_SIZE + temp_record.metadata_len;\n\n    if (g_current_log_pos + record_effective_size > DTC_LOG_BUFFER_TOTAL_SIZE) {\n        return -3;\n    }\n\n    memcpy(g_dtc_log_buffer + g_current_log_pos, &temp_record, record_effective_size);\n    g_current_log_pos += record_effective_size;\n\n    return 0;\n}\n\nuint16_t getDTCLogCount() {\n    if (SINGLE_DTC_RECORD_STORAGE_SIZE == 0) return 0;\n    return g_current_log_pos / SINGLE_DTC_RECORD_STORAGE_SIZE;\n}\n\nvoid simulateExternalDTCReport(uint16_t dtc, uint8_t status, const uint8_t* data, uint8_t data_len) {\n    addDTCRecord(dtc, status, data, data_len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define NUM_SUBSYSTEM_LOGGERS 3\n#define MAX_EVENTS_ENGINE 10\n#define MAX_EVENTS_TRANSMISSION 5\n#define MAX_EVENTS_ABS 8\n\ntypedef struct {\n    uint32_t event_id;\n    uint32_t timestamp;\n    uint8_t  severity;\n} DiagnosticEvent;\n\ntypedef enum {\n    SUBSYSTEM_ENGINE = 0,\n    SUBSYSTEM_TRANSMISSION,\n    SUBSYSTEM_ABS,\n    SUBSYSTEM_COUNT\n} SubsystemType;\n\nstatic DiagnosticEvent g_engineEvents[MAX_EVENTS_ENGINE];\nstatic DiagnosticEvent g_transmissionEvents[MAX_EVENTS_TRANSMISSION];\nstatic DiagnosticEvent g_absEvents[MAX_EVENTS_ABS];\n\ntypedef struct {\n    DiagnosticEvent* buffer;\n    uint8_t  current_count;\n    uint8_t  max_size;\n} SubsystemLoggerConfig;\n\nstatic SubsystemLoggerConfig g_subsystemLoggers[SUBSYSTEM_COUNT];\n\nvoid logSystemNotification(const char* msg) {\n}\n\nvoid initializeLoggers_fixed() {\n    g_subsystemLoggers[SUBSYSTEM_ENGINE].buffer = g_engineEvents;\n    g_subsystemLoggers[SUBSYSTEM_ENGINE].max_size = MAX_EVENTS_ENGINE;\n    g_subsystemLoggers[SUBSYSTEM_ENGINE].current_count = 0;\n\n    g_subsystemLoggers[SUBSYSTEM_TRANSMISSION].buffer = g_transmissionEvents;\n    g_subsystemLoggers[SUBSYSTEM_TRANSMISSION].max_size = MAX_EVENTS_TRANSMISSION;\n    g_subsystemLoggers[SUBSYSTEM_TRANSMISSION].current_count = 0;\n\n    g_subsystemLoggers[SUBSYSTEM_ABS].buffer = g_absEvents;\n    g_subsystemLoggers[SUBSYSTEM_ABS].max_size = MAX_EVENTS_ABS;\n    g_subsystemLoggers[SUBSYSTEM_ABS].current_count = 0;\n}\n\ntypedef struct {\n    SubsystemType subsystem;\n    DiagnosticEvent event_data;\n} NewDiagnosticEvent_fixed;\n\nvoid processAndLogDiagnosticEvent_fixed(NewDiagnosticEvent_fixed received_event) {\n    if (received_event.subsystem < SUBSYSTEM_COUNT) {\n        SubsystemLoggerConfig* logger = &g_subsystemLoggers[received_event.subsystem];\n\n        if (logger->current_count < logger->max_size) {\n            logger->buffer[logger->current_count] = received_event.event_data;\n            logger->current_count++;\n            logSystemNotification(\"Diagnostic event added to log.\");\n        } else {\n            logSystemNotification(\"Diagnostic event logger full for subsystem. Event dropped.\");\n        }\n    } else {\n        logSystemNotification(\"Received event for invalid subsystem type.\");\n    }\n}\n\nvoid diagnosticMonitorLoop_fixed() {\n    initializeLoggers_fixed();\n\n    for (int i = 0; i <= MAX_EVENTS_TRANSMISSION; ++i) {\n        NewDiagnosticEvent_fixed event_to_process;\n        event_to_process.subsystem = SUBSYSTEM_TRANSMISSION;\n        event_to_process.event_data.event_id = 0xA000 + i;\n        event_to_process.event_data.timestamp = 1000 + i;\n        event_to_process.event_data.severity = (uint8_t)(i % 4 + 1);\n        processAndLogDiagnosticEvent_fixed(event_to_process);\n    }\n\n    NewDiagnosticEvent_fixed engine_event;\n    engine_event.subsystem = SUBSYSTEM_ENGINE;\n    engine_event.event_data.event_id = 0xB001;\n    engine_event.event_data.timestamp = 2000;\n    engine_event.event_data.severity = 3;\n    processAndLogDiagnosticEvent_fixed(engine_event);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRY_DESCRIPTION_LEN 256\n#define INITIAL_LOG_BUFFER_CAPACITY 1024\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t desc_length;\n} LogEntryHeader;\n\nclass DiagnosticLogBufferFixed {\npublic:\n    DiagnosticLogBufferFixed() :\n        log_buffer(nullptr),\n        current_data_size(0),\n        allocated_capacity(0)\n    {\n        log_buffer = (uint8_t*)malloc(INITIAL_LOG_BUFFER_CAPACITY);\n        if (log_buffer) {\n            allocated_capacity = INITIAL_LOG_BUFFER_CAPACITY;\n        }\n    }\n\n    ~DiagnosticLogBufferFixed() {\n        if (log_buffer) {\n            free(log_buffer);\n            log_buffer = nullptr;\n        }\n    }\n\n    bool addLogEntryFixed(uint32_t timestamp, uint16_t event_id, const char* description) {\n        if (!description) {\n            return false;\n        }\n\n        size_t actual_desc_len = strlen(description);\n        if (actual_desc_len >= MAX_LOG_ENTRY_DESCRIPTION_LEN) {\n            return false;\n        }\n\n        size_t required_entry_data_space = sizeof(LogEntryHeader) + actual_desc_len + 1; \n\n        if (current_data_size + required_entry_data_space > allocated_capacity) {\n            size_t new_capacity = allocated_capacity * 2;\n            if (new_capacity <= allocated_capacity || new_capacity < current_data_size + required_entry_data_space) {\n                new_capacity = current_data_size + required_entry_data_space + INITIAL_LOG_BUFFER_CAPACITY;\n            }\n            \n            uint8_t* new_log_buffer = (uint8_t*)realloc(log_buffer, new_capacity);\n            if (!new_log_buffer) {\n                return false;\n            }\n            log_buffer = new_log_buffer;\n            allocated_capacity = new_capacity;\n        }\n\n        LogEntryHeader header;\n        header.timestamp = timestamp;\n        header.event_id = event_id;\n        header.desc_length = (uint16_t)actual_desc_len;\n\n        memcpy(log_buffer + current_data_size, &header, sizeof(LogEntryHeader));\n        \n        uint8_t* desc_dest_ptr = log_buffer + current_data_size + sizeof(LogEntryHeader);\n\n        for (size_t i = 0; i <= actual_desc_len; ++i) {\n            desc_dest_ptr[i] = description[i];\n        }\n\n        current_data_size += sizeof(LogEntryHeader) + actual_desc_len + 1;\n\n        return true;\n    }\n\n    const uint8_t* getRawLogBuffer() const {\n        return log_buffer;\n    }\n\n    size_t getContainedDataSize() const {\n        return current_data_size;\n    }\n\nprivate:\n    uint8_t* log_buffer;\n    size_t current_data_size;\n    size_t allocated_capacity;\n};\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_FILE_SIZE 2048\n#define ECU_CONFIG_BUFFER_SIZE 256\n#define PARAMETER_BLOCK_SIZE 64 // Fixed size for processing parameters within a section\n\n// Global buffer holding the raw configuration data for an ECU\nstatic uint8_t g_ecuConfigData[ECU_CONFIG_BUFFER_SIZE];\n\n// Simulates a header for a configuration section within the main config file\ntypedef struct {\n    uint16_t section_id;\n    uint16_t section_length; // Total length of this section including this header\n    uint16_t num_parameters;\n} ConfigSectionHeader;\n\n// Function to process a specific configuration section from a larger config stream\n// raw_config_stream: Pointer to the start of the configuration section\n// stream_available_len: Total bytes available from raw_config_stream until end of message/file\nint processEcuConfigSection(const uint8_t* raw_config_stream, uint16_t stream_available_len) {\n    if (raw_config_stream == NULL || stream_available_len < sizeof(ConfigSectionHeader)) {\n        return -1; // Invalid input\n    }\n\n    const ConfigSectionHeader* header = (const ConfigSectionHeader*)raw_config_stream;\n\n    // Validate overall section length from the header against the available stream length.\n    if (header->section_length > stream_available_len || header->section_length < sizeof(ConfigSectionHeader)) {\n        return -2; // Section length inconsistent with available stream or too small\n    }\n\n    uint16_t data_offset = sizeof(ConfigSectionHeader); // Offset to the actual data within the section\n\n    // Calculate the length of the raw parameter data block within this section.\n    // This length is determined by the total section length declared in the header.\n    uint16_t raw_parameter_data_len = header->section_length - data_offset;\n\n    // VULNERABILITY: Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-119)\n    // A temporary buffer 'temp_param_block' is declared with a fixed size (PARAMETER_BLOCK_SIZE).\n    // 'raw_parameter_data_len' is derived from the 'section_length' which is controllable via input.\n    // There is no check to ensure that 'raw_parameter_data_len' does not exceed the size of 'temp_param_block'.\n    // If 'raw_parameter_data_len' is larger than PARAMETER_BLOCK_SIZE (e.g., 100 > 64),\n    // the memcpy will write beyond the bounds of 'temp_param_block' on the stack, leading to an OOB write.\n    // The subsequent check against ECU_CONFIG_BUFFER_SIZE is for the global buffer, not for 'temp_param_block'.\n    uint8_t temp_param_block[PARAMETER_BLOCK_SIZE]; // Fixed-size buffer for processing a parameter block\n\n    if (raw_parameter_data_len > 0) {\n        memcpy(temp_param_block, raw_config_stream + data_offset, raw_parameter_data_len);\n\n        // Simulate further processing on temp_param_block, then copy to global ECU config.\n        // Note: The overflow of temp_param_block may already have occurred here.\n        if (raw_parameter_data_len <= ECU_CONFIG_BUFFER_SIZE) {\n             memcpy(g_ecuConfigData, temp_param_block, raw_parameter_data_len);\n        } else {\n            return -3; // Parameter data too large for global ECU_CONFIG_BUFFER_SIZE\n        }\n    }\n\n    // Simulate further processing based on parameters if needed\n    // e.g., iterating header->num_parameters to parse elements from temp_param_block\n\n    return 0; // Success\n}\n\n// Dummy function to simulate receiving a configuration update from a vehicle network.\n// In a real system, full_config_msg might contain multiple sections,\n// but for this example, it points directly to the section being processed.\nvoid receiveConfigUpdate(const uint8_t* full_config_msg, uint16_t msg_len) {\n    processEcuConfigSection(full_config_msg, msg_len);\n}\n\n// Function to retrieve a config value for testing/demonstration.\nuint8_t getEcuConfigByte(uint16_t index) {\n    if (index < ECU_CONFIG_BUFFER_SIZE) {\n        return g_ecuConfigData[index];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n#pragma pack(push, 1)\nstruct ModuleConfigHeader {\n    uint16_t module_id;\n    uint16_t payload_length; \n};\n#pragma pack(pop)\n\nconst size_t MAX_STORED_CONFIG_ENTRIES = 5; \nconst size_t ALLOC_SLOT_PAYLOAD_SIZE = 64; \n\nclass FirmwareConfigStorageVulnerable {\nprivate:\n    uint8_t* m_config_buffer;\n    size_t m_current_data_offset; \n    size_t m_total_allocated_capacity; \n    size_t m_num_stored_entries; \n\npublic:\n    FirmwareConfigStorageVulnerable() :\n        m_config_buffer(nullptr),\n        m_current_data_offset(0),\n        m_total_allocated_capacity(0),\n        m_num_stored_entries(0)\n    {\n        m_total_allocated_capacity = MAX_STORED_CONFIG_ENTRIES * (sizeof(ModuleConfigHeader) + ALLOC_SLOT_PAYLOAD_SIZE);\n        m_config_buffer = (uint8_t*)malloc(m_total_allocated_capacity);\n        if (!m_config_buffer) {\n            m_total_allocated_capacity = 0;\n        }\n    }\n\n    ~FirmwareConfigStorageVulnerable() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n        }\n    }\n\n    bool addModuleConfigEntryVulnerable(const uint8_t* raw_entry_data, size_t raw_entry_data_len) {\n        if (!m_config_buffer || !raw_entry_data || raw_entry_data_len < sizeof(ModuleConfigHeader)) {\n            return false;\n        }\n\n        const ModuleConfigHeader* header = reinterpret_cast<const ModuleConfigHeader*>(raw_entry_data);\n        uint16_t actual_payload_len = header->payload_length;\n\n        size_t incoming_entry_full_size = sizeof(ModuleConfigHeader) + actual_payload_len;\n\n        if (incoming_entry_full_size != raw_entry_data_len) {\n            return false;\n        }\n\n        if (m_num_stored_entries >= MAX_STORED_CONFIG_ENTRIES) {\n            return false;\n        }\n\n        size_t write_position_for_entry = m_num_stored_entries * (sizeof(ModuleConfigHeader) + ALLOC_SLOT_PAYLOAD_SIZE);\n\n        memcpy(m_config_buffer + write_position_for_entry, raw_entry_data, incoming_entry_full_size);\n\n        m_num_stored_entries++;\n\n        return true;\n    }\n\n    size_t getNumStoredEntries() const {\n        return m_num_stored_entries;\n    }\n\n    size_t getTotalAllocatedCapacity() const {\n        return m_total_allocated_capacity;\n    }\n\n    const uint8_t* getConfigBuffer() const {\n        return m_config_buffer;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_CONFIG_BANKS 4\n#define CONFIG_BANK_SIZE 128\n\nstatic uint8_t g_vehicleConfigMemory[NUM_CONFIG_BANKS][CONFIG_BANK_SIZE];\n\ntypedef struct {\n    uint8_t* current_bank_ptr;\n    uint8_t  bank_index;\n    uint16_t total_banks_size;\n} ConfigManagerContext;\n\nstatic ConfigManagerContext g_configManager;\n\nvoid initConfigManager() {\n    memset(g_vehicleConfigMemory, 0, sizeof(g_vehicleConfigMemory));\n    g_configManager.current_bank_ptr = NULL;\n    g_configManager.bank_index = 0xFF;\n    g_configManager.total_banks_size = NUM_CONFIG_BANKS * CONFIG_BANK_SIZE;\n}\n\nint selectConfigBank(uint8_t bank_idx) {\n    if (bank_idx >= NUM_CONFIG_BANKS) {\n        g_configManager.current_bank_ptr = NULL;\n        g_configManager.bank_index = 0xFF;\n        return -1;\n    }\n    g_configManager.current_bank_ptr = g_vehicleConfigMemory[bank_idx];\n    g_configManager.bank_index = bank_idx;\n    return 0;\n}\n\nint updateConfigParameter(const uint8_t* raw_msg, uint16_t msg_len) {\n    if (g_configManager.current_bank_ptr == NULL || g_configManager.bank_index == 0xFF) {\n        return -1;\n    }\n\n    if (raw_msg == NULL || msg_len < 2) {\n        return -2;\n    }\n\n    uint8_t offset_in_bank = raw_msg[0];\n    uint8_t data_len = raw_msg[1];\n\n    if (data_len == 0) {\n        return 0;\n    }\n\n    if (msg_len < (2 + data_len)) {\n        return -3;\n    }\n\n    if ((uint16_t)offset_in_bank + data_len > CONFIG_BANK_SIZE) {\n        return -4;\n    }\n\n    const uint8_t* data_source = raw_msg + 2;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_configManager.current_bank_ptr[offset_in_bank + i] = data_source[i];\n    }\n\n    return 0;\n}\n\nvoid handleIncomingConfigMessage(uint8_t bank_id, const uint8_t* data, uint16_t len) {\n    if (selectConfigBank(bank_id) == 0) {\n        updateConfigParameter(data, len);\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define LOG_BUFFER_SIZE 32\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t speed_kph;\n    uint16_t rpm;\n    uint8_t gear;\n    uint8_t brake_status;\n} VehicleState;\n\nstatic VehicleState g_state_log_buffer[LOG_BUFFER_SIZE];\nstatic int16_t g_latest_entry_idx = -1;\nstatic uint16_t g_active_entry_count = 0;\n\nvoid init_vehicle_state_logger_fixed() {\n    memset(g_state_log_buffer, 0, sizeof(g_state_log_buffer));\n    g_latest_entry_idx = -1;\n    g_active_entry_count = 0;\n}\n\nvoid add_vehicle_state_entry_fixed(uint32_t ts, uint16_t speed, uint16_t rpm, uint8_t gear_val, uint8_t brake_stat) {\n    g_latest_entry_idx = (g_latest_entry_idx + 1) % LOG_BUFFER_SIZE;\n    if (g_active_entry_count < LOG_BUFFER_SIZE) {\n        g_active_entry_count++;\n    }\n\n    g_state_log_buffer[g_latest_entry_idx].timestamp_ms = ts;\n    g_state_log_buffer[g_latest_entry_idx].speed_kph = speed;\n    g_state_log_buffer[g_latest_entry_idx].rpm = rpm;\n    g_state_log_buffer[g_latest_entry_idx].gear = gear_val;\n    g_state_log_buffer[g_latest_entry_idx].brake_status = brake_stat;\n}\n\nvoid update_historic_brake_status_fixed(uint16_t relative_past_steps, uint8_t new_brake_status) {\n    if (g_active_entry_count == 0) {\n        return;\n    }\n\n    if (relative_past_steps >= g_active_entry_count) {\n        return;\n    }\n\n    int16_t target_idx_calc = g_latest_entry_idx - relative_past_steps;\n    int16_t target_idx = (target_idx_calc % LOG_BUFFER_SIZE + LOG_BUFFER_SIZE) % LOG_BUFFER_SIZE;\n\n    g_state_log_buffer[target_idx].brake_status = new_brake_status;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_SENSOR_TYPES 5\n\ntypedef enum {\n    SENSOR_TYPE_RADAR = 0,\n    SENSOR_TYPE_LIDAR,\n    SENSOR_TYPE_CAMERA,\n    SENSOR_TYPE_ULTRASONIC,\n    SENSOR_TYPE_IMU,\n    SENSOR_TYPE_COUNT\n} SensorTypeID;\n\ntypedef struct {\n    float gain_factor;\n    int32_t offset_value;\n    uint16_t processing_flags;\n    char description[32];\n} SensorCalibrationProfile;\n\nstatic SensorCalibrationProfile g_sensorCalibrationProfiles[MAX_SENSOR_TYPES];\n\nvoid logSensorProcessingEvent(const char* msg) {\n    fprintf(stderr, \"SENSOR_PROC_LOG: %s\\n\", msg);\n}\n\nvoid applySensorCalibration(float* raw_value, SensorCalibrationProfile profile) {\n    *raw_value = (*raw_value * profile.gain_factor) + profile.offset_value;\n    logSensorProcessingEvent(\"Applied calibration.\");\n}\n\ntypedef struct {\n    uint8_t sensor_type_id;\n    uint32_t timestamp_ms;\n    float raw_measurement;\n    uint8_t data_integrity_checksum;\n} SensorDataPacket;\n\nSensorDataPacket receiveSensorDataPacket_Fixed() {\n    SensorDataPacket packet;\n    packet.sensor_type_id = SENSOR_TYPE_COUNT;\n    packet.timestamp_ms = 1678886400;\n    packet.raw_measurement = 25.5f;\n    packet.data_integrity_checksum = 0xAF;\n    return packet;\n}\n\nvoid initializeSensorCalibrationProfiles_Fixed() {\n    g_sensorCalibrationProfiles[SENSOR_TYPE_RADAR] = (SensorCalibrationProfile){1.0f, 0, 0x01, \"Radar Cal\"};\n    g_sensorCalibrationProfiles[SENSOR_TYPE_LIDAR] = (SensorCalibrationProfile){0.95f, 5, 0x02, \"Lidar Cal\"};\n    g_sensorCalibrationProfiles[SENSOR_TYPE_CAMERA] = (SensorCalibrationProfile){1.05f, -2, 0x04, \"Camera Cal\"};\n    g_sensorCalibrationProfiles[SENSOR_TYPE_ULTRASONIC] = (SensorCalibrationProfile){1.1f, 10, 0x08, \"Ultrasonic Cal\"};\n    g_sensorCalibrationProfiles[SENSOR_TYPE_IMU] = (SensorCalibrationProfile){0.9f, -1, 0x10, \"IMU Cal\"};\n    logSensorProcessingEvent(\"Sensor calibration profiles initialized (Fixed).\");\n}\n\nvoid processIncomingSensorData_Fixed() {\n    SensorDataPacket packet = receiveSensorDataPacket_Fixed();\n\n    if (packet.sensor_type_id < SENSOR_TYPE_COUNT) {\n        SensorCalibrationProfile current_profile = g_sensorCalibrationProfiles[packet.sensor_type_id];\n\n        float processed_value = packet.raw_measurement;\n        applySensorCalibration(&processed_value, current_profile);\n        logSensorProcessingEvent(\"Sensor data processed successfully (Fixed).\");\n    } else {\n        logSensorProcessingEvent(\"Invalid sensor type ID received. Ignoring data packet (Fixed).\");\n    }\n}\n\nvoid sensorModuleMain_Fixed() {\n    initializeSensorCalibrationProfiles_Fixed();\n    processIncomingSensorData_Fixed();\n}\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_FEATURES 10\n#define CONFIG_STORAGE_BUFFER_SIZE (MAX_CONFIG_FEATURES * sizeof(FeatureConfig))\n\n// Structure for a single feature configuration, representing a calibration or setting.\ntypedef struct {\n    uint16_t feature_id;\n    uint8_t  config_value;\n} FeatureConfig;\n\n// Global buffer to store parsed feature configurations for an ECU module.\nstatic FeatureConfig g_featureConfigStorage[MAX_CONFIG_FEATURES];\nstatic uint8_t g_currentFeatureCount = 0;\n\n// Initializes the feature configuration storage.\nvoid initFeatureConfigStorage() {\n    memset(g_featureConfigStorage, 0, CONFIG_STORAGE_BUFFER_SIZE);\n    g_currentFeatureCount = 0;\n}\n\n// Parses a received configuration data block from an external source (e.g., diagnostic tool or bootloader).\n// The format of 'raw_data_block' is expected to be:\n// [uint8_t magic_byte] [uint8_t num_entries] [entry1_id_high] [entry1_id_low] [entry1_value] ...\n// Each entry is 3 bytes (2 for ID, 1 for value).\nint parseConfigDataBlock(const uint8_t* raw_data_block, uint16_t block_len) {\n    if (raw_data_block == NULL || block_len < 2) {\n        return -1; // Invalid input: NULL block or too short for header\n    }\n\n    if (raw_data_block[0] != 0xAC) {\n        return -2; // Invalid magic byte: Not a recognized config block\n    }\n\n    uint8_t num_entries_from_stream = raw_data_block[1];\n    \n    // Calculate the total expected length based on the number of entries declared in the stream.\n    uint16_t expected_data_len = 2 + (num_entries_from_stream * (sizeof(uint16_t) + sizeof(uint8_t)));\n\n    // Check if the provided 'block_len' is sufficient for the declared number of entries.\n    // VULNERABILITY: This check ensures the input buffer is large enough, but does NOT\n    // ensure that 'num_entries_from_stream' itself does not exceed 'MAX_CONFIG_FEATURES'.\n    // If num_entries_from_stream is > MAX_CONFIG_FEATURES, the loop below will write out of bounds.\n    if (expected_data_len > block_len) {\n        return -3; // Data block too short for declared entries\n    }\n\n    uint16_t current_read_offset = 2; // Start reading data after magic byte and num_entries\n\n    // Reset current feature count for new block processing\n    g_currentFeatureCount = 0;\n\n    // Iterate through each declared entry in the data block.\n    for (uint8_t i = 0; i < num_entries_from_stream; ++i) {\n        // Ensure there's enough remaining data in the block for the current entry.\n        if (current_read_offset + sizeof(FeatureConfig) > block_len) {\n            return -4; // Malformed data: insufficient bytes for an entry\n        }\n\n        // Read feature_id (uint16_t, assumed big-endian for simplicity).\n        // VULNERABILITY HERE: If 'i' exceeds MAX_CONFIG_FEATURES, this access is out-of-bounds.\n        g_featureConfigStorage[i].feature_id = ((uint16_t)raw_data_block[current_read_offset] << 8) | raw_data_block[current_read_offset + 1];\n        current_read_offset += 2;\n\n        // Read config_value (uint8_t).\n        g_featureConfigStorage[i].config_value = raw_data_block[current_read_offset];\n        current_read_offset += 1;\n\n        g_currentFeatureCount++; // Increment count of processed features\n    }\n\n    return 0; // Successfully processed the configuration block\n}\n\n// Example usage in an automotive context\nvoid loadVehicleSpecificConfigs(const uint8_t* config_stream, uint16_t stream_size) {\n    initFeatureConfigStorage();\n    parseConfigDataBlock(config_stream, stream_size);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct UpdateChunkHeader {\n    uint32_t chunk_id;\n    uint32_t offset;    \n    uint32_t length;    \n    uint32_t crc;\n};\n#pragma pack(pop)\n\nclass ECUFlashUpdaterFixed {\npublic:\n    ECUFlashUpdaterFixed(size_t staging_buffer_capacity) {\n        if (staging_buffer_capacity > 0) {\n            m_staging_buffer = (uint8_t*)malloc(staging_buffer_capacity);\n            if (m_staging_buffer) {\n                m_capacity = staging_buffer_capacity;\n            } else {\n                m_capacity = 0;\n            }\n        } else {\n            m_capacity = 0;\n            m_staging_buffer = nullptr;\n        }\n    }\n\n    ~ECUFlashUpdaterFixed() {\n        if (m_staging_buffer) {\n            free(m_staging_buffer);\n        }\n    }\n\n    bool processUpdateChunkFixed(const uint8_t* raw_chunk_packet, size_t packet_len) {\n        if (!m_staging_buffer || !raw_chunk_packet || packet_len < sizeof(UpdateChunkHeader)) {\n            return false;\n        }\n\n        const UpdateChunkHeader* header = reinterpret_cast<const UpdateChunkHeader*>(raw_chunk_packet);\n\n        const uint8_t* chunk_data_payload = raw_chunk_packet + sizeof(UpdateChunkHeader);\n        size_t actual_chunk_data_len = packet_len - sizeof(UpdateChunkHeader);\n\n        if (actual_chunk_data_len != static_cast<size_t>(header->length)) {\n            return false;\n        }\n\n        size_t start_pos = static_cast<size_t>(header->offset);\n        size_t write_length = static_cast<size_t>(header->length);\n\n        if (start_pos > std::numeric_limits<size_t>::max() - write_length) {\n            return false; \n        }\n\n        size_t end_pos = start_pos + write_length;\n\n        if (end_pos > m_capacity) {\n            return false;\n        }\n\n        uint8_t* dest_ptr = m_staging_buffer + start_pos;\n\n        memcpy(dest_ptr, chunk_data_payload, write_length);\n\n        return true;\n    }\n\n    size_t getCapacity() const { return m_capacity; }\n    const uint8_t* getStagingBuffer() const { return m_staging_buffer; }\n\nprivate:\n    uint8_t* m_staging_buffer;\n    size_t m_capacity;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_SENSOR_TYPES_FIXED 3\n#define CALIBRATION_POINTS_PER_SENSOR_FIXED 10\n\ntypedef struct {\n    int16_t value;\n    uint32_t timestamp;\n} CalibrationPoint_Fixed;\n\nstatic CalibrationPoint_Fixed g_sensorCalibrationData_fixed[MAX_SENSOR_TYPES_FIXED][CALIBRATION_POINTS_PER_SENSOR_FIXED];\n\nvoid logSystemError_fixed(const char* msg) {\n    fprintf(stderr, \"FIXED_LOG_ERROR: %s\\n\", msg);\n}\n\nvoid logSystemInfo_fixed(const char* msg) {\n    fprintf(stdout, \"FIXED_LOG_INFO: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t sensor_type_id;\n    uint8_t start_offset_in_segment;\n    uint8_t num_points_to_update;\n    CalibrationPoint_Fixed data_payload[CALIBRATION_POINTS_PER_SENSOR_FIXED]; \n} SensorCalCommand_Fixed;\n\nSensorCalCommand_Fixed getIncomingSensorCalCommand_fixed() {\n    SensorCalCommand_Fixed cmd;\n    cmd.sensor_type_id = 1; \n    cmd.start_offset_in_segment = CALIBRATION_POINTS_PER_SENSOR_FIXED - 2; \n    cmd.num_points_to_update = 3; \n\n    for (int i = 0; i < cmd.num_points_to_update; ++i) {\n        cmd.data_payload[i].value = 1000 + i;\n        cmd.data_payload[i].timestamp = 0x5000 + i;\n    }\n    logSystemInfo_fixed(\"Simulated incoming sensor calibration command with potential OOB write.\");\n    return cmd;\n}\n\nvoid initializeCalibrationData_fixed() {\n    for (uint8_t i = 0; i < MAX_SENSOR_TYPES_FIXED; ++i) {\n        for (uint8_t j = 0; j < CALIBRATION_POINTS_PER_SENSOR_FIXED; ++j) {\n            g_sensorCalibrationData_fixed[i][j].value = 0;\n            g_sensorCalibrationData_fixed[i][j].timestamp = 0;\n        }\n    }\n    logSystemInfo_fixed(\"Sensor calibration data initialized.\");\n}\n\nvoid processSensorCalibrationUpdate_fixed() {\n    SensorCalCommand_Fixed cmd = getIncomingSensorCalCommand_fixed();\n\n    if (cmd.sensor_type_id >= MAX_SENSOR_TYPES_FIXED) {\n        logSystemError_fixed(\"Invalid sensor type ID received (fixed).\");\n        return;\n    }\n\n    if (cmd.start_offset_in_segment < CALIBRATION_POINTS_PER_SENSOR_FIXED &&\n        (uint16_t)cmd.start_offset_in_segment + cmd.num_points_to_update <= CALIBRATION_POINTS_PER_SENSOR_FIXED) {\n        \n        logSystemInfo_fixed(\"Processing sensor calibration update (fixed).\");\n        for (uint8_t i = 0; i < cmd.num_points_to_update; ++i) {\n            g_sensorCalibrationData_fixed[cmd.sensor_type_id][cmd.start_offset_in_segment + i] = cmd.data_payload[i];\n        }\n    } else {\n        logSystemError_fixed(\"Calibration update range out of bounds for sensor type. Ignoring update (fixed).\");\n    }\n}\n\nvoid automotiveSensorModule_fixed_main() {\n    initializeCalibrationData_fixed();\n    processSensorCalibrationUpdate_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_DTC_STORAGE_CAPACITY_FIXED 10\n\ntypedef struct {\n    uint32_t dtc_code;\n    uint8_t  status_byte;\n    uint16_t occurrence_count;\n    bool     is_active;\n} DTC_Entry_Fixed;\n\nstatic DTC_Entry_Fixed g_dtc_entries_fixed[MAX_DTC_STORAGE_CAPACITY_FIXED];\nstatic uint8_t g_current_active_dtc_count_fixed = 0;\n\nvoid logDiagnosticMessage_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t requested_dtc_index;\n} DTC_QueryRequest_Fixed;\n\nDTC_QueryRequest_Fixed receiveDTCQuery_fixed() {\n    DTC_QueryRequest_Fixed query;\n    query.requested_dtc_index = g_current_active_dtc_count_fixed;\n    return query;\n}\n\nvoid initializeDTCStorage_fixed() {\n    for (uint8_t i = 0; i < MAX_DTC_STORAGE_CAPACITY_FIXED; ++i) {\n        g_dtc_entries_fixed[i] = (DTC_Entry_Fixed){0, 0, 0, false};\n    }\n\n    g_dtc_entries_fixed[0] = (DTC_Entry_Fixed){0xF001, 0x0A, 1, true};\n    g_dtc_entries_fixed[1] = (DTC_Entry_Fixed){0xF002, 0x0B, 3, true};\n    g_dtc_entries_fixed[2] = (DTC_Entry_Fixed){0xF003, 0x0C, 1, true};\n    g_current_active_dtc_count_fixed = 3;\n\n    logDiagnosticMessage_fixed(\"DTC storage initialized (fixed).\");\n}\n\nvoid addDTC_fixed(uint32_t code, uint8_t status) {\n    if (g_current_active_dtc_count_fixed < MAX_DTC_STORAGE_CAPACITY_FIXED) {\n        DTC_Entry_Fixed new_dtc = {code, status, 1, true};\n        g_dtc_entries_fixed[g_current_active_dtc_count_fixed] = new_dtc;\n        g_current_active_dtc_count_fixed++;\n        logDiagnosticMessage_fixed(\"DTC added.\");\n    } else {\n        logDiagnosticMessage_fixed(\"DTC storage full.\");\n    }\n}\n\nDTC_Entry_Fixed getDTCDetails_fixed(uint8_t index) {\n    if (index < g_current_active_dtc_count_fixed) {\n        logDiagnosticMessage_fixed(\"Accessing DTC entry (fixed).\");\n        return g_dtc_entries_fixed[index];\n    } else {\n        logDiagnosticMessage_fixed(\"DTC query index out of active DTC count bounds (fixed).\");\n        return (DTC_Entry_Fixed){0, 0, 0, false};\n    }\n}\n\nvoid diagnosticModuleMain_fixed() {\n    initializeDTCStorage_fixed();\n    addDTC_fixed(0xF004, 0x0D);\n    \n    DTC_QueryRequest_Fixed query = receiveDTCQuery_fixed();\n    DTC_Entry_Fixed retrieved_dtc = getDTCDetails_fixed(query.requested_dtc_index);\n    logDiagnosticMessage_fixed(\"DTC query processed (fixed).\");\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_BLOCK_SIZE 512\n\n#define MAX_VEHICLE_NAME_LEN 32\n#define MAX_LICENSE_PLATE_LEN 16\n\n#define CONFIG_ID_VEHICLE_NAME 0x01\n#define CONFIG_ID_LICENSE_PLATE 0x02\n#define CONFIG_ID_SPEED_LIMIT_ENABLED 0x03\n#define CONFIG_ID_MAX_SPEED_VALUE 0x04\n\nstatic char g_vehicleName[MAX_VEHICLE_NAME_LEN + 1];\nstatic char g_licensePlate[MAX_LICENSE_PLATE_LEN + 1];\nstatic uint8_t g_speedLimitEnabled = 0;\nstatic uint16_t g_maxSpeedValue = 0;\n\ntypedef struct {\n    uint8_t param_id;\n    uint8_t param_len;\n} ConfigParamHeader;\n\nvoid resetVehicleConfig() {\n    memset(g_vehicleName, 0, sizeof(g_vehicleName));\n    memset(g_licensePlate, 0, sizeof(g_licensePlate));\n    g_speedLimitEnabled = 0;\n    g_maxSpeedValue = 0;\n    strcpy(g_vehicleName, \"DEFAULT_VEHICLE\");\n    strcpy(g_licensePlate, \"DEFAULT_PLATE\");\n}\n\nint applyVehicleConfiguration(const uint8_t* config_data_block, uint16_t block_len) {\n    if (config_data_block == NULL || block_len == 0 || block_len > MAX_CONFIG_BLOCK_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    while (current_offset < block_len) {\n        if (current_offset + sizeof(ConfigParamHeader) > block_len) {\n            return -2;\n        }\n\n        const ConfigParamHeader* header = (const ConfigParamHeader*)(config_data_block + current_offset);\n        uint8_t param_id = header->param_id;\n        uint8_t param_len = header->param_len;\n\n        if (current_offset + sizeof(ConfigParamHeader) + param_len > block_len) {\n            return -3;\n        }\n\n        const uint8_t* param_value_ptr = config_data_block + current_offset + sizeof(ConfigParamHeader);\n\n        switch (param_id) {\n            case CONFIG_ID_VEHICLE_NAME: {\n                uint8_t bytes_to_copy = param_len;\n                if (bytes_to_copy > MAX_VEHICLE_NAME_LEN) {\n                    bytes_to_copy = MAX_VEHICLE_NAME_LEN;\n                }\n                memcpy(g_vehicleName, param_value_ptr, bytes_to_copy);\n                g_vehicleName[bytes_to_copy] = '\\0';\n                break;\n            }\n            case CONFIG_ID_LICENSE_PLATE: {\n                uint8_t bytes_to_copy = param_len;\n                if (bytes_to_copy > MAX_LICENSE_PLATE_LEN) {\n                    bytes_to_copy = MAX_LICENSE_PLATE_LEN;\n                }\n                memcpy(g_licensePlate, param_value_ptr, bytes_to_copy);\n                g_licensePlate[bytes_to_copy] = '\\0';\n                break;\n            }\n            case CONFIG_ID_SPEED_LIMIT_ENABLED:\n                if (param_len == 1) {\n                    g_speedLimitEnabled = param_value_ptr[0];\n                }\n                break;\n            case CONFIG_ID_MAX_SPEED_VALUE:\n                if (param_len == sizeof(uint16_t)) {\n                    g_maxSpeedValue = (param_value_ptr[0] << 8) | param_value_ptr[1];\n                }\n                break;\n            default:\n                break;\n        }\n\n        current_offset += sizeof(ConfigParamHeader) + param_len;\n    }\n\n    return 0;\n}\n\nvoid simulateConfigUpdate(const uint8_t* data, uint16_t len) {\n    resetVehicleConfig();\n    applyVehicleConfiguration(data, len);\n}\n\nconst char* getVehicleName() {\n    return g_vehicleName;\n}\n\nconst char* getLicensePlate() {\n    return g_licensePlate;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_SENSOR_TYPES 5\n\ntypedef enum {\n    SENSOR_TYPE_RADAR = 0,\n    SENSOR_TYPE_LIDAR,\n    SENSOR_TYPE_CAMERA,\n    SENSOR_TYPE_ULTRASONIC,\n    SENSOR_TYPE_IMU,\n    SENSOR_TYPE_COUNT\n} SensorTypeID;\n\ntypedef struct {\n    float gain_factor;\n    int32_t offset_value;\n    uint16_t processing_flags;\n    char description[32];\n} SensorCalibrationProfile;\n\nstatic SensorCalibrationProfile g_sensorCalibrationProfiles[MAX_SENSOR_TYPES];\n\nvoid logSensorProcessingEvent(const char* msg) {\n    fprintf(stderr, \"SENSOR_PROC_LOG: %s\\n\", msg);\n}\n\nvoid applySensorCalibration(float* raw_value, SensorCalibrationProfile profile) {\n    *raw_value = (*raw_value * profile.gain_factor) + profile.offset_value;\n    logSensorProcessingEvent(\"Applied calibration.\");\n}\n\ntypedef struct {\n    uint8_t sensor_type_id;\n    uint32_t timestamp_ms;\n    float raw_measurement;\n    uint8_t data_integrity_checksum;\n} SensorDataPacket;\n\nSensorDataPacket receiveSensorDataPacket_Vulnerable() {\n    SensorDataPacket packet;\n    packet.sensor_type_id = SENSOR_TYPE_COUNT;\n    packet.timestamp_ms = 1678886400;\n    packet.raw_measurement = 25.5f;\n    packet.data_integrity_checksum = 0xAF;\n    return packet;\n}\n\nvoid initializeSensorCalibrationProfiles_Vulnerable() {\n    g_sensorCalibrationProfiles[SENSOR_TYPE_RADAR] = (SensorCalibrationProfile){1.0f, 0, 0x01, \"Radar Cal\"};\n    g_sensorCalibrationProfiles[SENSOR_TYPE_LIDAR] = (SensorCalibrationProfile){0.95f, 5, 0x02, \"Lidar Cal\"};\n    g_sensorCalibrationProfiles[SENSOR_TYPE_CAMERA] = (SensorCalibrationProfile){1.05f, -2, 0x04, \"Camera Cal\"};\n    g_sensorCalibrationProfiles[SENSOR_TYPE_ULTRASONIC] = (SensorCalibrationProfile){1.1f, 10, 0x08, \"Ultrasonic Cal\"};\n    g_sensorCalibrationProfiles[SENSOR_TYPE_IMU] = (SensorCalibrationProfile){0.9f, -1, 0x10, \"IMU Cal\"};\n    logSensorProcessingEvent(\"Sensor calibration profiles initialized (Vulnerable).\");\n}\n\nvoid processIncomingSensorData_Vulnerable() {\n    SensorDataPacket packet = receiveSensorDataPacket_Vulnerable();\n\n    SensorCalibrationProfile current_profile = g_sensorCalibrationProfiles[packet.sensor_type_id];\n\n    float processed_value = packet.raw_measurement;\n    applySensorCalibration(&processed_value, current_profile);\n\n    logSensorProcessingEvent(\"Sensor data processed (Vulnerable).\");\n}\n\nvoid sensorModuleMain_Vulnerable() {\n    initializeSensorCalibrationProfiles_Vulnerable();\n    processIncomingSensorData_Vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#define BCU_COUNT 8\n#define STATUS_PARAM_COUNT 16\n\ntypedef enum {\n    TEMP_SENSOR_1 = 0,\n    VOLTAGE_CELL_1,\n    CURRENT_MEASUREMENT,\n    FAN_SPEED,\n    STATUS_PARAM_MAX\n} BcuStatusParameter;\n\nstatic int g_bcuStatus[BCU_COUNT][STATUS_PARAM_COUNT];\n\ntypedef struct {\n    unsigned char bcu_id;\n    unsigned char param_index;\n    int           value;\n    unsigned char write_operation;\n} DiagnosticRequest;\n\nvoid logDiagnosticAlert(const char* msg) {\n}\n\nDiagnosticRequest receiveDiagnosticRequest_fixed() {\n    DiagnosticRequest req;\n    req.bcu_id = 0;\n    req.param_index = STATUS_PARAM_COUNT; \n    req.value = 0xABCD;\n    req.write_operation = 1;\n    return req;\n}\n\nvoid processBcuDiagnostic_fixed() {\n    DiagnosticRequest req = receiveDiagnosticRequest_fixed();\n\n    if (req.bcu_id < BCU_COUNT) {\n        if (req.param_index < STATUS_PARAM_COUNT) {\n            g_bcuStatus[req.bcu_id][req.param_index] = req.value;\n        } else {\n            logDiagnosticAlert(\"Invalid parameter index in diagnostic request.\");\n        }\n    } else {\n        logDiagnosticAlert(\"Invalid BCU ID in diagnostic request.\");\n    }\n}\n\nvoid bmsInit_fixed() {\n    for (int i = 0; i < BCU_COUNT; ++i) {\n        for (int j = 0; j < STATUS_PARAM_COUNT; ++j) {\n            g_bcuStatus[i][j] = 0;\n        }\n    }\n}\n\nvoid bmsMainLoop_fixed() {\n    bmsInit_fixed();\n    processBcuDiagnostic_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    uint16_t packet_id;\n    uint16_t num_sensor_readings;\n} SensorDataPacketHeader;\n\nclass SensorDataProcessor {\npublic:\n    SensorDataProcessor() : processed_readings(nullptr), current_reading_count(0) {}\n\n    ~SensorDataProcessor() {\n        if (processed_readings) {\n            free(processed_readings);\n            processed_readings = nullptr;\n        }\n    }\n\n    bool processRawSensorDataFixed(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(SensorDataPacketHeader)) {\n            return false;\n        }\n\n        const SensorDataPacketHeader* header = reinterpret_cast<const SensorDataPacketHeader*>(packet_data);\n        uint16_t num_samples = header->num_sensor_readings;\n\n        size_t data_offset = sizeof(SensorDataPacketHeader);\n        size_t expected_data_bytes = num_samples * sizeof(uint16_t);\n\n        if (num_samples > (SIZE_MAX / sizeof(uint16_t))) {\n             return false;\n        }\n\n        if (packet_length < (data_offset + expected_data_bytes)) {\n            return false;\n        }\n\n        if (processed_readings) {\n            free(processed_readings);\n            processed_readings = nullptr;\n        }\n\n        processed_readings = (uint16_t*)malloc(expected_data_bytes);\n\n        if (!processed_readings) {\n            return false;\n        }\n\n        memcpy(processed_readings, packet_data + data_offset, expected_data_bytes);\n\n        current_reading_count = num_samples;\n        return true;\n    }\n\n    uint16_t* getProcessedReadings() const { return processed_readings; }\n    uint16_t getReadingCount() const { return current_reading_count; }\n\nprivate:\n    uint16_t* processed_readings;\n    uint16_t current_reading_count;\n};\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define LOG_BUFFER_MAX_SIZE 512\n#define EVENT_HEADER_BASE_SIZE 2\n\nstatic uint8_t g_eventLogBuffer[LOG_BUFFER_MAX_SIZE];\nstatic uint16_t g_logCurrentWriteOffset = 0;\n\nvoid initEventLogger() {\n    memset(g_eventLogBuffer, 0, LOG_BUFFER_MAX_SIZE);\n    g_logCurrentWriteOffset = 0;\n}\n\nint processIncomingEvent(const uint8_t* message_payload, uint16_t payload_len) {\n    if (message_payload == NULL || payload_len < EVENT_HEADER_BASE_SIZE) {\n        return -1;\n    }\n\n    uint8_t event_type = message_payload[0];\n    uint8_t data_len = message_payload[1];\n\n    if (EVENT_HEADER_BASE_SIZE + data_len > payload_len) {\n        return -2;\n    }\n\n    uint8_t total_entry_size_check = (uint8_t)(EVENT_HEADER_BASE_SIZE + data_len);\n\n    if (g_logCurrentWriteOffset + total_entry_size_check > LOG_BUFFER_MAX_SIZE) {\n        return -3;\n    }\n\n    g_eventLogBuffer[g_logCurrentWriteOffset] = event_type;\n    g_logCurrentWriteOffset++;\n\n    g_eventLogBuffer[g_logCurrentWriteOffset] = data_len;\n    g_logCurrentWriteOffset++;\n\n    const uint8_t* event_data_ptr = message_payload + EVENT_HEADER_BASE_SIZE;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_eventLogBuffer[g_logCurrentWriteOffset + i] = event_data_ptr[i];\n    }\n    g_logCurrentWriteOffset += data_len;\n\n    return 0;\n}\n\nuint8_t getLogByte(uint16_t offset) {\n    if (offset < LOG_BUFFER_MAX_SIZE) {\n        return g_eventLogBuffer[offset];\n    }\n    return 0xFF;\n}\n\nvoid simulateEventReception(const uint8_t* msg, uint16_t len) {\n    processIncomingEvent(msg, len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_PACKET_PAYLOAD_SIZE 500\n#define TELEMETRY_HEADER_SIZE 5\n\n#define TEMP_DISPLAY_BUFFER_CAPACITY 80\n\ntypedef enum {\n    TELEMETRY_TYPE_INVALID = 0x00,\n    TELEMETRY_TYPE_SENSOR_READING = 0x01,\n    TELEMETRY_TYPE_EVENT_LOG = 0x02,\n    TELEMETRY_TYPE_DIAGNOSTIC_FAULT = 0x03\n} TelemetryPacketType;\n\nvoid displayEventDescription(const uint8_t* description_data, uint8_t description_len) {\n    char temp_display_buffer[TEMP_DISPLAY_BUFFER_CAPACITY];\n\n    if (description_data == NULL) {\n        return;\n    }\n\n    memcpy(temp_display_buffer, description_data, description_len);\n\n    if (description_len < TEMP_DISPLAY_BUFFER_CAPACITY) {\n        temp_display_buffer[description_len] = '\\0';\n    } else {\n        temp_display_buffer[TEMP_DISPLAY_BUFFER_CAPACITY - 1] = '\\0';\n    }\n}\n\nint handleIncomingTelemetryFrame(const uint8_t* frame_data, uint16_t frame_len) {\n    if (frame_data == NULL || frame_len < TELEMETRY_HEADER_SIZE) {\n        return -1;\n    }\n\n    uint16_t packet_id = (frame_data[0] << 8) | frame_data[1];\n    uint8_t packet_type = frame_data[2];\n    uint16_t payload_len = (frame_data[3] << 8) | frame_data[4];\n\n    if (TELEMETRY_HEADER_SIZE + payload_len > frame_len) {\n        return -1;\n    }\n\n    if (payload_len > MAX_PACKET_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    const uint8_t* payload_ptr = frame_data + TELEMETRY_HEADER_SIZE;\n\n    switch (packet_type) {\n        case TELEMETRY_TYPE_EVENT_LOG: {\n            uint16_t min_event_payload_size = sizeof(uint32_t) + sizeof(uint16_t) + sizeof(uint8_t);\n            if (payload_len < min_event_payload_size) {\n                return -1;\n            }\n\n            uint32_t timestamp = (payload_ptr[0] << 24) | (payload_ptr[1] << 16) |\n                                 (payload_ptr[2] << 8) | payload_ptr[3];\n            uint16_t event_code = (payload_ptr[4] << 8) | payload_ptr[5];\n            uint8_t description_len = payload_ptr[6];\n\n            if (description_len > (payload_len - min_event_payload_size)) {\n                return -1;\n            }\n\n            const uint8_t* description_ptr = payload_ptr + min_event_payload_size;\n\n            displayEventDescription(description_ptr, description_len);\n            break;\n        }\n        case TELEMETRY_TYPE_SENSOR_READING:\n            break;\n        case TELEMETRY_TYPE_DIAGNOSTIC_FAULT:\n            break;\n        default:\n            return -1;\n    }\n\n    return 0;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_RECORDER_BUFFER_SIZE 250 \n#define MAX_PAYLOAD_CHUNK_SIZE 60   \n\nstatic uint8_t g_diagRecordBuffer[DIAG_RECORDER_BUFFER_SIZE];\nstatic uint16_t g_currentRecordOffset = 0; \n\nvoid initDiagRecorder() {\n    memset(g_diagRecordBuffer, 0, DIAG_RECORDER_BUFFER_SIZE);\n    g_currentRecordOffset = 0;\n}\n\nint appendDiagDataChunk(const uint8_t* data_chunk, uint8_t chunk_len) {\n    if (data_chunk == NULL || chunk_len == 0 || chunk_len > MAX_PAYLOAD_CHUNK_SIZE) {\n        return -1; \n    }\n\n    uint16_t next_offset = g_currentRecordOffset + chunk_len;\n\n    if (next_offset > DIAG_RECORDER_BUFFER_SIZE) { \n        return -2; \n    }\n\n    for (uint8_t i = 0; i < chunk_len; ++i) {\n        g_diagRecordBuffer[g_currentRecordOffset + i] = data_chunk[i];\n    }\n\n    g_currentRecordOffset = next_offset; \n\n    return 0; \n}\n\nvoid processDiagnosticDataStream(const uint8_t* stream_data, uint16_t stream_len) {\n    initDiagRecorder(); \n\n    uint8_t fill_data[10];\n    memset(fill_data, 0x01, sizeof(fill_data));\n    \n    for (int k = 0; k < 20; ++k) {\n        appendDiagDataChunk(fill_data, 10); \n    }\n    \n    uint8_t evil_chunk_data[60];\n    memset(evil_chunk_data, 0xAA, sizeof(evil_chunk_data));\n\n    appendDiagDataChunk(evil_chunk_data, 60);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    uint16_t packet_id;\n    uint16_t num_sensor_readings;\n} SensorDataPacketHeader;\n\nclass SensorDataProcessor {\npublic:\n    SensorDataProcessor() : processed_readings(nullptr), current_reading_count(0) {}\n\n    ~SensorDataProcessor() {\n        if (processed_readings) {\n            free(processed_readings);\n            processed_readings = nullptr;\n        }\n    }\n\n    bool processRawSensorDataVulnerable(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(SensorDataPacketHeader)) {\n            return false;\n        }\n\n        const SensorDataPacketHeader* header = reinterpret_cast<const SensorDataPacketHeader*>(packet_data);\n        uint16_t num_samples = header->num_sensor_readings;\n\n        size_t data_offset = sizeof(SensorDataPacketHeader);\n        size_t expected_data_bytes = num_samples * sizeof(uint16_t);\n\n        if (packet_length < (data_offset + expected_data_bytes)) {\n            return false;\n        }\n\n        if (processed_readings) {\n            free(processed_readings);\n            processed_readings = nullptr;\n        }\n\n        processed_readings = (uint16_t*)malloc(num_samples);\n\n        if (!processed_readings) {\n            return false;\n        }\n\n        memcpy(processed_readings, packet_data + data_offset, expected_data_bytes);\n\n        current_reading_count = num_samples;\n        return true;\n    }\n\n    uint16_t* getProcessedReadings() const { return processed_readings; }\n    uint16_t getReadingCount() const { return current_reading_count; }\n\nprivate:\n    uint16_t* processed_readings;\n    uint16_t current_reading_count;\n};\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n\n// Max theoretical size for a decoded data block to prevent extreme allocation.\n// Even with this, an overflow can occur if the internal RLE logic expands beyond a malicious 'total_decoded_size' field.\n#define MAX_DECODED_BLOCK_SIZE 65536 // 64KB\n\n// Represents the header for an incoming telemetry data block\nstruct TelemetryBlockHeader {\n    uint16_t block_id;\n    uint16_t num_entries;\n    uint32_t total_decoded_size; // Advertised total size of ALL decoded data entries in this block\n};\n\n// Represents the header for an individual entry within the block\nstruct TelemetryEntryHeader {\n    uint8_t  entry_type; // 0x01 for raw, 0x02 for RLE\n    uint16_t encoded_data_length; // Length of the *encoded* data that follows this header\n};\n\nenum TelemetryEntryType : uint8_t {\n    RAW_DATA = 0x01,\n    RLE_DATA = 0x02\n};\n\nclass VehicleTelemetryProcessorVulnerable {\npublic:\n    VehicleTelemetryProcessorVulnerable() : m_decoded_buffer(nullptr), m_current_buffer_pos(0), m_allocated_capacity(0) {}\n\n    ~VehicleTelemetryProcessorVulnerable() {\n        if (m_decoded_buffer) {\n            free(m_decoded_buffer);\n        }\n    }\n\n    void resetBuffer() {\n        if (m_decoded_buffer) {\n            free(m_decoded_buffer);\n            m_decoded_buffer = nullptr;\n        }\n        m_current_buffer_pos = 0;\n        m_allocated_capacity = 0;\n    }\n\n    // Processes a raw telemetry data packet and appends decoded data to an internal buffer.\n    bool processTelemetryBlockVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(TelemetryBlockHeader)) {\n            return false;\n        }\n\n        const TelemetryBlockHeader* block_header = reinterpret_cast<const TelemetryBlockHeader*>(raw_packet);\n\n        // Preliminary check for packet size vs advertised total payload\n        // This check is insufficient, as total_decoded_size can be manipulated by attacker\n        // to be smaller than actual decoded size while still fitting in packet_len\n        if (packet_len < sizeof(TelemetryBlockHeader) + block_header->total_decoded_size) {\n            return false;\n        }\n\n        // Allocate buffer based on the *advertised* total_decoded_size.\n        // VULNERABILITY: This size might be undersized if RLE entries expand beyond what the attacker\n        // advertises as total_decoded_size, leading to a heap overflow during the copy loop.\n        size_t desired_alloc_size = block_header->total_decoded_size;\n        if (desired_alloc_size == 0) { // Handle empty block case\n             resetBuffer();\n             return true;\n        }\n\n        // Apply a hard limit to prevent excessively large legitimate allocations,\n        // but this doesn't prevent overflow for malicious inputs within this limit.\n        if (desired_alloc_size > MAX_DECODED_BLOCK_SIZE) {\n            return false;\n        }\n\n        // Reallocate/allocate the buffer\n        uint8_t* new_buffer = (uint8_t*)realloc(m_decoded_buffer, desired_alloc_size);\n        if (!new_buffer) {\n            // Realloc failed, clean up old buffer if it existed\n            if (m_decoded_buffer) free(m_decoded_buffer);\n            m_decoded_buffer = nullptr;\n            m_current_buffer_pos = 0;\n            m_allocated_capacity = 0;\n            return false;\n        }\n        m_decoded_buffer = new_buffer;\n        m_allocated_capacity = desired_alloc_size;\n        m_current_buffer_pos = 0; // Reset position for new block processing\n\n        size_t current_packet_offset = sizeof(TelemetryBlockHeader);\n\n        for (uint16_t i = 0; i < block_header->num_entries; ++i) {\n            if (current_packet_offset + sizeof(TelemetryEntryHeader) > packet_len) {\n                resetBuffer();\n                return false;\n            }\n\n            const TelemetryEntryHeader* entry_header = reinterpret_cast<const TelemetryEntryHeader*>(raw_packet + current_packet_offset);\n            \n            // Check if the encoded data fits within the packet\n            if (current_packet_offset + sizeof(TelemetryEntryHeader) + entry_header->encoded_data_length > packet_len) {\n                resetBuffer();\n                return false;\n            }\n\n            const uint8_t* entry_data_ptr = raw_packet + current_packet_offset + sizeof(TelemetryEntryHeader);\n            size_t bytes_to_read = entry_header->encoded_data_length;\n\n            switch (entry_header->entry_type) {\n                case RAW_DATA: {\n                    // Direct copy of raw data\n                    if (m_current_buffer_pos + bytes_to_read > m_allocated_capacity) {\n                        // This check exists, but for RLE data, bytes_to_read is encoded length, not decoded.\n                        // If total_decoded_size was manipulated, this may be too late or not applicable.\n                        resetBuffer();\n                        return false;\n                    }\n                    std::memcpy(m_decoded_buffer + m_current_buffer_pos, entry_data_ptr, bytes_to_read);\n                    m_current_buffer_pos += bytes_to_read;\n                    break;\n                }\n                case RLE_DATA: {\n                    // Process Run-Length Encoded data (format: [byte_to_repeat][repeat_count]...)\n                    size_t rle_current_read_offset = 0;\n                    while (rle_current_read_offset + 1 < bytes_to_read) { // Need at least 2 bytes (value, count)\n                        uint8_t value_to_repeat = entry_data_ptr[rle_current_read_offset];\n                        uint8_t repeat_count = entry_data_ptr[rle_current_read_offset + 1];\n\n                        // VULNERABILITY: No check here if 'm_current_buffer_pos + repeat_count' exceeds 'm_allocated_capacity'.\n                        // The 'm_allocated_capacity' is based on the potentially undersized 'total_decoded_size' field.\n                        // An attacker can craft a 'total_decoded_size' smaller than the actual\n                        // expanded size of RLE data, leading to a heap overflow.\n                        for (uint8_t k = 0; k < repeat_count; ++k) {\n                            m_decoded_buffer[m_current_buffer_pos + k] = value_to_repeat;\n                        }\n                        m_current_buffer_pos += repeat_count;\n\n                        rle_current_read_offset += 2; // Move to the next RLE pair\n                    }\n                    break;\n                }\n                default:\n                    // Unknown type, or other types would be handled here\n                    resetBuffer();\n                    return false;\n            }\n            current_packet_offset += sizeof(TelemetryEntryHeader) + bytes_to_read;\n        }\n\n        // Final check: ensure the total size written matches the advertised size.\n        // This check comes *after* the writes, so an overflow would have already occurred if triggered.\n        if (m_current_buffer_pos > block_header->total_decoded_size) {\n            resetBuffer(); \n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getDecodedBuffer() const { return m_decoded_buffer; }\n    size_t getCurrentDecodedSize() const { return m_current_buffer_pos; }\n\nprivate:\n    uint8_t* m_decoded_buffer;\n    size_t   m_current_buffer_pos;\n    size_t   m_allocated_capacity;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\n#define DTC_ALIGNMENT_BYTES 4\n\n#pragma pack(push, 1)\nstruct DTCHeader {\n    uint16_t dtc_id;\n    uint16_t data_length; \n};\n\nstruct DTCBatchPacket {\n    uint32_t timestamp;\n    uint16_t num_dtc_entries;\n};\n#pragma pack(pop)\n\nclass DiagnosticBufferVulnerable {\nprivate:\n    uint8_t* m_consolidated_buffer;\n    size_t   m_current_write_offset;\n    size_t   m_allocated_capacity;\n\npublic:\n    DiagnosticBufferVulnerable() :\n        m_consolidated_buffer(nullptr),\n        m_current_write_offset(0),\n        m_allocated_capacity(0)\n    {\n        m_allocated_capacity = 1024; \n        m_consolidated_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_consolidated_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~DiagnosticBufferVulnerable() {\n        if (m_consolidated_buffer) {\n            free(m_consolidated_buffer);\n            m_consolidated_buffer = nullptr;\n        }\n    }\n\n    bool addDTCBatchVulnerable(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(DTCBatchPacket)) {\n            return false;\n        }\n\n        const DTCBatchPacket* batch_hdr = reinterpret_cast<const DTCBatchPacket*>(packet_data);\n        size_t current_packet_read_offset = sizeof(DTCBatchPacket);\n        \n        size_t total_payload_bytes_in_batch = 0;\n\n        for (uint16_t i = 0; i < batch_hdr->num_dtc_entries; ++i) {\n            if (current_packet_read_offset + sizeof(DTCHeader) > packet_length) {\n                return false;\n            }\n            const DTCHeader* dtc_hdr = reinterpret_cast<const DTCHeader*>(packet_data + current_packet_read_offset);\n            \n            uint16_t dtc_data_len = dtc_hdr->data_length;\n\n            size_t entry_total_raw_size = sizeof(DTCHeader) + dtc_data_len;\n\n            if (current_packet_read_offset + entry_total_raw_size > packet_length) {\n                return false;\n            }\n            \n            if (total_payload_bytes_in_batch > SIZE_MAX - entry_total_raw_size) {\n                return false;\n            }\n            // VULNERABILITY:\n            // The sum for allocation calculation 'total_payload_bytes_in_batch' only accounts for the raw data length\n            // (header + data_length), but not the necessary padding that will be added to each entry\n            // for alignment purposes in the consolidated buffer.\n            total_payload_bytes_in_batch += entry_total_raw_size;\n\n            current_packet_read_offset += entry_total_raw_size;\n        }\n\n        size_t required_total_space = m_current_write_offset + total_payload_bytes_in_batch;\n        \n        if (required_total_space > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity * 2;\n            if (new_capacity < required_total_space) {\n                new_capacity = required_total_space;\n            }\n            if (new_capacity > (10 * 1024 * 1024)) {\n                if (required_total_space > (10 * 1024 * 1024)) {\n                    return false;\n                }\n                new_capacity = (10 * 1024 * 1024);\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_consolidated_buffer, new_capacity);\n            if (!new_buffer) {\n                free(m_consolidated_buffer);\n                m_consolidated_buffer = nullptr;\n                m_current_write_offset = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_consolidated_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        current_packet_read_offset = sizeof(DTCBatchPacket);\n\n        for (uint16_t i = 0; i < batch_hdr->num_dtc_entries; ++i) {\n            const DTCHeader* dtc_hdr = reinterpret_cast<const DTCHeader*>(packet_data + current_packet_read_offset);\n            uint16_t dtc_data_len = dtc_hdr->data_length;\n\n            size_t entry_total_raw_size = sizeof(DTCHeader) + dtc_data_len;\n            // This is the actual size including padding that will be written\n            size_t entry_actual_storage_size = (entry_total_raw_size + DTC_ALIGNMENT_BYTES - 1) & ~(DTC_ALIGNMENT_BYTES - 1);\n            \n            // VULNERABILITY: If the buffer was undersized due to the previous calculation, \n            // the following byte-by-byte copies and padding write operations will go out of bounds.\n            // Copy header bytes manually\n            m_consolidated_buffer[m_current_write_offset] = (uint8_t)(dtc_hdr->dtc_id & 0xFF);\n            m_consolidated_buffer[m_current_write_offset + 1] = (uint8_t)((dtc_hdr->dtc_id >> 8) & 0xFF);\n            m_consolidated_buffer[m_current_write_offset + 2] = (uint8_t)(dtc_hdr->data_length & 0xFF);\n            m_consolidated_buffer[m_current_write_offset + 3] = (uint8_t)((dtc_hdr->data_length >> 8) & 0xFF);\n            \n            // Copy data payload bytes manually\n            const uint8_t* payload_src = packet_data + current_packet_read_offset + sizeof(DTCHeader);\n            for (uint16_t j = 0; j < dtc_data_len; ++j) {\n                m_consolidated_buffer[m_current_write_offset + sizeof(DTCHeader) + j] = payload_src[j];\n            }\n\n            // Fill padding bytes with zeros manually\n            size_t bytes_to_pad = entry_actual_storage_size - entry_total_raw_size;\n            if (bytes_to_pad > 0) {\n                for (size_t k = 0; k < bytes_to_pad; ++k) {\n                    m_consolidated_buffer[m_current_write_offset + entry_total_raw_size + k] = 0;\n                }\n            }\n            \n            m_current_write_offset += entry_actual_storage_size;\n            current_packet_read_offset += entry_total_raw_size;\n        }\n\n        return true;\n    }\n\n    size_t getCurrentBufferSize() const { return m_current_write_offset; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n    const uint8_t* getConsolidatedBuffer() const { return m_consolidated_buffer; }\n};\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define MAX_SENSOR_DETECTIONS 100 \n\n#pragma pack(push, 1)\ntypedef struct {\n    int16_t x;\n    int16_t y;\n    int16_t z;\n    uint8_t confidence;\n} DetectionPoint;\n#pragma pack(pop)\n\ntypedef struct {\n    uint16_t frame_id;\n    uint8_t  sensor_id;\n    uint8_t  num_detection_points; \n    uint32_t timestamp;\n} SensorDataFrameHeader;\n\nstatic DetectionPoint g_processedDetections[MAX_SENSOR_DETECTIONS];\nstatic uint8_t g_currentDetectionCount = 0;\n\nvoid initDetectionBuffer() {\n    memset(g_processedDetections, 0, sizeof(g_processedDetections));\n    g_currentDetectionCount = 0;\n}\n\nint processSensorDataFrame(const uint8_t* raw_frame, uint16_t frame_len) {\n    if (raw_frame == NULL || frame_len < sizeof(SensorDataFrameHeader)) {\n        return -1;\n    }\n\n    const SensorDataFrameHeader* header = (const SensorDataFrameHeader*)raw_frame;\n\n    uint8_t num_points = header->num_detection_points;\n    \n    const uint8_t* data_ptr = raw_frame + sizeof(SensorDataFrameHeader);\n    uint16_t current_data_offset = 0;\n\n    uint16_t expected_points_data_len = num_points * sizeof(DetectionPoint);\n    if (frame_len < (sizeof(SensorDataFrameHeader) + expected_points_data_len)) {\n        return -2; \n    }\n\n    for (uint8_t i = 0; i < num_points; ++i) {\n        g_processedDetections[i].x = (int16_t)((data_ptr[current_data_offset + 0] << 8) | data_ptr[current_data_offset + 1]);\n        g_processedDetections[i].y = (int16_t)((data_ptr[current_data_offset + 2] << 8) | data_ptr[current_data_offset + 3]);\n        g_processedDetections[i].z = (int16_t)((data_ptr[current_data_offset + 4] << 8) | data_ptr[current_data_offset + 5]);\n        g_processedDetections[i].confidence = data_ptr[current_data_offset + 6];\n        current_data_offset += sizeof(DetectionPoint);\n    }\n\n    g_currentDetectionCount = num_points;\n    return 0;\n}\n\nvoid simulateReceiveSensorFrame(const uint8_t* frame, uint16_t len) {\n    processSensorDataFrame(frame, len);\n}\n\nDetectionPoint* getProcessedDetection(uint8_t index) {\n    if (index < g_currentDetectionCount) {\n        return &g_processedDetections[index];\n    }\n    return NULL;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <string.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n// Vehicle parameter IDs\n#define VEHICLE_PARAM_SENSOR_CALIBRATION_A 0x10\n#define VEHICLE_PARAM_VEHICLE_IDENTIFIER   0x11\n#define VEHICLE_PARAM_DIAG_LIFETIME_COUNTER 0x12\n\n// Maximum length for vehicle identifier string\n#define VEHICLE_IDENTIFIER_MAX_LEN 16\n\n// Structure to hold vehicle configuration parameters\ntypedef struct {\n    uint16_t sensorCalibrationValueA;       // 2 bytes\n    char     vehicleIdentifier[VEHICLE_IDENTIFIER_MAX_LEN]; // 16 bytes buffer for C string\n    uint32_t diagnosticLifetimeCounter;     // 4 bytes\n    uint8_t  featureFlags[4];               // 4 bytes of feature flags\n} VehicleSystemConfiguration;\n\n// Global instance of the vehicle configuration\nstatic VehicleSystemConfiguration g_systemConfig;\n\n// Function to initialize the configuration\nvoid systemConfigInit() {\n    g_systemConfig.sensorCalibrationValueA = 512;\n    strncpy(g_systemConfig.vehicleIdentifier, \"DEFAULT_VIN_XYZ\", VEHICLE_IDENTIFIER_MAX_LEN - 1);\n    g_systemConfig.vehicleIdentifier[VEHICLE_IDENTIFIER_MAX_LEN - 1] = '\\0';\n    g_systemConfig.diagnosticLifetimeCounter = 0;\n    memset(g_systemConfig.featureFlags, 0, sizeof(g_systemConfig.featureFlags));\n}\n\n// Function to process an incoming update request for a specific vehicle parameter\n// This function could be called by a diagnostic service handler or a CAN message handler.\n// paramId: The ID of the parameter to update.\n// data: Pointer to the new data for the parameter.\n// dataLen: The length of the new data in bytes.\nint updateVehicleParameter(uint8_t paramId, const uint8_t* data, uint16_t dataLen) {\n    if (data == NULL || dataLen == 0) {\n        return -1; // Invalid input\n    }\n\n    switch (paramId) {\n        case VEHICLE_PARAM_SENSOR_CALIBRATION_A:\n            if (dataLen == sizeof(uint16_t)) {\n                // Assuming little-endian or byte-order handled by caller/system\n                g_systemConfig.sensorCalibrationValueA = *(uint16_t*)data;\n            } else {\n                return -2; // Incorrect data length for calibration value\n            }\n            break;\n\n        case VEHICLE_PARAM_VEHICLE_IDENTIFIER:\n            // Fix: Add explicit length check against the buffer's capacity\n            uint16_t bytesToCopy = dataLen;\n            if (bytesToCopy >= VEHICLE_IDENTIFIER_MAX_LEN) { // Use >= to account for null terminator space if applicable\n                bytesToCopy = VEHICLE_IDENTIFIER_MAX_LEN - 1; // Truncate to fit, leaving space for null terminator\n            }\n            memcpy(g_systemConfig.vehicleIdentifier, data, bytesToCopy);\n            g_systemConfig.vehicleIdentifier[bytesToCopy] = '\\0'; // Ensure null termination\n            break;\n\n        case VEHICLE_PARAM_DIAG_LIFETIME_COUNTER:\n            if (dataLen == sizeof(uint32_t)) {\n                g_systemConfig.diagnosticLifetimeCounter = *(uint32_t*)data;\n            } else {\n                return -2; // Incorrect data length for lifetime counter\n            }\n            break;\n\n        default:\n            return -3; // Unknown parameter ID\n    }\n\n    return 0; // Parameter updated successfully\n}\n\n// Example usage context (not part of the vulnerability, just for completeness)\nvoid simulateIncomingMessage(uint8_t id, const uint8_t* payload, uint16_t len) {\n    updateVehicleParameter(id, payload, len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define LOG_BUFFER_SIZE 512\n#define SENSOR_READING_SIZE 2\n\nstatic uint8_t g_sensorLogBuffer[LOG_BUFFER_SIZE];\nstatic uint16_t g_logWriteCursor = 0;\n\nvoid initSensorLogger() {\n    memset(g_sensorLogBuffer, 0, LOG_BUFFER_SIZE);\n    g_logWriteCursor = 0;\n}\n\nint processSensorDataPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len < 3) {\n        return -1;\n    }\n\n    uint16_t current_packet_read_offset = 0;\n    uint8_t sensor_id = packet[current_packet_read_offset++];\n    uint16_t num_readings = (packet[current_packet_read_offset] << 8) | packet[current_packet_read_offset+1];\n    current_packet_read_offset += 2;\n\n    if (num_readings == 0) {\n        return 0;\n    }\n\n    uint16_t data_bytes_len = num_readings * SENSOR_READING_SIZE;\n\n    if (current_packet_read_offset + data_bytes_len > packet_len) {\n        return -3;\n    }\n\n    uint16_t header_size = 1 + 2;\n    uint16_t total_entry_size = header_size + data_bytes_len;\n\n    if (g_logWriteCursor + total_entry_size > LOG_BUFFER_SIZE) {\n        g_logWriteCursor = 0;\n        if (total_entry_size > LOG_BUFFER_SIZE) {\n            return -4;\n        }\n    }\n\n    g_sensorLogBuffer[g_logWriteCursor++] = sensor_id;\n    g_sensorLogBuffer[g_logWriteCursor++] = (uint8_t)(num_readings >> 8);\n    g_sensorLogBuffer[g_logWriteCursor++] = (uint8_t)(num_readings & 0xFF);\n\n    for (uint16_t i = 0; i < num_readings; ++i) {\n        uint16_t source_reading_offset = current_packet_read_offset + (i * SENSOR_READING_SIZE);\n        uint16_t dest_reading_offset = g_logWriteCursor + (i * SENSOR_READING_SIZE);\n\n        g_sensorLogBuffer[dest_reading_offset] = packet[source_reading_offset];\n        g_sensorLogBuffer[dest_reading_offset + 1] = packet[source_reading_offset + 1];\n    }\n\n    g_logWriteCursor = (g_logWriteCursor + data_bytes_len) % LOG_BUFFER_SIZE;\n\n    return 0;\n}\n\nvoid receiveSensorUpdate(const uint8_t* raw_data, uint16_t length) {\n    processSensorDataPacket(raw_data, length);\n}", "is_vuln": 1, "cvss": 7.5}
