{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define VEHICLE_COM_BUFFER_SIZE_FIXED 256\n#define VEHICLE_COM_HEADER_LEN_FIXED 5\n\ntypedef struct {\n    uint8_t start_marker;\n    uint8_t protocol_version;\n    uint8_t message_type;\n    uint8_t payload_length;\n    uint8_t checksum;\n    uint8_t payload_data[VEHICLE_COM_BUFFER_SIZE_FIXED - VEHICLE_COM_HEADER_LEN_FIXED];\n} VehicleComFrame_Fixed;\n\nstatic uint8_t g_com_buffer_fixed[VEHICLE_COM_BUFFER_SIZE_FIXED];\nstatic uint16_t g_current_frame_ptr_offset_fixed = 0;\nstatic uint16_t g_buffered_data_len_fixed = 0;\n\nvoid init_com_buffer_fixed() {\n    memset(g_com_buffer_fixed, 0, VEHICLE_COM_BUFFER_SIZE_FIXED);\n    g_current_frame_ptr_offset_fixed = 0;\n    g_buffered_data_len_fixed = 0;\n}\n\nbool receive_com_data_fixed(const uint8_t* data, uint16_t len) {\n    if (len == 0 || data == NULL || (g_buffered_data_len_fixed + len > VEHICLE_COM_BUFFER_SIZE_FIXED)) {\n        return false;\n    }\n    memcpy(g_com_buffer_fixed + g_buffered_data_len_fixed, data, len);\n    g_buffered_data_len_fixed += len;\n    return true;\n}\n\nbool set_current_frame_offset_fixed(uint16_t offset) {\n    if (offset < g_buffered_data_len_fixed && offset + VEHICLE_COM_HEADER_LEN_FIXED <= g_buffered_data_len_fixed) {\n        g_current_frame_ptr_offset_fixed = offset;\n        return true;\n    }\n    return false;\n}\n\nvoid update_frame_control_field_fixed(uint16_t relative_to_frame_start_offset, int16_t internal_adjustment, uint8_t new_value) {\n    int32_t effective_target_idx = (int32_t)g_current_frame_ptr_offset_fixed +\n                                   (int32_t)relative_to_frame_start_offset +\n                                   (int32_t)internal_adjustment;\n\n    if (effective_target_idx < 0 || effective_target_idx >= VEHICLE_COM_BUFFER_SIZE_FIXED) {\n        return;\n    }\n\n    g_com_buffer_fixed[effective_target_idx] = new_value;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_FIRMWARE_SIZE 0x10000 \n#define FRAGMENT_MAX_PAYLOAD_SIZE 256 \n\nstatic uint8_t g_firmwareBuffer[VEHICLE_FIRMWARE_SIZE];\n\nvoid initFirmwareBuffer() {\n    memset(g_firmwareBuffer, 0, VEHICLE_FIRMWARE_SIZE);\n}\n\nstatic int processFirmwareFragment(uint16_t fragment_offset, uint8_t fragment_len, const uint8_t* fragment_data) {\n    if (fragment_data == NULL || fragment_len == 0) {\n        return -1;\n    }\n\n    if ((uint32_t)fragment_offset + fragment_len > VEHICLE_FIRMWARE_SIZE) {\n        return -2;\n    }\n\n    for (uint8_t i = 0; i < fragment_len; ++i) {\n        g_firmwareBuffer[fragment_offset + i] = fragment_data[i];\n    }\n\n    return 0;\n}\n\nint handleFirmwareUpdateMessage(const uint8_t* message, uint16_t message_len) {\n    if (message == NULL || message_len < (1 + sizeof(uint16_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    uint8_t service_id = message[0];\n    if (service_id != 0x34) {\n        return -2;\n    }\n\n    uint16_t offset_idx = 1;\n    uint16_t fragment_offset = (message[offset_idx] << 8) | message[offset_idx+1];\n    \n    uint16_t len_idx = offset_idx + sizeof(uint16_t);\n    uint8_t fragment_len = message[len_idx];\n\n    const uint8_t* fragment_data = message + len_idx + sizeof(uint8_t);\n    uint16_t actual_data_in_msg_len = message_len - (len_idx + sizeof(uint8_t));\n\n    if (fragment_len > FRAGMENT_MAX_PAYLOAD_SIZE) {\n        return -3;\n    }\n    \n    if (fragment_len > actual_data_in_msg_len) { \n        return -4; \n    }\n\n    return processFirmwareFragment(fragment_offset, fragment_len, fragment_data);\n}\n\nuint8_t getFirmwareByte(uint32_t index) {\n    if (index < VEHICLE_FIRMWARE_SIZE) {\n        return g_firmwareBuffer[index];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define COM_LOG_SIZE 16\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_code;\n    uint8_t  severity;\n} ComEvent;\n\nstatic ComEvent g_com_event_log_fixed[COM_LOG_SIZE];\nstatic uint16_t g_next_event_idx_fixed = 0;\nstatic uint16_t g_current_event_count_fixed = 0;\n\nvoid init_com_log_fixed() {\n    memset(g_com_event_log_fixed, 0, sizeof(g_com_event_log_fixed));\n    g_next_event_idx_fixed = 0;\n    g_current_event_count_fixed = 0;\n}\n\nvoid log_com_event_fixed(uint32_t ts, uint16_t code, uint8_t sev) {\n    g_com_event_log_fixed[g_next_event_idx_fixed].timestamp = ts;\n    g_com_event_log_fixed[g_next_event_idx_fixed].event_code = code;\n    g_com_event_log_fixed[g_next_event_idx_fixed].severity = sev;\n\n    g_next_event_idx_fixed = (g_next_event_idx_fixed + 1) % COM_LOG_SIZE;\n    if (g_current_event_count_fixed < COM_LOG_SIZE) {\n        g_current_event_count_fixed++;\n    }\n}\n\nvoid adjust_com_event_severity_fixed(uint8_t relative_offset_from_latest, uint8_t new_severity) {\n    if (g_current_event_count_fixed == 0) {\n        return;\n    }\n\n    if (relative_offset_from_latest >= g_current_event_count_fixed) {\n        return;\n    }\n\n    int32_t latest_event_index;\n    if (g_next_event_idx_fixed == 0) {\n        latest_event_index = COM_LOG_SIZE - 1;\n    } else {\n        latest_event_index = g_next_event_idx_fixed - 1;\n    }\n\n    int32_t conceptual_target_index = latest_event_index - (int32_t)relative_offset_from_latest;\n    uint16_t target_index = (uint16_t)((conceptual_target_index % COM_LOG_SIZE + COM_LOG_SIZE) % COM_LOG_SIZE);\n\n    g_com_event_log_fixed[target_index].severity = new_severity;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define ECU_STATE_LOG_BUFFER_SIZE 32\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t control_param_A;\n    uint16_t control_param_B;\n    uint32_t diagnostic_status_flags;\n} ECU_StateSnapshot;\n\nstatic ECU_StateSnapshot g_ecu_state_log_fixed[ECU_STATE_LOG_BUFFER_SIZE];\nstatic uint16_t g_log_next_idx_fixed = 0; \nstatic bool g_buffer_full_fixed = false; \n\nvoid init_ecu_log_fixed() {\n    memset(g_ecu_state_log_fixed, 0, sizeof(g_ecu_state_log_fixed));\n    g_log_next_idx_fixed = 0;\n    g_buffer_full_fixed = false;\n}\n\nvoid log_ecu_state_fixed(uint32_t ts, uint16_t paramA, uint16_t paramB, uint32_t flags) {\n    g_ecu_state_log_fixed[g_log_next_idx_fixed].timestamp = ts;\n    g_ecu_state_log_fixed[g_log_next_idx_fixed].control_param_A = paramA;\n    g_ecu_state_log_fixed[g_log_next_idx_fixed].control_param_B = paramB;\n    g_ecu_state_log_fixed[g_log_next_idx_fixed].diagnostic_status_flags = flags;\n\n    g_log_next_idx_fixed++;\n    if (g_log_next_idx_fixed >= ECU_STATE_LOG_BUFFER_SIZE) {\n        g_log_next_idx_fixed = 0;\n        g_buffer_full_fixed = true;\n    }\n}\n\nvoid adjust_snapshot_param_fixed(uint16_t relative_offset_from_latest, uint16_t new_param_A_value) {\n    uint16_t num_logged_entries = g_buffer_full_fixed ? ECU_STATE_LOG_BUFFER_SIZE : g_log_next_idx_fixed;\n\n    if (num_logged_entries == 0 || relative_offset_from_latest >= num_logged_entries) {\n        return; \n    }\n\n    uint16_t latest_entry_idx;\n    if (g_log_next_idx_fixed == 0 && g_buffer_full_fixed) {\n        latest_entry_idx = ECU_STATE_LOG_BUFFER_SIZE - 1;\n    } else {\n        latest_entry_idx = g_log_next_idx_fixed - 1;\n    }\n\n    int32_t target_idx_conceptual = (int32_t)latest_entry_idx - relative_offset_from_latest;\n    \n    uint16_t target_idx_fixed = (uint16_t)(((target_idx_conceptual % ECU_STATE_LOG_BUFFER_SIZE) + ECU_STATE_LOG_BUFFER_SIZE) % ECU_STATE_LOG_BUFFER_SIZE);\n\n    g_ecu_state_log_fixed[target_idx_fixed].control_param_A = new_param_A_value;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define GLOBAL_DATA_BUFFER_SIZE_VULNERABLE 180\n#define PARAM_TYPE_COUNT_VULNERABLE 3\n\ntypedef enum {\n    PARAM_ENGINE_TEMP_HISTORY_VULNERABLE = 0,\n    PARAM_BATTERY_VOLTAGE_HISTORY_VULNERABLE,\n    PARAM_TRANSMISSION_SLIP_HISTORY_VULNERABLE,\n    PARAM_TYPE_MAX_VULNERABLE\n} VehicleParameterType_Vulnerable;\n\ntypedef struct {\n    uint16_t value;\n    uint32_t timestamp;\n} ParameterEntry_Vulnerable;\n\nstatic uint8_t g_globalParamDataBuffer_vulnerable[GLOBAL_DATA_BUFFER_SIZE_VULNERABLE];\n\ntypedef struct {\n    uint16_t start_offset_bytes;\n    uint16_t max_entries;\n    uint16_t current_entry_idx;\n} ParameterTypeConfig_Vulnerable;\n\nstatic ParameterTypeConfig_Vulnerable g_paramTypeConfigs_vulnerable[PARAM_TYPE_COUNT_VULNERABLE];\n\nvoid logVehicleInfo_vulnerable(const char* msg) {\n}\n\nvoid logVehicleError_vulnerable(const char* msg) {\n}\n\nvoid initParamLogger_vulnerable() {\n    g_paramTypeConfigs_vulnerable[PARAM_ENGINE_TEMP_HISTORY_VULNERABLE] = (ParameterTypeConfig_Vulnerable){\n        .start_offset_bytes = 0,\n        .max_entries = 5,\n        .current_entry_idx = 0\n    };\n\n    g_paramTypeConfigs_vulnerable[PARAM_BATTERY_VOLTAGE_HISTORY_VULNERABLE] = (ParameterTypeConfig_Vulnerable){\n        .start_offset_bytes = g_paramTypeConfigs_vulnerable[PARAM_ENGINE_TEMP_HISTORY_VULNERABLE].max_entries * sizeof(ParameterEntry_Vulnerable),\n        .max_entries = 5,\n        .current_entry_idx = 0\n    };\n\n    g_paramTypeConfigs_vulnerable[PARAM_TRANSMISSION_SLIP_HISTORY_VULNERABLE] = (ParameterTypeConfig_Vulnerable){\n        .start_offset_bytes = g_paramTypeConfigs_vulnerable[PARAM_ENGINE_TEMP_HISTORY_VULNERABLE].max_entries * sizeof(ParameterEntry_Vulnerable) +\n                              g_paramTypeConfigs_vulnerable[PARAM_BATTERY_VOLTAGE_HISTORY_VULNERABLE].max_entries * sizeof(ParameterEntry_Vulnerable),\n        .max_entries = 5,\n        .current_entry_idx = 0\n    };\n\n    for (uint16_t i = 0; i < GLOBAL_DATA_BUFFER_SIZE_VULNERABLE; ++i) {\n        g_globalParamDataBuffer_vulnerable[i] = 0;\n    }\n\n    logVehicleInfo_vulnerable(\"Parameter logger initialized (vulnerable).\");\n}\n\nvoid logParameterEntry_vulnerable(VehicleParameterType_Vulnerable type, uint16_t value, uint32_t timestamp) {\n    if (type >= PARAM_TYPE_MAX_VULNERABLE) {\n        logVehicleError_vulnerable(\"Invalid parameter type for logging.\");\n        return;\n    }\n\n    ParameterTypeConfig_Vulnerable* config = &g_paramTypeConfigs_vulnerable[type];\n    ParameterEntry_Vulnerable new_entry = { .value = value, .timestamp = timestamp };\n\n    uint16_t relative_offset_bytes = config->current_entry_idx * sizeof(ParameterEntry_Vulnerable);\n    uint16_t absolute_byte_offset = config->start_offset_bytes + relative_offset_bytes;\n\n    if (absolute_byte_offset + sizeof(ParameterEntry_Vulnerable) <= GLOBAL_DATA_BUFFER_SIZE_VULNERABLE) {\n        *(ParameterEntry_Vulnerable*)(g_globalParamDataBuffer_vulnerable + absolute_byte_offset) = new_entry;\n        logVehicleInfo_vulnerable(\"Parameter entry logged.\");\n        config->current_entry_idx++;\n    } else {\n        logVehicleError_vulnerable(\"Global parameter buffer limit reached, entry dropped.\");\n    }\n}\n\nvoid automotiveParameterLogging_vulnerable_main() {\n    initParamLogger_vulnerable();\n\n    logVehicleInfo_vulnerable(\"Simulating excessive ENGINE_TEMP_HISTORY logging...\");\n    for (int i = 0; i < 7; ++i) {\n        logParameterEntry_vulnerable(PARAM_ENGINE_TEMP_HISTORY_VULNERABLE, 80 + i, 0x1000 + i);\n    }\n\n    logVehicleInfo_vulnerable(\"Logging a BATTERY_VOLTAGE_HISTORY entry...\");\n    logParameterEntry_vulnerable(PARAM_BATTERY_VOLTAGE_HISTORY_VULNERABLE, 125, 0x2001);\n\n    logParameterEntry_vulnerable(PARAM_TRANSMISSION_SLIP_HISTORY_VULNERABLE, 10, 0x3001);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <string.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n#define CAN_PAYLOAD_MAX_SUPPORTED 256\n#define DIAG_PROCESSING_BUFFER_SIZE 128\n\ntypedef struct {\n    uint32_t arbitrationId;\n    uint8_t  dlc;\n    uint8_t  data[CAN_PAYLOAD_MAX_SUPPORTED];\n} CanRxFrame;\n\ntypedef struct {\n    uint8_t currentServiceId;\n    uint8_t diagnosticDataBuffer[DIAG_PROCESSING_BUFFER_SIZE];\n    uint16_t dataReceivedLength;\n    bool processingActive;\n} DiagnosticHandlerContext;\n\nstatic DiagnosticHandlerContext g_diagContext = {0};\n\nvoid initDiagnosticHandler(void) {\n    memset(&g_diagContext, 0, sizeof(DiagnosticHandlerContext));\n    g_diagContext.processingActive = false;\n}\n\nint handleIncomingDiagnosticMessage(const CanRxFrame* frame) {\n    if (frame == NULL || frame->dlc == 0) {\n        return -1;\n    }\n\n    memcpy(g_diagContext.diagnosticDataBuffer, frame->data, frame->dlc);\n\n    g_diagContext.dataReceivedLength = frame->dlc;\n    g_diagContext.processingActive = true;\n    g_diagContext.currentServiceId = g_diagContext.diagnosticDataBuffer[0];\n\n    if (g_diagContext.currentServiceId == 0x22) {\n        // Process data identifier request\n    } else if (g_diagContext.currentServiceId == 0x2E) {\n        // Process write request\n    }\n\n    return 0;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define ENGINE_CONFIG_BUFFER_SIZE 64\n#define TRANSMISSION_CONFIG_BUFFER_SIZE 32\n#define BRAKE_CONFIG_BUFFER_SIZE 48\n#define INFOTAINMENT_CONFIG_BUFFER_SIZE 128\n\nstatic uint8_t g_engineConfig[ENGINE_CONFIG_BUFFER_SIZE];\nstatic uint8_t g_transmissionConfig[TRANSMISSION_CONFIG_BUFFER_SIZE];\nstatic uint8_t g_brakeConfig[BRAKE_CONFIG_BUFFER_SIZE];\nstatic uint8_t g_infotainmentConfig[INFOTAINMENT_CONFIG_BUFFER_SIZE];\n\ntypedef enum {\n    PARAM_ENGINE = 0,\n    PARAM_TRANSMISSION = 1,\n    PARAM_BRAKE = 2,\n    PARAM_INFOTAINMENT = 3,\n    PARAM_MAX_ID = 4\n} VehicleParamID;\n\nvoid initVehicleConfigBuffers() {\n    memset(g_engineConfig, 0, ENGINE_CONFIG_BUFFER_SIZE);\n    memset(g_transmissionConfig, 0, TRANSMISSION_CONFIG_BUFFER_SIZE);\n    memset(g_brakeConfig, 0, BRAKE_CONFIG_BUFFER_SIZE);\n    memset(g_infotainmentConfig, 0, INFOTAINMENT_CONFIG_BUFFER_SIZE);\n}\n\nint updateVehicleParameter(uint8_t param_id, uint8_t offset, uint8_t length, const uint8_t* data) {\n    if (data == NULL || length == 0) {\n        return -1;\n    }\n    if (param_id >= PARAM_MAX_ID) {\n        return -2;\n    }\n\n    uint8_t* target_buffer = NULL;\n    uint16_t buffer_size = 0;\n    \n    switch (param_id) {\n        case PARAM_ENGINE:\n            target_buffer = g_engineConfig;\n            buffer_size = ENGINE_CONFIG_BUFFER_SIZE;\n            break;\n        case PARAM_TRANSMISSION:\n            target_buffer = g_transmissionConfig;\n            buffer_size = TRANSMISSION_CONFIG_BUFFER_SIZE;\n            break;\n        case PARAM_BRAKE:\n            target_buffer = g_brakeConfig;\n            buffer_size = BRAKE_CONFIG_BUFFER_SIZE;\n            break;\n        case PARAM_INFOTAINMENT:\n            target_buffer = g_infotainmentConfig;\n            buffer_size = INFOTAINMENT_CONFIG_BUFFER_SIZE;\n            break;\n        default:\n            return -3;\n    }\n\n    if (offset >= buffer_size) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < length; ++i) {\n        target_buffer[offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticCommand(const uint8_t* command_packet, uint16_t packet_len) {\n    if (command_packet == NULL || packet_len < 3) {\n        return;\n    }\n\n    uint8_t param_id = command_packet[0];\n    uint8_t offset = command_packet[1];\n    uint8_t length = command_packet[2];\n    const uint8_t* data = command_packet + 3;\n\n    if (3 + length > packet_len) {\n        return;\n    }\n\n    updateVehicleParameter(param_id, offset, length, data);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define NUM_SENSOR_TYPES_FIXED        8\n#define NUM_CALIB_SUBTYPES_FIXED      4\n#define TOTAL_CALIBRATION_ENTRIES_FIXED (NUM_SENSOR_TYPES_FIXED * NUM_CALIB_SUBTYPES_FIXED)\n\ntypedef struct {\n    int16_t offset_value;\n    uint16_t gain_factor;\n    uint8_t crc_check;\n} SensorCalibrationData_Fixed;\n\nstatic SensorCalibrationData_Fixed g_sensorCalibrationTable_fixed[TOTAL_CALIBRATION_ENTRIES_FIXED];\n\nvoid logSensorError_fixed(const char* msg) {\n}\n\nuint8_t receiveSensorConfigPacket_fixed() {\n    return 0x74;\n}\n\nvoid initializeCalibrationData_fixed() {\n    for (uint8_t i = 0; i < TOTAL_CALIBRATION_ENTRIES_FIXED; ++i) {\n        g_sensorCalibrationTable_fixed[i].offset_value = (int16_t)(i * 10);\n        g_sensorCalibrationTable_fixed[i].gain_factor = (uint16_t)(1000 + i);\n        g_sensorCalibrationTable_fixed[i].crc_check = (uint8_t)(i % 255);\n    }\n    logSensorError_fixed(\"Sensor calibration data initialized.\");\n}\n\nvoid applySensorCalibration_fixed() {\n    uint8_t config_byte = receiveSensorConfigPacket_fixed();\n\n    uint8_t sensor_id = (config_byte >> 4) & 0x0F;\n    uint8_t calibration_subtype = config_byte & 0x0F;\n\n    if (sensor_id < NUM_SENSOR_TYPES_FIXED) {\n        if (calibration_subtype < NUM_CALIB_SUBTYPES_FIXED) {\n            uint16_t array_index = (uint16_t)(sensor_id * NUM_CALIB_SUBTYPES_FIXED) + calibration_subtype;\n            \n            SensorCalibrationData_Fixed current_calib = g_sensorCalibrationTable_fixed[array_index];\n            logSensorError_fixed(\"Calibration applied from sensor config.\");\n        } else {\n            logSensorError_fixed(\"Invalid calibration subtype in config packet. Subtype out of range.\");\n        }\n    } else {\n        logSensorError_fixed(\"Invalid sensor ID in config packet.\");\n    }\n}\n\nvoid sensorManagementMain_fixed() {\n    initializeCalibrationData_fixed();\n    applySensorCalibration_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_DIAG_MESSAGE_TYPES 10\n#define DIAG_DATA_BUFFER_SIZE 32\n\ntypedef struct {\n    uint8_t messageType;\n    uint8_t payload[DIAG_DATA_BUFFER_SIZE];\n    uint8_t payload_len;\n} DiagnosticMessage;\n\nstatic uint32_t g_diagCounters[MAX_DIAG_MESSAGE_TYPES];\nstatic uint16_t g_diagData[MAX_DIAG_MESSAGE_TYPES][DIAG_DATA_BUFFER_SIZE];\n\nvoid logDiagnosticError(const char* msg) {\n}\n\nDiagnosticMessage receiveDiagnosticMessage_vulnerable() {\n    DiagnosticMessage msg;\n    msg.messageType = MAX_DIAG_MESSAGE_TYPES;\n    msg.payload_len = 4;\n    msg.payload[0] = 0xAA;\n    msg.payload[1] = 0xBB;\n    msg.payload[2] = 0xCC;\n    msg.payload[3] = 0xDD;\n    return msg;\n}\n\nvoid processDiagnosticMessage_vulnerable() {\n    DiagnosticMessage msg = receiveDiagnosticMessage_vulnerable();\n\n    g_diagCounters[msg.messageType]++;\n\n    for (uint8_t i = 0; i < msg.payload_len; ++i) {\n        if (i < DIAG_DATA_BUFFER_SIZE) {\n            g_diagData[msg.messageType][i] = msg.payload[i];\n        }\n    }\n}\n\nvoid initializeDiagnosticSystem_vulnerable() {\n    for (uint8_t i = 0; i < MAX_DIAG_MESSAGE_TYPES; ++i) {\n        g_diagCounters[i] = 0;\n        for (uint8_t j = 0; j < DIAG_DATA_BUFFER_SIZE; ++j) {\n            g_diagData[i][j] = 0;\n        }\n    }\n}\n\nvoid diagnosticSystem_vulnerable_main() {\n    initializeDiagnosticSystem_vulnerable();\n    processDiagnosticMessage_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_VEHICLE_LIGHT_TYPES 5\n\ntypedef enum {\n    LIGHT_TYPE_HEADLIGHTS = 0,\n    LIGHT_TYPE_TAILLIGHTS = 1,\n    LIGHT_TYPE_FOGLIGHTS = 2,\n    LIGHT_TYPE_INTERIOR = 3,\n    LIGHT_TYPE_INDICATORS = 4,\n    LIGHT_TYPE_COUNT = 5\n} VehicleLightType;\n\ntypedef enum {\n    LIGHT_ACTION_OFF = 0,\n    LIGHT_ACTION_ON = 1,\n    LIGHT_ACTION_HIGH_BEAM = 2,\n    LIGHT_ACTION_LOW_BEAM = 3,\n    LIGHT_ACTION_DIM = 4,\n    LIGHT_ACTION_FLASH = 5,\n    LIGHT_ACTION_MAX_VALUE = 5\n} LightActionState;\n\nvoid performHeadlightAction(LightActionState action) {\n    printf(\"Headlight action: %d\\n\", action);\n}\nvoid performTaillightAction(LightActionState action) {\n    printf(\"Taillight action: %d\\n\", action);\n}\nvoid performFoglightAction(LightActionState action) {\n    printf(\"Foglight action: %d\\n\", action);\n}\nvoid performInteriorLightAction(LightActionState action) {\n    printf(\"Interior Light action: %d\\n\", action);\n}\nvoid performIndicatorAction(LightActionState action) {\n    printf(\"Indicator action: %d\\n\", action);\n}\n\ntypedef void (*LightSpecificActionFunction)(LightActionState action);\n\nstatic LightSpecificActionFunction g_lightTypeActionDispatch_vulnerable[MAX_VEHICLE_LIGHT_TYPES];\n\nstatic const LightActionState g_validHeadlightActions[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON, LIGHT_ACTION_HIGH_BEAM, LIGHT_ACTION_LOW_BEAM};\nstatic const LightActionState g_validTaillightActions[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON, LIGHT_ACTION_FLASH};\nstatic const LightActionState g_validFoglightActions[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON};\nstatic const LightActionState g_validInteriorLightActions[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON, LIGHT_ACTION_DIM};\nstatic const LightActionState g_validIndicatorActions[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON, LIGHT_ACTION_FLASH};\n\ntypedef struct {\n    const LightActionState* actions;\n    uint8_t count;\n} LightActionSetInfo;\n\nstatic LightActionSetInfo g_lightActionSets_vulnerable[MAX_VEHICLE_LIGHT_TYPES];\n\nvoid initializeLightManagement_vulnerable() {\n    g_lightTypeActionDispatch_vulnerable[LIGHT_TYPE_HEADLIGHTS] = performHeadlightAction;\n    g_lightTypeActionDispatch_vulnerable[LIGHT_TYPE_TAILLIGHTS] = performTaillightAction;\n    g_lightTypeActionDispatch_vulnerable[LIGHT_TYPE_FOGLIGHTS] = performFoglightAction;\n    g_lightTypeActionDispatch_vulnerable[LIGHT_TYPE_INTERIOR] = performInteriorLightAction;\n    g_lightTypeActionDispatch_vulnerable[LIGHT_TYPE_INDICATORS] = performIndicatorAction;\n\n    g_lightActionSets_vulnerable[LIGHT_TYPE_HEADLIGHTS] = (LightActionSetInfo){g_validHeadlightActions, sizeof(g_validHeadlightActions) / sizeof(g_validHeadlightActions[0])};\n    g_lightActionSets_vulnerable[LIGHT_TYPE_TAILLIGHTS] = (LightActionSetInfo){g_validTaillightActions, sizeof(g_validTaillightActions) / sizeof(g_validTaillightActions[0])};\n    g_lightActionSets_vulnerable[LIGHT_TYPE_FOGLIGHTS] = (LightActionSetInfo){g_validFoglightActions, sizeof(g_validFoglightActions) / sizeof(g_validFoglightActions[0])};\n    g_lightActionSets_vulnerable[LIGHT_TYPE_INTERIOR] = (LightActionSetInfo){g_validInteriorLightActions, sizeof(g_validInteriorLightActions) / sizeof(g_validInteriorLightActions[0])};\n    g_lightActionSets_vulnerable[LIGHT_TYPE_INDICATORS] = (LightActionSetInfo){g_validIndicatorActions, sizeof(g_validIndicatorActions) / sizeof(g_validIndicatorActions[0])};\n}\n\ntypedef struct {\n    uint8_t light_type_id;\n    uint8_t action_list_idx;\n} LightControlCommand_vulnerable;\n\nLightControlCommand_vulnerable receiveLightCommand_vulnerable() {\n    LightControlCommand_vulnerable cmd;\n    cmd.light_type_id = LIGHT_TYPE_FOGLIGHTS;\n    cmd.action_list_idx = 2;\n    return cmd;\n}\n\nvoid logVehicleLightError_vulnerable(const char* msg) {\n    printf(\"LIGHT_ERR_VULN: %s\\n\", msg);\n}\n\nvoid processLightCommand_vulnerable() {\n    LightControlCommand_vulnerable cmd = receiveLightCommand_vulnerable();\n\n    if (cmd.light_type_id < LIGHT_TYPE_COUNT) {\n        if (cmd.action_list_idx <= LIGHT_ACTION_MAX_VALUE) {\n            LightActionState action_to_perform = g_lightActionSets_vulnerable[cmd.light_type_id].actions[cmd.action_list_idx];\n            g_lightTypeActionDispatch_vulnerable[cmd.light_type_id](action_to_perform);\n            printf(\"Light command processed (vulnerable).\\n\");\n        } else {\n            logVehicleLightError_vulnerable(\"Requested action value out of global enum range.\");\n        }\n    } else {\n        logVehicleLightError_vulnerable(\"Invalid light type ID received.\");\n    }\n}\n\nvoid vehicleLightManagerMain_vulnerable() {\n    initializeLightManagement_vulnerable();\n    processLightCommand_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n// Define maximum sizes for different types of recorded data\n#define VEHICLE_EVENTS_MAX_ENTRIES 50\n#define EVENT_ENTRY_SIZE_BYTES 12 // Each event entry is 12 bytes\n#define DIAG_SNAPSHOTS_MAX_ENTRIES 10\n#define SNAPSHOT_ENTRY_SIZE_BYTES 32 // Each snapshot entry is 32 bytes\n#define USER_LOGS_MAX_ENTRIES 20\n#define USER_LOG_ENTRY_SIZE_BYTES 8 // Each user log entry is 8 bytes\n\n// Total buffer size for all recorded data, ensuring contiguous allocation\n#define TOTAL_RECORDER_BUFFER_SIZE \\\n    (VEHICLE_EVENTS_MAX_ENTRIES * EVENT_ENTRY_SIZE_BYTES + \\\n     DIAG_SNAPSHOTS_MAX_ENTRIES * SNAPSHOT_ENTRY_SIZE_BYTES + \\\n     USER_LOGS_MAX_ENTRIES * USER_LOG_ENTRY_SIZE_BYTES)\n\n// Global buffer where all VDR data is stored contiguously\nstatic uint8_t g_vdrDataBuffer[TOTAL_RECORDER_BUFFER_SIZE];\n\n// Enums for different data types, mapping to specific segments within the global buffer\ntypedef enum {\n    VDR_DATA_TYPE_VEHICLE_EVENTS = 0,\n    VDR_DATA_TYPE_DIAG_SNAPSHOTS,\n    VDR_DATA_TYPE_USER_LOGS,\n    VDR_DATA_TYPE_COUNT // Total number of distinct VDR data types\n} VDRDataType;\n\n// Structure to define segments within the global VDR buffer\ntypedef struct {\n    uint16_t base_offset;      // Start offset of this data type's segment in g_vdrDataBuffer\n    uint16_t entry_size;       // Size of a single entry for this data type\n    uint16_t max_entries;      // Maximum number of entries for this data type in its segment\n    uint16_t current_entries;  // Current number of entries stored for this data type\n} VDRSegmentInfo;\n\n// Array of segment information, one for each VDRDataType\nstatic VDRSegmentInfo g_vdrSegments[VDR_DATA_TYPE_COUNT];\n\n// Initializes the VDR system and configures segment offsets and sizes\nvoid initVDRSystem() {\n    memset(g_vdrDataBuffer, 0, TOTAL_RECORDER_BUFFER_SIZE);\n\n    uint16_t current_offset = 0;\n\n    // Initialize VEHICLE_EVENTS segment\n    g_vdrSegments[VDR_DATA_TYPE_VEHICLE_EVENTS].base_offset = current_offset;\n    g_vdrSegments[VDR_DATA_TYPE_VEHICLE_EVENTS].entry_size = EVENT_ENTRY_SIZE_BYTES;\n    g_vdrSegments[VDR_DATA_TYPE_VEHICLE_EVENTS].max_entries = VEHICLE_EVENTS_MAX_ENTRIES;\n    g_vdrSegments[VDR_DATA_TYPE_VEHICLE_EVENTS].current_entries = 0;\n    current_offset += VEHICLE_EVENTS_MAX_ENTRIES * EVENT_ENTRY_SIZE_BYTES;\n\n    // Initialize DIAG_SNAPSHOTS segment\n    g_vdrSegments[VDR_DATA_TYPE_DIAG_SNAPSHOTS].base_offset = current_offset;\n    g_vdrSegments[VDR_DATA_TYPE_DIAG_SNAPSHOTS].entry_size = SNAPSHOT_ENTRY_SIZE_BYTES;\n    g_vdrSegments[VDR_DATA_TYPE_DIAG_SNAPSHOTS].max_entries = DIAG_SNAPSHOTS_MAX_ENTRIES;\n    g_vdrSegments[VDR_DATA_TYPE_DIAG_SNAPSHOTS].current_entries = 0;\n    current_offset += DIAG_SNAPSHOTS_MAX_ENTRIES * SNAPSHOT_ENTRY_SIZE_BYTES;\n\n    // Initialize USER_LOGS segment\n    g_vdrSegments[VDR_DATA_TYPE_USER_LOGS].base_offset = current_offset;\n    g_vdrSegments[VDR_DATA_TYPE_USER_LOGS].entry_size = USER_LOG_ENTRY_SIZE_BYTES;\n    g_vdrSegments[VDR_DATA_TYPE_USER_LOGS].max_entries = USER_LOGS_MAX_ENTRIES;\n    g_vdrSegments[VDR_DATA_TYPE_USER_LOGS].current_entries = 0;\n    // current_offset += USER_LOGS_MAX_ENTRIES * USER_LOG_ENTRY_SIZE_BYTES; // Final offset not needed\n}\n\n// Stores event data into the appropriate VDR segment based on type and index.\n// type: The VDRDataType indicating which segment to target.\n// entry_index: The specific entry slot within that data type's segment.\n// data: Pointer to the raw data payload to store.\n// data_len: The actual length of the raw data payload.\nint storeVDRDataEntry(VDRDataType type, uint16_t entry_index, const uint8_t* data, uint16_t data_len) {\n    if (type >= VDR_DATA_TYPE_COUNT || data == NULL) {\n        return -1; // Invalid type or data pointer\n    }\n\n    VDRSegmentInfo* segment = &g_vdrSegments[type];\n\n    // Check if the entry_index is valid for this segment's allocated entries\n    if (entry_index >= segment->max_entries) {\n        return -2; // Entry index out of bounds for this specific segment\n    }\n\n    // Calculate the absolute start offset for the target entry within the global buffer\n    uint16_t target_global_offset = segment->base_offset + (entry_index * segment->entry_size);\n\n    // VULNERABILITY:\n    // This check validates `data_len` against the `TOTAL_RECORDER_BUFFER_SIZE`,\n    // which is a common but insufficient check. It does NOT ensure that `data_len`\n    // fits within the specific `segment->entry_size` of the target slot.\n    // An attacker can provide a `data_len` greater than `segment->entry_size` (e.g., 15 bytes for an 8-byte log entry)\n    // but still less than `TOTAL_RECORDER_BUFFER_SIZE`, leading to an out-of-bounds write\n    // into the subsequent entry's memory, or even into a different segment.\n    if (data_len > TOTAL_RECORDER_BUFFER_SIZE) { \n        return -3; // Data length too large for the entire recorder buffer (overall check)\n    }\n\n    // The loop iterates `data_len` times. If `data_len` is greater than `segment->entry_size`,\n    // it will write past the end of the intended entry slot.\n    for (uint16_t i = 0; i < data_len; ++i) {\n        g_vdrDataBuffer[target_global_offset + i] = data[i];\n    }\n    \n    // Update current_entries. This is a simplistic update; an overflow could still\n    // cause data corruption in a way that this count doesn't directly reflect.\n    if (entry_index >= segment->current_entries) {\n        segment->current_entries = entry_index + 1;\n    }\n\n    return 0; // Success\n}\n\n// Example usage context to demonstrate the vulnerability\nvoid recordVehicleDiagnostics() {\n    initVDRSystem();\n\n    // Store a legitimate vehicle event (12 bytes)\n    uint8_t event_data[EVENT_ENTRY_SIZE_BYTES];\n    memset(event_data, 0x11, EVENT_ENTRY_SIZE_BYTES);\n    storeVDRDataEntry(VDR_DATA_TYPE_VEHICLE_EVENTS, 0, event_data, EVENT_ENTRY_SIZE_BYTES);\n\n    // Store a legitimate diagnostic snapshot (32 bytes)\n    uint8_t snapshot_data[SNAPSHOT_ENTRY_SIZE_BYTES];\n    memset(snapshot_data, 0x22, SNAPSHOT_ENTRY_SIZE_BYTES);\n    storeVDRDataEntry(VDR_DATA_TYPE_DIAG_SNAPSHOTS, 0, snapshot_data, SNAPSHOT_ENTRY_SIZE_BYTES);\n\n    // Simulate an attacker providing overly long data for a smaller slot.\n    // USER_LOG_ENTRY_SIZE_BYTES is 8 bytes.\n    // By providing 15 bytes, the extra 7 bytes will overflow into the next user log entry slot.\n    uint8_t malicious_log_data[15]; \n    memset(malicious_log_data, 0xEE, 15); // Fill with attacker-controlled data\n    // This call is vulnerable: `data_len` (15) > `USER_LOG_ENTRY_SIZE_BYTES` (8)\n    // The check `data_len > TOTAL_RECORDER_BUFFER_SIZE` passes, but it overflows the specific 8-byte slot.\n    storeVDRDataEntry(VDR_DATA_TYPE_USER_LOGS, 0, malicious_log_data, 15);\n\n    // Even if we try to write a legitimate log entry next, its data might be partially corrupted\n    // by the previous overflow from the 'malicious_log_data'.\n    uint8_t legit_log_data[USER_LOG_ENTRY_SIZE_BYTES];\n    memset(legit_log_data, 0xAA, USER_LOG_ENTRY_SIZE_BYTES);\n    storeVDRDataEntry(VDR_DATA_TYPE_USER_LOGS, 1, legit_log_data, USER_LOG_ENTRY_SIZE_BYTES);\n}\n\n// Helper function to retrieve data for verification (not part of vulnerability)\nuint8_t retrieveVDRDataByte(VDRDataType type, uint16_t entry_index, uint16_t offset_in_entry) {\n    if (type >= VDR_DATA_TYPE_COUNT || entry_index >= g_vdrSegments[type].max_entries || offset_in_entry >= g_vdrSegments[type].entry_size) {\n        return 0x00; // Invalid access or out of bounds for the logical entry\n    }\n    uint16_t global_offset = g_vdrSegments[type].base_offset + (entry_index * g_vdrSegments[type].entry_size) + offset_in_entry;\n    if (global_offset < TOTAL_RECORDER_BUFFER_SIZE) {\n        return g_vdrDataBuffer[global_offset];\n    }\n    return 0x00; // Global buffer access out of bounds\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define FAULT_HISTORY_SIZE 10\n#define FAULT_CODE_MAX_LEN 8\n\ntypedef struct {\n    uint32_t timestamp;\n    char code[FAULT_CODE_MAX_LEN];\n    uint8_t severity;\n    bool active;\n} FaultEntry;\n\nstatic FaultEntry g_fault_history_fixed[FAULT_HISTORY_SIZE];\nstatic uint16_t g_next_write_idx_fixed = 0;\nstatic uint16_t g_num_logged_faults_fixed = 0;\n\nvoid init_fault_history_fixed() {\n    memset(g_fault_history_fixed, 0, sizeof(g_fault_history_fixed));\n    g_next_write_idx_fixed = 0;\n    g_num_logged_faults_fixed = 0;\n}\n\nvoid add_fault_entry_fixed(uint32_t timestamp, const char* code, uint8_t severity) {\n    if (g_num_logged_faults_fixed < FAULT_HISTORY_SIZE) {\n        g_num_logged_faults_fixed++;\n    }\n    \n    FaultEntry* entry = &g_fault_history_fixed[g_next_write_idx_fixed];\n    entry->timestamp = timestamp;\n    strncpy(entry->code, code, FAULT_CODE_MAX_LEN - 1);\n    entry->code[FAULT_CODE_MAX_LEN - 1] = '\\0';\n    entry->severity = severity;\n    entry->active = true;\n\n    g_next_write_idx_fixed = (g_next_write_idx_fixed + 1) % FAULT_HISTORY_SIZE;\n}\n\nvoid clear_recent_faults_fixed(uint16_t num_to_clear) {\n    if (g_num_logged_faults_fixed == 0 || num_to_clear == 0) {\n        return;\n    }\n\n    uint16_t actual_clear_count = (num_to_clear > g_num_logged_faults_fixed) ? g_num_logged_faults_fixed : num_to_clear;\n\n    uint16_t last_fault_idx_phys;\n    if (g_next_write_idx_fixed == 0) {\n        last_fault_idx_phys = FAULT_HISTORY_SIZE - 1;\n    } else {\n        last_fault_idx_phys = g_next_write_idx_fixed - 1;\n    }\n\n    for (uint16_t i = 0; i < actual_clear_count; ++i) {\n        uint16_t target_phys_idx = (last_fault_idx_phys - i + FAULT_HISTORY_SIZE) % FAULT_HISTORY_SIZE;\n        \n        g_fault_history_fixed[target_phys_idx].active = false;\n        g_fault_history_fixed[target_phys_idx].severity = 0;\n    }\n    \n    g_num_logged_faults_fixed -= actual_clear_count;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n// Represents a firmware update packet header\nstruct FirmwarePacketHeader {\n    uint32_t packet_magic;\n    uint32_t total_data_payload_size; \n    uint16_t num_modules;\n    uint8_t  _reserved[2];\n};\n\n// Represents a header for an individual firmware module within the payload\nstruct FirmwareModuleHeader {\n    uint16_t module_id;\n    uint16_t module_version;\n    uint32_t module_data_length;\n};\n\nclass FirmwareUpdater {\nprivate:\n    uint8_t* m_firmware_buffer;\n    size_t   m_allocated_size;\n\npublic:\n    FirmwareUpdater() : m_firmware_buffer(nullptr), m_allocated_size(0) {}\n\n    ~FirmwareUpdater() {\n        if (m_firmware_buffer) {\n            free(m_firmware_buffer);\n        }\n    }\n\n    void clearFirmwareBuffer() {\n        if (m_firmware_buffer) {\n            free(m_firmware_buffer);\n            m_firmware_buffer = nullptr;\n            m_allocated_size = 0;\n        }\n    }\n\n    bool processFirmwareUpdatePacketVulnerable(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(FirmwarePacketHeader)) {\n            return false;\n        }\n\n        const FirmwarePacketHeader* header = reinterpret_cast<const FirmwarePacketHeader*>(packet_data);\n\n        // Initial sanity check: Is the claimed total payload size within packet bounds?\n        // This check is insufficient for the heap overflow as the sum of module lengths might differ.\n        if (header->total_data_payload_size > (packet_length - sizeof(FirmwarePacketHeader))) {\n            return false;\n        }\n\n        clearFirmwareBuffer();\n\n        // Allocate buffer based on the total_data_payload_size from the packet header\n        m_firmware_buffer = (uint8_t*)malloc(header->total_data_payload_size);\n        if (!m_firmware_buffer) {\n            return false;\n        }\n        m_allocated_size = header->total_data_payload_size;\n\n        size_t current_packet_offset = sizeof(FirmwarePacketHeader);\n        size_t current_buffer_write_offset = 0;\n\n        for (uint16_t i = 0; i < header->num_modules; ++i) {\n            // Check if there's enough data in the raw packet for the module header\n            if (current_packet_offset + sizeof(FirmwareModuleHeader) > packet_length) {\n                clearFirmwareBuffer();\n                return false;\n            }\n\n            const FirmwareModuleHeader* module_hdr = reinterpret_cast<const FirmwareModuleHeader*>(packet_data + current_packet_offset);\n\n            // Advance packet offset past the module header\n            current_packet_offset += sizeof(FirmwareModuleHeader);\n            \n            // Check if there's enough data in the raw packet for the module's payload\n            if (current_packet_offset + module_hdr->module_data_length > packet_length) {\n                clearFirmwareBuffer();\n                return false;\n            }\n            \n            // Vulnerability: No check here that (current_buffer_write_offset + module_hdr->module_data_length)\n            // doesn't exceed m_allocated_size (which is header->total_data_payload_size).\n            // An attacker can craft a packet where the sum of module_hdr->module_data_length values\n            // for all modules exceeds header->total_data_payload_size, leading to a heap overflow\n            // during the memcpy, even if individual module_data_length values don't exceed\n            // the remaining packet length at that point.\n            memcpy(m_firmware_buffer + current_buffer_write_offset,\n                   packet_data + current_packet_offset,\n                   module_hdr->module_data_length);\n\n            current_packet_offset += module_hdr->module_data_length;\n            current_buffer_write_offset += module_hdr->module_data_length;\n        }\n        \n        // A check for current_buffer_write_offset > m_allocated_size here would be too late.\n\n        return true;\n    }\n\n    size_t getAllocatedFirmwareSize() const {\n        return m_allocated_size;\n    }\n\n    const uint8_t* getFirmwareBuffer() const {\n        return m_firmware_buffer;\n    }\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_SENSOR_READINGS 100\n\ntypedef struct {\n    uint16_t value;\n    uint16_t timestamp_ms;\n} SensorReading;\n\nstatic SensorReading g_sensor_readings_buffer[MAX_SENSOR_READINGS];\nstatic uint32_t g_num_readings_stored = 0;\n\nvoid init_sensor_buffer() {\n    memset(g_sensor_readings_buffer, 0, sizeof(g_sensor_readings_buffer));\n    g_num_readings_stored = 0;\n}\n\nvoid add_sensor_reading(uint16_t value, uint16_t timestamp) {\n    if (g_num_readings_stored < MAX_SENSOR_READINGS) {\n        g_sensor_readings_buffer[g_num_readings_stored].value = value;\n        g_sensor_readings_buffer[g_num_readings_stored].timestamp_ms = timestamp;\n        g_num_readings_stored++;\n    }\n}\n\nvoid process_reading(SensorReading* reading) {\n    if (reading != NULL) {\n        volatile uint16_t val = reading->value;\n        (void)val;\n    }\n}\n\nvoid invalidate_old_sensor_readings_vulnerable(uint32_t offset_from_end, uint32_t num_to_invalidate) {\n    if (g_num_readings_stored == 0 || num_to_invalidate == 0) {\n        return;\n    }\n\n    // Calculate the starting pointer for invalidation.\n    // 'g_num_readings_stored - 1' gives the index of the last valid reading.\n    // Subtracting 'offset_from_end' from this pointer can cause it to point\n    // before the beginning of the 'g_sensor_readings_buffer' array if 'offset_from_end'\n    // is greater than the current valid range.\n    SensorReading* current_ptr = &g_sensor_readings_buffer[g_num_readings_stored - 1];\n    current_ptr -= offset_from_end; // VULNERABILITY: 'current_ptr' can become negative (underflow) here.\n\n    // Iterate 'num_to_invalidate' times, writing to the potentially underflowed pointer.\n    // If 'current_ptr' is before the buffer, these writes will be buffer underwrites.\n    for (uint32_t i = 0; i < num_to_invalidate; ++i) {\n        // The write occurs here. If 'current_ptr' points before the buffer,\n        // this operation will underwrite memory.\n        current_ptr->value = 0xDEAD;       \n        current_ptr->timestamp_ms = 0xDEFE;\n        current_ptr++;                     \n    }\n\n    // Adjust the number of stored readings based on what was *intended* to be invalidated.\n    // This part is conceptually separate from the underwrite, but part of the overall logic.\n    if (g_num_readings_stored > (offset_from_end + num_to_invalidate)) {\n        g_num_readings_stored -= (offset_from_end + num_to_invalidate);\n    } else {\n        g_num_readings_stored = 0;\n    }\n\n    if (g_num_readings_stored > 0) {\n        process_reading(&g_sensor_readings_buffer[0]);\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_SEATS 4\n#define MAX_SEAT_FEATURES 3\n\ntypedef enum {\n    SEAT_FEATURE_HEATING = 0,\n    SEAT_FEATURE_VENTILATION,\n    SEAT_FEATURE_MASSAGE,\n    SEAT_FEATURE_COUNT\n} SeatFeatureType;\n\ntypedef struct {\n    uint8_t current_level[MAX_SEAT_FEATURES];\n    bool    feature_enabled[MAX_SEAT_FEATURES];\n    uint16_t temperature_setting;\n} SeatControlUnit;\n\nstatic SeatControlUnit g_seatUnits[MAX_VEHICLE_SEATS];\n\nvoid logSeatControlError(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t seat_id;\n    uint8_t feature_id;\n    uint8_t new_level;\n    uint8_t command_type;\n} SeatCommand;\n\nSeatCommand receiveSeatCommand_vulnerable() {\n    SeatCommand cmd;\n    cmd.seat_id = 0;\n    cmd.feature_id = SEAT_FEATURE_COUNT; \n    cmd.new_level = 5;\n    cmd.command_type = 0x01;\n    return cmd;\n}\n\nvoid initializeSeatControl_vulnerable() {\n    for (int i = 0; i < MAX_VEHICLE_SEATS; ++i) {\n        for (int j = 0; j < MAX_SEAT_FEATURES; ++j) {\n            g_seatUnits[i].current_level[j] = 0;\n            g_seatUnits[i].feature_enabled[j] = false;\n        }\n        g_seatUnits[i].temperature_setting = 20;\n    }\n}\n\nvoid processSeatCommand_vulnerable() {\n    SeatCommand cmd = receiveSeatCommand_vulnerable();\n\n    if (cmd.seat_id < MAX_VEHICLE_SEATS) {\n        g_seatUnits[cmd.seat_id].current_level[cmd.feature_id] = cmd.new_level;\n    } else {\n        logSeatControlError(\"Invalid seat ID received. Command ignored.\");\n    }\n}\n\nvoid seatControlMain_vulnerable() {\n    initializeSeatControl_vulnerable();\n    processSeatCommand_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define FAULT_HISTORY_SIZE 10\n#define FAULT_CODE_MAX_LEN 8\n\ntypedef struct {\n    uint32_t timestamp;\n    char code[FAULT_CODE_MAX_LEN];\n    uint8_t severity;\n    bool active;\n} FaultEntry;\n\nstatic FaultEntry g_fault_history[FAULT_HISTORY_SIZE];\nstatic uint16_t g_next_write_idx = 0;\nstatic uint16_t g_num_logged_faults = 0;\n\nvoid init_fault_history_vulnerable() {\n    memset(g_fault_history, 0, sizeof(g_fault_history));\n    g_next_write_idx = 0;\n    g_num_logged_faults = 0;\n}\n\nvoid add_fault_entry_vulnerable(uint32_t timestamp, const char* code, uint8_t severity) {\n    if (g_num_logged_faults < FAULT_HISTORY_SIZE) {\n        g_num_logged_faults++;\n    }\n    \n    FaultEntry* entry = &g_fault_history[g_next_write_idx];\n    entry->timestamp = timestamp;\n    strncpy(entry->code, code, FAULT_CODE_MAX_LEN - 1);\n    entry->code[FAULT_CODE_MAX_LEN - 1] = '\\0';\n    entry->severity = severity;\n    entry->active = true;\n\n    g_next_write_idx = (g_next_write_idx + 1) % FAULT_HISTORY_SIZE;\n}\n\nvoid clear_recent_faults_vulnerable(uint16_t num_to_clear) {\n    if (g_num_logged_faults == 0 || num_to_clear == 0) {\n        return;\n    }\n\n    uint16_t actual_clear_count = (num_to_clear > g_num_logged_faults) ? g_num_logged_faults : num_to_clear;\n\n    int32_t last_fault_idx_phys = (g_next_write_idx == 0) ? (FAULT_HISTORY_SIZE - 1) : (g_next_write_idx - 1);\n\n    for (uint16_t i = 0; i < actual_clear_count; ++i) {\n        int32_t target_phys_idx = last_fault_idx_phys - i;\n        \n        g_fault_history[target_phys_idx].active = false;\n        g_fault_history[target_phys_idx].severity = 0;\n    }\n    \n    g_num_logged_faults -= actual_clear_count;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_SEATS 4\n#define MAX_SEAT_FEATURES 3\n\ntypedef enum {\n    SEAT_FEATURE_HEATING = 0,\n    SEAT_FEATURE_VENTILATION,\n    SEAT_FEATURE_MASSAGE,\n    SEAT_FEATURE_COUNT\n} SeatFeatureType;\n\ntypedef struct {\n    uint8_t current_level[MAX_SEAT_FEATURES];\n    bool    feature_enabled[MAX_SEAT_FEATURES];\n    uint16_t temperature_setting;\n} SeatControlUnit;\n\nstatic SeatControlUnit g_seatUnits_fixed[MAX_VEHICLE_SEATS];\n\nvoid logSeatControlError_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t seat_id;\n    uint8_t feature_id;\n    uint8_t new_level;\n    uint8_t command_type;\n} SeatCommand;\n\nSeatCommand receiveSeatCommand_fixed() {\n    SeatCommand cmd;\n    cmd.seat_id = 0;\n    cmd.feature_id = SEAT_FEATURE_COUNT;\n    cmd.new_level = 5;\n    cmd.command_type = 0x01;\n    return cmd;\n}\n\nvoid initializeSeatControl_fixed() {\n    for (int i = 0; i < MAX_VEHICLE_SEATS; ++i) {\n        for (int j = 0; j < MAX_SEAT_FEATURES; ++j) {\n            g_seatUnits_fixed[i].current_level[j] = 0;\n            g_seatUnits_fixed[i].feature_enabled[j] = false;\n        }\n        g_seatUnits_fixed[i].temperature_setting = 20;\n    }\n}\n\nvoid processSeatCommand_fixed() {\n    SeatCommand cmd = receiveSeatCommand_fixed();\n\n    if (cmd.seat_id < MAX_VEHICLE_SEATS) {\n        if (cmd.feature_id < SEAT_FEATURE_COUNT) {\n            g_seatUnits_fixed[cmd.seat_id].current_level[cmd.feature_id] = cmd.new_level;\n        } else {\n            logSeatControlError_fixed(\"Invalid feature ID received. Command ignored.\");\n        }\n    } else {\n        logSeatControlError_fixed(\"Invalid seat ID received. Command ignored.\");\n    }\n}\n\nvoid seatControlMain_fixed() {\n    initializeSeatControl_fixed();\n    processSeatCommand_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_SENSOR_READINGS 64\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    int16_t  temperature_celsius;\n    uint16_t pressure_kpa;\n    uint8_t  sensor_status; \n} SensorReading;\n\nstatic SensorReading g_sensor_data_log_fixed[MAX_SENSOR_READINGS];\nstatic uint16_t g_current_log_size_fixed = 0; \n\nvoid init_sensor_log_fixed() {\n    memset(g_sensor_data_log_fixed, 0, sizeof(g_sensor_data_log_fixed));\n    g_current_log_size_fixed = 0;\n}\n\nbool add_sensor_reading_fixed(uint32_t ts, int16_t temp, uint16_t press, uint8_t status) {\n    if (g_current_log_size_fixed >= MAX_SENSOR_READINGS) {\n        return false; \n    }\n    g_sensor_data_log_fixed[g_current_log_size_fixed].timestamp_ms = ts;\n    g_sensor_data_log_fixed[g_current_log_size_fixed].temperature_celsius = temp;\n    g_sensor_data_log_fixed[g_current_log_size_fixed].pressure_kpa = press;\n    g_sensor_data_log_fixed[g_current_log_size_fixed].sensor_status = status;\n    g_current_log_size_fixed++;\n    return true;\n}\n\nvoid correct_sensor_readings_backward_fixed(uint16_t start_offset_from_end, uint16_t correction_window_size) {\n    if (g_current_log_size_fixed == 0 || correction_window_size == 0) {\n        return;\n    }\n\n    int32_t effective_start_idx = (int32_t)g_current_log_size_fixed - 1 - start_offset_from_end;\n\n    if (effective_start_idx < 0) {\n        return;\n    }\n\n    int32_t actual_window_size = (int32_t)correction_window_size;\n    if ((effective_start_idx - (actual_window_size - 1)) < 0) {\n        actual_window_size = effective_start_idx + 1;\n    }\n\n    for (int32_t i = 0; i < actual_window_size; ++i) {\n        int32_t current_idx = effective_start_idx - i;\n\n        if (current_idx >= (int32_t)g_current_log_size_fixed || current_idx < 0) { \n            continue;\n        }\n\n        if (g_sensor_data_log_fixed[current_idx].sensor_status == 1) { \n            if (current_idx + 1 < g_current_log_size_fixed) {\n                g_sensor_data_log_fixed[current_idx].temperature_celsius = g_sensor_data_log_fixed[current_idx+1].temperature_celsius;\n            } else if (current_idx - 1 >= 0) {\n                g_sensor_data_log_fixed[current_idx].temperature_celsius = g_sensor_data_log_fixed[current_idx-1].temperature_celsius;\n            } else {\n                g_sensor_data_log_fixed[current_idx].temperature_celsius = 0;\n            }\n        }\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nstruct ConfigEntryHeader {\n    uint16_t key_hash;\n    uint16_t value_length; \n};\n\nclass VehicleConfigStoreVulnerable {\npublic:\n    VehicleConfigStoreVulnerable(size_t initial_capacity_bytes)\n        : m_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {\n        if (initial_capacity_bytes > 0) {\n            m_buffer = (uint8_t*)malloc(initial_capacity_bytes);\n            if (m_buffer) {\n                m_allocated_capacity = initial_capacity_bytes;\n            }\n        }\n    }\n\n    ~VehicleConfigStoreVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    bool addConfigEntryVulnerable(uint16_t key_hash, const uint8_t* value_data, uint16_t len) {\n        if (!value_data || len == 0) {\n            return false;\n        }\n\n        size_t entry_data_size_needed = sizeof(ConfigEntryHeader) + len; \n\n        if (m_current_size + entry_data_size_needed > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity == 0 ? entry_data_size_needed : m_allocated_capacity * 2;\n            if (new_capacity < m_current_size + entry_data_size_needed) {\n                new_capacity = m_current_size + entry_data_size_needed;\n            }\n            \n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_capacity);\n            if (!new_buffer) {\n                if (m_buffer) free(m_buffer);\n                m_buffer = nullptr;\n                m_current_size = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        if (!m_buffer) {\n            return false;\n        }\n\n        ConfigEntryHeader header = {key_hash, len};\n        memcpy(m_buffer + m_current_size, &header, sizeof(ConfigEntryHeader));\n        \n        memcpy(m_buffer + m_current_size + sizeof(ConfigEntryHeader), value_data, len);\n\n        m_buffer[m_current_size + sizeof(ConfigEntryHeader) + len] = '\\0';\n\n        m_current_size += entry_data_size_needed; \n\n        return true;\n    }\n\n    const uint8_t* getRawBuffer() const { return m_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n// Max number of distinct sensor data types\n#define MAX_SENSORS 4\n\n// Fixed size buffer for each sensor's aggregated data\n// This is intentionally smaller than MAX_TELEMETRY_PACKET_PAYLOAD\n#define SENSOR_DATA_BUFFER_SIZE 32\n\n// Maximum payload size for an incoming telemetry packet\n// This represents the maximum data that can be carried by the communication protocol.\n#define MAX_TELEMETRY_PACKET_PAYLOAD 64\n\n// Storage for sensor data. Each sensor has its own fixed-size buffer.\nstatic uint8_t g_sensorDataBuffers[MAX_SENSORS][SENSOR_DATA_BUFFER_SIZE];\n// Current valid length for each sensor's buffer\nstatic uint8_t g_sensorDataLengths[MAX_SENSORS];\n\n// Structure representing an incoming telemetry packet\ntypedef struct {\n    uint8_t  sensor_id;  // Identifier for the sensor (0 to MAX_SENSORS-1)\n    uint16_t data_len;   // Length of the data payload in this packet\n    uint8_t  data[MAX_TELEMETRY_PACKET_PAYLOAD]; // Raw data payload\n} TelemetryPacket;\n\n// Initialize sensor data buffers to zeros and lengths to zero\nvoid initSensorDataStorage() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        memset(g_sensorDataBuffers[i], 0, SENSOR_DATA_BUFFER_SIZE);\n        g_sensorDataLengths[i] = 0;\n    }\n}\n\n// Process an incoming telemetry packet\n// This function stores the sensor data into the respective buffer based on sensor_id.\nint processTelemetryPacket(const TelemetryPacket* packet) {\n    if (packet == NULL) {\n        return -1; // Invalid packet pointer\n    }\n\n    // 1. Validate sensor ID against the maximum number of sensors\n    if (packet->sensor_id >= MAX_SENSORS) {\n        return -2; // Invalid sensor ID, out of bounds for the array of buffers\n    }\n\n    // 2. Validate incoming data length against the packet's maximum allowed payload size.\n    // This check ensures the data doesn't exceed what the packet structure can hold.\n    if (packet->data_len > MAX_TELEMETRY_PACKET_PAYLOAD) {\n        return -3; // Data length exceeds the maximum payload defined for the packet format\n    }\n\n    // VULNERABILITY: Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-119)\n    // The 'packet->data_len' is checked against 'MAX_TELEMETRY_PACKET_PAYLOAD' (64 bytes), which is\n    // the maximum size the incoming packet *can* carry. However, the destination buffer\n    // 'g_sensorDataBuffers[packet->sensor_id]' is only 'SENSOR_DATA_BUFFER_SIZE' (32 bytes).\n    // If an attacker sends a 'data_len' value that is valid for the packet (e.g., 40 bytes),\n    // but larger than 'SENSOR_DATA_BUFFER_SIZE', the 'memcpy' will write beyond the bounds of\n    // the targeted sensor's buffer, potentially overwriting data in adjacent buffers\n    // or other critical memory regions.\n    memcpy(g_sensorDataBuffers[packet->sensor_id], packet->data, packet->data_len);\n    \n    // Update the stored length, note that it will be truncated if packet->data_len > 255,\n    // but the overflow happens during memcpy if packet->data_len > SENSOR_DATA_BUFFER_SIZE\n    g_sensorDataLengths[packet->sensor_id] = (uint8_t)packet->data_len;\n\n    return 0; // Success\n}\n\n// Dummy function to simulate receiving a raw data buffer from a communication interface.\n// In a real system, 'raw_data_buffer' would be parsed into a 'TelemetryPacket' structure.\nvoid receiveSensorData(const uint8_t* raw_data_buffer) {\n    processTelemetryPacket((const TelemetryPacket*)raw_data_buffer);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <new>\n#include <cstring>\n#include <cstdlib>\n\nstruct ConfigEntryMetadata {\n    uint32_t key_offset;\n    uint16_t key_len;\n    uint32_t value_offset;\n    uint16_t value_len;\n};\n\nclass VehicleConfigManagerVulnerable {\npublic:\n    VehicleConfigManagerVulnerable() : m_dataBuffer(nullptr), m_currentDataSize(0), m_allocatedCapacity(0) {\n        m_allocatedCapacity = 256;\n        m_dataBuffer = (uint8_t*)malloc(m_allocatedCapacity);\n        if (!m_dataBuffer) {\n            m_allocatedCapacity = 0;\n        }\n    }\n\n    ~VehicleConfigManagerVulnerable() {\n        if (m_dataBuffer) {\n            free(m_dataBuffer);\n            m_dataBuffer = nullptr;\n        }\n    }\n\n    bool addConfigEntryVulnerable(const char* key, uint16_t key_len, const char* value, uint16_t value_len) {\n        if (!key || !value) {\n            return false;\n        }\n\n        uint16_t entry_data_len = key_len + 1 + value_len + 1;\n\n        size_t required_total_size = m_currentDataSize + entry_data_len;\n\n        if (required_total_size > m_allocatedCapacity) {\n            uint8_t* new_buffer = (uint8_t*)realloc(m_dataBuffer, required_total_size);\n            if (!new_buffer) {\n                return false;\n            }\n            m_dataBuffer = new_buffer;\n            m_allocatedCapacity = required_total_size;\n        }\n\n        ConfigEntryMetadata new_metadata;\n        new_metadata.key_offset = m_currentDataSize;\n        new_metadata.key_len = key_len;\n        new_metadata.value_offset = m_currentDataSize + key_len + 1;\n        new_metadata.value_len = value_len;\n        m_configEntries.push_back(new_metadata);\n\n        memcpy(m_dataBuffer + m_currentDataSize, key, key_len);\n        m_dataBuffer[m_currentDataSize + key_len] = '\\0';\n\n        memcpy(m_dataBuffer + new_metadata.value_offset, value, value_len);\n        m_dataBuffer[new_metadata.value_offset + value_len] = '\\0';\n\n        m_currentDataSize += (key_len + 1 + value_len + 1);\n\n        return true;\n    }\n\n    const uint8_t* getDataBuffer() const { return m_dataBuffer; }\n    size_t getCurrentDataSize() const { return m_currentDataSize; }\n    size_t getAllocatedCapacity() const { return m_allocatedCapacity; }\n    const std::vector<ConfigEntryMetadata>& getConfigEntries() const { return m_configEntries; }\n\nprivate:\n    uint8_t* m_dataBuffer;\n    size_t m_currentDataSize;\n    size_t m_allocatedCapacity;\n    std::vector<ConfigEntryMetadata> m_configEntries;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLES_VULNERABLE 100\n\ntypedef struct {\n    uint32_t firmware_version;\n    uint8_t  diagnostic_mode;\n    bool     feature_X_enabled;\n    uint16_t checksum;\n} VehicleECUConfig_Vulnerable;\n\nstatic VehicleECUConfig_Vulnerable g_fleetECUConfigs_vulnerable[MAX_VEHICLES_VULNERABLE];\n\nvoid ecuLog_vulnerable(const char* message) {\n}\n\ntypedef struct {\n    uint16_t command_id;\n    uint16_t start_vehicle_idx;\n    uint16_t num_vehicles_to_update;\n    VehicleECUConfig_Vulnerable config_data;\n} BatchUpdateCommand_Vulnerable;\n\nBatchUpdateCommand_Vulnerable receiveBatchUpdateCommand_vulnerable() {\n    BatchUpdateCommand_Vulnerable cmd;\n    cmd.command_id = 0x5001;\n    cmd.start_vehicle_idx = 90;\n    cmd.num_vehicles_to_update = 15;\n    cmd.config_data = (VehicleECUConfig_Vulnerable){\n        .firmware_version = 0x01020304,\n        .diagnostic_mode = 1,\n        .feature_X_enabled = true,\n        .checksum = 0xABCD\n    };\n    return cmd;\n}\n\nvoid initializeFleetConfigs_vulnerable() {\n    for (int i = 0; i < MAX_VEHICLES_VULNERABLE; ++i) {\n        g_fleetECUConfigs_vulnerable[i] = (VehicleECUConfig_Vulnerable){\n            .firmware_version = 0x00000000,\n            .diagnostic_mode = 0,\n            .feature_X_enabled = false,\n            .checksum = 0x0000\n        };\n    }\n    ecuLog_vulnerable(\"Fleet ECU configurations initialized.\");\n}\n\nvoid processBatchECUConfigUpdate_vulnerable() {\n    BatchUpdateCommand_Vulnerable cmd = receiveBatchUpdateCommand_vulnerable();\n\n    if (cmd.command_id == 0x5001) {\n        for (uint16_t i = 0; i < cmd.num_vehicles_to_update; ++i) {\n            g_fleetECUConfigs_vulnerable[cmd.start_vehicle_idx + i] = cmd.config_data;\n        }\n        ecuLog_vulnerable(\"Batch ECU configuration update processed (vulnerable).\");\n    } else {\n        ecuLog_vulnerable(\"Unknown batch update command ID (vulnerable).\");\n    }\n}\n\nvoid mainECUController_vulnerable() {\n    initializeFleetConfigs_vulnerable();\n    processBatchECUConfigUpdate_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_RESPONSE_BUFFER_SIZE 256\n#define MAX_DIAG_ITEMS 10\n#define DIAG_ITEM_DATA_MAX_LEN 30 \n\nstatic uint8_t g_unpackedDiagData[DIAG_RESPONSE_BUFFER_SIZE];\nstatic uint16_t g_currentUnpackedOffset = 0;\n\ntypedef struct {\n    uint16_t item_id;\n    uint8_t  item_len; \n} DiagnosticItemHeader;\n\nvoid initDiagnosticSystem() {\n    memset(g_unpackedDiagData, 0, DIAG_RESPONSE_BUFFER_SIZE);\n    g_currentUnpackedOffset = 0;\n}\n\nint processDiagResponse(const uint8_t* response_msg, uint16_t msg_len) {\n    if (response_msg == NULL || msg_len < (sizeof(uint8_t) + sizeof(uint8_t))) {\n        return -1; \n    }\n\n    uint16_t current_msg_offset = 0;\n\n    uint8_t num_items = response_msg[current_msg_offset++];\n\n    uint8_t status_flag = response_msg[current_msg_offset++];\n\n    if (num_items == 0) {\n        g_currentUnpackedOffset = 0; \n        return 0;\n    }\n\n    if (num_items > MAX_DIAG_ITEMS) {\n        return -2; \n    }\n\n    g_currentUnpackedOffset = 0;\n\n    for (uint8_t i = 0; i < num_items; ++i) {\n        if (current_msg_offset + sizeof(DiagnosticItemHeader) > msg_len) {\n            return -3; \n        }\n\n        DiagnosticItemHeader header;\n        header.item_id = (response_msg[current_msg_offset] << 8) | response_msg[current_msg_offset + 1];\n        current_msg_offset += 2; \n\n        header.item_len = response_msg[current_msg_offset++]; \n        \n        if (header.item_len > DIAG_ITEM_DATA_MAX_LEN) {\n            return -6; \n        }\n\n        if (current_msg_offset + header.item_len > msg_len) {\n            return -4; \n        }\n\n        if ((uint32_t)g_currentUnpackedOffset + header.item_len > DIAG_RESPONSE_BUFFER_SIZE) {\n            current_msg_offset += header.item_len; \n            return -5; \n        }\n\n        for (uint8_t j = 0; j < header.item_len; ++j) {\n            g_unpackedDiagData[g_currentUnpackedOffset + j] = response_msg[current_msg_offset + j];\n        }\n        g_currentUnpackedOffset += header.item_len; \n        current_msg_offset += header.item_len;      \n    }\n\n    return 0;\n}\n\nvoid simulateDiagMessageReceive(const uint8_t* data, uint16_t len) {\n    initDiagnosticSystem();\n    processDiagResponse(data, len);\n}\n\nvoid triggerVulnerability() {\n    uint8_t malicious_msg[332]; \n    uint16_t offset = 0;\n\n    malicious_msg[offset++] = MAX_DIAG_ITEMS; \n    malicious_msg[offset++] = 0; \n\n    for (uint8_t i = 0; i < MAX_DIAG_ITEMS; ++i) {\n        malicious_msg[offset++] = (uint8_t)(0x0001 >> 8); \n        malicious_msg[offset++] = (uint8_t)(0x0001 & 0xFF); \n        malicious_msg[offset++] = DIAG_ITEM_DATA_MAX_LEN; \n\n        for (uint8_t j = 0; j < DIAG_ITEM_DATA_MAX_LEN; ++j) {\n            malicious_msg[offset++] = 'A'; \n        }\n    }\n\n    simulateDiagMessageReceive(malicious_msg, offset);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define CONFIG_TABLE_SIZE 256 \n\nstatic uint8_t g_configTable[CONFIG_TABLE_SIZE];\n\ntypedef enum {\n    CFG_TYPE_UINT8 = 0,\n    CFG_TYPE_UINT16,\n    CFG_TYPE_UINT32,\n    CFG_TYPE_MAX\n} ConfigDataType;\n\nstatic uint8_t getConfigTypeSize(ConfigDataType type) {\n    switch (type) {\n        case CFG_TYPE_UINT8:  return 1;\n        case CFG_TYPE_UINT16: return 2;\n        case CFG_TYPE_UINT32: return 4;\n        default: return 0;\n    }\n}\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t offset;\n    ConfigDataType data_type;\n} ConfigEntryDescriptor;\n\nstatic const ConfigEntryDescriptor g_cfgDescriptors[] = {\n    {0x1001, 0, CFG_TYPE_UINT16},\n    {0x1002, 2, CFG_TYPE_UINT8},\n    {0x1003, 3, CFG_TYPE_UINT32},\n    {0x1004, 7, CFG_TYPE_UINT16},\n    {0x2001, 200, CFG_TYPE_UINT8},\n    {0x2002, 250, CFG_TYPE_UINT16}\n};\n#define NUM_CFG_ENTRIES (sizeof(g_cfgDescriptors) / sizeof(ConfigEntryDescriptor))\n\nvoid initConfigTable() {\n    memset(g_configTable, 0, CONFIG_TABLE_SIZE);\n}\n\nint updateConfigEntryValue(uint16_t entry_id, const uint8_t* new_value_bytes, uint8_t max_value_len) {\n    if (new_value_bytes == NULL || max_value_len == 0) {\n        return -1;\n    }\n\n    const ConfigEntryDescriptor* target_entry = NULL;\n    for (int i = 0; i < NUM_CFG_ENTRIES; ++i) {\n        if (g_cfgDescriptors[i].entry_id == entry_id) {\n            target_entry = &g_cfgDescriptors[i];\n            break;\n        }\n    }\n\n    if (target_entry == NULL) {\n        return -2;\n    }\n\n    uint8_t required_size = getConfigTypeSize(target_entry->data_type);\n\n    if (required_size == 0 || required_size > max_value_len) {\n        return -3;\n    }\n\n    // FIX: Add a bounds check to ensure the entire write operation stays within CONFIG_TABLE_SIZE.\n    // This prevents an out-of-bounds write if target_entry->offset + required_size exceeds the buffer's capacity.\n    if ((uint32_t)target_entry->offset + required_size > CONFIG_TABLE_SIZE) {\n        return -5; // Data would write out of bounds\n    }\n\n    switch (target_entry->data_type) {\n        case CFG_TYPE_UINT8:\n            g_configTable[target_entry->offset] = new_value_bytes[0];\n            break;\n        case CFG_TYPE_UINT16:\n            *(uint16_t*)(g_configTable + target_entry->offset) = *(uint16_t*)new_value_bytes;\n            break;\n        case CFG_TYPE_UINT32:\n            *(uint32_t*)(g_configTable + target_entry->offset) = *(uint32_t*)new_value_bytes;\n            break;\n        default:\n            return -4;\n    }\n\n    return 0;\n}\n\nvoid simulateConfigUpdate(uint16_t id, const uint8_t* data, uint8_t len) {\n    updateConfigEntryValue(id, data, len);\n}\n\nuint8_t getConfigByte(uint16_t offset) {\n    if (offset < CONFIG_TABLE_SIZE) {\n        return g_configTable[offset];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_MESSAGE_SIZE 256\n#define VEHICLE_ID_BUFFER_SIZE 32\n#define CALIBRATION_VERSION_BUFFER_SIZE 16\n\nstatic char g_vehicleIdentifier[VEHICLE_ID_BUFFER_SIZE];\nstatic char g_calibrationVersion[CALIBRATION_VERSION_BUFFER_SIZE];\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_length;\n} DiagnosticRecordHeader;\n\ntypedef enum {\n    RECORD_TYPE_INVALID = 0,\n    RECORD_TYPE_VEHICLE_ID = 1,\n    RECORD_TYPE_CALIBRATION_VERSION = 2,\n    RECORD_TYPE_STATUS_CODE = 3\n} DiagnosticRecordType;\n\nvoid initVehicleInfoStore() {\n    memset(g_vehicleIdentifier, 0, VEHICLE_ID_BUFFER_SIZE);\n    memset(g_calibrationVersion, 0, CALIBRATION_VERSION_BUFFER_SIZE);\n}\n\nint processDiagnosticInfoMessage(const uint8_t* message, uint16_t message_len) {\n    if (message == NULL || message_len < sizeof(DiagnosticRecordHeader)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    while (current_offset + sizeof(DiagnosticRecordHeader) <= message_len) {\n        const DiagnosticRecordHeader* header = (const DiagnosticRecordHeader*)(message + current_offset);\n        \n        uint8_t type = header->record_type;\n        uint8_t length = header->record_length;\n\n        if (current_offset + sizeof(DiagnosticRecordHeader) + length > message_len) {\n            return -2;\n        }\n\n        const uint8_t* data_ptr = message + current_offset + sizeof(DiagnosticRecordHeader);\n\n        switch (type) {\n            case RECORD_TYPE_VEHICLE_ID: {\n                uint8_t bytes_to_copy = length;\n                if (bytes_to_copy >= VEHICLE_ID_BUFFER_SIZE) {\n                    bytes_to_copy = VEHICLE_ID_BUFFER_SIZE - 1;\n                }\n                for (uint8_t i = 0; i < bytes_to_copy; ++i) {\n                    g_vehicleIdentifier[i] = data_ptr[i];\n                }\n                g_vehicleIdentifier[bytes_to_copy] = '\\0';\n                break;\n            }\n            case RECORD_TYPE_CALIBRATION_VERSION: {\n                uint8_t bytes_to_copy = length;\n                if (bytes_to_copy >= CALIBRATION_VERSION_BUFFER_SIZE) {\n                    bytes_to_copy = CALIBRATION_VERSION_BUFFER_SIZE - 1;\n                }\n                for (uint8_t i = 0; i < bytes_to_copy; ++i) {\n                    g_calibrationVersion[i] = data_ptr[i];\n                }\n                g_calibrationVersion[bytes_to_copy] = '\\0';\n                break;\n            }\n            case RECORD_TYPE_STATUS_CODE: {\n                if (length != sizeof(uint16_t)) return -3;\n                break;\n            }\n            default:\n                break;\n        }\n\n        current_offset += sizeof(DiagnosticRecordHeader) + length;\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticMessage(const uint8_t* msg_data, uint16_t msg_len) {\n    initVehicleInfoStore();\n    processDiagnosticInfoMessage(msg_data, msg_len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define VEHICLE_SETTINGS_BANK_SIZE_BYTES 1024\n#define SETTINGS_BLOCK_SIZE_BYTES        64\n\ntypedef struct {\n    uint16_t version;\n    uint16_t crc;\n    uint8_t  active_flag; \n    uint8_t  _reserved[59]; \n} SettingsBlockHeader;\n\nstatic uint8_t g_settings_bank_fixed[VEHICLE_SETTINGS_BANK_SIZE_BYTES];\nstatic uint8_t* g_active_settings_block_ptr_fixed = NULL;\nstatic uint16_t g_last_stored_offset_fixed = 0;\n\nvoid init_settings_manager_fixed() {\n    memset(g_settings_bank_fixed, 0, VEHICLE_SETTINGS_BANK_SIZE_BYTES);\n    g_active_settings_block_ptr_fixed = g_settings_bank_fixed;\n    g_last_stored_offset_fixed = 0;\n    ((SettingsBlockHeader*)g_active_settings_block_ptr_fixed)->active_flag = 0xAA;\n}\n\nbool store_new_settings_fixed(const uint8_t* new_settings_data) {\n    if (g_last_stored_offset_fixed + SETTINGS_BLOCK_SIZE_BYTES > VEHICLE_SETTINGS_BANK_SIZE_BYTES) {\n        return false;\n    }\n\n    if (g_active_settings_block_ptr_fixed != NULL) {\n        ((SettingsBlockHeader*)g_active_settings_block_ptr_fixed)->active_flag = 0x55;\n    }\n\n    uint8_t* new_block_location = g_settings_bank_fixed + g_last_stored_offset_fixed;\n    memcpy(new_block_location, new_settings_data, SETTINGS_BLOCK_SIZE_BYTES);\n\n    ((SettingsBlockHeader*)new_block_location)->active_flag = 0xAA;\n\n    g_active_settings_block_ptr_fixed = new_block_location;\n    g_last_stored_offset_fixed += SETTINGS_BLOCK_SIZE_BYTES;\n    return true;\n}\n\nconst uint8_t* get_active_settings_fixed() {\n    return g_active_settings_block_ptr_fixed;\n}\n\nvoid rollback_settings_fixed(uint8_t steps_back) {\n    if (g_active_settings_block_ptr_fixed == NULL || steps_back == 0) {\n        return;\n    }\n\n    uint8_t* potential_target_ptr = g_active_settings_block_ptr_fixed - (steps_back * SETTINGS_BLOCK_SIZE_BYTES);\n\n    if (potential_target_ptr < g_settings_bank_fixed) {\n        potential_target_ptr = g_settings_bank_fixed;\n    }\n\n    if (g_active_settings_block_ptr_fixed != potential_target_ptr) {\n        ((SettingsBlockHeader*)g_active_settings_block_ptr_fixed)->active_flag = 0x55;\n        g_active_settings_block_ptr_fixed = potential_target_ptr;\n        ((SettingsBlockHeader*)g_active_settings_block_ptr_fixed)->active_flag = 0xAA;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_STORED_DTCS 50\n\ntypedef enum {\n    DTC_STATUS_INACTIVE = 0,\n    DTC_STATUS_ACTIVE,\n    DTC_STATUS_CONFIRMED,\n    DTC_STATUS_PENDING\n} DtcStatus;\n\ntypedef struct {\n    uint16_t  dtc_code;\n    DtcStatus status;\n    uint8_t   occurrence_count;\n    uint32_t  first_occurrence_timestamp;\n} DtcEntry;\n\nstatic DtcEntry g_dtcStatusTable_vulnerable[MAX_STORED_DTCS];\n\nvoid logDTCSystemError_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t dtc_logical_index;\n    uint8_t new_status_value;\n    uint16_t reserved;\n} DiagnosticRequestFrame;\n\nDiagnosticRequestFrame receiveDiagnosticRequest_vulnerable() {\n    DiagnosticRequestFrame req;\n    req.command_id = 0x01;\n    req.dtc_logical_index = MAX_STORED_DTCS;\n    req.new_status_value = DTC_STATUS_CONFIRMED;\n    req.reserved = 0;\n    return req;\n}\n\nvoid initializeDTCSystem_vulnerable() {\n    for (int i = 0; i < MAX_STORED_DTCS; ++i) {\n        g_dtcStatusTable_vulnerable[i].dtc_code = 0x0000;\n        g_dtcStatusTable_vulnerable[i].status = DTC_STATUS_INACTIVE;\n        g_dtcStatusTable_vulnerable[i].occurrence_count = 0;\n        g_dtcStatusTable_vulnerable[i].first_occurrence_timestamp = 0;\n    }\n    g_dtcStatusTable_vulnerable[0].dtc_code = 0x1234;\n    g_dtcStatusTable_vulnerable[1].dtc_code = 0x5678;\n    g_dtcStatusTable_vulnerable[2].dtc_code = 0x9ABC;\n}\n\nvoid processDiagnosticRequest_vulnerable() {\n    DiagnosticRequestFrame request = receiveDiagnosticRequest_vulnerable();\n\n    if (request.command_id == 0x01) {\n        g_dtcStatusTable_vulnerable[request.dtc_logical_index].status = (DtcStatus)request.new_status_value;\n        g_dtcStatusTable_vulnerable[request.dtc_logical_index].occurrence_count++;\n        logDTCSystemError_vulnerable(\"DTC status update processed (vulnerable).\");\n    } else {\n        logDTCSystemError_vulnerable(\"Unknown diagnostic command received (vulnerable).\");\n    }\n}\n\nvoid dtcManagerMain_vulnerable() {\n    initializeDTCSystem_vulnerable();\n    processDiagnosticRequest_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_CONFIG_ENTRIES 16\n#define CONFIG_VALUE_SIZE 4\n\ntypedef struct {\n    uint16_t param_id;\n    uint8_t  config_data[CONFIG_VALUE_SIZE];\n    uint8_t  status_flags;\n} ConfigEntryFixed;\n\nstatic ConfigEntryFixed g_config_entries_fixed[MAX_CONFIG_ENTRIES];\nstatic uint8_t g_num_config_entries_fixed = 0;\nstatic int16_t g_last_updated_idx_fixed = -1;\n\nvoid init_config_manager_fixed() {\n    memset(g_config_entries_fixed, 0, sizeof(g_config_entries_fixed));\n    g_num_config_entries_fixed = 0;\n    g_last_updated_idx_fixed = -1;\n}\n\nbool add_config_entry_fixed(uint16_t id, const uint8_t* data) {\n    if (g_num_config_entries_fixed >= MAX_CONFIG_ENTRIES) {\n        return false;\n    }\n    ConfigEntryFixed* entry = &g_config_entries_fixed[g_num_config_entries_fixed];\n    entry->param_id = id;\n    memcpy(entry->config_data, data, CONFIG_VALUE_SIZE);\n    entry->status_flags = 0xFF;\n    g_last_updated_idx_fixed = g_num_config_entries_fixed;\n    g_num_config_entries_fixed++;\n    return true;\n}\n\nvoid access_config_entry_fixed(uint16_t index) {\n    if (index < g_num_config_entries_fixed) {\n        volatile uint16_t id = g_config_entries_fixed[index].param_id;\n        (void)id;\n    }\n}\n\nvoid update_preceding_config_marker_fixed(int16_t offset_from_first_entry, uint8_t marker_val) {\n    if (g_num_config_entries_fixed == 0) {\n        return;\n    }\n\n    int16_t target_idx = offset_from_first_entry;\n\n    if (target_idx < 0 || target_idx >= MAX_CONFIG_ENTRIES) {\n        return;\n    }\n\n    uint8_t* current_entry_byte_ptr = (uint8_t*)&g_config_entries_fixed[target_idx];\n\n    uint8_t* buffer_start_ptr = (uint8_t*)&g_config_entries_fixed[0];\n\n    uint8_t* marker_location_ptr = current_entry_byte_ptr - 1;\n\n    if (marker_location_ptr < buffer_start_ptr) {\n        return;\n    }\n\n    *marker_location_ptr = marker_val;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_MESSAGE_TYPES 5\n#define MAX_FIELDS_PER_MESSAGE_TYPE 8 \n#define PAYLOAD_MAX_SIZE 8\n\nvoid automotiveLog_fixed(const char* msg) {\n    printf(\"LOG_FIXED: %s\\n\", msg);\n}\n\ntypedef enum {\n    FIELD_TYPE_UINT8_FIXED = 0,\n    FIELD_TYPE_UINT16_FIXED = 1,\n    FIELD_TYPE_UINT32_FIXED = 2,\n    FIELD_TYPE_FLOAT_FIXED = 3\n} FieldDataType_Fixed;\n\ntypedef struct {\n    uint8_t offset;    \n    uint8_t size;      \n    FieldDataType_Fixed type;\n} FieldInfo_Fixed;\n\ntypedef struct {\n    uint8_t message_id;\n    uint8_t num_defined_fields; \n    FieldInfo_Fixed fields[MAX_FIELDS_PER_MESSAGE_TYPE]; \n} MessageDescriptor_Fixed;\n\nstatic MessageDescriptor_Fixed g_messageDescriptors_fixed[MAX_MESSAGE_TYPES];\n\ntypedef struct {\n    uint8_t  message_id;\n    uint8_t  payload[PAYLOAD_MAX_SIZE];\n    uint8_t  requested_field_index; \n} NetworkMessage_fixed;\n\nvoid initializeMessageDescriptors_fixed() {\n    g_messageDescriptors_fixed[0].message_id = 0x10;\n    g_messageDescriptors_fixed[0].num_defined_fields = 2;\n    g_messageDescriptors_fixed[0].fields[0] = (FieldInfo_Fixed){0, 2, FIELD_TYPE_UINT16_FIXED};\n    g_messageDescriptors_fixed[0].fields[1] = (FieldInfo_Fixed){2, 1, FIELD_TYPE_UINT8_FIXED};\n\n    g_messageDescriptors_fixed[1].message_id = 0x20;\n    g_messageDescriptors_fixed[1].num_defined_fields = 1;\n    g_messageDescriptors_fixed[1].fields[0] = (FieldInfo_Fixed){0, 2, FIELD_TYPE_UINT16_FIXED};\n\n    g_messageDescriptors_fixed[2].message_id = 0x30;\n    g_messageDescriptors_fixed[2].num_defined_fields = 2;\n    g_messageDescriptors_fixed[2].fields[0] = (FieldInfo_Fixed){0, 4, FIELD_TYPE_FLOAT_FIXED};\n    g_messageDescriptors_fixed[2].fields[1] = (FieldInfo_Fixed){4, 4, FIELD_TYPE_FLOAT_FIXED};\n\n    for(int i = 3; i < MAX_MESSAGE_TYPES; ++i) {\n        g_messageDescriptors_fixed[i].message_id = 0xFF;\n        g_messageDescriptors_fixed[i].num_defined_fields = 0;\n    }\n}\n\nNetworkMessage_fixed receiveNetworkMessage_fixed() {\n    NetworkMessage_fixed msg;\n    msg.message_id = 0x10;\n    msg.requested_field_index = 3;\n    msg.payload[0] = 0xCD; msg.payload[1] = 0xAB;\n    msg.payload[2] = 0x50;\n    memset(msg.payload + 3, 0x00, PAYLOAD_MAX_SIZE - 3);\n    return msg;\n}\n\nvoid processNetworkMessage_fixed() {\n    NetworkMessage_fixed msg = receiveNetworkMessage_fixed();\n    uint8_t descriptor_idx = 0xFF;\n\n    for (uint8_t i = 0; i < MAX_MESSAGE_TYPES; ++i) {\n        if (g_messageDescriptors_fixed[i].message_id == msg.message_id) {\n            descriptor_idx = i;\n            break;\n        }\n    }\n\n    if (descriptor_idx != 0xFF) {\n        MessageDescriptor_Fixed* descriptor = &g_messageDescriptors_fixed[descriptor_idx];\n\n        if (msg.requested_field_index < descriptor->num_defined_fields) {\n            FieldInfo_Fixed field_to_extract = descriptor->fields[msg.requested_field_index];\n            automotiveLog_fixed(\"Attempting to extract data from payload (fixed).\");\n\n            if (field_to_extract.offset < PAYLOAD_MAX_SIZE && (field_to_extract.offset + field_to_extract.size) <= PAYLOAD_MAX_SIZE) {\n                uint32_t extracted_val = 0;\n                switch (field_to_extract.type) {\n                    case FIELD_TYPE_UINT8_FIXED:\n                        extracted_val = msg.payload[field_to_extract.offset];\n                        break;\n                    case FIELD_TYPE_UINT16_FIXED:\n                        memcpy(&extracted_val, msg.payload + field_to_extract.offset, 2);\n                        break;\n                    case FIELD_TYPE_UINT32_FIXED:\n                        memcpy(&extracted_val, msg.payload + field_to_extract.offset, 4);\n                        break;\n                    case FIELD_TYPE_FLOAT_FIXED:\n                        memcpy(&extracted_val, msg.payload + field_to_extract.offset, 4);\n                        break;\n                    default:\n                        automotiveLog_fixed(\"Unknown field type detected from descriptor (fixed).\");\n                        break;\n                }\n            } else {\n                automotiveLog_fixed(\"Field offset or size out of payload bounds (fixed - likely due to valid but invalid FieldInfo).\");\n            }\n        } else {\n            automotiveLog_fixed(\"Requested field index is out of bounds for this message type (fixed).\");\n        }\n    } else {\n        automotiveLog_fixed(\"Received message with unknown ID (fixed).\");\n    }\n}\n\nvoid automotiveMain_fixed() {\n    initializeMessageDescriptors_fixed();\n    processNetworkMessage_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\n\nstruct DiagnosticReportPacketHeader {\n    uint16_t report_id;\n    uint16_t num_data_elements; \n    uint32_t total_payload_bytes; \n};\n\nstruct DiagnosticDataElement {\n    uint16_t element_tag;\n    uint16_t data_length; \n};\n\nstruct AggregatedDataEntry {\n    uint16_t element_tag;\n    uint16_t actual_data_length; \n};\n\n#pragma pack(pop)\n\nclass DiagnosticDataAggregatorVulnerable {\npublic:\n    DiagnosticDataAggregatorVulnerable() : m_aggregated_buffer(nullptr), m_buffer_capacity(0), m_current_write_offset(0) {}\n\n    ~DiagnosticDataAggregatorVulnerable() {\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n        }\n    }\n\n    bool processDiagnosticReportVulnerable(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(DiagnosticReportPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticReportPacketHeader* packet_header = reinterpret_cast<const DiagnosticReportPacketHeader*>(raw_packet);\n\n        if (packet_length < (sizeof(DiagnosticReportPacketHeader) + packet_header->total_payload_bytes)) {\n            return false;\n        }\n\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n            m_current_write_offset = 0;\n            m_buffer_capacity = 0;\n        }\n\n        m_buffer_capacity = packet_header->total_payload_bytes; \n        \n        if (m_buffer_capacity == 0 && packet_header->num_data_elements > 0) {\n            return false; \n        }\n\n        m_aggregated_buffer = (uint8_t*)malloc(m_buffer_capacity);\n        if (!m_aggregated_buffer && m_buffer_capacity > 0) {\n            return false; \n        }\n        \n        size_t current_raw_read_offset = sizeof(DiagnosticReportPacketHeader);\n        m_current_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_header->num_data_elements; ++i) {\n            if (current_raw_read_offset + sizeof(DiagnosticDataElement) > packet_length) {\n                return false;\n            }\n\n            const DiagnosticDataElement* incoming_element_header = \n                reinterpret_cast<const DiagnosticDataElement*>(raw_packet + current_raw_read_offset);\n\n            uint16_t current_data_len = incoming_element_header->data_length;\n\n            if (current_raw_read_offset + sizeof(DiagnosticDataElement) + current_data_len > packet_length) {\n                return false;\n            }\n            \n            size_t space_needed_for_this_entry = sizeof(AggregatedDataEntry) + current_data_len;\n\n            if (m_current_write_offset + space_needed_for_this_entry > m_buffer_capacity) {\n                return false;\n            }\n\n            uint16_t tag_to_copy = incoming_element_header->element_tag;\n            memcpy(m_aggregated_buffer + m_current_write_offset, &tag_to_copy, sizeof(tag_to_copy));\n            m_current_write_offset += sizeof(tag_to_copy);\n\n            uint16_t len_to_copy = incoming_element_header->data_length;\n            memcpy(m_aggregated_buffer + m_current_write_offset, &len_to_copy, sizeof(len_to_copy));\n            m_current_write_offset += sizeof(len_to_copy);\n\n            memcpy(m_aggregated_buffer + m_current_write_offset, \n                   raw_packet + current_raw_read_offset + sizeof(DiagnosticDataElement), \n                   current_data_len);\n            m_current_write_offset += current_data_len;\n\n            current_raw_read_offset += sizeof(DiagnosticDataElement) + current_data_len;\n        }\n\n        if (m_current_write_offset != packet_header->total_payload_bytes + (packet_header->num_data_elements * sizeof(AggregatedDataEntry))) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedBuffer() const { return m_aggregated_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n    size_t getCurrentWriteOffset() const { return m_current_write_offset; }\n\nprivate:\n    uint8_t* m_aggregated_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_write_offset;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define DTC_TYPE_ENGINE 0\n#define DTC_TYPE_TRANSMISSION 1\n#define DTC_TYPE_BRAKE 2\n#define MAX_DTC_TYPES 3\n\n#define GLOBAL_MAX_INSTANCES_PER_DTC 5\n\ntypedef struct {\n    uint16_t code;\n    uint8_t  instance_id;\n    uint32_t timestamp;\n    uint8_t  status;\n} DTC_Entry;\n\nstatic DTC_Entry g_dtcHistory_vulnerable[MAX_DTC_TYPES][GLOBAL_MAX_INSTANCES_PER_DTC];\n\nstatic const uint8_t g_dtcCapacities[MAX_DTC_TYPES] = {\n    3, \n    2, \n    4  \n};\n\nvoid logECUError_vulnerable(const char* msg) {\n    fprintf(stderr, \"ECU_LOG_VULN: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t dtc_type_id;\n    uint8_t instance_idx;\n    uint16_t dtc_code;\n    uint8_t dtc_status;\n} IncomingDTC_Message_Vulnerable;\n\nIncomingDTC_Message_Vulnerable receiveDiagnosticMessage_vulnerable() {\n    IncomingDTC_Message_Vulnerable msg;\n    msg.dtc_type_id = DTC_TYPE_TRANSMISSION;\n    msg.instance_idx = 2;\n    msg.dtc_code = 0xDEAD;\n    msg.dtc_status = 0x01;\n    return msg;\n}\n\nvoid initializeDTCStorage_vulnerable() {\n    for (uint8_t i = 0; i < MAX_DTC_TYPES; ++i) {\n        for (uint8_t j = 0; j < GLOBAL_MAX_INSTANCES_PER_DTC; ++j) {\n            g_dtcHistory_vulnerable[i][j] = (DTC_Entry){0, 0, 0, 0};\n        }\n    }\n    logECUError_vulnerable(\"DTC history storage initialized.\");\n}\n\nvoid processDiagnosticMessage_vulnerable() {\n    IncomingDTC_Message_Vulnerable msg = receiveDiagnosticMessage_vulnerable();\n    uint32_t current_timestamp = 12345;\n\n    if (msg.dtc_type_id < MAX_DTC_TYPES) {\n        if (msg.instance_idx < GLOBAL_MAX_INSTANCES_PER_DTC) {\n            g_dtcHistory_vulnerable[msg.dtc_type_id][msg.instance_idx].code = msg.dtc_code;\n            g_dtcHistory_vulnerable[msg.dtc_type_id][msg.instance_idx].instance_id = msg.instance_idx;\n            g_dtcHistory_vulnerable[msg.dtc_type_id][msg.instance_idx].timestamp = current_timestamp;\n            g_dtcHistory_vulnerable[msg.dtc_type_id][msg.instance_idx].status = msg.dtc_status;\n            logECUError_vulnerable(\"DTC entry processed (vulnerable).\");\n        } else {\n            logECUError_vulnerable(\"DTC instance index exceeds global maximum instances.\");\n        }\n    } else {\n        logECUError_vulnerable(\"Invalid DTC type ID received.\");\n    }\n}\n\nvoid automotiveDiagnosticModule_vulnerable_main() {\n    initializeDTCStorage_vulnerable();\n    processDiagnosticMessage_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n#include <limits>\n\n// Represents a raw sensor data packet header received over a bus.\nstruct RawSensorPacketHeader {\n    uint16_t packet_id;\n    uint16_t num_readings; // Number of uint16_t readings following the header\n    uint32_t checksum;     // Simple checksum for integrity\n};\n\n// Class to process raw sensor data into floating-point format for internal use.\nclass SensorDataProcessorVulnerable {\npublic:\n    SensorDataProcessorVulnerable() : m_processed_data(nullptr), m_num_elements(0), m_allocated_bytes(0) {}\n\n    ~SensorDataProcessorVulnerable() {\n        if (m_processed_data) {\n            free(m_processed_data);\n            m_processed_data = nullptr;\n        }\n    }\n\n    // Processes a raw sensor data packet, converting uint16_t readings to float.\n    // VULNERABILITY: Heap-based buffer overflow due to incorrect allocation size for type conversion.\n    bool processRawSensorDataVulnerable(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(RawSensorPacketHeader)) {\n            return false;\n        }\n\n        const RawSensorPacketHeader* header = reinterpret_cast<const RawSensorPacketHeader*>(raw_packet);\n\n        if (header->packet_id != 0xABCD) { // Simple magic check for realism\n            return false;\n        }\n\n        // Basic sanity check on packet length for the raw data payload\n        // This checks if the packet contains enough raw data based on 'num_readings' and 'uint16_t' size.\n        if (header->num_readings > (std::numeric_limits<size_t>::max() / sizeof(uint16_t))) {\n            return false; // Prevent integer overflow for this length calculation\n        }\n        size_t expected_raw_data_size = static_cast<size_t>(header->num_readings) * sizeof(uint16_t);\n        \n        if (packet_length < sizeof(RawSensorPacketHeader) + expected_raw_data_size) {\n            return false;\n        }\n\n        // Free existing buffer if any\n        if (m_processed_data) {\n            free(m_processed_data);\n            m_processed_data = nullptr;\n        }\n\n        // VULNERABILITY:\n        // The allocation size is calculated based on the *original* uint16_t size, not the target float size.\n        // If sizeof(float) > sizeof(uint16_t) (e.g., 4 bytes vs 2 bytes), this allocation is too small.\n        // For example, if num_readings is 100:\n        // Allocated: 100 * 2 = 200 bytes\n        // Needed:    100 * 4 = 400 bytes (for float)\n        // The loop iterating through 'i' will eventually write past the end of 'm_processed_data'.\n        m_allocated_bytes = static_cast<size_t>(header->num_readings) * sizeof(uint16_t);\n        \n        m_processed_data = (float*)malloc(m_allocated_bytes);\n        if (!m_processed_data && m_allocated_bytes > 0) {\n            return false;\n        }\n        \n        m_num_elements = header->num_readings;\n\n        const uint16_t* raw_readings_ptr = reinterpret_cast<const uint16_t*>(raw_packet + sizeof(RawSensorPacketHeader));\n\n        for (uint16_t i = 0; i < m_num_elements; ++i) {\n            // This write operation expects 'm_processed_data' to hold 'float' type elements.\n            // As 'i' increments, the access m_processed_data[i] will go out of bounds of the \n            // buffer allocated based on 'sizeof(uint16_t)'.\n            m_processed_data[i] = static_cast<float>(raw_readings_ptr[i]);\n        }\n\n        // Additional check for checksum (for realism, not directly related to the overflow)\n        uint32_t calculated_checksum = 0;\n        for (uint16_t i = 0; i < header->num_readings; ++i) {\n            calculated_checksum += raw_readings_ptr[i];\n        }\n        if (calculated_checksum != header->checksum) {\n            if (m_processed_data) {\n                free(m_processed_data);\n                m_processed_data = nullptr;\n            }\n            m_num_elements = 0;\n            m_allocated_bytes = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const float* getProcessedData() const { return m_processed_data; }\n    uint16_t getNumElements() const { return m_num_elements; }\n\nprivate:\n    float*   m_processed_data;\n    uint16_t m_num_elements;\n    size_t   m_allocated_bytes;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_CALIBRATION_POINTS 16\n#define CALIBRATION_DATA_SIZE 10 \n#define CALIBRATION_HEADER_SIZE 2 \n\n#define SINGLE_CAL_ENTRY_TOTAL_SIZE (CALIBRATION_HEADER_SIZE + CALIBRATION_DATA_SIZE)\n\n#define CAL_ENTRY_PREAMBLE_BYTE_OFFSET -1 \n\nstatic uint8_t g_calibration_buffer[MAX_CALIBRATION_POINTS * SINGLE_CAL_ENTRY_TOTAL_SIZE];\nstatic uint16_t g_active_cal_points = 0; \nstatic uint16_t g_current_calibration_ptr = 0; \n\nvoid initCalibrationBuffer() {\n    memset(g_calibration_buffer, 0, sizeof(g_calibration_buffer));\n    g_active_cal_points = 0;\n    g_current_calibration_ptr = 0;\n}\n\nint16_t addCalibrationEntry(uint16_t id, const uint8_t* data) {\n    if (g_active_cal_points >= MAX_CALIBRATION_POINTS) {\n        return -1; \n    }\n\n    uint32_t current_byte_offset = (uint32_t)g_current_calibration_ptr * SINGLE_CAL_ENTRY_TOTAL_SIZE;\n\n    g_calibration_buffer[current_byte_offset] = (uint8_t)(id >> 8);\n    g_calibration_buffer[current_byte_offset + 1] = (uint8_t)(id & 0xFF);\n\n    memcpy(&g_calibration_buffer[current_byte_offset + CALIBRATION_HEADER_SIZE], data, CALIBRATION_DATA_SIZE);\n\n    int16_t added_idx = g_current_calibration_ptr;\n    g_current_calibration_ptr++;\n    g_active_cal_points++;\n    return added_idx;\n}\n\nvoid updateCalibrationEntryPreamble_Fixed(uint16_t target_cal_idx, uint8_t preamble_status) {\n    if (target_cal_idx >= g_active_cal_points) {\n        return; \n    }\n\n    uint32_t entry_start_byte_pos = (uint32_t)target_cal_idx * SINGLE_CAL_ENTRY_TOTAL_SIZE;\n\n    int32_t target_byte_pos = (int32_t)entry_start_byte_pos + CAL_ENTRY_PREAMBLE_BYTE_OFFSET;\n\n    if (target_byte_pos >= 0 && target_byte_pos < (MAX_CALIBRATION_POINTS * SINGLE_CAL_ENTRY_TOTAL_SIZE)) {\n        g_calibration_buffer[target_byte_pos] = preamble_status;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <string.h>\n\n#define MAX_DIAG_EVENTS 10\n#define DIAG_EVENT_DATA_SIZE 16\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp;\n    uint8_t  data_len;\n    uint8_t  diag_data[DIAG_EVENT_DATA_SIZE];\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diag_event_buffer[MAX_DIAG_EVENTS];\nstatic uint8_t g_num_active_events = 0;\n\nvoid init_diag_system() {\n    for (uint8_t i = 0; i < MAX_DIAG_EVENTS; ++i) {\n        memset(&g_diag_event_buffer[i], 0, sizeof(DiagnosticEvent));\n    }\n    g_num_active_events = 0;\n}\n\nbool add_diag_event(uint16_t event_id, uint32_t timestamp, const uint8_t* initial_data, uint8_t initial_data_len) {\n    if (g_num_active_events >= MAX_DIAG_EVENTS) {\n        return false;\n    }\n    if (initial_data_len > DIAG_EVENT_DATA_SIZE) {\n        initial_data_len = DIAG_EVENT_DATA_SIZE;\n    }\n\n    g_diag_event_buffer[g_num_active_events].event_id = event_id;\n    g_diag_event_buffer[g_num_active_events].timestamp = timestamp;\n    g_diag_event_buffer[g_num_active_events].data_len = initial_data_len;\n    if (initial_data && initial_data_len > 0) {\n        for (uint8_t i = 0; i < initial_data_len; ++i) {\n            g_diag_event_buffer[g_num_active_events].diag_data[i] = initial_data[i];\n        }\n    }\n    g_num_active_events++;\n    return true;\n}\n\nvoid clear_diag_data_byte_vulnerable(uint16_t target_event_id, int16_t relative_offset_from_data_end) {\n    int event_idx = -1;\n    for (int i = 0; i < g_num_active_events; ++i) {\n        if (g_diag_event_buffer[i].event_id == target_event_id) {\n            event_idx = i;\n            break;\n        }\n    }\n\n    if (event_idx == -1 || g_diag_event_buffer[event_idx].data_len == 0) {\n        return;\n    }\n\n    int32_t target_byte_index = (int32_t)g_diag_event_buffer[event_idx].data_len - 1 - relative_offset_from_data_end;\n\n    g_diag_event_buffer[event_idx].diag_data[target_byte_index] = 0x00;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SCRATCHPAD_BUFFER_SIZE 256\n#define MAX_TEMP_DATA_BLOCKS 16\n\ntypedef struct {\n    uint16_t start_offset;\n    uint16_t size;\n    bool active;\n} TempDataBlock;\n\nstatic uint8_t g_scratchpad_buffer_fixed[SCRATCHPAD_BUFFER_SIZE];\nstatic TempDataBlock g_data_blocks_meta_fixed[MAX_TEMP_DATA_BLOCKS];\nstatic uint8_t g_num_active_blocks_fixed = 0;\n\nvoid init_scratchpad_manager_fixed() {\n    memset(g_scratchpad_buffer_fixed, 0, SCRATCHPAD_BUFFER_SIZE);\n    memset(g_data_blocks_meta_fixed, 0, sizeof(g_data_blocks_meta_fixed));\n    g_num_active_blocks_fixed = 0;\n}\n\nint16_t allocate_data_block_fixed(uint16_t requested_size) {\n    if (g_num_active_blocks_fixed >= MAX_TEMP_DATA_BLOCKS || requested_size == 0) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n    if (g_num_active_blocks_fixed > 0) {\n        TempDataBlock *last_block = &g_data_blocks_meta_fixed[g_num_active_blocks_fixed - 1];\n        current_offset = last_block->start_offset + last_block->size;\n    }\n\n    if (current_offset + requested_size > SCRATCHPAD_BUFFER_SIZE) {\n        return -1;\n    }\n\n    g_data_blocks_meta_fixed[g_num_active_blocks_fixed].start_offset = current_offset;\n    g_data_blocks_meta_fixed[g_num_active_blocks_fixed].size = requested_size;\n    g_data_blocks_meta_fixed[g_num_active_blocks_fixed].active = true;\n    g_num_active_blocks_fixed++;\n\n    return g_num_active_blocks_fixed - 1;\n}\n\nvoid write_block_data_fixed(int16_t block_idx, uint16_t offset_in_block, uint8_t value) {\n    if (block_idx < 0 || block_idx >= g_num_active_blocks_fixed || !g_data_blocks_meta_fixed[block_idx].active) {\n        return;\n    }\n    if (offset_in_block >= g_data_blocks_meta_fixed[block_idx].size) {\n        return;\n    }\n\n    uint16_t actual_buffer_idx = g_data_blocks_meta_fixed[block_idx].start_offset + offset_in_block;\n    if (actual_buffer_idx < SCRATCHPAD_BUFFER_SIZE) {\n        g_scratchpad_buffer_fixed[actual_buffer_idx] = value;\n    }\n}\n\nvoid adjust_block_byte_fixed(int16_t block_idx, int32_t relative_offset_from_start, uint8_t new_value) {\n    if (block_idx < 0 || block_idx >= g_num_active_blocks_fixed || !g_data_blocks_meta_fixed[block_idx].active) {\n        return; \n    }\n\n    uint16_t block_start = g_data_blocks_meta_fixed[block_idx].start_offset;\n    uint16_t block_size = g_data_blocks_meta_fixed[block_idx].size;\n\n    int32_t potential_target_idx = (int32_t)block_start + relative_offset_from_start;\n\n    if (potential_target_idx < 0 || potential_target_idx >= SCRATCHPAD_BUFFER_SIZE) {\n        return; \n    }\n\n    uint16_t target_idx = (uint16_t)potential_target_idx;\n\n    if (target_idx < block_start || target_idx >= (block_start + block_size)) {\n        return; \n    }\n\n    g_scratchpad_buffer_fixed[target_idx] = new_value;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_SENSOR_READINGS 64\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    int16_t  temperature_celsius;\n    uint16_t pressure_kpa;\n    uint8_t  sensor_status; \n} SensorReading;\n\nstatic SensorReading g_sensor_data_log[MAX_SENSOR_READINGS];\nstatic uint16_t g_current_log_size = 0; \n\nvoid init_sensor_log() {\n    memset(g_sensor_data_log, 0, sizeof(g_sensor_data_log));\n    g_current_log_size = 0;\n}\n\nbool add_sensor_reading(uint32_t ts, int16_t temp, uint16_t press, uint8_t status) {\n    if (g_current_log_size >= MAX_SENSOR_READINGS) {\n        return false; \n    }\n    g_sensor_data_log[g_current_log_size].timestamp_ms = ts;\n    g_sensor_data_log[g_current_log_size].temperature_celsius = temp;\n    g_sensor_data_log[g_current_log_size].pressure_kpa = press;\n    g_sensor_data_log[g_current_log_size].sensor_status = status;\n    g_current_log_size++;\n    return true;\n}\n\nvoid correct_sensor_readings_backward_vulnerable(uint16_t start_offset_from_end, uint16_t correction_window_size) {\n    if (g_current_log_size == 0 || correction_window_size == 0) {\n        return;\n    }\n\n    int32_t effective_start_idx = (int32_t)g_current_log_size - 1 - start_offset_from_end;\n\n    for (int32_t i = 0; i < (int32_t)correction_window_size; ++i) {\n        int32_t current_idx = effective_start_idx - i;\n\n        if (current_idx >= (int32_t)g_current_log_size) {\n            continue;\n        }\n\n        if (g_sensor_data_log[current_idx].sensor_status == 1) { \n            if (current_idx + 1 < g_current_log_size) {\n                g_sensor_data_log[current_idx].temperature_celsius = g_sensor_data_log[current_idx+1].temperature_celsius;\n            } else if (current_idx - 1 >= 0) {\n                g_sensor_data_log[current_idx].temperature_celsius = g_sensor_data_log[current_idx-1].temperature_celsius;\n            } else {\n                g_sensor_data_log[current_idx].temperature_celsius = 0;\n            }\n        }\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CAL_DATA_BANK_SIZE_BYTES 1024\n#define CAL_BLOCK_SIZE_BYTES 16\n\nstatic uint8_t g_calibration_bank[CAL_DATA_BANK_SIZE_BYTES];\nstatic size_t g_next_free_offset = 0;\n\nvoid init_calibration_bank() {\n    memset(g_calibration_bank, 0xFF, CAL_DATA_BANK_SIZE_BYTES);\n    g_next_free_offset = 0;\n}\n\nbool write_calibration_block(uint16_t id, const uint8_t* data) {\n    if (g_next_free_offset + CAL_BLOCK_SIZE_BYTES > CAL_DATA_BANK_SIZE_BYTES) {\n        return false;\n    }\n\n    uint8_t* block_ptr = g_calibration_bank + g_next_free_offset;\n    *((uint16_t*)block_ptr) = id; \n    *((uint16_t*)(block_ptr + 2)) = 0; \n    memcpy(block_ptr + 4, data, CAL_BLOCK_SIZE_BYTES - 4);\n\n    g_next_free_offset += CAL_BLOCK_SIZE_BYTES;\n    return true;\n}\n\nvoid invalidate_previous_cal_block_fixed(uint16_t blocks_ago_to_invalidate) {\n    if (g_next_free_offset == 0) {\n        return;\n    }\n\n    int32_t target_offset_signed = (int32_t)g_next_free_offset - ((int32_t)blocks_ago_to_invalidate * CAL_BLOCK_SIZE_BYTES);\n\n    if (target_offset_signed < 0 || target_offset_signed >= CAL_DATA_BANK_SIZE_BYTES || (target_offset_signed % CAL_BLOCK_SIZE_BYTES != 0)) {\n        return;\n    }\n    \n    *((uint16_t*)(g_calibration_bank + target_offset_signed)) = 0x0000;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CALIBRATION_DATA_SIZE 256\n#define VALID_CALIBRATION_CONTEXT_MAX_OFFSET 150\n\nstatic uint16_t g_system_calibrations[CALIBRATION_DATA_SIZE];\nstatic int16_t g_active_calibration_base_offset = 0;\n\nvoid init_calibration_system() {\n    memset(g_system_calibrations, 0xFF, sizeof(g_system_calibrations));\n    g_active_calibration_base_offset = 0;\n}\n\nvoid set_active_calibration_context_vulnerable(uint16_t context_id) {\n    switch (context_id) {\n        case 0x01: \n            g_active_calibration_base_offset = 0;\n            break;\n        case 0x02: \n            g_active_calibration_base_offset = 50;\n            break;\n        case 0x03: \n            g_active_calibration_base_offset = 100;\n            break;\n        case 0xFF: \n            g_active_calibration_base_offset = -10; \n            break;\n        default: \n            g_active_calibration_base_offset = 0; \n            break;\n    }\n}\n\nstatic void log_calibration_update_attempt(int32_t index, uint16_t value) {\n    volatile int32_t dummy_idx = index;\n    volatile uint16_t dummy_val = value;\n    (void)dummy_idx;\n    (void)dummy_val;\n}\n\nvoid modify_calibration_value_vulnerable(int16_t relative_index_within_context, uint16_t new_value) {\n    int32_t target_absolute_index = g_active_calibration_base_offset + relative_index_within_context;\n\n    log_calibration_update_attempt(target_absolute_index, new_value);\n\n    g_system_calibrations[target_absolute_index] = new_value;\n}\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_DIAGNOSTIC_DOMAINS 3\n#define MAX_DTCS_PER_DOMAIN_GLOBAL 20\n\ntypedef enum {\n    DOMAIN_POWERTRAIN = 0,\n    DOMAIN_CHASSIS,\n    DOMAIN_INFOTAINMENT,\n    DOMAIN_COUNT\n} DiagnosticDomainId;\n\ntypedef struct {\n    bool active;\n    bool pending;\n    bool history;\n    uint8_t failure_count;\n} DtcStatus;\n\nstatic DtcStatus g_domainDtcStatuses[MAX_DIAGNOSTIC_DOMAINS][MAX_DTCS_PER_DOMAIN_GLOBAL];\n\nstatic const uint8_t g_actualDtcCountsPerDomain[MAX_DIAGNOSTIC_DOMAINS] = {\n    10,\n    15,\n    5\n};\n\ntypedef struct {\n    DiagnosticDomainId domain_id;\n    uint8_t dtc_index;\n    uint8_t command_type;\n} DiagnosticCommand;\n\nvoid logDiagnosticEvent(const char* msg) {\n}\n\nDiagnosticCommand receiveDiagnosticCommand_fixed() {\n    DiagnosticCommand cmd;\n    cmd.domain_id = DOMAIN_POWERTRAIN;\n    cmd.dtc_index = 12;\n    cmd.command_type = 0x01;\n    return cmd;\n}\n\nvoid initializeDtcStatuses_fixed() {\n    for (uint8_t i = 0; i < MAX_DIAGNOSTIC_DOMAINS; ++i) {\n        for (uint8_t j = 0; j < MAX_DTCS_PER_DOMAIN_GLOBAL; ++j) {\n            g_domainDtcStatuses[i][j] = (DtcStatus){false, false, false, 0};\n        }\n    }\n}\n\nvoid processDiagnosticCommand_fixed() {\n    DiagnosticCommand cmd = receiveDiagnosticCommand_fixed();\n\n    if (cmd.domain_id < DOMAIN_COUNT) {\n        if (cmd.dtc_index < g_actualDtcCountsPerDomain[cmd.domain_id]) {\n            switch (cmd.command_type) {\n                case 0x01:\n                    g_domainDtcStatuses[cmd.domain_id][cmd.dtc_index].active = false;\n                    logDiagnosticEvent(\"DTC active flag cleared.\");\n                    break;\n                case 0x02:\n                    g_domainDtcStatuses[cmd.domain_id][cmd.dtc_index].pending = false;\n                    logDiagnosticEvent(\"DTC pending flag cleared.\");\n                    break;\n                default:\n                    logDiagnosticEvent(\"Unknown diagnostic command type received.\");\n                    break;\n            }\n        } else {\n            logDiagnosticEvent(\"Diagnostic command with out-of-bounds DTC index for specific domain. Ignoring.\");\n        }\n    } else {\n        logDiagnosticEvent(\"Diagnostic command with invalid domain ID received. Ignoring.\");\n    }\n}\n\nvoid ecuDiagnosticManager_fixed() {\n    initializeDtcStatuses_fixed();\n    processDiagnosticCommand_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_LOG_TOTAL_BUFFER_SIZE 256\n#define DIAG_LOG_ENTRY_HEADER_SIZE 8 // Example header: Event ID (1), Reserved (5), DataLength (2)\n#define DIAG_LOG_MAX_PAYLOAD_SIZE 64 // Max size of data payload for a single entry\n\n// The main circular buffer for diagnostic logs\nstatic uint8_t g_diagLogBuffer[DIAG_LOG_TOTAL_BUFFER_SIZE];\n// Pointer to the start of the current active log entry being filled\n// This pointer moves in a circular fashion within g_diagLogBuffer.\nstatic uint16_t g_currentEntryStart = 0;\n\nvoid initDiagnosticLogger() {\n    memset(g_diagLogBuffer, 0, DIAG_LOG_TOTAL_BUFFER_SIZE);\n    g_currentEntryStart = 0;\n}\n\n// This function is called to prepare space for a new log entry.\n// It reserves the space and writes a simplified header.\n// 'intended_payload_len' is the expected maximum length of data for this entry's payload.\nint createNewLogEntry(uint8_t event_type, uint16_t intended_payload_len) {\n    uint16_t total_entry_size = DIAG_LOG_ENTRY_HEADER_SIZE + intended_payload_len;\n\n    if (intended_payload_len > DIAG_LOG_MAX_PAYLOAD_SIZE) {\n        return -1; // Payload length exceeds maximum allowed for any single entry\n    }\n    if (total_entry_size > DIAG_LOG_TOTAL_BUFFER_SIZE) {\n        return -2; // Entry too large for the entire buffer\n    }\n\n    // Handle circular buffer wrap-around for the start of the new entry.\n    // If the new entry doesn't fit contiguously, wrap to the beginning.\n    if (g_currentEntryStart + total_entry_size > DIAG_LOG_TOTAL_BUFFER_SIZE) {\n        g_currentEntryStart = 0; // Wrap to beginning of buffer\n    }\n\n    // Write simplified header data at g_currentEntryStart\n    g_diagLogBuffer[g_currentEntryStart] = event_type; // Byte 0: Event Type\n    // Bytes 1-5 reserved/other header fields (for simplicity, assumed to be 0)\n    // Bytes 6-7: Data Length (MSB, LSB) - stored here for later reference\n    g_diagLogBuffer[g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE - 2] = (uint8_t)(intended_payload_len >> 8);\n    g_diagLogBuffer[g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE - 1] = (uint8_t)(intended_payload_len & 0xFF);\n\n    return 0; // Success\n}\n\n// This function is used to update a specific byte within the payload\n// of the *current* active log entry. This is often used for incrementally\n// filling or correcting log data.\n// 'payload_offset': The offset FROM THE START OF THE PAYLOAD AREA of the current entry.\n// 'value': The byte value to write.\n//\n// VULNERABILITY: Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-119)\n// The function calculates an absolute write position based on 'g_currentEntryStart',\n// 'DIAG_LOG_ENTRY_HEADER_SIZE', and the user-controlled 'payload_offset'.\n// It only checks if the 'absolute_write_pos' is within the 'DIAG_LOG_TOTAL_BUFFER_SIZE'.\n// It *does not* check if 'payload_offset' exceeds the 'intended_payload_len' (or\n// 'DIAG_LOG_MAX_PAYLOAD_SIZE') that was declared when the entry was created.\n// An attacker can provide a 'payload_offset' value that is greater than the \n// current entry's intended payload length, but still within the total buffer size.\n// This leads to writing past the end of the current log entry's designated payload area,\n// potentially corrupting the header of the next log entry or other critical adjacent data.\nint updateLogEntryPayloadByte(uint16_t payload_offset, uint8_t value) {\n    uint16_t absolute_write_pos = g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE + payload_offset;\n\n    // This check is insufficient. It only prevents writing outside the entire static buffer.\n    // It does not prevent writing outside the *allocated space for the current entry's payload*.\n    if (absolute_write_pos >= DIAG_LOG_TOTAL_BUFFER_SIZE) {\n        return -1; // Attempt to write beyond total log buffer boundaries\n    }\n\n    g_diagLogBuffer[absolute_write_pos] = value;\n    return 0;\n}\n\n// After an entry is fully populated, this function advances the write pointer.\n// 'actual_payload_len': The actual number of payload bytes written for this entry.\nvoid finalizeLogEntry(uint16_t actual_payload_len) {\n    g_currentEntryStart = (g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE + actual_payload_len) % DIAG_LOG_TOTAL_BUFFER_SIZE;\n}\n\n// Public interface to simulate logging a vehicle event with a given data block.\n// This function itself appears safe by respecting effective_payload_len.\nvoid logVehicleEvent(uint8_t event_type, const uint8_t* event_data, uint16_t event_data_len) {\n    if (event_data == NULL || event_data_len == 0) return;\n\n    uint16_t effective_payload_len = event_data_len;\n    if (effective_payload_len > DIAG_LOG_MAX_PAYLOAD_SIZE) {\n        effective_payload_len = DIAG_LOG_MAX_PAYLOAD_SIZE;\n    }\n\n    if (createNewLogEntry(event_type, effective_payload_len) == 0) {\n        for (uint16_t i = 0; i < effective_payload_len; ++i) {\n            // This loop iterates within the correctly bounded effective_payload_len.\n            // The vulnerability is in `updateLogEntryPayloadByte` if called directly\n            // with a manipulated offset.\n            updateLogEntryPayloadByte(i, event_data[i]);\n        }\n        finalizeLogEntry(effective_payload_len);\n    }\n}\n\n// Function simulating an external call that might exploit the vulnerability.\n// In a real system, 'payload_offset' might be extracted from a malicious CAN message\n// or a diagnostic command that allows direct memory access for debugging.\nvoid maliciousDiagnosticPoke(uint16_t offset_from_payload_start, uint8_t value) {\n    // This call directly exploits the lack of bounds checking for payload_offset\n    // within updateLogEntryPayloadByte, allowing a write outside the current entry's\n    // logical payload boundary but within the overall buffer.\n    updateLogEntryPayloadByte(offset_from_payload_start, value);\n}\n\n// Example of how a diagnostic command handler might use these functions\nvoid processDiagnosticCommand(uint8_t command_id, uint8_t* command_payload, uint16_t payload_len) {\n    initDiagnosticLogger(); // Initialize for demonstration\n\n    switch(command_id) {\n        case 0x01: // Standard event logging command\n            logVehicleEvent(0x55, command_payload, payload_len);\n            break;\n        case 0x02: // Special command to 'poke' a byte in the current log entry's data area\n            if (payload_len >= 3) {\n                uint16_t offset = (command_payload[0] << 8) | command_payload[1];\n                uint8_t val = command_payload[2];\n                maliciousDiagnosticPoke(offset, val); // Attacker controls 'offset'\n            }\n            break;\n        // ... other commands\n    }\n}\n", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\n#define DTC_ALIGNMENT_BYTES 4\n\n#pragma pack(push, 1)\nstruct DTCHeader {\n    uint16_t dtc_id;\n    uint16_t data_length;\n};\n\nstruct DTCBatchPacket {\n    uint32_t timestamp;\n    uint16_t num_dtc_entries;\n};\n#pragma pack(pop)\n\nclass DiagnosticBufferFixed {\nprivate:\n    uint8_t* m_consolidated_buffer;\n    size_t   m_current_write_offset;\n    size_t   m_allocated_capacity;\n\npublic:\n    DiagnosticBufferFixed() :\n        m_consolidated_buffer(nullptr),\n        m_current_write_offset(0),\n        m_allocated_capacity(0)\n    {\n        m_allocated_capacity = 1024;\n        m_consolidated_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_consolidated_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~DiagnosticBufferFixed() {\n        if (m_consolidated_buffer) {\n            free(m_consolidated_buffer);\n            m_consolidated_buffer = nullptr;\n        }\n    }\n\n    bool addDTCBatchFixed(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(DTCBatchPacket)) {\n            return false;\n        }\n\n        const DTCBatchPacket* batch_hdr = reinterpret_cast<const DTCBatchPacket*>(packet_data);\n        size_t current_packet_read_offset = sizeof(DTCBatchPacket);\n        \n        size_t total_required_storage_for_batch = 0;\n        \n        static const uint16_t MAX_DTC_ENTRIES = 200; \n        if (batch_hdr->num_dtc_entries > MAX_DTC_ENTRIES) {\n            return false;\n        }\n\n        for (uint16_t i = 0; i < batch_hdr->num_dtc_entries; ++i) {\n            if (current_packet_read_offset > packet_length - sizeof(DTCHeader)) {\n                return false;\n            }\n            const DTCHeader* dtc_hdr = reinterpret_cast<const DTCHeader*>(packet_data + current_packet_read_offset);\n            \n            uint16_t dtc_data_len = dtc_hdr->data_length;\n            \n            if (sizeof(DTCHeader) > std::numeric_limits<size_t>::max() - dtc_data_len) {\n                return false;\n            }\n            size_t entry_total_raw_size = sizeof(DTCHeader) + dtc_data_len;\n\n            if (current_packet_read_offset > packet_length - entry_total_raw_size) {\n                return false;\n            }\n\n            // FIX: Correctly calculate the actual padded size needed for each entry\n            size_t entry_actual_storage_size = (entry_total_raw_size + DTC_ALIGNMENT_BYTES - 1) & ~(DTC_ALIGNMENT_BYTES - 1);\n            \n            // Check for integer overflow before accumulating to total_required_storage_for_batch\n            if (total_required_storage_for_batch > std::numeric_limits<size_t>::max() - entry_actual_storage_size) {\n                return false;\n            }\n            total_required_storage_for_batch += entry_actual_storage_size;\n\n            current_packet_read_offset += entry_total_raw_size;\n        }\n\n        // FIX: Use the correctly calculated 'total_required_storage_for_batch' for buffer sizing.\n        if (m_current_write_offset > std::numeric_limits<size_t>::max() - total_required_storage_for_batch) {\n            return false;\n        }\n        size_t required_total_space = m_current_write_offset + total_required_storage_for_batch;\n        \n        if (required_total_space > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity * 2;\n            if (new_capacity < m_allocated_capacity) { \n                new_capacity = std::numeric_limits<size_t>::max();\n            }\n            if (new_capacity < required_total_space) {\n                new_capacity = required_total_space;\n            }\n            \n            static const size_t MAX_CONSOLIDATED_BUFFER_SIZE = 10 * 1024 * 1024; \n            if (new_capacity > MAX_CONSOLIDATED_BUFFER_SIZE) {\n                if (required_total_space > MAX_CONSOLIDATED_BUFFER_SIZE) {\n                    return false;\n                }\n                new_capacity = MAX_CONSOLIDATED_BUFFER_SIZE;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_consolidated_buffer, new_capacity);\n            if (!new_buffer) {\n                free(m_consolidated_buffer);\n                m_consolidated_buffer = nullptr;\n                m_current_write_offset = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_consolidated_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        current_packet_read_offset = sizeof(DTCBatchPacket);\n\n        for (uint16_t i = 0; i < batch_hdr->num_dtc_entries; ++i) {\n            const DTCHeader* dtc_hdr = reinterpret_cast<const DTCHeader*>(packet_data + current_packet_read_offset);\n            uint16_t dtc_data_len = dtc_hdr->data_length;\n\n            size_t entry_total_raw_size = sizeof(DTCHeader) + dtc_data_len;\n            size_t entry_actual_storage_size = (entry_total_raw_size + DTC_ALIGNMENT_BYTES - 1) & ~(DTC_ALIGNMENT_BYTES - 1);\n            \n            // Final check just before writing to ensure we don't exceed buffer bounds\n            if (m_current_write_offset > m_allocated_capacity - entry_actual_storage_size) {\n                return false;\n            }\n\n            // Copy header bytes manually\n            m_consolidated_buffer[m_current_write_offset] = (uint8_t)(dtc_hdr->dtc_id & 0xFF);\n            m_consolidated_buffer[m_current_write_offset + 1] = (uint8_t)((dtc_hdr->dtc_id >> 8) & 0xFF);\n            m_consolidated_buffer[m_current_write_offset + 2] = (uint8_t)(dtc_hdr->data_length & 0xFF);\n            m_consolidated_buffer[m_current_write_offset + 3] = (uint8_t)((dtc_hdr->data_length >> 8) & 0xFF);\n            \n            // Copy data payload bytes manually\n            const uint8_t* payload_src = packet_data + current_packet_read_offset + sizeof(DTCHeader);\n            for (uint16_t j = 0; j < dtc_data_len; ++j) {\n                m_consolidated_buffer[m_current_write_offset + sizeof(DTCHeader) + j] = payload_src[j];\n            }\n\n            // Fill padding bytes with zeros manually\n            size_t bytes_to_pad = entry_actual_storage_size - entry_total_raw_size;\n            if (bytes_to_pad > 0) {\n                for (size_t k = 0; k < bytes_to_pad; ++k) {\n                    m_consolidated_buffer[m_current_write_offset + entry_total_raw_size + k] = 0;\n                }\n            }\n            \n            m_current_write_offset += entry_actual_storage_size;\n            current_packet_read_offset += entry_total_raw_size;\n        }\n\n        if (m_current_write_offset > m_allocated_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    size_t getCurrentBufferSize() const { return m_current_write_offset; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n    const uint8_t* getConsolidatedBuffer() const { return m_consolidated_buffer; }\n};\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_FEATURES_FIXED 5\n\ntypedef struct {\n    uint16_t feature_id;\n    bool is_active;\n    uint8_t current_level;\n    uint8_t reserved_status;\n} VehicleFeature_Fixed;\n\nstatic VehicleFeature_Fixed g_vehicleFeatures_fixed[MAX_VEHICLE_FEATURES_FIXED];\n\ntypedef struct {\n    uint16_t command_code;\n    uint8_t target_feature_idx;\n    uint8_t requested_level;\n    uint8_t padding[4];\n} DiagnosticCommand_Fixed;\n\nvoid vehicleSystemLog_fixed(const char* message) {\n}\n\nDiagnosticCommand_Fixed receiveDiagnosticCommand_fixed() {\n    DiagnosticCommand_Fixed cmd;\n    cmd.command_code = 0x10;\n    cmd.target_feature_idx = MAX_VEHICLE_FEATURES_FIXED; \n    cmd.requested_level = 2;\n    cmd.padding[0] = 0; cmd.padding[1] = 0; cmd.padding[2] = 0; cmd.padding[3] = 0;\n    return cmd;\n}\n\nvoid initializeVehicleFeatures_fixed() {\n    for (int i = 0; i < MAX_VEHICLE_FEATURES_FIXED; ++i) {\n        g_vehicleFeatures_fixed[i].feature_id = 1000 + i;\n        g_vehicleFeatures_fixed[i].is_active = false;\n        g_vehicleFeatures_fixed[i].current_level = 0;\n        g_vehicleFeatures_fixed[i].reserved_status = 0;\n    }\n    g_vehicleFeatures_fixed[0].is_active = true;\n    g_vehicleFeatures_fixed[0].current_level = 1;\n    g_vehicleFeatures_fixed[2].is_active = true;\n    g_vehicleFeatures_fixed[2].current_level = 0;\n    vehicleSystemLog_fixed(\"Vehicle features initialized (fixed).\");\n}\n\nvoid processVehicleControlCommand_fixed() {\n    DiagnosticCommand_Fixed cmd = receiveDiagnosticCommand_fixed();\n\n    switch (cmd.command_code) {\n        case 0x10:\n            if (cmd.target_feature_idx < MAX_VEHICLE_FEATURES_FIXED) {\n                g_vehicleFeatures_fixed[cmd.target_feature_idx].current_level = cmd.requested_level;\n                g_vehicleFeatures_fixed[cmd.target_feature_idx].is_active = (cmd.requested_level > 0);\n                vehicleSystemLog_fixed(\"Feature state update processed successfully (fixed).\");\n            } else {\n                vehicleSystemLog_fixed(\"Error: Invalid feature index received in diagnostic command (fixed).\");\n            }\n            break;\n        case 0x11:\n            vehicleSystemLog_fixed(\"Query feature state command received (fixed).\");\n            break;\n        default:\n            vehicleSystemLog_fixed(\"Unsupported diagnostic command received (fixed).\");\n            break;\n    }\n}\n\nvoid vehicleMainControlLoop_fixed() {\n    initializeVehicleFeatures_fixed();\n    processVehicleControlCommand_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <algorithm>\n\nstruct ProcessedTelemetryData {\n    uint32_t timestamp;\n    int32_t  engine_rpm;\n    int16_t  vehicle_speed;\n    uint8_t  gear_position;\n    bool     is_engine_on;\n};\n\nstruct RawTelemetryPacketHeader {\n    uint16_t packet_type;\n    uint16_t num_readings;\n    uint32_t total_payload_bytes;\n};\n\nclass TelemetryDataManager {\npublic:\n    TelemetryDataManager() : data_buffer(nullptr), buffer_capacity(0), current_data_count(0) {}\n\n    ~TelemetryDataManager() {\n        if (data_buffer) {\n            delete[] data_buffer;\n            data_buffer = nullptr;\n        }\n    }\n\n    bool processRawTelemetryPacketFixed(const uint8_t* raw_packet, size_t raw_packet_len) {\n        if (!raw_packet || raw_packet_len < sizeof(RawTelemetryPacketHeader)) {\n            return false;\n        }\n\n        const RawTelemetryPacketHeader* header = reinterpret_cast<const RawTelemetryPacketHeader*>(raw_packet);\n\n        size_t max_actual_payload_in_packet = raw_packet_len - sizeof(RawTelemetryPacketHeader);\n\n        if (static_cast<size_t>(header->total_payload_bytes) > max_actual_payload_in_packet) {\n            return false;\n        }\n\n        size_t requested_num_readings = header->num_readings;\n        \n        if (requested_num_readings > (SIZE_MAX / sizeof(ProcessedTelemetryData))) {\n             return false;\n        }\n        size_t required_allocation_bytes = requested_num_readings * sizeof(ProcessedTelemetryData);\n\n        if (data_buffer) {\n            delete[] data_buffer;\n            data_buffer = nullptr;\n        }\n\n        data_buffer = new (std::nothrow) ProcessedTelemetryData[requested_num_readings];\n        if (!data_buffer) {\n            return false;\n        }\n        buffer_capacity = requested_num_readings;\n\n        size_t bytes_to_copy = std::min({\n            static_cast<size_t>(header->total_payload_bytes),\n            max_actual_payload_in_packet,\n            required_allocation_bytes\n        });\n\n        const uint8_t* payload_start = raw_packet + sizeof(RawTelemetryPacketHeader);\n        for (size_t i = 0; i < bytes_to_copy; ++i) {\n            reinterpret_cast<uint8_t*>(data_buffer)[i] = payload_start[i];\n        }\n\n        current_data_count = bytes_to_copy / sizeof(ProcessedTelemetryData);\n\n        return true;\n    }\n\n    const ProcessedTelemetryData* getTelemetryData() const { return data_buffer; }\n    uint16_t getTelemetryCount() const { return current_data_count; }\n\nprivate:\n    ProcessedTelemetryData* data_buffer;\n    uint16_t                buffer_capacity;\n    uint16_t                current_data_count;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n\n#define MAX_UINT32_DIGITS 10\n\nstruct LoggedEvent {\n    uint32_t event_id;\n    char*    parameter_str;\n    size_t   parameter_str_capacity;\n};\n\nsize_t uint32_to_string_vulnerable(uint32_t value, char* buffer) {\n    if (value == 0) {\n        buffer[0] = '0';\n        buffer[1] = '\\0';\n        return 1;\n    }\n\n    int i = 0;\n    char temp_buffer[MAX_UINT32_DIGITS + 1];\n    \n    uint32_t temp_val = value;\n    while (temp_val > 0) {\n        temp_buffer[i++] = (temp_val % 10) + '0';\n        temp_val /= 10;\n    }\n\n    size_t len = i;\n    for (int j = 0; j < len; j++) {\n        buffer[j] = temp_buffer[i - 1 - j];\n    }\n    buffer[len] = '\\0';\n    return len;\n}\n\nclass DiagnosticMessageProcessorVulnerable {\npublic:\n    DiagnosticMessageProcessorVulnerable() {}\n\n    ~DiagnosticMessageProcessorVulnerable() {\n        clearLoggedEvents();\n    }\n\n    void clearLoggedEvents() {\n        for (auto& event : m_logged_events) {\n            if (event.parameter_str) {\n                free(event.parameter_str);\n            }\n        }\n        m_logged_events.clear();\n    }\n\n    bool logNumericEventVulnerable(uint32_t event_id, uint32_t numeric_value) {\n        LoggedEvent new_event;\n        new_event.event_id = event_id;\n        \n        new_event.parameter_str_capacity = MAX_UINT32_DIGITS;\n        new_event.parameter_str = (char*)malloc(new_event.parameter_str_capacity);\n        if (!new_event.parameter_str && new_event.parameter_str_capacity > 0) {\n            return false;\n        }\n\n        size_t actual_len = uint32_to_string_vulnerable(numeric_value, new_event.parameter_str);\n        \n        if (actual_len >= new_event.parameter_str_capacity) {\n            if (new_event.parameter_str) {\n                free(new_event.parameter_str);\n            }\n            return false;\n        }\n\n        m_logged_events.push_back(new_event);\n        return true;\n    }\n\n    const std::vector<LoggedEvent>& getLoggedEvents() const {\n        return m_logged_events;\n    }\n\nprivate:\n    std::vector<LoggedEvent> m_logged_events;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define LOG_CONTEXT_BUFFER_SIZE 64\n#define LOG_ENTRY_FOOTPRINT_SIZE 4\n\nstatic uint8_t g_log_context_buffer[LOG_CONTEXT_BUFFER_SIZE];\nstatic uint32_t g_current_log_end_ptr_offset = 0;\n\nvoid init_log_context_fixed() {\n    memset(g_log_context_buffer, 0, LOG_CONTEXT_BUFFER_SIZE);\n    g_current_log_end_ptr_offset = 0;\n}\n\nbool add_log_context_entry_fixed(uint32_t entry_value) {\n    if (g_current_log_end_ptr_offset + LOG_ENTRY_FOOTPRINT_SIZE > LOG_CONTEXT_BUFFER_SIZE) {\n        g_current_log_end_ptr_offset = 0;\n    }\n    g_log_context_buffer[g_current_log_end_ptr_offset + 0] = (uint8_t)(entry_value >> 24);\n    g_log_context_buffer[g_current_log_end_ptr_offset + 1] = (uint8_t)(entry_value >> 16);\n    g_log_context_buffer[g_current_log_end_ptr_offset + 2] = (uint8_t)(entry_value >> 8);\n    g_log_context_buffer[g_current_log_end_ptr_offset + 3] = (uint8_t)(entry_value);\n\n    g_current_log_end_ptr_offset += LOG_ENTRY_FOOTPRINT_SIZE;\n    return true;\n}\n\nvoid update_historical_log_context_fixed(int16_t offset_from_current, uint32_t new_context_value) {\n    if (g_current_log_end_ptr_offset == 0) {\n        return;\n    }\n\n    int32_t potential_target_byte_offset = (int32_t)g_current_log_end_ptr_offset - (offset_from_current * LOG_ENTRY_FOOTPRINT_SIZE);\n\n    if (potential_target_byte_offset < 0) {\n        return;\n    }\n\n    uint32_t target_byte_offset = (uint32_t)potential_target_byte_offset;\n\n    if (target_byte_offset + LOG_ENTRY_FOOTPRINT_SIZE > LOG_CONTEXT_BUFFER_SIZE) {\n        return;\n    }\n    \n    g_log_context_buffer[target_byte_offset + 0] = (uint8_t)(new_context_value >> 24);\n    g_log_context_buffer[target_byte_offset + 1] = (uint8_t)(new_context_value >> 16);\n    g_log_context_buffer[target_byte_offset + 2] = (uint8_t)(new_context_value >> 8);\n    g_log_context_buffer[target_byte_offset + 3] = (uint8_t)(new_context_value);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_TEMPERATURE_SENSORS 10\n#define MAX_PRESSURE_SENSORS 5\n#define MAX_FUEL_LEVEL_SENSORS 2\n\ntypedef struct {\n    int16_t offset;\n    float gain;\n    uint8_t status_flags;\n} TemperatureCalibration;\n\ntypedef struct {\n    int16_t offset_low;\n    int16_t offset_high;\n    float gain;\n    uint8_t checksum;\n} PressureCalibration;\n\ntypedef struct {\n    uint16_t empty_resistance_ohm;\n    uint16_t full_resistance_ohm;\n} FuelLevelCalibration;\n\nstatic TemperatureCalibration g_tempCalibData[MAX_TEMPERATURE_SENSORS];\nstatic PressureCalibration g_pressureCalibData[MAX_PRESSURE_SENSORS];\nstatic FuelLevelCalibration g_fuelLevelCalibData[MAX_FUEL_LEVEL_SENSORS];\n\ntypedef enum {\n    SENSOR_TYPE_TEMP = 0,\n    SENSOR_TYPE_PRESSURE,\n    SENSOR_TYPE_FUEL_LEVEL,\n    NUM_SENSOR_TYPES_CALIB\n} SensorCalibrationType;\n\ntypedef struct {\n    uint8_t command_type;\n    uint8_t sensor_type_id;\n    uint8_t sensor_instance_id;\n    union {\n        TemperatureCalibration temp_cal;\n        PressureCalibration pres_cal;\n        FuelLevelCalibration fuel_cal;\n    } cal_data;\n} CalibrationCommand;\n\nvoid systemLog(const char* msg) {\n}\n\nCalibrationCommand receiveCalibrationCommand_vulnerable() {\n    CalibrationCommand cmd;\n    cmd.command_type = 0x01;\n    cmd.sensor_type_id = SENSOR_TYPE_TEMP;\n    cmd.sensor_instance_id = MAX_TEMPERATURE_SENSORS;\n    cmd.cal_data.temp_cal = (TemperatureCalibration){-5, 1.05f, 0x0F};\n    return cmd;\n}\n\nvoid initializeCalibrationData_vulnerable() {\n    for (uint8_t i = 0; i < MAX_TEMPERATURE_SENSORS; ++i) {\n        g_tempCalibData[i] = (TemperatureCalibration){0, 1.0f, 0};\n    }\n    for (uint8_t i = 0; i < MAX_PRESSURE_SENSORS; ++i) {\n        g_pressureCalibData[i] = (PressureCalibration){0, 0, 1.0f, 0};\n    }\n    for (uint8_t i = 0; i < MAX_FUEL_LEVEL_SENSORS; ++i) {\n        g_fuelLevelCalibData[i] = (FuelLevelCalibration){0, 0};\n    }\n    systemLog(\"Calibration data initialized (vulnerable).\");\n}\n\nvoid processCalibrationCommand_vulnerable() {\n    CalibrationCommand cmd = receiveCalibrationCommand_vulnerable();\n\n    if (cmd.command_type == 0x01) {\n        switch (cmd.sensor_type_id) {\n            case SENSOR_TYPE_TEMP:\n                g_tempCalibData[cmd.sensor_instance_id] = cmd.cal_data.temp_cal;\n                systemLog(\"Temperature sensor calibration update attempted (vulnerable).\");\n                break;\n            case SENSOR_TYPE_PRESSURE:\n                g_pressureCalibData[cmd.sensor_instance_id] = cmd.cal_data.pres_cal;\n                systemLog(\"Pressure sensor calibration update attempted (vulnerable).\");\n                break;\n            case SENSOR_TYPE_FUEL_LEVEL:\n                g_fuelLevelCalibData[cmd.sensor_instance_id] = cmd.cal_data.fuel_cal;\n                systemLog(\"Fuel level sensor calibration update attempted (vulnerable).\");\n                break;\n            default:\n                systemLog(\"Unknown sensor type ID in calibration command (vulnerable).\");\n                break;\n        }\n    } else {\n        systemLog(\"Unsupported calibration command type (vulnerable).\");\n    }\n}\n\nvoid sensorCalibrationManager_vulnerable_main() {\n    initializeCalibrationData_vulnerable();\n    processCalibrationCommand_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stddef.h>\n\n#define MAX_CONFIG_PARAMETERS 15\n\nstatic long g_engineRPMTarget = 0;\nstatic long g_gearShiftThreshold = 0;\nstatic long g_suspensionHeightOffset = 0;\n\ntypedef struct {\n    long* valuePtr;\n    long  minValue;\n    long  maxValue;\n} ConfigParameterInfo;\n\nstatic ConfigParameterInfo g_configParameterMap[MAX_CONFIG_PARAMETERS];\n\nvoid initializeParameterMap() {\n    g_configParameterMap[0].valuePtr = &g_engineRPMTarget;\n    g_configParameterMap[0].minValue = 500;\n    g_configParameterMap[0].maxValue = 7000;\n\n    g_configParameterMap[1].valuePtr = &g_gearShiftThreshold;\n    g_configParameterMap[1].minValue = 1000;\n    g_configParameterMap[1].maxValue = 6000;\n\n    g_configParameterMap[2].valuePtr = &g_suspensionHeightOffset;\n    g_configParameterMap[2].minValue = -50;\n    g_configParameterMap[2].maxValue = 50;\n\n    for (int i = 3; i < MAX_CONFIG_PARAMETERS; ++i) {\n        g_configParameterMap[i].valuePtr = NULL;\n        g_configParameterMap[i].minValue = 0;\n        g_configParameterMap[i].maxValue = 0;\n    }\n}\n\ntypedef struct {\n    unsigned char commandID;\n    unsigned char parameterIndex;\n    long          newValue;\n} ParameterUpdateCommand;\n\nParameterUpdateCommand receiveParameterUpdateCommand_fixed() {\n    ParameterUpdateCommand cmd;\n    cmd.commandID = 0x05;\n    cmd.parameterIndex = 20;\n    cmd.newValue = 9999;\n    return cmd;\n}\n\nvoid logVehicleWarning(const char* msg) {\n}\n\nvoid processParameterUpdate_fixed() {\n    ParameterUpdateCommand command = receiveParameterUpdateCommand_fixed();\n\n    if (command.commandID == 0x05) {\n        if (command.parameterIndex < MAX_CONFIG_PARAMETERS) {\n            ConfigParameterInfo paramInfo = g_configParameterMap[command.parameterIndex];\n\n            if (paramInfo.valuePtr != NULL) {\n                if (command.newValue >= paramInfo.minValue && command.newValue <= paramInfo.maxValue) {\n                    *(paramInfo.valuePtr) = command.newValue;\n                } else {\n                    logVehicleWarning(\"Parameter update value out of allowed range.\");\n                }\n            } else {\n                logVehicleWarning(\"Attempted to update unregistered parameter.\");\n            }\n        } else {\n            logVehicleWarning(\"Received parameter update with out-of-bounds index.\");\n        }\n    } else {\n        logVehicleWarning(\"Received unsupported parameter command ID.\");\n    }\n}\n\nvoid ecuMainLoop_fixed() {\n    initializeParameterMap();\n    processParameterUpdate_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#define MAX_SENSORS 10#define CAN_MESSAGE_ID_CALIBRATION_UPDATE 0x18F00100#define CAN_MESSAGE_DLC_CALIBRATION 3typedef struct {unsigned int id; unsigned char data[8]; unsigned char dlc;} CanMessage;static int g_sensorCalibrationData[MAX_SENSORS];void logError(const char* msg) {}CanMessage receiveCANMessage_simulated() {CanMessage msg; msg.id = CAN_MESSAGE_ID_CALIBRATION_UPDATE; msg.dlc = CAN_MESSAGE_DLC_CALIBRATION; msg.data[0] = 15; msg.data[1] = 0x01; msg.data[2] = 0x23; for (int i = msg.dlc; i < 8; ++i) {msg.data[i] = 0;} return msg;}void systemInit() {for (int i = 0; i < MAX_SENSORS; ++i) {g_sensorCalibrationData[i] = 0;}}void processCanCommand_fixed(const CanMessage* msg) {if (msg->id == CAN_MESSAGE_ID_CALIBRATION_UPDATE && msg->dlc >= CAN_MESSAGE_DLC_CALIBRATION) {unsigned char sensorId = msg->data[0]; int calibrationValue = (msg->data[1] << 8) | msg->data[2]; if (sensorId < MAX_SENSORS) {g_sensorCalibrationData[sensorId] = calibrationValue;} else {logError(\"Received out-of-bounds sensor ID for calibration update. Ignoring command.\");}}}void vehicleECUMainLoop_fixed() {systemInit(); CanMessage receivedMsg = receiveCANMessage_simulated(); processCanCommand_fixed(&receivedMsg);}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRIES_PER_PRIORITY_FIXED 10\n\ntypedef enum {\n    PRIO_CRITICAL_FIXED = 0,\n    PRIO_MAJOR_FIXED,\n    PRIO_MINOR_FIXED,\n    PRIO_INFO_FIXED,\n    NUM_PRIORITY_LEVELS_FIXED\n} EventPriority_Fixed;\n\ntypedef struct {\n    uint32_t event_id;\n    uint32_t timestamp;\n    uint8_t flags;\n} IncomingLogMessage_Fixed;\n\ntypedef struct {\n    uint32_t id;\n    uint32_t time;\n} LogEntry_Fixed;\n\nstatic LogEntry_Fixed g_logBuffer_fixed[NUM_PRIORITY_LEVELS_FIXED][MAX_LOG_ENTRIES_PER_PRIORITY_FIXED];\nstatic uint8_t g_logCounts_fixed[NUM_PRIORITY_LEVELS_FIXED];\n\nvoid automotive_system_log_fixed(const char* msg) {\n    (void)msg;\n}\n\nIncomingLogMessage_Fixed receiveLogMessage_fixed() {\n    IncomingLogMessage_Fixed msg;\n    msg.event_id = 0xABCD1234;\n    msg.timestamp = 0x567890AB;\n    msg.flags = 0x40;\n    automotive_system_log_fixed(\"Simulated incoming log message with potentially malicious flags.\");\n    return msg;\n}\n\nvoid initializeLoggingSystem_fixed() {\n    for (uint8_t i = 0; i < NUM_PRIORITY_LEVELS_FIXED; ++i) {\n        g_logCounts_fixed[i] = 0;\n        for (uint8_t j = 0; j < MAX_LOG_ENTRIES_PER_PRIORITY_FIXED; ++j) {\n            g_logBuffer_fixed[i][j].id = 0;\n            g_logBuffer_fixed[i][j].time = 0;\n        }\n    }\n    automotive_system_log_fixed(\"Logging system initialized (fixed).\");\n}\n\nvoid processIncomingLog_fixed() {\n    IncomingLogMessage_Fixed msg = receiveLogMessage_fixed();\n\n    uint8_t raw_prio_val = (msg.flags >> 4) & 0x0F;\n\n    if (raw_prio_val < NUM_PRIORITY_LEVELS_FIXED) {\n        EventPriority_Fixed actual_priority = (EventPriority_Fixed)raw_prio_val;\n\n        if (g_logCounts_fixed[actual_priority] < MAX_LOG_ENTRIES_PER_PRIORITY_FIXED) {\n            g_logBuffer_fixed[actual_priority][g_logCounts_fixed[actual_priority]].id = msg.event_id;\n            g_logBuffer_fixed[actual_priority][g_logCounts_fixed[actual_priority]].time = msg.timestamp;\n            g_logCounts_fixed[actual_priority]++;\n            automotive_system_log_fixed(\"Log entry stored based on derived priority.\");\n        } else {\n            automotive_system_log_fixed(\"Log buffer full for this priority level. Dropping message.\");\n        }\n    } else {\n        automotive_system_log_fixed(\"Invalid derived priority level from flags. Message dropped.\");\n    }\n}\n\nvoid main_logging_fixed() {\n    initializeLoggingSystem_fixed();\n    processIncomingLog_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\ntypedef struct {\n    uint16_t param_id;\n    uint16_t data_length;\n} ParameterEntryHeader;\n\nclass VehicleConfigurationManagerVulnerable {\npublic:\n    VehicleConfigurationManagerVulnerable() : m_config_buffer(nullptr), m_current_offset(0), m_allocated_capacity(0) {}\n\n    ~VehicleConfigurationManagerVulnerable() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n        }\n    }\n\n    bool addConfigurationParameterVulnerable(uint16_t param_id, const uint8_t* param_data, uint16_t data_len) {\n        if (!param_data || data_len == 0) {\n            return false;\n        }\n\n        size_t entry_total_size = sizeof(ParameterEntryHeader) + data_len;\n\n        size_t padded_data_len = (data_len + 3) & ~3;\n        size_t physical_entry_size = sizeof(ParameterEntryHeader) + padded_data_len;\n\n        if (m_current_offset > (SIZE_MAX - physical_entry_size)) {\n            return false;\n        }\n\n        if (m_config_buffer == nullptr) {\n            m_config_buffer = (uint8_t*)malloc(entry_total_size);\n            if (!m_config_buffer) return false;\n            m_allocated_capacity = entry_total_size;\n        } else if (m_current_offset + entry_total_size > m_allocated_capacity) {\n            uint8_t* temp_buffer = (uint8_t*)realloc(m_config_buffer, m_current_offset + entry_total_size);\n            if (!temp_buffer) {\n                free(m_config_buffer);\n                m_config_buffer = nullptr;\n                m_current_offset = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_config_buffer = temp_buffer;\n            m_allocated_capacity = m_current_offset + entry_total_size;\n        }\n\n        ParameterEntryHeader header_to_write = {param_id, data_len};\n        memcpy(m_config_buffer + m_current_offset, &header_to_write, sizeof(ParameterEntryHeader));\n        m_current_offset += sizeof(ParameterEntryHeader);\n\n        memcpy(m_config_buffer + m_current_offset, param_data, data_len);\n        m_current_offset += data_len;\n\n        size_t bytes_to_pad = padded_data_len - data_len;\n        if (bytes_to_pad > 0) {\n            memset(m_config_buffer + m_current_offset, 0, bytes_to_pad);\n            m_current_offset += bytes_to_pad;\n        }\n        \n        return true;\n    }\n\n    const uint8_t* getConfigurationBuffer() const { return m_config_buffer; }\n    size_t getCurrentOffset() const { return m_current_offset; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_config_buffer;\n    size_t   m_current_offset;\n    size_t   m_allocated_capacity;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_STORAGE_SIZE 128\n#define CONFIG_VALUE_BYTE_SIZE 4\n\nstatic uint8_t g_vehicle_config_storage[VEHICLE_CONFIG_STORAGE_SIZE];\nstatic uint32_t g_current_config_data_len = 0;\n\nvoid init_ecu_config_manager() {\n    memset(g_vehicle_config_storage, 0, VEHICLE_CONFIG_STORAGE_SIZE);\n    g_current_config_data_len = 0;\n}\n\nvoid load_config_data_block(const uint8_t* data, uint32_t len) {\n    if (len > VEHICLE_CONFIG_STORAGE_SIZE) {\n        len = VEHICLE_CONFIG_STORAGE_SIZE;\n    }\n    memcpy(g_vehicle_config_storage, data, len);\n    g_current_config_data_len = len;\n}\n\nvoid update_past_config_value_vulnerable(uint32_t start_index_bytes, uint8_t backward_steps_slots, int32_t new_value) {\n    if (start_index_bytes >= g_current_config_data_len) {\n        return;\n    }\n\n    int32_t target_byte_offset = (int32_t)start_index_bytes - ((int32_t)backward_steps_slots * CONFIG_VALUE_BYTE_SIZE);\n\n    g_vehicle_config_storage[target_byte_offset + 0] = (uint8_t)(new_value >> 24);\n    g_vehicle_config_storage[target_byte_offset + 1] = (uint8_t)(new_value >> 16);\n    g_vehicle_config_storage[target_byte_offset + 2] = (uint8_t)(new_value >> 8);\n    g_vehicle_config_storage[target_byte_offset + 3] = (uint8_t)(new_value);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_PARAMETER_GROUPS 3\n#define MAX_PARAMS_PER_GROUP 10\n\ntypedef struct {\n    uint16_t value;\n    uint8_t status;\n} DiagnosticParameter;\n\nDiagnosticParameter g_engineParams[MAX_PARAMS_PER_GROUP];\nDiagnosticParameter g_chassisParams[MAX_PARAMS_PER_GROUP];\nDiagnosticParameter g_batteryParams[MAX_PARAMS_PER_GROUP];\n\ntypedef struct {\n    DiagnosticParameter* data_buffer;\n    uint8_t max_params;\n    uint8_t current_count;\n} ParameterGroupConfig;\n\nstatic ParameterGroupConfig g_paramGroupConfigs_vulnerable[MAX_PARAMETER_GROUPS];\n\nvoid diagnosticLog_vulnerable(const char* msg) {\n    printf(\"DIAG_LOG_VULN: %s\\n\", msg);\n}\n\nvoid initializeDiagnosticSystem_vulnerable() {\n    g_paramGroupConfigs_vulnerable[0] = (ParameterGroupConfig){.data_buffer = g_engineParams, .max_params = MAX_PARAMS_PER_GROUP, .current_count = 0};\n    g_paramGroupConfigs_vulnerable[1] = (ParameterGroupConfig){.data_buffer = g_chassisParams, .max_params = MAX_PARAMS_PER_GROUP, .current_count = 0};\n    g_paramGroupConfigs_vulnerable[2] = (ParameterGroupConfig){.data_buffer = g_batteryParams, .max_params = MAX_PARAMS_PER_GROUP, .current_count = 0};\n    diagnosticLog_vulnerable(\"Diagnostic system initialized (vulnerable).\");\n}\n\ntypedef struct {\n    uint8_t group_id;\n    uint8_t param_idx_to_update;\n    DiagnosticParameter new_value;\n} IncomingDiagnosticUpdate_vulnerable;\n\nIncomingDiagnosticUpdate_vulnerable receiveDiagnosticUpdate_vulnerable() {\n    IncomingDiagnosticUpdate_vulnerable update;\n    update.group_id = 0;\n    update.param_idx_to_update = 10;\n    update.new_value = (DiagnosticParameter){.value = 0xAAAA, .status = 0xFF};\n    return update;\n}\n\nvoid updateDiagnosticParameter_vulnerable(IncomingDiagnosticUpdate_vulnerable update) {\n    if (update.group_id < MAX_PARAMETER_GROUPS) {\n        ParameterGroupConfig* config = &g_paramGroupConfigs_vulnerable[update.group_id];\n        config->data_buffer[update.param_idx_to_update] = update.new_value;\n        diagnosticLog_vulnerable(\"Diagnostic parameter updated (vulnerable).\");\n    } else {\n        diagnosticLog_vulnerable(\"Invalid diagnostic group ID received (vulnerable).\");\n    }\n}\n\nvoid diagnosticManagerLoop_vulnerable() {\n    initializeDiagnosticSystem_vulnerable();\n    IncomingDiagnosticUpdate_vulnerable bad_update = receiveDiagnosticUpdate_vulnerable();\n    updateDiagnosticParameter_vulnerable(bad_update);\n    IncomingDiagnosticUpdate_vulnerable good_update;\n    good_update.group_id = 1;\n    good_update.param_idx_to_update = 2;\n    good_update.new_value = (DiagnosticParameter){.value = 0xBBBB, .status = 0xEE};\n    updateDiagnosticParameter_vulnerable(good_update);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\nstruct DiagnosticMessageHeader {\n    uint16_t message_id;\n    uint16_t data_length; \n    uint32_t timestamp_ms;\n};\n\nstruct DiagnosticPacketHeader {\n    uint32_t packet_sequence_num;\n    uint16_t num_messages;\n    uint16_t reserved;\n};\n#pragma pack(pop)\n\nclass DiagnosticMessageAggregatorVulnerable {\npublic:\n    DiagnosticMessageAggregatorVulnerable()\n        : m_aggregated_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {\n        m_allocated_capacity = 4096;\n        m_aggregated_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (m_aggregated_buffer == nullptr) {\n            m_allocated_capacity = 0;\n        }\n        m_current_size = 0;\n    }\n\n    ~DiagnosticMessageAggregatorVulnerable() {\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n        }\n    }\n\n    bool appendDiagnosticPacketVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeader* packet_header = reinterpret_cast<const DiagnosticPacketHeader*>(raw_packet);\n        size_t current_raw_read_offset = sizeof(DiagnosticPacketHeader);\n\n        for (uint16_t i = 0; i < packet_header->num_messages; ++i) {\n            if (current_raw_read_offset + sizeof(DiagnosticMessageHeader) > packet_len) {\n                return false;\n            }\n\n            const DiagnosticMessageHeader* msg_header = reinterpret_cast<const DiagnosticMessageHeader*>(raw_packet + current_raw_read_offset);\n            uint16_t message_data_len = msg_header->data_length;\n\n            if (current_raw_read_offset + sizeof(DiagnosticMessageHeader) + message_data_len > packet_len) {\n                return false;\n            }\n\n            size_t total_message_storage_size = sizeof(DiagnosticMessageHeader) + message_data_len;\n\n            if (m_current_size > (SIZE_MAX - total_message_storage_size) || \n                m_current_size + total_message_storage_size > m_allocated_capacity) {\n\n                size_t new_capacity = m_allocated_capacity == 0 ? total_message_storage_size : m_allocated_capacity * 2;\n                if (new_capacity < m_current_size + total_message_storage_size) {\n                    new_capacity = m_current_size + total_message_storage_size;\n                }\n                \n                if (new_capacity > (16ULL * 1024 * 1024)) { \n                    if (total_message_storage_size > (16ULL * 1024 * 1024)) {\n                        return false;\n                    }\n                    new_capacity = (16ULL * 1024 * 1024);\n                }\n\n                uint8_t* new_buffer = (uint8_t*)realloc(m_aggregated_buffer, new_capacity);\n                if (!new_buffer) {\n                    if (m_aggregated_buffer) {\n                        free(m_aggregated_buffer);\n                        m_aggregated_buffer = nullptr;\n                    }\n                    m_current_size = 0;\n                    m_allocated_capacity = 0;\n                    return false;\n                }\n                m_aggregated_buffer = new_buffer;\n                m_allocated_capacity = new_capacity;\n            }\n\n            uint8_t* dest_ptr = m_aggregated_buffer + m_current_size;\n            const uint8_t* source_ptr = raw_packet + current_raw_read_offset;\n\n            for (size_t k = 0; k < sizeof(DiagnosticMessageHeader); ++k) {\n                dest_ptr[k] = source_ptr[k];\n            }\n\n            for (size_t k = 0; k < message_data_len; ++k) {\n                dest_ptr[sizeof(DiagnosticMessageHeader) + k] = source_ptr[sizeof(DiagnosticMessageHeader) + k];\n            }\n            \n            \n            m_aggregated_buffer[m_current_size + sizeof(DiagnosticMessageHeader) + message_data_len] = '\\0'; \n\n            m_current_size += total_message_storage_size; \n\n            current_raw_read_offset += sizeof(DiagnosticMessageHeader) + message_data_len;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedBuffer() const { return m_aggregated_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_aggregated_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_VEHICLE_SYSTEMS 3\n#define MAX_CALIBRATION_POINTS_ENGINE 10\n#define MAX_CALIBRATION_POINTS_TRANSMISSION 8\n#define MAX_CALIBRATION_POINTS_BRAKES 5\n\ntypedef union {\n    float float_val;\n    int32_t int_val;\n    uint16_t short_val;\n} CalibrationValue_fixed;\n\nstatic CalibrationValue_fixed g_engineCalibrations_fixed[MAX_CALIBRATION_POINTS_ENGINE];\nstatic CalibrationValue_fixed g_transmissionCalibrations_fixed[MAX_CALIBRATION_POINTS_TRANSMISSION];\nstatic CalibrationValue_fixed g_brakeCalibrations_fixed[MAX_CALIBRATION_POINTS_BRAKES];\n\ntypedef enum {\n    VEHICLE_SYSTEM_ENGINE_FIXED = 0,\n    VEHICLE_SYSTEM_TRANSMISSION_FIXED = 1,\n    VEHICLE_SYSTEM_BRAKES_FIXED = 2,\n    VEHICLE_SYSTEM_INVALID_FIXED = 3\n} VehicleSystemID_fixed;\n\nvoid logVehicleError_fixed(const char* msg) {}\n\ntypedef struct {\n    VehicleSystemID_fixed system_id;\n    uint8_t calibration_index;\n    uint8_t requested_type;\n} CalibrationReadRequest_fixed;\n\nCalibrationReadRequest_fixed getSimulatedCalibrationReadRequest_fixed() {\n    CalibrationReadRequest_fixed req;\n    req.system_id = VEHICLE_SYSTEM_ENGINE_FIXED;\n    req.calibration_index = 12;\n    req.requested_type = 0;\n    return req;\n}\n\nvoid initializeCalibrationData_fixed() {\n    for (uint8_t i = 0; i < MAX_CALIBRATION_POINTS_ENGINE; ++i) {\n        g_engineCalibrations_fixed[i].float_val = (float)i * 1.5f;\n    }\n    for (uint8_t i = 0; i < MAX_CALIBRATION_POINTS_TRANSMISSION; ++i) {\n        g_transmissionCalibrations_fixed[i].int_val = (int32_t)(i * 100);\n    }\n    for (uint8_t i = 0; i < MAX_CALIBRATION_POINTS_BRAKES; ++i) {\n        g_brakeCalibrations_fixed[i].short_val = (uint16_t)(i * 5);\n    }\n}\n\nvoid handleCalibrationReadRequest_fixed(CalibrationReadRequest_fixed request) {\n    CalibrationValue_fixed retrieved_value;\n\n    if (request.system_id >= VEHICLE_SYSTEM_INVALID_FIXED) {\n        logVehicleError_fixed(\"Invalid Vehicle System ID received.\");\n        return;\n    }\n\n    switch (request.system_id) {\n        case VEHICLE_SYSTEM_ENGINE_FIXED:\n            if (request.calibration_index >= MAX_CALIBRATION_POINTS_ENGINE) {\n                logVehicleError_fixed(\"Calibration index out of bounds for Engine system.\");\n                return;\n            }\n            retrieved_value = g_engineCalibrations_fixed[request.calibration_index];\n            break;\n        case VEHICLE_SYSTEM_TRANSMISSION_FIXED:\n            if (request.calibration_index >= MAX_CALIBRATION_POINTS_TRANSMISSION) {\n                logVehicleError_fixed(\"Calibration index out of bounds for Transmission system.\");\n                return;\n            }\n            retrieved_value = g_transmissionCalibrations_fixed[request.calibration_index];\n            break;\n        case VEHICLE_SYSTEM_BRAKES_FIXED:\n            if (request.calibration_index >= MAX_CALIBRATION_POINTS_BRAKES) {\n                logVehicleError_fixed(\"Calibration index out of bounds for Brake system.\");\n                return;\n            }\n            retrieved_value = g_brakeCalibrations_fixed[request.calibration_index];\n            break;\n        default:\n            logVehicleError_fixed(\"Unknown vehicle system ID. Should not happen.\");\n            return;\n    }\n\n    if (request.requested_type == 0) { /* use retrieved_value.float_val */ }\n    else if (request.requested_type == 1) { /* use retrieved_value.int_val */ }\n    else if (request.requested_type == 2) { /* use retrieved_value.short_val */ }\n    else { logVehicleError_fixed(\"Unknown requested type for calibration value.\"); }\n}\n\nvoid main_fixed() {\n    initializeCalibrationData_fixed();\n    CalibrationReadRequest_fixed req = getSimulatedCalibrationReadRequest_fixed();\n    handleCalibrationReadRequest_fixed(req);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SCRATCHPAD_BUFFER_SIZE 256\n#define MAX_TEMP_DATA_BLOCKS 16\n\ntypedef struct {\n    uint16_t start_offset;\n    uint16_t size;\n    bool active;\n} TempDataBlock;\n\nstatic uint8_t g_scratchpad_buffer[SCRATCHPAD_BUFFER_SIZE];\nstatic TempDataBlock g_data_blocks_meta[MAX_TEMP_DATA_BLOCKS];\nstatic uint8_t g_num_active_blocks = 0;\n\nvoid init_scratchpad_manager() {\n    memset(g_scratchpad_buffer, 0, SCRATCHPAD_BUFFER_SIZE);\n    memset(g_data_blocks_meta, 0, sizeof(g_data_blocks_meta));\n    g_num_active_blocks = 0;\n}\n\nint16_t allocate_data_block(uint16_t requested_size) {\n    if (g_num_active_blocks >= MAX_TEMP_DATA_BLOCKS || requested_size == 0) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n    if (g_num_active_blocks > 0) {\n        TempDataBlock *last_block = &g_data_blocks_meta[g_num_active_blocks - 1];\n        current_offset = last_block->start_offset + last_block->size;\n    }\n\n    if (current_offset + requested_size > SCRATCHPAD_BUFFER_SIZE) {\n        return -1;\n    }\n\n    g_data_blocks_meta[g_num_active_blocks].start_offset = current_offset;\n    g_data_blocks_meta[g_num_active_blocks].size = requested_size;\n    g_data_blocks_meta[g_num_active_blocks].active = true;\n    g_num_active_blocks++;\n\n    return g_num_active_blocks - 1;\n}\n\nvoid write_block_data(int16_t block_idx, uint16_t offset_in_block, uint8_t value) {\n    if (block_idx < 0 || block_idx >= g_num_active_blocks || !g_data_blocks_meta[block_idx].active) {\n        return;\n    }\n    if (offset_in_block >= g_data_blocks_meta[block_idx].size) {\n        return;\n    }\n\n    uint16_t actual_buffer_idx = g_data_blocks_meta[block_idx].start_offset + offset_in_block;\n    if (actual_buffer_idx < SCRATCHPAD_BUFFER_SIZE) {\n        g_scratchpad_buffer[actual_buffer_idx] = value;\n    }\n}\n\nvoid adjust_block_byte_vulnerable(int16_t block_idx, int32_t relative_offset_from_start, uint8_t new_value) {\n    if (block_idx < 0 || block_idx >= g_num_active_blocks || !g_data_blocks_meta[block_idx].active) {\n        return; \n    }\n\n    uint16_t block_start = g_data_blocks_meta[block_idx].start_offset;\n\n    int32_t target_idx = (int32_t)block_start + relative_offset_from_start;\n\n    g_scratchpad_buffer[target_idx] = new_value;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stddef.h>\n\ntypedef struct {\n    unsigned int message_id;\n    unsigned char data[8];\n    unsigned char data_length;\n    unsigned long long timestamp_us;\n} CanMessage;\n\n#define MAX_CAN_LOG_ENTRIES 256\nstatic CanMessage message_log_buffer[MAX_CAN_LOG_ENTRIES];\nstatic unsigned int latest_entry_index = 0;\n\nvoid logCanMessage(const CanMessage* msg) {\n    if (msg == NULL) {\n        return;\n    }\n    message_log_buffer[latest_entry_index] = *msg;\n    latest_entry_index = (latest_entry_index + 1) % MAX_CAN_LOG_ENTRIES;\n}\n\ntypedef enum {\n    DIAG_GET_STATUS,\n    DIAG_RETRIEVE_PAST_MESSAGE,\n    DIAG_OVERWRITE_HISTORICAL_MESSAGE,\n    DIAG_PERFORM_CHECKSUM_CALC\n} DiagnosticCommandType;\n\ntypedef struct {\n    DiagnosticCommandType type;\n    int historical_offset_steps;\n    CanMessage payload_data;\n} DiagnosticCommand;\n\nvoid processDiagnosticCommand_Vulnerable(const DiagnosticCommand* cmd) {\n    if (cmd == NULL) {\n        return;\n    }\n\n    switch (cmd->type) {\n        case DIAG_OVERWRITE_HISTORICAL_MESSAGE: {\n            unsigned int current_head_idx = (latest_entry_index == 0) ? (MAX_CAN_LOG_ENTRIES - 1) : (latest_entry_index - 1);\n\n            int target_idx_calc = (int)current_head_idx - cmd->historical_offset_steps;\n\n            message_log_buffer[target_idx_calc] = cmd->payload_data;\n\n            break;\n        }\n        case DIAG_RETRIEVE_PAST_MESSAGE:\n            break;\n        case DIAG_GET_STATUS:\n            break;\n        case DIAG_PERFORM_CHECKSUM_CALC:\n            break;\n        default:\n            break;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#define GLOBAL_DATA_STORAGE_SIZE_VULNERABLE 256\n#define MAX_DTC_SEGMENTS_VULNERABLE 4\n\ntypedef struct {\n    uint16_t segment_start_offset;\n    uint16_t segment_actual_size;\n    uint16_t segment_max_offset;\n} DTCSegmentConfig_Vulnerable;\n\nstatic uint8_t g_dtcDataStorage_vulnerable[GLOBAL_DATA_STORAGE_SIZE_VULNERABLE];\n\nstatic DTCSegmentConfig_Vulnerable g_dtcConfigs_vulnerable[MAX_DTC_SEGMENTS_VULNERABLE];\n\nvoid logSystemOutput_vulnerable(const char* msg) {\n    printf(\"VULN_LOG: %s\\n\", msg);\n}\n\nvoid initializeDTCSystem_vulnerable() {\n    g_dtcConfigs_vulnerable[0] = (DTCSegmentConfig_Vulnerable){ .segment_start_offset = 0, .segment_actual_size = 20, .segment_max_offset = 50 };\n    g_dtcConfigs_vulnerable[1] = (DTCSegmentConfig_Vulnerable){ .segment_start_offset = 50, .segment_actual_size = 30, .segment_max_offset = 50 };\n    g_dtcConfigs_vulnerable[2] = (DTCSegmentConfig_Vulnerable){ .segment_start_offset = 100, .segment_actual_size = 10, .segment_max_offset = 50 };\n    g_dtcConfigs_vulnerable[3] = (DTCSegmentConfig_Vulnerable){ .segment_start_offset = 150, .segment_actual_size = 40, .segment_max_offset = 50 };\n\n    for (uint16_t i = 0; i < GLOBAL_DATA_STORAGE_SIZE_VULNERABLE; ++i) {\n        g_dtcDataStorage_vulnerable[i] = (uint8_t)(i % 0xFF);\n    }\n\n    memset(&g_dtcDataStorage_vulnerable[g_dtcConfigs_vulnerable[0].segment_start_offset], 0x11, g_dtcConfigs_vulnerable[0].segment_actual_size);\n    memset(&g_dtcDataStorage_vulnerable[g_dtcConfigs_vulnerable[1].segment_start_offset], 0x22, g_dtcConfigs_vulnerable[1].segment_actual_size);\n    memset(&g_dtcDataStorage_vulnerable[g_dtcConfigs_vulnerable[2].segment_start_offset], 0xAA, g_dtcConfigs_vulnerable[2].segment_actual_size);\n    memset(&g_dtcDataStorage_vulnerable[g_dtcConfigs_vulnerable[3].segment_start_offset], 0x44, g_dtcConfigs_vulnerable[3].segment_actual_size);\n\n    g_dtcDataStorage_vulnerable[112] = 0xDD;\n    g_dtcDataStorage_vulnerable[113] = 0xEE;\n\n    logSystemOutput_vulnerable(\"DTC system initialized.\");\n}\n\nuint16_t getRequestedDTCID_vulnerable() {\n    return 0x020C;\n}\n\nuint8_t getDTCFaultValue_vulnerable(uint16_t dtc_id) {\n    uint8_t segment_idx = (uint8_t)((dtc_id >> 8) & 0xFF);\n    uint8_t relative_offset = (uint8_t)(dtc_id & 0xFF);\n\n    if (segment_idx >= MAX_DTC_SEGMENTS_VULNERABLE) {\n        logSystemOutput_vulnerable(\"Error: Invalid DTC segment ID.\");\n        return 0xFF;\n    }\n\n    uint16_t absolute_byte_offset = g_dtcConfigs_vulnerable[segment_idx].segment_start_offset + relative_offset;\n\n    if (absolute_byte_offset >= GLOBAL_DATA_STORAGE_SIZE_VULNERABLE) {\n        logSystemOutput_vulnerable(\"Error: Calculated offset exceeds global data storage bounds.\");\n        return 0xFF;\n    }\n    \n    logSystemOutput_vulnerable(\"Reading DTC fault value.\");\n    return g_dtcDataStorage_vulnerable[absolute_byte_offset];\n}\n\nvoid diagnosticMonitorLoop_vulnerable() {\n    initializeDTCSystem_vulnerable();\n\n    uint16_t requested_dtc_id = getRequestedDTCID_vulnerable();\n    uint8_t fault_value = getDTCFaultValue_vulnerable(requested_dtc_id);\n    \n    char log_msg[64];\n    sprintf(log_msg, \"Retrieved fault value: 0x%02X\", fault_value);\n    logSystemOutput_vulnerable(log_msg);\n}\n\nvoid automotiveDTCManager_vulnerable_main() {\n    diagnosticMonitorLoop_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_PAYLOAD 64\n#define DIAG_EVENT_LOG_CAPACITY 10\n\ntypedef struct {\n    uint8_t  event_type;\n    uint8_t  log_level;\n    uint8_t  payload_actual_len;\n    uint8_t  payload[MAX_DIAG_PAYLOAD];\n    uint32_t timestamp;\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diagEventLog[DIAG_EVENT_LOG_CAPACITY];\nstatic uint8_t g_currentLogIndex = 0;\n\nvoid initDiagEventLog() {\n    memset(g_diagEventLog, 0, sizeof(g_diagEventLog));\n    g_currentLogIndex = 0;\n}\n\nstatic int addEventToLog(const DiagnosticEvent* event) {\n    if (g_currentLogIndex >= DIAG_EVENT_LOG_CAPACITY) {\n        return -1;\n    }\n    memcpy(&g_diagEventLog[g_currentLogIndex], event, sizeof(DiagnosticEvent));\n    g_currentLogIndex++;\n    return 0;\n}\n\nint processIncomingDiagData(const uint8_t* raw_data, uint16_t raw_data_len) {\n    if (raw_data == NULL || raw_data_len < 3) {\n        return -1;\n    }\n\n    uint8_t event_type = raw_data[0];\n    uint8_t log_level = raw_data[1];\n    uint8_t incoming_payload_len = raw_data[2];\n\n    if (raw_data_len < (3 + incoming_payload_len)) {\n        return -2;\n    }\n\n    DiagnosticEvent temp_event;\n    temp_event.event_type = event_type;\n    temp_event.log_level = log_level;\n    temp_event.timestamp = 0xDEADBEEF;\n\n    uint8_t bytes_to_copy = incoming_payload_len;\n    if (bytes_to_copy > MAX_DIAG_PAYLOAD) {\n        bytes_to_copy = MAX_DIAG_PAYLOAD;\n    }\n    temp_event.payload_actual_len = bytes_to_copy;\n\n    memcpy(temp_event.payload, raw_data + 3, bytes_to_copy);\n\n    return addEventToLog(&temp_event);\n}\n\nvoid receiveNetworkDiagMessage(const uint8_t* message_buffer, uint16_t buffer_len) {\n    processIncomingDiagData(message_buffer, buffer_len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_SUBSYSTEM_PARAMS_FIXED 8\n\ntypedef enum {\n    SUBSYSTEM_ENGINE_FIXED = 0,\n    SUBSYSTEM_TRANSMISSION_FIXED,\n    SUBSYSTEM_BRAKES_FIXED,\n    SUBSYSTEM_HVAC_FIXED,\n    SUBSYSTEM_INFOTAINMENT_FIXED,\n    NUM_VEHICLE_SUBSYSTEMS_FIXED\n} VehicleSubSystem_Fixed;\n\ntypedef struct {\n    uint32_t params[MAX_SUBSYSTEM_PARAMS_FIXED];\n    uint8_t  active_param_count;\n} SubsystemConfiguration_Fixed;\n\nstatic SubsystemConfiguration_Fixed g_vehicle_configs_fixed[NUM_VEHICLE_SUBSYSTEMS_FIXED];\n\ntypedef struct {\n    uint8_t  target_subsystem_id;\n    uint8_t  config_param_idx;\n    uint32_t new_value;\n} CanConfigurationCommand_Fixed;\n\nvoid log_ecu_event_fixed(const char* event) {\n}\n\nvoid log_ecu_error_fixed(const char* error) {\n}\n\nCanConfigurationCommand_Fixed receive_can_command_fixed() {\n    CanConfigurationCommand_Fixed cmd;\n    cmd.target_subsystem_id = NUM_VEHICLE_SUBSYSTEMS_FIXED;\n    cmd.config_param_idx = 0;\n    cmd.new_value = 0xAAAA;\n    return cmd;\n}\n\nvoid initialize_vehicle_configs_fixed() {\n    for (uint8_t i = 0; i < NUM_VEHICLE_SUBSYSTEMS_FIXED; ++i) {\n        for (uint8_t j = 0; j < MAX_SUBSYSTEM_PARAMS_FIXED; ++j) {\n            g_vehicle_configs_fixed[i].params[j] = 0;\n        }\n        g_vehicle_configs_fixed[i].active_param_count = MAX_SUBSYSTEM_PARAMS_FIXED;\n    }\n    log_ecu_event_fixed(\"Vehicle configurations initialized (fixed).\");\n}\n\nvoid update_subsystem_param_fixed() {\n    CanConfigurationCommand_Fixed cmd = receive_can_command_fixed();\n\n    if (cmd.target_subsystem_id < NUM_VEHICLE_SUBSYSTEMS_FIXED) {\n        if (cmd.config_param_idx < MAX_SUBSYSTEM_PARAMS_FIXED) {\n            g_vehicle_configs_fixed[cmd.target_subsystem_id].params[cmd.config_param_idx] = cmd.new_value;\n            log_ecu_event_fixed(\"Subsystem parameter updated (fixed).\");\n        } else {\n            log_ecu_error_fixed(\"Error: Invalid configuration parameter index received.\");\n        }\n    } else {\n        log_ecu_error_fixed(\"Error: Invalid subsystem ID received for configuration update.\");\n    n}\n}\n\nvoid vehicle_configuration_manager_fixed_main() {\n    initialize_vehicle_configs_fixed();\n    update_subsystem_param_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define SENSOR_CALIBRATION_MAX_POINTS 128\n#define DIAG_PACKET_MAX_PAYLOAD_SIZE 256\n\nstatic uint16_t g_sensorCalibration[SENSOR_CALIBRATION_MAX_POINTS];\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t sub_command;\n    uint16_t start_index;\n    uint16_t num_points;\n    uint8_t  payload[DIAG_PACKET_MAX_PAYLOAD_SIZE];\n} DiagnosticCommandPacket;\n\nvoid initSensorCalibration() {\n    for (int i = 0; i < SENSOR_CALIBRATION_MAX_POINTS; ++i) {\n        g_sensorCalibration[i] = 0xAAAA;\n    }\n}\n\nint processCalibrationUpdateCommand(const DiagnosticCommandPacket* packet, uint16_t packet_size) {\n    if (packet == NULL || packet_size < sizeof(DiagnosticCommandPacket) - DIAG_PACKET_MAX_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    if (packet->command_id != 0x01 || packet->sub_command != 0x01) {\n        return -2;\n    }\n\n    uint16_t requested_start_index = packet->start_index;\n    uint16_t requested_num_points = packet->num_points;\n\n    if (requested_num_points > (DIAG_PACKET_MAX_PAYLOAD_SIZE / sizeof(uint16_t))) {\n        return -3;\n    }\n\n    if (requested_start_index >= SENSOR_CALIBRATION_MAX_POINTS ||\n        (uint32_t)requested_start_index + requested_num_points > SENSOR_CALIBRATION_MAX_POINTS) {\n        return -4;\n    }\n\n    const uint16_t* new_values = (const uint16_t*)packet->payload;\n\n    for (uint16_t i = 0; i < requested_num_points; ++i) {\n        g_sensorCalibration[requested_start_index + i] = new_values[i];\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticMessage(const uint8_t* raw_message, uint16_t raw_message_len) {\n    initSensorCalibration();\n    processCalibrationUpdateCommand((const DiagnosticCommandPacket*)raw_message, raw_message_len);\n}\n\nuint16_t getSensorCalibrationValue(uint16_t index) {\n    if (index < SENSOR_CALIBRATION_MAX_POINTS) {\n        return g_sensorCalibration[index];\n    }\n    return 0xFFFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define NUM_VIRTUAL_ECUS 5\n#define MAX_PARAMS_PER_ECU_TYPE 100\n#define MAX_TOTAL_PARAMETERS 150\n\ntypedef struct {\n    uint32_t value;\n    uint8_t  status_flags;\n} FirmwareParameter;\n\nstatic FirmwareParameter g_firmwareParameterStorage_vulnerable[MAX_TOTAL_PARAMETERS];\nstatic uint16_t g_ecuStartOffset_vulnerable[NUM_VIRTUAL_ECUS];\nstatic uint16_t g_ecuParamCounts_vulnerable[NUM_VIRTUAL_ECUS];\n\nvoid diagnosticLog_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t  ecu_id;\n    uint16_t param_index;\n    uint32_t new_value;\n} ParameterUpdateCommand;\n\nParameterUpdateCommand receiveParameterUpdateCommand_vulnerable() {\n    ParameterUpdateCommand cmd;\n    cmd.ecu_id = 1;\n    cmd.param_index = 80;\n    cmd.new_value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeEcuParameters_vulnerable() {\n    g_ecuStartOffset_vulnerable[0] = 0;\n    g_ecuParamCounts_vulnerable[0] = 70;\n\n    g_ecuStartOffset_vulnerable[1] = 70;\n    g_ecuParamCounts_vulnerable[1] = 90;\n\n    g_ecuStartOffset_vulnerable[2] = 160;\n    g_ecuParamCounts_vulnerable[2] = 50;\n\n    g_ecuStartOffset_vulnerable[3] = 210;\n    g_ecuParamCounts_vulnerable[3] = 40;\n    \n    g_ecuStartOffset_vulnerable[4] = 250;\n    g_ecuParamCounts_vulnerable[4] = 30;\n\n    for (uint16_t i = 0; i < MAX_TOTAL_PARAMETERS; ++i) {\n        g_firmwareParameterStorage_vulnerable[i] = (FirmwareParameter){0, 0};\n    }\n    diagnosticLog_vulnerable(\"ECU parameters initialized (vulnerable).\");\n}\n\nvoid processParameterUpdate_vulnerable() {\n    ParameterUpdateCommand cmd = receiveParameterUpdateCommand_vulnerable();\n\n    if (cmd.ecu_id >= NUM_VIRTUAL_ECUS) {\n        diagnosticLog_vulnerable(\"Error: Invalid ECU ID in parameter update command.\");\n        return;\n    }\n\n    if (cmd.param_index >= g_ecuParamCounts_vulnerable[cmd.ecu_id]) {\n        diagnosticLog_vulnerable(\"Error: Parameter index out of bounds for specified ECU type (local range).\");\n        return;\n    }\n\n    uint16_t base_offset = g_ecuStartOffset_vulnerable[cmd.ecu_id];\n    uint16_t absolute_param_index = base_offset + cmd.param_index;\n\n    g_firmwareParameterStorage_vulnerable[absolute_param_index].value = cmd.new_value;\n    g_firmwareParameterStorage_vulnerable[absolute_param_index].status_flags = 0x01;\n    diagnosticLog_vulnerable(\"Firmware parameter update attempted (vulnerable).\");\n}\n\nvoid main_ecu_firmware_manager_vulnerable() {\n    initializeEcuParameters_vulnerable();\n    processParameterUpdate_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_SENSORS 5\n\ntypedef enum {\n    SENSOR_TYPE_PRESSURE = 0,\n    SENSOR_TYPE_TEMPERATURE,\n    SENSOR_TYPE_ACCELEROMETER,\n    SENSOR_TYPE_GYROSCOPE,\n    SENSOR_TYPE_VOLTAGE\n} SensorType;\n\ntypedef struct {\n    float offset;\n    float gain;\n} SensorCalibrationParams;\n\nstatic SensorCalibrationParams g_sensorCalibrationData[MAX_SENSORS];\n\nvoid logError(const char* msg) {\n}\n\nvoid initializeSensorCalibrations_vulnerable() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        g_sensorCalibrationData[i].offset = 0.0f;\n        g_sensorCalibrationData[i].gain = 1.0f;\n    }\n}\n\ntypedef struct {\n    uint8_t sensor_type_id;\n    float new_offset;\n    float new_gain;\n} SensorCalibrationCommand;\n\nSensorCalibrationCommand receiveCalibrationCommand_vulnerable() {\n    SensorCalibrationCommand cmd;\n    cmd.sensor_type_id = MAX_SENSORS;\n    cmd.new_offset = 12.34f;\n    cmd.new_gain = 5.67f;\n    return cmd;\n}\n\nvoid processSensorCalibrationCommand_vulnerable() {\n    SensorCalibrationCommand cmd = receiveCalibrationCommand_vulnerable();\n\n    g_sensorCalibrationData[cmd.sensor_type_id].offset = cmd.new_offset;\n    g_sensorCalibrationData[cmd.sensor_type_id].gain = cmd.new_gain;\n    \n    logError(\"Sensor calibration attempted (vulnerable).\");\n}\n\nvoid automotiveCalibrationService_vulnerable() {\n    initializeSensorCalibrations_vulnerable();\n    processSensorCalibrationCommand_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define RECORD_BUFFER_SIZE 256\n#define HEADER_MAGIC_BYTE 0xAA\n#define FOOTER_MAGIC_BYTE 0x55\n#define MIN_RECORD_SIZE 8\n\nstatic uint8_t g_diagnostic_record_buffer_fixed[RECORD_BUFFER_SIZE];\nstatic int32_t g_last_record_start_offset_fixed = -1;\n\nbool parse_record_fixed(uint32_t offset) {\n    if (offset < 0 || offset >= RECORD_BUFFER_SIZE) return false;\n    volatile uint8_t magic = g_diagnostic_record_buffer_fixed[offset];\n    (void)magic;\n    return true;\n}\n\nvoid init_diagnostic_buffer_fixed() {\n    memset(g_diagnostic_record_buffer_fixed, 0, RECORD_BUFFER_SIZE);\n    g_last_record_start_offset_fixed = -1;\n}\n\nbool add_diagnostic_record_fixed(const uint8_t* payload, uint8_t payload_len) {\n    uint32_t record_total_len = 1 + 1 + payload_len + 1;\n    if (record_total_len > RECORD_BUFFER_SIZE || record_total_len < MIN_RECORD_SIZE) {\n        return false;\n    }\n\n    int32_t next_write_offset;\n    if (g_last_record_start_offset_fixed == -1) {\n        next_write_offset = 0;\n    } else {\n        uint8_t prev_payload_len = g_diagnostic_record_buffer_fixed[g_last_record_start_offset_fixed + 1];\n        next_write_offset = g_last_record_start_offset_fixed + (1 + 1 + prev_payload_len + 1);\n    }\n\n    if (next_write_offset + record_total_len > RECORD_BUFFER_SIZE) {\n        next_write_offset = 0;\n    }\n\n    g_diagnostic_record_buffer_fixed[next_write_offset] = HEADER_MAGIC_BYTE;\n    g_diagnostic_record_buffer_fixed[next_write_offset + 1] = payload_len;\n    memcpy(g_diagnostic_record_buffer_fixed + next_write_offset + 2, payload, payload_len);\n    g_diagnostic_record_buffer_fixed[next_write_offset + 2 + payload_len] = FOOTER_MAGIC_BYTE;\n\n    g_last_record_start_offset_fixed = next_write_offset;\n    return true;\n}\n\nvoid update_segment_marker_fixed(int16_t offset_from_last_record_start, uint8_t marker_value) {\n    if (g_last_record_start_offset_fixed == -1) {\n        return;\n    }\n\n    int32_t target_index = g_last_record_start_offset_fixed + offset_from_last_record_start;\n\n    if (target_index < 0 || target_index >= RECORD_BUFFER_SIZE) {\n        return;\n    }\n\n    g_diagnostic_record_buffer_fixed[target_index] = marker_value;\n\n    parse_record_fixed(g_last_record_start_offset_fixed);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n\n// Represents a single firmware image entry within an update manifest\nstruct FirmwareImageEntry {\n    uint32_t image_id;\n    uint32_t image_size;\n    uint8_t  checksum[16];\n    char     version_string[32]; // Fixed-size string buffer for version\n};\n\n// Represents the header of a firmware update manifest packet\nstruct UpdateManifestHeader {\n    uint16_t manifest_version;\n    uint16_t num_firmware_images;   // Declared number of images - used for allocation\n    uint32_t total_payload_bytes;   // Total bytes of ALL image entries in the payload - used for loop bounds\n};\n\nclass FirmwareUpdaterFixed {\npublic:\n    FirmwareUpdaterFixed() : update_tasks(nullptr), num_tasks_allocated(0) {}\n\n    ~FirmwareUpdaterFixed() {\n        clearTasks();\n    }\n\n    void clearTasks() {\n        if (update_tasks) {\n            delete[] update_tasks;\n            update_tasks = nullptr;\n        }\n        num_tasks_allocated = 0;\n    }\n\n    // Processes a raw firmware update manifest packet\n    // Fix: Ensures consistency between declared image count and total payload bytes,\n    // and strictly bounds the writing loop to the allocated array size.\n    bool parseManifestFixed(const uint8_t* raw_manifest, size_t manifest_len) {\n        if (!raw_manifest || manifest_len < sizeof(UpdateManifestHeader)) {\n            return false;\n        }\n\n        const UpdateManifestHeader* header = reinterpret_cast<const UpdateManifestHeader*>(raw_manifest);\n\n        // Fix 1: Add reasonable limits for num_firmware_images to prevent excessively large allocations.\n        static const uint16_t MAX_SUPPORTED_FIRMWARE_IMAGES = 200;\n        if (header->num_firmware_images > MAX_SUPPORTED_FIRMWARE_IMAGES) {\n            return false;\n        }\n\n        // Fix 2: Check for potential integer overflow during allocation size calculation.\n        if (header->num_firmware_images > (SIZE_MAX / sizeof(FirmwareImageEntry))) {\n            return false;\n        }\n\n        // Fix 3: Crucial consistency check: total_payload_bytes must precisely match\n        // the expected size based on num_firmware_images and entry size.\n        // This prevents an attacker from supplying a small num_firmware_images but a large total_payload_bytes.\n        if (header->num_firmware_images > 0 &&\n            header->total_payload_bytes != (size_t)header->num_firmware_images * sizeof(FirmwareImageEntry)) {\n            return false; // Malformed packet: declared count vs. total bytes mismatch\n        }\n\n        // Fix 4: Packet length check ensures enough data for the full declared payload.\n        if (manifest_len < sizeof(UpdateManifestHeader) + header->total_payload_bytes) {\n            return false;\n        }\n\n        clearTasks(); // Clear any existing tasks before processing new manifest\n\n        // Allocation size is correctly determined by 'num_firmware_images'.\n        num_tasks_allocated = header->num_firmware_images;\n\n        // If num_tasks_allocated is 0, we don't allocate or process anything.\n        if (num_tasks_allocated == 0) {\n            return true;\n        }\n\n        update_tasks = new (std::nothrow) FirmwareImageEntry[num_tasks_allocated];\n        if (!update_tasks) {\n            return false;\n        }\n\n        const uint8_t* current_payload_ptr = raw_manifest + sizeof(UpdateManifestHeader);\n\n        // Fix 5: The loop now explicitly iterates only up to 'num_tasks_allocated',\n        // which is the actual allocated size of the 'update_tasks' array.\n        // This prevents writing beyond the array bounds.\n        for (uint16_t i = 0; i < num_tasks_allocated; ++i) {\n            // Additional runtime check to ensure we don't read beyond the packet data (should be caught by Fix 4).\n            // This guards against highly malformed packets where actual data is less than declared `total_payload_bytes`.\n            if ((current_payload_ptr + (i * sizeof(FirmwareImageEntry)) + sizeof(FirmwareImageEntry)) > (raw_manifest + manifest_len)) {\n                clearTasks();\n                return false; // Malformed packet: not enough data for all declared entries\n            }\n\n            const FirmwareImageEntry* incoming_entry = reinterpret_cast<const FirmwareImageEntry*>(current_payload_ptr + (i * sizeof(FirmwareImageEntry)));\n            \n            update_tasks[i].image_id = incoming_entry->image_id;\n            update_tasks[i].image_size = incoming_entry->image_size;\n            memcpy(update_tasks[i].checksum, incoming_entry->checksum, sizeof(incoming_entry->checksum));\n            \n            // strncpy with null-termination is safe for individual string field.\n            strncpy(update_tasks[i].version_string, incoming_entry->version_string, sizeof(incoming_entry->version_string) - 1);\n            update_tasks[i].version_string[sizeof(incoming_entry->version_string) - 1] = '\\0';\n        }\n\n        return true;\n    }\n\n    const FirmwareImageEntry* getUpdateTasks() const { return update_tasks; }\n    uint16_t getNumTasksAllocated() const { return num_tasks_allocated; }\n\nprivate:\n    FirmwareImageEntry* update_tasks;\n    uint16_t            num_tasks_allocated;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <algorithm>\n#include <limits>\n\n// Define types for clarity\ntypedef uint8_t TelemetryBlockType;\n\n// Telemetry Block Types\nconst TelemetryBlockType TYPE_RAW_SENSOR_DATA = 0x01;\nconst TelemetryBlockType TYPE_TEXT_MESSAGE = 0x02;\nconst TelemetryBlockType TYPE_EVENT_CODE = 0x03;\n\nstruct TelemetryBlockHeader {\n    TelemetryBlockType block_type;\n    uint16_t block_id;\n    uint16_t data_length; // Length of the data payload following this header\n};\n\nclass TelemetryDataBufferFixed {\npublic:\n    TelemetryDataBufferFixed(size_t initial_capacity = 256)\n        : m_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {\n        if (initial_capacity > 0) {\n            m_buffer = (uint8_t*)malloc(initial_capacity);\n            if (m_buffer) {\n                m_allocated_capacity = initial_capacity;\n            }\n        }\n    }\n\n    ~TelemetryDataBufferFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool appendTelemetryBlockFixed(const TelemetryBlockHeader* header, const uint8_t* payload) {\n        if (!header || !payload || header->data_length == 0) {\n            return false;\n        }\n\n        size_t block_header_size = sizeof(TelemetryBlockHeader);\n        size_t required_payload_storage_size = 0; // The actual size needed in the buffer for the payload\n\n        switch (header->block_type) {\n            case TYPE_RAW_SENSOR_DATA:\n                // FIX: Raw sensor data will be converted to hex string (2 chars per byte).\n                // Ensure data_length * 2 doesn't overflow.\n                if (header->data_length > (std::numeric_limits<uint16_t>::max() / 2)) {\n                    return false; // multiplication would overflow\n                }\n                required_payload_storage_size = static_cast<size_t>(header->data_length) * 2;\n                break;\n            case TYPE_TEXT_MESSAGE:\n            case TYPE_EVENT_CODE:\n                // For text or event codes, it's a direct byte copy, plus null terminator\n                // FIX: Ensure data_length + 1 doesn't overflow\n                if (header->data_length == std::numeric_limits<uint16_t>::max()) {\n                    return false; // addition would overflow\n                }\n                required_payload_storage_size = static_cast<size_t>(header->data_length) + 1; // +1 for null terminator\n                break;\n            default:\n                return false; // Unknown type\n        }\n\n        // FIX: Check for integer overflow before adding header size\n        if (block_header_size > std::numeric_limits<size_t>::max() - required_payload_storage_size) {\n            return false; // addition would overflow\n        }\n        size_t total_space_needed_for_this_block = block_header_size + required_payload_storage_size;\n\n        // Check for potential integer overflow in m_current_size + total_space_needed_for_this_block\n        if (m_current_size > std::numeric_limits<size_t>::max() - total_space_needed_for_this_block) {\n            return false; // Would overflow size_t\n        }\n\n        // Check if current buffer has enough space. If not, reallocate.\n        if (m_current_size + total_space_needed_for_this_block > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity == 0 ? total_space_needed_for_this_block : m_allocated_capacity * 2;\n            \n            // Handle overflow during doubling of capacity\n            if (m_allocated_capacity > std::numeric_limits<size_t>::max() / 2 && m_allocated_capacity != 0) {\n                 new_capacity = std::numeric_limits<size_t>::max();\n            }\n\n            // Ensure new_capacity is at least what's needed\n            if (new_capacity < m_current_size + total_space_needed_for_this_block) {\n                new_capacity = m_current_size + total_space_needed_for_this_block;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_capacity);\n            if (!new_buffer) {\n                if (m_buffer) {\n                    free(m_buffer);\n                    m_buffer = nullptr;\n                }\n                m_current_size = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        if (!m_buffer) {\n            return false;\n        }\n\n        // Copy header\n        memcpy(m_buffer + m_current_size, header, block_header_size);\n        m_current_size += block_header_size;\n\n        // Copy payload based on type\n        switch (header->block_type) {\n            case TYPE_RAW_SENSOR_DATA: {\n                // FIX: Loop bound and write now match the correctly calculated required_payload_storage_size\n                size_t bytes_to_write_char_count = static_cast<size_t>(header->data_length) * 2;\n                if (m_current_size > m_allocated_capacity - bytes_to_write_char_count) {\n                    return false;\n                }\n\n                for (uint16_t i = 0; i < header->data_length; ++i) {\n                    uint8_t byte_val = payload[i];\n                    m_buffer[m_current_size++] = nibbleToHex(byte_val >> 4);\n                    m_buffer[m_current_size++] = nibbleToHex(byte_val & 0x0F);\n                }\n                break;\n            }\n            case TYPE_TEXT_MESSAGE:\n            case TYPE_EVENT_CODE: {\n                // FIX: Ensure enough space for memcpy + null terminator\n                size_t copy_len = header->data_length;\n                if (m_current_size > m_allocated_capacity - (copy_len + 1)) {\n                     return false;\n                }\n                memcpy(m_buffer + m_current_size, payload, copy_len);\n                m_current_size += copy_len;\n                m_buffer[m_current_size++] = '\\0'; // Null terminate\n                break;\n            }\n            default:\n                return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getBuffer() const { return m_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n\n    // Helper to convert nibble to hex char (0-9, A-F)\n    char nibbleToHex(uint8_t nibble) {\n        if (nibble < 10) {\n            return '0' + nibble;\n        } else {\n            return 'A' + (nibble - 10);\n        }\n    }\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CAL_BUFFER_SIZE 256\n#define CAL_CHANGE_SIZE 8\n#define CAL_HEADER_SIZE 16\n\nstatic uint8_t g_calibration_data[CAL_BUFFER_SIZE];\nstatic uint16_t g_current_cal_data_end_offset = CAL_HEADER_SIZE;\n\nvoid init_calibration_module() {\n    memset(g_calibration_data, 0xFF, CAL_BUFFER_SIZE);\n    g_calibration_data[0] = 0xAA;\n    g_calibration_data[1] = 0x55;\n    g_calibration_data[CAL_HEADER_SIZE - 1] = 0x01;\n    g_current_cal_data_end_offset = CAL_HEADER_SIZE;\n}\n\nbool append_calibration_record(const uint8_t* record, uint16_t len) {\n    if (len != CAL_CHANGE_SIZE) {\n        return false;\n    }\n    if (g_current_cal_data_end_offset + len > CAL_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_calibration_data + g_current_cal_data_end_offset, record, len);\n    g_current_cal_data_end_offset += len;\n    return true;\n}\n\nvoid revert_calibration_history_vulnerable(int16_t num_steps_to_revert) {\n    int32_t new_effective_end_offset_signed = (int32_t)g_current_cal_data_end_offset - (num_steps_to_revert * CAL_CHANGE_SIZE);\n\n    g_calibration_data[new_effective_end_offset_signed - 1] = 0x00;\n\n    if (new_effective_end_offset_signed < CAL_HEADER_SIZE) {\n        g_current_cal_data_end_offset = CAL_HEADER_SIZE;\n    } else {\n        g_current_cal_data_end_offset = (uint16_t)new_effective_end_offset_signed;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#define DATA_BUFFER_SIZE 256\n\nstatic uint8_t g_data_buffer[DATA_BUFFER_SIZE];\nstatic size_t g_data_stored_len = 0;\n\nvoid initialize_data_buffer() {\n    for (size_t i = 0; i < DATA_BUFFER_SIZE; ++i) {\n        g_data_buffer[i] = 0;\n    }\n    g_data_stored_len = 0;\n}\n\nbool append_data_block(const uint8_t* data, size_t len) {\n    if (g_data_stored_len + len > DATA_BUFFER_SIZE) {\n        return false;\n    }\n    for (size_t i = 0; i < len; ++i) {\n        g_data_buffer[g_data_stored_len + i] = data[i];\n    }\n    g_data_stored_len += len;\n    return true;\n}\n\nvoid process_data_block_status_fixed(int32_t relative_offset) {\n    if (g_data_stored_len == 0) {\n        return;\n    }\n\n    int32_t target_idx = (int32_t)g_data_stored_len - 1 + relative_offset;\n\n    if (target_idx < 0 || target_idx >= (int32_t)g_data_stored_len) {\n        return;\n    }\n    \n    g_data_buffer[target_idx] = 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n\ntypedef struct {\n    uint32_t offset;\n    uint16_t length;\n    uint16_t chunk_id;\n} FirmwareChunkHeader;\n\nclass FirmwareUpdaterVulnerable {\nprivate:\n    uint8_t* m_firmware_image_buffer;\n    size_t   m_allocated_size;\n    uint32_t m_expected_total_firmware_size;\n    bool     m_is_initialized;\n\npublic:\n    FirmwareUpdaterVulnerable() : m_firmware_image_buffer(nullptr), m_allocated_size(0), m_expected_total_firmware_size(0), m_is_initialized(false) {}\n\n    ~FirmwareUpdaterVulnerable() {\n        if (m_firmware_image_buffer) {\n            free(m_firmware_image_buffer);\n            m_firmware_image_buffer = nullptr;\n        }\n    }\n\n    bool initializeUpdater(uint32_t total_firmware_size) {\n        if (total_firmware_size == 0 || total_firmware_size > (1024U * 1024U * 10U)) {\n            return false;\n        }\n        if (m_firmware_image_buffer) {\n            free(m_firmware_image_buffer);\n        }\n        m_firmware_image_buffer = (uint8_t*)malloc(total_firmware_size);\n        if (!m_firmware_image_buffer) {\n            m_allocated_size = 0;\n            m_expected_total_firmware_size = 0;\n            m_is_initialized = false;\n            return false;\n        }\n        m_allocated_size = total_firmware_size;\n        m_expected_total_firmware_size = total_firmware_size;\n        m_is_initialized = true;\n        return true;\n    }\n\n    bool applyFirmwareChunkVulnerable(const uint8_t* raw_chunk_data, size_t raw_chunk_data_len) {\n        if (!m_is_initialized || !m_firmware_image_buffer || raw_chunk_data_len < sizeof(FirmwareChunkHeader)) {\n            return false;\n        }\n\n        const FirmwareChunkHeader* header = reinterpret_cast<const FirmwareChunkHeader*>(raw_chunk_data);\n\n        if (raw_chunk_data_len < (sizeof(FirmwareChunkHeader) + header->length)) {\n            return false;\n        }\n        \n        if (header->offset >= m_expected_total_firmware_size) {\n            return false;\n        }\n\n        const uint8_t* chunk_payload_start = raw_chunk_data + sizeof(FirmwareChunkHeader);\n\n        for (uint16_t i = 0; i < header->length; ++i) {\n            m_firmware_image_buffer[header->offset + i] = chunk_payload_start[i];\n        }\n\n        return true;\n    }\n\n    const uint8_t* getFirmwareBuffer() const {\n        return m_firmware_image_buffer;\n    }\n\n    size_t getAllocatedSize() const {\n        return m_allocated_size;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <cstdlib>\n#include <new>\n#include <limits>\n\nstruct DiagnosticEntryHeader {\n    uint32_t timestamp;\n    uint16_t event_code;\n    uint16_t data_payload_length;\n};\n\nstruct DiagnosticStreamPacket {\n    uint32_t  stream_id;\n    uint16_t  num_entries_in_packet;\n    uint32_t  total_packet_payload_bytes;\n};\n\nclass DiagnosticLogStreamFixed {\npublic:\n    DiagnosticLogStreamFixed() : m_log_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {}\n\n    ~DiagnosticLogStreamFixed() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n    }\n\n    void resetStream() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n        m_current_size = 0;\n        m_allocated_capacity = 0;\n    }\n\n    bool appendDiagnosticDataFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticStreamPacket)) {\n            return false;\n        }\n\n        const DiagnosticStreamPacket* packet_header = reinterpret_cast<const DiagnosticStreamPacket*>(raw_packet);\n        \n        if (packet_len < sizeof(DiagnosticStreamPacket) + packet_header->total_packet_payload_bytes) {\n            return false;\n        }\n\n        const uint8_t* current_data_ptr = raw_packet + sizeof(DiagnosticStreamPacket);\n        size_t bytes_remaining_in_packet = packet_header->total_packet_payload_bytes;\n\n        static const uint16_t MAX_SINGLE_PAYLOAD_LENGTH = 0xFFF0; \n\n        for (uint16_t i = 0; i < packet_header->num_entries_in_packet; ++i) {\n            if (bytes_remaining_in_packet < sizeof(DiagnosticEntryHeader)) {\n                return false;\n            }\n\n            const DiagnosticEntryHeader* entry_header = reinterpret_cast<const DiagnosticEntryHeader*>(current_data_ptr);\n\n            if (entry_header->data_payload_length > MAX_SINGLE_PAYLOAD_LENGTH) {\n                return false;\n            }\n\n            size_t entry_total_size = sizeof(DiagnosticEntryHeader) + entry_header->data_payload_length;\n\n            if (bytes_remaining_in_packet < entry_total_size) {\n                return false;\n            }\n\n            if (m_current_size > std::numeric_limits<size_t>::max() - entry_total_size) {\n                return false;\n            }\n            \n            size_t required_capacity = m_current_size + entry_total_size;\n\n            if (required_capacity > m_allocated_capacity) {\n                size_t new_capacity;\n\n                if (m_allocated_capacity > std::numeric_limits<size_t>::max() / 2) {\n                    new_capacity = std::numeric_limits<size_t>::max();\n                } else {\n                    new_capacity = m_allocated_capacity * 2;\n                }\n\n                if (new_capacity < required_capacity) {\n                    if (required_capacity > std::numeric_limits<size_t>::max()) {\n                        return false;\n                    }\n                    new_capacity = required_capacity;\n                }\n                \n                uint8_t* temp_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n                if (!temp_buffer) {\n                    if (m_log_buffer) {\n                        free(m_log_buffer);\n                        m_log_buffer = nullptr;\n                    }\n                    m_current_size = 0;\n                    m_allocated_capacity = 0;\n                    return false;\n                }\n                m_log_buffer = temp_buffer;\n                m_allocated_capacity = new_capacity;\n            }\n\n            for (size_t k = 0; k < sizeof(DiagnosticEntryHeader); ++k) {\n                m_log_buffer[m_current_size + k] = current_data_ptr[k];\n            }\n            m_current_size += sizeof(DiagnosticEntryHeader);\n\n            for (size_t k = 0; k < entry_header->data_payload_length; ++k) {\n                m_log_buffer[m_current_size + k] = current_data_ptr[sizeof(DiagnosticEntryHeader) + k];\n            }\n            m_current_size += entry_header->data_payload_length;\n\n            current_data_ptr += entry_total_size;\n            bytes_remaining_in_packet -= entry_total_size;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getLogBuffer() const {\n        return m_log_buffer;\n    }\n\n    size_t getCurrentSize() const {\n        return m_current_size;\n    }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n\n#define NUM_SENSOR_GROUPS 5\n#define MAX_PARAMETERS_PER_GROUP 10\n\ntypedef struct {\n    uint16_t parameter_values[MAX_PARAMETERS_PER_GROUP];\n    uint32_t last_update_timestamp;\n    uint8_t  status_flags;\n} SensorGroupData;\n\nstatic SensorGroupData g_sensorData_fixed[NUM_SENSOR_GROUPS];\n\ntypedef struct {\n    uint8_t  sensor_group_id;\n    uint8_t  parameter_index;\n    uint16_t new_value;\n} TelemetryUpdateCommand_fixed;\n\nvoid logTelemetryError_fixed(const char* msg) {\n}\n\nvoid initializeTelemetrySystem_fixed() {\n    for (int i = 0; i < NUM_SENSOR_GROUPS; ++i) {\n        for (int j = 0; j < MAX_PARAMETERS_PER_GROUP; ++j) {\n            g_sensorData_fixed[i].parameter_values[j] = 0;\n        }\n        g_sensorData_fixed[i].last_update_timestamp = 0;\n        g_sensorData_fixed[i].status_flags = 0;\n    }\n}\n\nTelemetryUpdateCommand_fixed receiveTelemetryCommand_fixed() {\n    TelemetryUpdateCommand_fixed cmd;\n    cmd.sensor_group_id = 0;\n    cmd.parameter_index = MAX_PARAMETERS_PER_GROUP; \n    cmd.new_value = 0xDEAD;\n    return cmd;\n}\n\nvoid processTelemetryUpdate_fixed() {\n    TelemetryUpdateCommand_fixed cmd = receiveTelemetryCommand_fixed();\n\n    if (cmd.sensor_group_id < NUM_SENSOR_GROUPS) {\n        if (cmd.parameter_index < MAX_PARAMETERS_PER_GROUP) {\n            g_sensorData_fixed[cmd.sensor_group_id].parameter_values[cmd.parameter_index] = cmd.new_value;\n            g_sensorData_fixed[cmd.sensor_group_id].last_update_timestamp = 12345;\n            logTelemetryError_fixed(\"Telemetry parameter updated.\");\n        } else {\n            logTelemetryError_fixed(\"Invalid parameter index received for telemetry update. Ignoring.\");\n        }\n    } else {\n        logTelemetryError_fixed(\"Invalid sensor group ID received for telemetry update. Ignoring.\");\n    }\n}\n\nvoid telemetrySystemMain_fixed() {\n    initializeTelemetrySystem_fixed();\n    processTelemetryUpdate_fixed();\n}", "is_vuln": 0, "cvss": NaN}
