{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_PARAMETERS 10\n#define PARAM_VALUE_BUFFER_SIZE 32\n#define MAX_INCOMING_DATA_LEN 256\n\ntypedef struct {\n    uint16_t param_id;\n    uint8_t  param_type;\n    uint8_t  value[PARAM_VALUE_BUFFER_SIZE];\n    uint8_t  current_len;\n} ParameterEntry;\n\nstatic ParameterEntry g_parameterStore[MAX_PARAMETERS];\nstatic uint8_t g_activeParameters = 0;\n\nvoid initParameterStore() {\n    memset(g_parameterStore, 0, sizeof(g_parameterStore));\n    g_activeParameters = 0;\n}\n\nint addParameterDefinition(uint16_t id, uint8_t type) {\n    if (g_activeParameters < MAX_PARAMETERS) {\n        g_parameterStore[g_activeParameters].param_id = id;\n        g_parameterStore[g_activeParameters].param_type = type;\n        g_parameterStore[g_activeParameters].current_len = 0;\n        g_activeParameters++;\n        return 0;\n    }\n    return -1;\n}\n\nint updateParameterValue(uint16_t target_param_id, const uint8_t* data, uint8_t data_len) {\n    if (data == NULL) {\n        return -1;\n    }\n\n    if (data_len > MAX_INCOMING_DATA_LEN) {\n        return -2;\n    }\n\n    int found_idx = -1;\n    for (uint8_t i = 0; i < g_activeParameters; ++i) {\n        if (g_parameterStore[i].param_id == target_param_id) {\n            found_idx = i;\n            break;\n        }\n    }\n\n    if (found_idx == -1) {\n        return -3;\n    }\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_parameterStore[found_idx].value[i] = data[i];\n    }\n\n    g_parameterStore[found_idx].current_len = data_len;\n\n    return 0;\n}\n\nint handleCANMessage(uint16_t msg_id, const uint8_t* msg_payload, uint8_t payload_len) {\n    if (msg_id == 0x123) {\n        if (payload_len < (sizeof(uint16_t) + sizeof(uint8_t) + 1)) {\n            return -1;\n        }\n        uint16_t param_id = (msg_payload[0] << 8) | msg_payload[1];\n        uint8_t data_len = msg_payload[2];\n        const uint8_t* data_ptr = &msg_payload[3];\n\n        if ((3 + data_len) > payload_len) {\n            return -5;\n        }\n\n        return updateParameterValue(param_id, data_ptr, data_len);\n    }\n    return 0;\n}\n\nuint8_t getParameterValueByte(uint16_t param_id, uint8_t index) {\n    int found_idx = -1;\n    for (uint8_t i = 0; i < g_activeParameters; ++i) {\n        if (g_parameterStore[i].param_id == param_id) {\n            found_idx = i;\n            break;\n        }\n    }\n    if (found_idx != -1 && index < g_parameterStore[found_idx].current_len) {\n        return g_parameterStore[found_idx].value[index];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_PENDING_TASKS 128\n#define TASK_DESCRIPTION_MAX_LEN 32\n\ntypedef enum {\n    TASK_STATE_IDLE,\n    TASK_STATE_PENDING,\n    TASK_STATE_RUNNING,\n    TASK_STATE_COMPLETED,\n    TASK_STATE_ERROR\n} TaskState;\n\ntypedef struct {\n    uint16_t task_id;\n    uint16_t priority;\n    TaskState state;\n    char description[TASK_DESCRIPTION_MAX_LEN];\n    void (*task_handler)(void);\n} TaskDescriptor;\n\nstatic TaskDescriptor g_task_queue[MAX_PENDING_TASKS];\nstatic uint16_t g_current_task_count = 0;\n\nvoid dummy_veh_handler(void) {\n    // Simulate some vehicle operation\n}\n\nuint16_t scheduleVehicleTask(uint16_t priority, const char* desc) {\n    if (g_current_task_count < MAX_PENDING_TASKS) {\n        g_task_queue[g_current_task_count].task_id = g_current_task_count;\n        g_task_queue[g_current_task_count].priority = priority;\n        g_task_queue[g_current_task_count].state = TASK_STATE_PENDING;\n        strncpy(g_task_queue[g_current_task_count].description, desc, TASK_DESCRIPTION_MAX_LEN - 1);\n        g_task_queue[g_current_task_count].description[TASK_DESCRIPTION_MAX_LEN - 1] = '\\0';\n        g_task_queue[g_current_task_count].task_handler = dummy_veh_handler;\n        g_current_task_count++;\n        return g_current_task_count - 1;\n    }\n    return (uint16_t)-1;\n}\n\nvoid cancelLastVehicleTasks_Fixed(int rollback_count) {\n    if (rollback_count <= 0) {\n        return;\n    }\n\n    // Calculate the actual number of tasks to rollback, preventing underflow.\n    // This ensures that 'actual_rollback' does not exceed the number of currently active tasks,\n    // thus guaranteeing 'target_idx' remains non-negative.\n    int actual_rollback = (rollback_count > g_current_task_count) ? (int)g_current_task_count : rollback_count;\n\n    // Iterate backwards, setting task state and ID to their default/cleared values.\n    for (int i = 0; i < actual_rollback; ++i) {\n        int target_idx = (int)g_current_task_count - 1 - i;\n\n        // With 'actual_rollback' correctly clamping the loop iterations,\n        // 'target_idx' will always be within valid bounds (>= 0).\n        g_task_queue[target_idx].state = TASK_STATE_IDLE;\n        g_task_queue[target_idx].task_id = 0;\n    }\n\n    // Update the global count of active tasks based on the actual number rolled back.\n    g_current_task_count -= actual_rollback;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>#define MAX_LIGHT_ZONES 5typedef struct {uint8_t brightness;uint8_t red;uint8_t green;uint8_t blue;uint16_t fade_rate_ms;} LightConfig;static LightConfig g_zoneConfigs[MAX_LIGHT_ZONES];typedef struct {uint8_t command_type;uint8_t zone_id;LightConfig new_config;} LightingCommand;void logLightingError(const char* msg) {}void initializeLightingSystem() {for (int i = 0; i < MAX_LIGHT_ZONES; ++i) {g_zoneConfigs[i].brightness = 50;g_zoneConfigs[i].red = 255;g_zoneConfigs[i].green = 255;g_zoneConfigs[i].blue = 255;g_zoneConfigs[i].fade_rate_ms = 100;}}LightingCommand getSimulatedLightingCommand_fixed() {LightingCommand cmd;cmd.command_type = 0x01;cmd.zone_id = 7;cmd.new_config.brightness = 100;cmd.new_config.red = 0;cmd.new_config.green = 255;cmd.new_config.blue = 0;cmd.new_config.fade_rate_ms = 500;return cmd;}void processLightingCommand_fixed(const LightingCommand* cmd) {if (cmd->command_type == 0x01) {if (cmd->zone_id < MAX_LIGHT_ZONES) {g_zoneConfigs[cmd->zone_id] = cmd->new_config;} else {logLightingError(\"Received out-of-bounds light zone ID. Ignoring command.\");}} else {logLightingError(\"Unknown lighting command type.\");}}void lightingControlUnitMain_fixed() {initializeLightingSystem();LightingCommand cmd = getSimulatedLightingCommand_fixed();processLightingCommand_fixed(&cmd);}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define COMPONENT_STATE_BUFFER_SIZE 512\n#define MAX_STATE_DATA_SEGMENTS 10\n\nstatic uint8_t g_componentStateBuffer[COMPONENT_STATE_BUFFER_SIZE];\n\ntypedef struct {\n    uint8_t segment_id;\n    uint16_t segment_offset;\n    uint8_t segment_length;\n} StateSegmentDescriptor;\n\nstatic const StateSegmentDescriptor g_stateDescriptors[MAX_STATE_DATA_SEGMENTS] = {\n    {0x01, 0,   10},\n    {0x02, 10,  20},\n    {0x03, 30,  15},\n    {0x04, 45,  5},\n    {0x05, 50,  100},\n    {0x06, 150, 10},\n    {0x07, 160, 200},\n    {0x08, 360, 50},\n    {0x09, 410, 100},\n    {0x0A, 510, 3}\n};\n#define NUM_STATE_DESCRIPTORS (sizeof(g_stateDescriptors) / sizeof(StateSegmentDescriptor))\n\nvoid initializeComponentStates() {\n    memset(g_componentStateBuffer, 0, COMPONENT_STATE_BUFFER_SIZE);\n}\n\nint updateComponentStateSegment(uint8_t segment_id, const uint8_t* new_data, uint8_t new_data_len) {\n    if (new_data == NULL) {\n        return -1;\n    }\n\n    const StateSegmentDescriptor* target_desc = NULL;\n    for (int i = 0; i < NUM_STATE_DESCRIPTORS; ++i) {\n        if (g_stateDescriptors[i].segment_id == segment_id) {\n            target_desc = &g_stateDescriptors[i];\n            break;\n        }\n    }\n\n    if (target_desc == NULL) {\n        return -2;\n    }\n\n    if (new_data_len > target_desc->segment_length) {\n        return -3;\n    }\n\n    if ((uint32_t)target_desc->segment_offset + new_data_len > COMPONENT_STATE_BUFFER_SIZE) {\n        return -4;\n    }\n\n    memcpy(g_componentStateBuffer + target_desc->segment_offset, new_data, new_data_len);\n\n    return 0;\n}\n\nvoid receiveComponentStateUpdate(uint8_t id, const uint8_t* data, uint8_t len) {\n    updateComponentStateSegment(id, data, len);\n}\n\nuint8_t getComponentStateByte(uint16_t index) {\n    if (index < COMPONENT_STATE_BUFFER_SIZE) {\n        return g_componentStateBuffer[index];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_TELEMETRY_DATA_BLOCKS 4\n#define TELEMETRY_DATA_BLOCK_SIZE 64\n\nstatic uint8_t g_telemetryDataBlocks[MAX_TELEMETRY_DATA_BLOCKS][TELEMETRY_DATA_BLOCK_SIZE];\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t block_idx;\n    uint8_t start_offset;\n    uint8_t data_len;\n} TelemetryUpdateCommandHeader;\n\nvoid initTelemetryData() {\n    for (int i = 0; i < MAX_TELEMETRY_DATA_BLOCKS; ++i) {\n        memset(g_telemetryDataBlocks[i], 0x00, TELEMETRY_DATA_BLOCK_SIZE);\n    }\n}\n\nint processTelemetryUpdate(const uint8_t* msg_payload, uint16_t payload_total_len) {\n    if (msg_payload == NULL || payload_total_len < sizeof(TelemetryUpdateCommandHeader)) {\n        return -1;\n    }\n\n    const TelemetryUpdateCommandHeader* header = (const TelemetryUpdateCommandHeader*)msg_payload;\n\n    if (header->command_id != 0x01) {\n        return -2;\n    }\n\n    if (header->block_idx >= MAX_TELEMETRY_DATA_BLOCKS) {\n        return -3;\n    }\n    if (header->start_offset >= TELEMETRY_DATA_BLOCK_SIZE) {\n        return -4;\n    }\n\n    if (payload_total_len < sizeof(TelemetryUpdateCommandHeader) + header->data_len) {\n        return -5;\n    }\n\n    if ((uint16_t)header->start_offset + header->data_len > TELEMETRY_DATA_BLOCK_SIZE) {\n        return -6;\n    }\n\n    const uint8_t* data_to_write = msg_payload + sizeof(TelemetryUpdateCommandHeader);\n\n    for (uint8_t i = 0; i < header->data_len; ++i) {\n        g_telemetryDataBlocks[header->block_idx][header->start_offset + i] = data_to_write[i];\n    }\n\n    return 0;\n}\n\nvoid receiveCANTelemetryCommand(const uint8_t* data, uint16_t len) {\n    initTelemetryData();\n    processTelemetryUpdate(data, len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_LANE_SEGMENTS 5\n#define MAX_OBJECTS_PER_SEGMENT 10\n\ntypedef struct {\n    uint16_t object_id;\n    float position_x;\n    float position_y;\n    float velocity_x;\n    float velocity_y;\n    uint8_t confidence;\n} DetectedObject_Vulnerable;\n\ntypedef struct {\n    uint8_t active_objects_count;\n    DetectedObject_Vulnerable objects[MAX_OBJECTS_PER_SEGMENT];\n} LaneSegmentData_Vulnerable;\n\nstatic LaneSegmentData_Vulnerable g_laneData_vulnerable[MAX_LANE_SEGMENTS];\n\nvoid logPerceptionError_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t lane_idx;\n    uint8_t object_slot_idx;\n    DetectedObject_Vulnerable obj_data;\n} SensorFusionUpdatePacket_Vulnerable;\n\nSensorFusionUpdatePacket_Vulnerable receiveFusionUpdate_vulnerable() {\n    SensorFusionUpdatePacket_Vulnerable packet;\n    packet.lane_idx = MAX_LANE_SEGMENTS; \n    packet.object_slot_idx = 0;\n    packet.obj_data = (DetectedObject_Vulnerable){.object_id = 123, .position_x = 10.5f, .position_y = 5.2f, .velocity_x = 1.0f, .velocity_y = 0.5f, .confidence = 95};\n    return packet;\n}\n\nvoid initializeLaneData_vulnerable() {\n    for (uint8_t i = 0; i < MAX_LANE_SEGMENTS; ++i) {\n        g_laneData_vulnerable[i].active_objects_count = 0;\n        for (uint8_t j = 0; j < MAX_OBJECTS_PER_SEGMENT; ++j) {\n            g_laneData_vulnerable[i].objects[j] = (DetectedObject_Vulnerable){0};\n        }\n    }\n}\n\nvoid updateLaneObject_vulnerable() {\n    SensorFusionUpdatePacket_Vulnerable update = receiveFusionUpdate_vulnerable();\n\n    g_laneData_vulnerable[update.lane_idx].objects[update.object_slot_idx] = update.obj_data;\n    if (update.object_slot_idx >= g_laneData_vulnerable[update.lane_idx].active_objects_count) {\n        g_laneData_vulnerable[update.lane_idx].active_objects_count = update.object_slot_idx + 1;\n    }\n}\n\nvoid perceptionModuleMain_vulnerable() {\n    initializeLaneData_vulnerable();\n    updateLaneObject_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_PARAM_LOG_ENTRIES 64\n#define PARAM_ENTRY_SIZE_BYTES 16\n\nstatic uint8_t g_param_log_buffer[MAX_PARAM_LOG_ENTRIES * PARAM_ENTRY_SIZE_BYTES];\nstatic int32_t g_current_active_log_idx = 0;\nstatic uint32_t g_total_logged_entries = 0;\n\nvoid init_param_logger() {\n    memset(g_param_log_buffer, 0, sizeof(g_param_log_buffer));\n    g_current_active_log_idx = 0;\n    g_total_logged_entries = 0;\n}\n\nbool log_param_entry(const uint8_t* param_data) {\n    if (g_total_logged_entries >= MAX_PARAM_LOG_ENTRIES) {\n        return false;\n    }\n    memcpy(g_param_log_buffer + (g_total_logged_entries * PARAM_ENTRY_SIZE_BYTES), param_data, PARAM_ENTRY_SIZE_BYTES);\n    g_total_logged_entries++;\n    return true;\n}\n\nvoid set_active_log_entry_vulnerable(int32_t offset_from_current) {\n    g_current_active_log_idx += offset_from_current;\n}\n\nvoid mark_active_entry_status_byte_vulnerable(uint8_t status_value, uint8_t relative_byte_offset) {\n    if (relative_byte_offset >= PARAM_ENTRY_SIZE_BYTES) {\n        return;\n    }\n    int32_t byte_target_idx = (g_current_active_log_idx * PARAM_ENTRY_SIZE_BYTES) + relative_byte_offset;\n    g_param_log_buffer[byte_target_idx] = status_value;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define MAX_SENSOR_DATA_POINTS 128\n#define EVENT_DATA_SIZE 8\n\ntypedef struct {\n    uint16_t value;\n    uint16_t checksum;\n    uint8_t  event_data[EVENT_DATA_SIZE];\n} SensorDataPoint;\n\nstatic SensorDataPoint g_sensor_history[MAX_SENSOR_DATA_POINTS];\nstatic uint32_t g_num_history_points = 0;\nstatic int16_t g_current_engine_calibration = 100;\n\nvoid init_sensor_history_vulnerable() {\n    memset(g_sensor_history, 0, sizeof(g_sensor_history));\n    g_num_history_points = 0;\n    g_current_engine_calibration = 100;\n}\n\nvoid add_sensor_reading_vulnerable(uint16_t value, uint16_t checksum, const uint8_t* event_data) {\n    if (g_num_history_points < MAX_SENSOR_DATA_POINTS) {\n        g_sensor_history[g_num_history_points].value = value;\n        g_sensor_history[g_num_history_points].checksum = checksum;\n        memcpy(g_sensor_history[g_num_history_points].event_data, event_data, EVENT_DATA_SIZE);\n        g_num_history_points++;\n    } else {\n        for (uint32_t i = 0; i < MAX_SENSOR_DATA_POINTS - 1; ++i) {\n            g_sensor_history[i] = g_sensor_history[i+1];\n        }\n        g_sensor_history[MAX_SENSOR_DATA_POINTS - 1].value = value;\n        g_sensor_history[MAX_SENSOR_DATA_POINTS - 1].checksum = checksum;\n        memcpy(g_sensor_history[MAX_SENSOR_DATA_POINTS - 1].event_data, event_data, EVENT_DATA_SIZE);\n    }\n}\n\nvoid perform_data_analysis_vulnerable(SensorDataPoint* data_point) {\n    if (data_point != NULL) {\n        if (data_point->value > 500 && data_point->checksum == (uint16_t)(data_point->value ^ 0xFFFF)) {\n            g_current_engine_calibration += 5;\n        } else {\n            g_current_engine_calibration -= 1;\n        }\n    }\n}\n\nvoid calibrate_historical_readings_vulnerable(int32_t offset_from_current, uint32_t num_to_adjust, uint16_t new_value) {\n    if (g_num_history_points == 0 || num_to_adjust == 0) {\n        return;\n    }\n\n    int32_t start_idx = (int32_t)g_num_history_points - 1 - offset_from_current;\n\n    for (uint32_t i = 0; i < num_to_adjust; ++i) {\n        if (start_idx + i < MAX_SENSOR_DATA_POINTS) {\n            g_sensor_history[start_idx + i].value = new_value;\n            g_sensor_history[start_idx + i].checksum = (uint16_t)(new_value ^ 0xFFFF);\n        }\n    }\n\n    if (g_num_history_points > 0) {\n        perform_data_analysis_vulnerable(&g_sensor_history[g_num_history_points - 1]);\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <new>\n#include <algorithm>\n\n#pragma pack(push, 1)\nstruct EventRecordHeaderFixed {\n    uint16_t event_type;\n    uint16_t data_size; \n};\n#pragma pack(pop)\n\nclass EventRecordFixed {\npublic:\n    EventRecordFixed() : m_event_data(nullptr), m_allocated_data_size(0) {}\n\n    ~EventRecordFixed() {\n        if (m_event_data) {\n            delete[] m_event_data;\n            m_event_data = nullptr;\n        }\n    }\n\n    bool populateFromRawDataFixed(const uint8_t* raw_input_block, size_t input_block_len) {\n        if (!raw_input_block || input_block_len < sizeof(EventRecordHeaderFixed)) {\n            return false;\n        }\n\n        const EventRecordHeaderFixed* header = reinterpret_cast<const EventRecordHeaderFixed*>(raw_input_block);\n        \n        uint16_t advertised_data_len = header->data_size;\n\n        if (m_event_data) {\n            delete[] m_event_data;\n            m_event_data = nullptr;\n        }\n\n        m_event_data = new (std::nothrow) uint8_t[advertised_data_len];\n        if (!m_event_data) {\n            m_allocated_data_size = 0;\n            return false;\n        }\n        m_allocated_data_size = advertised_data_len;\n\n        size_t actual_data_available_in_input = 0;\n        if (input_block_len > sizeof(EventRecordHeaderFixed)) {\n            actual_data_available_in_input = input_block_len - sizeof(EventRecordHeaderFixed);\n        } else {\n            return false;\n        }\n        \n        size_t bytes_to_copy = std::min((size_t)advertised_data_len, actual_data_available_in_input);\n\n        for (size_t i = 0; i < bytes_to_copy; ++i) {\n            m_event_data[i] = raw_input_block[sizeof(EventRecordHeaderFixed) + i];\n        }\n\n        return true;\n    }\n\n    const uint8_t* getEventData() const {\n        return m_event_data;\n    }\n\n    uint16_t getAllocatedDataSize() const {\n        return m_allocated_data_size;\n    }\n\nprivate:\n    uint8_t* m_event_data;\n    uint16_t m_allocated_data_size;\n};\n\nclass VehicleEventDataManagerFixed {\npublic:\n    VehicleEventDataManagerFixed() {}\n    ~VehicleEventDataManagerFixed() {\n        for (auto* record : m_records) {\n            delete record;\n        }\n    }\n\n    bool addEventFromPacketFixed(const uint8_t* packet_data, size_t packet_len) {\n        EventRecordFixed* new_record = new (std::nothrow) EventRecordFixed();\n        if (!new_record) {\n            return false;\n        }\n\n        if (!new_record->populateFromRawDataFixed(packet_data, packet_len)) {\n            delete new_record;\n            return false;\n        }\n\n        m_records.push_back(new_record);\n        return true;\n    }\n\n    size_t getNumRecords() const {\n        return m_records.size();\n    }\n\n    const EventRecordFixed* getRecord(size_t index) const {\n        if (index < m_records.size()) {\n            return m_records[index];\n        }\n        return nullptr;\n    }\n\nprivate:\n    std::vector<EventRecordFixed*> m_records;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_SETTINGS_AREA_SIZE 256\n#define SETTING_BLOCK_DATA_SIZE 16\n#define SETTING_HEADER_SIZE 4\n\n#define TOTAL_BLOCK_SIZE (SETTING_HEADER_SIZE + SETTING_BLOCK_DATA_SIZE)\n\nstatic uint8_t g_vehicle_settings_area[VEHICLE_SETTINGS_AREA_SIZE];\nstatic size_t g_num_stored_blocks = 0;\n\nvoid init_vehicle_settings_storage() {\n    memset(g_vehicle_settings_area, 0, sizeof(g_vehicle_settings_area));\n    g_num_stored_blocks = 0;\n}\n\nbool store_new_setting_block(uint32_t header_flags, const uint8_t* block_data) {\n    if ((g_num_stored_blocks + 1) * TOTAL_BLOCK_SIZE > VEHICLE_SETTINGS_AREA_SIZE) {\n        return false;\n    }\n\n    size_t current_byte_offset = g_num_stored_blocks * TOTAL_BLOCK_SIZE;\n    *(uint32_t*)(g_vehicle_settings_area + current_byte_offset) = header_flags;\n    memcpy(g_vehicle_settings_area + current_byte_offset + SETTING_HEADER_SIZE, block_data, SETTING_BLOCK_DATA_SIZE);\n    g_num_stored_blocks++;\n    return true;\n}\n\nvoid adjust_setting_block_active_state_vulnerable(uint16_t target_block_index, int16_t offset_to_prev_block, bool activate) {\n    if (target_block_index >= g_num_stored_blocks) {\n        return;\n    }\n\n    size_t base_header_offset = target_block_index * TOTAL_BLOCK_SIZE;\n\n    int32_t effective_byte_offset = (int32_t)base_header_offset - (offset_to_prev_block * TOTAL_BLOCK_SIZE);\n\n    uint32_t* header_ptr = (uint32_t*)(g_vehicle_settings_area + effective_byte_offset);\n\n    if (activate) {\n        *header_ptr |= 0x01;\n    } else {\n        *header_ptr &= ~0x01;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define FIRMWARE_CONFIG_BUFFER_SIZE 256\n#define MAX_INCOMING_PARAM_DATA_SIZE 64\n\nstatic uint8_t g_firmwareConfigData[FIRMWARE_CONFIG_BUFFER_SIZE];\n\nvoid initFirmwareConfig() {\n    memset(g_firmwareConfigData, 0x00, FIRMWARE_CONFIG_BUFFER_SIZE);\n    g_firmwareConfigData[0] = 0xAA;\n    g_firmwareConfigData[1] = 0xBB;\n}\n\nint updateFirmwareConfigSegment(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len < 2) {\n        return -1;\n    }\n\n    uint8_t config_area_offset = packet_data[0];\n    uint8_t data_segment_length = packet_data[1];\n\n    if (2 + data_segment_length > packet_len) {\n        return -2;\n    }\n\n    if (data_segment_length > MAX_INCOMING_PARAM_DATA_SIZE) {\n        return -3;\n    }\n\n    if (config_area_offset >= FIRMWARE_CONFIG_BUFFER_SIZE) {\n        return -4;\n    }\n\n    const uint8_t* actual_data_ptr = packet_data + 2;\n\n    for (uint8_t i = 0; i < data_segment_length; ++i) {\n        g_firmwareConfigData[config_area_offset + i] = actual_data_ptr[i];\n    }\n\n    return 0;\n}\n\nvoid handleFirmwareUpdateMessage(const uint8_t* msg_payload, uint16_t payload_size) {\n    updateFirmwareConfigSegment(msg_payload, payload_size);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define TOTAL_SENSOR_DATA_POOL_SIZE 256\n#define SENSOR_TYPE_COUNT 3\n#define READING_SIZE sizeof(int16_t)\n\ntypedef enum {\n    SENSOR_TYPE_TEMPERATURE = 0,\n    SENSOR_TYPE_PRESSURE,\n    SENSOR_TYPE_HUMIDITY\n} SensorType;\n\nstatic uint8_t g_sensorDataPool_fixed[TOTAL_SENSOR_DATA_POOL_SIZE];\n\nstatic uint16_t g_sensorTypeDataStartOffset_fixed[SENSOR_TYPE_COUNT];\n\nstatic uint16_t g_sensorTypeDataCapacity_fixed[SENSOR_TYPE_COUNT];\n\nvoid logSystemAlert_fixed(const char* msg) {\n}\n\ntypedef struct {\n    SensorType type;\n    uint16_t   reading_index;\n    int16_t    value;\n} SensorUpdateCommand_fixed;\n\nSensorUpdateCommand_fixed getIncomingSensorUpdate_fixed() {\n    SensorUpdateCommand_fixed cmd;\n    cmd.type = SENSOR_TYPE_TEMPERATURE;\n    cmd.reading_index = 40;\n    cmd.value = 0xAAAA;\n    return cmd;\n}\n\nvoid initializeSensorDataManager_fixed() {\n    g_sensorTypeDataStartOffset_fixed[SENSOR_TYPE_TEMPERATURE] = 0;\n    g_sensorTypeDataCapacity_fixed[SENSOR_TYPE_TEMPERATURE] = 30;\n\n    g_sensorTypeDataStartOffset_fixed[SENSOR_TYPE_PRESSURE] = 60;\n    g_sensorTypeDataCapacity_fixed[SENSOR_TYPE_PRESSURE] = 50;\n\n    g_sensorTypeDataStartOffset_fixed[SENSOR_TYPE_HUMIDITY] = 160;\n    g_sensorTypeDataCapacity_fixed[SENSOR_TYPE_HUMIDITY] = 40;\n\n    for (uint16_t i = 0; i < TOTAL_SENSOR_DATA_POOL_SIZE; ++i) {\n        g_sensorDataPool_fixed[i] = 0;\n    }\n\n    logSystemAlert_fixed(\"Sensor data manager initialized (fixed).\");\n}\n\nvoid processSensorUpdateCommand_fixed() {\n    SensorUpdateCommand_fixed cmd = getIncomingSensorUpdate_fixed();\n\n    if (cmd.type >= SENSOR_TYPE_COUNT) {\n        logSystemAlert_fixed(\"Error: Invalid sensor type in update command.\");\n        return;\n    }\n\n    if (cmd.reading_index >= g_sensorTypeDataCapacity_fixed[cmd.type]) {\n        logSystemAlert_fixed(\"Error: Reading index out of bounds for specified sensor type.\");\n        return;\n    }\n\n    uint16_t base_offset = g_sensorTypeDataStartOffset_fixed[cmd.type];\n    uint16_t target_byte_offset = base_offset + (cmd.reading_index * READING_SIZE);\n\n    if (target_byte_offset + READING_SIZE <= TOTAL_SENSOR_DATA_POOL_SIZE) {\n        *(int16_t*)(g_sensorDataPool_fixed + target_byte_offset) = cmd.value;\n        logSystemAlert_fixed(\"Sensor reading updated (fixed).\");\n    } else {\n        logSystemAlert_fixed(\"Internal error: Calculated offset exceeds total sensor data pool size.\");\n    }\n}\n\nvoid main_vehicle_sensor_system_fixed() {\n    initializeSensorDataManager_fixed();\n    processSensorUpdateCommand_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_FAULT_TYPES 3\n#define MAX_LOG_ENTRIES_PER_TYPE 5\n\ntypedef struct {\n    uint16_t code;\n    uint32_t timestamp;\n} FaultLogEntry;\n\nstatic FaultLogEntry g_faultLog_Fixed[MAX_FAULT_TYPES][MAX_LOG_ENTRIES_PER_TYPE];\nstatic uint8_t g_currentLogCount_Fixed[MAX_FAULT_TYPES];\n\nvoid logSystemActivity_Fixed(const char* msg) {\n    fprintf(stderr, \"FIXED_LOG: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t fault_type_id;\n    uint16_t fault_code;\n    uint32_t event_timestamp;\n} IncomingFaultReport_Fixed;\n\nstatic uint8_t s_simulated_fault_count_fixed = 0;\nIncomingFaultReport_Fixed simulateIncomingFault_Fixed() {\n    IncomingFaultReport_Fixed report;\n    report.fault_type_id = 0;\n    report.fault_code = 0x1234 + s_simulated_fault_count_fixed;\n    report.event_timestamp = 0xABCDEF00 + s_simulated_fault_count_fixed;\n    s_simulated_fault_count_fixed++;\n    return report;\n}\n\nvoid initializeFaultLoggingSystem_Fixed() {\n    for (uint8_t i = 0; i < MAX_FAULT_TYPES; ++i) {\n        g_currentLogCount_Fixed[i] = 0;\n        for (uint8_t j = 0; j < MAX_LOG_ENTRIES_PER_TYPE; ++j) {\n            g_faultLog_Fixed[i][j] = (FaultLogEntry){0, 0};\n        }\n    }\n    s_simulated_fault_count_fixed = 0;\n    logSystemActivity_Fixed(\"Fault logging system initialized (fixed).\");\n}\n\nvoid recordFault_Fixed(IncomingFaultReport_Fixed report) {\n    if (report.fault_type_id < MAX_FAULT_TYPES) {\n        if (g_currentLogCount_Fixed[report.fault_type_id] < MAX_LOG_ENTRIES_PER_TYPE) {\n            FaultLogEntry new_entry;\n            new_entry.code = report.fault_code;\n            new_entry.timestamp = report.event_timestamp;\n\n            g_faultLog_Fixed[report.fault_type_id][g_currentLogCount_Fixed[report.fault_type_id]] = new_entry;\n            g_currentLogCount_Fixed[report.fault_type_id]++;\n            logSystemActivity_Fixed(\"Fault recorded (fixed).\");\n        } else {\n            logSystemActivity_Fixed(\"Fault log for this type is full. Ignoring new entry.\");\n        }\n    } else {\n        logSystemActivity_Fixed(\"Invalid fault type ID received. Ignoring report.\");\n    }\n}\n\nvoid automotiveFaultManager_Fixed() {\n    initializeFaultLoggingSystem_Fixed();\n\n    for (int i = 0; i < MAX_LOG_ENTRIES_PER_TYPE + 1; ++i) {\n        IncomingFaultReport_Fixed fault = simulateIncomingFault_Fixed();\n        recordFault_Fixed(fault);\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VLAN_PROFILES 16 \n#define BITMAP_SIZE_BITS 32 \n\ntypedef struct {\n    uint16_t vlan_id;\n    uint8_t priority_tag;\n    bool enable_filtering;\n    uint32_t reserved_flags;\n} VlanProfile;\n\nstatic VlanProfile g_vlanProfiles_vulnerable[MAX_VLAN_PROFILES];\n\nstatic uint32_t g_activeVlanProfileBitmap_vulnerable;\n\nvoid log_ethernet_event_vulnerable(const char* event_msg) {\n}\n\nvoid simulate_config_reception_vulnerable() {\n    g_activeVlanProfileBitmap_vulnerable = (1U << 0) | (1U << 5) | (1U << 20); \n}\n\nvoid initialize_vlan_profiles_vulnerable() {\n    for (uint8_t i = 0; i < MAX_VLAN_PROFILES; ++i) {\n        g_vlanProfiles_vulnerable[i].vlan_id = 0;\n        g_vlanProfiles_vulnerable[i].priority_tag = 0;\n        g_vlanProfiles_vulnerable[i].enable_filtering = false;\n        g_vlanProfiles_vulnerable[i].reserved_flags = 0;\n    }\n    log_ethernet_event_vulnerable(\"VLAN profiles initialized.\");\n}\n\nvoid apply_vlan_profile_to_hardware_vulnerable(uint8_t profile_index) {\n    VlanProfile current_profile = g_vlanProfiles_vulnerable[profile_index];\n    log_ethernet_event_vulnerable(\"Applying VLAN profile to hardware.\");\n}\n\nvoid process_active_vlan_configurations_vulnerable() {\n    log_ethernet_event_vulnerable(\"Processing active VLAN configurations.\");\n\n    for (uint8_t i = 0; i < BITMAP_SIZE_BITS; ++i) {\n        if ((g_activeVlanProfileBitmap_vulnerable >> i) & 1) {\n            apply_vlan_profile_to_hardware_vulnerable(i);\n        }\n    }\n    log_ethernet_event_vulnerable(\"Finished processing VLAN configurations.\");\n}\n\nvoid ethernet_switch_manager_main_vulnerable() {\n    initialize_vlan_profiles_vulnerable();\n    simulate_config_reception_vulnerable();\n    process_active_vlan_configurations_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_SYSTEM_COMPONENTS 3\n#define TOTAL_CONFIG_SLOTS_FIXED 20\n\ntypedef struct {\n    uint8_t start_index;\n    uint8_t size;\n} ComponentMapEntry_Fixed;\n\nstatic const ComponentMapEntry_Fixed g_componentMap_fixed[MAX_SYSTEM_COMPONENTS] = {\n    {0, 10},   \n    {10, 5},   \n    {15, 5}    \n};\n\nstatic uint16_t g_componentConfigData_fixed[TOTAL_CONFIG_SLOTS_FIXED];\n\ntypedef struct {\n    uint8_t component_id;\n    uint8_t parameter_offset;\n    uint16_t new_value;\n} ConfigUpdateCommand_Fixed;\n\nvoid logConfigError_fixed(const char* msg) {\n}\n\nConfigUpdateCommand_Fixed receiveConfigUpdate_fixed() {\n    ConfigUpdateCommand_Fixed cmd;\n    cmd.component_id = 1; \n    cmd.parameter_offset = 5; \n    cmd.new_value = 0xAA55;\n    return cmd;\n}\n\nvoid initializeComponentConfig_fixed() {\n    for (int i = 0; i < TOTAL_CONFIG_SLOTS_FIXED; ++i) {\n        g_componentConfigData_fixed[i] = 0;\n    }\n}\n\nvoid processConfigurationUpdate_fixed() {\n    ConfigUpdateCommand_Fixed cmd = receiveConfigUpdate_fixed();\n\n    if (cmd.component_id < MAX_SYSTEM_COMPONENTS) {\n        uint8_t component_logical_size = g_componentMap_fixed[cmd.component_id].size;\n\n        if (cmd.parameter_offset < component_logical_size) {\n            uint8_t base_index = g_componentMap_fixed[cmd.component_id].start_index;\n            uint8_t absolute_index = base_index + cmd.parameter_offset;\n\n            if (absolute_index < TOTAL_CONFIG_SLOTS_FIXED) {\n                g_componentConfigData_fixed[absolute_index] = cmd.new_value;\n                logConfigError_fixed(\"Component configuration updated successfully.\");\n            } else {\n                logConfigError_fixed(\"Configuration update failed: Internal error, absolute index out of global bounds.\");\n            }\n        } else {\n            logConfigError_fixed(\"Configuration update failed: Parameter offset out of component-specific bounds.\");\n        }\n    } else {\n        logConfigError_fixed(\"Configuration update failed: Invalid component ID.\");\n    }\n}\n\nvoid configManagerMain_fixed() {\n    initializeComponentConfig_fixed();\n    processConfigurationUpdate_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\nstruct CalibrationPointWireFormat {\n    uint16_t id;\n    uint32_t value;\n};\n#pragma pack(pop)\n\nstruct CalibrationPointStorage {\n    uint16_t id;\n    uint32_t value;\n};\n\nclass CalibrationManagerVulnerable {\npublic:\n    CalibrationManagerVulnerable() : m_calibration_data(nullptr), m_num_stored_points(0) {}\n\n    ~CalibrationManagerVulnerable() {\n        if (m_calibration_data) {\n            free(m_calibration_data);\n            m_calibration_data = nullptr;\n        }\n    }\n\n    bool processCalibrationPacketVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(uint16_t)) {\n            return false;\n        }\n\n        uint16_t num_points = *reinterpret_cast<const uint16_t*>(raw_packet);\n        size_t expected_packet_payload_len = (size_t)num_points * sizeof(CalibrationPointWireFormat);\n        size_t total_expected_packet_len = sizeof(uint16_t) + expected_packet_payload_len;\n\n        if (packet_len < total_expected_packet_len) {\n            return false;\n        }\n\n        if (m_calibration_data) {\n            free(m_calibration_data);\n            m_calibration_data = nullptr;\n        }\n\n        size_t allocation_size_bytes = (size_t)num_points * sizeof(CalibrationPointWireFormat);\n        \n        m_calibration_data = (CalibrationPointStorage*)malloc(allocation_size_bytes);\n        if (!m_calibration_data && allocation_size_bytes > 0) {\n            m_num_stored_points = 0;\n            return false;\n        }\n\n        const uint8_t* current_read_ptr = raw_packet + sizeof(uint16_t);\n        \n        for (uint16_t i = 0; i < num_points; ++i) {\n            memcpy(&m_calibration_data[i], current_read_ptr, sizeof(CalibrationPointWireFormat));\n            current_read_ptr += sizeof(CalibrationPointWireFormat);\n        }\n\n        m_num_stored_points = num_points;\n        return true;\n    }\n\n    const CalibrationPointStorage* getCalibrationData() const {\n        return m_calibration_data;\n    }\n\n    uint16_t getNumStoredPoints() const {\n        return m_num_stored_points;\n    }\n\nprivate:\n    CalibrationPointStorage* m_calibration_data;\n    uint16_t m_num_stored_points;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\ntypedef struct {\n    uint16_t param_id;\n    uint16_t data_length;\n} ParameterEntryHeader;\n\nclass VehicleConfigurationManagerFixed {\npublic:\n    VehicleConfigurationManagerFixed() : m_config_buffer(nullptr), m_current_offset(0), m_allocated_capacity(0) {}\n\n    ~VehicleConfigurationManagerFixed() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n        }\n    }\n\n    bool addConfigurationParameterFixed(uint16_t param_id, const uint8_t* param_data, uint16_t data_len) {\n        if (!param_data || data_len == 0) {\n            return false;\n        }\n\n        size_t padded_data_len = (data_len + 3) & ~3;\n        size_t physical_entry_size = sizeof(ParameterEntryHeader) + padded_data_len;\n\n        if (physical_entry_size == 0 || m_current_offset > (SIZE_MAX - physical_entry_size)) {\n            return false;\n        }\n\n        size_t required_total_capacity = m_current_offset + physical_entry_size;\n\n        if (m_config_buffer == nullptr) {\n            m_config_buffer = (uint8_t*)malloc(required_total_capacity);\n            if (!m_config_buffer) return false;\n            m_allocated_capacity = required_total_capacity;\n        } else if (required_total_capacity > m_allocated_capacity) {\n            uint8_t* temp_buffer = (uint8_t*)realloc(m_config_buffer, required_total_capacity);\n            if (!temp_buffer) {\n                free(m_config_buffer);\n                m_config_buffer = nullptr;\n                m_current_offset = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_config_buffer = temp_buffer;\n            m_allocated_capacity = required_total_capacity;\n        }\n\n        ParameterEntryHeader header_to_write = {param_id, data_len};\n        memcpy(m_config_buffer + m_current_offset, &header_to_write, sizeof(ParameterEntryHeader));\n        \n        memcpy(m_config_buffer + m_current_offset + sizeof(ParameterEntryHeader), param_data, data_len);\n        \n        size_t bytes_to_pad = padded_data_len - data_len;\n        if (bytes_to_pad > 0) {\n            memset(m_config_buffer + m_current_offset + sizeof(ParameterEntryHeader) + data_len, 0, bytes_to_pad);\n        }\n        \n        m_current_offset += physical_entry_size;\n        \n        return true;\n    }\n\n    const uint8_t* getConfigurationBuffer() const { return m_config_buffer; }\n    size_t getCurrentOffset() const { return m_current_offset; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_config_buffer;\n    size_t   m_current_offset;\n    size_t   m_allocated_capacity;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SENSOR_READING_BUFFER_SIZE 256\n#define MAX_SENSOR_VALUE 4095\n\ntypedef struct {\n    uint16_t value;\n    uint32_t timestamp;\n    uint8_t sensor_id;\n    bool valid;\n} SensorReading;\n\nstatic SensorReading g_sensor_data_buffer[SENSOR_READING_BUFFER_SIZE];\nstatic uint16_t g_write_head_idx = 0; \nstatic bool g_buffer_wrapped = false; \n\nvoid initSensorBuffer() {\n    for (int i = 0; i < SENSOR_READING_BUFFER_SIZE; ++i) {\n        memset(&g_sensor_data_buffer[i], 0, sizeof(SensorReading));\n        g_sensor_data_buffer[i].valid = false;\n    }\n    g_write_head_idx = 0;\n    g_buffer_wrapped = false;\n}\n\nvoid addSensorReading(uint16_t value, uint8_t sensor_id, uint32_t timestamp) {\n    g_sensor_data_buffer[g_write_head_idx].value = value;\n    g_sensor_data_buffer[g_write_head_idx].timestamp = timestamp;\n    g_sensor_data_buffer[g_write_head_idx].sensor_id = sensor_id;\n    g_sensor_data_buffer[g_write_head_idx].valid = true;\n\n    g_write_head_idx++;\n    if (g_write_head_idx >= SENSOR_READING_BUFFER_SIZE) {\n        g_write_head_idx = 0;\n        g_buffer_wrapped = true;\n    }\n}\n\nvoid adjustHistoricalSensorReading_Vulnerable(int32_t backward_offset_steps, uint16_t new_value) {\n    if (g_write_head_idx == 0 && !g_buffer_wrapped) {\n        return;\n    }\n\n    uint16_t last_written_actual_idx;\n    if (g_write_head_idx == 0 && g_buffer_wrapped) {\n        last_written_actual_idx = SENSOR_READING_BUFFER_SIZE - 1;\n    } else if (g_write_head_idx > 0) {\n        last_written_actual_idx = g_write_head_idx - 1;\n    } else {\n        return;\n    }\n\n    SensorReading* target_ptr = &g_sensor_data_buffer[last_written_actual_idx];\n\n    target_ptr -= backward_offset_steps;\n\n    target_ptr->value = new_value;\n    target_ptr->valid = true;\n}\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define CALIBRATION_STORAGE_SIZE 128\n#define INITIAL_CALIBRATION_DATA_LEN 10\n#define MAX_PARAM_PAYLOAD_LEN 60\n\nstatic uint8_t g_calibrationStorage[CALIBRATION_STORAGE_SIZE];\nstatic uint16_t g_currentCalibrationOffset = 0;\n\nvoid initCalibrationManager() {\n    memset(g_calibrationStorage, 0, CALIBRATION_STORAGE_SIZE);\n    for (uint8_t i = 0; i < INITIAL_CALIBRATION_DATA_LEN; ++i) {\n        g_calibrationStorage[i] = i * 2;\n    }\n    g_currentCalibrationOffset = INITIAL_CALIBRATION_DATA_LEN;\n}\n\nint processCalibrationPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len < 1) {\n        return -1;\n    }\n\n    uint16_t current_packet_read_offset = 0;\n    uint8_t num_params = packet[current_packet_read_offset++];\n\n    if (num_params == 0) {\n        return 0;\n    }\n\n    if (current_packet_read_offset >= packet_len) {\n        return -2;\n    }\n\n    uint8_t anticipated_new_data_total_len = 0;\n\n    uint16_t temp_packet_offset_check = current_packet_read_offset;\n    for (uint8_t i = 0; i < num_params; ++i) {\n        if (temp_packet_offset_check + 2 > packet_len) {\n            return -3;\n        }\n\n        uint8_t param_id = packet[temp_packet_offset_check];\n        uint8_t param_len = packet[temp_packet_offset_check + 1];\n        \n        temp_packet_offset_check += 2;\n\n        if (param_len > MAX_PARAM_PAYLOAD_LEN) {\n             return -4;\n        }\n\n        if (temp_packet_offset_check + param_len > packet_len) {\n            return -5;\n        }\n\n        uint8_t entry_size_in_storage = 1 + param_len;\n\n        anticipated_new_data_total_len += entry_size_in_storage;\n\n        temp_packet_offset_check += param_len;\n    }\n\n    if ((uint16_t)g_currentCalibrationOffset + anticipated_new_data_total_len > CALIBRATION_STORAGE_SIZE) {\n        return -6;\n    }\n\n    current_packet_read_offset = 1;\n\n    for (uint8_t i = 0; i < num_params; ++i) {\n        uint8_t param_id = packet[current_packet_read_offset++];\n        uint8_t param_len = packet[current_packet_read_offset++];\n        \n        g_calibrationStorage[g_currentCalibrationOffset++] = param_id;\n\n        for (uint8_t j = 0; j < param_len; ++j) {\n            g_calibrationStorage[g_currentCalibrationOffset++] = packet[current_packet_read_offset++];\n        }\n    }\n\n    return 0;\n}\n\nvoid handleCalibrationUpdate(const uint8_t* data, uint16_t len) {\n    processCalibrationPacket(data, len);\n}\n\nuint8_t getCalibrationByte(uint8_t index) {\n    if (index < CALIBRATION_STORAGE_SIZE) {\n        return g_calibrationStorage[index];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_DATA_REGION_SIZE 512\n#define MAX_COMMAND_PAYLOAD_SIZE 64\n\nstatic uint8_t g_diagDataRegion[DIAG_DATA_REGION_SIZE];\n\ntypedef struct {\n    uint16_t target_address;\n    uint8_t  data_length;\n    uint8_t  data[MAX_COMMAND_PAYLOAD_SIZE];\n} DiagWriteCommand;\n\nvoid initDiagDataRegion() {\n    memset(g_diagDataRegion, 0x00, DIAG_DATA_REGION_SIZE);\n}\n\nint processDiagWriteCommand_Fixed(const uint8_t* raw_command_data, uint16_t raw_command_len) {\n    if (raw_command_data == NULL || raw_command_len < (sizeof(uint16_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    DiagWriteCommand cmd;\n    cmd.target_address = (raw_command_data[0] << 8) | raw_command_data[1];\n    cmd.data_length = raw_command_data[2];\n\n    if (raw_command_len != (sizeof(uint16_t) + sizeof(uint8_t) + cmd.data_length)) {\n        return -2;\n    }\n\n    if (cmd.data_length > MAX_COMMAND_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    if (cmd.target_address >= DIAG_DATA_REGION_SIZE || (uint32_t)cmd.target_address + cmd.data_length > DIAG_DATA_REGION_SIZE) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < cmd.data_length; ++i) {\n        g_diagDataRegion[cmd.target_address + i] = raw_command_data[3 + i];\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticCommand_Fixed(const uint8_t* data, uint16_t len) {\n    processDiagWriteCommand_Fixed(data, len);\n}\n\nuint8_t getDiagDataByte(uint16_t index) {\n    if (index < DIAG_DATA_REGION_SIZE) {\n        return g_diagDataRegion[index];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <algorithm>\n\ntypedef struct {\n    uint16_t message_type;\n    uint16_t total_data_size;\n    uint16_t fragment_offset;\n    uint8_t  fragment_length;\n    uint8_t  payload[64];\n} TelemetryDataFragment;\n\nclass TelemetryDataAssembler {\nprivate:\n    uint8_t* assembled_data_buffer;\n    uint32_t current_assembled_length;\n    uint32_t expected_total_data_size;\n    bool     assembly_active;\n    uint16_t current_message_type;\n\npublic:\n    TelemetryDataAssembler() : assembled_data_buffer(nullptr), current_assembled_length(0),\n                               expected_total_data_size(0), assembly_active(false), current_message_type(0) {}\n\n    ~TelemetryDataAssembler() {\n        if (assembled_data_buffer) {\n            free(assembled_data_buffer);\n            assembled_data_buffer = nullptr;\n        }\n    }\n\n    void resetAssembly() {\n        if (assembled_data_buffer) {\n            free(assembled_data_buffer);\n        }\n        assembled_data_buffer = nullptr;\n        current_assembled_length = 0;\n        expected_total_data_size = 0;\n        assembly_active = false;\n        current_message_type = 0;\n    }\n\n    bool processFragmentFixed(const TelemetryDataFragment* fragment) {\n        if (!fragment || fragment->fragment_length > sizeof(fragment->payload)) {\n            return false;\n        }\n\n        if (!assembly_active) {\n            expected_total_data_size = fragment->total_data_size;\n            current_message_type = fragment->message_type;\n\n            if (expected_total_data_size == 0 || expected_total_data_size > 65535) {\n                return false;\n            }\n\n            assembled_data_buffer = (uint8_t*)malloc(expected_total_data_size);\n            if (!assembled_data_buffer) {\n                return false;\n            }\n            current_assembled_length = 0;\n            assembly_active = true;\n        } else {\n            if (fragment->message_type != current_message_type) {\n                return false;\n            }\n        }\n\n        if (fragment->fragment_offset >= expected_total_data_size ||\n            (uint32_t)fragment->fragment_offset + fragment->fragment_length > expected_total_data_size) {\n            return false;\n        }\n\n        for (uint8_t i = 0; i < fragment->fragment_length; ++i) {\n            assembled_data_buffer[fragment->fragment_offset + i] = fragment->payload[i];\n        }\n\n        uint32_t end_offset = fragment->fragment_offset + fragment->fragment_length;\n        if (end_offset > current_assembled_length) {\n            current_assembled_length = end_offset;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAssembledData() const {\n        if (current_assembled_length == expected_total_data_size) {\n            return assembled_data_buffer;\n        }\n        return nullptr;\n    }\n\n    uint32_t getAssembledLength() const {\n        return current_assembled_length;\n    }\n\n    uint32_t getExpectedTotalSize() const {\n        return expected_total_data_size;\n    }\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define NUM_ECU_TYPES 3\n#define MAX_ROUTINES_PER_ECU_TYPE 10\n\ntypedef void (*DiagnosticRoutine_t)(uint32_t);\n\nstatic const uint8_t g_numRoutinesPerEcuType_vulnerable[NUM_ECU_TYPES] = {\n    5, \n    8, \n    3  \n};\n\nstatic DiagnosticRoutine_t g_diagnosticRoutines_vulnerable[NUM_ECU_TYPES][MAX_ROUTINES_PER_ECU_TYPE];\n\ntypedef struct {\n    uint8_t ecu_type_id;\n    uint8_t routine_index;\n    uint32_t routine_param;\n} DiagnosticCommand_vulnerable;\n\nvoid logDiagnosticEvent_vulnerable(const char* msg) {\n}\n\nvoid simulatedDiagnosticRoutine_vulnerable(uint32_t param) {\n    (void)param;\n    logDiagnosticEvent_vulnerable(\"Simulated diagnostic routine executed.\");\n}\n\nDiagnosticCommand_vulnerable receiveDiagnosticCommand_vulnerable() {\n    DiagnosticCommand_vulnerable cmd;\n    cmd.ecu_type_id = 2; \n    cmd.routine_index = 4; \n    cmd.routine_param = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeDiagnosticSystem_vulnerable() {\n    for (uint8_t i = 0; i < NUM_ECU_TYPES; ++i) {\n        for (uint8_t j = 0; j < MAX_ROUTINES_PER_ECU_TYPE; ++j) {\n            g_diagnosticRoutines_vulnerable[i][j] = NULL;\n        }\n        for (uint8_t j = 0; j < g_numRoutinesPerEcuType_vulnerable[i]; ++j) {\n            g_diagnosticRoutines_vulnerable[i][j] = simulatedDiagnosticRoutine_vulnerable;\n        }\n    }\n    logDiagnosticEvent_vulnerable(\"Diagnostic system initialized (vulnerable).\");\n}\n\nvoid executeDiagnosticCommand_vulnerable() {\n    DiagnosticCommand_vulnerable cmd = receiveDiagnosticCommand_vulnerable();\n\n    if (cmd.ecu_type_id < NUM_ECU_TYPES) {\n        if (cmd.routine_index < MAX_ROUTINES_PER_ECU_TYPE) { \n            if (g_diagnosticRoutines_vulnerable[cmd.ecu_type_id][cmd.routine_index] != NULL) {\n                g_diagnosticRoutines_vulnerable[cmd.ecu_type_id][cmd.routine_index](cmd.routine_param);\n            } else {\n                logDiagnosticEvent_vulnerable(\"Requested routine is NULL for this index. (Possible logical OOB)\");\n            }\n        } else {\n            logDiagnosticEvent_vulnerable(\"Routine index out of global allocated bounds.\");\n        }\n    } else {\n        logDiagnosticEvent_vulnerable(\"Invalid ECU type ID.\");\n    }\n}\n\nvoid diagnosticManagerMain_vulnerable() {\n    initializeDiagnosticSystem_vulnerable();\n    executeDiagnosticCommand_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_DTC_HISTORY 64\n#define DTC_CODE_LEN 6\n\ntypedef struct {\n    char code[DTC_CODE_LEN];\n    uint32_t timestamp_ms;\n    bool active;\n    uint8_t severity;\n} DTC_Entry;\n\nstatic DTC_Entry dtc_history_buffer[MAX_DTC_HISTORY];\nstatic int dtc_history_count = 0;\n\nvoid add_dtc_to_history(const char* dtc_code, uint32_t timestamp, uint8_t severity) {\n    if (dtc_history_count < MAX_DTC_HISTORY) {\n        strncpy(dtc_history_buffer[dtc_history_count].code, dtc_code, DTC_CODE_LEN);\n        dtc_history_buffer[dtc_history_count].code[DTC_CODE_LEN - 1] = '\\0';\n        dtc_history_buffer[dtc_history_count].timestamp_ms = timestamp;\n        dtc_history_buffer[dtc_history_count].active = false;\n        dtc_history_buffer[dtc_history_count].severity = severity;\n        dtc_history_count++;\n    }\n}\n\nvoid revert_last_dtc_clears_Fixed(int num_to_revert) {\n    if (num_to_revert <= 0) {\n        return;\n    }\n\n    int actual_revert_count = num_to_revert;\n    if (actual_revert_count > dtc_history_count) {\n        actual_revert_count = dtc_history_count;\n    }\n    \n    for (int i = 0; i < actual_revert_count; ++i) {\n        int target_idx = dtc_history_count - 1 - i;\n        dtc_history_buffer[target_idx].active = true;\n        dtc_history_buffer[target_idx].severity = 0xFF;\n    }\n\n    dtc_history_count -= actual_revert_count;\n    if (dtc_history_count < 0) {\n        dtc_history_count = 0;\n    }\n}\n\nDTC_Entry* get_dtc_history_entry(int index) {\n    if (index >= 0 && index < dtc_history_count) {\n        return &dtc_history_buffer[index];\n    }\n    return NULL;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define MAX_DIAG_PACKET_SIZE 256\n#define DIAG_DATA_AREA_OFFSET 8\n\ntypedef struct {\n    uint16_t command_id;\n    uint16_t data_length;\n    uint32_t timestamp;\n} DiagnosticHeader;\n\nstatic uint8_t g_diag_packet_buffer[MAX_DIAG_PACKET_SIZE];\nstatic size_t g_current_packet_len = 0;\n\nvoid clear_diag_buffer() {\n    memset(g_diag_packet_buffer, 0, MAX_DIAG_PACKET_SIZE);\n    g_current_packet_len = 0;\n}\n\nvoid receive_diag_packet(const uint8_t* raw_data, size_t len) {\n    if (len > MAX_DIAG_PACKET_SIZE) {\n        len = MAX_DIAG_PACKET_SIZE;\n    }\n    memcpy(g_diag_packet_buffer, raw_data, len);\n    g_current_packet_len = len;\n}\n\ntypedef struct {\n    int16_t relative_offset;\n    uint8_t  field_id;\n    uint8_t  field_size;\n} DataFieldDescriptor;\n\nvoid process_diagnostic_fields_fixed(const DataFieldDescriptor* fields, size_t num_fields, uint8_t update_value) {\n    if (g_current_packet_len < DIAG_DATA_AREA_OFFSET) {\n        return;\n    }\n\n    uint8_t* data_ptr = g_diag_packet_buffer + DIAG_DATA_AREA_OFFSET;\n    size_t data_area_size = g_current_packet_len - DIAG_DATA_AREA_OFFSET;\n\n    for (size_t i = 0; i < num_fields; ++i) {\n        const DataFieldDescriptor* field = &fields[i];\n\n        if (field->relative_offset < 0) {\n            continue;\n        }\n\n        size_t current_field_offset = (size_t)field->relative_offset;\n\n        if (current_field_offset + field->field_size > data_area_size || field->field_size == 0) {\n            continue;\n        }\n\n        uint8_t* target_addr = data_ptr + current_field_offset;\n\n        *target_addr = update_value;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 256\n#define MAX_COMMAND_DATA_SIZE 128\n#define MAX_COMMANDS_PER_PACKET 8\n\nstatic uint8_t g_vehicleConfiguration[VEHICLE_CONFIG_BUFFER_SIZE];\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t target_offset;\n    uint8_t data_length;\n} ConfigCommandHeader;\n\nvoid initVehicleConfiguration() {\n    memset(g_vehicleConfiguration, 0, VEHICLE_CONFIG_BUFFER_SIZE);\n}\n\nint processConfigCommands(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len < sizeof(uint8_t)) {\n        return -1;\n    }\n\n    uint8_t num_commands = packet_data[0];\n    uint16_t current_read_offset = sizeof(uint8_t);\n\n    if (num_commands > MAX_COMMANDS_PER_PACKET) {\n        return -2;\n    }\n\n    for (uint8_t i = 0; i < num_commands; ++i) {\n        if (current_read_offset + sizeof(ConfigCommandHeader) > packet_len) {\n            return -3;\n        }\n\n        uint8_t command_id = packet_data[current_read_offset];\n        uint8_t target_offset = packet_data[current_read_offset + 1];\n        uint8_t data_length = packet_data[current_read_offset + 2];\n        current_read_offset += sizeof(ConfigCommandHeader);\n\n        if (data_length > MAX_COMMAND_DATA_SIZE) {\n            return -4;\n        }\n\n        if (current_read_offset + data_length > packet_len) {\n            return -5;\n        }\n\n        if (target_offset >= VEHICLE_CONFIG_BUFFER_SIZE || (uint16_t)target_offset + data_length > VEHICLE_CONFIG_BUFFER_SIZE) {\n            return -6;\n        }\n\n        for (uint8_t j = 0; j < data_length; ++j) {\n            g_vehicleConfiguration[target_offset + j] = packet_data[current_read_offset + j];\n        }\n        current_read_offset += data_length;\n    }\n    return 0;\n}\n\nvoid receiveConfigCommandPacket(const uint8_t* msg_data, uint16_t msg_len) {\n    processConfigCommands(msg_data, msg_len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_ECU_MODULES 8\n#define MAX_ERRORS_PER_MODULE 20\n\ntypedef struct {\n    uint16_t code;\n    uint32_t timestamp;\n} ErrorEntry;\n\ntypedef struct {\n    ErrorEntry errors[MAX_ERRORS_PER_MODULE];\n    uint8_t current_error_count;\n    uint8_t next_write_index;\n} ModuleErrorLog;\n\nstatic ModuleErrorLog g_ecu_error_logs_vulnerable[MAX_ECU_MODULES];\n\nvoid system_log_vulnerable(const char* message) {\n}\n\nuint32_t receive_diagnostic_event_vulnerable() {\n    return (0x0 << 28) | 0x19; \n}\n\nvoid initialize_error_logs_vulnerable() {\n    for (uint8_t i = 0; i < MAX_ECU_MODULES; ++i) {\n        g_ecu_error_logs_vulnerable[i].current_error_count = 0;\n        g_ecu_error_logs_vulnerable[i].next_write_index = 0;\n        for (uint8_t j = 0; j < MAX_ERRORS_PER_MODULE; ++j) {\n            g_ecu_error_logs_vulnerable[i].errors[j].code = 0;\n            g_ecu_error_logs_vulnerable[i].errors[j].timestamp = 0;\n        }\n    }\n    system_log_vulnerable(\"Error logs initialized (vulnerable).\");\n}\n\nvoid process_diagnostic_event_vulnerable() {\n    uint32_t event_id_raw = receive_diagnostic_event_vulnerable();\n\n    uint8_t module_id = (uint8_t)((event_id_raw >> 28) & 0xF); \n    uint8_t error_idx = (uint8_t)(event_id_raw & 0xFF);         \n\n    if (module_id < MAX_ECU_MODULES) {\n        g_ecu_error_logs_vulnerable[module_id].errors[error_idx].code = (uint16_t)(event_id_raw >> 8); \n        g_ecu_error_logs_vulnerable[module_id].errors[error_idx].timestamp = 0xABCD; \n        system_log_vulnerable(\"Diagnostic event processed (vulnerable).\");\n    } else {\n        system_log_vulnerable(\"Invalid module ID received (vulnerable).\");\n    }\n}\n\nvoid diagnostic_monitor_main_vulnerable() {\n    initialize_error_logs_vulnerable();\n    process_diagnostic_event_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_PAYLOAD 64\n#define DIAG_EVENT_LOG_CAPACITY 10\n\ntypedef struct {\n    uint8_t  event_type;\n    uint8_t  log_level;\n    uint8_t  payload_actual_len;\n    uint8_t  payload[MAX_DIAG_PAYLOAD];\n    uint32_t timestamp;\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diagEventLog[DIAG_EVENT_LOG_CAPACITY];\nstatic uint8_t g_currentLogIndex = 0;\n\nvoid initDiagEventLog() {\n    memset(g_diagEventLog, 0, sizeof(g_diagEventLog));\n    g_currentLogIndex = 0;\n}\n\nstatic int addEventToLog(const DiagnosticEvent* event) {\n    if (g_currentLogIndex >= DIAG_EVENT_LOG_CAPACITY) {\n        return -1;\n    }\n    memcpy(&g_diagEventLog[g_currentLogIndex], event, sizeof(DiagnosticEvent));\n    g_currentLogIndex++;\n    return 0;\n}\n\nint processIncomingDiagData(const uint8_t* raw_data, uint16_t raw_data_len) {\n    if (raw_data == NULL || raw_data_len < 3) {\n        return -1;\n    }\n\n    uint8_t event_type = raw_data[0];\n    uint8_t log_level = raw_data[1];\n    uint8_t incoming_payload_len = raw_data[2];\n\n    if (raw_data_len < (3 + incoming_payload_len)) {\n        return -2;\n    }\n\n    DiagnosticEvent temp_event;\n    temp_event.event_type = event_type;\n    temp_event.log_level = log_level;\n    temp_event.payload_actual_len = incoming_payload_len;\n    temp_event.timestamp = 0xDEADBEEF;\n\n    memcpy(temp_event.payload, raw_data + 3, incoming_payload_len);\n\n    return addEventToLog(&temp_event);\n}\n\nvoid receiveNetworkDiagMessage(const uint8_t* message_buffer, uint16_t buffer_len) {\n    processIncomingDiagData(message_buffer, buffer_len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define ENGINE_CONFIG_BUFFER_SIZE 64\n#define TRANSMISSION_CONFIG_BUFFER_SIZE 32\n#define BRAKE_CONFIG_BUFFER_SIZE 48\n#define INFOTAINMENT_CONFIG_BUFFER_SIZE 128\n\nstatic uint8_t g_engineConfig[ENGINE_CONFIG_BUFFER_SIZE];\nstatic uint8_t g_transmissionConfig[TRANSMISSION_CONFIG_BUFFER_SIZE];\nstatic uint8_t g_brakeConfig[BRAKE_CONFIG_BUFFER_SIZE];\nstatic uint8_t g_infotainmentConfig[INFOTAINMENT_CONFIG_BUFFER_SIZE];\n\ntypedef enum {\n    PARAM_ENGINE = 0,\n    PARAM_TRANSMISSION = 1,\n    PARAM_BRAKE = 2,\n    PARAM_INFOTAINMENT = 3,\n    PARAM_MAX_ID = 4\n} VehicleParamID;\n\nvoid initVehicleConfigBuffers() {\n    memset(g_engineConfig, 0, ENGINE_CONFIG_BUFFER_SIZE);\n    memset(g_transmissionConfig, 0, TRANSMISSION_CONFIG_BUFFER_SIZE);\n    memset(g_brakeConfig, 0, BRAKE_CONFIG_BUFFER_SIZE);\n    memset(g_infotainmentConfig, 0, INFOTAINMENT_CONFIG_BUFFER_SIZE);\n}\n\nint updateVehicleParameter(uint8_t param_id, uint8_t offset, uint8_t length, const uint8_t* data) {\n    if (data == NULL || length == 0) {\n        return -1;\n    }\n    if (param_id >= PARAM_MAX_ID) {\n        return -2;\n    }\n\n    uint8_t* target_buffer = NULL;\n    uint16_t buffer_size = 0;\n    \n    switch (param_id) {\n        case PARAM_ENGINE:\n            target_buffer = g_engineConfig;\n            buffer_size = ENGINE_CONFIG_BUFFER_SIZE;\n            break;\n        case PARAM_TRANSMISSION:\n            target_buffer = g_transmissionConfig;\n            buffer_size = TRANSMISSION_CONFIG_BUFFER_SIZE;\n            break;\n        case PARAM_BRAKE:\n            target_buffer = g_brakeConfig;\n            buffer_size = BRAKE_CONFIG_BUFFER_SIZE;\n            break;\n        case PARAM_INFOTAINMENT:\n            target_buffer = g_infotainmentConfig;\n            buffer_size = INFOTAINMENT_CONFIG_BUFFER_SIZE;\n            break;\n        default:\n            return -3;\n    }\n\n    if (offset >= buffer_size) {\n        return -4;\n    }\n\n    if ((uint16_t)offset + length > buffer_size) {\n        return -5;\n    }\n\n    for (uint8_t i = 0; i < length; ++i) {\n        target_buffer[offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticCommand(const uint8_t* command_packet, uint16_t packet_len) {\n    if (command_packet == NULL || packet_len < 3) {\n        return;\n    }\n\n    uint8_t param_id = command_packet[0];\n    uint8_t offset = command_packet[1];\n    uint8_t length = command_packet[2];\n    const uint8_t* data = command_packet + 3;\n\n    if (3 + length > packet_len) {\n        return;\n    }\n\n    updateVehicleParameter(param_id, offset, length, data);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n\nstruct TelemetryEntryHeader {\n    uint8_t  entry_type;\n    uint16_t entry_data_len;\n};\n\n#define CAN_MESSAGE_PAYLOAD_SIZE 8\n#define MAX_TELEMETRY_BUFFER_SIZE (1 * 1024 * 1024)\n\nclass TelemetryRecorderVulnerable {\nprivate:\n    uint8_t* m_buffer;\n    size_t m_current_offset;\n    size_t m_allocated_capacity;\n\npublic:\n    TelemetryRecorderVulnerable() : m_buffer(nullptr), m_current_offset(0), m_allocated_capacity(0) {\n        m_allocated_capacity = 4096;\n        m_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~TelemetryRecorderVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool recordTelemetryEntryVulnerable(const uint8_t* raw_entry, size_t raw_entry_len) {\n        if (!raw_entry || raw_entry_len < sizeof(TelemetryEntryHeader)) {\n            return false;\n        }\n\n        const TelemetryEntryHeader* header = reinterpret_cast<const TelemetryEntryHeader*>(raw_entry);\n        uint8_t entry_type = header->entry_type;\n        uint16_t advertised_data_len = header->entry_data_len;\n\n        size_t required_space_for_this_entry = sizeof(TelemetryEntryHeader) + advertised_data_len;\n\n        if (m_current_offset + required_space_for_this_entry > MAX_TELEMETRY_BUFFER_SIZE) {\n            return false;\n        }\n\n        if (m_current_offset + required_space_for_this_entry > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity * 2;\n            if (new_capacity < m_current_offset + required_space_for_this_entry) {\n                new_capacity = m_current_offset + required_space_for_this_entry + 4096;\n            }\n            if (new_capacity > MAX_TELEMETRY_BUFFER_SIZE) {\n                new_capacity = MAX_TELEMETRY_BUFFER_SIZE;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_capacity);\n            if (!new_buffer) {\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        for (size_t i = 0; i < sizeof(TelemetryEntryHeader); ++i) {\n            m_buffer[m_current_offset + i] = raw_entry[i];\n        }\n\n        const uint8_t* payload_src = raw_entry + sizeof(TelemetryEntryHeader);\n        size_t bytes_to_copy_payload;\n\n        if (entry_type == 0x03) {\n            bytes_to_copy_payload = (size_t)advertised_data_len * CAN_MESSAGE_PAYLOAD_SIZE;\n        } else {\n            bytes_to_copy_payload = advertised_data_len;\n        }\n\n        if (raw_entry_len < sizeof(TelemetryEntryHeader) + bytes_to_copy_payload) {\n            return false;\n        }\n        \n        for (size_t i = 0; i < bytes_to_copy_payload; ++i) {\n            m_buffer[m_current_offset + sizeof(TelemetryEntryHeader) + i] = payload_src[i];\n        }\n\n        m_current_offset += sizeof(TelemetryEntryHeader) + bytes_to_copy_payload;\n\n        return true;\n    }\n\n    const uint8_t* getTelemetryBuffer() const {\n        return m_buffer;\n    }\n\n    size_t getContainedDataSize() const {\n        return m_current_offset;\n    }\n};\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_TIRE_SENSORS 8\n#define SENSOR_DATA_HISTORY_SIZE 10\n\ntypedef struct {\n    uint16_t pressure_kPa;\n    int8_t   temperature_celsius;\n    uint8_t  battery_status;\n    bool     alarm_active;\n} TPMS_SensorData;\n\nstatic TPMS_SensorData g_tpms_sensor_data_fixed[MAX_TIRE_SENSORS];\n\nstatic uint8_t g_active_tire_sensors_count_fixed = 4;\n\nvoid log_tpms_error_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t  sensor_id;\n    uint16_t pressure;\n    int8_t   temperature;\n    uint8_t  battery;\n} TPMS_IncomingMessage_Fixed;\n\nTPMS_IncomingMessage_Fixed receive_tpms_message_fixed() {\n    TPMS_IncomingMessage_Fixed msg;\n    msg.sensor_id = 4;\n    msg.pressure = 250;\n    msg.temperature = 25;\n    msg.battery = 90;\n    return msg;\n}\n\nvoid initialize_tpms_data_fixed() {\n    for (uint8_t i = 0; i < MAX_TIRE_SENSORS; ++i) {\n        g_tpms_sensor_data_fixed[i] = (TPMS_SensorData){0, 0, 0, false};\n    }\n    for (uint8_t i = 0; i < g_active_tire_sensors_count_fixed; ++i) {\n        g_tpms_sensor_data_fixed[i].pressure_kPa = 220;\n        g_tpms_sensor_data_fixed[i].temperature_celsius = 20;\n        g_tpms_sensor_data_fixed[i].battery_status = 100;\n    }\n}\n\nvoid process_tpms_reading_fixed() {\n    TPMS_IncomingMessage_Fixed msg = receive_tpms_message_fixed();\n\n    if (msg.sensor_id < g_active_tire_sensors_count_fixed) {\n        g_tpms_sensor_data_fixed[msg.sensor_id].pressure_kPa = msg.pressure;\n        g_tpms_sensor_data_fixed[msg.sensor_id].temperature_celsius = msg.temperature;\n        g_tpms_sensor_data_fixed[msg.sensor_id].battery_status = msg.battery;\n        g_tpms_sensor_data_fixed[msg.sensor_id].alarm_active = (msg.pressure < 150 || msg.pressure > 300);\n        log_tpms_error_fixed(\"TPMS data updated successfully (fixed).\");\n    } else {\n        log_tpms_error_fixed(\"Received TPMS message with sensor ID out of active bounds. Ignoring.\");\n    }\n}\n\nvoid tpms_module_main_fixed() {\n    initialize_tpms_data_fixed();\n    process_tpms_reading_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stddef.h>\n\n#define MAX_CONFIG_PARAMETERS 15\n\nstatic long g_engineRPMTarget = 0;\nstatic long g_gearShiftThreshold = 0;\nstatic long g_suspensionHeightOffset = 0;\n\ntypedef struct {\n    long* valuePtr;\n    long  minValue;\n    long  maxValue;\n} ConfigParameterInfo;\n\nstatic ConfigParameterInfo g_configParameterMap[MAX_CONFIG_PARAMETERS];\n\nvoid initializeParameterMap() {\n    g_configParameterMap[0].valuePtr = &g_engineRPMTarget;\n    g_configParameterMap[0].minValue = 500;\n    g_configParameterMap[0].maxValue = 7000;\n\n    g_configParameterMap[1].valuePtr = &g_gearShiftThreshold;\n    g_configParameterMap[1].minValue = 1000;\n    g_configParameterMap[1].maxValue = 6000;\n\n    g_configParameterMap[2].valuePtr = &g_suspensionHeightOffset;\n    g_configParameterMap[2].minValue = -50;\n    g_configParameterMap[2].maxValue = 50;\n\n    for (int i = 3; i < MAX_CONFIG_PARAMETERS; ++i) {\n        g_configParameterMap[i].valuePtr = NULL;\n        g_configParameterMap[i].minValue = 0;\n        g_configParameterMap[i].maxValue = 0;\n    }\n}\n\ntypedef struct {\n    unsigned char commandID;\n    unsigned char parameterIndex;\n    long          newValue;\n} ParameterUpdateCommand;\n\nParameterUpdateCommand receiveParameterUpdateCommand_vulnerable() {\n    ParameterUpdateCommand cmd;\n    cmd.commandID = 0x05;\n    cmd.parameterIndex = 20;\n    cmd.newValue = 9999;\n    return cmd;\n}\n\nvoid logVehicleWarning(const char* msg) {\n}\n\nvoid processParameterUpdate_vulnerable() {\n    ParameterUpdateCommand command = receiveParameterUpdateCommand_vulnerable();\n\n    if (command.commandID == 0x05) {\n        ConfigParameterInfo paramInfo = g_configParameterMap[command.parameterIndex];\n\n        if (paramInfo.valuePtr != NULL) {\n            *(paramInfo.valuePtr) = command.newValue;\n        } else {\n            logVehicleWarning(\"Attempted to update unregistered parameter.\");\n        }\n    } else {\n        logVehicleWarning(\"Received unsupported parameter command ID.\");\n    }\n}\n\nvoid ecuMainLoop_vulnerable() {\n    initializeParameterMap();\n    processParameterUpdate_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\nvoid log_diag_vulnerable(const char* msg) {\n    printf(\"VULN LOG: %s\\n\", msg);\n}\n\n#define MAX_MESSAGE_BUFFER_SIZE_VULNERABLE 256\nstatic uint8_t g_messageBuffer_vulnerable[MAX_MESSAGE_BUFFER_SIZE_VULNERABLE];\nstatic uint16_t g_currentParseOffset_vulnerable = 0;\n\ntypedef struct {\n    uint8_t command_code;\n    int16_t param_length_bytes; \n    uint8_t data[10]; \n} IncomingDiagMessage_vulnerable;\n\nIncomingDiagMessage_vulnerable receiveDiagMessage_vulnerable() {\n    IncomingDiagMessage_vulnerable msg;\n    msg.command_code = 0x01;\n    msg.param_length_bytes = -10; \n    for (int i = 0; i < 10; ++i) {\n        msg.data[i] = (uint8_t)i;\n    }\n    return msg;\n}\n\nvoid initializeParser_vulnerable() {\n    g_currentParseOffset_vulnerable = 5; \n    for (int i = 0; i < MAX_MESSAGE_BUFFER_SIZE_VULNERABLE; ++i) {\n        g_messageBuffer_vulnerable[i] = (uint8_t)(i % 0xFF); \n    }\n    log_diag_vulnerable(\"Parser initialized (vulnerable).\");\n}\n\nvoid parseVariableLengthParameter_vulnerable(int16_t param_length_bytes) {\n    log_diag_vulnerable(\"Attempting to parse variable length parameter (vulnerable).\");\n\n    if (g_currentParseOffset_vulnerable + param_length_bytes < 0) {\n        log_diag_vulnerable(\"Error: Proposed offset would underflow. This check should not be passed.\");\n        return;\n    }\n\n    g_currentParseOffset_vulnerable += param_length_bytes; \n\n    if (g_currentParseOffset_vulnerable < MAX_MESSAGE_BUFFER_SIZE_VULNERABLE) {\n        log_diag_vulnerable(\"Offset updated. Attempting to read a byte at new position.\");\n        uint8_t val = g_messageBuffer_vulnerable[g_currentParseOffset_vulnerable]; \n        printf(\"VULN: Read byte: %02X at offset %u\\n\", val, g_currentParseOffset_vulnerable);\n    } else {\n        log_diag_vulnerable(\"Fatal: Parser offset became out of bounds after update. This path usually indicates a prior issue.\");\n    }\n}\n\nvoid diagParser_vulnerable_main() {\n    initializeParser_vulnerable();\n    IncomingDiagMessage_vulnerable msg = receiveDiagMessage_vulnerable();\n    parseVariableLengthParameter_vulnerable(msg.param_length_bytes);\n    log_diag_vulnerable(\"Vulnerable diagnostic parser finished.\");\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CONFIG_NAME_MAX_LEN 32\n#define CONFIG_VALUE_MAX_LEN 64\n#define MAX_CONFIG_PARAMS 10\n\ntypedef enum {\n    PARAM_TYPE_UINT8,\n    PARAM_TYPE_UINT16,\n    PARAM_TYPE_UINT32,\n    PARAM_TYPE_STRING,\n    PARAM_TYPE_BOOL\n} ConfigParamType;\n\ntypedef struct {\n    char name[CONFIG_NAME_MAX_LEN];\n    ConfigParamType type;\n    uint8_t value_len;\n    union {\n        uint8_t  u8_val;\n        uint16_t u16_val;\n        uint32_t u32_val;\n        char     str_val[CONFIG_VALUE_MAX_LEN];\n        bool     bool_val;\n    } value;\n} ConfigurationParameter;\n\nstatic ConfigurationParameter g_vehicleConfig[MAX_CONFIG_PARAMS];\nstatic uint8_t g_numConfigParams = 0;\n\nint parseConfigurationParameter(const uint8_t* stream, uint16_t stream_len, ConfigurationParameter* param_out) {\n    if (stream == NULL || param_out == NULL || stream_len < 2) {\n        return -1;\n    }\n\n    uint16_t bytes_consumed = 0;\n\n    uint8_t name_len = stream[bytes_consumed++];\n    if (name_len >= CONFIG_NAME_MAX_LEN || bytes_consumed + name_len > stream_len) {\n        return -1;\n    }\n    memcpy(param_out->name, stream + bytes_consumed, name_len);\n    param_out->name[name_len] = '\\0';\n    bytes_consumed += name_len;\n\n    param_out->type = (ConfigParamType)stream[bytes_consumed++];\n    if (bytes_consumed > stream_len) {\n        return -1;\n    }\n\n    switch (param_out->type) {\n        case PARAM_TYPE_UINT8:\n            if (bytes_consumed + sizeof(uint8_t) > stream_len) return -1;\n            param_out->value.u8_val = stream[bytes_consumed];\n            param_out->value_len = sizeof(uint8_t);\n            bytes_consumed += sizeof(uint8_t);\n            break;\n        case PARAM_TYPE_UINT16:\n            if (bytes_consumed + sizeof(uint16_t) > stream_len) return -1;\n            param_out->value.u16_val = (uint16_t)((stream[bytes_consumed] << 8) | stream[bytes_consumed+1]);\n            param_out->value_len = sizeof(uint16_t);\n            bytes_consumed += sizeof(uint16_t);\n            break;\n        case PARAM_TYPE_UINT32:\n            if (bytes_consumed + sizeof(uint32_t) > stream_len) return -1;\n            param_out->value.u32_val = (uint32_t)((stream[bytes_consumed] << 24) | (stream[bytes_consumed+1] << 16) |\n                                                   (stream[bytes_consumed+2] << 8) | stream[bytes_consumed+3]);\n            param_out->value_len = sizeof(uint32_t);\n            bytes_consumed += sizeof(uint32_t);\n            break;\n        case PARAM_TYPE_BOOL:\n            if (bytes_consumed + sizeof(bool) > stream_len) return -1;\n            param_out->value.bool_val = (bool)stream[bytes_consumed];\n            param_out->value_len = sizeof(bool);\n            bytes_consumed += sizeof(bool);\n            break;\n        case PARAM_TYPE_STRING:\n            if (bytes_consumed >= stream_len) return -1;\n            uint8_t str_actual_len = stream[bytes_consumed++];\n            if (str_actual_len >= CONFIG_VALUE_MAX_LEN || bytes_consumed + str_actual_len > stream_len) {\n                return -1;\n            }\n            memcpy(param_out->value.str_val, stream + bytes_consumed, str_actual_len);\n            param_out->value.str_val[str_actual_len] = '\\0';\n            param_out->value_len = str_actual_len;\n            bytes_consumed += str_actual_len;\n            break;\n        default:\n            return -1;\n    }\n\n    return bytes_consumed;\n}\n\nint loadVehicleConfiguration(const uint8_t* config_stream, uint16_t stream_total_len) {\n    if (config_stream == NULL || stream_total_len == 0) {\n        return -1;\n    }\n\n    uint16_t current_stream_pos = 0;\n    g_numConfigParams = 0;\n\n    while (current_stream_pos < stream_total_len && g_numConfigParams < MAX_CONFIG_PARAMS) {\n        int bytes_parsed = parseConfigurationParameter(\n                                config_stream + current_stream_pos,\n                                stream_total_len - current_stream_pos,\n                                &g_vehicleConfig[g_numConfigParams]\n                           );\n\n        if (bytes_parsed <= 0) {\n            return -1;\n        }\n        current_stream_pos += bytes_parsed;\n        g_numConfigParams++;\n    }\n\n    return 0;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define ENGINE_PARAM_MAP_SIZE 256\n#define MAX_PARAM_UPDATE_LENGTH 64\n\nstatic uint8_t g_engineParamMap[ENGINE_PARAM_MAP_SIZE];\n\nvoid initializeEngineParameters() {\n    memset(g_engineParamMap, 0x00, ENGINE_PARAM_MAP_SIZE);\n    for (uint16_t i = 0; i < ENGINE_PARAM_MAP_SIZE; ++i) {\n        g_engineParamMap[i] = (uint8_t)(i % 0xFF);\n    }\n}\n\nint updateEngineParameterSegment(uint8_t param_offset, const uint8_t* update_data, uint8_t update_len) {\n    if (update_data == NULL || update_len == 0) {\n        return -1;\n    }\n\n    if (param_offset >= ENGINE_PARAM_MAP_SIZE) {\n        return -2;\n    }\n\n    if (update_len > MAX_PARAM_UPDATE_LENGTH) {\n        return -3;\n    }\n\n    if ((uint16_t)param_offset + update_len > ENGINE_PARAM_MAP_SIZE) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < update_len; ++i) {\n        g_engineParamMap[param_offset + i] = update_data[i];\n    }\n\n    return 0;\n}\n\nvoid handleParamUpdateMessage(uint8_t offset, const uint8_t* data, uint8_t len) {\n    updateEngineParameterSegment(offset, data, len);\n}\n\nuint8_t getEngineParameter(uint8_t index) {\n    if (index < ENGINE_PARAM_MAP_SIZE) {\n        return g_engineParamMap[index];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <new>\n\ntypedef struct {\n    uint16_t record_id;\n    uint16_t data_size; \n} LogRecordHeader;\n\ntypedef struct {\n    uint32_t total_expected_payload_bytes; \n    uint16_t num_records;       \n} LogPacketHeader;\n\nclass VehicleLogProcessor {\npublic:\n    VehicleLogProcessor() :\n        internal_log_buffer(nullptr),\n        allocated_buffer_size(0) {}\n\n    ~VehicleLogProcessor() {\n        if (internal_log_buffer) {\n            delete[] internal_log_buffer;\n            internal_log_buffer = nullptr;\n        }\n    }\n\n    bool processLogPacketVulnerable(const uint8_t* raw_packet, size_t raw_packet_len) {\n        if (!raw_packet || raw_packet_len < sizeof(LogPacketHeader)) {\n            return false;\n        }\n\n        const LogPacketHeader* packet_header = reinterpret_cast<const LogPacketHeader*>(raw_packet);\n\n        if (raw_packet_len < (sizeof(LogPacketHeader) + packet_header->total_expected_payload_bytes)) {\n            return false;\n        }\n\n        if (internal_log_buffer) {\n            delete[] internal_log_buffer;\n        }\n        internal_log_buffer = new (std::nothrow) uint8_t[packet_header->total_expected_payload_bytes];\n        if (!internal_log_buffer) {\n            return false;\n        }\n        allocated_buffer_size = packet_header->total_expected_payload_bytes;\n\n        size_t current_raw_read_offset = sizeof(LogPacketHeader);\n        size_t current_internal_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_header->num_records; ++i) {\n            if (current_raw_read_offset + sizeof(LogRecordHeader) > raw_packet_len) {\n                return false;\n            }\n            const LogRecordHeader* record_header = reinterpret_cast<const LogRecordHeader*>(raw_packet + current_raw_read_offset);\n\n            uint16_t record_data_len = record_header->data_size;\n\n            for (uint16_t j = 0; j < record_data_len; ++j) {\n                internal_log_buffer[current_internal_write_offset + j] = raw_packet[current_raw_read_offset + sizeof(LogRecordHeader) + j];\n            }\n\n            current_raw_read_offset += sizeof(LogRecordHeader) + record_data_len;\n            current_internal_write_offset += record_data_len;\n\n            if (current_raw_read_offset > raw_packet_len) {\n                return false;\n            }\n        }\n\n        if (current_internal_write_offset > allocated_buffer_size) {\n            return false;\n        }\n        \n        if (current_internal_write_offset != packet_header->total_expected_payload_bytes) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getLogBuffer() const {\n        return internal_log_buffer;\n    }\n\n    size_t getAllocatedSize() const {\n        return allocated_buffer_size;\n    }\n\nprivate:\n    uint8_t* internal_log_buffer;\n    size_t allocated_buffer_size;\n};\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_FEATURES_VULNERABLE 5\n\ntypedef struct {\n    uint16_t feature_id;\n    bool is_active;\n    uint8_t current_level;\n    uint8_t reserved_status;\n} VehicleFeature_Vulnerable;\n\nstatic VehicleFeature_Vulnerable g_vehicleFeatures_vulnerable[MAX_VEHICLE_FEATURES_VULNERABLE];\n\ntypedef struct {\n    uint16_t command_code;\n    uint8_t target_feature_idx;\n    uint8_t requested_level;\n    uint8_t padding[4];\n} DiagnosticCommand_Vulnerable;\n\nvoid vehicleSystemLog_vulnerable(const char* message) {\n}\n\nDiagnosticCommand_Vulnerable receiveDiagnosticCommand_vulnerable() {\n    DiagnosticCommand_Vulnerable cmd;\n    cmd.command_code = 0x10;\n    cmd.target_feature_idx = MAX_VEHICLE_FEATURES_VULNERABLE; \n    cmd.requested_level = 2;\n    cmd.padding[0] = 0; cmd.padding[1] = 0; cmd.padding[2] = 0; cmd.padding[3] = 0;\n    return cmd;\n}\n\nvoid initializeVehicleFeatures_vulnerable() {\n    for (int i = 0; i < MAX_VEHICLE_FEATURES_VULNERABLE; ++i) {\n        g_vehicleFeatures_vulnerable[i].feature_id = 1000 + i;\n        g_vehicleFeatures_vulnerable[i].is_active = false;\n        g_vehicleFeatures_vulnerable[i].current_level = 0;\n        g_vehicleFeatures_vulnerable[i].reserved_status = 0;\n    }\n    g_vehicleFeatures_vulnerable[0].is_active = true;\n    g_vehicleFeatures_vulnerable[0].current_level = 1;\n    g_vehicleFeatures_vulnerable[2].is_active = true;\n    g_vehicleFeatures_vulnerable[2].current_level = 0;\n    vehicleSystemLog_vulnerable(\"Vehicle features initialized.\");\n}\n\nvoid processVehicleControlCommand_vulnerable() {\n    DiagnosticCommand_Vulnerable cmd = receiveDiagnosticCommand_vulnerable();\n\n    switch (cmd.command_code) {\n        case 0x10:\n            g_vehicleFeatures_vulnerable[cmd.target_feature_idx].current_level = cmd.requested_level;\n            g_vehicleFeatures_vulnerable[cmd.target_feature_idx].is_active = (cmd.requested_level > 0);\n            vehicleSystemLog_vulnerable(\"Feature state update processed.\");\n            break;\n        case 0x11:\n            vehicleSystemLog_vulnerable(\"Query feature state command received.\");\n            break;\n        default:\n            vehicleSystemLog_vulnerable(\"Unsupported diagnostic command received.\");\n            break;\n    }\n}\n\nvoid vehicleMainControlLoop_vulnerable() {\n    initializeVehicleFeatures_vulnerable();\n    processVehicleControlCommand_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_DIAG_ENTRIES 32\n#define MESSAGE_LEN 24\n\ntypedef struct {\n    uint8_t priority;\n    uint32_t timestamp;\n    char message[MESSAGE_LEN];\n} DiagMessage;\n\nstatic DiagMessage g_diag_log_buffer[MAX_DIAG_ENTRIES];\nstatic uint8_t g_current_write_idx = 0;\nstatic uint8_t g_num_messages = 0;\n\nvoid init_diag_log() {\n    memset(g_diag_log_buffer, 0, sizeof(g_diag_log_buffer));\n    g_current_write_idx = 0;\n    g_num_messages = 0;\n}\n\nvoid add_diag_message(uint8_t priority, uint32_t timestamp, const char* msg) {\n    strncpy(g_diag_log_buffer[g_current_write_idx].message, msg, MESSAGE_LEN - 1);\n    g_diag_log_buffer[g_current_write_idx].message[MESSAGE_LEN - 1] = '\\0';\n    g_diag_log_buffer[g_current_write_idx].priority = priority;\n    g_diag_log_buffer[g_current_write_idx].timestamp = timestamp;\n\n    g_current_write_idx = (g_current_write_idx + 1) % MAX_DIAG_ENTRIES;\n    if (g_num_messages < MAX_DIAG_ENTRIES) {\n        g_num_messages++;\n    }\n}\n\nvoid modify_diag_message_vulnerable(uint8_t relative_idx_from_last, uint8_t new_priority, const char* new_msg) {\n    if (g_num_messages == 0) {\n        return;\n    }\n\n    int32_t last_entry_idx = (g_current_write_idx == 0) ? (MAX_DIAG_ENTRIES - 1) : (g_current_write_idx - 1);\n\n    int32_t target_actual_idx = last_entry_idx - relative_idx_from_last;\n\n    strncpy(g_diag_log_buffer[target_actual_idx].message, new_msg, MESSAGE_LEN - 1);\n    g_diag_log_buffer[target_actual_idx].message[MESSAGE_LEN - 1] = '\\0';\n    g_diag_log_buffer[target_actual_idx].priority = new_priority;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_PROCESSED_SENSORS 128\n\ntypedef struct {\n    uint32_t sensor_id;\n    uint32_t processed_value;\n    bool valid;\n} ProcessedSensorEntry;\n\nstatic ProcessedSensorEntry g_processed_sensor_data_vulnerable[MAX_PROCESSED_SENSORS];\nstatic int16_t g_next_write_idx_vulnerable = 0;\n\nvoid init_sensor_data_buffer_vulnerable() {\n    memset(g_processed_sensor_data_vulnerable, 0, sizeof(g_processed_sensor_data_vulnerable));\n    g_next_write_idx_vulnerable = 0;\n}\n\nbool add_processed_sensor_data_vulnerable(uint32_t id, uint32_t value) {\n    if (g_next_write_idx_vulnerable >= MAX_PROCESSED_SENSORS) {\n        return false;\n    }\n    g_processed_sensor_data_vulnerable[g_next_write_idx_vulnerable].sensor_id = id;\n    g_processed_sensor_data_vulnerable[g_next_write_idx_vulnerable].processed_value = value;\n    g_processed_sensor_data_vulnerable[g_next_write_idx_vulnerable].valid = true;\n    g_next_write_idx_vulnerable++;\n    return true;\n}\n\nvoid mark_sensor_data_invalid_vulnerable(uint16_t historical_offset) {\n    if (g_next_write_idx_vulnerable == 0) {\n        return;\n    }\n\n    int16_t last_valid_idx = g_next_write_idx_vulnerable - 1;\n\n    int16_t target_idx = last_valid_idx - historical_offset;\n\n    g_processed_sensor_data_vulnerable[target_idx].valid = false;\n    g_processed_sensor_data_vulnerable[target_idx].processed_value = 0xFFFFFFFF;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_BUFFER_SIZE 256\n#define MAX_TELEMETRY_PAYLOAD_LEN 8 \n\nstatic uint8_t g_telemetryDataBuffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_currentBufferWriteOffset = 0;\n\ntypedef enum {\n    TELEMETRY_TYPE_ENGINE_STATUS = 0,\n    TELEMETRY_TYPE_BATTERY_INFO,\n    TELEMETRY_TYPE_TIRE_PRESSURE,\n    TELEMETRY_TYPE_COUNT\n} TelemetryBlockType;\n\ntypedef struct {\n    uint8_t item_size;\n    uint8_t num_items;\n} TelemetryBlockMetadata;\n\nstatic const TelemetryBlockMetadata g_telemetryMetadata[TELEMETRY_TYPE_COUNT] = {\n    {10, 10}, \n    {5, 5},   \n    {8, 10}   \n};\n\nstatic uint16_t g_telemetryTypeBaseOffsets[TELEMETRY_TYPE_COUNT];\n\nvoid initTelemetrySystem() {\n    memset(g_telemetryDataBuffer, 0, TELEMETRY_BUFFER_SIZE);\n    g_currentBufferWriteOffset = 0;\n\n    uint16_t current_offset = 0;\n    for (int i = 0; i < TELEMETRY_TYPE_COUNT; ++i) {\n        g_telemetryTypeBaseOffsets[i] = current_offset;\n        current_offset += (uint16_t)g_telemetryMetadata[i].item_size * g_telemetryMetadata[i].num_items;\n    }\n    g_currentBufferWriteOffset = current_offset; \n}\n\nint updateTelemetryDataItem(TelemetryBlockType telemetry_type, uint8_t item_index, \n                            uint8_t update_offset, uint8_t data_len, const uint8_t* data_payload) {\n    \n    if (telemetry_type >= TELEMETRY_TYPE_COUNT || data_payload == NULL || data_len == 0) {\n        return -1;\n    }\n\n    if (item_index >= g_telemetryMetadata[telemetry_type].num_items) {\n        return -2;\n    }\n\n    if (data_len > MAX_TELEMETRY_PAYLOAD_LEN) {\n        return -3;\n    }\n\n    uint16_t item_base_addr = g_telemetryTypeBaseOffsets[telemetry_type] + \n                              (uint16_t)item_index * g_telemetryMetadata[telemetry_type].item_size;\n\n    uint16_t dest_offset = item_base_addr + update_offset;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_telemetryDataBuffer[dest_offset + i] = data_payload[i];\n    }\n\n    return 0;\n}\n\nvoid simulateCanTelemetryUpdate(TelemetryBlockType type, uint8_t index, uint8_t offset, uint8_t len, const uint8_t* data) {\n    updateTelemetryDataItem(type, index, offset, len, data);\n}\n\nuint8_t getTelemetryDataByte(uint16_t global_offset) {\n    if (global_offset < TELEMETRY_BUFFER_SIZE) {\n        return g_telemetryDataBuffer[global_offset];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n\ntypedef enum {\n    MODE_PARK = 0,\n    MODE_DRIVE,\n    MODE_REVERSE,\n    MODE_NEUTRAL,\n    NUM_VEHICLE_MODES\n} VehicleMode;\n\ntypedef enum {\n    INPUT_SHIFT_P = 0,\n    INPUT_SHIFT_D,\n    INPUT_SHIFT_R,\n    INPUT_SHIFT_N,\n    INPUT_ACCEL,\n    INPUT_BRAKE,\n    INPUT_CRUISE_ON,\n    INPUT_CRUISE_OFF,\n    NUM_VEHICLE_INPUTS\n} VehicleInput;\n\nvoid logSystemError(const char* msg) {\n}\n\nstatic VehicleMode g_currentVehicleMode = MODE_PARK;\n\nstatic const VehicleMode g_transition_table[NUM_VEHICLE_MODES][NUM_VEHICLE_INPUTS] = {\n    { MODE_PARK, MODE_DRIVE, MODE_REVERSE, MODE_NEUTRAL, MODE_PARK, MODE_PARK, MODE_PARK, MODE_PARK },\n    { MODE_PARK, MODE_DRIVE, MODE_DRIVE,   MODE_NEUTRAL, MODE_DRIVE,MODE_DRIVE,MODE_DRIVE,MODE_DRIVE },\n    { MODE_PARK, MODE_REVERSE, MODE_REVERSE, MODE_NEUTRAL, MODE_REVERSE,MODE_REVERSE,MODE_REVERSE,MODE_REVERSE },\n    { MODE_PARK, MODE_DRIVE, MODE_REVERSE, MODE_NEUTRAL, MODE_NEUTRAL,MODE_NEUTRAL,MODE_NEUTRAL,MODE_NEUTRAL }\n};\n\nVehicleInput receiveSimulatedInputEvent_fixed() {\n    return (VehicleInput)NUM_VEHICLE_INPUTS;\n}\n\nvoid processVehicleInput_fixed() {\n    VehicleInput inputEvent = receiveSimulatedInputEvent_fixed();\n    VehicleMode newMode = g_currentVehicleMode;\n\n    if (inputEvent >= 0 && inputEvent < NUM_VEHICLE_INPUTS) {\n        newMode = g_transition_table[g_currentVehicleMode][inputEvent];\n    } else {\n        logSystemError(\"Invalid vehicle input event received. Ignoring transition.\");\n        newMode = g_currentVehicleMode;\n    }\n\n    g_currentVehicleMode = newMode;\n}\n\nvoid vehicleStateManager_fixed_main() {\n    g_currentVehicleMode = MODE_PARK;\n    processVehicleInput_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <limits>\n\n#pragma pack(push, 1)\n\nstruct ConfigPacketHeader {\n    uint32_t magic_id;\n    uint16_t num_entries;\n    uint32_t total_declared_size; \n};\n\nstruct ConfigEntryHeader {\n    uint16_t param_id;\n    uint16_t data_length; \n};\n\n#pragma pack(pop)\n\nclass VehicleConfigStoreFixed {\npublic:\n    VehicleConfigStoreFixed() : m_config_buffer(nullptr), m_current_buffer_size(0), m_allocated_capacity(0) {}\n\n    ~VehicleConfigStoreFixed() {\n        clearConfig();\n    }\n\n    void clearConfig() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n            m_config_buffer = nullptr;\n        }\n        m_current_buffer_size = 0;\n        m_allocated_capacity = 0;\n    }\n\n    bool processConfigPacketFixed(const uint8_t* raw_packet_data, size_t packet_length) {\n        if (!raw_packet_data || packet_length < sizeof(ConfigPacketHeader)) {\n            return false;\n        }\n\n        const ConfigPacketHeader* packet_hdr = reinterpret_cast<const ConfigPacketHeader*>(raw_packet_data);\n\n        if (packet_hdr->magic_id != 0xFEEDC0DE) {\n            return false;\n        }\n        \n        if (packet_hdr->num_entries == 0) {\n            clearConfig();\n            return true; \n        }\n\n        size_t current_read_offset_scan = sizeof(ConfigPacketHeader);\n        size_t calculated_actual_payload_size = 0;\n\n        for (uint16_t i = 0; i < packet_hdr->num_entries; ++i) {\n            if (current_read_offset_scan > (packet_length - sizeof(ConfigEntryHeader))) {\n                return false;\n            }\n\n            const ConfigEntryHeader* entry_hdr = reinterpret_cast<const ConfigEntryHeader*>(raw_packet_data + current_read_offset_scan);\n            uint16_t data_len = entry_hdr->data_length;\n\n            if (data_len > (std::numeric_limits<size_t>::max() - sizeof(ConfigEntryHeader))) {\n                return false; \n            }\n            size_t entry_content_size_without_padding = sizeof(ConfigEntryHeader) + data_len;\n\n            size_t padding_bytes = (4 - (entry_content_size_without_padding % 4)) % 4;\n            if (entry_content_size_without_padding % 4 == 0) {\n                padding_bytes = 0;\n            }\n\n            if (entry_content_size_without_padding > (std::numeric_limits<size_t>::max() - padding_bytes)) {\n                return false; \n            }\n            size_t total_entry_storage_size = entry_content_size_without_padding + padding_bytes;\n\n            if (current_read_offset_scan > (packet_length - total_entry_storage_size)) {\n                return false;\n            }\n\n            if (calculated_actual_payload_size > (std::numeric_limits<size_t>::max() - total_entry_storage_size)) {\n                return false; \n            }\n            calculated_actual_payload_size += total_entry_storage_size;\n            \n            current_read_offset_scan += total_entry_storage_size;\n        }\n\n        if (calculated_actual_payload_size != packet_hdr->total_declared_size) {\n            return false; \n        }\n\n        uint8_t* new_buffer = (uint8_t*)realloc(m_config_buffer, calculated_actual_payload_size);\n        if (!new_buffer) {\n            clearConfig();\n            return false;\n        }\n        m_config_buffer = new_buffer;\n        m_allocated_capacity = calculated_actual_payload_size;\n        m_current_buffer_size = 0;\n\n        size_t current_read_offset_copy = sizeof(ConfigPacketHeader);\n        size_t current_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_hdr->num_entries; ++i) {\n            const ConfigEntryHeader* entry_hdr = reinterpret_cast<const ConfigEntryHeader*>(raw_packet_data + current_read_offset_copy);\n            uint16_t data_len = entry_hdr->data_length;\n\n            size_t entry_content_size_without_padding = sizeof(ConfigEntryHeader) + data_len;\n            size_t padding_bytes = (4 - (entry_content_size_without_padding % 4)) % 4;\n            if (entry_content_size_without_padding % 4 == 0) {\n                padding_bytes = 0;\n            }\n            size_t total_entry_storage_size = entry_content_size_without_padding + padding_bytes;\n\n            if (current_write_offset > (m_allocated_capacity - total_entry_storage_size)) {\n                clearConfig();\n                return false;\n            }\n            \n            memcpy(m_config_buffer + current_write_offset, entry_hdr, sizeof(ConfigEntryHeader));\n            current_write_offset += sizeof(ConfigEntryHeader);\n\n            memcpy(m_config_buffer + current_write_offset, raw_packet_data + current_read_offset_copy + sizeof(ConfigEntryHeader), data_len);\n            current_write_offset += data_len;\n\n            if (padding_bytes > 0) {\n                memset(m_config_buffer + current_write_offset, 0, padding_bytes);\n                current_write_offset += padding_bytes;\n            }\n            \n            current_read_offset_copy += total_entry_storage_size;\n            m_current_buffer_size = current_write_offset;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getConfigBuffer() const {\n        return m_config_buffer;\n    }\n\n    size_t getCurrentBufferSize() const {\n        return m_current_buffer_size;\n    }\n\n    size_t getAllocatedCapacity() const {\n        return m_allocated_capacity;\n    }\n\nprivate:\n    uint8_t* m_config_buffer;\n    size_t m_current_buffer_size;\n    size_t m_allocated_capacity;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <string.h>\n\nstruct DiagnosticEvent {\n    uint32_t timestamp;\n    uint16_t event_code;\n    char*    details;\n};\n\nclass DiagnosticEventRecorderFixed {\nprivate:\n    DiagnosticEvent* m_events;\n    size_t m_event_count;\n    size_t m_capacity;\n\npublic:\n    DiagnosticEventRecorderFixed() : m_events(nullptr), m_event_count(0), m_capacity(0) {\n        m_capacity = 10; \n        m_events = (DiagnosticEvent*)malloc(m_capacity * sizeof(DiagnosticEvent));\n        if (!m_events) {\n            m_capacity = 0;\n        }\n    }\n\n    ~DiagnosticEventRecorderFixed() {\n        for (size_t i = 0; i < m_event_count; ++i) {\n            if (m_events[i].details) {\n                free(m_events[i].details);\n            }\n        }\n        if (m_events) {\n            free(m_events);\n        }\n    }\n\n    bool addEventFixed(uint32_t timestamp, uint16_t event_code, const char* details_str, uint16_t details_len_from_packet) {\n        if (!details_str || details_len_from_packet == 0) {\n            return false;\n        }\n        \n        if (details_len_from_packet > 255) {\n            return false;\n        }\n\n        if (m_event_count >= m_capacity) {\n            size_t new_capacity = m_capacity * 2;\n            if (new_capacity == 0) new_capacity = 1;\n            DiagnosticEvent* new_events = (DiagnosticEvent*)realloc(m_events, new_capacity * sizeof(DiagnosticEvent));\n            if (!new_events) {\n                return false;\n            }\n            m_events = new_events;\n            m_capacity = new_capacity;\n        }\n\n        DiagnosticEvent new_event;\n        new_event.timestamp = timestamp;\n        new_event.event_code = event_code;\n\n        new_event.details = (char*)malloc(details_len_from_packet + 1);\n        if (!new_event.details) {\n            return false;\n        }\n        \n        for (uint16_t i = 0; i < details_len_from_packet; ++i) {\n            new_event.details[i] = details_str[i];\n        }\n        new_event.details[details_len_from_packet] = '\\0';\n\n        m_events[m_event_count++] = new_event;\n        return true;\n    }\n\n    size_t getEventCount() const { return m_event_count; }\n    const DiagnosticEvent* getEvent(size_t index) const {\n        if (index < m_event_count) return &m_events[index];\n        return nullptr;\n    }\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CAL_BUFFER_SIZE 256\n#define CAL_CHANGE_SIZE 8\n#define CAL_HEADER_SIZE 16\n\nstatic uint8_t g_calibration_data_fixed[CAL_BUFFER_SIZE];\nstatic uint16_t g_current_cal_data_end_offset_fixed = CAL_HEADER_SIZE;\n\nvoid init_calibration_module_fixed() {\n    memset(g_calibration_data_fixed, 0xFF, CAL_BUFFER_SIZE);\n    g_calibration_data_fixed[0] = 0xAA;\n    g_calibration_data_fixed[1] = 0x55;\n    g_calibration_data_fixed[CAL_HEADER_SIZE - 1] = 0x01;\n    g_current_cal_data_end_offset_fixed = CAL_HEADER_SIZE;\n}\n\nbool append_calibration_record_fixed(const uint8_t* record, uint16_t len) {\n    if (len != CAL_CHANGE_SIZE) {\n        return false;\n    }\n    if (g_current_cal_data_end_offset_fixed + len > CAL_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_calibration_data_fixed + g_current_cal_data_end_offset_fixed, record, len);\n    g_current_cal_data_end_offset_fixed += len;\n    return true;\n}\n\nvoid revert_calibration_history_fixed(int16_t num_steps_to_revert) {\n    int32_t new_effective_end_offset_signed = (int32_t)g_current_cal_data_end_offset_fixed - (num_steps_to_revert * CAL_CHANGE_SIZE);\n\n    int32_t marker_target_idx = new_effective_end_offset_signed - 1;\n\n    if (marker_target_idx >= (int32_t)CAL_HEADER_SIZE) {\n        g_calibration_data_fixed[marker_target_idx] = 0x00;\n    }\n\n    if (new_effective_end_offset_signed < CAL_HEADER_SIZE) {\n        g_current_cal_data_end_offset_fixed = CAL_HEADER_SIZE;\n    } else if (new_effective_end_offset_signed > CAL_BUFFER_SIZE) {\n        g_current_cal_data_end_offset_fixed = CAL_BUFFER_SIZE;\n    } else {\n        g_current_cal_data_end_offset_fixed = (uint16_t)new_effective_end_offset_signed;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_FAULT_ENTRIES 64\n#define DTC_CODE_LEN 6 \n\ntypedef enum {\n    FAULT_STATUS_ACTIVE,\n    FAULT_STATUS_CLEARED,\n    FAULT_STATUS_HISTORY\n} FaultStatus;\n\ntypedef struct {\n    char dtc_code[DTC_CODE_LEN + 1]; \n    uint32_t timestamp;\n    uint8_t severity;\n    FaultStatus status;\n} FaultEntry;\n\nstatic FaultEntry g_fault_log[MAX_FAULT_ENTRIES];\nstatic int g_fault_count = 0; \nstatic int g_write_ptr = 0; \n\nvoid init_fault_log() {\n    for (int i = 0; i < MAX_FAULT_ENTRIES; ++i) {\n        memset(&g_fault_log[i], 0, sizeof(FaultEntry));\n        g_fault_log[i].status = FAULT_STATUS_CLEARED;\n    }\n    g_fault_count = 0;\n    g_write_ptr = 0;\n}\n\nvoid log_dtc(const char* dtc, uint32_t timestamp, uint8_t severity) {\n    strncpy(g_fault_log[g_write_ptr].dtc_code, dtc, DTC_CODE_LEN);\n    g_fault_log[g_write_ptr].dtc_code[DTC_CODE_LEN] = '\\0';\n    g_fault_log[g_write_ptr].timestamp = timestamp;\n    g_fault_log[g_write_ptr].severity = severity;\n    g_fault_log[g_write_ptr].status = FAULT_STATUS_ACTIVE;\n\n    g_write_ptr = (g_write_ptr + 1) % MAX_FAULT_ENTRIES;\n    if (g_fault_count < MAX_FAULT_ENTRIES) {\n        g_fault_count++;\n    }\n}\n\nvoid revert_last_faults_fixed(int num_to_revert) {\n    if (num_to_revert <= 0) {\n        return;\n    }\n\n    if (g_fault_count == 0) {\n        return;\n    }\n\n    int actual_num_to_revert = (num_to_revert > g_fault_count) ? g_fault_count : num_to_revert;\n\n    int start_clear_idx = (g_write_ptr - 1 + MAX_FAULT_ENTRIES) % MAX_FAULT_ENTRIES;\n\n    for (int i = 0; i < actual_num_to_revert; ++i) {\n        int target_idx_fixed = (start_clear_idx - i + MAX_FAULT_ENTRIES) % MAX_FAULT_ENTRIES;\n\n        g_fault_log[target_idx_fixed].status = FAULT_STATUS_CLEARED;\n        memset(g_fault_log[target_idx_fixed].dtc_code, 0, DTC_CODE_LEN + 1);\n        g_fault_log[target_idx_fixed].timestamp = 0;\n        g_fault_log[target_idx_fixed].severity = 0;\n    }\n\n    g_write_ptr = (g_write_ptr - actual_num_to_revert + MAX_FAULT_ENTRIES) % MAX_FAULT_ENTRIES;\n    g_fault_count -= actual_num_to_revert;\n    if (g_fault_count < 0) {\n        g_fault_count = 0;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_DTC_LOG_ENTRIES 32\n#define DTC_ID_LEN 8\n\ntypedef struct {\n    char dtc_id[DTC_ID_LEN + 1];\n    uint32_t timestamp_ms;\n    uint8_t severity_level; \n    bool active;\n    uint16_t associated_param_A;\n    uint16_t associated_param_B;\n} DiagnosticTroubleCodeEntry;\n\nstatic DiagnosticTroubleCodeEntry g_dtc_log_buffer_fixed[MAX_DTC_LOG_ENTRIES];\nstatic uint16_t g_next_write_idx_fixed = 0; \nstatic uint16_t g_num_logged_dtcs_fixed = 0;\n\nvoid init_dtc_logger_fixed() {\n    for (uint16_t i = 0; i < MAX_DTC_LOG_ENTRIES; ++i) {\n        memset(&g_dtc_log_buffer_fixed[i], 0, sizeof(DiagnosticTroubleCodeEntry));\n    }\n    g_next_write_idx_fixed = 0;\n    g_num_logged_dtcs_fixed = 0;\n}\n\nvoid log_dtc_entry_fixed(const char* id, uint32_t timestamp, uint8_t severity, uint16_t param_A, uint16_t param_B) {\n    strncpy(g_dtc_log_buffer_fixed[g_next_write_idx_fixed].dtc_id, id, DTC_ID_LEN);\n    g_dtc_log_buffer_fixed[g_next_write_idx_fixed].dtc_id[DTC_ID_LEN] = '\\0';\n    g_dtc_log_buffer_fixed[g_next_write_idx_fixed].timestamp_ms = timestamp;\n    g_dtc_log_buffer_fixed[g_next_write_idx_fixed].severity_level = severity;\n    g_dtc_log_buffer_fixed[g_next_write_idx_fixed].active = true;\n    g_dtc_log_buffer_fixed[g_next_write_idx_fixed].associated_param_A = param_A;\n    g_dtc_log_buffer_fixed[g_next_write_idx_fixed].associated_param_B = param_B;\n\n    g_next_write_idx_fixed = (g_next_write_idx_fixed + 1) % MAX_DTC_LOG_ENTRIES;\n    if (g_num_logged_dtcs_fixed < MAX_DTC_LOG_ENTRIES) {\n        g_num_logged_dtcs_fixed++;\n    }\n}\n\nvoid update_dtc_params_fixed(uint16_t offset_from_last, uint16_t new_param_A, uint16_t new_param_B) {\n    if (g_num_logged_dtcs_fixed == 0) {\n        return;\n    }\n\n    if (offset_from_last >= g_num_logged_dtcs_fixed) {\n        return;\n    }\n\n    uint16_t target_buffer_idx = (g_next_write_idx_fixed - (1 + offset_from_last) + MAX_DTC_LOG_ENTRIES * 2) % MAX_DTC_LOG_ENTRIES;\n\n    g_dtc_log_buffer_fixed[target_buffer_idx].associated_param_A = new_param_A;\n    g_dtc_log_buffer_fixed[target_buffer_idx].associated_param_B = new_param_B;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define NUM_VIRTUAL_ECUS 5\n#define MAX_PARAMS_PER_ECU_TYPE 100\n#define MAX_TOTAL_PARAMETERS 150\n\ntypedef struct {\n    uint32_t value;\n    uint8_t  status_flags;\n} FirmwareParameter;\n\nstatic FirmwareParameter g_firmwareParameterStorage_fixed[MAX_TOTAL_PARAMETERS];\nstatic uint16_t g_ecuStartOffset_fixed[NUM_VIRTUAL_ECUS];\nstatic uint16_t g_ecuParamCounts_fixed[NUM_VIRTUAL_ECUS];\n\nvoid diagnosticLog_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t  ecu_id;\n    uint16_t param_index;\n    uint32_t new_value;\n} ParameterUpdateCommand;\n\nParameterUpdateCommand receiveParameterUpdateCommand_fixed() {\n    ParameterUpdateCommand cmd;\n    cmd.ecu_id = 1;\n    cmd.param_index = 80;\n    cmd.new_value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeEcuParameters_fixed() {\n    g_ecuStartOffset_fixed[0] = 0;\n    g_ecuParamCounts_fixed[0] = 70;\n\n    g_ecuStartOffset_fixed[1] = 70;\n    g_ecuParamCounts_fixed[1] = 90;\n\n    g_ecuStartOffset_fixed[2] = 160;\n    g_ecuParamCounts_fixed[2] = 50;\n\n    g_ecuStartOffset_fixed[3] = 210;\n    g_ecuParamCounts_fixed[3] = 40;\n    \n    g_ecuStartOffset_fixed[4] = 250;\n    g_ecuParamCounts_fixed[4] = 30;\n\n    for (uint16_t i = 0; i < MAX_TOTAL_PARAMETERS; ++i) {\n        g_firmwareParameterStorage_fixed[i] = (FirmwareParameter){0, 0};\n    }\n    diagnosticLog_fixed(\"ECU parameters initialized (fixed).\");\n}\n\nvoid processParameterUpdate_fixed() {\n    ParameterUpdateCommand cmd = receiveParameterUpdateCommand_fixed();\n\n    if (cmd.ecu_id >= NUM_VIRTUAL_ECUS) {\n        diagnosticLog_fixed(\"Error: Invalid ECU ID in parameter update command.\");\n        return;\n    }\n\n    if (cmd.param_index >= g_ecuParamCounts_fixed[cmd.ecu_id]) {\n        diagnosticLog_fixed(\"Error: Parameter index out of bounds for specified ECU type (local range).\");\n        return;\n    }\n\n    uint16_t base_offset = g_ecuStartOffset_fixed[cmd.ecu_id];\n    uint16_t absolute_param_index = base_offset + cmd.param_index;\n\n    if (absolute_param_index < MAX_TOTAL_PARAMETERS) {\n        g_firmwareParameterStorage_fixed[absolute_param_index].value = cmd.new_value;\n        g_firmwareParameterStorage_fixed[absolute_param_index].status_flags = 0x01;\n        diagnosticLog_fixed(\"Firmware parameter updated successfully (fixed).\");\n    } else {\n        diagnosticLog_fixed(\"Error: Calculated parameter index exceeds total storage capacity.\");\n    }\n}\n\nvoid main_ecu_firmware_manager_fixed() {\n    initializeEcuParameters_fixed();\n    processParameterUpdate_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define MAX_SENSOR_DETECTIONS 100 \n\n#pragma pack(push, 1)\ntypedef struct {\n    int16_t x;\n    int16_t y;\n    int16_t z;\n    uint8_t confidence;\n} DetectionPoint;\n#pragma pack(pop)\n\ntypedef struct {\n    uint16_t frame_id;\n    uint8_t  sensor_id;\n    uint8_t  num_detection_points; \n    uint32_t timestamp;\n} SensorDataFrameHeader;\n\nstatic DetectionPoint g_processedDetections[MAX_SENSOR_DETECTIONS];\nstatic uint8_t g_currentDetectionCount = 0;\n\nvoid initDetectionBuffer() {\n    memset(g_processedDetections, 0, sizeof(g_processedDetections));\n    g_currentDetectionCount = 0;\n}\n\nint processSensorDataFrame(const uint8_t* raw_frame, uint16_t frame_len) {\n    if (raw_frame == NULL || frame_len < sizeof(SensorDataFrameHeader)) {\n        return -1;\n    }\n\n    const SensorDataFrameHeader* header = (const SensorDataFrameHeader*)raw_frame;\n\n    uint8_t num_points = header->num_detection_points;\n\n    if (num_points > MAX_SENSOR_DETECTIONS) {\n        return -3; \n    }\n    \n    const uint8_t* data_ptr = raw_frame + sizeof(SensorDataFrameHeader);\n    uint16_t current_data_offset = 0;\n\n    uint16_t expected_points_data_len = num_points * sizeof(DetectionPoint);\n    if (frame_len < (sizeof(SensorDataFrameHeader) + expected_points_data_len)) {\n        return -2; \n    }\n\n    for (uint8_t i = 0; i < num_points; ++i) {\n        g_processedDetections[i].x = (int16_t)((data_ptr[current_data_offset + 0] << 8) | data_ptr[current_data_offset + 1]);\n        g_processedDetections[i].y = (int16_t)((data_ptr[current_data_offset + 2] << 8) | data_ptr[current_data_offset + 3]);\n        g_processedDetections[i].z = (int16_t)((data_ptr[current_data_offset + 4] << 8) | data_ptr[current_data_offset + 5]);\n        g_processedDetections[i].confidence = data_ptr[current_data_offset + 6];\n        current_data_offset += sizeof(DetectionPoint);\n    }\n\n    g_currentDetectionCount = num_points;\n    return 0;\n}\n\nvoid simulateReceiveSensorFrame(const uint8_t* frame, uint16_t len) {\n    processSensorDataFrame(frame, len);\n}\n\nDetectionPoint* getProcessedDetection(uint8_t index) {\n    if (index < g_currentDetectionCount) {\n        return &g_processedDetections[index];\n    }\n    return NULL;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_ENGINE_CALIBRATION_POINTS 100\n#define MAX_PAYLOAD_FOR_CALIBRATION 512\n\ntypedef struct {\n    uint16_t rpm_target;\n    uint16_t fuel_injection_pulse;\n} EngineCalibrationPoint;\n\nstatic EngineCalibrationPoint g_engineCalibrationTable[MAX_ENGINE_CALIBRATION_POINTS];\n\nvoid initEngineCalibration() {\n    memset(g_engineCalibrationTable, 0, sizeof(g_engineCalibrationTable));\n    for (int i = 0; i < MAX_ENGINE_CALIBRATION_POINTS; ++i) {\n        g_engineCalibrationTable[i].rpm_target = 800 + i * 10;\n        g_engineCalibrationTable[i].fuel_injection_pulse = 100 + i * 2;\n    }\n}\n\nint updateEngineCalibration(const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len < 4) {\n        return -1;\n    }\n\n    uint16_t start_index = (payload[0] << 8) | payload[1];\n    uint16_t num_points = (payload[2] << 8) | payload[3];\n\n    uint16_t data_offset = 4;\n    uint16_t expected_data_len = num_points * sizeof(EngineCalibrationPoint);\n\n    if (data_offset + expected_data_len > payload_len) {\n        return -2;\n    }\n    \n    if (start_index >= MAX_ENGINE_CALIBRATION_POINTS || (num_points > 0 && (uint32_t)start_index + num_points > MAX_ENGINE_CALIBRATION_POINTS)) {\n        return -3;\n    }\n\n    for (uint16_t i = 0; i < num_points; ++i) {\n        uint16_t current_data_ptr_offset = data_offset + (i * sizeof(EngineCalibrationPoint));\n        \n        g_engineCalibrationTable[start_index + i].rpm_target = \n            (payload[current_data_ptr_offset] << 8) | payload[current_data_ptr_offset + 1];\n        g_engineCalibrationTable[start_index + i].fuel_injection_pulse = \n            (payload[current_data_ptr_offset + 2] << 8) | payload[current_data_ptr_offset + 3];\n    }\n\n    return 0;\n}\n\nvoid simulateCanMessage(const uint8_t* data, uint16_t len) {\n    updateEngineCalibration(data, len);\n}\n\nEngineCalibrationPoint getCalibrationPoint(uint16_t index) {\n    if (index < MAX_ENGINE_CALIBRATION_POINTS) {\n        return g_engineCalibrationTable[index];\n    }\n    EngineCalibrationPoint invalid = {0,0};\n    return invalid;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOG_MESSAGE_SIZE 256 // Maximum size of an incoming diagnostic log message\n#define INTERNAL_RECORD_BUFFER_SIZE 64 // Fixed-size buffer for a single log record entry\n\n// A simplified log record structure stored internally\ntypedef struct {\n    uint8_t type;\n    uint8_t length; // Actual length of 'data' copied\n    uint8_t data[INTERNAL_RECORD_BUFFER_SIZE];\n} DiagnosticLogRecord;\n\n// Global instance of the current log record being processed/stored\nstatic DiagnosticLogRecord currentLogRecord;\n\n// Initializes the log record buffer with zeros\nvoid initDiagnosticLogRecord() {\n    memset(&currentLogRecord, 0, sizeof(DiagnosticLogRecord));\n}\n\n// Function to process an incoming diagnostic message and store relevant part\n// This function is vulnerable to buffer overflow if 'data_length' from the message\n// is greater than INTERNAL_RECORD_BUFFER_SIZE.\nint processDiagnosticMessage(const uint8_t* message_data, uint16_t message_len) {\n    if (message_data == NULL || message_len < 2) { // Requires at least tag and length\n        return -1; // Invalid input message\n    }\n\n    uint16_t current_offset = 0;\n\n    // Assume message_data format: [tag (1 byte)][length (1 byte)][data (length bytes)]\n    uint8_t data_tag = message_data[current_offset];\n    current_offset++;\n    uint8_t data_length = message_data[current_offset]; // Length of the data payload\n    current_offset++;\n\n    // Check if the declared data_length fits within the remainder of the incoming message\n    // This check is correctly performed against the source message length.\n    if (current_offset + data_length > message_len) {\n        return -2; // Malformed message: declared length exceeds actual message bounds\n    }\n\n    const uint8_t* source_data_ptr = message_data + current_offset;\n\n    // Store the processed data into the internal log record structure.\n    // The 'data_length' can be up to 254 bytes (MAX_LOG_MESSAGE_SIZE - 2), \n    // which is much larger than INTERNAL_RECORD_BUFFER_SIZE (64 bytes).\n    currentLogRecord.type = data_tag;\n    currentLogRecord.length = data_length; // This 'length' might be > INTERNAL_RECORD_BUFFER_SIZE\n\n    // VULNERABILITY: The loop iterates 'data_length' times, potentially writing\n    // past the end of 'currentLogRecord.data' array (size INTERNAL_RECORD_BUFFER_SIZE).\n    for (uint8_t i = 0; i < data_length; ++i) {\n        currentLogRecord.data[i] = source_data_ptr[i];\n    }\n\n    return 0;\n}\n\n// Public interface to simulate receiving a diagnostic message\nvoid receiveDiagnosticData(const uint8_t* data, uint16_t len) {\n    initDiagnosticLogRecord();\n    processDiagnosticMessage(data, len);\n}\n\n// Helper function to get a byte from the stored log record data\nuint8_t getLogRecordByte(uint8_t index) {\n    if (index < INTERNAL_RECORD_BUFFER_SIZE) {\n        return currentLogRecord.data[index];\n    }\n    return 0xFF; // Indicate out of bounds read or invalid index\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOG_MESSAGE_SIZE 256 // Maximum size of an incoming diagnostic log message\n#define INTERNAL_RECORD_BUFFER_SIZE 64 // Fixed-size buffer for a single log record entry\n\n// A simplified log record structure stored internally\ntypedef struct {\n    uint8_t type;\n    uint8_t length; // Actual length of 'data' copied\n    uint8_t data[INTERNAL_RECORD_BUFFER_SIZE];\n} DiagnosticLogRecord;\n\n// Global instance of the current log record being processed/stored\nstatic DiagnosticLogRecord currentLogRecord;\n\n// Initializes the log record buffer with zeros\nvoid initDiagnosticLogRecord() {\n    memset(&currentLogRecord, 0, sizeof(DiagnosticLogRecord));\n}\n\n// Function to process an incoming diagnostic message and store relevant part\n// This function is now fixed against buffer overflow by limiting the copy length.\nint processDiagnosticMessage(const uint8_t* message_data, uint16_t message_len) {\n    if (message_data == NULL || message_len < 2) { // Requires at least tag and length\n        return -1; // Invalid input message\n    }\n\n    uint16_t current_offset = 0;\n\n    // Assume message_data format: [tag (1 byte)][length (1 byte)][data (length bytes)]\n    uint8_t data_tag = message_data[current_offset];\n    current_offset++;\n    uint8_t data_length = message_data[current_offset]; // Length of the data payload\n    current_offset++;\n\n    // Check if the declared data_length fits within the remainder of the incoming message\n    if (current_offset + data_length > message_len) {\n        return -2; // Malformed message: declared length exceeds actual message bounds\n    }\n\n    const uint8_t* source_data_ptr = message_data + current_offset;\n\n    // Determine the actual number of bytes to copy to prevent overflow\n    uint8_t bytes_to_copy = data_length;\n    if (bytes_to_copy > INTERNAL_RECORD_BUFFER_SIZE) {\n        bytes_to_copy = INTERNAL_RECORD_BUFFER_SIZE; // Truncate if incoming data is too large\n    }\n\n    // Store the processed data into the internal log record structure.\n    currentLogRecord.type = data_tag;\n    // The 'length' field should reflect the actual data copied, not the requested length.\n    currentLogRecord.length = bytes_to_copy;\n\n    // FIXED: The loop now uses 'bytes_to_copy' which is bounded by INTERNAL_RECORD_BUFFER_SIZE.\n    for (uint8_t i = 0; i < bytes_to_copy; ++i) {\n        currentLogRecord.data[i] = source_data_ptr[i];\n    }\n\n    // It might be necessary to pad the rest of the buffer with zeros if partial data is copied,\n    // but for simplicity, we only focus on preventing the overflow here.\n\n    return 0;\n}\n\n// Public interface to simulate receiving a diagnostic message\nvoid receiveDiagnosticData(const uint8_t* data, uint16_t len) {\n    initDiagnosticLogRecord();\n    processDiagnosticMessage(data, len);\n}\n\n// Helper function to get a byte from the stored log record data\nuint8_t getLogRecordByte(uint8_t index) {\n    if (index < INTERNAL_RECORD_BUFFER_SIZE) {\n        return currentLogRecord.data[index];\n    }\n    return 0xFF; // Indicate out of bounds read or invalid index\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_DRIVING_PROFILES 3\n#define MAX_PARAMS_PER_PROFILE 10\n\ntypedef struct {\n    uint16_t value;\n    uint8_t type;\n} ProfileParameter;\n\ntypedef struct {\n    ProfileParameter params[MAX_PARAMS_PER_PROFILE];\n    uint8_t active_param_count;\n} DrivingProfile;\n\nstatic DrivingProfile g_drivingProfiles[MAX_DRIVING_PROFILES];\n\nvoid logSystemEvent(const char* message) {\n}\n\ntypedef struct {\n    uint8_t profile_idx;\n    uint8_t parameter_idx;\n    uint16_t new_param_value;\n} DiagnosticMessage;\n\nvoid initializeDrivingProfiles_vulnerable() {\n    g_drivingProfiles[0].active_param_count = 5;\n    for (int i = 0; i < g_drivingProfiles[0].active_param_count; ++i) {\n        g_drivingProfiles[0].params[i].value = 100 + i;\n        g_drivingProfiles[0].params[i].type = i % 2;\n    }\n\n    g_drivingProfiles[1].active_param_count = 8;\n    for (int i = 0; i < g_drivingProfiles[1].active_param_count; ++i) {\n        g_drivingProfiles[1].params[i].value = 200 + i;\n        g_drivingProfiles[1].params[i].type = i % 2;\n    }\n\n    g_drivingProfiles[2].active_param_count = 3;\n    for (int i = 0; i < g_drivingProfiles[2].active_param_count; ++i) {\n        g_drivingProfiles[2].params[i].value = 300 + i;\n        g_drivingProfiles[2].params[i].type = i % 2;\n    }\n\n    for (int p = 0; p < MAX_DRIVING_PROFILES; ++p) {\n        for (int i = g_drivingProfiles[p].active_param_count; i < MAX_PARAMS_PER_PROFILE; ++i) {\n            g_drivingProfiles[p].params[i].value = 0;\n            g_drivingProfiles[p].params[i].type = 0;\n        }\n    }\n    logSystemEvent(\"Driving profiles initialized (vulnerable).\");\n}\n\nDiagnosticMessage receiveDiagnosticMessage_vulnerable() {\n    DiagnosticMessage msg;\n    msg.profile_idx = 1;\n    msg.parameter_idx = 8;\n    msg.new_param_value = 0xABCD;\n    return msg;\n}\n\nvoid updateProfileParameter_vulnerable() {\n    DiagnosticMessage msg = receiveDiagnosticMessage_vulnerable();\n\n    if (msg.profile_idx < MAX_DRIVING_PROFILES) {\n        if (msg.parameter_idx < MAX_PARAMS_PER_PROFILE) {\n            g_drivingProfiles[msg.profile_idx].params[msg.parameter_idx].value = msg.new_param_value;\n            logSystemEvent(\"Profile parameter updated (vulnerable).\");\n        } else {\n            logSystemEvent(\"Invalid parameter index received (vulnerable).\");\n        }\n    } else {\n        logSystemEvent(\"Invalid profile index received (vulnerable).\");\n    }\n}\n\nvoid automotiveProfileManager_vulnerable_main() {\n    initializeDrivingProfiles_vulnerable();\n    updateProfileParameter_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <algorithm>\n\ntypedef struct {\n    uint32_t config_id;\n    uint32_t data_length;\n} ConfigBlockHeader;\n\nclass VehicleConfigUpdater {\npublic:\n    VehicleConfigUpdater() : current_config_data(nullptr), current_config_size(0) {}\n\n    ~VehicleConfigUpdater() {\n        if (current_config_data) {\n            delete[] current_config_data;\n            current_config_data = nullptr;\n        }\n    }\n\n    const uint8_t* getCurrentConfigData() const {\n        return current_config_data;\n    }\n\n    uint32_t getCurrentConfigSize() const {\n        return current_config_size;\n    }\n\n    bool processConfigBlockFixed(const uint8_t* block_data, size_t block_len) {\n        if (!block_data || block_len < sizeof(ConfigBlockHeader)) {\n            return false;\n        }\n\n        const ConfigBlockHeader* header = reinterpret_cast<const ConfigBlockHeader*>(block_data);\n        uint32_t advertised_data_len = header->data_length;\n\n        size_t actual_payload_bytes_in_block = block_len - sizeof(ConfigBlockHeader);\n\n        static const uint32_t MAX_ALLOWED_CONFIG_DATA_SIZE = 4096;\n        if (advertised_data_len > MAX_ALLOWED_CONFIG_DATA_SIZE) {\n            return false;\n        }\n\n        size_t bytes_to_copy = std::min((size_t)advertised_data_len, actual_payload_bytes_in_block);\n\n        uint8_t* temp_buffer = new (std::nothrow) uint8_t[advertised_data_len];\n        if (!temp_buffer) {\n            return false;\n        }\n\n        for (size_t i = 0; i < bytes_to_copy; ++i) {\n            temp_buffer[i] = block_data[sizeof(ConfigBlockHeader) + i];\n        }\n\n        if (current_config_data) {\n            delete[] current_config_data;\n        }\n\n        current_config_data = temp_buffer;\n        current_config_size = advertised_data_len;\n\n        return true;\n    }\n\nprivate:\n    uint8_t* current_config_data;\n    uint32_t current_config_size;\n};\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_CAN_DATA_ELEMENTS 100\n#define MAX_ITEM_TYPES 5\n\ntypedef struct {\n    uint32_t value;\n    uint8_t status;\n} DataElement;\n\nstatic DataElement g_configDataElements_vulnerable[MAX_CAN_DATA_ELEMENTS];\n\ntypedef struct {\n    uint8_t start_idx;\n    uint8_t num_elements;\n} ItemMapping;\n\nstatic const ItemMapping g_itemMaps_vulnerable[MAX_ITEM_TYPES] = {\n    {0, 10}, \n    {10, 20}, \n    {30, 5},  \n    {35, 15}, \n    {50, 50}  \n};\n\ntypedef struct {\n    uint8_t item_type_id;  \n    uint8_t item_offset;   \n    uint32_t new_value;\n} CANConfigCommand_vulnerable;\n\nvoid log_automotive_security_event_vulnerable(const char* msg) {\n}\n\nCANConfigCommand_vulnerable receive_can_config_command_vulnerable() {\n    CANConfigCommand_vulnerable cmd;\n    cmd.item_type_id = 1; \n    cmd.item_offset = 20; \n    cmd.new_value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initialize_config_data_vulnerable() {\n    for (uint16_t i = 0; i < MAX_CAN_DATA_ELEMENTS; ++i) {\n        g_configDataElements_vulnerable[i] = (DataElement){0, 0};\n    }\n    \n    g_configDataElements_vulnerable[30].value = 0x11223344;\n    g_configDataElements_vulnerable[30].status = 0xA5;\n}\n\nvoid process_can_config_update_vulnerable() {\n    CANConfigCommand_vulnerable cmd = receive_can_config_command_vulnerable();\n\n    if (cmd.item_type_id < MAX_ITEM_TYPES) {\n        uint8_t base_index = g_itemMaps_vulnerable[cmd.item_type_id].start_idx;\n        uint8_t global_index = base_index + cmd.item_offset;\n\n        if (global_index < MAX_CAN_DATA_ELEMENTS) {\n            g_configDataElements_vulnerable[global_index].value = cmd.new_value;\n            g_configDataElements_vulnerable[global_index].status = 1;\n        } else {\n            log_automotive_security_event_vulnerable(\"CAN config update: Calculated global index out of overall array bounds.\");\n        }\n    } else {\n        log_automotive_security_event_vulnerable(\"CAN config update: Invalid item type ID received.\");\n    }\n}\n\nvoid automotive_system_main_vulnerable() {\n    initialize_config_data_vulnerable();\n    process_can_config_update_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_SUBSYSTEMS 5\n#define MAX_COMMANDS_PER_SUBSYSTEM 10\n#define MAX_PAYLOAD_SIZE 8\n\nvoid logSystemEvent(const char* event_msg) {\n}\n\nvoid logSecurityAlert(const char* alert_msg) {\n}\n\nvoid handleEngineCommand1(const uint8_t* data, uint32_t len) {\n    logSystemEvent(\"EngineCmd1: Processing engine status request.\");\n}\n\nvoid handleEngineCommand2(const uint8_t* data, uint32_t len) {\n    logSystemEvent(\"EngineCmd2: Adjusting ignition timing.\");\n}\n\nvoid handleBrakeCommand1(const uint8_t* data, uint32_t len) {\n    logSystemEvent(\"BrakeCmd1: Calibrating ABS sensors.\");\n}\n\nvoid handleBrakeCommand2(const uint8_t* data, uint32_t len) {\n    logSystemEvent(\"BrakeCmd2: Activating emergency braking.\");\n}\n\nvoid handleInvalidCommand(const uint8_t* data, uint32_t len) {\n    logSecurityAlert(\"Invalid/Unsupported command handler invoked.\");\n}\n\ntypedef void (*CommandHandler)(const uint8_t*, uint32_t);\n\nstatic CommandHandler g_subsystemCommandHandlers_fixed[MAX_SUBSYSTEMS][MAX_COMMANDS_PER_SUBSYSTEM];\nstatic uint8_t g_actualCommandsPerSubsystem_fixed[MAX_SUBSYSTEMS];\n\ntypedef struct {\n    uint8_t subsystem_id;\n    uint8_t command_id;\n    uint32_t data_len;\n    uint8_t payload[MAX_PAYLOAD_SIZE];\n} IncomingVehicleCommand;\n\nIncomingVehicleCommand receiveIncomingCommand_Fixed() {\n    IncomingVehicleCommand cmd;\n    cmd.subsystem_id = 0;\n    cmd.command_id = 5;\n    cmd.data_len = 2;\n    cmd.payload[0] = 0xAA;\n    cmd.payload[1] = 0xBB;\n    return cmd;\n}\n\nvoid initializeCommandHandlers_Fixed() {\n    for (uint8_t i = 0; i < MAX_SUBSYSTEMS; ++i) {\n        g_actualCommandsPerSubsystem_fixed[i] = 0;\n        for (uint8_t j = 0; j < MAX_COMMANDS_PER_SUBSYSTEM; ++j) {\n            g_subsystemCommandHandlers_fixed[i][j] = handleInvalidCommand;\n        }\n    }\n\n    g_subsystemCommandHandlers_fixed[0][0] = handleEngineCommand1;\n    g_subsystemCommandHandlers_fixed[0][1] = handleEngineCommand2;\n    g_actualCommandsPerSubsystem_fixed[0] = 2;\n\n    g_subsystemCommandHandlers_fixed[1][0] = handleBrakeCommand1;\n    g_subsystemCommandHandlers_fixed[1][1] = handleBrakeCommand2;\n    g_actualCommandsPerSubsystem_fixed[1] = 2;\n}\n\nvoid processVehicleCommand_Fixed() {\n    IncomingVehicleCommand cmd = receiveIncomingCommand_Fixed();\n\n    if (cmd.subsystem_id < MAX_SUBSYSTEMS) {\n        if (cmd.command_id < g_actualCommandsPerSubsystem_fixed[cmd.subsystem_id]) {\n            CommandHandler handler = g_subsystemCommandHandlers_fixed[cmd.subsystem_id][cmd.command_id];\n            handler(cmd.payload, cmd.data_len);\n        } else {\n            logSecurityAlert(\"Attempted to invoke unregistered command for subsystem.\");\n            handleInvalidCommand(cmd.payload, cmd.data_len);\n        }\n    } else {\n        logSystemEvent(\"Subsystem ID out of bounds.\");\n        handleInvalidCommand(cmd.payload, cmd.data_len);\n    }\n}\n\nvoid automotiveECULoop_Fixed() {\n    initializeCommandHandlers_Fixed();\n    logSystemEvent(\"Fixed ECU started.\");\n    processVehicleCommand_Fixed();\n    logSystemEvent(\"Fixed ECU finished processing command.\");\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <limits>\n\nstruct ConfigEntryHeader {\n    uint16_t key_hash;\n    uint16_t value_length; \n};\n\nclass VehicleConfigStoreFixed {\npublic:\n    VehicleConfigStoreFixed(size_t initial_capacity_bytes)\n        : m_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {\n        if (initial_capacity_bytes > 0) {\n            m_buffer = (uint8_t*)malloc(initial_capacity_bytes);\n            if (m_buffer) {\n                m_allocated_capacity = initial_capacity_bytes;\n            }\n        }\n    }\n\n    ~VehicleConfigStoreFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    bool addConfigEntryFixed(uint16_t key_hash, const uint8_t* value_data, uint16_t len) {\n        if (!value_data || len == 0) {\n            return false;\n        }\n\n        size_t entry_data_size_needed = sizeof(ConfigEntryHeader) + len + 1; \n\n        if (sizeof(ConfigEntryHeader) > std::numeric_limits<size_t>::max() - (len + 1)) {\n            return false;\n        }\n\n        if (m_current_size > std::numeric_limits<size_t>::max() - entry_data_size_needed) {\n            return false;\n        }\n        \n        if (m_current_size + entry_data_size_needed > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity == 0 ? entry_data_size_needed : m_allocated_capacity * 2;\n\n            if (m_allocated_capacity > (std::numeric_limits<size_t>::max() / 2) && m_allocated_capacity != 0) {\n                 new_capacity = std::numeric_limits<size_t>::max();\n            }\n            if (new_capacity < m_current_size + entry_data_size_needed) {\n                new_capacity = m_current_size + entry_data_size_needed;\n            }\n            \n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_capacity);\n            if (!new_buffer) {\n                if (m_buffer) free(m_buffer);\n                m_buffer = nullptr;\n                m_current_size = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        if (!m_buffer) {\n            return false;\n        }\n\n        ConfigEntryHeader header = {key_hash, len};\n        memcpy(m_buffer + m_current_size, &header, sizeof(ConfigEntryHeader));\n        \n        memcpy(m_buffer + m_current_size + sizeof(ConfigEntryHeader), value_data, len);\n\n        m_buffer[m_current_size + sizeof(ConfigEntryHeader) + len] = '\\0';\n\n        m_current_size += entry_data_size_needed; \n\n        return true;\n    }\n\n    const uint8_t* getRawBuffer() const { return m_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <string.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n#define CAN_PAYLOAD_MAX_SUPPORTED 256\n#define DIAG_PROCESSING_BUFFER_SIZE 128\n\ntypedef struct {\n    uint32_t arbitrationId;\n    uint8_t  dlc;\n    uint8_t  data[CAN_PAYLOAD_MAX_SUPPORTED];\n} CanRxFrame;\n\ntypedef struct {\n    uint8_t currentServiceId;\n    uint8_t diagnosticDataBuffer[DIAG_PROCESSING_BUFFER_SIZE];\n    uint16_t dataReceivedLength;\n    bool processingActive;\n} DiagnosticHandlerContext;\n\nstatic DiagnosticHandlerContext g_diagContext = {0};\n\nvoid initDiagnosticHandler(void) {\n    memset(&g_diagContext, 0, sizeof(DiagnosticHandlerContext));\n    g_diagContext.processingActive = false;\n}\n\nint handleIncomingDiagnosticMessage(const CanRxFrame* frame) {\n    if (frame == NULL || frame->dlc == 0) {\n        return -1;\n    }\n\n    uint16_t bytesToCopy = frame->dlc;\n    if (bytesToCopy > DIAG_PROCESSING_BUFFER_SIZE) {\n        bytesToCopy = DIAG_PROCESSING_BUFFER_SIZE;\n    }\n\n    memcpy(g_diagContext.diagnosticDataBuffer, frame->data, bytesToCopy);\n\n    g_diagContext.dataReceivedLength = bytesToCopy;\n    g_diagContext.processingActive = true;\n    g_diagContext.currentServiceId = g_diagContext.diagnosticDataBuffer[0];\n\n    if (g_diagContext.currentServiceId == 0x22) {\n        // Process data identifier request\n    } else if (g_diagContext.currentServiceId == 0x2E) {\n        // Process write request\n    }\n\n    return 0;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n#include <limits>\n\nstruct DTC_Entry {\n    uint32_t code;\n    uint16_t status_flags;\n    uint8_t  occurrence_count;\n    char     reserved[5];\n};\n\nstruct DiagnosticPacketHeader {\n    uint16_t packet_id;\n    uint16_t num_dtc_entries;\n    uint32_t payload_data_bytes;\n};\n\nclass VehicleDiagnosticLoggerFixed {\npublic:\n    VehicleDiagnosticLoggerFixed() : m_dtc_buffer(nullptr), m_buffer_capacity(0), m_actual_dtc_count(0) {}\n\n    ~VehicleDiagnosticLoggerFixed() {\n        if (m_dtc_buffer) {\n            delete[] m_dtc_buffer;\n            m_dtc_buffer = nullptr;\n        }\n    }\n\n    bool processDiagnosticPacketFixed(const uint8_t* raw_packet_data, size_t packet_data_len) {\n        if (!raw_packet_data || packet_data_len < sizeof(DiagnosticPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeader* header = reinterpret_cast<const DiagnosticPacketHeader*>(raw_packet_data);\n\n        size_t expected_payload_from_num_entries;\n        if (header->num_dtc_entries > (std::numeric_limits<size_t>::max() / sizeof(DTC_Entry))) {\n            return false;\n        }\n        expected_payload_from_num_entries = (size_t)header->num_dtc_entries * sizeof(DTC_Entry);\n\n        if (header->payload_data_bytes != expected_payload_from_num_entries ||\n            packet_data_len < sizeof(DiagnosticPacketHeader) + header->payload_data_bytes) {\n            return false;\n        }\n        \n        if (m_dtc_buffer) {\n            delete[] m_dtc_buffer;\n            m_dtc_buffer = nullptr;\n            m_buffer_capacity = 0;\n            m_actual_dtc_count = 0;\n        }\n\n        m_buffer_capacity = header->num_dtc_entries;\n        if (m_buffer_capacity == 0) {\n            return true;\n        }\n\n        m_dtc_buffer = new (std::nothrow) DTC_Entry[m_buffer_capacity];\n        if (!m_dtc_buffer) {\n            return false;\n        }\n\n        const uint8_t* current_payload_ptr = raw_packet_data + sizeof(DiagnosticPacketHeader);\n        \n        for (uint16_t i = 0; i < m_buffer_capacity; ++i) {\n            if ((size_t)i * sizeof(DTC_Entry) + sizeof(DTC_Entry) > header->payload_data_bytes) {\n                delete[] m_dtc_buffer;\n                m_dtc_buffer = nullptr;\n                m_buffer_capacity = 0;\n                m_actual_dtc_count = 0;\n                return false;\n            }\n\n            const DTC_Entry* incoming_dtc = reinterpret_cast<const DTC_Entry*>(current_payload_ptr + (size_t)i * sizeof(DTC_Entry));\n            \n            m_dtc_buffer[i].code = incoming_dtc->code;\n            m_dtc_buffer[i].status_flags = incoming_dtc->status_flags;\n            m_dtc_buffer[i].occurrence_count = incoming_dtc->occurrence_count;\n            std::memcpy(m_dtc_buffer[i].reserved, incoming_dtc->reserved, sizeof(incoming_dtc->reserved));\n        }\n\n        m_actual_dtc_count = m_buffer_capacity;\n        return true;\n    }\n\n    const DTC_Entry* getDTCBuffer() const { return m_dtc_buffer; }\n    uint16_t getBufferCapacity() const { return m_buffer_capacity; }\n    uint16_t getActualDTCCount() const { return m_actual_dtc_count; }\n\nprivate:\n    DTC_Entry* m_dtc_buffer;\n    uint16_t   m_buffer_capacity;\n    uint16_t   m_actual_dtc_count;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DATA_LOG_BUFFER_SIZE 256\n#define MAX_LOG_ENTRY_PAYLOAD_SIZE 60\n\ntypedef struct {\n    uint8_t  type;\n    uint8_t  payload_len;\n} LogEntryHeader;\n\nstatic uint8_t g_logBuffer[DATA_LOG_BUFFER_SIZE];\nstatic uint16_t g_logBufferWriteHead = 0;\n\nvoid initDataLogger() {\n    memset(g_logBuffer, 0, DATA_LOG_BUFFER_SIZE);\n    g_logBufferWriteHead = 0;\n}\n\nint addLogEntry(uint8_t type, const uint8_t* payload_data, uint8_t payload_len) {\n    if (payload_data == NULL) {\n        return -1;\n    }\n\n    if (payload_len > MAX_LOG_ENTRY_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    uint16_t required_total_entry_size = sizeof(LogEntryHeader) + payload_len;\n\n    if (required_total_entry_size > DATA_LOG_BUFFER_SIZE) {\n        return -3;\n    }\n    \n    LogEntryHeader header = { .type = type, .payload_len = payload_len };\n\n    uint16_t current_write_pos = g_logBufferWriteHead;\n    uint16_t bytes_to_copy_this_segment;\n\n    // Write Header - handle potential wrap-around\n    bytes_to_copy_this_segment = sizeof(LogEntryHeader);\n    if (current_write_pos + bytes_to_copy_this_segment > DATA_LOG_BUFFER_SIZE) {\n        uint16_t first_part_len = DATA_LOG_BUFFER_SIZE - current_write_pos;\n        memcpy(g_logBuffer + current_write_pos, &header, first_part_len);\n        memcpy(g_logBuffer, (uint8_t*)&header + first_part_len, bytes_to_copy_this_segment - first_part_len);\n    } else {\n        memcpy(g_logBuffer + current_write_pos, &header, bytes_to_copy_this_segment);\n    }\n    current_write_pos = (current_write_pos + bytes_to_copy_this_segment) % DATA_LOG_BUFFER_SIZE;\n\n    // Write Payload - handle potential wrap-around\n    bytes_to_copy_this_segment = payload_len;\n    if (current_write_pos + bytes_to_copy_this_segment > DATA_LOG_BUFFER_SIZE) {\n        uint16_t first_part_len = DATA_LOG_BUFFER_SIZE - current_write_pos;\n        memcpy(g_logBuffer + current_write_pos, payload_data, first_part_len);\n        memcpy(g_logBuffer, payload_data + first_part_len, bytes_to_copy_this_segment - first_part_len);\n    } else {\n        memcpy(g_logBuffer + current_write_pos, payload_data, bytes_to_copy_this_segment);\n    }\n\n    // Update global write head for the next entry\n    g_logBufferWriteHead = (g_logBufferWriteHead + required_total_entry_size) % DATA_LOG_BUFFER_SIZE;\n\n    return 0;\n}\n\n// Dummy function to simulate usage in a larger context (e.g., error handling)\nvoid simulateSensorDTCLog(uint8_t dtc_code, const uint8_t* dtc_data, uint8_t data_len) {\n    addLogEntry(dtc_code, dtc_data, data_len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CAN_DIAG_BUFFER_SIZE_FIXED 256\n#define CAN_MSG_HEADER_SIZE_FIXED  4\n#define MIN_MSG_PAYLOAD_SIZE_FIXED 1\n#define MAX_MSG_PAYLOAD_SIZE_FIXED (CAN_DIAG_BUFFER_SIZE_FIXED - CAN_MSG_HEADER_SIZE_FIXED)\n\ntypedef struct {\n    uint16_t message_id;\n    uint8_t  payload_len;\n    uint8_t  control_byte;\n    uint8_t  payload_data[MAX_MSG_PAYLOAD_SIZE_FIXED];\n} CAN_DiagMessage_Fixed;\n\nstatic uint8_t g_diag_raw_buffer_fixed[CAN_DIAG_BUFFER_SIZE_FIXED];\nstatic int32_t g_current_buffer_offset_fixed = 0;\nstatic uint32_t g_data_in_buffer_fixed = 0;\n\nvoid init_diag_buffer_fixed() {\n    memset(g_diag_raw_buffer_fixed, 0, CAN_DIAG_BUFFER_SIZE_FIXED);\n    g_current_buffer_offset_fixed = 0;\n    g_data_in_buffer_fixed = 0;\n}\n\nbool append_diag_data_fixed(const uint8_t* data, uint16_t len) {\n    if (g_data_in_buffer_fixed + len > CAN_DIAG_BUFFER_SIZE_FIXED) {\n        return false;\n    }\n    memcpy(g_diag_raw_buffer_fixed + g_data_in_buffer_fixed, data, len);\n    g_data_in_buffer_fixed += len;\n    return true;\n}\n\nvoid process_complete_diag_message_fixed(const CAN_DiagMessage_Fixed* msg) {\n    volatile uint16_t id = msg->message_id;\n    (void)id;\n}\n\nvoid mark_message_pre_header_fixed(uint8_t marker_byte) {\n    if (g_current_buffer_offset_fixed > 0) {\n        g_diag_raw_buffer_fixed[g_current_buffer_offset_fixed - 1] = marker_byte;\n    } else {\n        return;\n    }\n    \n    if (g_current_buffer_offset_fixed < g_data_in_buffer_fixed) {\n        CAN_DiagMessage_Fixed* current_msg = (CAN_DiagMessage_Fixed*)(g_diag_raw_buffer_fixed + g_current_buffer_offset_fixed);\n        process_complete_diag_message_fixed(current_msg);\n    }\n}\n\nvoid advance_buffer_offset_fixed(uint16_t bytes_consumed) {\n    if (g_current_buffer_offset_fixed + bytes_consumed <= g_data_in_buffer_fixed) {\n        g_current_buffer_offset_fixed += bytes_consumed;\n    } else {\n        g_current_buffer_offset_fixed = g_data_in_buffer_fixed;\n    }\n    if (g_current_buffer_offset_fixed == g_data_in_buffer_fixed) {\n        g_current_buffer_offset_fixed = 0;\n        g_data_in_buffer_fixed = 0;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_ROUTABLE_NODES 10\n#define MESSAGE_PAYLOAD_SIZE 8\n\ntypedef struct {\n    uint8_t destination_node_id;\n    uint8_t source_node_id;\n    uint8_t payload[MESSAGE_PAYLOAD_SIZE];\n    uint8_t payload_len;\n} NetworkMessage;\n\nvoid handleNode0Message(const uint8_t* data, uint8_t len) {}\nvoid handleNode1Message(const uint8_t* data, uint8_t len) {}\nvoid handleNode2Message(const uint8_t* data, uint8_t len) {}\nvoid handleDefaultMessage(const uint8_t* data, uint8_t len) {}\n\ntypedef void (*NodeMessageHandler)(const uint8_t* data, uint8_t len);\n\nvoid logGatewayEvent(const char* msg) {}\nvoid logGatewayError(const char* msg) {}\n\nstatic NodeMessageHandler g_nodeHandlers_vulnerable[MAX_ROUTABLE_NODES];\n\nNetworkMessage receiveNetworkMessage_vulnerable() {\n    NetworkMessage msg;\n    msg.destination_node_id = MAX_ROUTABLE_NODES;\n    msg.source_node_id = 0x01;\n    msg.payload[0] = 0xDE;\n    msg.payload_len = 1;\n    return msg;\n}\n\nvoid initializeGatewayHandlers_vulnerable() {\n    for (int i = 0; i < MAX_ROUTABLE_NODES; ++i) {\n        g_nodeHandlers_vulnerable[i] = handleDefaultMessage;\n    }\n    g_nodeHandlers_vulnerable[0] = handleNode0Message;\n    g_nodeHandlers_vulnerable[1] = handleNode1Message;\n    g_nodeHandlers_vulnerable[2] = handleNode2Message;\n    logGatewayEvent(\"Gateway handlers initialized (vulnerable).\");\n}\n\nvoid processIncomingNetworkMessage_vulnerable() {\n    NetworkMessage incoming_msg = receiveNetworkMessage_vulnerable();\n\n    NodeMessageHandler handler = g_nodeHandlers_vulnerable[incoming_msg.destination_node_id];\n    \n    if (handler != NULL) {\n        handler(incoming_msg.payload, incoming_msg.payload_len);\n        logGatewayEvent(\"Message processed by handler.\");\n    } else {\n        logGatewayError(\"Handler is NULL, potential configuration error or invalid index.\");\n    }\n}\n\nvoid gatewayApplicationLoop_vulnerable() {\n    initializeGatewayHandlers_vulnerable();\n    processIncomingNetworkMessage_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\ntypedef enum {\n    DIAG_GROUP_ENGINE = 0,\n    DIAG_GROUP_TRANSMISSION,\n    DIAG_GROUP_SAFETY,\n    DIAG_GROUP_INFOTAINMENT,\n    NUM_DIAG_GROUPS\n} DiagnosticEventGroup;\n\ntypedef struct {\n    uint16_t event_code;\n    const char* description;\n    bool is_critical;\n} EventDefinition;\n\nstatic EventDefinition engineEventDefinitions_vulnerable[] = {\n    {0x1001, \"Engine Overheat\", true},\n    {0x1002, \"Misfire Cylinder 1\", true},\n    {0x1003, \"Low Oil Pressure\", true},\n    {0x1004, \"High Exhaust Temp\", false},\n    {0x1005, \"Idle Speed Deviation\", false}\n};\n#define ACTUAL_ENGINE_EVENTS (sizeof(engineEventDefinitions_vulnerable) / sizeof(EventDefinition))\n\nstatic EventDefinition transmissionEventDefinitions_vulnerable[] = {\n    {0x2001, \"Transmission Overload\", true},\n    {0x2002, \"Gear Shift Malfunction\", true},\n    {0x2003, \"Clutch Slip Detected\", false}\n};\n#define ACTUAL_TRANSMISSION_EVENTS (sizeof(transmissionEventDefinitions_vulnerable) / sizeof(EventDefinition))\n\nstatic EventDefinition safetyEventDefinitions_vulnerable[] = {\n    {0x3001, \"ABS Sensor Fault FL\", true},\n    {0x3002, \"Airbag Deployment Trigger\", true},\n    {0x3003, \"Seatbelt Pretensioner Fault\", false},\n    {0x3004, \"ESC System Error\", true},\n    {0x3005, \"Blind Spot Monitor Malf.\", false}\n};\n#define ACTUAL_SAFETY_EVENTS (sizeof(safetyEventDefinitions_vulnerable) / sizeof(EventDefinition))\n\nstatic EventDefinition infotainmentEventDefinitions_vulnerable[] = {\n    {0x4001, \"Navigation System Error\", false},\n    {0x4002, \"Audio System Fault\", false}\n};\n#define ACTUAL_INFOTAINMENT_EVENTS (sizeof(infotainmentEventDefinitions_vulnerable) / sizeof(EventDefinition))\n\ntypedef struct {\n    EventDefinition* events_ptr;\n    uint8_t count;\n} EventGroupRegistryEntry;\n\nstatic EventGroupRegistryEntry g_eventGroupRegistry_vulnerable[NUM_DIAG_GROUPS];\n\nvoid diagnosticLog_vulnerable(const char* msg) {\n}\n\nvoid initializeDiagnosticSystem_vulnerable() {\n    g_eventGroupRegistry_vulnerable[DIAG_GROUP_ENGINE] = (EventGroupRegistryEntry){engineEventDefinitions_vulnerable, ACTUAL_ENGINE_EVENTS};\n    g_eventGroupRegistry_vulnerable[DIAG_GROUP_TRANSMISSION] = (EventGroupRegistryEntry){transmissionEventDefinitions_vulnerable, ACTUAL_TRANSMISSION_EVENTS};\n    g_eventGroupRegistry_vulnerable[DIAG_GROUP_SAFETY] = (EventGroupRegistryEntry){safetyEventDefinitions_vulnerable, ACTUAL_SAFETY_EVENTS};\n    g_eventGroupRegistry_vulnerable[DIAG_GROUP_INFOTAINMENT] = (EventGroupRegistryEntry){infotainmentEventDefinitions_vulnerable, ACTUAL_INFOTAINMENT_EVENTS};\n    diagnosticLog_vulnerable(\"Diagnostic system initialized (vulnerable).\");\n}\n\ntypedef struct {\n    DiagnosticEventGroup group_id;\n    uint8_t event_type_idx;\n} EventLookupRequest_Vulnerable;\n\nEventLookupRequest_Vulnerable receiveEventLookupRequest_vulnerable() {\n    EventLookupRequest_Vulnerable req;\n    req.group_id = DIAG_GROUP_TRANSMISSION;\n    req.event_type_idx = 4;\n    return req;\n}\n\nvoid getEventDetails_vulnerable() {\n    EventLookupRequest_Vulnerable req = receiveEventLookupRequest_vulnerable();\n\n    if (req.group_id >= NUM_DIAG_GROUPS) {\n        diagnosticLog_vulnerable(\"Error: Invalid event group ID.\");\n        return;\n    }\n\n    EventDefinition selected_event = g_eventGroupRegistry_vulnerable[req.group_id].events_ptr[req.event_type_idx];\n    diagnosticLog_vulnerable(\"Attempted to retrieve event details (vulnerable).\");\n}\n\nvoid main_diagnostic_module_vulnerable() {\n    initializeDiagnosticSystem_vulnerable();\n    getEventDetails_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_SENSOR_TYPES_VULNERABLE 3\n#define CALIBRATION_POINTS_PER_SENSOR_VULNERABLE 10\n\ntypedef struct {\n    int16_t value;\n    uint32_t timestamp;\n} CalibrationPoint_Vulnerable;\n\nstatic CalibrationPoint_Vulnerable g_sensorCalibrationData_vulnerable[MAX_SENSOR_TYPES_VULNERABLE][CALIBRATION_POINTS_PER_SENSOR_VULNERABLE];\n\nvoid logSystemError_vulnerable(const char* msg) {\n    fprintf(stderr, \"VULN_LOG_ERROR: %s\\n\", msg);\n}\n\nvoid logSystemInfo_vulnerable(const char* msg) {\n    fprintf(stdout, \"VULN_LOG_INFO: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t sensor_type_id;\n    uint8_t start_offset_in_segment;\n    uint8_t num_points_to_update;\n    CalibrationPoint_Vulnerable data_payload[CALIBRATION_POINTS_PER_SENSOR_VULNERABLE]; \n} SensorCalCommand_Vulnerable;\n\nSensorCalCommand_Vulnerable getIncomingSensorCalCommand_vulnerable() {\n    SensorCalCommand_Vulnerable cmd;\n    cmd.sensor_type_id = 1; \n    cmd.start_offset_in_segment = CALIBRATION_POINTS_PER_SENSOR_VULNERABLE - 2; \n    cmd.num_points_to_update = 3; \n\n    for (int i = 0; i < cmd.num_points_to_update; ++i) {\n        cmd.data_payload[i].value = 1000 + i;\n        cmd.data_payload[i].timestamp = 0x5000 + i;\n    }\n    logSystemInfo_vulnerable(\"Simulated incoming sensor calibration command with potential OOB write.\");\n    return cmd;\n}\n\nvoid initializeCalibrationData_vulnerable() {\n    for (uint8_t i = 0; i < MAX_SENSOR_TYPES_VULNERABLE; ++i) {\n        for (uint8_t j = 0; j < CALIBRATION_POINTS_PER_SENSOR_VULNERABLE; ++j) {\n            g_sensorCalibrationData_vulnerable[i][j].value = 0;\n            g_sensorCalibrationData_vulnerable[i][j].timestamp = 0;\n        }\n    }\n    logSystemInfo_vulnerable(\"Sensor calibration data initialized.\");\n}\n\nvoid processSensorCalibrationUpdate_vulnerable() {\n    SensorCalCommand_Vulnerable cmd = getIncomingSensorCalCommand_vulnerable();\n\n    if (cmd.sensor_type_id >= MAX_SENSOR_TYPES_VULNERABLE) {\n        logSystemError_vulnerable(\"Invalid sensor type ID received.\");\n        return;\n    }\n\n    if (cmd.start_offset_in_segment < CALIBRATION_POINTS_PER_SENSOR_VULNERABLE) {\n        logSystemInfo_vulnerable(\"Processing sensor calibration update.\");\n        for (uint8_t i = 0; i < cmd.num_points_to_update; ++i) {\n            g_sensorCalibrationData_vulnerable[cmd.sensor_type_id][cmd.start_offset_in_segment + i] = cmd.data_payload[i];\n        }\n    } else {\n        logSystemError_vulnerable(\"Invalid starting offset for calibration update.\");\n    }\n}\n\nvoid automotiveSensorModule_vulnerable_main() {\n    initializeCalibrationData_vulnerable();\n    processSensorCalibrationUpdate_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_COMMAND_POOL_SIZE 256 \n\ntypedef struct {\n    uint8_t command_id;\n    uint16_t param_a;\n    uint16_t param_b;\n} VehicleCommand;\n\nstatic VehicleCommand g_commandPool_vulnerable[MAX_COMMAND_POOL_SIZE];\n\nvoid logECUEvent_vulnerable(const char* msg) {\n    fprintf(stderr, \"ECU_VULN_LOG: %s\\n\", msg);\n}\n\nvoid executeVehicleCommand_vulnerable(VehicleCommand cmd) {\n    logECUEvent_vulnerable(\"Executing vehicle command.\");\n}\n\ntypedef struct {\n    uint16_t start_idx;\n    uint16_t length;\n} SequenceConfigMsg_Vulnerable;\n\n// Simulates receiving a diagnostic command to configure a command sequence\n// This function provides untrusted input that can lead to an out-of-bounds access.\nSequenceConfigMsg_Vulnerable receiveSequenceConfig_vulnerable() {\n    SequenceConfigMsg_Vulnerable config;\n    config.start_idx = 200; // A seemingly valid start index (200 < 256)\n    config.length = 60;     // A seemingly valid length (60 < 256)\n                            // However, start_idx + length = 200 + 60 = 260, which is > 256.\n    return config;\n}\n\nvoid processActiveCommandSequence_vulnerable() {\n    SequenceConfigMsg_Vulnerable config = receiveSequenceConfig_vulnerable();\n    \n    uint16_t sequence_start_idx = config.start_idx;\n    uint16_t sequence_length = config.length;\n\n    logECUEvent_vulnerable(\"Processing active command sequence (vulnerable).\");\n\n    // Vulnerability: The individual checks for start_idx and length are insufficient.\n    // There is no check to ensure that the sum (start_idx + i) remains within bounds\n    // of MAX_COMMAND_POOL_SIZE for the entire loop iteration.\n    if (sequence_start_idx < MAX_COMMAND_POOL_SIZE && sequence_length > 0) {\n        for (uint16_t i = 0; i < sequence_length; ++i) {\n            // The index calculation (sequence_start_idx + i) can result in an out-of-bounds access.\n            // For the example input: when i = 56, the index becomes 200 + 56 = 256, which is OOB.\n            VehicleCommand cmd = g_commandPool_vulnerable[sequence_start_idx + i];\n            executeVehicleCommand_vulnerable(cmd);\n        }\n    } else {\n        logECUEvent_vulnerable(\"Invalid sequence configuration received (vulnerable).\");\n    }\n}\n\nvoid automotiveECU_CommandProcessor_vulnerable_main() {\n    // Initialize the command pool with dummy data\n    for (uint16_t i = 0; i < MAX_COMMAND_POOL_SIZE; ++i) {\n        g_commandPool_vulnerable[i] = (VehicleCommand){(uint8_t)i, i, (uint16_t)(i * 2)};\n    }\n    logECUEvent_vulnerable(\"Command pool initialized.\");\n    \n    // Process a potentially malicious command sequence configuration\n    processActiveCommandSequence_vulnerable();\n}\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n#include <limits>\n\ntypedef struct {\n    uint16_t param_id;\n    uint32_t payload_len;\n} ParameterHeader;\n\nclass VehicleDataAggregator {\npublic:\n    VehicleDataAggregator() : m_aggregated_data(nullptr), m_current_total_bytes(0), m_allocated_capacity_bytes(0) {}\n\n    ~VehicleDataAggregator() {\n        clear();\n    }\n\n    void clear() {\n        if (m_aggregated_data) {\n            delete[] m_aggregated_data;\n            m_aggregated_data = nullptr;\n        }\n        m_current_total_bytes = 0;\n        m_allocated_capacity_bytes = 0;\n    }\n\n    bool appendParameterBlockFixed(const uint8_t* raw_param_block, size_t block_length) {\n        if (!raw_param_block || block_length < sizeof(ParameterHeader)) {\n            return false;\n        }\n\n        const ParameterHeader* header = reinterpret_cast<const ParameterHeader*>(raw_param_block);\n        uint32_t incoming_payload_len = header->payload_len;\n\n        if (std::numeric_limits<uint32_t>::max() - incoming_payload_len < m_current_total_bytes) {\n            return false;\n        }\n\n        uint32_t required_new_total_size = m_current_total_bytes + incoming_payload_len; \n\n        if (block_length < sizeof(ParameterHeader) + incoming_payload_len) {\n            return false;\n        }\n        \n        if (required_new_total_size > m_allocated_capacity_bytes) {\n            uint8_t* new_buffer = new (std::nothrow) uint8_t[required_new_total_size];\n            if (!new_buffer) {\n                return false;\n            }\n            if (m_aggregated_data) {\n                memcpy(new_buffer, m_aggregated_data, m_current_total_bytes);\n                delete[] m_aggregated_data;\n            }\n            m_aggregated_data = new_buffer;\n            m_allocated_capacity_bytes = required_new_total_size;\n        }\n\n        memcpy(m_aggregated_data + m_current_total_bytes, raw_param_block + sizeof(ParameterHeader), incoming_payload_len);\n\n        m_current_total_bytes = required_new_total_size;\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedData() const {\n        return m_aggregated_data;\n    }\n\n    uint32_t getTotalAggregatedBytes() const {\n        return m_current_total_bytes;\n    }\n\nprivate:\n    uint8_t* m_aggregated_data;\n    uint32_t m_current_total_bytes;\n    uint32_t m_allocated_capacity_bytes;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_PARAMETERS 10\n#define PARAM_VALUE_BUFFER_SIZE 32\n#define MAX_INCOMING_DATA_LEN 256\n\ntypedef struct {\n    uint16_t param_id;\n    uint8_t  param_type;\n    uint8_t  value[PARAM_VALUE_BUFFER_SIZE];\n    uint8_t  current_len;\n} ParameterEntry;\n\nstatic ParameterEntry g_parameterStore[MAX_PARAMETERS];\nstatic uint8_t g_activeParameters = 0;\n\nvoid initParameterStore() {\n    memset(g_parameterStore, 0, sizeof(g_parameterStore));\n    g_activeParameters = 0;\n}\n\nint addParameterDefinition(uint16_t id, uint8_t type) {\n    if (g_activeParameters < MAX_PARAMETERS) {\n        g_parameterStore[g_activeParameters].param_id = id;\n        g_parameterStore[g_activeParameters].param_type = type;\n        g_parameterStore[g_activeParameters].current_len = 0;\n        g_activeParameters++;\n        return 0;\n    }\n    return -1;\n}\n\nint updateParameterValue(uint16_t target_param_id, const uint8_t* data, uint8_t data_len) {\n    if (data == NULL) {\n        return -1;\n    }\n\n    if (data_len > MAX_INCOMING_DATA_LEN) {\n        return -2;\n    }\n\n    int found_idx = -1;\n    for (uint8_t i = 0; i < g_activeParameters; ++i) {\n        if (g_parameterStore[i].param_id == target_param_id) {\n            found_idx = i;\n            break;\n        }\n    }\n\n    if (found_idx == -1) {\n        return -3;\n    }\n\n    uint8_t bytes_to_copy = data_len;\n    if (bytes_to_copy > PARAM_VALUE_BUFFER_SIZE) {\n        bytes_to_copy = PARAM_VALUE_BUFFER_SIZE;\n    }\n\n    for (uint8_t i = 0; i < bytes_to_copy; ++i) {\n        g_parameterStore[found_idx].value[i] = data[i];\n    }\n\n    g_parameterStore[found_idx].current_len = bytes_to_copy;\n\n    return 0;\n}\n\nint handleCANMessage(uint16_t msg_id, const uint8_t* msg_payload, uint8_t payload_len) {\n    if (msg_id == 0x123) {\n        if (payload_len < (sizeof(uint16_t) + sizeof(uint8_t) + 1)) {\n            return -1;\n        }\n        uint16_t param_id = (msg_payload[0] << 8) | msg_payload[1];\n        uint8_t data_len = msg_payload[2];\n        const uint8_t* data_ptr = &msg_payload[3];\n\n        if ((3 + data_len) > payload_len) {\n            return -5;\n        }\n\n        return updateParameterValue(param_id, data_ptr, data_len);\n    }\n    return 0;\n}\n\nuint8_t getParameterValueByte(uint16_t param_id, uint8_t index) {\n    int found_idx = -1;\n    for (uint8_t i = 0; i < g_activeParameters; ++i) {\n        if (g_parameterStore[i].param_id == param_id) {\n            found_idx = i;\n            break;\n        }\n    }\n    if (found_idx != -1 && index < g_parameterStore[found_idx].current_len) {\n        return g_parameterStore[found_idx].value[index];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CONFIG_NAME_MAX_LEN 32\n#define CONFIG_VALUE_MAX_LEN 64\n#define MAX_CONFIG_PARAMS 10\n\ntypedef enum {\n    PARAM_TYPE_UINT8,\n    PARAM_TYPE_UINT16,\n    PARAM_TYPE_UINT32,\n    PARAM_TYPE_STRING,\n    PARAM_TYPE_BOOL\n} ConfigParamType;\n\ntypedef struct {\n    char name[CONFIG_NAME_MAX_LEN];\n    ConfigParamType type;\n    uint8_t value_len;\n    union {\n        uint8_t  u8_val;\n        uint16_t u16_val;\n        uint32_t u32_val;\n        char     str_val[CONFIG_VALUE_MAX_LEN];\n        bool     bool_val;\n    } value;\n} ConfigurationParameter;\n\nstatic ConfigurationParameter g_vehicleConfig[MAX_CONFIG_PARAMS];\nstatic uint8_t g_numConfigParams = 0;\n\nint parseConfigurationParameter(const uint8_t* stream, uint16_t stream_len, ConfigurationParameter* param_out) {\n    if (stream == NULL || param_out == NULL || stream_len < 2) {\n        return -1;\n    }\n\n    uint16_t bytes_consumed = 0;\n\n    uint8_t name_len = stream[bytes_consumed++];\n    if (name_len >= CONFIG_NAME_MAX_LEN || bytes_consumed + name_len > stream_len) {\n        return -1;\n    }\n    memcpy(param_out->name, stream + bytes_consumed, name_len);\n    param_out->name[name_len] = '\\0';\n    bytes_consumed += name_len;\n\n    param_out->type = (ConfigParamType)stream[bytes_consumed++];\n    if (bytes_consumed > stream_len) {\n        return -1;\n    }\n\n    switch (param_out->type) {\n        case PARAM_TYPE_UINT8:\n            if (bytes_consumed + sizeof(uint8_t) > stream_len) return -1;\n            param_out->value.u8_val = stream[bytes_consumed];\n            param_out->value_len = sizeof(uint8_t);\n            bytes_consumed += sizeof(uint8_t);\n            break;\n        case PARAM_TYPE_UINT16:\n            if (bytes_consumed + sizeof(uint16_t) > stream_len) return -1;\n            param_out->value.u16_val = (uint16_t)((stream[bytes_consumed] << 8) | stream[bytes_consumed+1]);\n            param_out->value_len = sizeof(uint16_t);\n            bytes_consumed += sizeof(uint16_t);\n            break;\n        case PARAM_TYPE_UINT32:\n            if (bytes_consumed + sizeof(uint32_t) > stream_len) return -1;\n            param_out->value.u32_val = (uint32_t)((stream[bytes_consumed] << 24) | (stream[bytes_consumed+1] << 16) |\n                                                   (stream[bytes_consumed+2] << 8) | stream[bytes_consumed+3]);\n            param_out->value_len = sizeof(uint32_t);\n            bytes_consumed += sizeof(uint32_t);\n            break;\n        case PARAM_TYPE_BOOL:\n            if (bytes_consumed + sizeof(bool) > stream_len) return -1;\n            param_out->value.bool_val = (bool)stream[bytes_consumed];\n            param_out->value_len = sizeof(bool);\n            bytes_consumed += sizeof(bool);\n            break;\n        case PARAM_TYPE_STRING:\n            if (bytes_consumed >= stream_len) return -1;\n            uint8_t str_actual_len = stream[bytes_consumed++];\n            if (str_actual_len > CONFIG_VALUE_MAX_LEN || bytes_consumed + str_actual_len > stream_len) {\n                return -1;\n            }\n            memcpy(param_out->value.str_val, stream + bytes_consumed, str_actual_len);\n            param_out->value.str_val[str_actual_len] = '\\0';\n            param_out->value_len = str_actual_len;\n            bytes_consumed += str_actual_len;\n            break;\n        default:\n            return -1;\n    }\n\n    return bytes_consumed;\n}\n\nint loadVehicleConfiguration(const uint8_t* config_stream, uint16_t stream_total_len) {\n    if (config_stream == NULL || stream_total_len == 0) {\n        return -1;\n    }\n\n    uint16_t current_stream_pos = 0;\n    g_numConfigParams = 0;\n\n    while (current_stream_pos < stream_total_len && g_numConfigParams < MAX_CONFIG_PARAMS) {\n        int bytes_parsed = parseConfigurationParameter(\n                                config_stream + current_stream_pos,\n                                stream_total_len - current_stream_pos,\n                                &g_vehicleConfig[g_numConfigParams]\n                           );\n\n        if (bytes_parsed <= 0) {\n            return -1;\n        }\n        current_stream_pos += bytes_parsed;\n        g_numConfigParams++;\n    }\n\n    return 0;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_COMMAND_PACKET_SIZE 512\n#define VEHICLE_STATUS_BUFFER_SIZE 128\n#define COMMAND_HEADER_SIZE (sizeof(uint16_t) * 2)\n\nstatic uint8_t g_vehicleStatusData[VEHICLE_STATUS_BUFFER_SIZE];\n\nvoid initializeVehicleStatus() {\n    memset(g_vehicleStatusData, 0, VEHICLE_STATUS_BUFFER_SIZE);\n}\n\nint processStatusUpdatePayload(uint8_t target_offset, const uint8_t* source_data_ptr, uint16_t data_to_copy_len) {\n    if (source_data_ptr == NULL || data_to_copy_len == 0) {\n        return -1;\n    }\n\n    if ((uint32_t)target_offset + data_to_copy_len > VEHICLE_STATUS_BUFFER_SIZE) {\n        return -3;\n    }\n\n    for (uint16_t i = 0; i < data_to_copy_len; ++i) {\n        g_vehicleStatusData[target_offset + i] = source_data_ptr[i];\n    }\n\n    return 0;\n}\n\nint handleVehicleCommandPacket(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len < COMMAND_HEADER_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_read_offset = 0;\n\n    while (current_read_offset + COMMAND_HEADER_SIZE <= packet_len) {\n        uint16_t cmd_id = (packet_data[current_read_offset] << 8) | packet_data[current_read_offset + 1];\n        uint16_t cmd_payload_len = (packet_data[current_read_offset + 2] << 8) | packet_data[current_read_offset + 3];\n        current_read_offset += COMMAND_HEADER_SIZE;\n\n        if (cmd_payload_len > (packet_len - current_read_offset)) {\n            return -2;\n        }\n\n        const uint8_t* command_payload_data_ptr = packet_data + current_read_offset;\n\n        if (cmd_id == 0x0101) {\n            if (cmd_payload_len >= 1) {\n                uint8_t target_offset = command_payload_data_ptr[0];\n                const uint8_t* data_to_copy_ptr = command_payload_data_ptr + 1;\n                uint16_t actual_data_len = cmd_payload_len - 1;\n\n                int res = processStatusUpdatePayload(target_offset, data_to_copy_ptr, actual_data_len);\n                if (res != 0) {\n                    return res;\n                }\n            }\n        }\n        \n        current_read_offset += cmd_payload_len;\n    }\n    return 0;\n}\n\nuint8_t getVehicleStatusByte(uint8_t index) {\n    if (index < VEHICLE_STATUS_BUFFER_SIZE) {\n        return g_vehicleStatusData[index];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define SYSTEM_CONFIG_SIZE 1024\n#define MAX_CONFIG_GROUPS 10\n\n// Base offsets for each configuration group within the g_systemConfig array.\nstatic const uint16_t g_groupBaseOffsets[MAX_CONFIG_GROUPS] = {\n    0,     // Group 0\n    50,    // Group 1\n    120,   // Group 2\n    250,   // Group 3\n    400,   // Group 4\n    600,   // Group 5\n    850,   // Group 6\n    1150,  // Group 7\n    1400,  // Group 8\n    65500  // Group 9\n};\n\n// Global array storing various system configuration values.\nstatic uint16_t g_systemConfig[SYSTEM_CONFIG_SIZE]; \n\nvoid initSystemConfig() {\n    memset(g_systemConfig, 0, sizeof(g_systemConfig));\n    for (int i = 0; i < SYSTEM_CONFIG_SIZE; ++i) {\n        g_systemConfig[i] = i * 2; \n    }\n}\n\n// Function to update a specific configuration value based on group and item index.\n// group_id: Identifies the configuration group (0 to MAX_CONFIG_GROUPS-1).\n// item_index: Offset within the identified group (0 to 255 due to uint8_t).\n// new_value: The 16-bit value to write.\nint updateConfigurationValue(uint8_t group_id, uint8_t item_index, uint16_t new_value) {\n    if (group_id >= MAX_CONFIG_GROUPS) {\n        return -1; // Invalid group_id\n    }\n\n    // FIX: Use a wider type (uint32_t) for the intermediate index calculation.\n    // This prevents integer overflow when adding g_groupBaseOffsets[group_id] and item_index.\n    // The full, correct logical index is maintained before comparison to array bounds.\n    uint32_t potential_final_index = (uint32_t)g_groupBaseOffsets[group_id] + item_index;\n\n    // Now, compare the correctly calculated index against the actual buffer size.\n    // This check will properly catch cases where the intended logical index exceeds \n    // the physical buffer size, even if a uint16_t overflow would have made it appear in-bounds.\n    if (potential_final_index >= SYSTEM_CONFIG_SIZE) {\n        return -2; // Calculated index (even before wrap-around) is out of array bounds\n    }\n    \n    // Cast the validated index back to uint16_t for array access, as it is now guaranteed to be safe.\n    uint16_t final_index = (uint16_t)potential_final_index;\n\n    g_systemConfig[final_index] = new_value; \n\n    return 0; // Success\n}\n\n// Dummy function to simulate receiving a configuration update command from a vehicle's network.\nvoid receiveConfigUpdateCommand(uint8_t group, uint8_t item, uint16_t val) {\n    updateConfigurationValue(group, item, val);\n}\n\n// Function to retrieve a config value (for testing/demonstration).\nuint16_t getSystemConfigValue(uint16_t index) {\n    if (index < SYSTEM_CONFIG_SIZE) {\n        return g_systemConfig[index];\n    }\n    return 0xFFFF; // Error: Index out of bounds\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_STATE_BUFFER_SIZE 256\n#define VEHICLE_STATE_CHUNK_SIZE 20\n#define VEHICLE_STATE_HEADER_SIZE 4\n\nstatic uint8_t g_vehicle_state_data_buffer[VEHICLE_STATE_BUFFER_SIZE];\nstatic uint8_t* g_next_state_write_ptr = g_vehicle_state_data_buffer;\nstatic size_t g_current_state_entries = 0;\n\nvoid init_vehicle_state_manager() {\n    memset(g_vehicle_state_data_buffer, 0, sizeof(g_vehicle_state_data_buffer));\n    g_next_state_write_ptr = g_vehicle_state_data_buffer;\n    g_current_state_entries = 0;\n}\n\nbool add_vehicle_state_entry(uint8_t status, const uint8_t* state_data) {\n    if (g_next_state_write_ptr + VEHICLE_STATE_HEADER_SIZE + VEHICLE_STATE_CHUNK_SIZE >\n        g_vehicle_state_data_buffer + VEHICLE_STATE_BUFFER_SIZE) {\n        return false;\n    }\n\n    *g_next_state_write_ptr = status;\n    *(g_next_state_write_ptr + 1) = 0xDE;\n    *(g_next_state_write_ptr + 2) = 0xAD;\n    *(g_next_state_write_ptr + 3) = 0xBE;\n\n    memcpy(g_next_state_write_ptr + VEHICLE_STATE_HEADER_SIZE, state_data, VEHICLE_STATE_CHUNK_SIZE);\n\n    g_next_state_write_ptr += (VEHICLE_STATE_HEADER_SIZE + VEHICLE_STATE_CHUNK_SIZE);\n    g_current_state_entries++;\n    return true;\n}\n\nvoid invalidate_oldest_vehicle_state_vulnerable(uint32_t entries_to_invalidate_from_end) {\n    if (g_current_state_entries == 0 || entries_to_invalidate_from_end == 0) {\n        return;\n    }\n\n    size_t entry_total_size = VEHICLE_STATE_HEADER_SIZE + VEHICLE_STATE_CHUNK_SIZE;\n\n    int32_t byte_offset_from_end = (int32_t)entries_to_invalidate_from_end * entry_total_size;\n\n    uint8_t* target_entry_header_ptr = g_next_state_write_ptr - byte_offset_from_end;\n\n    *target_entry_header_ptr = 0x00;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DATA_CACHE_SIZE 256 \n#define SEGMENT_SIZE 16     \n#define METADATA_OFFSET_FROM_SEGMENT_START -4 \n\nstatic uint8_t g_vehicle_data_cache_fixed[DATA_CACHE_SIZE];\nstatic uint16_t g_num_active_segments_fixed = 0;\n\nvoid init_data_cache_fixed() {\n    memset(g_vehicle_data_cache_fixed, 0, DATA_CACHE_SIZE);\n    g_num_active_segments_fixed = 0;\n}\n\nbool add_data_segment_fixed(const uint8_t* segment_data) {\n    if ((g_num_active_segments_fixed + 1) * SEGMENT_SIZE > DATA_CACHE_SIZE) {\n        return false;\n    }\n    uint16_t write_offset = g_num_active_segments_fixed * SEGMENT_SIZE;\n    memcpy(g_vehicle_data_cache_fixed + write_offset, segment_data, SEGMENT_SIZE);\n    g_num_active_segments_fixed++;\n    return true;\n}\n\nvoid update_segment_control_byte_fixed(uint16_t segment_idx, uint8_t new_control_value) {\n    if (segment_idx >= g_num_active_segments_fixed) {\n        return;\n    }\n\n    uint16_t segment_start_offset = segment_idx * SEGMENT_SIZE;\n\n    int32_t potential_control_byte_offset = (int32_t)segment_start_offset + METADATA_OFFSET_FROM_SEGMENT_START;\n\n    if (potential_control_byte_offset < 0 || potential_control_byte_offset >= DATA_CACHE_SIZE) {\n        return;\n    }\n\n    g_vehicle_data_cache_fixed[potential_control_byte_offset] = new_control_value;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_PACKET_BUFFER_SIZE 512\n#define MIN_PACKET_HEADER_SIZE 8\n\nstatic uint8_t g_rx_packet_buffer[MAX_PACKET_BUFFER_SIZE];\nstatic uint32_t g_current_rx_data_len = 0;\n\ntypedef struct {\n    uint16_t packet_id;\n    uint8_t  packet_type;\n    uint8_t  flags;\n    uint16_t payload_length;\n    int16_t  checksum_offset;\n} PacketHeaderStruct;\n\nvoid receive_raw_packet_data(const uint8_t* data, uint32_t len) {\n    if (len > MAX_PACKET_BUFFER_SIZE) {\n        len = MAX_PACKET_BUFFER_SIZE;\n    }\n    memcpy(g_rx_packet_buffer, data, len);\n    g_current_rx_data_len = len;\n}\n\nvoid process_packet_payload(uint8_t* payload, uint16_t len) {\n    if (len > 0) {\n        volatile uint8_t first_byte = payload[0];\n        (void)first_byte;\n    }\n}\n\nvoid finalize_and_process_packet_fixed(void) {\n    if (g_current_rx_data_len < MIN_PACKET_HEADER_SIZE) {\n        return;\n    }\n\n    PacketHeaderStruct* header = (PacketHeaderStruct*)g_rx_packet_buffer;\n\n    uint16_t effective_payload_len = header->payload_length;\n    int16_t effective_checksum_offset = header->checksum_offset;\n\n    if (sizeof(PacketHeaderStruct) + effective_payload_len > g_current_rx_data_len ||\n        sizeof(PacketHeaderStruct) + effective_payload_len > MAX_PACKET_BUFFER_SIZE) {\n        return;\n    }\n    \n    uint8_t calculated_checksum = 0xAA;\n\n    int32_t target_byte_index = effective_checksum_offset;\n\n    if (target_byte_index < 0 || target_byte_index >= (int32_t)g_current_rx_data_len) {\n        return;\n    }\n\n    g_rx_packet_buffer[target_byte_index] = calculated_checksum;\n\n    process_packet_payload(g_rx_packet_buffer + sizeof(PacketHeaderStruct), effective_payload_len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n#include <stdbool.h>\n\nvoid automotiveLog_fixed(const char* msg) {\n}\n\n#define NUM_SENSOR_CHANNELS_FIXED 3\n#define MAX_PROCESSING_STEPS_PER_CHANNEL_FIXED 8\n\ntypedef enum {\n    SENSOR_CHANNEL_ENGINE_TEMP_FIXED = 0,\n    SENSOR_CHANNEL_BRAKE_PRESSURE_FIXED,\n    SENSOR_CHANNEL_STEERING_ANGLE_FIXED,\n    SENSOR_CHANNEL_COUNT_FIXED\n} SensorChannelID_fixed;\n\ntypedef float (*SensorProcessor_fixed)(float);\n\nfloat process_identity_fixed(float val) {\n    automotiveLog_fixed(\"  Identity processing.\");\n    return val;\n}\n\nfloat process_filter_fixed(float val) {\n    automotiveLog_fixed(\"  Filtering data.\");\n    return val * 0.95f;\n}\n\nfloat process_calibrate_fixed(float val) {\n    automotiveLog_fixed(\"  Calibrating data.\");\n    return val + 10.0f;\n}\n\nfloat process_transform_fixed(float val) {\n    automotiveLog_fixed(\"  Transforming data.\");\n    return val * 2.0f - 5.0f;\n}\n\nfloat process_security_critical_fixed(float val) {\n    automotiveLog_fixed(\"  WARNING: Executed security-critical dummy function!\");\n    return val;\n}\n\ntypedef struct {\n    SensorProcessor_fixed steps_fixed[MAX_PROCESSING_STEPS_PER_CHANNEL_FIXED];\n    uint8_t num_active_steps_fixed;\n} ProcessingPipeline_fixed;\n\nstatic ProcessingPipeline_fixed g_sensorPipelines_fixed[SENSOR_CHANNEL_COUNT_FIXED];\n\ntypedef struct {\n    SensorChannelID_fixed channel_id_fixed;\n    uint8_t step_index_fixed;\n    float input_value_fixed;\n} SensorProcessCommand_fixed;\n\nSensorProcessCommand_fixed receiveSensorProcessCommand_fixed() {\n    SensorProcessCommand_fixed cmd;\n    cmd.channel_id_fixed = SENSOR_CHANNEL_BRAKE_PRESSURE_FIXED;\n    cmd.step_index_fixed = 5;\n    cmd.input_value_fixed = 50.5f;\n    return cmd;\n}\n\nvoid initializeSensorPipelines_fixed() {\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_ENGINE_TEMP_FIXED].steps_fixed[0] = process_filter_fixed;\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_ENGINE_TEMP_FIXED].steps_fixed[1] = process_calibrate_fixed;\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_ENGINE_TEMP_FIXED].num_active_steps_fixed = 2;\n\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_BRAKE_PRESSURE_FIXED].steps_fixed[0] = process_identity_fixed;\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_BRAKE_PRESSURE_FIXED].steps_fixed[1] = process_filter_fixed;\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_BRAKE_PRESSURE_FIXED].num_active_steps_fixed = 2;\n\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_STEERING_ANGLE_FIXED].steps_fixed[0] = process_calibrate_fixed;\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_STEERING_ANGLE_FIXED].steps_fixed[1] = process_transform_fixed;\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_STEERING_ANGLE_FIXED].steps_fixed[2] = process_filter_fixed;\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_STEERING_ANGLE_FIXED].num_active_steps_fixed = 3;\n\n    for (int i = 0; i < NUM_SENSOR_CHANNELS_FIXED; ++i) {\n        for (int j = g_sensorPipelines_fixed[i].num_active_steps_fixed; j < MAX_PROCESSING_STEPS_PER_CHANNEL_FIXED; ++j) {\n            g_sensorPipelines_fixed[i].steps_fixed[j] = process_identity_fixed;\n        }\n    }\n\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_BRAKE_PRESSURE_FIXED].steps_fixed[5] = process_security_critical_fixed;\n\n    automotiveLog_fixed(\"Sensor processing pipelines initialized (fixed).\");\n}\n\nvoid executeSensorProcessingStep_fixed(SensorProcessCommand_fixed cmd) {\n    automotiveLog_fixed(\"Attempting to execute sensor processing step (fixed).\");\n\n    if (cmd.channel_id_fixed >= SENSOR_CHANNEL_COUNT_FIXED) {\n        automotiveLog_fixed(\"Error: Invalid sensor channel ID received.\");\n        return;\n    }\n\n    ProcessingPipeline_fixed* pipeline = &g_sensorPipelines_fixed[cmd.channel_id_fixed];\n\n    if (cmd.step_index_fixed < pipeline->num_active_steps_fixed) {\n        SensorProcessor_fixed processor_func = pipeline->steps_fixed[cmd.step_index_fixed];\n        \n        float result = processor_func(cmd.input_value_fixed);\n        (void)result;\n        automotiveLog_fixed(\"Sensor processing step executed.\");\n    } else {\n        automotiveLog_fixed(\"Error: Requested step index out of bounds for the specific sensor channel's pipeline.\");\n    }\n}\n\nvoid automotiveSensorProcessingUnit_fixed_main() {\n    initializeSensorPipelines_fixed();\n    SensorProcessCommand_fixed command = receiveSensorProcessCommand_fixed();\n    executeSensorProcessingStep_fixed(command);\n    automotiveLog_fixed(\"Fixed sensor processing unit finished.\");\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_CAN_MESSAGE_HANDLERS 10\n#define NUM_INITIALIZED_HANDLERS 5\n\ntypedef struct {\n    uint16_t id;\n    uint8_t data[8];\n    uint8_t length;\n} CanFrame;\n\ntypedef void (*CanMessageHandler)(uint16_t message_id, const uint8_t* data, uint8_t length);\n\ntypedef struct {\n    CanMessageHandler func;\n    bool is_active;\n} HandlerEntry;\n\nstatic HandlerEntry g_canMessageDispatchTable[MAX_CAN_MESSAGE_HANDLERS];\n\nvoid logCanEvent(const char* msg) {\n    printf(\"CAN_LOG: %s\\n\", msg);\n}\n\nvoid logCanError(const char* msg) {\n    printf(\"CAN_ERROR: %s\\n\", msg);\n}\n\nvoid handleEngineData(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Engine data processed.\");\n}\n\nvoid handleBrakeStatus(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Brake status processed.\");\n}\n\nvoid handleSteeringAngle(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Steering angle processed.\");\n}\n\nvoid handleVehicleSpeed(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Vehicle speed processed.\");\n}\n\nvoid handleDoorLockStatus(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Door lock status processed.\");\n}\n\nvoid handleCriticalSystemReset(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanError(\"SECURITY ALERT: Critical system reset attempted via CAN message!\");\n}\n\nvoid initializeCanDispatchTable_vulnerable() {\n    g_canMessageDispatchTable[0].func = handleEngineData;\n    g_canMessageDispatchTable[0].is_active = true;\n\n    g_canMessageDispatchTable[1].func = handleBrakeStatus;\n    g_canMessageDispatchTable[1].is_active = true;\n\n    g_canMessageDispatchTable[2].func = handleSteeringAngle;\n    g_canMessageDispatchTable[2].is_active = true;\n\n    g_canMessageDispatchTable[3].func = handleVehicleSpeed;\n    g_canMessageDispatchTable[3].is_active = true;\n\n    g_canMessageDispatchTable[4].func = handleDoorLockStatus;\n    g_canMessageDispatchTable[4].is_active = true;\n\n    g_canMessageDispatchTable[7].func = handleCriticalSystemReset;\n    g_canMessageDispatchTable[7].is_active = false;\n\n    for (int i = NUM_INITIALIZED_HANDLERS; i < MAX_CAN_MESSAGE_HANDLERS; ++i) {\n        if (i != 7) {\n             g_canMessageDispatchTable[i].func = NULL;\n             g_canMessageDispatchTable[i].is_active = false;\n        }\n    }\n    logCanEvent(\"CAN message dispatch table initialized (vulnerable).\");\n}\n\nCanFrame receiveSimulatedCanFrame_vulnerable() {\n    CanFrame frame;\n    frame.id = 7;\n    frame.data[0] = 0xDE;\n    frame.data[1] = 0xAD;\n    frame.length = 2;\n    logCanEvent(\"Simulated CAN frame received for ID 7.\");\n    return frame;\n}\n\nvoid processCanFrame_vulnerable() {\n    CanFrame frame = receiveSimulatedCanFrame_vulnerable();\n\n    if (frame.id < MAX_CAN_MESSAGE_HANDLERS) {\n        CanMessageHandler handler = g_canMessageDispatchTable[frame.id].func;\n        if (handler != NULL) {\n            handler(frame.id, frame.data, frame.length);\n        } else {\n            logCanError(\"Received CAN message for unhandled ID (NULL handler).\");\n        }\n    } else {\n        logCanError(\"Received CAN message with out-of-bounds ID.\");\n    }\n}\n\nvoid canBusManager_vulnerable_main() {\n    initializeCanDispatchTable_vulnerable();\n    processCanFrame_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_LOG_TOTAL_BUFFER_SIZE 256\n#define DIAG_LOG_ENTRY_HEADER_SIZE 8 // Example header: Event ID (1), Reserved (5), DataLength (2)\n#define DIAG_LOG_MAX_PAYLOAD_SIZE 64 // Max size of data payload for a single entry\n\n// The main circular buffer for diagnostic logs\nstatic uint8_t g_diagLogBuffer[DIAG_LOG_TOTAL_BUFFER_SIZE];\n// Pointer to the start of the current active log entry being filled\n// This pointer moves in a circular fashion within g_diagLogBuffer.\nstatic uint16_t g_currentEntryStart = 0;\n\nvoid initDiagnosticLogger() {\n    memset(g_diagLogBuffer, 0, DIAG_LOG_TOTAL_BUFFER_SIZE);\n    g_currentEntryStart = 0;\n}\n\n// This function is called to prepare space for a new log entry.\n// It reserves the space and writes a simplified header.\n// 'intended_payload_len' is the expected maximum length of data for this entry's payload.\nint createNewLogEntry(uint8_t event_type, uint16_t intended_payload_len) {\n    uint16_t total_entry_size = DIAG_LOG_ENTRY_HEADER_SIZE + intended_payload_len;\n\n    if (intended_payload_len > DIAG_LOG_MAX_PAYLOAD_SIZE) {\n        return -1; // Payload length exceeds maximum allowed for any single entry\n    }\n    if (total_entry_size > DIAG_LOG_TOTAL_BUFFER_SIZE) {\n        return -2; // Entry too large for the entire buffer\n    }\n\n    // Handle circular buffer wrap-around for the start of the new entry.\n    // If the new entry doesn't fit contiguously, wrap to the beginning.\n    if (g_currentEntryStart + total_entry_size > DIAG_LOG_TOTAL_BUFFER_SIZE) {\n        g_currentEntryStart = 0; // Wrap to beginning of buffer\n    }\n\n    // Write simplified header data at g_currentEntryStart\n    g_diagLogBuffer[g_currentEntryStart] = event_type; // Byte 0: Event Type\n    // Bytes 1-5 reserved/other header fields (for simplicity, assumed to be 0)\n    // Bytes 6-7: Data Length (MSB, LSB) - stored here for later reference\n    g_diagLogBuffer[g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE - 2] = (uint8_t)(intended_payload_len >> 8);\n    g_diagLogBuffer[g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE - 1] = (uint8_t)(intended_payload_len & 0xFF);\n\n    return 0; // Success\n}\n\n// This function is used to update a specific byte within the payload\n// of the *current* active log entry. This is often used for incrementally\n// filling or correcting log data.\n// 'payload_offset': The offset FROM THE START OF THE PAYLOAD AREA of the current entry.\n// 'value': The byte value to write.\nint updateLogEntryPayloadByte(uint16_t payload_offset, uint8_t value) {\n    // Retrieve the intended payload length for the current entry from its header.\n    // This assumes g_currentEntryStart points to a valid header of an active entry.\n    uint16_t stored_intended_payload_len = (g_diagLogBuffer[g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE - 2] << 8) |\n                                           g_diagLogBuffer[g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE - 1];\n\n    // FIX: Add a bounds check to ensure 'payload_offset' is within the intended payload area.\n    if (payload_offset >= stored_intended_payload_len) {\n        return -2; // Attempt to write beyond the intended payload area for this entry\n    }\n\n    uint16_t absolute_write_pos = g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE + payload_offset;\n\n    // Defensive check: This condition should ideally not be reached if the intended_payload_len\n    // was correctly validated when the entry was created, and payload_offset is now validated.\n    if (absolute_write_pos >= DIAG_LOG_TOTAL_BUFFER_SIZE) {\n        return -1; // Attempt to write beyond total log buffer boundaries (should be caught earlier)\n    }\n\n    g_diagLogBuffer[absolute_write_pos] = value;\n    return 0;\n}\n\n// After an entry is fully populated, this function advances the write pointer.\n// 'actual_payload_len': The actual number of payload bytes written for this entry.\nvoid finalizeLogEntry(uint16_t actual_payload_len) {\n    g_currentEntryStart = (g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE + actual_payload_len) % DIAG_LOG_TOTAL_BUFFER_SIZE;\n}\n\n// Public interface to simulate logging a vehicle event with a given data block.\n// This function itself appears safe by respecting effective_payload_len.\nvoid logVehicleEvent(uint8_t event_type, const uint8_t* event_data, uint16_t event_data_len) {\n    if (event_data == NULL || event_data_len == 0) return;\n\n    uint16_t effective_payload_len = event_data_len;\n    if (effective_payload_len > DIAG_LOG_MAX_PAYLOAD_SIZE) {\n        effective_payload_len = DIAG_LOG_MAX_PAYLOAD_SIZE;\n    }\n\n    if (createNewLogEntry(event_type, effective_payload_len) == 0) {\n        for (uint16_t i = 0; i < effective_payload_len; ++i) {\n            updateLogEntryPayloadByte(i, event_data[i]);\n        }\n        finalizeLogEntry(effective_payload_len);\n    }\n}\n\n// Function simulating an external call that might have attempted to exploit the vulnerability.\nvoid maliciousDiagnosticPoke(uint16_t offset_from_payload_start, uint8_t value) {\n    // Now, updateLogEntryPayloadByte is protected and will return an error\n    // if the offset is out of the logical bounds of the current entry's payload.\n    updateLogEntryPayloadByte(offset_from_payload_start, value);\n}\n\n// Example of how a diagnostic command handler might use these functions\nvoid processDiagnosticCommand(uint8_t command_id, uint8_t* command_payload, uint16_t payload_len) {\n    initDiagnosticLogger(); // Initialize for demonstration\n\n    switch(command_id) {\n        case 0x01: // Standard event logging command\n            logVehicleEvent(0x55, command_payload, payload_len);\n            break;\n        case 0x02: // Special command to 'poke' a byte in the current log entry's data area\n            if (payload_len >= 3) {\n                uint16_t offset = (command_payload[0] << 8) | command_payload[1];\n                uint8_t val = command_payload[2];\n                maliciousDiagnosticPoke(offset, val);\n            }\n            break;\n        // ... other commands\n    }\n}\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_VEHICLE_LIGHT_TYPES 5\n\ntypedef enum {\n    LIGHT_TYPE_HEADLIGHTS = 0,\n    LIGHT_TYPE_TAILLIGHTS = 1,\n    LIGHT_TYPE_FOGLIGHTS = 2,\n    LIGHT_TYPE_INTERIOR = 3,\n    LIGHT_TYPE_INDICATORS = 4,\n    LIGHT_TYPE_COUNT = 5\n} VehicleLightType;\n\ntypedef enum {\n    LIGHT_ACTION_OFF = 0,\n    LIGHT_ACTION_ON = 1,\n    LIGHT_ACTION_HIGH_BEAM = 2,\n    LIGHT_ACTION_LOW_BEAM = 3,\n    LIGHT_ACTION_DIM = 4,\n    LIGHT_ACTION_FLASH = 5,\n    LIGHT_ACTION_MAX_VALUE = 5\n} LightActionState;\n\nvoid performHeadlightAction_fixed(LightActionState action) {\n    printf(\"Headlight action: %d\\n\", action);\n}\nvoid performTaillightAction_fixed(LightActionState action) {\n    printf(\"Taillight action: %d\\n\", action);\n}\nvoid performFoglightAction_fixed(LightActionState action) {\n    printf(\"Foglight action: %d\\n\", action);\n}\nvoid performInteriorLightAction_fixed(LightActionState action) {\n    printf(\"Interior Light action: %d\\n\", action);\n}\nvoid performIndicatorAction_fixed(LightActionState action) {\n    printf(\"Indicator action: %d\\n\", action);\n}\n\ntypedef void (*LightSpecificActionFunction_fixed)(LightActionState action);\n\nstatic LightSpecificActionFunction_fixed g_lightTypeActionDispatch_fixed[MAX_VEHICLE_LIGHT_TYPES];\n\nstatic const LightActionState g_validHeadlightActions_fixed[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON, LIGHT_ACTION_HIGH_BEAM, LIGHT_ACTION_LOW_BEAM};\nstatic const LightActionState g_validTaillightActions_fixed[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON, LIGHT_ACTION_FLASH};\nstatic const LightActionState g_validFoglightActions_fixed[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON};\nstatic const LightActionState g_validInteriorLightActions_fixed[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON, LIGHT_ACTION_DIM};\nstatic const LightActionState g_validIndicatorActions_fixed[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON, LIGHT_ACTION_FLASH};\n\ntypedef struct {\n    const LightActionState* actions;\n    uint8_t count;\n} LightActionSetInfo_fixed;\n\nstatic LightActionSetInfo_fixed g_lightActionSets_fixed[MAX_VEHICLE_LIGHT_TYPES];\n\nvoid initializeLightManagement_fixed() {\n    g_lightTypeActionDispatch_fixed[LIGHT_TYPE_HEADLIGHTS] = performHeadlightAction_fixed;\n    g_lightTypeActionDispatch_fixed[LIGHT_TYPE_TAILLIGHTS] = performTaillightAction_fixed;\n    g_lightTypeActionDispatch_fixed[LIGHT_TYPE_FOGLIGHTS] = performFoglightAction_fixed;\n    g_lightTypeActionDispatch_fixed[LIGHT_TYPE_INTERIOR] = performInteriorLightAction_fixed;\n    g_lightTypeActionDispatch_fixed[LIGHT_TYPE_INDICATORS] = performIndicatorAction_fixed;\n\n    g_lightActionSets_fixed[LIGHT_TYPE_HEADLIGHTS] = (LightActionSetInfo_fixed){g_validHeadlightActions_fixed, sizeof(g_validHeadlightActions_fixed) / sizeof(g_validHeadlightActions_fixed[0])};\n    g_lightActionSets_fixed[LIGHT_TYPE_TAILLIGHTS] = (LightActionSetInfo_fixed){g_validTaillightActions_fixed, sizeof(g_validTaillightActions_fixed) / sizeof(g_validTaillightActions_fixed[0])};\n    g_lightActionSets_fixed[LIGHT_TYPE_FOGLIGHTS] = (LightActionSetInfo_fixed){g_validFoglightActions_fixed, sizeof(g_validFoglightActions_fixed) / sizeof(g_validFoglightActions_fixed[0])};\n    g_lightActionSets_fixed[LIGHT_TYPE_INTERIOR] = (LightActionSetInfo_fixed){g_validInteriorLightActions_fixed, sizeof(g_validInteriorLightActions_fixed) / sizeof(g_validInteriorLightActions_fixed[0])};\n    g_lightActionSets_fixed[LIGHT_TYPE_INDICATORS] = (LightActionSetInfo_fixed){g_validIndicatorActions_fixed, sizeof(g_validIndicatorActions_fixed) / sizeof(g_validIndicatorActions_fixed[0])};\n}\n\ntypedef struct {\n    uint8_t light_type_id;\n    uint8_t action_list_idx;\n} LightControlCommand_fixed;\n\nLightControlCommand_fixed receiveLightCommand_fixed() {\n    LightControlCommand_fixed cmd;\n    cmd.light_type_id = LIGHT_TYPE_FOGLIGHTS;\n    cmd.action_list_idx = 2;\n    return cmd;\n}\n\nvoid logVehicleLightError_fixed(const char* msg) {\n    printf(\"LIGHT_ERR_FIXED: %s\\n\", msg);\n}\n\nvoid processLightCommand_fixed() {\n    LightControlCommand_fixed cmd = receiveLightCommand_fixed();\n\n    if (cmd.light_type_id < LIGHT_TYPE_COUNT) {\n        if (cmd.action_list_idx < g_lightActionSets_fixed[cmd.light_type_id].count) {\n            LightActionState action_to_perform = g_lightActionSets_fixed[cmd.light_type_id].actions[cmd.action_list_idx];\n            g_lightTypeActionDispatch_fixed[cmd.light_type_id](action_to_perform);\n            printf(\"Light command processed (fixed).\\n\");\n        } else {\n            logVehicleLightError_fixed(\"Requested action index out of bounds for specified light type.\");\n        }\n    } else {\n        logVehicleLightError_fixed(\"Invalid light type ID received.\");\n    }\n}\n\nvoid vehicleLightManagerMain_fixed() {\n    initializeLightManagement_fixed();\n    processLightCommand_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n\n#pragma pack(push, 1)\n\nstruct VehicleCommandHeader {\n    uint16_t command_id;\n    uint16_t data_length;\n};\n\nstruct CommandBatchHeader {\n    uint32_t batch_id;\n    uint16_t num_commands;\n    uint32_t total_payload_bytes;\n};\n\n#pragma pack(pop)\n\nclass CommandBatchProcessor {\npublic:\n    CommandBatchProcessor() : m_processed_batch_data(nullptr), m_processed_data_size(0) {}\n\n    ~CommandBatchProcessor() {\n        if (m_processed_batch_data) {\n            delete[] m_processed_batch_data;\n            m_processed_batch_data = nullptr;\n        }\n    }\n\n    bool processCommandBatchVulnerable(const uint8_t* raw_batch_data, size_t raw_batch_data_len) {\n        if (!raw_batch_data || raw_batch_data_len < sizeof(CommandBatchHeader)) {\n            return false;\n        }\n\n        const CommandBatchHeader* batch_header = reinterpret_cast<const CommandBatchHeader*>(raw_batch_data);\n\n        if (batch_header->total_payload_bytes > (raw_batch_data_len - sizeof(CommandBatchHeader))) {\n            return false;\n        }\n\n        if (m_processed_batch_data) {\n            delete[] m_processed_batch_data;\n            m_processed_batch_data = nullptr;\n        }\n\n        m_processed_batch_data = new (std::nothrow) uint8_t[batch_header->total_payload_bytes];\n        if (!m_processed_batch_data) {\n            m_processed_data_size = 0;\n            return false;\n        }\n        m_processed_data_size = batch_header->total_payload_bytes;\n\n        size_t current_raw_offset = sizeof(CommandBatchHeader);\n        size_t current_processed_offset = 0;\n\n        for (uint16_t i = 0; i < batch_header->num_commands; ++i) {\n            if (current_raw_offset + sizeof(VehicleCommandHeader) > raw_batch_data_len) {\n                return false;\n            }\n\n            const VehicleCommandHeader* cmd_header = reinterpret_cast<const VehicleCommandHeader*>(raw_batch_data + current_raw_offset);\n            uint16_t current_cmd_data_len = cmd_header->data_length;\n\n            if (current_raw_offset + sizeof(VehicleCommandHeader) + current_cmd_data_len > raw_batch_data_len) {\n                return false;\n            }\n\n            memcpy(m_processed_batch_data + current_processed_offset, cmd_header, sizeof(VehicleCommandHeader));\n            current_processed_offset += sizeof(VehicleCommandHeader);\n\n            memcpy(m_processed_batch_data + current_processed_offset, raw_batch_data + current_raw_offset + sizeof(VehicleCommandHeader), current_cmd_data_len);\n            current_processed_offset += current_cmd_data_len;\n\n            current_raw_offset += sizeof(VehicleCommandHeader) + current_cmd_data_len;\n        }\n\n        if (current_processed_offset > m_processed_data_size) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedBatchData() const {\n        return m_processed_batch_data;\n    }\n\n    size_t getProcessedDataSize() const {\n        return m_processed_data_size;\n    }\n\nprivate:\n    uint8_t* m_processed_batch_data;\n    size_t m_processed_data_size;\n};\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#define CONFIG_TYPE_A_COUNT 10\n#define CONFIG_TYPE_B_COUNT 15\n#define CONFIG_TYPE_C_COUNT 8\n#define MAX_CONFIG_TYPES 3\n\ntypedef struct {\n    unsigned int param1;\n    unsigned short param2;\n} ConfigItemA;\n\ntypedef struct {\n    unsigned char status;\n    unsigned int data;\n    unsigned short checksum;\n} ConfigItemB;\n\ntypedef struct {\n    float value;\n} ConfigItemC;\n\nstatic ConfigItemA g_configA[CONFIG_TYPE_A_COUNT];\nstatic ConfigItemB g_configB[CONFIG_TYPE_B_COUNT];\nstatic ConfigItemC g_configC[CONFIG_TYPE_C_COUNT];\n\nstatic unsigned short g_configSizes[MAX_CONFIG_TYPES] = {\n    CONFIG_TYPE_A_COUNT,\n    CONFIG_TYPE_B_COUNT,\n    CONFIG_TYPE_C_COUNT\n};\n\ntypedef struct {\n    unsigned char config_type_id;\n    unsigned char sub_index;\n    unsigned int value;\n} DiagnosticCommand;\n\nDiagnosticCommand receiveDiagnosticCommand_vulnerable() {\n    DiagnosticCommand cmd;\n    cmd.config_type_id = 0; \n    cmd.sub_index = 10; \n    cmd.value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid logDiagnosticError(const char* msg) {\n}\n\nvoid processDiagnosticCommand_vulnerable() {\n    DiagnosticCommand cmd = receiveDiagnosticCommand_vulnerable();\n\n    if (cmd.config_type_id < MAX_CONFIG_TYPES) {\n        switch (cmd.config_type_id) {\n            case 0:\n                g_configA[cmd.sub_index].param1 = cmd.value;\n                break;\n            case 1:\n                g_configB[cmd.sub_index].data = cmd.value;\n                break;\n            case 2:\n                g_configC[cmd.sub_index].value = (float)cmd.value;\n                break;\n            default:\n                logDiagnosticError(\"Unknown config type ID received.\");\n                break;\n        }\n    } else {\n        logDiagnosticError(\"Invalid config type ID received.\");\n    }\n}\n\nvoid diagnosticModuleMain_vulnerable() {\n    for (int i = 0; i < CONFIG_TYPE_A_COUNT; ++i) g_configA[i] = (ConfigItemA){0,0};\n    for (int i = 0; i < CONFIG_TYPE_B_COUNT; ++i) g_configB[i] = (ConfigItemB){0,0,0};\n    for (int i = 0; i < CONFIG_TYPE_C_COUNT; ++i) g_configC[i] = (ConfigItemC){0.0f};\n\n    processDiagnosticCommand_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define CALIBRATION_DATA_SIZE 256\n#define MAX_CAN_DLC 8\n\ntypedef struct {\n    uint8_t  command_id;\n    uint8_t  segment_offset_high;\n    uint8_t  segment_offset_low;\n    uint8_t  segment_length;\n    uint8_t  data[MAX_CAN_DLC - 4];\n} CanCalibrationUpdatePacket;\n\nstatic uint8_t g_calibrationData[CALIBRATION_DATA_SIZE];\n\nvoid initCalibrationSystem() {\n    memset(g_calibrationData, 0xFF, CALIBRATION_DATA_SIZE);\n}\n\nint processCalibrationUpdate(const CanCalibrationUpdatePacket* packet_data, uint8_t actual_can_dlc) {\n    if (packet_data == NULL || actual_can_dlc < 4) {\n        return -1;\n    }\n\n    if (packet_data->command_id != 0x01) {\n        return -2;\n    }\n\n    uint16_t segment_offset = ((uint16_t)packet_data->segment_offset_high << 8) | packet_data->segment_offset_low;\n    uint8_t segment_length = packet_data->segment_length;\n\n    if (segment_length > (actual_can_dlc - 4)) {\n        return -3;\n    }\n\n    if (segment_offset >= CALIBRATION_DATA_SIZE) {\n        return -4;\n    }\n\n    memcpy(g_calibrationData + segment_offset, packet_data->data, segment_length);\n\n    return 0;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define TOTAL_FIRMWARE_MEMORY_BYTES_VULNERABLE 2048\n#define PAGE_SIZE_BYTES_VULNERABLE 64\n#define MAX_COMPONENTS_VULNERABLE 3\n\nstatic uint8_t g_firmwareMemory_vulnerable[TOTAL_FIRMWARE_MEMORY_BYTES_VULNERABLE];\n\ntypedef enum {\n    COMPONENT_ENGINE_CONTROL_VULNERABLE = 0,\n    COMPONENT_TRANSMISSION_CONTROL_VULNERABLE,\n    COMPONENT_BRAKE_SYSTEM_VULNERABLE,\n    COMPONENT_INVALID_VULNERABLE\n} ComponentID_Vulnerable;\n\ntypedef struct {\n    size_t start_offset_bytes;\n    size_t bank_size_pages;\n} ComponentFirmwareBankConfig_Vulnerable;\n\nstatic ComponentFirmwareBankConfig_Vulnerable g_componentBankConfigs_vulnerable[MAX_COMPONENTS_VULNERABLE];\n\nvoid logFirmwareUpdateEvent_vulnerable(const char* msg) {\n}\n\nvoid logFirmwareUpdateError_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    ComponentID_Vulnerable component_id;\n    uint16_t page_index;\n    uint8_t data[PAGE_SIZE_BYTES_VULNERABLE];\n} FirmwareUpdatePacket_Vulnerable;\n\nFirmwareUpdatePacket_Vulnerable receiveFirmwareUpdatePacket_vulnerable() {\n    FirmwareUpdatePacket_Vulnerable packet;\n    packet.component_id = COMPONENT_ENGINE_CONTROL_VULNERABLE;\n    packet.page_index = 20;\n    for (int i = 0; i < PAGE_SIZE_BYTES_VULNERABLE; ++i) {\n        packet.data[i] = (uint8_t)i;\n    }\n    return packet;\n}\n\nvoid initializeFirmwareBanks_vulnerable() {\n    g_componentBankConfigs_vulnerable[COMPONENT_ENGINE_CONTROL_VULNERABLE] = (ComponentFirmwareBankConfig_Vulnerable){\n        .start_offset_bytes = 0,\n        .bank_size_pages = 10\n    };\n    g_componentBankConfigs_vulnerable[COMPONENT_TRANSMISSION_CONTROL_VULNERABLE] = (ComponentFirmwareBankConfig_Vulnerable){\n        .start_offset_bytes = g_componentBankConfigs_vulnerable[COMPONENT_ENGINE_CONTROL_VULNERABLE].start_offset_bytes +\n                              g_componentBankConfigs_vulnerable[COMPONENT_ENGINE_CONTROL_VULNERABLE].bank_size_pages * PAGE_SIZE_BYTES_VULNERABLE,\n        .bank_size_pages = 15\n    };\n    g_componentBankConfigs_vulnerable[COMPONENT_BRAKE_SYSTEM_VULNERABLE] = (ComponentFirmwareBankConfig_Vulnerable){\n        .start_offset_bytes = g_componentBankConfigs_vulnerable[COMPONENT_TRANSMISSION_CONTROL_VULNERABLE].start_offset_bytes +\n                              g_componentBankConfigs_vulnerable[COMPONENT_TRANSMISSION_CONTROL_VULNERABLE].bank_size_pages * PAGE_SIZE_BYTES_VULNERABLE,\n        .bank_size_pages = 8\n    };\n\n    for (size_t i = 0; i < TOTAL_FIRMWARE_MEMORY_BYTES_VULNERABLE; ++i) {\n        g_firmwareMemory_vulnerable[i] = 0;\n    }\n\n    logFirmwareUpdateEvent_vulnerable(\"Firmware banks initialized (vulnerable).\");\n}\n\nvoid applyFirmwareUpdate_vulnerable(FirmwareUpdatePacket_Vulnerable update_packet) {\n    if (update_packet.component_id >= COMPONENT_INVALID_VULNERABLE) {\n        logFirmwareUpdateError_vulnerable(\"Invalid component ID in firmware update.\");\n        return;\n    }\n\n    ComponentFirmwareBankConfig_Vulnerable config = g_componentBankConfigs_vulnerable[update_packet.component_id];\n\n    size_t target_byte_offset = config.start_offset_bytes + (size_t)update_packet.page_index * PAGE_SIZE_BYTES_VULNERABLE;\n\n    if (target_byte_offset + PAGE_SIZE_BYTES_VULNERABLE <= TOTAL_FIRMWARE_MEMORY_BYTES_VULNERABLE) {\n        for (size_t i = 0; i < PAGE_SIZE_BYTES_VULNERABLE; ++i) {\n            g_firmwareMemory_vulnerable[target_byte_offset + i] = update_packet.data[i];\n        }\n        logFirmwareUpdateEvent_vulnerable(\"Firmware page updated.\");\n    } else {\n        logFirmwareUpdateError_vulnerable(\"Firmware update would write out of total memory bounds.\");\n    }\n}\n\nvoid firmwareUpdateManager_vulnerable_main() {\n    initializeFirmwareBanks_vulnerable();\n    FirmwareUpdatePacket_Vulnerable cmd = receiveFirmwareUpdatePacket_vulnerable();\n    applyFirmwareUpdate_vulnerable(cmd);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_FIRMWARE_CHUNK_SIZE 256\n#define FIRMWARE_BLOCK_BUFFER_SIZE 4096\n#define TOTAL_FIRMWARE_IMAGE_SIZE 1048576\n\ntypedef struct {\n    uint32_t address_offset;\n    uint16_t data_length;\n    uint8_t  data[MAX_FIRMWARE_CHUNK_SIZE];\n} FirmwarePacket;\n\ntypedef struct {\n    uint32_t current_block_address;\n    uint8_t  firmware_block_buffer[FIRMWARE_BLOCK_BUFFER_SIZE];\n    uint32_t bytes_in_current_block;\n    bool     update_in_progress;\n} FirmwareUpdateContext;\n\nstatic FirmwareUpdateContext g_fwUpdateContext = {0};\n\nvoid initFirmwareUpdater() {\n    memset(&g_fwUpdateContext, 0, sizeof(FirmwareUpdateContext));\n    g_fwUpdateContext.update_in_progress = false;\n}\n\nint handleFirmwarePacket(const FirmwarePacket* packet) {\n    if (packet == NULL || packet->data_length == 0 || packet->data_length > MAX_FIRMWARE_CHUNK_SIZE) {\n        return -1;\n    }\n\n    if (!g_fwUpdateContext.update_in_progress) {\n        return -1;\n    }\n\n    uint32_t global_target_offset = packet->address_offset;\n    uint16_t chunk_len = packet->data_length;\n\n    if (global_target_offset + chunk_len > TOTAL_FIRMWARE_IMAGE_SIZE) {\n        return -2;\n    }\n\n    uint32_t packet_block_base_address = global_target_offset / FIRMWARE_BLOCK_BUFFER_SIZE * FIRMWARE_BLOCK_BUFFER_SIZE;\n    uint32_t offset_within_block = global_target_offset % FIRMWARE_BLOCK_BUFFER_SIZE;\n\n    if (g_fwUpdateContext.current_block_address != packet_block_base_address) {\n        memset(g_fwUpdateContext.firmware_block_buffer, 0, FIRMWARE_BLOCK_BUFFER_SIZE);\n        g_fwUpdateContext.bytes_in_current_block = 0;\n        g_fwUpdateContext.current_block_address = packet_block_base_address;\n    }\n\n    if (offset_within_block + chunk_len > FIRMWARE_BLOCK_BUFFER_SIZE) {\n        return -3;\n    }\n\n    memcpy(g_fwUpdateContext.firmware_block_buffer + offset_within_block, packet->data, chunk_len);\n\n    if (offset_within_block + chunk_len > g_fwUpdateContext.bytes_in_current_block) {\n        g_fwUpdateContext.bytes_in_current_block = offset_within_block + chunk_len;\n    }\n\n    return 0;\n}\n\nvoid startFirmwareUpdate() {\n    g_fwUpdateContext.update_in_progress = true;\n    g_fwUpdateContext.current_block_address = 0;\n    g_fwUpdateContext.bytes_in_current_block = 0;\n    memset(g_fwUpdateContext.firmware_block_buffer, 0, FIRMWARE_BLOCK_BUFFER_SIZE);\n}\n\nvoid endFirmwareUpdate() {\n    g_fwUpdateContext.update_in_progress = false;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define VEHICLE_COM_BUFFER_SIZE 256\n#define VEHICLE_COM_HEADER_LEN 5\n\ntypedef struct {\n    uint8_t start_marker;\n    uint8_t protocol_version;\n    uint8_t message_type;\n    uint8_t payload_length;\n    uint8_t checksum;\n    uint8_t payload_data[VEHICLE_COM_BUFFER_SIZE - VEHICLE_COM_HEADER_LEN];\n} VehicleComFrame;\n\nstatic uint8_t g_com_buffer[VEHICLE_COM_BUFFER_SIZE];\nstatic uint16_t g_current_frame_ptr_offset = 0;\nstatic uint16_t g_buffered_data_len = 0;\n\nvoid init_com_buffer() {\n    memset(g_com_buffer, 0, VEHICLE_COM_BUFFER_SIZE);\n    g_current_frame_ptr_offset = 0;\n    g_buffered_data_len = 0;\n}\n\nbool receive_com_data(const uint8_t* data, uint16_t len) {\n    if (len == 0 || data == NULL || (g_buffered_data_len + len > VEHICLE_COM_BUFFER_SIZE)) {\n        return false;\n    }\n    memcpy(g_com_buffer + g_buffered_data_len, data, len);\n    g_buffered_data_len += len;\n    return true;\n}\n\nbool set_current_frame_offset(uint16_t offset) {\n    if (offset < g_buffered_data_len && offset + VEHICLE_COM_HEADER_LEN <= g_buffered_data_len) {\n        g_current_frame_ptr_offset = offset;\n        return true;\n    }\n    return false;\n}\n\nvoid update_frame_control_field_vulnerable(uint16_t relative_to_frame_start_offset, int16_t internal_adjustment, uint8_t new_value) {\n    int32_t effective_target_idx = (int32_t)g_current_frame_ptr_offset +\n                                   (int32_t)relative_to_frame_start_offset +\n                                   (int32_t)internal_adjustment;\n\n    g_com_buffer[effective_target_idx] = new_value;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_INCOMING_FAULT_MSG_SIZE 256\n#define MAX_FAULT_DESCRIPTION_LEN 64\n\ntypedef enum {\n    SEVERITY_INFO = 0,\n    SEVERITY_WARNING,\n    SEVERITY_CRITICAL\n} FaultSeverity;\n\ntypedef struct {\n    uint16_t      fault_id;\n    FaultSeverity severity;\n    char          description[MAX_FAULT_DESCRIPTION_LEN];\n} ParsedFaultEntry;\n\nstatic ParsedFaultEntry g_lastFaultEntry;\n\nvoid initFaultEntry() {\n    memset(&g_lastFaultEntry, 0, sizeof(ParsedFaultEntry));\n}\n\nint processFaultMessage(const uint8_t* raw_msg, uint16_t msg_len) {\n    if (raw_msg == NULL || msg_len < (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    if (msg_len > MAX_INCOMING_FAULT_MSG_SIZE) {\n        return -2;\n    }\n\n    uint16_t current_offset = 0;\n\n    g_lastFaultEntry.fault_id = (raw_msg[current_offset] << 8) | raw_msg[current_offset + 1];\n    current_offset += sizeof(uint16_t);\n\n    g_lastFaultEntry.severity = (FaultSeverity)raw_msg[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    uint8_t incoming_description_len = raw_msg[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    if (current_offset + incoming_description_len > msg_len) {\n        return -3;\n    }\n\n    memcpy(g_lastFaultEntry.description, raw_msg + current_offset, incoming_description_len);\n\n    if (incoming_description_len < MAX_FAULT_DESCRIPTION_LEN) {\n        g_lastFaultEntry.description[incoming_description_len] = '\\0';\n    } else {\n        g_lastFaultEntry.description[MAX_FAULT_DESCRIPTION_LEN - 1] = '\\0';\n    }\n\n    return 0;\n}\n\nconst ParsedFaultEntry* getLastFaultEntry() {\n    return &g_lastFaultEntry;\n}\n\nvoid receiveSimulatedFaultData(const uint8_t* data, uint16_t len) {\n    processFaultMessage(data, len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_EVENT_BUFFER_SIZE 512\n#define MAX_EVENT_DESCRIPTION_LEN 100\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp;\n    uint8_t  severity;\n    uint8_t  description_len; \n} DiagnosticEventHeader;\n\nstatic uint8_t g_eventRecordBuffer[DIAG_EVENT_BUFFER_SIZE];\nstatic uint16_t g_bufferWritePointer = 0;\n\nvoid initDiagnosticRecorder() {\n    memset(g_eventRecordBuffer, 0, DIAG_EVENT_BUFFER_SIZE);\n    g_bufferWritePointer = 0;\n}\n\nint recordDiagnosticEvent(uint16_t id, uint32_t ts, uint8_t sev, const char* desc, uint8_t desc_len) {\n    uint16_t fixed_header_size = sizeof(DiagnosticEventHeader);\n    uint16_t total_event_size_to_write = fixed_header_size + desc_len;\n\n    if (total_event_size_to_write > DIAG_EVENT_BUFFER_SIZE) {\n        return -1;\n    }\n\n    uint16_t write_start_pos = g_bufferWritePointer;\n    if (write_start_pos + total_event_size_to_write > DIAG_EVENT_BUFFER_SIZE) {\n        write_start_pos = 0;\n    }\n\n    uint8_t* current_write_ptr = g_eventRecordBuffer + write_start_pos;\n\n    *(uint16_t*)current_write_ptr = id;\n    current_write_ptr += sizeof(uint16_t);\n    *(uint32_t*)current_write_ptr = ts;\n    current_write_ptr += sizeof(uint32_t);\n    *current_write_ptr = sev;\n    current_write_ptr += sizeof(uint8_t);\n    *current_write_ptr = desc_len; \n    current_write_ptr += sizeof(uint8_t);\n\n    memcpy(current_write_ptr, desc, desc_len);\n\n    g_bufferWritePointer = (write_start_pos + total_event_size_to_write) % DIAG_EVENT_BUFFER_SIZE;\n\n    return 0;\n}\n\nvoid simulateIncomingEvent(uint16_t id, uint32_t ts, uint8_t sev, const char* desc, uint8_t desc_len) {\n    recordDiagnosticEvent(id, ts, sev, desc, desc_len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n// Represents a sub-message header within a larger diagnostic packet\nstruct DiagnosticSubMessageHeader {\n    uint16_t message_id;\n    uint16_t payload_length; // Actual length of payload for this sub-message\n};\n\n// Represents the overall diagnostic packet header\nstruct DiagnosticPacketHeader {\n    uint16_t packet_type;\n    uint16_t num_sub_messages;\n    uint32_t max_expected_sub_message_payload_len; // Max payload size for ANY sub-message in this packet\n};\n\nclass DiagnosticDataProcessorVulnerable {\npublic:\n    DiagnosticDataProcessorVulnerable() : m_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~DiagnosticDataProcessorVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool processPacketVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeader* header = reinterpret_cast<const DiagnosticPacketHeader*>(raw_packet);\n\n        // Calculate total space needed for all sub-messages' payloads based on the MAX expected length.\n        // This multiplication is vulnerable to integer overflow. If num_sub_messages and\n        // max_expected_sub_message_payload_len are large, their product can exceed UINT32_MAX.\n        // E.g., num_sub_messages = 2, max_expected_sub_message_payload_len = 0x80000000 (2GB).\n        // The product 2 * 0x80000000 = 0x100000000 (4GB) will wrap around to 0 in a uint32_t.\n        uint32_t total_payload_data_space = header->num_sub_messages * header->max_expected_sub_message_payload_len; // Vulnerable point\n\n        // Add space for all sub-message headers\n        size_t total_headers_space = (size_t)header->num_sub_messages * sizeof(DiagnosticSubMessageHeader);\n        \n        // Calculate the total allocation size for the internal buffer.\n        // If total_payload_data_space wrapped to 0 due to the overflow, this size will be very small.\n        size_t total_allocation_size = total_payload_data_space + total_headers_space;\n\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n        \n        // Allocate the buffer. If total_allocation_size was truncated, this allocation is too small.\n        m_buffer = (uint8_t*)malloc(total_allocation_size);\n        if (!m_buffer) {\n            m_buffer_capacity = 0;\n            return false;\n        }\n        m_buffer_capacity = total_allocation_size;\n\n        uint8_t* current_write_ptr = m_buffer;\n        const uint8_t* current_read_ptr = raw_packet + sizeof(DiagnosticPacketHeader);\n        size_t remaining_packet_data = packet_len - sizeof(DiagnosticPacketHeader);\n\n        for (uint16_t i = 0; i < header->num_sub_messages; ++i) {\n            // Basic validation for sub-message header presence in source packet\n            if (remaining_packet_data < sizeof(DiagnosticSubMessageHeader)) {\n                return false; // Malformed packet or truncated\n            }\n\n            const DiagnosticSubMessageHeader* sub_header = reinterpret_cast<const DiagnosticSubMessageHeader*>(current_read_ptr);\n            uint16_t actual_payload_len = sub_header->payload_length;\n\n            // Validate actual payload length against remaining source packet data\n            if (remaining_packet_data - sizeof(DiagnosticSubMessageHeader) < actual_payload_len) {\n                return false; // Not enough source data for declared payload\n            }\n            \n            // --- Heap-based Buffer Overflow happens here ---\n            // No check is performed to ensure that 'current_write_ptr + sizeof(DiagnosticSubMessageHeader) + actual_payload_len'\n            // does not exceed 'm_buffer + m_buffer_capacity'.\n            // If total_allocation_size was truncated due to the integer overflow mentioned above,\n            // and actual_payload_len is still large (even if it respects the max_expected_sub_message_payload_len from the header),\n            // this memcpy will write beyond the bounds of the undersized m_buffer.\n            \n            // Copy sub-message header\n            memcpy(current_write_ptr, sub_header, sizeof(DiagnosticSubMessageHeader));\n            current_write_ptr += sizeof(DiagnosticSubMessageHeader);\n\n            // Copy sub-message payload\n            memcpy(current_write_ptr, current_read_ptr + sizeof(DiagnosticSubMessageHeader), actual_payload_len); // Direct copy\n            current_write_ptr += actual_payload_len;\n\n            current_read_ptr += sizeof(DiagnosticSubMessageHeader) + actual_payload_len;\n            remaining_packet_data -= (sizeof(DiagnosticSubMessageHeader) + actual_payload_len);\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedData() const { return m_buffer; }\n    size_t getProcessedDataCapacity() const { return m_buffer_capacity; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_buffer_capacity;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VLAN_PROFILES 16 \n#define BITMAP_SIZE_BITS 32 \n\ntypedef struct {\n    uint16_t vlan_id;\n    uint8_t priority_tag;\n    bool enable_filtering;\n    uint32_t reserved_flags;\n} VlanProfile;\n\nstatic VlanProfile g_vlanProfiles_fixed[MAX_VLAN_PROFILES];\n\nstatic uint32_t g_activeVlanProfileBitmap_fixed;\n\nvoid log_ethernet_event_fixed(const char* event_msg) {\n}\n\nvoid simulate_config_reception_fixed() {\n    g_activeVlanProfileBitmap_fixed = (1U << 0) | (1U << 5) | (1U << 20); \n}\n\nvoid initialize_vlan_profiles_fixed() {\n    for (uint8_t i = 0; i < MAX_VLAN_PROFILES; ++i) {\n        g_vlanProfiles_fixed[i].vlan_id = 0;\n        g_vlanProfiles_fixed[i].priority_tag = 0;\n        g_vlanProfiles_fixed[i].enable_filtering = false;\n        g_vlanProfiles_fixed[i].reserved_flags = 0;\n    }\n    log_ethernet_event_fixed(\"VLAN profiles initialized.\");\n}\n\nvoid apply_vlan_profile_to_hardware_fixed(uint8_t profile_index) {\n    VlanProfile current_profile = g_vlanProfiles_fixed[profile_index];\n    log_ethernet_event_fixed(\"Applying VLAN profile to hardware.\");\n}\n\nvoid process_active_vlan_configurations_fixed() {\n    log_ethernet_event_fixed(\"Processing active VLAN configurations.\");\n\n    for (uint8_t i = 0; i < BITMAP_SIZE_BITS; ++i) {\n        if ((g_activeVlanProfileBitmap_fixed >> i) & 1) {\n            if (i < MAX_VLAN_PROFILES) { \n                apply_vlan_profile_to_hardware_fixed(i);\n            } else {\n                log_ethernet_event_fixed(\"Attempted to apply VLAN profile with out-of-bounds index. Ignoring.\");\n            }\n        }\n    }\n    log_ethernet_event_fixed(\"Finished processing VLAN configurations.\");\n}\n\nvoid ethernet_switch_manager_main_fixed() {\n    initialize_vlan_profiles_fixed();\n    simulate_config_reception_fixed();\n    process_active_vlan_configurations_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stbool.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE_FIXED 512\n#define CONFIG_BLOCK_HEADER_SIZE_FIXED 8\n#define MAX_CONFIG_PAYLOAD_FIXED (VEHICLE_CONFIG_BUFFER_SIZE_FIXED - CONFIG_BLOCK_HEADER_SIZE_FIXED)\n\n#define GLOBAL_METADATA_OFFSET_FIXED 16\n\nstatic uint8_t g_vehicle_config_buffer_fixed[VEHICLE_CONFIG_BUFFER_SIZE_FIXED];\nstatic uint8_t* g_config_data_start_ptr_fixed;\nstatic uint16_t g_current_config_data_len_fixed = 0;\n\nvoid init_vehicle_config_manager_fixed() {\n    memset(g_vehicle_config_buffer_fixed, 0, VEHICLE_CONFIG_BUFFER_SIZE_FIXED);\n    g_config_data_start_ptr_fixed = g_vehicle_config_buffer_fixed + GLOBAL_METADATA_OFFSET_FIXED;\n    g_current_config_data_len_fixed = 0;\n\n    g_vehicle_config_buffer_fixed[0] = 0x01;\n    g_vehicle_config_buffer_fixed[1] = 0xAF;\n}\n\nint16_t add_config_block_fixed(uint16_t block_id, uint16_t version, const uint8_t* payload, uint32_t payload_len) {\n    if (payload == NULL || payload_len == 0 || payload_len > MAX_CONFIG_PAYLOAD_FIXED) {\n        return -1;\n    }\n\n    uint32_t block_total_size = CONFIG_BLOCK_HEADER_SIZE_FIXED + payload_len;\n    if (g_current_config_data_len_fixed + block_total_size > (VEHICLE_CONFIG_BUFFER_SIZE_FIXED - GLOBAL_METADATA_OFFSET_FIXED)) {\n        return -1;\n    }\n\n    uint16_t block_start_relative_offset = g_current_config_data_len_fixed;\n    uint8_t* current_write_ptr = g_config_data_start_ptr_fixed + block_start_relative_offset;\n\n    *(uint16_t*)current_write_ptr = block_id;\n    *(uint16_t*)(current_write_ptr + 2) = version;\n    *(uint32_t*)(current_write_ptr + 4) = payload_len;\n\n    memcpy(current_write_ptr + CONFIG_BLOCK_HEADER_SIZE_FIXED, payload, payload_len);\n\n    g_current_config_data_len_fixed += block_total_size;\n    return block_start_relative_offset;\n}\n\nvoid update_global_metadata_fixed(uint16_t config_block_offset, int32_t meta_target_offset, uint8_t value) {\n    uint8_t* potential_target_address = g_config_data_start_ptr_fixed + meta_target_offset;\n\n    if (potential_target_address < g_vehicle_config_buffer_fixed ||\n        potential_target_address >= (g_vehicle_config_buffer_fixed + VEHICLE_CONFIG_BUFFER_SIZE_FIXED)) {\n        return;\n    }\n\n    if (potential_target_address >= g_config_data_start_ptr_fixed) {\n        return;\n    }\n\n    *potential_target_address = value;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_CAN_DATA_ELEMENTS 100\n#define MAX_ITEM_TYPES 5\n\ntypedef struct {\n    uint32_t value;\n    uint8_t status;\n} DataElement;\n\nstatic DataElement g_configDataElements_fixed[MAX_CAN_DATA_ELEMENTS];\n\ntypedef struct {\n    uint8_t start_idx;\n    uint8_t num_elements;\n} ItemMapping;\n\nstatic const ItemMapping g_itemMaps_fixed[MAX_ITEM_TYPES] = {\n    {0, 10}, \n    {10, 20}, \n    {30, 5},  \n    {35, 15}, \n    {50, 50}  \n};\n\ntypedef struct {\n    uint8_t item_type_id;  \n    uint8_t item_offset;   \n    uint32_t new_value;\n} CANConfigCommand_fixed;\n\nvoid log_automotive_security_event_fixed(const char* msg) {\n}\n\nCANConfigCommand_fixed receive_can_config_command_fixed() {\n    CANConfigCommand_fixed cmd;\n    cmd.item_type_id = 1; \n    cmd.item_offset = 20; \n    cmd.new_value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initialize_config_data_fixed() {\n    for (uint16_t i = 0; i < MAX_CAN_DATA_ELEMENTS; ++i) {\n        g_configDataElements_fixed[i] = (DataElement){0, 0};\n    }\n    \n    g_configDataElements_fixed[30].value = 0x11223344;\n    g_configDataElements_fixed[30].status = 0xA5;\n}\n\nvoid process_can_config_update_fixed() {\n    CANConfigCommand_fixed cmd = receive_can_config_command_fixed();\n\n    if (cmd.item_type_id < MAX_ITEM_TYPES) {\n        if (cmd.item_offset < g_itemMaps_fixed[cmd.item_type_id].num_elements) {\n            uint8_t base_index = g_itemMaps_fixed[cmd.item_type_id].start_idx;\n            uint8_t global_index = base_index + cmd.item_offset;\n\n            if (global_index < MAX_CAN_DATA_ELEMENTS) {\n                g_configDataElements_fixed[global_index].value = cmd.new_value;\n                g_configDataElements_fixed[global_index].status = 1;\n            } else {\n                log_automotive_security_event_fixed(\"CAN config update: Internal error - calculated global index out of overall array bounds despite local validation.\");\n            }\n        } else {\n            log_automotive_security_event_fixed(\"CAN config update: Item offset out of bounds for specified item type.\");\n        }\n    } else {\n        log_automotive_security_event_fixed(\"CAN config update: Invalid item type ID received.\");\n    }\n}\n\nvoid automotive_system_main_fixed() {\n    initialize_config_data_fixed();\n    process_can_config_update_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_MSG_TYPES 3\n#define MAX_SUB_TYPES_PER_MSG 5\n#define PAYLOAD_MAX_SIZE 16\n\nvoid handleMsgType0Sub0_fixed(const uint8_t* payload) {}\nvoid handleMsgType0Sub1_fixed(const uint8_t* payload) {}\nvoid handleMsgType1Sub0_fixed(const uint8_t* payload) {}\nvoid handleMsgType1Sub1_fixed(const uint8_t* payload) {}\nvoid handleMsgType2Sub0_fixed(const uint8_t* payload) {}\n\ntypedef struct {\n    uint8_t msg_id;\n    uint8_t sub_id;\n    uint8_t payload[PAYLOAD_MAX_SIZE];\n    uint8_t payload_len;\n} DiagnosticMessage;\n\nstatic void (*g_diagMsgHandlers_fixed[MAX_MSG_TYPES][MAX_SUB_TYPES_PER_MSG])(const uint8_t* payload);\n\nvoid logECUError_fixed(const char* msg) {}\n\nvoid initializeDiagHandlers_fixed() {\n    for (int i = 0; i < MAX_MSG_TYPES; ++i) {\n        for (int j = 0; j < MAX_SUB_TYPES_PER_MSG; ++j) {\n            g_diagMsgHandlers_fixed[i][j] = NULL;\n        }\n    }\n    g_diagMsgHandlers_fixed[0][0] = handleMsgType0Sub0_fixed;\n    g_diagMsgHandlers_fixed[0][1] = handleMsgType0Sub1_fixed;\n    g_diagMsgHandlers_fixed[1][0] = handleMsgType1Sub0_fixed;\n    g_diagMsgHandlers_fixed[1][1] = handleMsgType1Sub1_fixed;\n    g_diagMsgHandlers_fixed[2][0] = handleMsgType2Sub0_fixed;\n}\n\nDiagnosticMessage receiveDiagnosticMessage_fixed() {\n    DiagnosticMessage msg;\n    msg.msg_id = 1;\n    msg.sub_id = MAX_SUB_TYPES_PER_MSG;\n    msg.payload[0] = 0xAA;\n    msg.payload_len = 1;\n    return msg;\n}\n\nvoid processDiagnosticMessage_fixed() {\n    DiagnosticMessage received_msg = receiveDiagnosticMessage_fixed();\n\n    if (received_msg.msg_id < MAX_MSG_TYPES) {\n        if (received_msg.sub_id < MAX_SUB_TYPES_PER_MSG) { \n            if (g_diagMsgHandlers_fixed[received_msg.msg_id][received_msg.sub_id] != NULL) {\n                g_diagMsgHandlers_fixed[received_msg.msg_id][received_msg.sub_id](received_msg.payload);\n            } else {\n                logECUError_fixed(\"Handler not registered for the given sub_id.\");\n            }\n        } else {\n            logECUError_fixed(\"Sub-ID out of bounds for diagnostic message. Ignoring.\");\n        }\n    } else {\n        logECUError_fixed(\"Invalid message ID received.\");\n    }\n}\n\nvoid main_ecu_loop_fixed() {\n    initializeDiagHandlers_fixed();\n    processDiagnosticMessage_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#define GLOBAL_DATA_STORAGE_SIZE_FIXED 256\n#define MAX_DTC_SEGMENTS_FIXED 4\n\ntypedef struct {\n    uint16_t segment_start_offset;\n    uint16_t segment_actual_size;\n    uint16_t segment_max_offset;\n} DTCSegmentConfig_Fixed;\n\nstatic uint8_t g_dtcDataStorage_fixed[GLOBAL_DATA_STORAGE_SIZE_FIXED];\n\nstatic DTCSegmentConfig_Fixed g_dtcConfigs_fixed[MAX_DTC_SEGMENTS_FIXED];\n\nvoid logSystemOutput_fixed(const char* msg) {\n    printf(\"FIXED_LOG: %s\\n\", msg);\n}\n\nvoid initializeDTCSystem_fixed() {\n    g_dtcConfigs_fixed[0] = (DTCSegmentConfig_Fixed){ .segment_start_offset = 0, .segment_actual_size = 20, .segment_max_offset = 50 };\n    g_dtcConfigs_fixed[1] = (DTCSegmentConfig_Fixed){ .segment_start_offset = 50, .segment_actual_size = 30, .segment_max_offset = 50 };\n    g_dtcConfigs_fixed[2] = (DTCSegmentConfig_Fixed){ .segment_start_offset = 100, .segment_actual_size = 10, .segment_max_offset = 50 };\n    g_dtcConfigs_fixed[3] = (DTCSegmentConfig_Fixed){ .segment_start_offset = 150, .segment_actual_size = 40, .segment_max_offset = 50 };\n\n    for (uint16_t i = 0; i < GLOBAL_DATA_STORAGE_SIZE_FIXED; ++i) {\n        g_dtcDataStorage_fixed[i] = (uint8_t)(i % 0xFF);\n    }\n\n    memset(&g_dtcDataStorage_fixed[g_dtcConfigs_fixed[0].segment_start_offset], 0x11, g_dtcConfigs_fixed[0].segment_actual_size);\n    memset(&g_dtcDataStorage_fixed[g_dtcConfigs_fixed[1].segment_start_offset], 0x22, g_dtcConfigs_fixed[1].segment_actual_size);\n    memset(&g_dtcDataStorage_fixed[g_dtcConfigs_fixed[2].segment_start_offset], 0xAA, g_dtcConfigs_fixed[2].segment_actual_size);\n    memset(&g_dtcDataStorage_fixed[g_dtcConfigs_fixed[3].segment_start_offset], 0x44, g_dtcConfigs_fixed[3].segment_actual_size);\n\n    g_dtcDataStorage_fixed[112] = 0xDD;\n    g_dtcDataStorage_fixed[113] = 0xEE;\n\n    logSystemOutput_fixed(\"DTC system initialized.\");\n}\n\nuint16_t getRequestedDTCID_fixed() {\n    return 0x020C;\n}\n\nuint8_t getDTCFaultValue_fixed(uint16_t dtc_id) {\n    uint8_t segment_idx = (uint8_t)((dtc_id >> 8) & 0xFF);\n    uint8_t relative_offset = (uint8_t)(dtc_id & 0xFF);\n\n    if (segment_idx >= MAX_DTC_SEGMENTS_FIXED) {\n        logSystemOutput_fixed(\"Error: Invalid DTC segment ID (fixed).\\n\");\n        return 0xFF;\n    }\n\n    if (relative_offset >= g_dtcConfigs_fixed[segment_idx].segment_actual_size) {\n        logSystemOutput_fixed(\"Error: Relative offset out of bounds for specified DTC segment (fixed).\\n\");\n        return 0xFF;\n    }\n\n    uint16_t absolute_byte_offset = g_dtcConfigs_fixed[segment_idx].segment_start_offset + relative_offset;\n\n    if (absolute_byte_offset >= GLOBAL_DATA_STORAGE_SIZE_FIXED) {\n        logSystemOutput_fixed(\"Error: Calculated offset exceeds global data storage bounds (fixed).\\n\");\n        return 0xFF;\n    }\n    \n    logSystemOutput_fixed(\"Reading DTC fault value (fixed).\\n\");\n    return g_dtcDataStorage_fixed[absolute_byte_offset];\n}\n\nvoid diagnosticMonitorLoop_fixed() {\n    initializeDTCSystem_fixed();\n\n    uint16_t requested_dtc_id = getRequestedDTCID_fixed();\n    uint8_t fault_value = getDTCFaultValue_fixed(requested_dtc_id);\n    \n    char log_msg[64];\n    sprintf(log_msg, \"Retrieved fault value: 0x%02X (fixed)\", fault_value);\n    logSystemOutput_fixed(log_msg);\n}\n\nvoid automotiveDTCManager_fixed_main() {\n    diagnosticMonitorLoop_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct SensorBatchHeader {\n    uint32_t timestamp;\n    uint16_t num_entries;\n};\n\nstruct SensorEntryHeader {\n    uint8_t  sensor_id;\n    uint16_t data_len;\n};\n#pragma pack(pop)\n\nclass VehicleSensorLoggerFixed {\npublic:\n    VehicleSensorLoggerFixed() :\n        m_log_buffer(nullptr),\n        m_current_buffer_size(0),\n        m_allocated_capacity(0)\n    {\n        m_allocated_capacity = 1024;\n        m_log_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_log_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~VehicleSensorLoggerFixed() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n    }\n\n    bool addSensorBatchFixed(const uint8_t* raw_data_packet, size_t packet_length) {\n        if (!raw_data_packet || packet_length < sizeof(SensorBatchHeader)) {\n            return false;\n        }\n\n        const SensorBatchHeader* batch_hdr = reinterpret_cast<const SensorBatchHeader*>(raw_data_packet);\n        size_t current_packet_offset_scan = sizeof(SensorBatchHeader);\n        size_t total_new_data_size = 0;\n\n        static const uint16_t MAX_BATCH_ENTRIES = 250;\n        if (batch_hdr->num_entries > MAX_BATCH_ENTRIES) {\n            return false;\n        }\n\n        for (uint16_t i = 0; i < batch_hdr->num_entries; ++i) {\n            if (current_packet_offset_scan > (packet_length - sizeof(SensorEntryHeader))) {\n                return false;\n            }\n            const SensorEntryHeader* entry_hdr = reinterpret_cast<const SensorEntryHeader*>(raw_data_packet + current_packet_offset_scan);\n            uint16_t entry_data_len = entry_hdr->data_len;\n\n            if (sizeof(SensorEntryHeader) > (std::numeric_limits<size_t>::max() - total_new_data_size) ||\n                entry_data_len > (std::numeric_limits<size_t>::max() - total_new_data_size - sizeof(SensorEntryHeader))) {\n                return false;\n            }\n            \n            size_t required_entry_size = sizeof(SensorEntryHeader) + entry_data_len;\n            total_new_data_size += required_entry_size;\n            \n            if (current_packet_offset_scan > (packet_length - required_entry_size)) {\n                return false;\n            }\n            current_packet_offset_scan += required_entry_size;\n        }\n\n        if (total_new_data_size > (std::numeric_limits<size_t>::max() - m_current_buffer_size)) {\n            return false;\n        }\n        size_t required_total_space = m_current_buffer_size + total_new_data_size;\n\n        if (required_total_space > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity * 2;\n            if (new_capacity < m_allocated_capacity) {\n                new_capacity = std::numeric_limits<size_t>::max();\n            }\n            \n            if (new_capacity < required_total_space) {\n                new_capacity = required_total_space;\n            }\n\n            static const size_t MAX_LOG_BUFFER_SIZE = 16 * 1024 * 1024;\n            if (new_capacity > MAX_LOG_BUFFER_SIZE) {\n                if (required_total_space > MAX_LOG_BUFFER_SIZE) {\n                    return false;\n                }\n                new_capacity = MAX_LOG_BUFFER_SIZE;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n            if (!new_buffer) {\n                return false;\n            }\n            m_log_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        size_t current_packet_offset_copy = sizeof(SensorBatchHeader);\n        \n        for (uint16_t i = 0; i < batch_hdr->num_entries; ++i) {\n            const SensorEntryHeader* entry_hdr = reinterpret_cast<const SensorEntryHeader*>(raw_data_packet + current_packet_offset_copy);\n            uint16_t entry_data_len = entry_hdr->data_len;\n            size_t bytes_to_copy_for_entry = sizeof(SensorEntryHeader) + entry_data_len;\n\n            if (m_current_buffer_size > (m_allocated_capacity - bytes_to_copy_for_entry)) {\n                return false;\n            }\n\n            m_log_buffer[m_current_buffer_size] = entry_hdr->sensor_id;\n            m_log_buffer[m_current_buffer_size + 1] = (uint8_t)(entry_hdr->data_len & 0xFF);\n            m_log_buffer[m_current_buffer_size + 2] = (uint8_t)((entry_hdr->data_len >> 8) & 0xFF);\n            \n            const uint8_t* payload_src = raw_data_packet + current_packet_offset_copy + sizeof(SensorEntryHeader);\n            for (uint16_t j = 0; j < entry_data_len; ++j) {\n                m_log_buffer[m_current_buffer_size + sizeof(SensorEntryHeader) + j] = payload_src[j];\n            }\n            \n            m_current_buffer_size += bytes_to_copy_for_entry;\n            current_packet_offset_copy += bytes_to_copy_for_entry;\n        }\n\n        return true;\n    }\n\n    size_t getCurrentBufferSize() const { return m_current_buffer_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n    const uint8_t* getLogBuffer() const { return m_log_buffer; }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t m_current_buffer_size;\n    size_t m_allocated_capacity;\n};\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n#pragma pack(push, 1)\nstruct UpdateChunkHeader {\n    uint32_t chunk_id;\n    uint32_t offset;    \n    uint32_t length;    \n    uint32_t crc;\n};\n#pragma pack(pop)\n\nclass ECUFlashUpdaterVulnerable {\npublic:\n    ECUFlashUpdaterVulnerable(size_t staging_buffer_capacity) {\n        if (staging_buffer_capacity > 0) {\n            m_staging_buffer = (uint8_t*)malloc(staging_buffer_capacity);\n            if (m_staging_buffer) {\n                m_capacity = staging_buffer_capacity;\n            } else {\n                m_capacity = 0;\n            }\n        } else {\n            m_capacity = 0;\n            m_staging_buffer = nullptr;\n        }\n    }\n\n    ~ECUFlashUpdaterVulnerable() {\n        if (m_staging_buffer) {\n            free(m_staging_buffer);\n        }\n    }\n\n    bool processUpdateChunkVulnerable(const uint8_t* raw_chunk_packet, size_t packet_len) {\n        if (!m_staging_buffer || !raw_chunk_packet || packet_len < sizeof(UpdateChunkHeader)) {\n            return false;\n        }\n\n        const UpdateChunkHeader* header = reinterpret_cast<const UpdateChunkHeader*>(raw_chunk_packet);\n\n        const uint8_t* chunk_data_payload = raw_chunk_packet + sizeof(UpdateChunkHeader);\n        size_t actual_chunk_data_len = packet_len - sizeof(UpdateChunkHeader);\n\n        if (actual_chunk_data_len != header->length) {\n            return false;\n        }\n\n        uint32_t end_address = header->offset + header->length; \n\n        if (end_address > m_capacity) {\n            return false;\n        }\n\n        uint8_t* dest_ptr = m_staging_buffer + header->offset;\n\n        memcpy(dest_ptr, chunk_data_payload, header->length);\n\n        return true;\n    }\n\n    size_t getCapacity() const { return m_capacity; }\n    const uint8_t* getStagingBuffer() const { return m_staging_buffer; }\n\nprivate:\n    uint8_t* m_staging_buffer;\n    size_t m_capacity;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define SCRATCHPAD_BUFFER_SIZE 128\n#define RAW_DATA_BUFFER_SIZE 512\n\nstatic uint8_t g_raw_data_stream[RAW_DATA_BUFFER_SIZE];\nstatic uint32_t g_raw_data_len = 0;\n\nstatic int32_t g_current_record_offset = 0;\n\nvoid fill_raw_data(const uint8_t* data, uint32_t len)\n{\n    if (len > RAW_DATA_BUFFER_SIZE) {\n        len = RAW_DATA_BUFFER_SIZE;\n    }\n    memcpy(g_raw_data_stream, data, len);\n    g_raw_data_len = len;\n    g_current_record_offset = 0;\n}\n\nvoid process_extracted_record(const uint8_t* record_data, uint32_t record_len)\n{\n}\n\nbool extract_record_to_scratchpad(uint8_t* scratchpad_buffer, uint32_t scratchpad_max_len, uint32_t record_len)\n{\n    if (g_current_record_offset < 0 || g_current_record_offset + record_len > g_raw_data_len || record_len > scratchpad_max_len) {\n        return false;\n    }\n    memcpy(scratchpad_buffer, g_raw_data_stream + g_current_record_offset, record_len);\n    process_extracted_record(scratchpad_buffer, record_len);\n    return true;\n}\n\nvoid recalibrate_record_offset_fixed(int32_t offset_delta)\n{\n    int32_t proposed_offset = g_current_record_offset + offset_delta;\n\n    if (proposed_offset < 0) {\n        proposed_offset = 0;\n    } else if (proposed_offset > (int32_t)g_raw_data_len) {\n        proposed_offset = (int32_t)g_raw_data_len;\n    }\n\n    if (g_raw_data_len > 0 && proposed_offset < (int32_t)g_raw_data_len) {\n        g_raw_data_stream[proposed_offset] = 0x00;\n    }\n\n    g_current_record_offset = proposed_offset;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <string.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n// Vehicle parameter IDs\n#define VEHICLE_PARAM_SENSOR_CALIBRATION_A 0x10\n#define VEHICLE_PARAM_VEHICLE_IDENTIFIER   0x11\n#define VEHICLE_PARAM_DIAG_LIFETIME_COUNTER 0x12\n\n// Maximum length for vehicle identifier string\n#define VEHICLE_IDENTIFIER_MAX_LEN 16\n\n// Structure to hold vehicle configuration parameters\ntypedef struct {\n    uint16_t sensorCalibrationValueA;       // 2 bytes\n    char     vehicleIdentifier[VEHICLE_IDENTIFIER_MAX_LEN]; // 16 bytes buffer for C string\n    uint32_t diagnosticLifetimeCounter;     // 4 bytes\n    uint8_t  featureFlags[4];               // 4 bytes of feature flags\n} VehicleSystemConfiguration;\n\n// Global instance of the vehicle configuration\nstatic VehicleSystemConfiguration g_systemConfig;\n\n// Function to initialize the configuration\nvoid systemConfigInit() {\n    g_systemConfig.sensorCalibrationValueA = 512;\n    strncpy(g_systemConfig.vehicleIdentifier, \"DEFAULT_VIN_XYZ\", VEHICLE_IDENTIFIER_MAX_LEN - 1);\n    g_systemConfig.vehicleIdentifier[VEHICLE_IDENTIFIER_MAX_LEN - 1] = '\\0';\n    g_systemConfig.diagnosticLifetimeCounter = 0;\n    memset(g_systemConfig.featureFlags, 0, sizeof(g_systemConfig.featureFlags));\n}\n\n// Function to process an incoming update request for a specific vehicle parameter\n// This function could be called by a diagnostic service handler or a CAN message handler.\n// paramId: The ID of the parameter to update.\n// data: Pointer to the new data for the parameter.\n// dataLen: The length of the new data in bytes.\nint updateVehicleParameter(uint8_t paramId, const uint8_t* data, uint16_t dataLen) {\n    if (data == NULL || dataLen == 0) {\n        return -1; // Invalid input\n    }\n\n    switch (paramId) {\n        case VEHICLE_PARAM_SENSOR_CALIBRATION_A:\n            if (dataLen == sizeof(uint16_t)) {\n                // Assuming little-endian or byte-order handled by caller/system\n                g_systemConfig.sensorCalibrationValueA = *(uint16_t*)data;\n            } else {\n                return -2; // Incorrect data length for calibration value\n            }\n            break;\n\n        case VEHICLE_PARAM_VEHICLE_IDENTIFIER:\n            // Vulnerability: No explicit length check against VEHICLE_IDENTIFIER_MAX_LEN\n            // The memcpy copies 'dataLen' bytes. If dataLen > VEHICLE_IDENTIFIER_MAX_LEN,\n            // it will write past the end of 'vehicleIdentifier', overflowing into\n            // 'diagnosticLifetimeCounter' and 'featureFlags'.\n            memcpy(g_systemConfig.vehicleIdentifier, data, dataLen);\n            // This line attempts to null-terminate, but only if dataLen < buffer size,\n            // which doesn't protect against overflow if dataLen is too large.\n            if (dataLen < VEHICLE_IDENTIFIER_MAX_LEN) {\n                g_systemConfig.vehicleIdentifier[dataLen] = '\\0';\n            } else {\n                g_systemConfig.vehicleIdentifier[VEHICLE_IDENTIFIER_MAX_LEN - 1] = '\\0';\n            }\n            break;\n\n        case VEHICLE_PARAM_DIAG_LIFETIME_COUNTER:\n            if (dataLen == sizeof(uint32_t)) {\n                g_systemConfig.diagnosticLifetimeCounter = *(uint32_t*)data;\n            } else {\n                return -2; // Incorrect data length for lifetime counter\n            }\n            break;\n\n        default:\n            return -3; // Unknown parameter ID\n    }\n\n    return 0; // Parameter updated successfully\n}\n\n// Example usage context (not part of the vulnerability, just for completeness)\nvoid simulateIncomingMessage(uint8_t id, const uint8_t* payload, uint16_t len) {\n    updateVehicleParameter(id, payload, len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMANDS 32\n#define INITIAL_COMMAND_OFFSET 5 \n\ntypedef enum {\n    CMD_TYPE_NONE = 0,\n    CMD_TYPE_ACCEL,\n    CMD_TYPE_BRAKE,\n    CMD_TYPE_STEER,\n    CMD_TYPE_PARK\n} CommandType;\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    CommandType type;\n    int16_t value;\n    bool is_active;\n} VehicleCommand;\n\nstatic VehicleCommand g_command_log[MAX_COMMANDS];\nstatic uint16_t g_next_write_idx = INITIAL_COMMAND_OFFSET;\nstatic uint16_t g_active_command_count = 0;\n\nvoid init_command_log() {\n    memset(g_command_log, 0, sizeof(g_command_log));\n    g_next_write_idx = INITIAL_COMMAND_OFFSET;\n    g_active_command_count = 0;\n}\n\nbool add_vehicle_command(CommandType type, int16_t value) {\n    if (g_next_write_idx >= MAX_COMMANDS) {\n        return false;\n    }\n    g_command_log[g_next_write_idx].timestamp_ms = 0xDEADBEEF;\n    g_command_log[g_next_write_idx].type = type;\n    g_command_log[g_next_write_idx].value = value;\n    g_command_log[g_next_write_idx].is_active = true;\n\n    g_next_write_idx++;\n    g_active_command_count++;\n    return true;\n}\n\nvoid cancel_command_by_logical_index_vulnerable(int16_t logical_cmd_idx) {\n    int32_t target_phys_idx = (int32_t)INITIAL_COMMAND_OFFSET + logical_cmd_idx;\n\n    if (target_phys_idx >= MAX_COMMANDS) {\n        return;\n    }\n\n    g_command_log[target_phys_idx].is_active = false;\n    g_command_log[target_phys_idx].type = CMD_TYPE_NONE;\n    g_command_log[target_phys_idx].value = 0;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\n// Maximum allowed length for a sanitized string in the UI\n#define MAX_SANITIZED_STRING_LENGTH 2048\n\n// Represents a diagnostic log message structure received from a vehicle ECU\nstruct DiagnosticLogMessage {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t raw_string_length; // Length of the raw description string\n    // raw_description_data follows this struct in the packet\n};\n\n// Represents a processed, sanitized log entry\nstruct SanitizedLogEntry {\n    uint32_t timestamp;\n    uint16_t event_id;\n    char*    sanitized_description; // Heap-allocated, null-terminated\n};\n\nclass TelemetryLogProcessor {\npublic:\n    TelemetryLogProcessor() {}\n\n    ~TelemetryLogProcessor() {\n        clearProcessedLogs();\n    }\n\n    void clearProcessedLogs() {\n        for (auto& entry : m_processed_entries) {\n            if (entry.sanitized_description) {\n                free(entry.sanitized_description);\n            }\n        }\n        m_processed_entries.clear();\n    }\n\n    // Fixed function\n    // Parses a raw packet containing multiple diagnostic log messages\n    // and sanitizes their descriptions for display.\n    bool processRawTelemetryLogsFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticLogMessage)) {\n            return false;\n        }\n\n        clearProcessedLogs();\n\n        size_t current_offset = 0;\n\n        while (current_offset + sizeof(DiagnosticLogMessage) <= packet_len) {\n            const DiagnosticLogMessage* msg_header = reinterpret_cast<const DiagnosticLogMessage*>(raw_packet + current_offset);\n            \n            // Check if the claimed raw_string_length extends beyond the packet boundary\n            if (current_offset + sizeof(DiagnosticLogMessage) + msg_header->raw_string_length > packet_len) {\n                clearProcessedLogs();\n                return false;\n            }\n\n            // FIX: Correctly calculate the maximum required size based on the largest expansion factor (4x for \"[XX]\").\n            // Also, ensure it does not exceed MAX_SANITIZED_STRING_LENGTH.\n            size_t max_expansion_factor = 4; // Max expansion for \"[XX]\" format (e.g., 0x01 becomes \"[01]\")\n            size_t required_chars_for_sanitized_string = msg_header->raw_string_length * max_expansion_factor;\n            \n            // Ensure space for null terminator and apply hard limit\n            size_t allocated_desc_len = std::min(required_chars_for_sanitized_string + 1, (size_t)MAX_SANITIZED_STRING_LENGTH);\n            if (allocated_desc_len == 0) allocated_desc_len = 1; // Always allocate at least 1 byte for null terminator\n\n            char* sanitized_buffer = (char*)malloc(allocated_desc_len);\n            if (!sanitized_buffer) {\n                clearProcessedLogs();\n                return false;\n            }\n\n            SanitizedLogEntry new_entry;\n            new_entry.timestamp = msg_header->timestamp;\n            new_entry.event_id = msg_header->event_id;\n            new_entry.sanitized_description = sanitized_buffer;\n\n            const uint8_t* raw_desc_ptr = raw_packet + current_offset + sizeof(DiagnosticLogMessage);\n            size_t current_sanitized_pos = 0;\n\n            for (uint16_t i = 0; i < msg_header->raw_string_length; ++i) {\n                uint8_t char_code = raw_desc_ptr[i];\n\n                if (char_code >= 0x20 && char_code <= 0x7E) { // Printable ASCII\n                    // FIX: Add bounds check before writing\n                    if (current_sanitized_pos + 1 > allocated_desc_len - 1) { // Check if space for 1 char + null terminator\n                        break; \n                    }\n                    sanitized_buffer[current_sanitized_pos++] = static_cast<char>(char_code);\n                } else {\n                    // Non-printable or control character\n                    if (char_code == '\\n') {\n                        // FIX: Add bounds check before writing\n                        if (current_sanitized_pos + 2 > allocated_desc_len - 1) { // Check space for 2 chars + null terminator\n                            break;\n                        }\n                        sanitized_buffer[current_sanitized_pos++] = '\\\\';\n                        sanitized_buffer[current_sanitized_pos++] = 'n';\n                    } else if (char_code == '\\r') {\n                        // FIX: Add bounds check before writing\n                        if (current_sanitized_pos + 2 > allocated_desc_len - 1) {\n                            break;\n                        }\n                        sanitized_buffer[current_sanitized_pos++] = '\\\\';\n                        sanitized_buffer[current_sanitized_pos++] = 'r';\n                    } else if (char_code == '\\t') {\n                        // FIX: Add bounds check before writing\n                        if (current_sanitized_pos + 2 > allocated_desc_len - 1) {\n                            break;\n                        }\n                        sanitized_buffer[current_sanitized_pos++] = '\\\\';\n                        sanitized_buffer[current_sanitized_pos++] = 't';\n                    } else {\n                        // For other control characters, represent as \"[XX]\" (4 chars)\n                        // FIX: Add bounds check before writing\n                        if (current_sanitized_pos + 4 > allocated_desc_len - 1) { // Check space for 4 chars + null terminator\n                            break;\n                        }\n                        sanitized_buffer[current_sanitized_pos++] = '[';\n                        sanitized_buffer[current_sanitized_pos++] = (char_code / 16 < 10 ? '0' + char_code / 16 : 'A' + char_code / 16 - 10);\n                        sanitized_buffer[current_sanitized_pos++] = (char_code % 16 < 10 ? '0' + char_code % 16 : 'A' + char_code % 16 - 10);\n                        sanitized_buffer[current_sanitized_pos++] = ']';\n                    }\n                }\n            }\n            sanitized_buffer[current_sanitized_pos] = '\\0'; // Always null-terminate safely\n\n            m_processed_entries.push_back(new_entry);\n\n            current_offset += sizeof(DiagnosticLogMessage) + msg_header->raw_string_length;\n        }\n\n        return true;\n    }\n\n    const std::vector<SanitizedLogEntry>& getProcessedEntries() const {\n        return m_processed_entries;\n    }\n\nprivate:\n    std::vector<SanitizedLogEntry> m_processed_entries;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\nstruct CalibrationPoint {\n    uint32_t timestamp;\n    int16_t value;\n};\n\nstruct CalibrationPacketHeader {\n    uint16_t packet_magic;\n    uint16_t num_calibration_points;\n    uint8_t  _reserved[4];\n};\n\nclass CalibrationManager {\nprivate:\n    CalibrationPoint* m_current_calibration_data;\n    size_t m_allocated_buffer_size_bytes;\n    size_t m_active_points_count;\n\npublic:\n    CalibrationManager() : m_current_calibration_data(nullptr), m_allocated_buffer_size_bytes(0), m_active_points_count(0) {}\n\n    ~CalibrationManager() {\n        if (m_current_calibration_data) {\n            free(m_current_calibration_data);\n            m_current_calibration_data = nullptr;\n        }\n    }\n\n    void clearCalibrationData() {\n        if (m_current_calibration_data) {\n            free(m_current_calibration_data);\n            m_current_calibration_data = nullptr;\n        }\n        m_allocated_buffer_size_bytes = 0;\n        m_active_points_count = 0;\n    }\n\n    bool processCalibrationPacketFixed(const uint8_t* packet_buffer, size_t buffer_length) {\n        if (!packet_buffer || buffer_length < sizeof(CalibrationPacketHeader)) {\n            return false;\n        }\n\n        const CalibrationPacketHeader* header = reinterpret_cast<const CalibrationPacketHeader*>(packet_buffer);\n\n        if (header->packet_magic != 0xABCD) {\n            return false;\n        }\n\n        uint16_t num_points = header->num_calibration_points;\n\n        // FIX: Add a reasonable maximum limit to prevent excessive memory allocation (DoS)\n        static const uint16_t MAX_POINTS_ALLOWED = 10000;\n        if (num_points > MAX_POINTS_ALLOWED) {\n            return false;\n        }\n\n        // Calculate expected total data size for the points payload.\n        // FIX: Add integer overflow checks for multiplication and addition.\n        size_t expected_payload_bytes;\n        if (num_points > 0 && SIZE_MAX / sizeof(CalibrationPoint) < num_points) {\n            return false; \n        }\n        expected_payload_bytes = num_points * sizeof(CalibrationPoint);\n        \n        size_t total_expected_packet_size;\n        if (SIZE_MAX - sizeof(CalibrationPacketHeader) < expected_payload_bytes) {\n            return false; \n        }\n        total_expected_packet_size = sizeof(CalibrationPacketHeader) + expected_payload_bytes;\n\n        if (buffer_length < total_expected_packet_size) {\n            return false;\n        }\n\n        clearCalibrationData();\n\n        // FIX: Correct size calculation for malloc by using the actual size of CalibrationPoint.\n        m_current_calibration_data = (CalibrationPoint*)malloc(expected_payload_bytes);\n\n        if (!m_current_calibration_data && num_points > 0) {\n            return false;\n        }\n        m_allocated_buffer_size_bytes = expected_payload_bytes;\n\n        const uint8_t* data_ptr = packet_buffer + sizeof(CalibrationPacketHeader);\n        size_t current_data_offset = 0;\n\n        for (uint16_t i = 0; i < num_points; ++i) {\n            // No explicit bounds checks needed here anymore for writing to 'm_current_calibration_data'\n            // because the buffer is now correctly sized and 'i' iterates up to 'num_points - 1'.\n\n            // Read timestamp (uint32_t) from packet and write to heap buffer\n            m_current_calibration_data[i].timestamp = (uint32_t)data_ptr[current_data_offset] |\n                                                      ((uint32_t)data_ptr[current_data_offset + 1] << 8) |\n                                                      ((uint32_t)data_ptr[current_data_offset + 2] << 16) |\n                                                      ((uint32_t)data_ptr[current_data_offset + 3] << 24);\n            current_data_offset += sizeof(uint32_t);\n\n            // Read value (int16_t) from packet and write to heap buffer\n            m_current_calibration_data[i].value = (int16_t)data_ptr[current_data_offset] |\n                                                  ((int16_t)data_ptr[current_data_offset + 1] << 8);\n            current_data_offset += sizeof(int16_t);\n        }\n\n        m_active_points_count = num_points;\n        return true;\n    }\n\n    size_t getActivePointsCount() const {\n        return m_active_points_count;\n    }\n\n    const CalibrationPoint* getCalibrationData() const {\n        return m_current_calibration_data;\n    }\n};\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_ENGINE_CALIBRATION_POINTS 100\n#define MAX_PAYLOAD_FOR_CALIBRATION 512\n\ntypedef struct {\n    uint16_t rpm_target;\n    uint16_t fuel_injection_pulse;\n} EngineCalibrationPoint;\n\nstatic EngineCalibrationPoint g_engineCalibrationTable[MAX_ENGINE_CALIBRATION_POINTS];\n\nvoid initEngineCalibration() {\n    memset(g_engineCalibrationTable, 0, sizeof(g_engineCalibrationTable));\n    for (int i = 0; i < MAX_ENGINE_CALIBRATION_POINTS; ++i) {\n        g_engineCalibrationTable[i].rpm_target = 800 + i * 10;\n        g_engineCalibrationTable[i].fuel_injection_pulse = 100 + i * 2;\n    }\n}\n\nint updateEngineCalibration(const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len < 4) {\n        return -1;\n    }\n\n    uint16_t start_index = (payload[0] << 8) | payload[1];\n    uint16_t num_points = (payload[2] << 8) | payload[3];\n\n    uint16_t data_offset = 4;\n    uint16_t expected_data_len = num_points * sizeof(EngineCalibrationPoint);\n\n    if (data_offset + expected_data_len > payload_len) {\n        return -2;\n    }\n    \n    if (start_index >= MAX_ENGINE_CALIBRATION_POINTS) {\n        return -3;\n    }\n\n    for (uint16_t i = 0; i < num_points; ++i) {\n        uint16_t current_data_ptr_offset = data_offset + (i * sizeof(EngineCalibrationPoint));\n        \n        g_engineCalibrationTable[start_index + i].rpm_target = \n            (payload[current_data_ptr_offset] << 8) | payload[current_data_ptr_offset + 1];\n        g_engineCalibrationTable[start_index + i].fuel_injection_pulse = \n            (payload[current_data_ptr_offset + 2] << 8) | payload[current_data_ptr_offset + 3];\n    }\n\n    return 0;\n}\n\nvoid simulateCanMessage(const uint8_t* data, uint16_t len) {\n    updateEngineCalibration(data, len);\n}\n\nEngineCalibrationPoint getCalibrationPoint(uint16_t index) {\n    if (index < MAX_ENGINE_CALIBRATION_POINTS) {\n        return g_engineCalibrationTable[index];\n    }\n    EngineCalibrationPoint invalid = {0,0};\n    return invalid;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_SUBSYSTEM_PARAMS 10\n#define MAX_PARAM_DATA_SIZE 64 \n\ntypedef struct {\n    uint8_t* param_data_ptr;\n    uint16_t param_data_size;\n    bool is_initialized;\n} SubsystemParameter;\n\nstatic uint8_t engineParamBuffer1[20];\nstatic uint8_t engineParamBuffer2[10];\nstatic uint8_t engineParamBuffer3[30];\n\nstatic SubsystemParameter g_engineParameters[MAX_SUBSYSTEM_PARAMS];\n\nvoid initializeEngineParameters() {\n    memset(g_engineParameters, 0, sizeof(g_engineParameters));\n    \n    g_engineParameters[0] = (SubsystemParameter){.param_data_ptr = engineParamBuffer1, .param_data_size = sizeof(engineParamBuffer1), .is_initialized = true};\n    g_engineParameters[1] = (SubsystemParameter){.param_data_ptr = engineParamBuffer2, .param_data_size = sizeof(engineParamBuffer2), .is_initialized = true};\n    g_engineParameters[2] = (SubsystemParameter){.param_data_ptr = engineParamBuffer3, .param_data_size = sizeof(engineParamBuffer3), .is_initialized = true};\n}\n\n#define DIAG_SERVICE_READ_PARAM 0x22\n#define DIAG_RESPONSE_HEADER_SIZE 3 \n#define DIAG_MAX_RESPONSE_DATA_SIZE 128 \n\nint handleReadParameterRequest(const uint8_t* request_msg, uint16_t request_len, uint8_t* response_buffer, uint16_t* response_len) {\n    if (request_msg == NULL || response_buffer == NULL || response_len == NULL || request_len < 6) {\n        return -1; \n    }\n\n    if (request_msg[0] != DIAG_SERVICE_READ_PARAM) {\n        return -2; \n    }\n\n    uint8_t param_idx = request_msg[1];\n    uint16_t fragment_offset = (request_msg[2] << 8) | request_msg[3];\n    uint16_t fragment_length = (request_msg[4] << 8) | request_msg[5];\n\n    if (param_idx >= MAX_SUBSYSTEM_PARAMS) {\n        return -3; \n    }\n\n    SubsystemParameter* param = &g_engineParameters[param_idx];\n\n    if (!param->is_initialized || param->param_data_ptr == NULL) {\n        return -4; \n    }\n    \n    if (fragment_offset >= param->param_data_size || (uint32_t)fragment_offset + fragment_length > param->param_data_size) {\n        return -5; \n    }\n\n    uint16_t actual_read_length = fragment_length;\n    if (actual_read_length > (DIAG_MAX_RESPONSE_DATA_SIZE - DIAG_RESPONSE_HEADER_SIZE)) {\n        actual_read_length = DIAG_MAX_RESPONSE_DATA_SIZE - DIAG_RESPONSE_HEADER_SIZE;\n    }\n    if (actual_read_length > (param->param_data_size - fragment_offset)) {\n        actual_read_length = param->param_data_size - fragment_offset;\n    }\n\n    response_buffer[0] = DIAG_SERVICE_READ_PARAM | 0x40; \n    response_buffer[1] = 0x00; \n    response_buffer[2] = (uint8_t)actual_read_length; \n\n    for (uint16_t i = 0; i < actual_read_length; ++i) {\n        response_buffer[DIAG_RESPONSE_HEADER_SIZE + i] = param->param_data_ptr[fragment_offset + i];\n    }\n    *response_len = DIAG_RESPONSE_HEADER_SIZE + actual_read_length;\n\n    return 0;\n}\n\nvoid processDiagnosticRequest(const uint8_t* msg, uint16_t len, uint8_t* resp_buf, uint16_t* resp_len) {\n    if (!g_engineParameters[0].is_initialized) {\n        initializeEngineParameters();\n    }\n    handleReadParameterRequest(msg, len, resp_buf, resp_len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_LOG_BUFFER_SIZE 4096\n#define MAX_DTC_SNAPSHOT_DATA 1024\n\ntypedef struct {\n    uint16_t dtcCode;\n    uint32_t timestamp;\n    uint16_t snapshotDataLen;\n} DiagLogEntryHeader;\n\nstatic uint8_t g_diagLogBuffer[DIAG_LOG_BUFFER_SIZE];\nstatic uint32_t g_logWritePointer = 0;\n\nvoid initDiagnosticLog() {\n    memset(g_diagLogBuffer, 0, DIAG_LOG_BUFFER_SIZE);\n    g_logWritePointer = 0;\n}\n\nint addDiagnosticEventToLog(uint16_t dtc, uint32_t timestamp, const uint8_t* snapshot_data, uint16_t snapshot_data_len) {\n    if (snapshot_data == NULL && snapshot_data_len > 0) {\n        return -1;\n    }\n\n    if (snapshot_data_len > MAX_DTC_SNAPSHOT_DATA) {\n        return -2;\n    }\n\n    uint32_t entry_header_size = sizeof(DiagLogEntryHeader);\n    uint32_t entry_total_size = entry_header_size + snapshot_data_len;\n\n    if (entry_total_size > DIAG_LOG_BUFFER_SIZE) {\n        return -3;\n    }\n\n    if (g_logWritePointer + entry_total_size > DIAG_LOG_BUFFER_SIZE) {\n        g_logWritePointer = 0;\n    }\n\n    DiagLogEntryHeader header;\n    header.dtcCode = dtc;\n    header.timestamp = timestamp;\n    header.snapshotDataLen = snapshot_data_len;\n\n    memcpy(g_diagLogBuffer + g_logWritePointer, &header, entry_header_size);\n    g_logWritePointer += entry_header_size;\n\n    memcpy(g_diagLogBuffer + g_logWritePointer, snapshot_data, snapshot_data_len);\n    g_logWritePointer += snapshot_data_len;\n\n    return 0;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_DIAG_LOG_BUFFER_SIZE 256\n#define DIAG_RECORD_MAX_DATA_LEN 100 \n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t flags;\n    uint8_t data_len; \n} DiagLogRecordHeader;\n\nstatic uint8_t g_diagLogBuffer[VEHICLE_DIAG_LOG_BUFFER_SIZE];\nstatic uint16_t g_logWriteCursor = 0; \n\nvoid initDiagLogger() {\n    memset(g_diagLogBuffer, 0, VEHICLE_DIAG_LOG_BUFFER_SIZE);\n    g_logWriteCursor = 0;\n}\n\nint storeDiagEvent(const uint8_t* record_payload, uint16_t payload_total_len) {\n    if (record_payload == NULL || payload_total_len < sizeof(DiagLogRecordHeader)) {\n        return -1;\n    }\n\n    uint8_t record_type = record_payload[0];\n    uint8_t flags = record_payload[1];\n    uint8_t data_len = record_payload[2];\n\n    if (data_len > DIAG_RECORD_MAX_DATA_LEN) {\n        return -2;\n    }\n    \n    uint16_t current_record_size = sizeof(DiagLogRecordHeader) + data_len;\n\n    if (payload_total_len < current_record_size) {\n        return -3;\n    }\n\n    uint16_t effective_write_pos = g_logWriteCursor;\n\n    if (effective_write_pos + current_record_size >= VEHICLE_DIAG_LOG_BUFFER_SIZE) { \n        effective_write_pos = 0;\n        if (current_record_size > VEHICLE_DIAG_LOG_BUFFER_SIZE) {\n            return -4;\n        }\n    }\n\n    g_diagLogBuffer[effective_write_pos++] = record_type;\n    g_diagLogBuffer[effective_write_pos++] = flags;\n    g_diagLogBuffer[effective_write_pos++] = data_len;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_diagLogBuffer[effective_write_pos + i] = record_payload[sizeof(DiagLogRecordHeader) + i];\n    }\n\n    g_logWriteCursor = (effective_write_pos + data_len) % VEHICLE_DIAG_LOG_BUFFER_SIZE;\n\n    return 0;\n}\n\nvoid receiveNewDiagEventMessage(const uint8_t* msg, uint16_t len) {\n    if (g_logWriteCursor == 0) {\n        initDiagLogger();\n    }\n    storeDiagEvent(msg, len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_MSG_SIZE 1024\n#define DIAG_DATA_RECORD_BUF_SIZE 100\n\n#define DIAG_CMD_READ_DATA_BY_ID 0x22\n#define DIAG_CMD_WRITE_DATA_BY_ID 0x2E\n#define DIAG_CMD_ROUTINE_CONTROL 0x31\n\ntypedef struct {\n    uint8_t service_id;\n    uint16_t data_identifier;\n    uint16_t data_offset_in_pdu;\n    uint16_t data_length;\n} DiagServiceRecordHeader;\n\nstatic uint8_t g_currentDiagPDU[MAX_DIAG_MSG_SIZE];\nstatic uint16_t g_currentPDULength = 0;\n\nstatic uint8_t g_dataRecordProcessingBuffer[DIAG_DATA_RECORD_BUF_SIZE];\n\nvoid resetDiagnosticPDU() {\n    memset(g_currentDiagPDU, 0, sizeof(g_currentDiagPDU));\n    g_currentPDULength = 0;\n}\n\nint receiveDiagnosticPDU(const uint8_t* pdu_data, uint16_t pdu_len) {\n    if (pdu_data == NULL || pdu_len == 0 || pdu_len > MAX_DIAG_MSG_SIZE) {\n        return -1;\n    }\n    memcpy(g_currentDiagPDU, pdu_data, pdu_len);\n    g_currentPDULength = pdu_len;\n    return 0;\n}\n\nint processDiagDataRecordPayload(const DiagServiceRecordHeader* record_header) {\n    if (record_header == NULL) {\n        return -1;\n    }\n\n    uint16_t payload_offset = record_header->data_offset_in_pdu;\n    uint16_t payload_len = record_header->data_length;\n\n    if (payload_offset + payload_len > g_currentPDULength) {\n        return -1;\n    }\n\n    const uint8_t* source_ptr = g_currentDiagPDU + payload_offset;\n\n    memcpy(g_dataRecordProcessingBuffer, source_ptr, payload_len);\n\n    if (record_header->service_id == DIAG_CMD_READ_DATA_BY_ID) {\n\n    } else if (record_header->service_id == DIAG_CMD_WRITE_DATA_BY_ID) {\n\n    }\n    \n    return 0;\n}\n\nint handleIncomingDiagnosticMessage(const uint8_t* raw_pdu, uint16_t raw_pdu_len) {\n    if (receiveDiagnosticPDU(raw_pdu, raw_pdu_len) != 0) {\n        return -1;\n    }\n\n    if (raw_pdu_len < sizeof(DiagServiceRecordHeader)) {\n        return -1;\n    }\n\n    DiagServiceRecordHeader parsed_header;\n    memcpy(&parsed_header, g_currentDiagPDU, sizeof(DiagServiceRecordHeader));\n\n    return processDiagDataRecordPayload(&parsed_header);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CALIBRATION_POOL_SIZE 512\n#define NUM_CALIBRATION_BLOCKS 4\n\ntypedef struct {\n    uint16_t base_address; \n    uint16_t length;       \n    bool     is_active;    \n} CalibrationBlock;\n\nstatic uint8_t g_calibration_pool[CALIBRATION_POOL_SIZE];\n\nstatic CalibrationBlock g_calibration_blocks[NUM_CALIBRATION_BLOCKS] = {\n    { .base_address = 0,   .length = 100, .is_active = true },  \n    { .base_address = 100, .length = 150, .is_active = true },  \n    { .base_address = 250, .length = 50,  .is_active = true },  \n    { .base_address = 300, .length = 200, .is_active = true }   \n};\n\nvoid init_calibration_manager_vulnerable() {\n    memset(g_calibration_pool, 0xFF, CALIBRATION_POOL_SIZE);\n}\n\nuint8_t read_calibration_byte_vulnerable(uint8_t block_id, int16_t relative_offset) {\n    if (block_id >= NUM_CALIBRATION_BLOCKS || !g_calibration_blocks[block_id].is_active) {\n        return 0xFF;\n    }\n\n    CalibrationBlock* block = &g_calibration_blocks[block_id];\n    int32_t absolute_idx = (int32_t)block->base_address + relative_offset;\n\n    if (absolute_idx < 0 || absolute_idx >= CALIBRATION_POOL_SIZE) {\n        return 0xFF;\n    }\n\n    if (relative_offset < 0 || relative_offset >= block->length) {\n        return 0xFF;\n    }\n\n    return g_calibration_pool[absolute_idx];\n}\n\nvoid update_calibration_value_vulnerable(uint8_t block_id, int16_t relative_offset, uint8_t new_value) {\n    if (block_id >= NUM_CALIBRATION_BLOCKS || !g_calibration_blocks[block_id].is_active) {\n        return;\n    }\n\n    CalibrationBlock* block = &g_calibration_blocks[block_id];\n\n    int32_t target_absolute_idx = (int32_t)block->base_address + relative_offset;\n\n    g_calibration_pool[target_absolute_idx] = new_value;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_SENSORS 8\n#define SENSOR_HISTORY_BUFFER_SIZE 10\n\ntypedef struct {\n    uint16_t sensor_id;\n    int32_t readings[SENSOR_HISTORY_BUFFER_SIZE];\n    uint8_t current_idx;\n    uint8_t count;\n} SensorHistory;\n\nstatic SensorHistory g_sensor_data_history[MAX_SENSORS];\n\nvoid init_sensor_history_fixed() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        g_sensor_data_history[i].sensor_id = (uint16_t)-1;\n        memset(g_sensor_data_history[i].readings, 0, sizeof(g_sensor_data_history[i].readings));\n        g_sensor_data_history[i].current_idx = 0;\n        g_sensor_data_history[i].count = 0;\n    }\n}\n\nbool add_sensor_reading_to_history_fixed(uint16_t sensor_id, int32_t reading) {\n    int sensor_idx = -1;\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        if (g_sensor_data_history[i].sensor_id == sensor_id || g_sensor_data_history[i].sensor_id == (uint16_t)-1) {\n            sensor_idx = i;\n            if (g_sensor_data_history[i].sensor_id == (uint16_t)-1) {\n                g_sensor_data_history[i].sensor_id = sensor_id;\n            }\n            break;\n        }\n    }\n\n    if (sensor_idx == -1) {\n        return false;\n    }\n\n    SensorHistory* history = &g_sensor_data_history[sensor_idx];\n    history->readings[history->current_idx] = reading;\n    history->current_idx = (history->current_idx + 1) % SENSOR_HISTORY_BUFFER_SIZE;\n    if (history->count < SENSOR_HISTORY_BUFFER_SIZE) {\n        history->count++;\n    }\n    return true;\n}\n\nvoid update_historical_reading_fixed(uint16_t sensor_id, int32_t offset_from_current, int32_t new_value) {\n    int sensor_idx = -1;\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        if (g_sensor_data_history[i].sensor_id == sensor_id) {\n            sensor_idx = i;\n            break;\n        }\n    }\n\n    if (sensor_idx == -1) {\n        return;\n    }\n\n    SensorHistory* history = &g_sensor_data_history[sensor_idx];\n\n    if (history->count == 0) {\n        return;\n    }\n\n    if (offset_from_current < 0 || offset_from_current >= history->count) {\n        return;\n    }\n\n    int32_t effective_last_idx = (history->current_idx == 0) ? (SENSOR_HISTORY_BUFFER_SIZE - 1) : (history->current_idx - 1);\n\n    int32_t target_idx_calc = effective_last_idx - offset_from_current;\n    int32_t target_idx = (target_idx_calc + SENSOR_HISTORY_BUFFER_SIZE) % SENSOR_HISTORY_BUFFER_SIZE;\n\n    history->readings[target_idx] = new_value;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_PARAMETER_GROUPS 3\n#define MAX_PARAMS_PER_GROUP 10\n\ntypedef struct {\n    uint16_t value;\n    uint8_t status;\n} DiagnosticParameter_Fixed;\n\nDiagnosticParameter_Fixed g_engineParams_fixed[MAX_PARAMS_PER_GROUP];\nDiagnosticParameter_Fixed g_chassisParams_fixed[MAX_PARAMS_PER_GROUP];\nDiagnosticParameter_Fixed g_batteryParams_fixed[MAX_PARAMS_PER_GROUP];\n\ntypedef struct {\n    DiagnosticParameter_Fixed* data_buffer;\n    uint8_t max_params;\n    uint8_t current_count;\n} ParameterGroupConfig_Fixed;\n\nstatic ParameterGroupConfig_Fixed g_paramGroupConfigs_fixed[MAX_PARAMETER_GROUPS];\n\nvoid diagnosticLog_fixed(const char* msg) {\n    printf(\"DIAG_LOG_FIXED: %s\\n\", msg);\n}\n\nvoid initializeDiagnosticSystem_fixed() {\n    g_paramGroupConfigs_fixed[0] = (ParameterGroupConfig_Fixed){.data_buffer = g_engineParams_fixed, .max_params = MAX_PARAMS_PER_GROUP, .current_count = 0};\n    g_paramGroupConfigs_fixed[1] = (ParameterGroupConfig_Fixed){.data_buffer = g_chassisParams_fixed, .max_params = MAX_PARAMS_PER_GROUP, .current_count = 0};\n    g_paramGroupConfigs_fixed[2] = (ParameterGroupConfig_Fixed){.data_buffer = g_batteryParams_fixed, .max_params = MAX_PARAMS_PER_GROUP, .current_count = 0};\n    diagnosticLog_fixed(\"Diagnostic system initialized (fixed).\");\n}\n\ntypedef struct {\n    uint8_t group_id;\n    uint8_t param_idx_to_update;\n    DiagnosticParameter_Fixed new_value;\n} IncomingDiagnosticUpdate_Fixed;\n\nIncomingDiagnosticUpdate_Fixed receiveDiagnosticUpdate_fixed() {\n    IncomingDiagnosticUpdate_Fixed update;\n    update.group_id = 0;\n    update.param_idx_to_update = 10;\n    update.new_value = (DiagnosticParameter_Fixed){.value = 0xAAAA, .status = 0xFF};\n    return update;\n}\n\nvoid updateDiagnosticParameter_fixed(IncomingDiagnosticUpdate_Fixed update) {\n    if (update.group_id < MAX_PARAMETER_GROUPS) {\n        ParameterGroupConfig_Fixed* config = &g_paramGroupConfigs_fixed[update.group_id];\n        if (update.param_idx_to_update < config->max_params) {\n            config->data_buffer[update.param_idx_to_update] = update.new_value;\n            diagnosticLog_fixed(\"Diagnostic parameter updated (fixed).\");\n        } else {\n            diagnosticLog_fixed(\"Parameter index out of bounds for the specified group. Ignoring update (fixed).\");\n        }\n    } else {\n        diagnosticLog_fixed(\"Invalid diagnostic group ID received (fixed).\");\n    }\n}\n\nvoid diagnosticManagerLoop_fixed() {\n    initializeDiagnosticSystem_fixed();\n    IncomingDiagnosticUpdate_Fixed bad_update = receiveDiagnosticUpdate_fixed();\n    updateDiagnosticParameter_fixed(bad_update);\n    IncomingDiagnosticUpdate_Fixed good_update;\n    good_update.group_id = 1;\n    good_update.param_idx_to_update = 2;\n    good_update.new_value = (DiagnosticParameter_Fixed){.value = 0xBBBB, .status = 0xEE};\n    updateDiagnosticParameter_fixed(good_update);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOGGED_FAULTS 10\n#define CMD_LOG_FAULTS 0x01\n\nstatic uint16_t g_faultLogBuffer[MAX_LOGGED_FAULTS];\nstatic uint8_t g_currentFaultCount = 0;\n\nvoid initFaultLogger() {\n    memset(g_faultLogBuffer, 0, sizeof(g_faultLogBuffer));\n    g_currentFaultCount = 0;\n}\n\nint logDiagnosticFaults(const uint8_t* diag_packet, uint16_t packet_len) {\n    if (diag_packet == NULL || packet_len < 2) {\n        return -1;\n    }\n\n    uint8_t command_id = diag_packet[0];\n    if (command_id != CMD_LOG_FAULTS) {\n        return -2;\n    }\n\n    uint8_t num_faults = diag_packet[1];\n    uint16_t current_offset = 2;\n\n    g_currentFaultCount = 0;\n\n    for (uint8_t i = 0; i < num_faults; ++i) {\n        if (current_offset + sizeof(uint16_t) > packet_len) {\n            return -3;\n        }\n\n        uint16_t fault_code = (diag_packet[current_offset] << 8) | diag_packet[current_offset + 1];\n        current_offset += sizeof(uint16_t);\n\n        g_faultLogBuffer[i] = fault_code;\n        g_currentFaultCount++;\n    }\n\n    return 0;\n}\n\nvoid simulateDiagnosticRequest(const uint8_t* data, uint16_t len) {\n    logDiagnosticFaults(data, len);\n}\n\nuint8_t getLoggedFaultCount() {\n    return g_currentFaultCount;\n}\n\nuint16_t getLoggedFault(uint8_t index) {\n    if (index < g_currentFaultCount) {\n        return g_faultLogBuffer[index];\n    }\n    return 0xFFFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_FRAME_BUFFER_SIZE 256\n#define MAX_ERROR_MESSAGE_LEN 60\n\n// Fixed offsets and sizes for telemetry frame components\n#define FRAME_HEADER_SIZE 4\n#define SENSOR_DATA_BLOCK_OFFSET FRAME_HEADER_SIZE\n#define SENSOR_DATA_BLOCK_SIZE 200 // This size makes the buffer vulnerable\n#define ERROR_MESSAGE_OFFSET (SENSOR_DATA_BLOCK_OFFSET + SENSOR_DATA_BLOCK_SIZE)\n\n// Global buffer for assembling the telemetry frame\nstatic uint8_t g_telemetryFrameBuffer[TELEMETRY_FRAME_BUFFER_SIZE];\n\nvoid initTelemetryFrameAssembler() {\n    memset(g_telemetryFrameBuffer, 0, TELEMETRY_FRAME_BUFFER_SIZE);\n}\n\n// Function to assemble a telemetry frame containing header, sensor data, and an error message.\n// sensor_data: Pointer to a fixed-size block of sensor readings.\n// error_msg: Pointer to a null-terminated error message string.\n// msg_len: The actual length of the error message (excluding null terminator).\n//\n// The frame structure is [Header (4 bytes)] [Sensor Data (200 bytes)] [Error Message (variable, up to MAX_ERROR_MESSAGE_LEN)]\n//\n// VULNERABILITY: Improper buffer bounds check for the error message segment.\n// The sum of fixed block sizes (Header + Sensor Data) and the maximum error message length\n// exceeds the total allocated buffer size. Specifically, ERROR_MESSAGE_OFFSET is 204,\n// and MAX_ERROR_MESSAGE_LEN is 60. A message of 60 bytes will attempt to write up to index\n// 204 + 60 - 1 = 263. However, TELEMETRY_FRAME_BUFFER_SIZE is 256, meaning valid indices\n// are 0-255. This results in an out-of-bounds write to g_telemetryFrameBuffer.\nint assembleTelemetryFrame(const uint8_t* sensor_data, const char* error_msg, uint8_t msg_len) {\n    if (sensor_data == NULL || error_msg == NULL) {\n        return -1; // Invalid input\n    }\n\n    // Populate fixed header fields\n    g_telemetryFrameBuffer[0] = 0xAA;\n    g_telemetryFrameBuffer[1] = 0x55;\n    g_telemetryFrameBuffer[2] = 0x01;\n    // Note: Total length field calculation here does not impact the vulnerability directly\n    // as the overflow is in the copy loop, not in this length field's value.\n    g_telemetryFrameBuffer[3] = (uint8_t)(FRAME_HEADER_SIZE + SENSOR_DATA_BLOCK_SIZE + msg_len);\n\n    // Copy sensor data block\n    // Assumes sensor_data is at least SENSOR_DATA_BLOCK_SIZE bytes\n    for (uint8_t i = 0; i < SENSOR_DATA_BLOCK_SIZE; ++i) {\n        g_telemetryFrameBuffer[SENSOR_DATA_BLOCK_OFFSET + i] = sensor_data[i];\n    }\n\n    // Check if error message length is within its individual defined maximum\n    if (msg_len > MAX_ERROR_MESSAGE_LEN) {\n        msg_len = MAX_ERROR_MESSAGE_LEN;\n    }\n\n    // Copy error message data into the telemetry frame.\n    // The loop iterates based on msg_len, without a sufficient check that\n    // ERROR_MESSAGE_OFFSET + i remains within TELEMETRY_FRAME_BUFFER_SIZE.\n    for (uint8_t i = 0; i < msg_len; ++i) {\n        g_telemetryFrameBuffer[ERROR_MESSAGE_OFFSET + i] = (uint8_t)error_msg[i];\n    }\n\n    return 0; // Success (even if overflow occurred)\n}\n\n// Dummy function to simulate receiving data from an internal module\nvoid simulateDataReception(const uint8_t* s_data, const char* e_msg, uint8_t e_len) {\n    assembleTelemetryFrame(s_data, e_msg, e_len);\n}\n\n// Dummy function to retrieve a byte from the assembled frame\nuint8_t getFrameByte(uint16_t index) {\n    if (index < TELEMETRY_FRAME_BUFFER_SIZE) {\n        return g_telemetryFrameBuffer[index];\n    }\n    return 0xFF; // Out of bounds read indication\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_STORAGE_SIZE 1024\n#define DIAG_RESPONSE_BUFFER_SIZE 256\n\nstatic uint8_t g_vehicleConfig[VEHICLE_CONFIG_STORAGE_SIZE];\n\nvoid initVehicleConfig() {\n    for (int i = 0; i < VEHICLE_CONFIG_STORAGE_SIZE; ++i) {\n        g_vehicleConfig[i] = (uint8_t)(i % 0xFF);\n    }\n}\n\ntypedef struct {\n    uint16_t serviceId;\n    uint16_t configAreaOffset;\n    uint16_t bytesToRead;\n} DiagReadConfigRequest;\n\ntypedef struct {\n    uint16_t serviceIdResponse;\n    uint8_t data[DIAG_RESPONSE_BUFFER_SIZE];\n    uint16_t dataLength;\n} DiagReadConfigResponse;\n\nint handleDiagReadConfigRequest(const DiagReadConfigRequest* request, DiagReadConfigResponse* response) {\n    if (request == NULL || response == NULL) {\n        return -1;\n    }\n\n    if (request->serviceId != 0x22) {\n        return -1;\n    }\n\n    uint16_t offset = request->configAreaOffset;\n    uint16_t length = request->bytesToRead;\n\n    if (offset >= VEHICLE_CONFIG_STORAGE_SIZE || (uint32_t)offset + length > VEHICLE_CONFIG_STORAGE_SIZE) {\n        return -2;\n    }\n\n    uint16_t bytes_to_copy = length;\n    if (bytes_to_copy > DIAG_RESPONSE_BUFFER_SIZE) {\n        bytes_to_copy = DIAG_RESPONSE_BUFFER_SIZE;\n    }\n    if (bytes_to_copy > (VEHICLE_CONFIG_STORAGE_SIZE - offset)) {\n        bytes_to_copy = VEHICLE_CONFIG_STORAGE_SIZE - offset;\n    }\n\n    memcpy(response->data, g_vehicleConfig + offset, bytes_to_copy);\n\n    response->serviceIdResponse = 0x62;\n    response->dataLength = bytes_to_copy;\n\n    return 0;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_SUBSYSTEM_PARAMS_VULNERABLE 8\n\ntypedef enum {\n    SUBSYSTEM_ENGINE_VULNERABLE = 0,\n    SUBSYSTEM_TRANSMISSION_VULNERABLE,\n    SUBSYSTEM_BRAKES_VULNERABLE,\n    SUBSYSTEM_HVAC_VULNERABLE,\n    SUBSYSTEM_INFOTAINMENT_VULNERABLE,\n    NUM_VEHICLE_SUBSYSTEMS_VULNERABLE \n} VehicleSubSystem_Vulnerable;\n\ntypedef struct {\n    uint32_t params[MAX_SUBSYSTEM_PARAMS_VULNERABLE];\n    uint8_t  active_param_count;\n} SubsystemConfiguration_Vulnerable;\n\nstatic SubsystemConfiguration_Vulnerable g_vehicle_configs_vulnerable[NUM_VEHICLE_SUBSYSTEMS_VULNERABLE];\n\ntypedef struct {\n    uint8_t  target_subsystem_id;\n    uint8_t  config_param_idx;\n    uint32_t new_value;\n} CanConfigurationCommand_Vulnerable;\n\nvoid log_ecu_event_vulnerable(const char* event) {\n}\n\nCanConfigurationCommand_Vulnerable receive_can_command_vulnerable() {\n    CanConfigurationCommand_Vulnerable cmd;\n    cmd.target_subsystem_id = NUM_VEHICLE_SUBSYSTEMS_VULNERABLE; \n    cmd.config_param_idx = 0;\n    cmd.new_value = 0xAAAA;\n    return cmd;\n}\n\nvoid initialize_vehicle_configs_vulnerable() {\n    for (uint8_t i = 0; i < NUM_VEHICLE_SUBSYSTEMS_VULNERABLE; ++i) {\n        for (uint8_t j = 0; j < MAX_SUBSYSTEM_PARAMS_VULNERABLE; ++j) {\n            g_vehicle_configs_vulnerable[i].params[j] = 0;\n        }\n        g_vehicle_configs_vulnerable[i].active_param_count = MAX_SUBSYSTEM_PARAMS_VULNERABLE;\n    }\n    log_ecu_event_vulnerable(\"Vehicle configurations initialized (vulnerable).\");\n}\n\nvoid update_subsystem_param_vulnerable() {\n    CanConfigurationCommand_Vulnerable cmd = receive_can_command_vulnerable();\n\n    g_vehicle_configs_vulnerable[cmd.target_subsystem_id].params[cmd.config_param_idx] = cmd.new_value;\n    log_ecu_event_vulnerable(\"Subsystem parameter updated (vulnerable).\");\n}\n\nvoid vehicle_configuration_manager_vulnerable_main() {\n    initialize_vehicle_configs_vulnerable();\n    update_subsystem_param_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CALIBRATION_BLOCK_SIZE 64\n#define NUM_CALIBRATION_BLOCKS 8\n#define TOTAL_CALIBRATION_SIZE (CALIBRATION_BLOCK_SIZE * NUM_CALIBRATION_BLOCKS)\n\nstatic uint8_t g_calibrationData[TOTAL_CALIBRATION_SIZE];\nstatic bool g_calibrationInitialized = false;\n\nvoid initCalibrationSystem() {\n    memset(g_calibrationData, 0, TOTAL_CALIBRATION_SIZE);\n    g_calibrationInitialized = true;\n}\n\nint processCalibrationFragment(const uint8_t* msg_payload, uint16_t payload_len) {\n    if (!g_calibrationInitialized || msg_payload == NULL || payload_len < 5) {\n        return -1;\n    }\n\n    uint8_t block_idx = msg_payload[0];\n    uint16_t block_offset = (msg_payload[1] << 8) | msg_payload[2];\n    uint16_t data_len = (msg_payload[3] << 8) | msg_payload[4];\n\n    if (payload_len < (5 + data_len)) {\n        return -2;\n    }\n\n    if (block_idx >= NUM_CALIBRATION_BLOCKS) {\n        return -3;\n    }\n    \n    if (block_offset >= CALIBRATION_BLOCK_SIZE) {\n        return -4;\n    }\n\n    const uint8_t* data_payload = msg_payload + 5;\n\n    uint16_t global_start_offset = (uint16_t)block_idx * CALIBRATION_BLOCK_SIZE + block_offset;\n\n    for (uint16_t i = 0; i < data_len; ++i) {\n        g_calibrationData[global_start_offset + i] = data_payload[i];\n    }\n    \n    return 0;\n}\n\nvoid handleCANCalibrationMessage(const uint8_t* can_data, uint16_t can_dlc) {\n    processCalibrationFragment(can_data, can_dlc);\n}\n\nuint8_t getCalibrationByte(uint16_t index) {\n    if (index < TOTAL_CALIBRATION_SIZE) {\n        return g_calibrationData[index];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_TELEMETRY_PACKET_SIZE   2000 \n#define SENSOR_DATA_ENTRY_SIZE      12   \n#define MAX_INTERNAL_SENSOR_ENTRIES 40   \n#define TELEMETRY_DATA_BUFFER_SIZE  (MAX_INTERNAL_SENSOR_ENTRIES * SENSOR_DATA_ENTRY_SIZE) \n\nstatic uint8_t g_aggregatedSensorData[TELEMETRY_DATA_BUFFER_SIZE]; \n\ntypedef struct {\n    uint16_t packet_id;\n    uint8_t  num_sensor_entries; \n    uint8_t  _reserved; \n} TelemetryPacketHeader;\n\ntypedef struct {\n    uint8_t sensor_type;\n    uint16_t sensor_value;\n    uint32_t timestamp;\n    uint32_t sensor_flags;\n    uint8_t  checksum;\n} SensorDataEntry; \n\nvoid initTelemetryUnit() {\n    memset(g_aggregatedSensorData, 0, TELEMETRY_DATA_BUFFER_SIZE);\n}\n\nint processTelemetryPacket(const uint8_t* raw_packet, uint16_t packet_len) {\n    if (raw_packet == NULL || packet_len < sizeof(TelemetryPacketHeader)) {\n        return -1; \n    }\n\n    const TelemetryPacketHeader* header = (const TelemetryPacketHeader*)raw_packet;\n\n    if (header->num_sensor_entries > 60) { \n        return -2; \n    }\n\n    uint16_t expected_data_len = header->num_sensor_entries * SENSOR_DATA_ENTRY_SIZE;\n    uint16_t minimum_packet_len = sizeof(TelemetryPacketHeader) + expected_data_len;\n\n    if (packet_len < minimum_packet_len) {\n        return -3; \n    }\n\n    for (uint16_t i = 0; i < expected_data_len; ++i) {\n        g_aggregatedSensorData[i] = raw_packet[sizeof(TelemetryPacketHeader) + i];\n    }\n\n    return 0; \n}\n\nvoid receiveTelemetryUpdate(const uint8_t* data, uint16_t length) {\n    processTelemetryPacket(data, length);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_LIVE_DATA_GROUPS 5\n#define MAX_PARAMS_PER_GROUP 10\n#define DATA_VALUE_SIZE      2\n\ntypedef struct {\n    uint16_t param_id;\n    const char* name;\n    uint16_t min_val;\n    uint16_t max_val;\n} LiveDataParamDef;\n\ntypedef struct {\n    uint8_t group_id;\n    LiveDataParamDef* params_list;\n    uint8_t num_params;\n} LiveDataGroup;\n\nstatic LiveDataParamDef g_engineParams_fixed[5] = {\n    {0x0100, \"Engine RPM\", 0, 8000},\n    {0x0101, \"Vehicle Speed\", 0, 250},\n    {0x0102, \"Coolant Temp\", -40, 150},\n    {0x0103, \"Throttle Pos\", 0, 100},\n    {0x0104, \"Fuel Pressure\", 0, 1000}\n};\n\nstatic LiveDataParamDef g_brakesParams_fixed[3] = {\n    {0x0200, \"ABS Status\", 0, 1},\n    {0x0201, \"Brake Temp FL\", -20, 300},\n    {0x0202, \"Wheel Speed RL\", 0, 250}\n};\n\nstatic LiveDataParamDef g_transmissionParams_fixed[4] = {\n    {0x0300, \"Gear Pos\", 0, 6},\n    {0x0301, \"Trans Temp\", -30, 120},\n    {0x0302, \"Clutch Slip\", 0, 100},\n    {0x0303, \"Torque Conv Lock\", 0, 1}\n};\n\nstatic LiveDataGroup g_liveDataGroups_fixed[MAX_LIVE_DATA_GROUPS];\n\ntypedef struct {\n    uint8_t requested_group_id;\n    uint8_t requested_param_index;\n} DiagnosticLiveDataReaderRequest;\n\nDiagnosticLiveDataReaderRequest receiveDiagnosticLiveDataReaderRequest_fixed() {\n    DiagnosticLiveDataReaderRequest req;\n    req.requested_group_id = 0;\n    req.requested_param_index = 5;\n    return req;\n}\n\nvoid automotiveDiagLog_fixed(const char* msg) {\n}\n\nvoid initializeLiveDataSystem_fixed() {\n    for (uint8_t i = 0; i < MAX_LIVE_DATA_GROUPS; ++i) {\n        g_liveDataGroups_fixed[i].group_id = 0xFF;\n        g_liveDataGroups_fixed[i].params_list = NULL;\n        g_liveDataGroups_fixed[i].num_params = 0;\n    }\n\n    g_liveDataGroups_fixed[0].group_id = 0;\n    g_liveDataGroups_fixed[0].params_list = g_engineParams_fixed;\n    g_liveDataGroups_fixed[0].num_params = sizeof(g_engineParams_fixed) / sizeof(LiveDataParamDef);\n\n    g_liveDataGroups_fixed[1].group_id = 1;\n    g_liveDataGroups_fixed[1].params_list = g_brakesParams_fixed;\n    g_liveDataGroups_fixed[1].num_params = sizeof(g_brakesParams_fixed) / sizeof(LiveDataParamDef);\n\n    g_liveDataGroups_fixed[2].group_id = 2;\n    g_liveDataGroups_fixed[2].params_list = g_transmissionParams_fixed;\n    g_liveDataGroups_fixed[2].num_params = sizeof(g_transmissionParams_fixed) / sizeof(LiveDataParamDef);\n\n    automotiveDiagLog_fixed(\"Live Data System Initialized (Fixed).\");\n}\n\nvoid retrieveLiveDataParamDef_fixed() {\n    DiagnosticLiveDataReaderRequest req = receiveDiagnosticLiveDataReaderRequest_fixed();\n\n    if (req.requested_group_id < MAX_LIVE_DATA_GROUPS) {\n        LiveDataGroup* target_group = &g_liveDataGroups_fixed[req.requested_group_id];\n        if (req.requested_param_index < target_group->num_params) {\n            LiveDataParamDef retrieved_def = target_group->params_list[req.requested_param_index];\n            automotiveDiagLog_fixed(\"Live data parameter definition retrieved (fixed).\");\n        } else {\n            automotiveDiagLog_fixed(\"Requested parameter index out of bounds for the selected group (fixed).\");\n        }\n    } else {\n        automotiveDiagLog_fixed(\"Invalid live data group ID (fixed).\");\n    }\n}\n\nvoid diagnosticModuleMain_fixed() {\n    initializeLiveDataSystem_fixed();\n    retrieveLiveDataParamDef_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define TOTAL_MEMORY_POOL_SIZE 512\n#define PROFILE_DATA_SIZE 128\n#define PROFILE_METADATA_SIZE sizeof(uint8_t) \n#define PROFILE_ALLOC_SIZE (PROFILE_METADATA_SIZE + PROFILE_DATA_SIZE)\n\nstatic uint8_t g_memory_pool[TOTAL_MEMORY_POOL_SIZE];\nstatic uint8_t* g_active_profile_data_ptr = NULL;\n\nstatic const uint8_t default_profile_data[PROFILE_DATA_SIZE] = {\n    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,\n    0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,\n    0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,\n    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40,\n    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,\n    0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60,\n    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,\n    0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80\n};\n\nvoid init_profile_manager() {\n    memset(g_memory_pool, 0x00, TOTAL_MEMORY_POOL_SIZE);\n    g_active_profile_data_ptr = NULL;\n\n    int num_profiles = TOTAL_MEMORY_POOL_SIZE / PROFILE_ALLOC_SIZE;\n    for (int i = 0; i < num_profiles; ++i) {\n        uint8_t* current_profile_base = g_memory_pool + (i * PROFILE_ALLOC_SIZE);\n        *current_profile_base = 0x00;\n        memcpy(current_profile_base + PROFILE_METADATA_SIZE, default_profile_data, PROFILE_DATA_SIZE);\n    }\n\n    g_active_profile_data_ptr = g_memory_pool + PROFILE_METADATA_SIZE;\n    *(g_active_profile_data_ptr - PROFILE_METADATA_SIZE) = 0x01;\n}\n\nvoid utilize_active_profile() {\n    if (g_active_profile_data_ptr != NULL) {\n        volatile uint32_t sum = 0;\n        for (uint16_t i = 0; i < PROFILE_DATA_SIZE; ++i) {\n            sum += g_active_profile_data_ptr[i];\n        }\n        (void)sum;\n    }\n}\n\nvoid revert_active_profile_vulnerable(int16_t steps_backward) {\n    if (g_active_profile_data_ptr == NULL || steps_backward <= 0) {\n        return;\n    }\n\n    uint8_t* current_profile_base_ptr = g_active_profile_data_ptr - PROFILE_METADATA_SIZE;\n\n    uint8_t* proposed_new_profile_base_ptr = current_profile_base_ptr - (steps_backward * PROFILE_ALLOC_SIZE);\n\n    *(g_active_profile_data_ptr - PROFILE_METADATA_SIZE) = 0x00;\n\n    g_active_profile_data_ptr = proposed_new_profile_base_ptr + PROFILE_METADATA_SIZE;\n\n    *(g_active_profile_data_ptr - PROFILE_METADATA_SIZE) = 0x01;\n\n    utilize_active_profile();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <new>\n#include <algorithm>\n\nstruct DiagnosticLogEntry {\n    uint32_t timestamp;\n    uint16_t event_code;\n    char*    description;\n    size_t   description_buffer_capacity;\n};\n\nstruct LogBatchPacketHeader {\n    uint16_t num_messages;\n    uint16_t global_max_description_len;\n    uint32_t total_payload_bytes;\n};\n\nstruct IndividualMessageData {\n    uint32_t timestamp;\n    uint16_t event_code;\n    uint16_t actual_description_len;\n};\n\nclass DiagnosticLogger {\npublic:\n    DiagnosticLogger() = default;\n\n    ~DiagnosticLogger() {\n        clearLogEntries();\n    }\n\n    void clearLogEntries() {\n        for (auto& entry : m_log_entries) {\n            if (entry.description) {\n                delete[] entry.description;\n            }\n        }\n        m_log_entries.clear();\n    }\n\n    bool processLogBatchFixed(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(LogBatchPacketHeader)) {\n            return false;\n        }\n\n        const LogBatchPacketHeader* header = reinterpret_cast<const LogBatchPacketHeader*>(packet_data);\n\n        if (header->total_payload_bytes > (packet_length - sizeof(LogBatchPacketHeader))) {\n            return false;\n        }\n\n        static const uint16_t MAX_SINGLE_DESCRIPTION_HARD_LIMIT = 511;\n        if (header->global_max_description_len > MAX_SINGLE_DESCRIPTION_HARD_LIMIT) {\n            return false;\n        }\n        \n        clearLogEntries();\n\n        const uint8_t* current_payload_ptr = packet_data + sizeof(LogBatchPacketHeader);\n        size_t remaining_payload_data = header->total_payload_bytes;\n\n        for (uint16_t i = 0; i < header->num_messages; ++i) {\n            if (remaining_payload_data < sizeof(IndividualMessageData)) {\n                return false;\n            }\n\n            const IndividualMessageData* msg_header = reinterpret_cast<const IndividualMessageData*>(current_payload_ptr);\n\n            if (msg_header->actual_description_len > MAX_SINGLE_DESCRIPTION_HARD_LIMIT) {\n                return false;\n            }\n\n            if (remaining_payload_data - sizeof(IndividualMessageData) < msg_header->actual_description_len) {\n                return false;\n            }\n\n            size_t alloc_size_for_description = header->global_max_description_len + 1;\n            if (alloc_size_for_description == 0) {\n                 alloc_size_for_description = 1;\n            }\n\n            DiagnosticLogEntry new_entry;\n            new_entry.timestamp = msg_header->timestamp;\n            new_entry.event_code = msg_header->event_code;\n            new_entry.description = new (std::nothrow) char[alloc_size_for_description];\n            new_entry.description_buffer_capacity = alloc_size_for_description;\n\n            if (!new_entry.description) {\n                clearLogEntries();\n                return false;\n            }\n\n            current_payload_ptr += sizeof(IndividualMessageData);\n            remaining_payload_data -= sizeof(IndividualMessageData);\n\n            size_t bytes_to_copy = std::min({\n                static_cast<size_t>(msg_header->actual_description_len),\n                static_cast<size_t>(alloc_size_for_description - 1),\n                remaining_payload_data\n            });\n            \n            for (size_t k = 0; k < bytes_to_copy; ++k) {\n                new_entry.description[k] = static_cast<char>(current_payload_ptr[k]);\n            }\n            new_entry.description[bytes_to_copy] = '\\0';\n\n            current_payload_ptr += msg_header->actual_description_len;\n            remaining_payload_data -= msg_header->actual_description_len;\n\n            m_log_entries.push_back(new_entry);\n        }\n\n        return true;\n    }\n\n    const std::vector<DiagnosticLogEntry>& getLogEntries() const {\n        return m_log_entries;\n    }\n\nprivate:\n    std::vector<DiagnosticLogEntry> m_log_entries;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAG_EVENT_BUFFER_SIZE 256\n#define DIAG_EVENT_ENTRY_BYTE_SIZE 8\n\nstatic uint8_t g_diag_event_buffer[DIAG_EVENT_BUFFER_SIZE];\nstatic uint16_t g_active_event_count = 0;\nstatic uint16_t g_next_event_write_byte_idx = 0;\n\nvoid init_diag_event_manager() {\n    memset(g_diag_event_buffer, 0, DIAG_EVENT_BUFFER_SIZE);\n    g_active_event_count = 0;\n    g_next_event_write_byte_idx = 0;\n}\n\nbool record_diagnostic_event(uint32_t timestamp, uint32_t event_code) {\n    if ((g_next_event_write_byte_idx + DIAG_EVENT_ENTRY_BYTE_SIZE) > DIAG_EVENT_BUFFER_SIZE) {\n        return false;\n    }\n    \n    memcpy(g_diag_event_buffer + g_next_event_write_byte_idx, &timestamp, sizeof(timestamp));\n    memcpy(g_diag_event_buffer + g_next_event_write_byte_idx + sizeof(timestamp), &event_code, sizeof(event_code));\n    \n    g_next_event_write_byte_idx += DIAG_EVENT_ENTRY_BYTE_SIZE;\n    g_active_event_count++;\n    \n    return true;\n}\n\nvoid clear_recent_diag_events_and_mark_vulnerable(uint16_t events_to_purge, int16_t marker_byte_offset_from_new_end) {\n    if (g_active_event_count == 0) {\n        return;\n    }\n\n    uint16_t actual_events_to_purge = events_to_purge;\n    if (actual_events_to_purge > g_active_event_count) {\n        actual_events_to_purge = g_active_event_count;\n    }\n\n    g_active_event_count -= actual_events_to_purge;\n    g_next_event_write_byte_idx = g_active_event_count * DIAG_EVENT_ENTRY_BYTE_SIZE;\n\n    int32_t target_marker_byte_idx = (int32_t)g_next_event_write_byte_idx + marker_byte_offset_from_new_end;\n\n    g_diag_event_buffer[target_marker_byte_idx] = 0xDE;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_VEHICLE_EVENTS 100\n#define EVENT_ENTRY_WORD_SIZE 4\n\ntypedef struct {\n    uint32_t event_id;\n    uint32_t timestamp_ms;\n    uint32_t flags;\n    uint32_t reserved;\n} VehicleEventEntry;\n\nstatic uint32_t g_event_log_words[MAX_VEHICLE_EVENTS * EVENT_ENTRY_WORD_SIZE];\nstatic uint16_t g_next_write_word_idx = 0;\nstatic uint16_t g_num_logged_events = 0;\n\nvoid init_event_logger() {\n    memset(g_event_log_words, 0, sizeof(g_event_log_words));\n    g_next_write_word_idx = 0;\n    g_num_logged_events = 0;\n}\n\nbool log_vehicle_event(uint32_t event_id, uint32_t timestamp, uint32_t flags) {\n    if (g_num_logged_events >= MAX_VEHICLE_EVENTS) {\n        return false;\n    }\n\n    uint16_t current_entry_start_word_idx = g_next_write_word_idx;\n\n    g_event_log_words[current_entry_start_word_idx + 0] = event_id;\n    g_event_log_words[current_entry_start_word_idx + 1] = timestamp;\n    g_event_log_words[current_entry_start_word_idx + 2] = flags;\n    g_event_log_words[current_entry_start_word_idx + 3] = 0;\n\n    g_next_write_word_idx += EVENT_ENTRY_WORD_SIZE;\n    g_num_logged_events++;\n    return true;\n}\n\nvoid update_event_flags_fixed(uint16_t event_index_from_latest, uint32_t new_flags) {\n    if (g_num_logged_events == 0) {\n        return;\n    }\n\n    if (event_index_from_latest >= g_num_logged_events) {\n        return;\n    }\n\n    uint16_t latest_event_start_word_idx = g_next_write_word_idx - EVENT_ENTRY_WORD_SIZE;\n\n    uint16_t target_event_start_word_idx = latest_event_start_word_idx - (event_index_from_latest * EVENT_ENTRY_WORD_SIZE);\n\n    g_event_log_words[target_event_start_word_idx + 2] = new_flags;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\nuint32_t get_current_timestamp() {\n    return 0xDEADBEEF; \n}\n\n#define DIAG_DATA_POINTS_HISTORY_SIZE 20\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t engine_runtime_hrs;\n    uint16_t km_driven_hundreds;\n    uint8_t  error_code_count;\n    bool     valid_entry;\n} DiagnosticSnapshot;\n\nstatic DiagnosticSnapshot g_diag_history_buffer[DIAG_DATA_POINTS_HISTORY_SIZE];\nstatic uint16_t g_diag_write_head_idx = 0;\nstatic uint16_t g_num_active_snapshots = 0;\n\nvoid init_diagnostic_history_vulnerable() {\n    for (uint16_t i = 0; i < DIAG_DATA_POINTS_HISTORY_SIZE; ++i) {\n        g_diag_history_buffer[i].valid_entry = false;\n    }\n    g_diag_write_head_idx = 0;\n    g_num_active_snapshots = 0;\n}\n\nvoid add_diag_snapshot_vulnerable(uint16_t runtime, uint16_t km_driven, uint8_t error_count) {\n    g_diag_history_buffer[g_diag_write_head_idx].timestamp_ms = get_current_timestamp();\n    g_diag_history_buffer[g_diag_write_head_idx].engine_runtime_hrs = runtime;\n    g_diag_history_buffer[g_diag_write_head_idx].km_driven_hundreds = km_driven;\n    g_diag_history_buffer[g_diag_write_head_idx].error_code_count = error_count;\n    g_diag_history_buffer[g_diag_write_head_idx].valid_entry = true;\n\n    g_diag_write_head_idx = (g_diag_write_head_idx + 1) % DIAG_DATA_POINTS_HISTORY_SIZE;\n    if (g_num_active_snapshots < DIAG_DATA_POINTS_HISTORY_SIZE) {\n        g_num_active_snapshots++;\n    }\n}\n\nvoid invalidate_recent_diag_snapshots_vulnerable(uint16_t num_to_invalidate) {\n    if (g_num_active_snapshots == 0 || num_to_invalidate == 0) {\n        return;\n    }\n\n    uint16_t actual_invalidate_count = num_to_invalidate;\n    if (actual_invalidate_count > g_num_active_snapshots) {\n        actual_invalidate_count = g_num_active_snapshots;\n    }\n\n    uint16_t latest_snapshot_idx;\n    if (g_diag_write_head_idx == 0) {\n        latest_snapshot_idx = DIAG_DATA_POINTS_HISTORY_SIZE - 1;\n    } else {\n        latest_snapshot_idx = g_diag_write_head_idx - 1;\n    }\n\n    for (uint16_t i = 0; i < actual_invalidate_count; ++i) {\n        uint16_t target_phys_idx = latest_snapshot_idx - i;\n\n        g_diag_history_buffer[target_phys_idx].valid_entry = false;\n        g_diag_history_buffer[target_phys_idx].engine_runtime_hrs = 0;\n        g_diag_history_buffer[target_phys_idx].km_driven_hundreds = 0;\n        g_diag_history_buffer[target_phys_idx].error_code_count = 0;\n    }\n\n    g_num_active_snapshots -= actual_invalidate_count;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CONFIG_MEMORY_SIZE 512\n#define CONFIG_BLOCK_DATA_SIZE 26\n#define CONFIG_BLOCK_HEADER_SIZE 4\n#define CONFIG_BLOCK_CHECKSUM_SIZE 2\n#define CONFIG_BLOCK_SIZE (CONFIG_BLOCK_HEADER_SIZE + CONFIG_BLOCK_DATA_SIZE + CONFIG_BLOCK_CHECKSUM_SIZE)\n\n#define CONFIG_BLOCK_ID_OFFSET 0\n#define CONFIG_BLOCK_STATUS_OFFSET 2\n#define CONFIG_BLOCK_DATA_OFFSET 4\n#define CONFIG_BLOCK_DATA_MAX_LEN (CONFIG_BLOCK_SIZE - CONFIG_BLOCK_HEADER_SIZE - CONFIG_BLOCK_CHECKSUM_SIZE)\n#define CONFIG_BLOCK_CHECKSUM_OFFSET (CONFIG_BLOCK_SIZE - CONFIG_BLOCK_CHECKSUM_SIZE)\n\n#define MAX_CONFIG_BLOCKS (CONFIG_MEMORY_SIZE / CONFIG_BLOCK_SIZE)\n\nstatic uint8_t g_config_bank[CONFIG_MEMORY_SIZE];\nstatic bool g_block_in_use[MAX_CONFIG_BLOCKS];\n\nvoid init_config_manager() {\n    memset(g_config_bank, 0xFF, CONFIG_MEMORY_SIZE);\n    for (uint16_t i = 0; i < MAX_CONFIG_BLOCKS; ++i) {\n        g_block_in_use[i] = false;\n    }\n}\n\nbool allocate_config_block(uint16_t block_id, uint8_t initial_status) {\n    if (block_id >= MAX_CONFIG_BLOCKS || g_block_in_use[block_id]) {\n        return false;\n    }\n    uint16_t block_start_offset = block_id * CONFIG_BLOCK_SIZE;\n    if (block_start_offset + CONFIG_BLOCK_SIZE > CONFIG_MEMORY_SIZE) {\n        return false;\n    }\n    g_block_in_use[block_id] = true;\n    *(uint16_t*)(g_config_bank + block_start_offset + CONFIG_BLOCK_ID_OFFSET) = block_id;\n    g_config_bank[block_start_offset + CONFIG_BLOCK_STATUS_OFFSET] = initial_status;\n    memset(g_config_bank + block_start_offset + CONFIG_BLOCK_DATA_OFFSET, 0, CONFIG_BLOCK_DATA_MAX_LEN);\n    *(uint16_t*)(g_config_bank + block_start_offset + CONFIG_BLOCK_CHECKSUM_OFFSET) = 0;\n    return true;\n}\n\nbool write_config_data(uint16_t block_id, const uint8_t* data, uint8_t data_len) {\n    if (block_id >= MAX_CONFIG_BLOCKS || !g_block_in_use[block_id] || data_len > CONFIG_BLOCK_DATA_MAX_LEN) {\n        return false;\n    }\n    uint16_t data_start_offset = block_id * CONFIG_BLOCK_SIZE + CONFIG_BLOCK_DATA_OFFSET;\n    memcpy(g_config_bank + data_start_offset, data, data_len);\n    return true;\n}\n\nvoid update_config_checksum_fixed(uint16_t block_index, int16_t relative_checksum_offset, uint16_t new_checksum_value) {\n    if (block_index >= MAX_CONFIG_BLOCKS || !g_block_in_use[block_index]) {\n        return;\n    }\n\n    int32_t block_start_offset = (int32_t)block_index * CONFIG_BLOCK_SIZE;\n\n    int32_t target_offset_signed = block_start_offset + relative_checksum_offset;\n\n    if (target_offset_signed < 0 || (uint32_t)target_offset_signed + CONFIG_BLOCK_CHECKSUM_SIZE > CONFIG_MEMORY_SIZE) {\n        return;\n    }\n    \n    uint16_t target_offset = (uint16_t)target_offset_signed;\n\n    *(uint16_t*)(g_config_bank + target_offset) = new_checksum_value;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#define MAX_SUBSYSTEMS 3\n#define MAX_PARAMS_PER_SUBSYSTEM 10\n\ntypedef struct {\n    unsigned int param_value;\n    unsigned char param_status;\n} ConfigParam;\n\nstatic ConfigParam g_subsystemConfigs[MAX_SUBSYSTEMS][MAX_PARAMS_PER_SUBSYSTEM];\n\nstatic unsigned char g_subsystemActualParamCounts[MAX_SUBSYSTEMS] = {\n    5, \n    8, \n    3  \n};\n\ntypedef struct {\n    unsigned char subsystem_id;\n    unsigned char parameter_offset;\n    unsigned int new_value;\n} ConfigUpdateCommand;\n\nvoid logError(const char* msg) {\n}\n\nConfigUpdateCommand receiveConfigUpdateCommand_fixed() {\n    ConfigUpdateCommand cmd;\n    cmd.subsystem_id = 0;\n    cmd.parameter_offset = 5;\n    cmd.new_value = 0xAAAA;\n    return cmd;\n}\n\nvoid initializeSubsystemConfigs_fixed() {\n    for (int i = 0; i < MAX_SUBSYSTEMS; ++i) {\n        for (int j = 0; j < MAX_PARAMS_PER_SUBSYSTEM; ++j) {\n            g_subsystemConfigs[i][j] = (ConfigParam){0, 0};\n        }\n    }\n}\n\nvoid processConfigUpdate_fixed() {\n    ConfigUpdateCommand cmd = receiveConfigUpdateCommand_fixed();\n\n    if (cmd.subsystem_id < MAX_SUBSYSTEMS) {\n        if (cmd.parameter_offset < g_subsystemActualParamCounts[cmd.subsystem_id]) {\n            g_subsystemConfigs[cmd.subsystem_id][cmd.parameter_offset].param_value = cmd.new_value;\n        } else {\n            logError(\"Parameter offset out of bounds for specified subsystem.\");\n        }\n    } else {\n        logError(\"Invalid subsystem ID received.\");\n    }\n}\n\nvoid systemMain_fixed() {\n    initializeSubsystemConfigs_fixed();\n    processConfigUpdate_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_DTC_LOG_ENTRIES 32\n#define DTC_ID_LEN 8\n\ntypedef struct {\n    char dtc_id[DTC_ID_LEN + 1];\n    uint32_t timestamp_ms;\n    uint8_t severity_level; \n    bool active;\n    uint16_t associated_param_A;\n    uint16_t associated_param_B;\n} DiagnosticTroubleCodeEntry;\n\nstatic DiagnosticTroubleCodeEntry g_dtc_log_buffer_vulnerable[MAX_DTC_LOG_ENTRIES];\nstatic uint16_t g_next_write_idx_vulnerable = 0; \nstatic uint16_t g_num_logged_dtcs_vulnerable = 0;\n\nvoid init_dtc_logger_vulnerable() {\n    for (uint16_t i = 0; i < MAX_DTC_LOG_ENTRIES; ++i) {\n        memset(&g_dtc_log_buffer_vulnerable[i], 0, sizeof(DiagnosticTroubleCodeEntry));\n    }\n    g_next_write_idx_vulnerable = 0;\n    g_num_logged_dtcs_vulnerable = 0;\n}\n\nvoid log_dtc_entry_vulnerable(const char* id, uint32_t timestamp, uint8_t severity, uint16_t param_A, uint16_t param_B) {\n    strncpy(g_dtc_log_buffer_vulnerable[g_next_write_idx_vulnerable].dtc_id, id, DTC_ID_LEN);\n    g_dtc_log_buffer_vulnerable[g_next_write_idx_vulnerable].dtc_id[DTC_ID_LEN] = '\\0';\n    g_dtc_log_buffer_vulnerable[g_next_write_idx_vulnerable].timestamp_ms = timestamp;\n    g_dtc_log_buffer_vulnerable[g_next_write_idx_vulnerable].severity_level = severity;\n    g_dtc_log_buffer_vulnerable[g_next_write_idx_vulnerable].active = true;\n    g_dtc_log_buffer_vulnerable[g_next_write_idx_vulnerable].associated_param_A = param_A;\n    g_dtc_log_buffer_vulnerable[g_next_write_idx_vulnerable].associated_param_B = param_B;\n\n    g_next_write_idx_vulnerable = (g_next_write_idx_vulnerable + 1) % MAX_DTC_LOG_ENTRIES;\n    if (g_num_logged_dtcs_vulnerable < MAX_DTC_LOG_ENTRIES) {\n        g_num_logged_dtcs_vulnerable++;\n    }\n}\n\nvoid update_dtc_params_vulnerable(uint16_t offset_from_last, uint16_t new_param_A, uint16_t new_param_B) {\n    if (g_num_logged_dtcs_vulnerable == 0) {\n        return;\n    }\n\n    int32_t last_logged_idx = (g_next_write_idx_vulnerable == 0) ? (MAX_DTC_LOG_ENTRIES - 1) : (g_next_write_idx_vulnerable - 1);\n\n    int32_t target_idx_raw = last_logged_idx - offset_from_last;\n\n    uint16_t target_buffer_idx = (uint16_t)(target_idx_raw % MAX_DTC_LOG_ENTRIES);\n\n    g_dtc_log_buffer_vulnerable[target_buffer_idx].associated_param_A = new_param_A;\n    g_dtc_log_buffer_vulnerable[target_buffer_idx].associated_param_B = new_param_B;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAG_HISTORY_CAPACITY 50\n#define DIAG_REQ_DATA_MAX_SIZE 24\n\ntypedef struct {\n    uint32_t request_id;\n    uint32_t timestamp_ms;\n    uint8_t  request_data[DIAG_REQ_DATA_MAX_SIZE];\n    uint8_t  data_len;\n    bool     processed;\n} DiagRequestEntry;\n\nstatic DiagRequestEntry g_diag_history[DIAG_HISTORY_CAPACITY];\nstatic size_t g_current_history_size = 0;\n\nvoid init_diag_history() {\n    memset(g_diag_history, 0, sizeof(g_diag_history));\n    g_current_history_size = 0;\n}\n\nvoid add_diag_request(uint32_t id, uint32_t timestamp, const uint8_t* data, uint8_t len) {\n    if (g_current_history_size < DIAG_HISTORY_CAPACITY) {\n        DiagRequestEntry* target_entry = &g_diag_history[g_current_history_size];\n        target_entry->request_id = id;\n        target_entry->timestamp_ms = timestamp;\n        uint8_t actual_len = (len > DIAG_REQ_DATA_MAX_SIZE) ? DIAG_REQ_DATA_MAX_SIZE : len;\n        memcpy(target_entry->request_data, data, actual_len);\n        target_entry->data_len = actual_len;\n        target_entry->processed = false;\n        g_current_history_size++;\n    }\n}\n\nvoid archive_recent_diag_requests_vulnerable(uint16_t steps_to_archive) {\n    if (g_current_history_size == 0 || steps_to_archive == 0) {\n        return;\n    }\n\n    DiagRequestEntry* current_entry_ptr = &g_diag_history[g_current_history_size - 1];\n\n    for (uint16_t i = 0; i < steps_to_archive; ++i) {\n        current_entry_ptr->processed = true;\n        memset(current_entry_ptr->request_data, 0, DIAG_REQ_DATA_MAX_SIZE);\n        current_entry_ptr--;\n    }\n\n    if (g_current_history_size < steps_to_archive) {\n        g_current_history_size = 0;\n    } else {\n        g_current_history_size -= steps_to_archive;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_DIAG_ENTRIES_FIXED 32\n#define MESSAGE_LEN_FIXED 24\n\ntypedef struct {\n    uint8_t priority;\n    uint32_t timestamp;\n    char message[MESSAGE_LEN_FIXED];\n} DiagMessageFixed;\n\nstatic DiagMessageFixed g_diag_log_buffer_fixed[MAX_DIAG_ENTRIES_FIXED];\nstatic uint8_t g_current_write_idx_fixed = 0;\nstatic uint8_t g_num_messages_fixed = 0;\n\nvoid init_diag_log_fixed() {\n    memset(g_diag_log_buffer_fixed, 0, sizeof(g_diag_log_buffer_fixed));\n    g_current_write_idx_fixed = 0;\n    g_num_messages_fixed = 0;\n}\n\nvoid add_diag_message_fixed(uint8_t priority, uint32_t timestamp, const char* msg) {\n    strncpy(g_diag_log_buffer_fixed[g_current_write_idx_fixed].message, msg, MESSAGE_LEN_FIXED - 1);\n    g_diag_log_buffer_fixed[g_current_write_idx_fixed].message[MESSAGE_LEN_FIXED - 1] = '\\0';\n    g_diag_log_buffer_fixed[g_current_write_idx_fixed].priority = priority;\n    g_diag_log_buffer_fixed[g_current_write_idx_fixed].timestamp = timestamp;\n\n    g_current_write_idx_fixed = (g_current_write_idx_fixed + 1) % MAX_DIAG_ENTRIES_FIXED;\n    if (g_num_messages_fixed < MAX_DIAG_ENTRIES_FIXED) {\n        g_num_messages_fixed++;\n    }\n}\n\nvoid modify_diag_message_fixed(uint8_t relative_idx_from_last, uint8_t new_priority, const char* new_msg) {\n    if (g_num_messages_fixed == 0) {\n        return;\n    }\n\n    if (relative_idx_from_last >= g_num_messages_fixed) {\n        return;\n    }\n\n    int32_t last_entry_idx = (g_current_write_idx_fixed == 0) ? (MAX_DIAG_ENTRIES_FIXED - 1) : (g_current_write_idx_fixed - 1);\n\n    int32_t target_raw_idx = last_entry_idx - relative_idx_from_last;\n\n    uint8_t target_actual_idx = (target_raw_idx < 0) ? (uint8_t)(target_raw_idx + MAX_DIAG_ENTRIES_FIXED) : (uint8_t)target_raw_idx;\n\n    strncpy(g_diag_log_buffer_fixed[target_actual_idx].message, new_msg, MESSAGE_LEN_FIXED - 1);\n    g_diag_log_buffer_fixed[target_actual_idx].message[MESSAGE_LEN_FIXED - 1] = '\\0';\n    g_diag_log_buffer_fixed[target_actual_idx].priority = new_priority;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMAND_DATA_PAYLOAD 64 \n#define PROCESSING_BUFFER_SIZE 32   \n\ntypedef struct {\n    uint16_t command_id;\n    uint8_t  payload_len;\n    uint8_t  payload[MAX_COMMAND_DATA_PAYLOAD];\n    uint16_t crc_checksum;\n} VehicleCommand;\n\nstatic uint8_t g_tempProcessingBuffer[PROCESSING_BUFFER_SIZE];\n\nvoid initCommandProcessor() {\n    memset(g_tempProcessingBuffer, 0, PROCESSING_BUFFER_SIZE);\n}\n\nuint16_t calculateCrc(const uint8_t* data, uint8_t len) {\n    uint16_t crc = 0xFFFF;\n    for (uint8_t i = 0; i < len; ++i) {\n        crc ^= data[i];\n        for (int j = 0; j < 8; ++j) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\nint processVehicleCommand(const VehicleCommand* cmd) {\n    if (cmd == NULL) {\n        return -1; \n    }\n\n    if (cmd->payload_len > MAX_COMMAND_DATA_PAYLOAD) {\n        return -2; \n    }\n\n    memset(g_tempProcessingBuffer, 0, PROCESSING_BUFFER_SIZE); \n\n    uint8_t bytes_to_copy = cmd->payload_len;\n    if (bytes_to_copy > PROCESSING_BUFFER_SIZE) {\n        bytes_to_copy = PROCESSING_BUFFER_SIZE; \n    }\n\n    for (uint8_t i = 0; i < bytes_to_copy; ++i) {\n        g_tempProcessingBuffer[i] = cmd->payload[i];\n    }\n\n    uint16_t calculated_crc = calculateCrc(g_tempProcessingBuffer, bytes_to_copy);\n\n    if (calculated_crc != cmd->crc_checksum) {\n        return -3; \n    }\n\n    return 0; \n}\n\nvoid simulateCommandReception(const VehicleCommand* rx_cmd) {\n    processVehicleCommand(rx_cmd);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define FIRMWARE_DATA_BUFFER_SIZE 512\n#define MAX_FIRMWARE_CHUNK_SIZE 128\n\nstatic uint8_t g_firmware_data_buffer[FIRMWARE_DATA_BUFFER_SIZE];\nstatic uint8_t* g_firmware_write_ptr;\nstatic uint32_t g_firmware_data_current_len;\n\nstatic volatile uint8_t g_ecu_operational_mode = 0x01;\n\nvoid init_firmware_data_handler() {\n    memset(g_firmware_data_buffer, 0, FIRMWARE_DATA_BUFFER_SIZE);\n    g_firmware_write_ptr = g_firmware_data_buffer;\n    g_firmware_data_current_len = 0;\n    g_ecu_operational_mode = 0x01;\n}\n\nbool append_firmware_chunk(const uint8_t* chunk, uint16_t chunk_len) {\n    if (chunk == NULL || chunk_len == 0 || chunk_len > MAX_FIRMWARE_CHUNK_SIZE) {\n        return false;\n    }\n\n    if (g_firmware_data_current_len + chunk_len > FIRMWARE_DATA_BUFFER_SIZE) {\n        return false;\n    }\n\n    memcpy(g_firmware_write_ptr, chunk, chunk_len);\n    g_firmware_write_ptr += chunk_len;\n    g_firmware_data_current_len += chunk_len;\n    return true;\n}\n\nvoid rewind_firmware_data_vulnerable(uint16_t bytes_to_rewind) {\n    if (bytes_to_rewind > g_firmware_data_current_len) {\n        bytes_to_rewind = g_firmware_data_current_len;\n    }\n\n    g_firmware_write_ptr -= bytes_to_rewind;\n    g_firmware_data_current_len -= bytes_to_rewind;\n\n    *g_firmware_write_ptr = 0x00;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_REPORT_PAYLOAD_SIZE 128\n#define DIAG_DATA_BUFFER_SIZE 64\n#define MAX_DIAG_DATA_ID_ENTRIES 5\n\ntypedef struct {\n    uint16_t id;\n    uint8_t  data[DIAG_DATA_BUFFER_SIZE];\n    uint8_t  current_len;\n} DiagnosticDataEntry;\n\nstatic DiagnosticDataEntry g_diagDataStore[MAX_DIAG_DATA_ID_ENTRIES];\nstatic uint8_t g_diagDataCount = 0;\n\nvoid initDiagnosticDataStore() {\n    memset(g_diagDataStore, 0, sizeof(g_diagDataStore));\n}\n\nint processDiagnosticReport(uint16_t report_id, const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len == 0 || payload_len > MAX_REPORT_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    if (report_id == 0x10) {\n        if (payload_len < (1 + 2 + 1)) {\n            return -2;\n        }\n\n        uint8_t entry_index = payload[0];\n        uint16_t data_id = (payload[1] << 8) | payload[2];\n        uint8_t data_len = payload[3];\n\n        if (entry_index >= MAX_DIAG_DATA_ID_ENTRIES) {\n            return -3;\n        }\n\n        if (data_len > (payload_len - (1 + 2 + 1))) {\n            return -4;\n        }\n        \n        int found_idx = -1;\n        for (int i = 0; i < g_diagDataCount; ++i) {\n            if (g_diagDataStore[i].id == data_id) {\n                found_idx = i;\n                break;\n            }\n        }\n\n        if (found_idx == -1) {\n            if (g_diagDataCount < MAX_DIAG_DATA_ID_ENTRIES) {\n                found_idx = g_diagDataCount++;\n                g_diagDataStore[found_idx].id = data_id;\n            } else {\n                return -5;\n            }\n        }\n\n        uint8_t bytes_to_copy = data_len;\n        if (bytes_to_copy > DIAG_DATA_BUFFER_SIZE) {\n            bytes_to_copy = DIAG_DATA_BUFFER_SIZE;\n        }\n\n        memcpy(g_diagDataStore[found_idx].data, payload + (1 + 2 + 1), bytes_to_copy);\n        g_diagDataStore[found_idx].current_len = bytes_to_copy;\n\n        if (data_len > DIAG_DATA_BUFFER_SIZE) {\n            return -6;\n        }\n\n        return 0;\n\n    } else if (report_id == 0x20) {\n        return 0;\n    }\n\n    return -99;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <cstring> \n\nstruct TelemetryParameterVulnerable {\n    uint16_t id;\n    const char* value_str;\n};\n\nclass TelemetryMessageBuilderVulnerable {\npublic:\n    TelemetryMessageBuilderVulnerable() : m_message_buffer(nullptr), m_buffer_size(0) {}\n\n    ~TelemetryMessageBuilderVulnerable() {\n        if (m_message_buffer) {\n            free(m_message_buffer);\n        }\n    }\n\n    void addParameter(uint16_t id, const char* value) {\n        if (value) {\n            m_parameters.push_back({id, value});\n        }\n    }\n\n    bool buildMessageVulnerable() {\n        if (m_message_buffer) {\n            free(m_message_buffer);\n            m_message_buffer = nullptr;\n            m_buffer_size = 0;\n        }\n\n        size_t calculated_total_len = 0;\n        for (const auto& param : m_parameters) {\n            // VULNERABILITY: Calculated length does NOT account for the null terminator\n            // that will be written for each string parameter. strlen() returns the length\n            // WITHOUT the null terminator. Each string requires strlen() + 1 byte for null termination.\n            calculated_total_len += sizeof(param.id) + strlen(param.value_str);\n        }\n\n        if (m_parameters.empty()) {\n            return true;\n        }\n\n        if (calculated_total_len == 0) {\n            // This case might be an error if parameters exist but total length is 0.\n            // For example, if all strings are empty and only IDs are present.\n            return false;\n        }\n\n        m_message_buffer = (uint8_t*)malloc(calculated_total_len);\n        if (!m_message_buffer) {\n            return false;\n        }\n        m_buffer_size = calculated_total_len;\n\n        size_t current_offset = 0;\n        for (const auto& param : m_parameters) {\n            // Write parameter ID (manual byte copy)\n            uint16_t network_order_id = param.id; \n            for (size_t i = 0; i < sizeof(network_order_id); ++i) {\n                // Basic bounds check, but the main vulnerability is in calculation of m_buffer_size\n                if (current_offset + i >= m_buffer_size) {\n                    free(m_message_buffer);\n                    m_message_buffer = nullptr;\n                    m_buffer_size = 0;\n                    return false;\n                }\n                m_message_buffer[current_offset + i] = ((uint8_t*)&network_order_id)[i];\n            }\n            current_offset += sizeof(network_order_id);\n\n            // Write parameter value string (includes null terminator)\n            size_t value_len = strlen(param.value_str);\n            for (size_t i = 0; i <= value_len; ++i) { // Loop includes the null terminator (i <= value_len)\n                // VULNERABILITY HERE: If buffer is exactly sized for `value_len` and this is the last item,\n                // `current_offset + i` will access `m_buffer_size` (out-of-bounds) when `i == value_len`,\n                // causing a heap-based buffer overflow for each string's null terminator.\n                if (current_offset + i >= m_buffer_size) {\n                    free(m_message_buffer);\n                    m_message_buffer = nullptr;\n                    m_buffer_size = 0;\n                    return false;\n                }\n                m_message_buffer[current_offset + i] = param.value_str[i];\n            }\n            current_offset += (value_len + 1); // Advance offset including null terminator\n        }\n\n        // This check comes *after* the potential overflow has already occurred.\n        if (current_offset > m_buffer_size) {\n            free(m_message_buffer);\n            m_message_buffer = nullptr;\n            m_buffer_size = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getMessageBuffer() const {\n        return m_message_buffer;\n    }\n\n    size_t getBufferSize() const {\n        return m_buffer_size;\n    }\n\nprivate:\n    std::vector<TelemetryParameterVulnerable> m_parameters;\n    uint8_t* m_message_buffer;\n    size_t m_buffer_size;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CAN_PAYLOAD_SIZE 8 \n#define RESPONSE_HEADER_SIZE 3 \n\nint constructDiagnosticResponse(uint8_t* output_buffer, uint16_t output_buffer_max_len,\n                                uint8_t message_id, uint8_t sub_id,\n                                const uint8_t* data_to_send, uint8_t data_len) {\n    if (output_buffer == NULL || data_to_send == NULL) {\n        return -1;\n    }\n\n    uint16_t required_payload_size = (uint16_t)RESPONSE_HEADER_SIZE + data_len;\n\n    if (required_payload_size > output_buffer_max_len) {\n        return -2;\n    }\n\n    output_buffer[0] = message_id;\n    output_buffer[1] = sub_id;\n    output_buffer[2] = data_len;\n\n    uint16_t current_payload_offset = RESPONSE_HEADER_SIZE;\n\n    for (uint8_t i = 0; i < data_len; ++i) { /* FIX: Changed <= to < to correctly limit iterations */\n        output_buffer[current_payload_offset + i] = data_to_send[i];\n    }\n\n    return required_payload_size;\n}\n\nvoid simulateCanRxHandler() {\n    uint8_t can_data_buffer[MAX_CAN_PAYLOAD_SIZE];\n    uint8_t sensor_data_to_reply[5];\n    memset(sensor_data_to_reply, 0xAA, sizeof(sensor_data_to_reply));\n\n    constructDiagnosticResponse(can_data_buffer, MAX_CAN_PAYLOAD_SIZE, 0x01, 0x10, sensor_data_to_reply, sizeof(sensor_data_to_reply));\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n\n#define MAX_CONFIG_PAYLOAD_SIZE 4096\n\ntypedef struct {\n    uint16_t total_payload_size;\n    uint16_t num_entries;\n} PacketHeaderVulnerable;\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t data_length;\n} ConfigEntryHeaderVulnerable;\n\nclass VehicleConfigProcessorVulnerable {\npublic:\n    VehicleConfigProcessorVulnerable() : processed_config_data(nullptr), current_data_offset(0) {}\n\n    ~VehicleConfigProcessorVulnerable() {\n        if (processed_config_data) {\n            free(processed_config_data);\n            processed_config_data = nullptr;\n        }\n    }\n\n    bool processConfigPacketVulnerable(const uint8_t* raw_packet, size_t raw_len) {\n        if (processed_config_data) {\n            free(processed_config_data);\n            processed_config_data = nullptr;\n        }\n\n        if (!raw_packet || raw_len < sizeof(PacketHeaderVulnerable)) {\n            return false;\n        }\n\n        const PacketHeaderVulnerable* pkt_header = reinterpret_cast<const PacketHeaderVulnerable*>(raw_packet);\n\n        if (pkt_header->total_payload_size > MAX_CONFIG_PAYLOAD_SIZE || pkt_header->total_payload_size == 0) {\n            return false;\n        }\n\n        size_t expected_min_raw_len = sizeof(PacketHeaderVulnerable) + (size_t)pkt_header->num_entries * sizeof(ConfigEntryHeaderVulnerable);\n        if (raw_len < expected_min_raw_len) {\n            return false;\n        }\n\n        processed_config_data = (uint8_t*)malloc(pkt_header->total_payload_size);\n        if (!processed_config_data) {\n            return false;\n        }\n        current_data_offset = 0;\n\n        size_t current_parse_offset = sizeof(PacketHeaderVulnerable);\n\n        for (uint16_t i = 0; i < pkt_header->num_entries; ++i) {\n            if (current_parse_offset + sizeof(ConfigEntryHeaderVulnerable) > raw_len) {\n                free(processed_config_data); processed_config_data = nullptr;\n                return false;\n            }\n\n            const ConfigEntryHeaderVulnerable* entry_header = \n                reinterpret_cast<const ConfigEntryHeaderVulnerable*>(raw_packet + current_parse_offset);\n            \n            if (current_parse_offset + sizeof(ConfigEntryHeaderVulnerable) + entry_header->data_length > raw_len) {\n                free(processed_config_data); processed_config_data = nullptr;\n                return false;\n            }\n\n            \n            for (uint16_t k = 0; k < entry_header->data_length; ++k) {\n                processed_config_data[current_data_offset + k] = \n                    raw_packet[current_parse_offset + sizeof(ConfigEntryHeaderVulnerable) + k];\n            }\n            current_data_offset += entry_header->data_length;\n            current_parse_offset += sizeof(ConfigEntryHeaderVulnerable) + entry_header->data_length;\n        }\n        \n        if (current_data_offset != pkt_header->total_payload_size) {\n            free(processed_config_data); processed_config_data = nullptr;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedConfigData() const { return processed_config_data; }\n    size_t getProcessedDataLength() const { return current_data_offset; }\n\nprivate:\n    uint8_t* processed_config_data;\n    size_t current_data_offset;\n};\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_CONFIG_ENTRIES 16\n#define CONFIG_VALUE_SIZE 4\n\ntypedef struct {\n    uint16_t param_id;\n    uint8_t  config_data[CONFIG_VALUE_SIZE];\n    uint8_t  status_flags;\n} ConfigEntry;\n\nstatic ConfigEntry g_config_entries[MAX_CONFIG_ENTRIES];\nstatic uint8_t g_num_config_entries = 0;\nstatic int16_t g_last_updated_idx = -1;\n\nvoid init_config_manager() {\n    memset(g_config_entries, 0, sizeof(g_config_entries));\n    g_num_config_entries = 0;\n    g_last_updated_idx = -1;\n}\n\nbool add_config_entry(uint16_t id, const uint8_t* data) {\n    if (g_num_config_entries >= MAX_CONFIG_ENTRIES) {\n        return false;\n    }\n    ConfigEntry* entry = &g_config_entries[g_num_config_entries];\n    entry->param_id = id;\n    memcpy(entry->config_data, data, CONFIG_VALUE_SIZE);\n    entry->status_flags = 0xFF;\n    g_last_updated_idx = g_num_config_entries;\n    g_num_config_entries++;\n    return true;\n}\n\nvoid access_config_entry(uint16_t index) {\n    if (index < g_num_config_entries) {\n        volatile uint16_t id = g_config_entries[index].param_id;\n        (void)id;\n    }\n}\n\nvoid update_preceding_config_marker_vulnerable(int16_t offset_from_first_entry, uint8_t marker_val) {\n    if (g_num_config_entries == 0) {\n        return;\n    }\n\n    int16_t target_idx = offset_from_first_entry;\n\n    if (target_idx < 0 || target_idx >= MAX_CONFIG_ENTRIES) {\n        return;\n    }\n\n    uint8_t* current_entry_byte_ptr = (uint8_t*)&g_config_entries[target_idx];\n\n    uint8_t* marker_location_ptr = current_entry_byte_ptr - 1;\n\n    *marker_location_ptr = marker_val;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRIES 32\n#define LOG_ENTRY_SIZE 8\n\ntypedef struct {\n    uint32_t event_id;\n    uint32_t timestamp;\n} LogEntry;\n\nstatic LogEntry g_diag_log_buffer[MAX_LOG_ENTRIES];\nstatic uint16_t g_log_count = 0;\n\nvoid init_diag_log() {\n    memset(g_diag_log_buffer, 0, sizeof(g_diag_log_buffer));\n    g_log_count = 0;\n}\n\nbool add_log_entry(uint32_t event_id, uint32_t timestamp) {\n    if (g_log_count >= MAX_LOG_ENTRIES) {\n        return false;\n    }\n    g_diag_log_buffer[g_log_count].event_id = event_id;\n    g_diag_log_buffer[g_log_count].timestamp = timestamp;\n    g_log_count++;\n    return true;\n}\n\nvoid clear_log_segment_vulnerable(uint16_t entries_to_clear_from_end) {\n    if (g_log_count == 0) {\n        return;\n    }\n\n    if (entries_to_clear_from_end > g_log_count) {\n        g_log_count = 0;\n        return;\n    }\n\n    g_log_count -= entries_to_clear_from_end;\n\n    ((uint8_t*)g_diag_log_buffer)[g_log_count * LOG_ENTRY_SIZE - 1] = 0xDE;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_DATA_BUFFER_SIZE 256\n#define COMPRESSED_PACKET_MAX_SIZE 128\n\ntypedef struct {\n    uint8_t  chunk_type;\n    uint8_t  compressed_len;\n} CompressedChunkHeader;\n\nstatic uint8_t g_decompressedConfigData[MAX_CONFIG_DATA_BUFFER_SIZE];\nstatic uint16_t g_decompressedDataOffset = 0;\n\nvoid initDecompressor() {\n    memset(g_decompressedConfigData, 0, MAX_CONFIG_DATA_BUFFER_SIZE);\n    g_decompressedDataOffset = 0;\n}\n\nint decompress_rle_chunk(const uint8_t* input_ptr, uint8_t compressed_len,\n                         uint8_t* output_ptr, uint16_t output_buffer_max_len,\n                         uint16_t current_output_offset) {\n    if (input_ptr == NULL || output_ptr == NULL || compressed_len % 2 != 0) {\n        return -1;\n    }\n\n    uint16_t bytes_written_in_chunk = 0;\n    uint8_t input_bytes_processed = 0;\n\n    while (input_bytes_processed < compressed_len) {\n        if (input_bytes_processed + 2 > compressed_len) {\n            return -2;\n        }\n\n        uint8_t byte_value = input_ptr[input_bytes_processed];\n        uint8_t repeat_count = input_ptr[input_bytes_processed + 1];\n\n        for (uint8_t i = 0; i < repeat_count; ++i) {\n            output_ptr[current_output_offset + bytes_written_in_chunk] = byte_value;\n            bytes_written_in_chunk++;\n        }\n        input_bytes_processed += 2;\n    }\n    return bytes_written_in_chunk;\n}\n\nint processCompressedConfigPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len == 0 || packet_len > COMPRESSED_PACKET_MAX_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_packet_offset = 0;\n    \n    while (current_packet_offset < packet_len) {\n        if (current_packet_offset + sizeof(CompressedChunkHeader) > packet_len) {\n            return -2;\n        }\n\n        const CompressedChunkHeader* header = (const CompressedChunkHeader*)(packet + current_packet_offset);\n        uint8_t chunk_type = header->chunk_type;\n        uint8_t compressed_chunk_len = header->compressed_len;\n\n        if (current_packet_offset + sizeof(CompressedChunkHeader) + compressed_chunk_len > packet_len) {\n            return -3;\n        }\n\n        const uint8_t* chunk_data_ptr = packet + current_packet_offset + sizeof(CompressedChunkHeader);\n\n        int decompress_result;\n        if (chunk_type == 0x01) {\n            decompress_result = decompress_rle_chunk(chunk_data_ptr, compressed_chunk_len,\n                                                    g_decompressedConfigData,\n                                                    MAX_CONFIG_DATA_BUFFER_SIZE,\n                                                    g_decompressedDataOffset);\n            if (decompress_result < 0) {\n                return -4;\n            }\n            g_decompressedDataOffset += decompress_result;\n        } else {\n\n        }\n\n        current_packet_offset += sizeof(CompressedChunkHeader) + compressed_chunk_len;\n    }\n\n    return 0;\n}\n\nvoid receiveCompressedUpdate(const uint8_t* data, uint16_t len) {\n    initDecompressor();\n    processCompressedConfigPacket(data, len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define EVENT_LOG_BUFFER_SIZE 256\n#define MAX_EVENT_CODE 0xFFF\n\ntypedef struct {\n    uint16_t eventCode;\n    uint32_t timestamp;\n    uint8_t  severity;\n    uint8_t  data[4];\n} VehicleEventEntry_Fixed;\n\nstatic VehicleEventEntry_Fixed g_eventLogBuffer_fixed[EVENT_LOG_BUFFER_SIZE];\nstatic uint16_t g_eventLogWriteIndex_fixed = 0;\nstatic bool g_eventLogWrapped_fixed = false;\n\nvoid logRecorderError_fixed(const char* msg) {\n}\n\nVehicleEventEntry_Fixed receiveVehicleEvent_fixed() {\n    VehicleEventEntry_Fixed event;\n    event.eventCode = 0x100;\n    event.timestamp = 0xDEADBEEF;\n    event.severity = 5;\n    event.data[0] = 0xAA; event.data[1] = 0xBB; event.data[2] = 0xCC; event.data[3] = 0xDD;\n    return event;\n}\n\nvoid initializeEventLog_fixed() {\n    for (uint16_t i = 0; i < EVENT_LOG_BUFFER_SIZE; ++i) {\n        g_eventLogBuffer_fixed[i] = (VehicleEventEntry_Fixed){0, 0, 0, {0,0,0,0}};\n    }\n    g_eventLogWriteIndex_fixed = EVENT_LOG_BUFFER_SIZE - 1;\n    g_eventLogWrapped_fixed = false;\n    logRecorderError_fixed(\"Vehicle event log initialized.\");\n}\n\nvoid recordVehicleEvent_fixed(VehicleEventEntry_Fixed event) {\n    g_eventLogBuffer_fixed[g_eventLogWriteIndex_fixed] = event;\n\n    g_eventLogWriteIndex_fixed = (g_eventLogWriteIndex_fixed + 1) % EVENT_LOG_BUFFER_SIZE;\n\n    if (g_eventLogWriteIndex_fixed == 0 && !g_eventLogWrapped_fixed) {\n        g_eventLogWrapped_fixed = true;\n    }\n    logRecorderError_fixed(\"Vehicle event recorded.\");\n}\n\nvoid vehicleEventRecorderMain_fixed() {\n    initializeEventLog_fixed();\n\n    VehicleEventEntry_Fixed receivedEvent = receiveVehicleEvent_fixed();\n    recordVehicleEvent_fixed(receivedEvent);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 256\n\nstatic uint8_t g_vehicle_config_data[VEHICLE_CONFIG_BUFFER_SIZE];\nstatic uint16_t g_active_config_segment_base_idx = 0;\n\nvoid init_vehicle_config() {\n    memset(g_vehicle_config_data, 0xFF, VEHICLE_CONFIG_BUFFER_SIZE);\n    g_active_config_segment_base_idx = 0;\n}\n\nbool set_active_config_segment(uint16_t segment_id) {\n    if (segment_id == 0x01) {\n        g_active_config_segment_base_idx = 0;\n    } else if (segment_id == 0x02) {\n        g_active_config_segment_base_idx = 50;\n    } else if (segment_id == 0x03) {\n        g_active_config_segment_base_idx = 120;\n    } else {\n        return false;\n    }\n    return true;\n}\n\nvoid update_config_segment_vulnerable(int16_t relative_start_offset, const uint8_t* data, uint16_t data_len) {\n    if (data == NULL || data_len == 0) {\n        return;\n    }\n\n    int32_t target_abs_idx = (int32_t)g_active_config_segment_base_idx + relative_start_offset;\n\n    if (target_abs_idx + data_len > VEHICLE_CONFIG_BUFFER_SIZE || data_len > VEHICLE_CONFIG_BUFFER_SIZE) {\n        return;\n    }\n\n    memcpy(&g_vehicle_config_data[target_abs_idx], data, data_len);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMAND_PAYLOAD_SIZE 128\n#define COMMAND_FRAME_HEADER_SIZE (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t))\n#define COMMAND_BUFFER_TOTAL_SIZE 256\n\ntypedef struct {\n    uint16_t command_id;\n    uint8_t  payload_length;\n    uint8_t  reserved_byte;\n    uint8_t  payload[MAX_COMMAND_PAYLOAD_SIZE];\n    uint8_t  final_status_marker;\n} DiagnosticCommandFrame;\n\nstatic uint8_t g_rx_command_buffer[COMMAND_BUFFER_TOTAL_SIZE];\nstatic uint32_t g_rx_data_length = 0;\n\nvoid receive_raw_command(const uint8_t* data, uint32_t len) {\n    if (len > COMMAND_BUFFER_TOTAL_SIZE) {\n        len = COMMAND_BUFFER_TOTAL_SIZE;\n    }\n    memcpy(g_rx_command_buffer, data, len);\n    g_rx_data_length = len;\n}\n\nvoid process_parsed_command(const DiagnosticCommandFrame* frame) {\n    volatile uint16_t cmd_id = frame->command_id;\n    (void)cmd_id;\n}\n\n// Fixed function: Prevents buffer underwrite by validating the calculated target index.\nvoid update_command_final_status_fixed(uint8_t status_value, uint8_t external_status_offset) {\n    if (g_rx_data_length < COMMAND_FRAME_HEADER_SIZE) {\n        return;\n    }\n\n    DiagnosticCommandFrame* current_frame = (DiagnosticCommandFrame*)g_rx_command_buffer;\n    uint8_t effective_payload_len = current_frame->payload_length;\n\n    // Sanitize effective_payload_len to prevent calculations beyond valid data\n    // and ensure the calculated base position doesn't exceed the buffer bounds\n    if (effective_payload_len > MAX_COMMAND_PAYLOAD_SIZE ||\n        (COMMAND_FRAME_HEADER_SIZE + effective_payload_len) > g_rx_data_length) {\n        // The frame is malformed or incomplete, cannot safely determine end of payload\n        return;\n    }\n\n    int32_t base_pos = (int32_t)(COMMAND_FRAME_HEADER_SIZE + effective_payload_len);\n    int32_t target_idx = base_pos - external_status_offset;\n\n    // CRITICAL FIX: Validate target_idx to prevent buffer underwrite or overflow.\n    // target_idx must be non-negative and within the bounds of the currently received data.\n    if (target_idx < 0 || target_idx >= (int32_t)g_rx_data_length) {\n        return; // Prevent out-of-bounds access\n    }\n\n    g_rx_command_buffer[target_idx] = status_value;\n\n    process_parsed_command(current_frame);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMAND_HISTORY 64\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t status;\n    uint16_t value;\n    uint32_t timestamp_ms;\n} VehicleCommandEntry;\n\nstatic VehicleCommandEntry g_command_history[MAX_COMMAND_HISTORY];\nstatic uint16_t g_current_command_count = 0;\nstatic uint32_t g_current_time_ms = 0;\n\nvoid init_command_history_system() {\n    memset(g_command_history, 0, sizeof(g_command_history));\n    g_current_command_count = 0;\n    g_current_time_ms = 0;\n}\n\nvoid increment_system_time(uint32_t ms) {\n    g_current_time_ms += ms;\n}\n\nbool record_vehicle_command(uint8_t cmd_id, uint16_t val) {\n    if (g_current_command_count >= MAX_COMMAND_HISTORY) {\n        return false;\n    }\n\n    g_command_history[g_current_command_count].command_id = cmd_id;\n    g_command_history[g_current_command_count].status = 0x01;\n    g_command_history[g_current_command_count].value = val;\n    g_command_history[g_current_command_count].timestamp_ms = g_current_time_ms;\n    g_current_command_count++;\n    return true;\n}\n\n#define CMD_TYPE_BRAKE 0x05\n#define CMD_TYPE_ACCELERATE 0x06\n#define CMD_TYPE_PARK 0x07\n\n#define STATUS_PROCESSED 0x02\n#define STATUS_CANCELED_IMPACT 0x04\n\nvoid process_recent_commands_fixed() {\n    if (g_current_command_count == 0) {\n        return;\n    }\n\n    for (int i = (int)g_current_command_count - 1; i >= 0; --i) {\n        switch (g_command_history[i].command_id) {\n            case CMD_TYPE_BRAKE:\n                if (i > 0) { \n                    g_command_history[i - 1].status |= STATUS_CANCELED_IMPACT;\n                }\n                g_command_history[i].status = STATUS_PROCESSED;\n                break;\n            case CMD_TYPE_ACCELERATE:\n                g_command_history[i].status = STATUS_PROCESSED;\n                break;\n            case CMD_TYPE_PARK:\n                g_command_history[i].status = STATUS_PROCESSED;\n                break;\n            default:\n                break;\n        }\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_TELEMETRY_PACKET_SIZE 100\n#define FIXED_LOG_BUFFER_SIZE 32\n#define MAX_LOG_ENTRIES 5\n\ntypedef struct {\n    uint16_t packet_id;\n    uint8_t  dynamic_payload_len;\n    uint8_t  payload_data[MAX_TELEMETRY_PACKET_SIZE - 3];\n} TelemetryDataPacket;\n\ntypedef struct {\n    uint16_t log_id;\n    uint8_t  actual_payload_len;\n    uint8_t  fixed_log_buffer[FIXED_LOG_BUFFER_SIZE];\n    uint32_t timestamp;\n} TelemetryLogEntry;\n\nstatic TelemetryLogEntry g_telemetryLog[MAX_LOG_ENTRIES];\nstatic uint8_t g_currentLogEntryIndex = 0;\n\nvoid initTelemetryLog() {\n    for (int i = 0; i < MAX_LOG_ENTRIES; ++i) {\n        g_telemetryLog[i].log_id = 0;\n        g_telemetryLog[i].actual_payload_len = 0;\n        for (int j = 0; j < FIXED_LOG_BUFFER_SIZE; ++j) {\n            g_telemetryLog[i].fixed_log_buffer[j] = 0;\n        }\n        g_telemetryLog[i].timestamp = 0;\n    }\n    g_currentLogEntryIndex = 0;\n}\n\nint processTelemetryPacket(const TelemetryDataPacket* packet, uint32_t current_timestamp) {\n    if (packet == NULL) {\n        return -1;\n    }\n\n    if (g_currentLogEntryIndex >= MAX_LOG_ENTRIES) {\n        return -2;\n    }\n\n    TelemetryLogEntry* current_entry = &g_telemetryLog[g_currentLogEntryIndex];\n\n    current_entry->log_id = packet->packet_id;\n    current_entry->timestamp = current_timestamp;\n\n    uint8_t bytes_to_copy = packet->dynamic_payload_len;\n\n    if (bytes_to_copy > FIXED_LOG_BUFFER_SIZE) {\n        bytes_to_copy = FIXED_LOG_BUFFER_SIZE;\n    }\n\n    for (uint8_t i = 0; i < bytes_to_copy; ++i) {\n        current_entry->fixed_log_buffer[i] = packet->payload_data[i];\n    }\n    \n    current_entry->actual_payload_len = bytes_to_copy;\n\n    g_currentLogEntryIndex++;\n\n    return 0;\n}\n\nvoid simulateTelemetryReception() {\n    initTelemetryLog();\n\n    TelemetryDataPacket packet1 = {0};\n    packet1.packet_id = 0x101;\n    packet1.dynamic_payload_len = 20;\n    for (int i = 0; i < 20; ++i) {\n        packet1.payload_data[i] = (uint8_t)i;\n    }\n    processTelemetryPacket(&packet1, 1000);\n\n    TelemetryDataPacket packet2 = {0};\n    packet2.packet_id = 0x102;\n    packet2.dynamic_payload_len = 40;\n    for (int i = 0; i < 40; ++i) {\n        packet2.payload_data[i] = 0xAA;\n    }\n    processTelemetryPacket(&packet2, 1001);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#define NUM_VEHICLE_MODES 4\n#define NUM_MODE_PARAMS 3\n\ntypedef enum {\n    MODE_PARAM_THROTTLE = 0,\n    MODE_PARAM_SUSPENSION,\n    MODE_PARAM_STEERING\n} ModeParameterIndex;\n\ntypedef struct {\n    int parameters[NUM_MODE_PARAMS];\n} VehicleModeConfig;\n\nstatic VehicleModeConfig g_vehicleModeConfigurations[NUM_VEHICLE_MODES];\n\ntypedef struct {\n    unsigned char mode_id;\n    unsigned char parameter_idx;\n    int new_value;\n} ConfigurationUpdateCommand;\n\nConfigurationUpdateCommand receiveConfigUpdateCommand_fixed() {\n    ConfigurationUpdateCommand cmd;\n    cmd.mode_id = 0;\n    cmd.parameter_idx = 3;\n    cmd.new_value = 123;\n    return cmd;\n}\n\nvoid logSystemDiagnostic(const char* msg) {\n}\n\nvoid initializeVehicleConfigs_fixed() {\n    for (unsigned char i = 0; i < NUM_VEHICLE_MODES; ++i) {\n        for (unsigned char j = 0; j < NUM_MODE_PARAMS; ++j) {\n            g_vehicleModeConfigurations[i].parameters[j] = 50;\n        }\n    }\n}\n\nvoid applyVehicleConfigUpdate_fixed() {\n    ConfigurationUpdateCommand cmd = receiveConfigUpdateCommand_fixed();\n\n    if (cmd.mode_id < NUM_VEHICLE_MODES) {\n        if (cmd.parameter_idx < NUM_MODE_PARAMS) {\n            g_vehicleModeConfigurations[cmd.mode_id].parameters[cmd.parameter_idx] = cmd.new_value;\n        } else {\n            logSystemDiagnostic(\"WARNING: Attempted to update out-of-bounds mode parameter index.\");\n        }\n    } else {\n        logSystemDiagnostic(\"ERROR: Invalid mode ID received for configuration update.\");\n    }\n}\n\nvoid vehicleControlMain_fixed() {\n    initializeVehicleConfigs_fixed();\n    applyVehicleConfigUpdate_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CONFIG_LOG_BUFFER_SIZE 128\n#define CONFIG_ENTRY_SIZE 8 \n\nstatic uint8_t g_config_log_buffer[CONFIG_LOG_BUFFER_SIZE];\nstatic uint32_t g_log_current_offset = 0; \n\nvoid init_config_log_fixed() {\n    memset(g_config_log_buffer, 0, CONFIG_LOG_BUFFER_SIZE);\n    g_log_current_offset = 0;\n}\n\nbool log_config_state_fixed(uint64_t state_value) {\n    if (g_log_current_offset + CONFIG_ENTRY_SIZE > CONFIG_LOG_BUFFER_SIZE) {\n        return false;\n    }\n    g_config_log_buffer[g_log_current_offset + 0] = (uint8_t)(state_value);\n    g_config_log_buffer[g_log_current_offset + 1] = (uint8_t)(state_value >> 8);\n    g_config_log_buffer[g_log_current_offset + 2] = (uint8_t)(state_value >> 16);\n    g_config_log_buffer[g_log_current_offset + 3] = (uint8_t)(state_value >> 24);\n    g_config_log_buffer[g_log_current_offset + 4] = (uint8_t)(state_value >> 32);\n    g_config_log_buffer[g_log_current_offset + 5] = (uint8_t)(state_value >> 40);\n    g_config_log_buffer[g_log_current_offset + 6] = (uint8_t)(state_value >> 48);\n    g_config_log_buffer[g_log_current_offset + 7] = (uint8_t)(state_value >> 56);\n    g_log_current_offset += CONFIG_ENTRY_SIZE;\n    return true;\n}\n\nvoid revert_and_mark_config_state_fixed(uint32_t entry_count_to_revert, uint8_t marker_value) {\n    if (g_log_current_offset == 0) {\n        return;\n    }\n\n    uint32_t bytes_to_revert = entry_count_to_revert * CONFIG_ENTRY_SIZE;\n\n    int32_t potential_target_byte_offset = (int32_t)g_log_current_offset - (int32_t)bytes_to_revert;\n\n    if (potential_target_byte_offset < 0) {\n        g_log_current_offset = 0;\n    } else {\n        g_log_current_offset = (uint32_t)potential_target_byte_offset;\n    }\n\n    int32_t marker_idx = potential_target_byte_offset - 1;\n    if (marker_idx >= 0 && (uint32_t)marker_idx < CONFIG_LOG_BUFFER_SIZE) {\n        g_config_log_buffer[marker_idx] = marker_value;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define CFG_GROUP_ENGINE_DIAG_VULNERABLE       0\n#define CFG_GROUP_TRANSMISSION_CAL_VULNERABLE  1\n#define CFG_GROUP_ADAS_SETTINGS_VULNERABLE     2\n#define NUM_CFG_GROUPS_VULNERABLE              3\n\n#define MAX_PARAMS_PER_GROUP_VULNERABLE        10\n\ntypedef struct {\n    uint32_t value;\n    uint8_t  type;\n    bool     is_writable;\n} ConfigParameter_Vulnerable;\n\nstatic ConfigParameter_Vulnerable g_config_parameters_vulnerable[NUM_CFG_GROUPS_VULNERABLE][MAX_PARAMS_PER_GROUP_VULNERABLE];\n\nstatic const uint8_t g_actual_params_in_group_vulnerable[NUM_CFG_GROUPS_VULNERABLE] = {\n    5,\n    8,\n    3\n};\n\nvoid log_config_system_error_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t group_id;\n    uint8_t param_index;\n} ConfigReadRequest_Vulnerable;\n\nConfigReadRequest_Vulnerable receive_config_read_request_vulnerable() {\n    ConfigReadRequest_Vulnerable req;\n    req.group_id = CFG_GROUP_ADAS_SETTINGS_VULNERABLE;\n    req.param_index = 3;\n    return req;\n}\n\nvoid initialize_config_data_vulnerable() {\n    for (uint8_t i = 0; i < NUM_CFG_GROUPS_VULNERABLE; ++i) {\n        for (uint8_t j = 0; j < g_actual_params_in_group_vulnerable[i]; ++j) {\n            g_config_parameters_vulnerable[i][j].value = (uint32_t)(i << 16) | j;\n            g_config_parameters_vulnerable[i][j].type = 0x01;\n            g_config_parameters_vulnerable[i][j].is_writable = true;\n        }\n        for (uint8_t j = g_actual_params_in_group_vulnerable[i]; j < MAX_PARAMS_PER_GROUP_VULNERABLE; ++j) {\n             g_config_parameters_vulnerable[i][j].value = 0xFFFFFFFF;\n             g_config_parameters_vulnerable[i][j].type = 0xFF;\n             g_config_parameters_vulnerable[i][j].is_writable = false;\n        }\n    }\n    log_config_system_error_vulnerable(\"Configuration data initialized (vulnerable).\");\n}\n\nvoid read_config_parameter_vulnerable() {\n    ConfigReadRequest_Vulnerable req = receive_config_read_request_vulnerable();\n\n    if (req.group_id < NUM_CFG_GROUPS_VULNERABLE) {\n        if (req.param_index < MAX_PARAMS_PER_GROUP_VULNERABLE) {\n            ConfigParameter_Vulnerable param = g_config_parameters_vulnerable[req.group_id][req.param_index];\n            log_config_system_error_vulnerable(\"Configuration parameter read (vulnerable).\");\n        } else {\n            log_config_system_error_vulnerable(\"Configuration parameter index out of global bounds.\");\n        }\n    } else {\n        log_config_system_error_vulnerable(\"Configuration group ID out of bounds.\");\n    }\n}\n\nvoid config_manager_main_vulnerable() {\n    initialize_config_data_vulnerable();\n    read_config_parameter_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_STORAGE_SIZE 128\n#define CONFIG_VALUE_BYTE_SIZE 4\n\nstatic uint8_t g_vehicle_config_storage[VEHICLE_CONFIG_STORAGE_SIZE];\nstatic uint32_t g_current_config_data_len = 0;\n\nvoid init_ecu_config_manager() {\n    memset(g_vehicle_config_storage, 0, VEHICLE_CONFIG_STORAGE_SIZE);\n    g_current_config_data_len = 0;\n}\n\nvoid load_config_data_block(const uint8_t* data, uint32_t len) {\n    if (len > VEHICLE_CONFIG_STORAGE_SIZE) {\n        len = VEHICLE_CONFIG_STORAGE_SIZE;\n    }\n    memcpy(g_vehicle_config_storage, data, len);\n    g_current_config_data_len = len;\n}\n\nvoid update_past_config_value_fixed(uint32_t start_index_bytes, uint8_t backward_steps_slots, int32_t new_value) {\n    if (start_index_bytes >= g_current_config_data_len) {\n        return;\n    }\n\n    int32_t target_byte_offset = (int32_t)start_index_bytes - ((int32_t)backward_steps_slots * CONFIG_VALUE_BYTE_SIZE);\n\n    if (target_byte_offset < 0 || (target_byte_offset + CONFIG_VALUE_BYTE_SIZE) > VEHICLE_CONFIG_STORAGE_SIZE) {\n        return;\n    }\n\n    g_vehicle_config_storage[target_byte_offset + 0] = (uint8_t)(new_value >> 24);\n    g_vehicle_config_storage[target_byte_offset + 1] = (uint8_t)(new_value >> 16);\n    g_vehicle_config_storage[target_byte_offset + 2] = (uint8_t)(new_value >> 8);\n    g_vehicle_config_storage[target_byte_offset + 3] = (uint8_t)(new_value);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <new>\n\n#pragma pack(push, 1)\nstruct EventRecordHeaderVulnerable {\n    uint16_t event_type;\n    uint16_t data_size; \n};\n#pragma pack(pop)\n\nclass EventRecordVulnerable {\npublic:\n    EventRecordVulnerable() : m_event_data(nullptr), m_allocated_data_size(0) {}\n\n    ~EventRecordVulnerable() {\n        if (m_event_data) {\n            delete[] m_event_data;\n            m_event_data = nullptr;\n        }\n    }\n\n    bool populateFromRawDataVulnerable(const uint8_t* raw_input_block, size_t input_block_len) {\n        if (!raw_input_block || input_block_len < sizeof(EventRecordHeaderVulnerable)) {\n            return false;\n        }\n\n        const EventRecordHeaderVulnerable* header = reinterpret_cast<const EventRecordHeaderVulnerable*>(raw_input_block);\n        \n        uint16_t advertised_data_len = header->data_size;\n\n        if (m_event_data) {\n            delete[] m_event_data;\n            m_event_data = nullptr;\n        }\n\n        m_event_data = new (std::nothrow) uint8_t[advertised_data_len];\n        if (!m_event_data) {\n            m_allocated_data_size = 0;\n            return false;\n        }\n        m_allocated_data_size = advertised_data_len;\n\n        size_t bytes_to_copy = input_block_len - sizeof(EventRecordHeaderVulnerable);\n\n        for (size_t i = 0; i < bytes_to_copy; ++i) {\n            m_event_data[i] = raw_input_block[sizeof(EventRecordHeaderVulnerable) + i];\n        }\n\n        return true;\n    }\n\n    const uint8_t* getEventData() const {\n        return m_event_data;\n    }\n\n    uint16_t getAllocatedDataSize() const {\n        return m_allocated_data_size;\n    }\n\nprivate:\n    uint8_t* m_event_data;\n    uint16_t m_allocated_data_size;\n};\n\nclass VehicleEventDataManagerVulnerable {\npublic:\n    VehicleEventDataManagerVulnerable() {}\n    ~VehicleEventDataManagerVulnerable() {\n        for (auto* record : m_records) {\n            delete record;\n        }\n    }\n\n    bool addEventFromPacketVulnerable(const uint8_t* packet_data, size_t packet_len) {\n        EventRecordVulnerable* new_record = new (std::nothrow) EventRecordVulnerable();\n        if (!new_record) {\n            return false;\n        }\n\n        if (!new_record->populateFromRawDataVulnerable(packet_data, packet_len)) {\n            delete new_record;\n            return false;\n        }\n\n        m_records.push_back(new_record);\n        return true;\n    }\n\n    size_t getNumRecords() const {\n        return m_records.size();\n    }\n\n    const EventRecordVulnerable* getRecord(size_t index) const {\n        if (index < m_records.size()) {\n            return m_records[index];\n        }\n        return nullptr;\n    }\n\nprivate:\n    std::vector<EventRecordVulnerable*> m_records;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SENSOR_LOG_BUFFER_SIZE 64\n#define SENSOR_DATA_INVALID_MARKER 0xFF\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t sensor_id;\n    int16_t  value;\n} SensorLogEntry;\n\nstatic SensorLogEntry g_sensor_log_buffer[SENSOR_LOG_BUFFER_SIZE];\nstatic uint16_t g_log_head_idx = 0;\n\nvoid init_sensor_logger() {\n    memset(g_sensor_log_buffer, 0, sizeof(g_sensor_log_buffer));\n    g_log_head_idx = 0;\n}\n\nvoid add_sensor_reading(uint32_t ts, uint16_t id, int16_t val) {\n    g_sensor_log_buffer[g_log_head_idx].timestamp = ts;\n    g_sensor_log_buffer[g_log_head_idx].sensor_id = id;\n    g_sensor_log_buffer[g_log_head_idx].value = val;\n    g_log_head_idx = (g_log_head_idx + 1) % SENSOR_LOG_BUFFER_SIZE;\n}\n\nvoid invalidate_oldest_log_entries_vulnerable(uint16_t num_entries_to_invalidate) {\n    if (num_entries_to_invalidate == 0) {\n        return;\n    }\n\n    int32_t conceptual_start_offset = (int32_t)g_log_head_idx - num_entries_to_invalidate;\n\n    for (uint16_t i = 0; i < num_entries_to_invalidate; ++i) {\n        uint16_t target_idx = (uint16_t)((conceptual_start_offset + i) % SENSOR_LOG_BUFFER_SIZE);\n        g_sensor_log_buffer[target_idx].value = SENSOR_DATA_INVALID_MARKER;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_MESSAGE_TYPES 5\n#define MAX_FIELDS_PER_MESSAGE_TYPE 8 \n#define PAYLOAD_MAX_SIZE 8\n\nvoid automotiveLog(const char* msg) {\n    printf(\"LOG_VULN: %s\\n\", msg);\n}\n\ntypedef enum {\n    FIELD_TYPE_UINT8 = 0,\n    FIELD_TYPE_UINT16 = 1,\n    FIELD_TYPE_UINT32 = 2,\n    FIELD_TYPE_FLOAT = 3\n} FieldDataType;\n\ntypedef struct {\n    uint8_t offset;    \n    uint8_t size;      \n    FieldDataType type;\n} FieldInfo;\n\ntypedef struct {\n    uint8_t message_id;\n    uint8_t num_defined_fields; \n    FieldInfo fields[MAX_FIELDS_PER_MESSAGE_TYPE]; \n} MessageDescriptor;\n\nstatic MessageDescriptor g_messageDescriptors_vulnerable[MAX_MESSAGE_TYPES];\n\ntypedef struct {\n    uint8_t  message_id;\n    uint8_t  payload[PAYLOAD_MAX_SIZE];\n    uint8_t  requested_field_index; \n} NetworkMessage_vulnerable;\n\nvoid initializeMessageDescriptors_vulnerable() {\n    g_messageDescriptors_vulnerable[0].message_id = 0x10;\n    g_messageDescriptors_vulnerable[0].num_defined_fields = 2;\n    g_messageDescriptors_vulnerable[0].fields[0] = (FieldInfo){0, 2, FIELD_TYPE_UINT16};\n    g_messageDescriptors_vulnerable[0].fields[1] = (FieldInfo){2, 1, FIELD_TYPE_UINT8};\n\n    g_messageDescriptors_vulnerable[1].message_id = 0x20;\n    g_messageDescriptors_vulnerable[1].num_defined_fields = 1;\n    g_messageDescriptors_vulnerable[1].fields[0] = (FieldInfo){0, 2, FIELD_TYPE_UINT16};\n\n    g_messageDescriptors_vulnerable[2].message_id = 0x30;\n    g_messageDescriptors_vulnerable[2].num_defined_fields = 2;\n    g_messageDescriptors_vulnerable[2].fields[0] = (FieldInfo){0, 4, FIELD_TYPE_FLOAT};\n    g_messageDescriptors_vulnerable[2].fields[1] = (FieldInfo){4, 4, FIELD_TYPE_FLOAT};\n\n    for(int i = 3; i < MAX_MESSAGE_TYPES; ++i) {\n        g_messageDescriptors_vulnerable[i].message_id = 0xFF;\n        g_messageDescriptors_vulnerable[i].num_defined_fields = 0;\n    }\n}\n\nNetworkMessage_vulnerable receiveNetworkMessage_vulnerable() {\n    NetworkMessage_vulnerable msg;\n    msg.message_id = 0x10;\n    msg.requested_field_index = 3;\n    msg.payload[0] = 0xCD; msg.payload[1] = 0xAB;\n    msg.payload[2] = 0x50;\n    memset(msg.payload + 3, 0x00, PAYLOAD_MAX_SIZE - 3);\n    return msg;\n}\n\nvoid processNetworkMessage_vulnerable() {\n    NetworkMessage_vulnerable msg = receiveNetworkMessage_vulnerable();\n    uint8_t descriptor_idx = 0xFF;\n\n    for (uint8_t i = 0; i < MAX_MESSAGE_TYPES; ++i) {\n        if (g_messageDescriptors_vulnerable[i].message_id == msg.message_id) {\n            descriptor_idx = i;\n            break;\n        }\n    }\n\n    if (descriptor_idx != 0xFF) {\n        MessageDescriptor* descriptor = &g_messageDescriptors_vulnerable[descriptor_idx];\n\n        FieldInfo field_to_extract = descriptor->fields[msg.requested_field_index];\n\n        automotiveLog(\"Attempting to extract data from payload (vulnerable).\");\n\n        if (field_to_extract.offset < PAYLOAD_MAX_SIZE && (field_to_extract.offset + field_to_extract.size) <= PAYLOAD_MAX_SIZE) {\n            uint32_t extracted_val = 0;\n            switch (field_to_extract.type) {\n                case FIELD_TYPE_UINT8:\n                    extracted_val = msg.payload[field_to_extract.offset];\n                    break;\n                case FIELD_TYPE_UINT16:\n                    memcpy(&extracted_val, msg.payload + field_to_extract.offset, 2);\n                    break;\n                case FIELD_TYPE_UINT32:\n                    memcpy(&extracted_val, msg.payload + field_to_extract.offset, 4);\n                    break;\n                case FIELD_TYPE_FLOAT:\n                    memcpy(&extracted_val, msg.payload + field_to_extract.offset, 4);\n                    break;\n                default:\n                    automotiveLog(\"Unknown field type detected from descriptor.\");\n                    break;\n            }\n        } else {\n            automotiveLog(\"Field offset or size out of payload bounds (likely due to bad index).\");\n        }\n    } else {\n        automotiveLog(\"Received message with unknown ID.\");\n    }\n}\n\nvoid automotiveMain_vulnerable() {\n    initializeMessageDescriptors_vulnerable();\n    processNetworkMessage_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DTC_METADATA_PROTO_MAX 60\n#define MAX_INTERNAL_DTC_METADATA_SIZE 30\n\n#define MAX_LOGGED_DTC_RECORDS 20\n#define DTC_RECORD_FIXED_SIZE (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t))\n#define SINGLE_DTC_RECORD_STORAGE_SIZE (DTC_RECORD_FIXED_SIZE + MAX_INTERNAL_DTC_METADATA_SIZE)\n#define DTC_LOG_BUFFER_TOTAL_SIZE (MAX_LOGGED_DTC_RECORDS * SINGLE_DTC_RECORD_STORAGE_SIZE)\n\ntypedef struct {\n    uint16_t dtc_id;\n    uint8_t status_byte;\n    uint8_t metadata_len;\n    uint8_t metadata[MAX_INTERNAL_DTC_METADATA_SIZE];\n} DTCRecord;\n\nstatic uint8_t g_dtc_log_buffer[DTC_LOG_BUFFER_TOTAL_SIZE];\nstatic uint16_t g_current_log_pos = 0;\n\nvoid initDTCLoggingSystem() {\n    memset(g_dtc_log_buffer, 0, DTC_LOG_BUFFER_TOTAL_SIZE);\n    g_current_log_pos = 0;\n}\n\nint addDTCRecord(uint16_t dtc_code, uint8_t status_byte, const uint8_t* metadata, uint8_t metadata_len) {\n    if (metadata == NULL && metadata_len > 0) {\n        return -1;\n    }\n\n    if (metadata_len > MAX_DTC_METADATA_PROTO_MAX) {\n        return -2;\n    }\n\n    DTCRecord temp_record;\n    temp_record.dtc_id = dtc_code;\n    temp_record.status_byte = status_byte;\n    temp_record.metadata_len = metadata_len;\n\n    memcpy(temp_record.metadata, metadata, metadata_len);\n\n    uint16_t record_effective_size = DTC_RECORD_FIXED_SIZE + metadata_len;\n\n    if (g_current_log_pos + record_effective_size > DTC_LOG_BUFFER_TOTAL_SIZE) {\n        return -3;\n    }\n\n    memcpy(g_dtc_log_buffer + g_current_log_pos, &temp_record, record_effective_size);\n    g_current_log_pos += record_effective_size;\n\n    return 0;\n}\n\nuint16_t getDTCLogCount() {\n    if (SINGLE_DTC_RECORD_STORAGE_SIZE == 0) return 0;\n    return g_current_log_pos / SINGLE_DTC_RECORD_STORAGE_SIZE;\n}\n\nvoid simulateExternalDTCReport(uint16_t dtc, uint8_t status, const uint8_t* data, uint8_t data_len) {\n    addDTCRecord(dtc, status, data, data_len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRIES 200\n#define LOG_ENTRY_SIZE 10\n#define TELEMETRY_BUFFER_TOTAL_SIZE (MAX_LOG_ENTRIES * LOG_ENTRY_SIZE)\n\nstatic uint8_t g_telemetryLogBuffer[TELEMETRY_BUFFER_TOTAL_SIZE];\nstatic uint16_t g_logWriteHead = 0;\nstatic uint16_t g_currentValidBytes = 0;\n\nvoid initTelemetryLogger() {\n    memset(g_telemetryLogBuffer, 0, TELEMETRY_BUFFER_TOTAL_SIZE);\n    g_logWriteHead = 0;\n    g_currentValidBytes = 0;\n}\n\nint addTelemetryEntry(const uint8_t* entry_data) {\n    if (entry_data == NULL) {\n        return -1;\n    }\n\n    for (uint8_t i = 0; i < LOG_ENTRY_SIZE; ++i) {\n        g_telemetryLogBuffer[g_logWriteHead] = entry_data[i];\n        g_logWriteHead = (g_logWriteHead + 1) % TELEMETRY_BUFFER_TOTAL_SIZE;\n    }\n\n    if (g_currentValidBytes < TELEMETRY_BUFFER_TOTAL_SIZE) {\n        g_currentValidBytes += LOG_ENTRY_SIZE;\n    }\n    return 0;\n}\n\nint getLatestTelemetryEntries(uint16_t num_requested_entries, uint8_t* response_buffer, uint16_t response_buffer_size) {\n    if (response_buffer == NULL) {\n        return -1;\n    }\n\n    if (num_requested_entries == 0) {\n        return 0;\n    }\n\n    uint16_t total_bytes_expected = num_requested_entries * LOG_ENTRY_SIZE;\n\n    if (total_bytes_expected > response_buffer_size) {\n        return -2;\n    }\n    \n    uint16_t start_byte_offset;\n    if (g_currentValidBytes < TELEMETRY_BUFFER_TOTAL_SIZE || (uint32_t)num_requested_entries * LOG_ENTRY_SIZE <= g_currentValidBytes) {\n        uint32_t effective_offset_calc = (uint32_t)g_currentValidBytes - ((uint32_t)num_requested_entries * LOG_ENTRY_SIZE);\n        if (effective_offset_calc > TELEMETRY_BUFFER_TOTAL_SIZE) {\n             start_byte_offset = 0;\n        } else {\n             start_byte_offset = (g_logWriteHead + TELEMETRY_BUFFER_TOTAL_SIZE - g_currentValidBytes + (uint16_t)effective_offset_calc) % TELEMETRY_BUFFER_TOTAL_SIZE;\n        }\n    } else {\n        start_byte_offset = (g_logWriteHead + TELEMETRY_BUFFER_TOTAL_SIZE - ((uint32_t)num_requested_entries * LOG_ENTRY_SIZE)) % TELEMETRY_BUFFER_TOTAL_SIZE;\n    }\n    start_byte_offset %= TELEMETRY_BUFFER_TOTAL_SIZE;\n\n    for (uint16_t i = 0; i < num_requested_entries; ++i) {\n        for (uint8_t j = 0; j < LOG_ENTRY_SIZE; ++j) {\n            uint16_t source_idx = (start_byte_offset + (i * LOG_ENTRY_SIZE) + j) % TELEMETRY_BUFFER_TOTAL_SIZE;\n            response_buffer[(i * LOG_ENTRY_SIZE) + j] = g_telemetryLogBuffer[source_idx];\n        }\n    }\n\n    return num_requested_entries;\n}\n\nvoid handleDiagnosticRequest(uint16_t command_id, uint16_t param1, uint8_t* diag_resp_buf, uint16_t diag_resp_buf_len) {\n    if (command_id == 0x1234) {\n        getLatestTelemetryEntries(param1, diag_resp_buf, diag_resp_buf_len);\n    }\n}\n", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_BATTERY_PROFILES 4\n#define PMU_HARDWARE_REG_COUNT 8\n\nvoid logPMUError_fixed(const char* msg) {\n}\n\nuint32_t g_pmuHardwareRegisters_fixed[PMU_HARDWARE_REG_COUNT];\n\nvoid writePMURegister_fixed(uint8_t reg_idx, uint32_t value) {\n    if (reg_idx < PMU_HARDWARE_REG_COUNT) {\n        g_pmuHardwareRegisters_fixed[reg_idx] = value;\n    } else {\n        logPMUError_fixed(\"Attempted to write to out-of-bounds PMU register.\");\n    }\n}\n\ntypedef struct {\n    float charging_voltage_mV;\n    float discharge_cut_off_voltage_mV;\n    uint16_t max_charge_current_mA;\n    uint16_t max_discharge_current_mA;\n    uint8_t  temperature_threshold_C;\n} BatteryProfile_fixed;\n\ntypedef enum {\n    BATTERY_TYPE_LEAD_ACID = 0,\n    BATTERY_TYPE_LI_ION = 1,\n    BATTERY_TYPE_NICKEL_METAL_HYDRIDE = 2,\n    BATTERY_TYPE_CUSTOM_PERFORMANCE = 3,\n    BATTERY_TYPE_DIAGNOSTIC_MODE = 4 \n} BatteryProfileIdentifier_fixed;\n\nstatic BatteryProfile_fixed g_batteryProfiles_fixed[MAX_BATTERY_PROFILES];\n\nvoid initializeBatteryProfiles_fixed() {\n    g_batteryProfiles_fixed[BATTERY_TYPE_LEAD_ACID] = (BatteryProfile_fixed){14200.0f, 10500.0f, 5000, 10000, 45};\n    g_batteryProfiles_fixed[BATTERY_TYPE_LI_ION] = (BatteryProfile_fixed){16800.0f, 12000.0f, 8000, 15000, 55};\n    g_batteryProfiles_fixed[BATTERY_TYPE_NICKEL_METAL_HYDRIDE] = (BatteryProfile_fixed){15000.0f, 9500.0f, 6000, 12000, 50};\n    g_batteryProfiles_fixed[BATTERY_TYPE_CUSTOM_PERFORMANCE] = (BatteryProfile_fixed){17000.0f, 11500.0f, 10000, 20000, 60};\n}\n\nBatteryProfileIdentifier_fixed getExternalBatteryConfig_fixed() {\n    return BATTERY_TYPE_DIAGNOSTIC_MODE;\n}\n\nvoid applyVoltageRegulationProfile_fixed() {\n    BatteryProfileIdentifier_fixed current_profile_id = getExternalBatteryConfig_fixed();\n    BatteryProfile_fixed profile_to_apply;\n\n    if (current_profile_id < MAX_BATTERY_PROFILES) {\n        profile_to_apply = g_batteryProfiles_fixed[current_profile_id];\n    } else {\n        logPMUError_fixed(\"Attempted to apply invalid battery profile ID. Using default profile.\");\n        profile_to_apply = g_batteryProfiles_fixed[BATTERY_TYPE_LEAD_ACID]; \n    }\n\n    writePMURegister_fixed(0, (uint32_t)profile_to_apply.charging_voltage_mV);\n    writePMURegister_fixed(1, (uint32_t)profile_to_apply.discharge_cut_off_voltage_mV);\n    writePMURegister_fixed(2, profile_to_apply.max_charge_current_mA);\n    writePMURegister_fixed(3, profile_to_apply.max_discharge_current_mA);\n    writePMURegister_fixed(4, profile_to_apply.temperature_threshold_C);\n}\n\nvoid powerManagementUnitMain_fixed() {\n    initializeBatteryProfiles_fixed();\n    applyVoltageRegulationProfile_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n\ntypedef struct {\n    uint16_t packet_id;\n    uint16_t num_sensor_readings; \n} TelemetryPacketHeader;\n\nclass TelemetryProcessor {\npublic:\n    TelemetryProcessor() : sensor_data_buffer(nullptr), buffer_size(0) {}\n\n    ~TelemetryProcessor() {\n        if (sensor_data_buffer) {\n            free(sensor_data_buffer);\n            sensor_data_buffer = nullptr;\n        }\n    }\n\n    bool processTelemetryPacketFixed(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(TelemetryPacketHeader)) {\n            return false;\n        }\n\n        const TelemetryPacketHeader* header = reinterpret_cast<const TelemetryPacketHeader*>(packet_data);\n        uint16_t num_readings = header->num_sensor_readings;\n\n        static const uint16_t MAX_SENSOR_READINGS = 1024;\n        if (num_readings > MAX_SENSOR_READINGS) {\n            return false;\n        }\n\n        size_t expected_payload_size = (size_t)num_readings * sizeof(uint16_t);\n        size_t expected_total_packet_size = sizeof(TelemetryPacketHeader) + expected_payload_size;\n\n        if (num_readings > 0 && expected_payload_size / sizeof(uint16_t) != num_readings) {\n             return false;\n        }\n\n        if (packet_length < expected_total_packet_size) {\n            return false;\n        }\n\n        if (sensor_data_buffer) {\n            free(sensor_data_buffer);\n            sensor_data_buffer = nullptr;\n            buffer_size = 0;\n        }\n\n        sensor_data_buffer = (uint16_t*)malloc(expected_payload_size);\n        if (!sensor_data_buffer) {\n            return false;\n        }\n        buffer_size = expected_payload_size;\n\n        const uint8_t* data_ptr = packet_data + sizeof(TelemetryPacketHeader);\n\n        for (uint16_t i = 0; i < num_readings; ++i) {\n            sensor_data_buffer[i] = (uint16_t)(data_ptr[i * 2] | (data_ptr[i * 2 + 1] << 8));\n        }\n\n        return true;\n    }\n\n    const uint16_t* getSensorData() const { return sensor_data_buffer; }\n    size_t getBufferSize() const { return buffer_size; }\n\nprivate:\n    uint16_t* sensor_data_buffer;\n    size_t buffer_size;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 256\n#define MAX_COMMAND_DATA_SIZE 128\n#define MAX_COMMANDS_PER_PACKET 8\n\nstatic uint8_t g_vehicleConfiguration[VEHICLE_CONFIG_BUFFER_SIZE];\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t target_offset;\n    uint8_t data_length;\n} ConfigCommandHeader;\n\nvoid initVehicleConfiguration() {\n    memset(g_vehicleConfiguration, 0, VEHICLE_CONFIG_BUFFER_SIZE);\n}\n\nint processConfigCommands(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len < sizeof(uint8_t)) {\n        return -1;\n    }\n\n    uint8_t num_commands = packet_data[0];\n    uint16_t current_read_offset = sizeof(uint8_t);\n\n    if (num_commands > MAX_COMMANDS_PER_PACKET) {\n        return -2;\n    }\n\n    for (uint8_t i = 0; i < num_commands; ++i) {\n        if (current_read_offset + sizeof(ConfigCommandHeader) > packet_len) {\n            return -3;\n        }\n\n        uint8_t command_id = packet_data[current_read_offset];\n        uint8_t target_offset = packet_data[current_read_offset + 1];\n        uint8_t data_length = packet_data[current_read_offset + 2];\n        current_read_offset += sizeof(ConfigCommandHeader);\n\n        if (data_length > MAX_COMMAND_DATA_SIZE) {\n            return -4;\n        }\n\n        if (current_read_offset + data_length > packet_len) {\n            return -5;\n        }\n\n        for (uint8_t j = 0; j < data_length; ++j) {\n            g_vehicleConfiguration[target_offset + j] = packet_data[current_read_offset + j];\n        }\n        current_read_offset += data_length;\n    }\n    return 0;\n}\n\nvoid receiveConfigCommandPacket(const uint8_t* msg_data, uint16_t msg_len) {\n    processConfigCommands(msg_data, msg_len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_SUBSYSTEM_PARAMS 10\n#define MAX_PARAM_DATA_SIZE 64 \n\ntypedef struct {\n    uint8_t* param_data_ptr;\n    uint16_t param_data_size;\n    bool is_initialized;\n} SubsystemParameter;\n\nstatic uint8_t engineParamBuffer1[20];\nstatic uint8_t engineParamBuffer2[10];\nstatic uint8_t engineParamBuffer3[30];\n\nstatic SubsystemParameter g_engineParameters[MAX_SUBSYSTEM_PARAMS];\n\nvoid initializeEngineParameters() {\n    memset(g_engineParameters, 0, sizeof(g_engineParameters));\n    \n    g_engineParameters[0] = (SubsystemParameter){.param_data_ptr = engineParamBuffer1, .param_data_size = sizeof(engineParamBuffer1), .is_initialized = true};\n    g_engineParameters[1] = (SubsystemParameter){.param_data_ptr = engineParamBuffer2, .param_data_size = sizeof(engineParamBuffer2), .is_initialized = true};\n    g_engineParameters[2] = (SubsystemParameter){.param_data_ptr = engineParamBuffer3, .param_data_size = sizeof(engineParamBuffer3), .is_initialized = true};\n}\n\n#define DIAG_SERVICE_READ_PARAM 0x22\n#define DIAG_RESPONSE_HEADER_SIZE 3 \n#define DIAG_MAX_RESPONSE_DATA_SIZE 128 \n\nint handleReadParameterRequest(const uint8_t* request_msg, uint16_t request_len, uint8_t* response_buffer, uint16_t* response_len) {\n    if (request_msg == NULL || response_buffer == NULL || response_len == NULL || request_len < 6) {\n        return -1; \n    }\n\n    if (request_msg[0] != DIAG_SERVICE_READ_PARAM) {\n        return -2; \n    }\n\n    uint8_t param_idx = request_msg[1];\n    uint16_t fragment_offset = (request_msg[2] << 8) | request_msg[3];\n    uint16_t fragment_length = (request_msg[4] << 8) | request_msg[5];\n\n    if (param_idx >= MAX_SUBSYSTEM_PARAMS) {\n        return -3; \n    }\n\n    SubsystemParameter* param = &g_engineParameters[param_idx];\n\n    if (!param->is_initialized || param->param_data_ptr == NULL) {\n        return -4; \n    }\n    \n    uint16_t actual_read_length = fragment_length;\n    if (actual_read_length > (DIAG_MAX_RESPONSE_DATA_SIZE - DIAG_RESPONSE_HEADER_SIZE)) {\n        actual_read_length = DIAG_MAX_RESPONSE_DATA_SIZE - DIAG_RESPONSE_HEADER_SIZE;\n    }\n\n    response_buffer[0] = DIAG_SERVICE_READ_PARAM | 0x40; \n    response_buffer[1] = 0x00; \n    response_buffer[2] = (uint8_t)actual_read_length; \n\n    for (uint16_t i = 0; i < actual_read_length; ++i) {\n        response_buffer[DIAG_RESPONSE_HEADER_SIZE + i] = param->param_data_ptr[fragment_offset + i];\n    }\n    *response_len = DIAG_RESPONSE_HEADER_SIZE + actual_read_length;\n\n    return 0;\n}\n\nvoid processDiagnosticRequest(const uint8_t* msg, uint16_t len, uint8_t* resp_buf, uint16_t* resp_len) {\n    if (!g_engineParameters[0].is_initialized) {\n        initializeEngineParameters();\n    }\n    handleReadParameterRequest(msg, len, resp_buf, resp_len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_FEATURES 5\n#define MAX_PARAMS_PER_FEATURE_SLOT 10 \n\ntypedef struct {\n    uint32_t value;\n    bool     active;\n    uint8_t  access_level;\n} FeatureParameter;\n\nstatic FeatureParameter g_featureConfigurations_fixed[MAX_VEHICLE_FEATURES][MAX_PARAMS_PER_FEATURE_SLOT];\n\nstatic const uint8_t g_actualFeatureParameterCounts_fixed[MAX_VEHICLE_FEATURES] = {\n    7, \n    3, \n    9, \n    2, \n    5  \n};\n\ntypedef struct {\n    uint8_t feature_id;\n    uint8_t param_index;\n    uint32_t new_value;\n} FeatureUpdateCommand_fixed;\n\nvoid logVehicleConfigError_fixed(const char* msg) {\n}\n\nFeatureUpdateCommand_fixed receiveFeatureUpdateCommand_fixed() {\n    FeatureUpdateCommand_fixed cmd;\n    cmd.feature_id = 0; \n    cmd.param_index = 8; \n    cmd.new_value = 0xABCDEF00;\n    return cmd;\n}\n\nvoid initializeFeatureConfigs_fixed() {\n    for (uint8_t i = 0; i < MAX_VEHICLE_FEATURES; ++i) {\n        for (uint8_t j = 0; j < MAX_PARAMS_PER_FEATURE_SLOT; ++j) {\n            g_featureConfigurations_fixed[i][j] = (FeatureParameter){0, false, 0};\n        }\n    }\n    for (uint8_t i = 0; i < MAX_VEHICLE_FEATURES; ++i) {\n        for (uint8_t j = 0; j < g_actualFeatureParameterCounts_fixed[i]; ++j) {\n            g_featureConfigurations_fixed[i][j].active = true;\n            g_featureConfigurations_fixed[i][j].access_level = 1;\n        }\n    }\n}\n\nvoid processFeatureUpdate_fixed() {\n    FeatureUpdateCommand_fixed cmd = receiveFeatureUpdateCommand_fixed();\n\n    if (cmd.feature_id < MAX_VEHICLE_FEATURES) {\n        if (cmd.param_index < g_actualFeatureParameterCounts_fixed[cmd.feature_id]) { \n            g_featureConfigurations_fixed[cmd.feature_id][cmd.param_index].value = cmd.new_value;\n            logVehicleConfigError_fixed(\"Feature configuration updated successfully.\");\n        } else {\n            logVehicleConfigError_fixed(\"Parameter index out of bounds for specified feature.\");\n        }\n    } else {\n        logVehicleConfigError_fixed(\"Invalid feature ID received.\");\n    }\n}\n\nvoid vehicleConfigSystemMain_fixed() {\n    initializeFeatureConfigs_fixed();\n    processFeatureUpdate_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define TOTAL_MEMORY_POOL_SIZE 512\n#define PROFILE_DATA_SIZE 128\n#define PROFILE_METADATA_SIZE sizeof(uint8_t) \n#define PROFILE_ALLOC_SIZE (PROFILE_METADATA_SIZE + PROFILE_DATA_SIZE)\n\nstatic uint8_t g_memory_pool_fixed[TOTAL_MEMORY_POOL_SIZE];\nstatic uint8_t* g_active_profile_data_ptr_fixed = NULL;\n\nstatic const uint8_t default_profile_data_fixed[PROFILE_DATA_SIZE] = {\n    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,\n    0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,\n    0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,\n    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40,\n    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,\n    0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60,\n    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,\n    0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80\n};\n\nvoid init_profile_manager_fixed() {\n    memset(g_memory_pool_fixed, 0x00, TOTAL_MEMORY_POOL_SIZE);\n    g_active_profile_data_ptr_fixed = NULL;\n\n    int num_profiles = TOTAL_MEMORY_POOL_SIZE / PROFILE_ALLOC_SIZE;\n    for (int i = 0; i < num_profiles; ++i) {\n        uint8_t* current_profile_base = g_memory_pool_fixed + (i * PROFILE_ALLOC_SIZE);\n        *current_profile_base = 0x00;\n        memcpy(current_profile_base + PROFILE_METADATA_SIZE, default_profile_data_fixed, PROFILE_DATA_SIZE);\n    }\n\n    g_active_profile_data_ptr_fixed = g_memory_pool_fixed + PROFILE_METADATA_SIZE;\n    *(g_active_profile_data_ptr_fixed - PROFILE_METADATA_SIZE) = 0x01;\n}\n\nvoid utilize_active_profile_fixed() {\n    if (g_active_profile_data_ptr_fixed != NULL) {\n        volatile uint32_t sum = 0;\n        for (uint16_t i = 0; i < PROFILE_DATA_SIZE; ++i) {\n            sum += g_active_profile_data_ptr_fixed[i];\n        }\n        (void)sum;\n    }\n}\n\nvoid revert_active_profile_fixed(int16_t steps_backward) {\n    if (g_active_profile_data_ptr_fixed == NULL || steps_backward <= 0) {\n        return;\n    }\n\n    uint8_t* current_profile_base_ptr = g_active_profile_data_ptr_fixed - PROFILE_METADATA_SIZE;\n\n    uint8_t* proposed_new_profile_base_ptr = current_profile_base_ptr - (steps_backward * PROFILE_ALLOC_SIZE);\n\n    if (proposed_new_profile_base_ptr < g_memory_pool_fixed) {\n        return;\n    }\n\n    if ((proposed_new_profile_base_ptr - g_memory_pool_fixed) % PROFILE_ALLOC_SIZE != 0) {\n        return;\n    }\n\n    *(g_active_profile_data_ptr_fixed - PROFILE_METADATA_SIZE) = 0x00;\n\n    g_active_profile_data_ptr_fixed = proposed_new_profile_base_ptr + PROFILE_METADATA_SIZE;\n\n    *(g_active_profile_data_ptr_fixed - PROFILE_METADATA_SIZE) = 0x01;\n\n    utilize_active_profile_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_DATA_BUFFER_SIZE 256\n#define COMPRESSED_PACKET_MAX_SIZE 128\n\ntypedef struct {\n    uint8_t  chunk_type;\n    uint8_t  compressed_len;\n} CompressedChunkHeader;\n\nstatic uint8_t g_decompressedConfigData[MAX_CONFIG_DATA_BUFFER_SIZE];\nstatic uint16_t g_decompressedDataOffset = 0;\n\nvoid initDecompressor() {\n    memset(g_decompressedConfigData, 0, MAX_CONFIG_DATA_BUFFER_SIZE);\n    g_decompressedDataOffset = 0;\n}\n\nint decompress_rle_chunk(const uint8_t* input_ptr, uint8_t compressed_len,\n                         uint8_t* output_ptr, uint16_t output_buffer_max_len,\n                         uint16_t current_output_offset) {\n    if (input_ptr == NULL || output_ptr == NULL || compressed_len % 2 != 0) {\n        return -1;\n    }\n\n    uint16_t bytes_written_in_chunk = 0;\n    uint8_t input_bytes_processed = 0;\n\n    while (input_bytes_processed < compressed_len) {\n        if (input_bytes_processed + 2 > compressed_len) {\n            return -2;\n        }\n\n        uint8_t byte_value = input_ptr[input_bytes_processed];\n        uint8_t repeat_count = input_ptr[input_bytes_processed + 1];\n\n        if ((uint32_t)current_output_offset + bytes_written_in_chunk + repeat_count > output_buffer_max_len) {\n            return -3;\n        }\n\n        for (uint8_t i = 0; i < repeat_count; ++i) {\n            output_ptr[current_output_offset + bytes_written_in_chunk] = byte_value;\n            bytes_written_in_chunk++;\n        }\n        input_bytes_processed += 2;\n    }\n    return bytes_written_in_chunk;\n}\n\nint processCompressedConfigPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len == 0 || packet_len > COMPRESSED_PACKET_MAX_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_packet_offset = 0;\n    \n    while (current_packet_offset < packet_len) {\n        if (current_packet_offset + sizeof(CompressedChunkHeader) > packet_len) {\n            return -2;\n        }\n\n        const CompressedChunkHeader* header = (const CompressedChunkHeader*)(packet + current_packet_offset);\n        uint8_t chunk_type = header->chunk_type;\n        uint8_t compressed_chunk_len = header->compressed_len;\n\n        if (current_packet_offset + sizeof(CompressedChunkHeader) + compressed_chunk_len > packet_len) {\n            return -3;\n        }\n\n        const uint8_t* chunk_data_ptr = packet + current_packet_offset + sizeof(CompressedChunkHeader);\n\n        int decompress_result;\n        if (chunk_type == 0x01) {\n            decompress_result = decompress_rle_chunk(chunk_data_ptr, compressed_chunk_len,\n                                                    g_decompressedConfigData,\n                                                    MAX_CONFIG_DATA_BUFFER_SIZE,\n                                                    g_decompressedDataOffset);\n            if (decompress_result < 0) {\n                return -4;\n            }\n            g_decompressedDataOffset += decompress_result;\n        } else {\n\n        }\n\n        current_packet_offset += sizeof(CompressedChunkHeader) + compressed_chunk_len;\n    }\n\n    return 0;\n}\n\nvoid receiveCompressedUpdate(const uint8_t* data, uint16_t len) {\n    initDecompressor();\n    processCompressedConfigPacket(data, len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_ECU_MODULES_FIXED 8\n#define MAX_ERRORS_PER_MODULE_FIXED 20\n\ntypedef struct {\n    uint16_t code;\n    uint32_t timestamp;\n} ErrorEntry_Fixed;\n\ntypedef struct {\n    ErrorEntry_Fixed errors[MAX_ERRORS_PER_MODULE_FIXED];\n    uint8_t current_error_count;\n    uint8_t next_write_index;\n} ModuleErrorLog_Fixed;\n\nstatic ModuleErrorLog_Fixed g_ecu_error_logs_fixed[MAX_ECU_MODULES_FIXED];\n\nvoid system_log_fixed(const char* message) {\n}\n\nuint32_t receive_diagnostic_event_fixed() {\n    return (0x0 << 28) | 0x19;\n}\n\nvoid initialize_error_logs_fixed() {\n    for (uint8_t i = 0; i < MAX_ECU_MODULES_FIXED; ++i) {\n        g_ecu_error_logs_fixed[i].current_error_count = 0;\n        g_ecu_error_logs_fixed[i].next_write_index = 0;\n        for (uint8_t j = 0; j < MAX_ERRORS_PER_MODULE_FIXED; ++j) {\n            g_ecu_error_logs_fixed[i].errors[j].code = 0;\n            g_ecu_error_logs_fixed[i].errors[j].timestamp = 0;\n        }\n    }\n    system_log_fixed(\"Error logs initialized (fixed).\");\n}\n\nvoid process_diagnostic_event_fixed() {\n    uint32_t event_id_raw = receive_diagnostic_event_fixed();\n\n    uint8_t module_id = (uint8_t)((event_id_raw >> 28) & 0xF);\n    uint8_t error_idx = (uint8_t)(event_id_raw & 0xFF);\n\n    if (module_id < MAX_ECU_MODULES_FIXED) {\n        if (error_idx < MAX_ERRORS_PER_MODULE_FIXED) {\n            g_ecu_error_logs_fixed[module_id].errors[error_idx].code = (uint16_t)(event_id_raw >> 8);\n            g_ecu_error_logs_fixed[module_id].errors[error_idx].timestamp = 0xABCD;\n            system_log_fixed(\"Diagnostic event processed (fixed).\");\n        } else {\n            system_log_fixed(\"Error index out of bounds for module log (fixed).\");\n        }\n    } else {\n        system_log_fixed(\"Invalid module ID received (fixed).\");\n    }\n}\n\nvoid diagnostic_monitor_main_fixed() {\n    initialize_error_logs_fixed();\n    process_diagnostic_event_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define SCRATCHPAD_BUFFER_SIZE 128\n#define RAW_DATA_BUFFER_SIZE 512\n\nstatic uint8_t g_raw_data_stream[RAW_DATA_BUFFER_SIZE];\nstatic uint32_t g_raw_data_len = 0;\n\nstatic int32_t g_current_record_offset = 0;\n\nvoid fill_raw_data(const uint8_t* data, uint32_t len)\n{\n    if (len > RAW_DATA_BUFFER_SIZE) {\n        len = RAW_DATA_BUFFER_SIZE;\n    }\n    memcpy(g_raw_data_stream, data, len);\n    g_raw_data_len = len;\n    g_current_record_offset = 0;\n}\n\nvoid process_extracted_record(const uint8_t* record_data, uint32_t record_len)\n{\n}\n\nbool extract_record_to_scratchpad(uint8_t* scratchpad_buffer, uint32_t scratchpad_max_len, uint32_t record_len)\n{\n    if (g_current_record_offset < 0 || g_current_record_offset + record_len > g_raw_data_len || record_len > scratchpad_max_len) {\n        return false;\n    }\n    memcpy(scratchpad_buffer, g_raw_data_stream + g_current_record_offset, record_len);\n    process_extracted_record(scratchpad_buffer, record_len);\n    return true;\n}\n\nvoid recalibrate_record_offset_vulnerable(int32_t offset_delta)\n{\n    int32_t proposed_offset = g_current_record_offset + offset_delta;\n\n    if (proposed_offset > (int32_t)g_raw_data_len) {\n        proposed_offset = (int32_t)g_raw_data_len;\n    }\n    g_raw_data_stream[proposed_offset] = 0x00;\n\n    g_current_record_offset = proposed_offset;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_DTC_HISTORY 64\n#define DTC_CODE_LEN 6\n\ntypedef struct {\n    char code[DTC_CODE_LEN];\n    uint32_t timestamp_ms;\n    bool active;\n    uint8_t severity;\n} DTC_Entry;\n\nstatic DTC_Entry dtc_history_buffer[MAX_DTC_HISTORY];\nstatic int dtc_history_count = 0;\n\nvoid add_dtc_to_history(const char* dtc_code, uint32_t timestamp, uint8_t severity) {\n    if (dtc_history_count < MAX_DTC_HISTORY) {\n        strncpy(dtc_history_buffer[dtc_history_count].code, dtc_code, DTC_CODE_LEN);\n        dtc_history_buffer[dtc_history_count].code[DTC_CODE_LEN - 1] = '\\0';\n        dtc_history_buffer[dtc_history_count].timestamp_ms = timestamp;\n        dtc_history_buffer[dtc_history_count].active = false;\n        dtc_history_buffer[dtc_history_count].severity = severity;\n        dtc_history_count++;\n    }\n}\n\nvoid revert_last_dtc_clears_Vulnerable(int num_to_revert) {\n    if (num_to_revert <= 0) {\n        return;\n    }\n\n    for (int i = 0; i < num_to_revert; ++i) {\n        int target_idx = dtc_history_count - 1 - i;\n        dtc_history_buffer[target_idx].active = true;\n        dtc_history_buffer[target_idx].severity = 0xFF;\n    }\n\n    if (dtc_history_count < num_to_revert) {\n        dtc_history_count = 0;\n    } else {\n        dtc_history_count -= num_to_revert;\n    }\n}\n\nDTC_Entry* get_dtc_history_entry(int index) {\n    if (index >= 0 && index < dtc_history_count) {\n        return &dtc_history_buffer[index];\n    }\n    return NULL;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRY_PAYLOAD_SIZE 62\n#define LOG_ACCUMULATOR_BUFFER_SIZE 256\n\ntypedef enum {\n    LOG_TYPE_GENERIC_INFO = 0x01,\n    LOG_TYPE_CRITICAL_FAULT = 0x02,\n    LOG_TYPE_SENSOR_DATA = 0x03,\n    LOG_TYPE_TELEMETRY_EVENT = 0x04\n} LogEntryType;\n\ntypedef struct {\n    uint8_t type;\n    uint8_t data_length;\n    uint8_t data[MAX_LOG_ENTRY_PAYLOAD_SIZE];\n} InternalLogEntry;\n\nstatic uint8_t g_logAccumulatorBuffer[LOG_ACCUMULATOR_BUFFER_SIZE];\nstatic uint16_t g_logAccumulatorCurrentPos = 0;\n\ntypedef struct {\n    const uint8_t* stream_ptr;\n    uint16_t stream_total_len;\n    uint16_t current_stream_offset;\n} DataStreamReaderContext;\n\nint processIncomingLogEntry(DataStreamReaderContext* reader_ctx) {\n    if (reader_ctx == NULL || reader_ctx->stream_ptr == NULL) {\n        return -1;\n    }\n\n    if (reader_ctx->current_stream_offset + 2 > reader_ctx->stream_total_len) {\n        return -1;\n    }\n\n    uint8_t log_type = reader_ctx->stream_ptr[reader_ctx->current_stream_offset];\n    uint8_t payload_len_from_stream = reader_ctx->stream_ptr[reader_ctx->current_stream_offset + 1];\n\n    if (reader_ctx->current_stream_offset + 2 + payload_len_from_stream > reader_ctx->stream_total_len) {\n        return -1;\n    }\n\n    InternalLogEntry temp_log_entry;\n    temp_log_entry.type = log_type;\n\n    uint8_t bytes_to_copy = payload_len_from_stream;\n    if (bytes_to_copy > MAX_LOG_ENTRY_PAYLOAD_SIZE) {\n        bytes_to_copy = MAX_LOG_ENTRY_PAYLOAD_SIZE;\n    }\n    \n    temp_log_entry.data_length = bytes_to_copy;\n\n    memcpy(temp_log_entry.data, reader_ctx->stream_ptr + reader_ctx->current_stream_offset + 2, bytes_to_copy);\n\n    uint16_t total_entry_size_consumed_from_stream = 2 + payload_len_from_stream;\n\n    uint16_t total_entry_size_to_store_in_accumulator = 2 + bytes_to_copy;\n\n    if (g_logAccumulatorCurrentPos + total_entry_size_to_store_in_accumulator > LOG_ACCUMULATOR_BUFFER_SIZE) {\n        return -1;\n    }\n\n    memcpy(g_logAccumulatorBuffer + g_logAccumulatorCurrentPos, &temp_log_entry, total_entry_size_to_store_in_accumulator);\n    g_logAccumulatorCurrentPos += total_entry_size_to_store_in_accumulator;\n\n    return total_entry_size_consumed_from_stream;\n}\n\nint processDiagnosticDataBlock(const uint8_t* diagnostic_data, uint16_t data_block_len) {\n    if (diagnostic_data == NULL || data_block_len < 2) {\n        return -1;\n    }\n\n    DataStreamReaderContext reader_ctx = {\n        .stream_ptr = diagnostic_data,\n        .stream_total_len = data_block_len,\n        .current_stream_offset = 0\n    };\n\n    g_logAccumulatorCurrentPos = 0;\n\n    while (reader_ctx.current_stream_offset < reader_ctx.stream_total_len) {\n        int bytes_consumed = processIncomingLogEntry(&reader_ctx);\n        if (bytes_consumed <= 0) {\n            return -1;\n        }\n        reader_ctx.current_stream_offset += bytes_consumed;\n    }\n\n    return g_logAccumulatorCurrentPos;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DRIVER_MESSAGE_BUFFER_SIZE 32\n#define PROTOCOL_MAX_MESSAGE_LEN 64\n\nstatic char g_driverWelcomeMessage[DRIVER_MESSAGE_BUFFER_SIZE];\nstatic uint8_t g_messageLength = 0;\n\nvoid initDriverProfile() {\n    memset(g_driverWelcomeMessage, 0, sizeof(g_driverWelcomeMessage));\n    const char* default_msg = \"Hello Driver!\";\n    uint8_t default_len = strlen(default_msg);\n    uint8_t actual_copy_len = default_len;\n    if (actual_copy_len >= DRIVER_MESSAGE_BUFFER_SIZE) {\n        actual_copy_len = DRIVER_MESSAGE_BUFFER_SIZE - 1;\n    }\n    strncpy(g_driverWelcomeMessage, default_msg, actual_copy_len);\n    g_driverWelcomeMessage[actual_copy_len] = '\\0';\n    g_messageLength = actual_copy_len;\n}\n\nint updateDriverWelcomeMessage(const char* new_message, uint8_t message_len) {\n    if (new_message == NULL) {\n        return -1;\n    }\n\n    if (message_len > PROTOCOL_MAX_MESSAGE_LEN) {\n        return -2;\n    }\n\n    uint8_t bytes_to_copy = message_len;\n    if (bytes_to_copy >= DRIVER_MESSAGE_BUFFER_SIZE) {\n        bytes_to_copy = DRIVER_MESSAGE_BUFFER_SIZE - 1;\n    }\n\n    memcpy(g_driverWelcomeMessage, new_message, bytes_to_copy);\n\n    g_driverWelcomeMessage[bytes_to_copy] = '\\0';\n    g_messageLength = bytes_to_copy;\n\n    return 0;\n}\n\nconst char* getDriverWelcomeMessage() {\n    return g_driverWelcomeMessage;\n}\n\nuint8_t getDriverWelcomeMessageLength() {\n    return g_messageLength;\n}\n\nvoid simulateCanMessage(const char* data, uint8_t len) {\n    updateDriverWelcomeMessage(data, len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_VEHICLE_EVENTS 100\n#define EVENT_NAME_MAX_LEN 16\n\ntypedef enum {\n    EVENT_TYPE_NONE = 0,\n    EVENT_TYPE_SENSOR_ERROR,\n    EVENT_TYPE_DIAGNOSTIC_REQUEST,\n    EVENT_TYPE_CRITICAL_ALERT,\n    EVENT_TYPE_PERFORMANCE_LOG\n} VehicleEventType;\n\ntypedef struct {\n    VehicleEventType type;\n    uint32_t timestamp;\n    char name[EVENT_NAME_MAX_LEN];\n    uint8_t severity;\n    bool active;\n} VehicleEvent;\n\nstatic VehicleEvent vehicle_event_log[MAX_VEHICLE_EVENTS];\nstatic int next_event_idx = 0;\n\nvoid initEventLog() {\n    for (int i = 0; i < MAX_VEHICLE_EVENTS; ++i) {\n        memset(&vehicle_event_log[i], 0, sizeof(VehicleEvent));\n        vehicle_event_log[i].type = EVENT_TYPE_NONE;\n        vehicle_event_log[i].active = false;\n    }\n    next_event_idx = 0;\n}\n\nvoid addVehicleEvent(VehicleEventType type, uint32_t timestamp, const char* name, uint8_t severity) {\n    if (next_event_idx < MAX_VEHICLE_EVENTS) {\n        vehicle_event_log[next_event_idx].type = type;\n        vehicle_event_log[next_event_idx].timestamp = timestamp;\n        strncpy(vehicle_event_log[next_event_idx].name, name, EVENT_NAME_MAX_LEN - 1);\n        vehicle_event_log[next_event_idx].name[EVENT_NAME_MAX_LEN - 1] = '\\0';\n        vehicle_event_log[next_event_idx].severity = severity;\n        vehicle_event_log[next_event_idx].active = true;\n        next_event_idx++;\n    }\n}\n\nvoid promoteVehicleEvent_Fixed(int current_event_index, int priority_offset) {\n    if (current_event_index < 0 || current_event_index >= next_event_idx || next_event_idx == 0) {\n        return;\n    }\n\n    if (priority_offset < 0) {\n        priority_offset = 0;\n    }\n    \n    int target_idx = current_event_index - priority_offset;\n\n    if (target_idx < 0) {\n        target_idx = 0;\n    }\n\n    if (target_idx != current_event_index) {\n        vehicle_event_log[target_idx] = vehicle_event_log[current_event_index];\n\n        vehicle_event_log[current_event_index].active = false;\n        vehicle_event_log[current_event_index].type = EVENT_TYPE_NONE;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_FEATURE_GROUPS 8\n#define MAX_FEATURES_PER_GROUP 16\n#define CAN_PAYLOAD_SIZE 8\n\ntypedef struct {\n    uint8_t feature_status_byte;\n    uint16_t feature_config_value;\n} FeatureConfig;\n\nstatic FeatureConfig g_featureConfigurations_fixed[MAX_FEATURE_GROUPS][MAX_FEATURES_PER_GROUP];\n\nvoid logVehicleEvent_fixed(const char* event_msg) {\n}\n\ntypedef struct {\n    uint16_t message_id;\n    uint8_t data[CAN_PAYLOAD_SIZE];\n    uint8_t data_len;\n} CanMessage;\n\nCanMessage receiveCanMessage_fixed() {\n    CanMessage msg;\n    msg.message_id = 0x100;\n    msg.data[0] = 0;\n    msg.data[1] = 20;\n    msg.data[2] = 0xDE;\n    msg.data[3] = 0xAD;\n    msg.data_len = 4;\n    return msg;\n}\n\nvoid initializeFeatureConfigs_fixed() {\n    for (uint8_t i = 0; i < MAX_FEATURE_GROUPS; ++i) {\n        for (uint8_t j = 0; j < MAX_FEATURES_PER_GROUP; ++j) {\n            g_featureConfigurations_fixed[i][j].feature_status_byte = 0;\n            g_featureConfigurations_fixed[i][j].feature_config_value = 0;\n        }\n    }\n    g_featureConfigurations_fixed[0][0].feature_config_value = 100;\n    g_featureConfigurations_fixed[0][1].feature_config_value = 200;\n}\n\nvoid processCanMessage_fixed() {\n    CanMessage msg = receiveCanMessage_fixed();\n\n    if (msg.message_id == 0x100) {\n        if (msg.data_len >= 4) {\n            uint8_t group_idx = msg.data[0];\n            uint8_t feature_idx = msg.data[1];\n            uint16_t config_value = (msg.data[2] << 8) | msg.data[3];\n\n            if (group_idx < MAX_FEATURE_GROUPS) {\n                if (feature_idx < MAX_FEATURES_PER_GROUP) {\n                    g_featureConfigurations_fixed[group_idx][feature_idx].feature_config_value = config_value;\n                    g_featureConfigurations_fixed[group_idx][feature_idx].feature_status_byte = 0x01;\n                    logVehicleEvent_fixed(\"Feature configuration updated successfully (fixed).\");\n                } else {\n                    logVehicleEvent_fixed(\"Invalid feature index in configuration message. Command ignored (fixed).\");\n                }\n            } else {\n                logVehicleEvent_fixed(\"Invalid feature group index in configuration message. Command ignored (fixed).\");\n            }\n        } else {\n            logVehicleEvent_fixed(\"Insufficient data for feature config update (fixed).\");\n        }\n    } else if (msg.message_id == 0x101) {\n        if (msg.data_len >= 2) {\n            uint8_t group_idx = msg.data[0];\n            uint8_t feature_idx = msg.data[1];\n\n            if (group_idx < MAX_FEATURE_GROUPS) {\n                if (feature_idx < MAX_FEATURES_PER_GROUP) {\n                    uint8_t current_status = g_featureConfigurations_fixed[group_idx][feature_idx].feature_status_byte;\n                    logVehicleEvent_fixed(\"Feature status queried successfully (fixed).\");\n                } else {\n                    logVehicleEvent_fixed(\"Invalid feature index in status request. Command ignored (fixed).\");\n                }\n            } else {\n                logVehicleEvent_fixed(\"Invalid feature group index in status request. Command ignored (fixed).\");\n            }\n        } else {\n            logVehicleEvent_fixed(\"Insufficient data for feature status request (fixed).\");\n        }\n    } else {\n        logVehicleEvent_fixed(\"Unknown CAN message ID received (fixed).\");\n    }\n}\n\nvoid main_ecu_loop_fixed() {\n    initializeFeatureConfigs_fixed();\n    processCanMessage_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_DATA_REGION_SIZE 512\n#define MAX_COMMAND_PAYLOAD_SIZE 64\n\nstatic uint8_t g_diagDataRegion[DIAG_DATA_REGION_SIZE];\n\ntypedef struct {\n    uint16_t target_address;\n    uint8_t  data_length;\n    uint8_t  data[MAX_COMMAND_PAYLOAD_SIZE];\n} DiagWriteCommand;\n\nvoid initDiagDataRegion() {\n    memset(g_diagDataRegion, 0x00, DIAG_DATA_REGION_SIZE);\n}\n\nint processDiagWriteCommand_Vulnerable(const uint8_t* raw_command_data, uint16_t raw_command_len) {\n    if (raw_command_data == NULL || raw_command_len < (sizeof(uint16_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    DiagWriteCommand cmd;\n    cmd.target_address = (raw_command_data[0] << 8) | raw_command_data[1];\n    cmd.data_length = raw_command_data[2];\n\n    if (raw_command_len != (sizeof(uint16_t) + sizeof(uint8_t) + cmd.data_length)) {\n        return -2;\n    }\n\n    if (cmd.data_length > MAX_COMMAND_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    if (cmd.target_address >= DIAG_DATA_REGION_SIZE) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < cmd.data_length; ++i) {\n        g_diagDataRegion[cmd.target_address + i] = raw_command_data[3 + i];\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticCommand(const uint8_t* data, uint16_t len) {\n    processDiagWriteCommand_Vulnerable(data, len);\n}\n\nuint8_t getDiagDataByte(uint16_t index) {\n    if (index < DIAG_DATA_REGION_SIZE) {\n        return g_diagDataRegion[index];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_DATA_BUF_SIZE_FIXED 32\n#define MAX_COMMAND_LEN_FIXED 16\n\nstatic uint8_t g_diag_data_buffer_fixed[DIAG_DATA_BUF_SIZE_FIXED];\nstatic uint8_t g_current_diag_data_len_fixed = 0;\n\nvoid diag_init_buffer_fixed() {\n    memset(g_diag_data_buffer_fixed, 0, DIAG_DATA_BUF_SIZE_FIXED);\n    g_current_diag_data_len_fixed = 0;\n}\n\nbool diag_load_data_fixed(const uint8_t* data, uint8_t len) {\n    if (len > DIAG_DATA_BUF_SIZE_FIXED) {\n        return false;\n    }\n    memcpy(g_diag_data_buffer_fixed, data, len);\n    g_current_diag_data_len_fixed = len;\n    return true;\n}\n\nvoid process_diagnostic_command_fixed(uint8_t command_id, int16_t arg1, uint8_t arg2_value) {\n    if (command_id == 0x05) { \n        int32_t target_index = (int32_t)g_current_diag_data_len_fixed - arg1;\n\n        if (target_index >= 0 && target_index < DIAG_DATA_BUF_SIZE_FIXED) {\n            g_diag_data_buffer_fixed[target_index] = arg2_value;\n        }\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define REASSEMBLY_BUFFER_SIZE 512\n#define MAX_RECORDS            4\n#define MAX_RECORD_LEN_BYTES   100 \n\n// Structure for a record's metadata within the reassembly manager\ntypedef struct {\n    uint16_t record_id;\n    uint16_t total_expected_len; \n    uint16_t current_len;        \n    uint16_t buffer_offset;      \n    bool     is_active;          \n} RecordMetadata;\n\n// Global buffer for reassembling record data\nstatic uint8_t g_reassemblyBuffer[REASSEMBLY_BUFFER_SIZE];\n// Metadata for active records being reassembled\nstatic RecordMetadata g_recordMetadata[MAX_RECORDS];\n// Pointer to the next free byte in g_reassemblyBuffer for new record allocation\nstatic uint16_t g_nextFreeBufferOffset = 0;\n\n// Initializes the reassembly manager system.\nvoid initReassemblyManager() {\n    memset(g_reassemblyBuffer, 0, REASSEMBLY_BUFFER_SIZE);\n    memset(g_recordMetadata, 0, sizeof(g_recordMetadata));\n    g_nextFreeBufferOffset = 0;\n}\n\n// Activates a new record reassembly slot or finds an existing one.\n// Returns the index into g_recordMetadata or a negative error code.\nint activateRecord(uint16_t id, uint16_t expected_total_len) {\n    if (expected_total_len == 0 || expected_total_len > MAX_RECORD_LEN_BYTES) {\n        return -1; \n    }\n\n    for (int i = 0; i < MAX_RECORDS; ++i) {\n        if (g_recordMetadata[i].is_active && g_recordMetadata[i].record_id == id) {\n            return i;\n        }\n    }\n\n    for (int i = 0; i < MAX_RECORDS; ++i) {\n        if (!g_recordMetadata[i].is_active) {\n            if (g_nextFreeBufferOffset + expected_total_len > REASSEMBLY_BUFFER_SIZE) {\n                return -2; \n            }\n\n            g_recordMetadata[i].record_id = id;\n            g_recordMetadata[i].total_expected_len = expected_total_len;\n            g_recordMetadata[i].current_len = 0;\n            g_recordMetadata[i].buffer_offset = g_nextFreeBufferOffset;\n            g_recordMetadata[i].is_active = true;\n\n            g_nextFreeBufferOffset += expected_total_len; \n\n            return i;\n        }\n    }\n    return -3; \n}\n\n// Processes a received data fragment for a specific record.\n// record_meta_idx: Index of the target record in g_recordMetadata.\n// fragment_offset: Offset of this fragment within the logical record's data.\n// fragment_data: Pointer to the raw fragment data.\n// fragment_len: Length of the raw fragment data.\nint processRecordFragment(int record_meta_idx, uint16_t fragment_offset, const uint8_t* fragment_data, uint16_t fragment_len) {\n    if (record_meta_idx < 0 || record_meta_idx >= MAX_RECORDS || !g_recordMetadata[record_meta_idx].is_active) {\n        return -1; \n    }\n    if (fragment_data == NULL || fragment_len == 0) {\n        return -2; \n    }\n\n    RecordMetadata* record = &g_recordMetadata[record_meta_idx];\n\n    // Calculate the absolute destination offset in the global reassembly buffer.\n    uint16_t dest_offset = record->buffer_offset + fragment_offset;\n\n    // VULNERABILITY:\n    // This check only ensures the *start* of the write is within the record's logical bounds.\n    // It does NOT ensure that the *entire* fragment data (dest_offset + fragment_len) fits within\n    // the record's allocated space (`record->total_expected_len`).\n    // If `fragment_offset + fragment_len` exceeds `record->total_expected_len`,\n    // an out-of-bounds write will occur into the subsequent record's buffer or beyond.\n    if (dest_offset < (record->buffer_offset + record->total_expected_len)) {\n        for (uint16_t i = 0; i < fragment_len; ++i) {\n            g_reassemblyBuffer[dest_offset + i] = fragment_data[i];\n        }\n\n        uint16_t new_current_len = fragment_offset + fragment_len;\n        if (new_current_len > record->current_len) {\n            record->current_len = new_current_len;\n        }\n        return 0;\n    }\n\n    return -3; \n}\n\n// Simulates receiving a vehicle data frame fragmented over a network.\nvoid receiveVehicleDataFrame(uint16_t record_id, uint16_t fragment_offset, const uint8_t* data, uint16_t len) {\n    // In a real system, expected_total_len would come from a header or prior message.\n    // For this simulation, assume a fixed expected length of 50 bytes for any record.\n    int record_idx = activateRecord(record_id, 50);\n    if (record_idx >= 0) {\n        processRecordFragment(record_idx, fragment_offset, data, len);\n    }\n}\n\n// This function would be used for testing/demonstration purposes\nuint8_t getReassembledByte(uint16_t absolute_offset) {\n    if (absolute_offset < REASSEMBLY_BUFFER_SIZE) {\n        return g_reassemblyBuffer[absolute_offset];\n    }\n    return 0;\n}\n\n// Example usage to demonstrate the vulnerability\nvoid runReassemblySimulation() {\n    initReassemblyManager();\n\n    // Activate two records. Each is allocated 50 bytes within g_reassemblyBuffer.\n    // Record 1 (ID 101): buffer_offset = 0, range [0, 49]\n    int record_idx1 = activateRecord(101, 50);\n    // Record 2 (ID 102): buffer_offset = 50, range [50, 99]\n    int record_idx2 = activateRecord(102, 50);\n\n    // Legitimate fragment for Record 2, populating its start\n    uint8_t legit_fragment_r2[] = {0xA1, 0xA2, 0xA3, 0xA4, 0xA5}; \n    processRecordFragment(record_idx2, 0, legit_fragment_r2, sizeof(legit_fragment_r2));\n    // g_reassemblyBuffer[50..54] should contain {0xA1, 0xA2, 0xA3, 0xA4, 0xA5}\n\n    // ATTACK SCENARIO: Send an oversized fragment for Record 1.\n    // Record 1 is allocated 50 bytes (indices 0-49). \n    // Fragment offset is 40, which is within bounds for Record 1 (0-49).\n    // Fragment length is 20. This means the write will cover indices [40, 40+20-1] = [40, 59].\n    // This will overwrite bytes [50-59], which belong to Record 2.\n    uint8_t malicious_fragment_r1[20];\n    memset(malicious_fragment_r1, 0xFF, sizeof(malicious_fragment_r1)); \n    processRecordFragment(record_idx1, 40, malicious_fragment_r1, sizeof(malicious_fragment_r1));\n\n    // After the attack, g_reassemblyBuffer[50] (first byte of record 2) should now be 0xFF,\n    // demonstrating the out-of-bounds write.\n}\n", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_EVENT_RECORDS 10\n#define MAX_EVENT_DATA_LEN 60 \n#define EVENT_LOG_BUFFER_SIZE (MAX_EVENT_RECORDS * (sizeof(EventRecordHeader) + MAX_EVENT_DATA_LEN))\n\ntypedef struct {\n    uint8_t event_type;\n    uint8_t data_len;\n} EventRecordHeader;\n\nstatic uint8_t g_eventLogBuffer[EVENT_LOG_BUFFER_SIZE];\nstatic uint16_t g_currentLogWriteOffset = 0;\n\nvoid initEventLog(void) {\n    memset(g_eventLogBuffer, 0, EVENT_LOG_BUFFER_SIZE);\n    g_currentLogWriteOffset = 0;\n}\n\nint addEventToLog(const uint8_t* raw_event_data, uint16_t event_total_len) {\n    if (raw_event_data == NULL || event_total_len < sizeof(EventRecordHeader)) {\n        return -1;\n    }\n\n    uint8_t received_event_type = raw_event_data[0];\n    uint8_t received_data_len = raw_event_data[1];\n\n    if (received_data_len > MAX_EVENT_DATA_LEN) {\n        return -2;\n    }\n\n    if (sizeof(EventRecordHeader) + received_data_len > event_total_len) {\n        return -3;\n    }\n\n    uint16_t record_packed_size = sizeof(EventRecordHeader) + received_data_len;\n\n    g_eventLogBuffer[g_currentLogWriteOffset] = received_event_type;\n    g_currentLogWriteOffset++;\n    g_eventLogBuffer[g_currentLogWriteOffset] = received_data_len;\n    g_currentLogWriteOffset++;\n\n    for (uint8_t i = 0; i < received_data_len; ++i) {\n        g_eventLogBuffer[g_currentLogWriteOffset + i] = raw_event_data[sizeof(EventRecordHeader) + i];\n    }\n    g_currentLogWriteOffset += received_data_len;\n\n    return 0;\n}\n\nvoid processIncomingEventStream(const uint8_t* data, uint16_t len) {\n    addEventToLog(data, len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n\ntypedef struct {\n    uint16_t param_id;\n    uint32_t payload_len;\n} ParameterHeader;\n\nclass VehicleDataAggregator {\npublic:\n    VehicleDataAggregator() : m_aggregated_data(nullptr), m_current_total_bytes(0), m_allocated_capacity_bytes(0) {}\n\n    ~VehicleDataAggregator() {\n        clear();\n    }\n\n    void clear() {\n        if (m_aggregated_data) {\n            delete[] m_aggregated_data;\n            m_aggregated_data = nullptr;\n        }\n        m_current_total_bytes = 0;\n        m_allocated_capacity_bytes = 0;\n    }\n\n    bool appendParameterBlockVulnerable(const uint8_t* raw_param_block, size_t block_length) {\n        if (!raw_param_block || block_length < sizeof(ParameterHeader)) {\n            return false;\n        }\n\n        const ParameterHeader* header = reinterpret_cast<const ParameterHeader*>(raw_param_block);\n        uint32_t incoming_payload_len = header->payload_len;\n\n        uint32_t required_new_total_size = m_current_total_bytes + incoming_payload_len; \n\n        if (block_length < sizeof(ParameterHeader) + incoming_payload_len) {\n            return false;\n        }\n        \n        if (required_new_total_size > m_allocated_capacity_bytes) {\n            uint8_t* new_buffer = new (std::nothrow) uint8_t[required_new_total_size];\n            if (!new_buffer) {\n                return false;\n            }\n            if (m_aggregated_data) {\n                memcpy(new_buffer, m_aggregated_data, m_current_total_bytes);\n                delete[] m_aggregated_data;\n            }\n            m_aggregated_data = new_buffer;\n            m_allocated_capacity_bytes = required_new_total_size;\n        }\n\n        memcpy(m_aggregated_data + m_current_total_bytes, raw_param_block + sizeof(ParameterHeader), incoming_payload_len);\n\n        m_current_total_bytes = required_new_total_size;\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedData() const {\n        return m_aggregated_data;\n    }\n\n    uint32_t getTotalAggregatedBytes() const {\n        return m_current_total_bytes;\n    }\n\nprivate:\n    uint8_t* m_aggregated_data;\n    uint32_t m_current_total_bytes;\n    uint32_t m_allocated_capacity_bytes;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define TRACE_BUFFER_SIZE 256\n#define TRACE_ENTRY_SIZE 16\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint8_t  data[TRACE_ENTRY_SIZE - sizeof(uint32_t) - sizeof(uint16_t)];\n} TraceEntry;\n\nstatic uint8_t g_trace_buffer[TRACE_BUFFER_SIZE];\nstatic uint16_t g_trace_write_ptr = 0; \n\nvoid init_trace_buffer_fixed() {\n    memset(g_trace_buffer, 0, TRACE_BUFFER_SIZE);\n    g_trace_write_ptr = 0;\n}\n\nbool add_trace_entry_fixed(uint32_t timestamp, uint16_t event_id, const uint8_t* data) {\n    if (g_trace_write_ptr + TRACE_ENTRY_SIZE > TRACE_BUFFER_SIZE) {\n        g_trace_write_ptr = 0; \n    }\n    \n    if (TRACE_ENTRY_SIZE > TRACE_BUFFER_SIZE) return false; \n\n    TraceEntry new_entry;\n    new_entry.timestamp = timestamp;\n    new_entry.event_id = event_id;\n    memcpy(new_entry.data, data, sizeof(new_entry.data));\n\n    memcpy(&g_trace_buffer[g_trace_write_ptr], &new_entry, TRACE_ENTRY_SIZE);\n    g_trace_write_ptr += TRACE_ENTRY_SIZE;\n    return true;\n}\n\nvoid set_trace_metadata_marker_fixed(int16_t meta_offset_multiplier, uint8_t marker_value) {\n    const int16_t BASE_METADATA_OFFSET = -2; \n\n    int32_t total_negative_offset = (int32_t)BASE_METADATA_OFFSET * meta_offset_multiplier;\n\n    int32_t target_idx = (int32_t)g_trace_write_ptr + total_negative_offset;\n\n    if (target_idx < 0 || target_idx >= TRACE_BUFFER_SIZE) {\n        return; \n    }\n\n    g_trace_buffer[target_idx] = marker_value;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_DIAG_EVENTS 50\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp_ms;\n    uint8_t status_flags;\n} DiagEvent;\n\nstatic DiagEvent g_diag_event_log[MAX_DIAG_EVENTS];\nstatic uint32_t g_event_log_count = 0;\n\nvoid init_event_log() {\n    memset(g_diag_event_log, 0, sizeof(g_diag_event_log));\n    g_event_log_count = 0;\n}\n\nbool add_diag_event(uint16_t id, uint32_t timestamp) {\n    if (g_event_log_count < MAX_DIAG_EVENTS) {\n        g_diag_event_log[g_event_log_count].event_id = id;\n        g_diag_event_log[g_event_log_count].timestamp_ms = timestamp;\n        g_diag_event_log[g_event_log_count].status_flags = 0x00;\n        g_event_log_count++;\n        return true;\n    }\n    return false;\n}\n\nvoid classify_recent_events_vulnerable(uint32_t window_size, uint8_t classification_status) {\n    if (g_event_log_count == 0 || window_size == 0) {\n        return;\n    }\n\n    int32_t start_index = (int32_t)g_event_log_count - (int32_t)window_size;\n\n    for (uint32_t i = 0; i < window_size; ++i) {\n        g_diag_event_log[start_index + i].status_flags |= classification_status;\n    }\n\n    if (g_event_log_count <= window_size) {\n        g_event_log_count = 0;\n    } else {\n        g_event_log_count -= window_size;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define EVENT_LOG_BUFFER_SIZE 256\n#define MAX_SINGLE_EVENT_PAYLOAD_SIZE 64\n\ntypedef struct {\n    uint8_t event_id;\n    uint8_t payload_len;\n} EventLogHeader;\n\nstatic uint8_t g_eventLogBuffer[EVENT_LOG_BUFFER_SIZE];\nstatic uint16_t g_logWritePointer = 0;\n\nvoid initEventLogger() {\n    memset(g_eventLogBuffer, 0, EVENT_LOG_BUFFER_SIZE);\n    g_logWritePointer = 0;\n}\n\nint addEventToLog(uint8_t event_type, const uint8_t* event_data, uint8_t data_len) {\n    if (event_data == NULL) {\n        return -1;\n    }\n\n    if (data_len > MAX_SINGLE_EVENT_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    uint16_t entry_total_size = sizeof(EventLogHeader) + data_len;\n\n    // FIX: Ensure the entire new entry (header + data) fits within the buffer.\n    if (g_logWritePointer + entry_total_size > EVENT_LOG_BUFFER_SIZE) {\n        return -3; // Not enough space, prevent overflow\n    }\n\n    g_eventLogBuffer[g_logWritePointer] = event_type;\n    g_eventLogBuffer[g_logWritePointer + 1] = data_len;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        // No further bounds check needed within the loop as the aggregate check above guarantees space.\n        g_eventLogBuffer[g_logWritePointer + 2 + i] = event_data[i];\n    }\n\n    g_logWritePointer += entry_total_size;\n\n    return 0;\n}\n\nvoid simulateDTCRecording(uint8_t dtc_code, const uint8_t* diagnostic_info, uint8_t info_len) {\n    if (g_logWritePointer == 0) {\n        initEventLogger();\n    }\n    addEventToLog(dtc_code, diagnostic_info, info_len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define TRACE_BUFFER_SIZE 256\n#define TRACE_ENTRY_SIZE 16\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint8_t  data[TRACE_ENTRY_SIZE - sizeof(uint32_t) - sizeof(uint16_t)];\n} TraceEntry;\n\nstatic uint8_t g_trace_buffer[TRACE_BUFFER_SIZE];\nstatic uint16_t g_trace_write_ptr = 0; \n\nvoid init_trace_buffer() {\n    memset(g_trace_buffer, 0, TRACE_BUFFER_SIZE);\n    g_trace_write_ptr = 0;\n}\n\nbool add_trace_entry(uint32_t timestamp, uint16_t event_id, const uint8_t* data) {\n    if (g_trace_write_ptr + TRACE_ENTRY_SIZE > TRACE_BUFFER_SIZE) {\n        g_trace_write_ptr = 0; \n    }\n    \n    if (TRACE_ENTRY_SIZE > TRACE_BUFFER_SIZE) return false; \n\n    TraceEntry new_entry;\n    new_entry.timestamp = timestamp;\n    new_entry.event_id = event_id;\n    memcpy(new_entry.data, data, sizeof(new_entry.data));\n\n    memcpy(&g_trace_buffer[g_trace_write_ptr], &new_entry, TRACE_ENTRY_SIZE);\n    g_trace_write_ptr += TRACE_ENTRY_SIZE;\n    return true;\n}\n\nvoid set_trace_metadata_marker_vulnerable(int16_t meta_offset_multiplier, uint8_t marker_value) {\n    const int16_t BASE_METADATA_OFFSET = -2; \n\n    int32_t total_negative_offset = (int32_t)BASE_METADATA_OFFSET * meta_offset_multiplier;\n\n    int32_t target_idx = (int32_t)g_trace_write_ptr + total_negative_offset;\n\n    g_trace_buffer[target_idx] = marker_value;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_TOTAL_LOG_ENTRIES 200\n\ntypedef struct {\n    uint8_t event_id;\n    uint16_t data_value;\n    uint32_t timestamp;\n} LogEntry;\n\nstatic LogEntry g_vehicleEventLog[MAX_TOTAL_LOG_ENTRIES];\n\ntypedef enum {\n    DOMAIN_POWERTRAIN = 0,\n    DOMAIN_CHASSIS,\n    DOMAIN_BODY,\n    DOMAIN_INFOTAINMENT,\n    DOMAIN_COUNT\n} VehicleDomainType;\n\nstatic const size_t g_domainOffsets[DOMAIN_COUNT] = {\n    0,\n    50,\n    100,\n    150\n};\n\nstatic const size_t g_domainMaxEntries[DOMAIN_COUNT] = {\n    50, 50, 50, 50\n};\n\nstatic size_t g_domainCurrentRelativeIndex[DOMAIN_COUNT];\n\nvoid logSystemCriticalEvent(const char* msg) {\n}\n\nvoid initVehicleLogSystem_vulnerable() {\n    for (int i = 0; i < DOMAIN_COUNT; ++i) {\n        g_domainCurrentRelativeIndex[i] = 0;\n    }\n    for (int i = 0; i < MAX_TOTAL_LOG_ENTRIES; ++i) {\n        g_vehicleEventLog[i] = (LogEntry){0, 0, 0};\n    }\n    logSystemCriticalEvent(\"Vehicle log system initialized.\");\n}\n\nvoid logVehicleDomainEvent_vulnerable(VehicleDomainType domain, uint8_t event_id, uint16_t data_value, uint32_t timestamp) {\n    if (domain >= DOMAIN_COUNT) {\n        logSystemCriticalEvent(\"Attempted to log event for invalid domain.\");\n        return;\n    }\n\n    size_t current_relative_idx = g_domainCurrentRelativeIndex[domain];\n    size_t global_target_idx = g_domainOffsets[domain] + current_relative_idx;\n\n    g_vehicleEventLog[global_target_idx] = (LogEntry){event_id, data_value, timestamp};\n    \n    g_domainCurrentRelativeIndex[domain]++;\n}\n\nvoid simulatePowertrainFaults_vulnerable() {\n    for (int i = 0; i < 60; ++i) {\n        logVehicleDomainEvent_vulnerable(DOMAIN_POWERTRAIN, 0x10 + i, 100 + i, 0x12345000 + i);\n    }\n}\n\nvoid runVulnerableLogSystem() {\n    initVehicleLogSystem_vulnerable();\n    simulatePowertrainFaults_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_DIAG_HANDLERS 16\n\ntypedef struct {\n    uint32_t raw_event_code;\n} DiagnosticEvent;\n\ntypedef void (*DiagnosticHandler)(uint16_t error_code, uint8_t module_id);\n\nvoid handleSubComponent0(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent1(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent2(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent3(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent4(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent5(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent6(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent7(uint16_t error_code, uint8_t module_id) {}\n\nstatic DiagnosticHandler g_diagHandlers_vulnerable[MAX_DIAG_HANDLERS];\nstatic const uint8_t actual_num_diag_handlers = 8;\n\nvoid automotive_system_log_vulnerable(const char* msg) {\n}\n\nDiagnosticEvent receiveDiagnosticEvent_vulnerable() {\n    DiagnosticEvent event;\n    event.raw_event_code = 0x01234508;\n    return event;\n}\n\nvoid initializeDiagnosticSystem_vulnerable() {\n    g_diagHandlers_vulnerable[0] = handleSubComponent0;\n    g_diagHandlers_vulnerable[1] = handleSubComponent1;\n    g_diagHandlers_vulnerable[2] = handleSubComponent2;\n    g_diagHandlers_vulnerable[3] = handleSubComponent3;\n    g_diagHandlers_vulnerable[4] = handleSubComponent4;\n    g_diagHandlers_vulnerable[5] = handleSubComponent5;\n    g_diagHandlers_vulnerable[6] = handleSubComponent6;\n    g_diagHandlers_vulnerable[7] = handleSubComponent7;\n\n    automotive_system_log_vulnerable(\"Diagnostic system initialized (vulnerable).\");\n}\n\nvoid processDiagnosticEvent_vulnerable() {\n    DiagnosticEvent event = receiveDiagnosticEvent_vulnerable();\n\n    uint8_t component_index = (uint8_t)(event.raw_event_code & 0xFF);\n    uint16_t error_code = (uint16_t)((event.raw_event_code >> 8) & 0xFFFF);\n    uint8_t module_id = (uint8_t)((event.raw_event_code >> 24) & 0xFF);\n\n    if (component_index < MAX_DIAG_HANDLERS) {\n        DiagnosticHandler handler = g_diagHandlers_vulnerable[component_index];\n        if (handler != NULL) {\n            handler(error_code, module_id);\n            automotive_system_log_vulnerable(\"Diagnostic event dispatched (vulnerable).\");\n        } else {\n            automotive_system_log_vulnerable(\"No handler found for component index (vulnerable).\");\n        }\n    } else {\n        automotive_system_log_vulnerable(\"Invalid component index out of declared bounds (vulnerable).\");\n    }\n}\n\nvoid main_diag_vulnerable() {\n    initializeDiagnosticSystem_vulnerable();\n    processDiagnosticEvent_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 64\n#define MAX_COMMAND_PAYLOAD_SIZE 128\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t parameter_idx;\n    uint8_t data_length;\n    uint8_t data[MAX_COMMAND_PAYLOAD_SIZE - 3];\n} VehicleCommand;\n\nstatic uint8_t g_vehicleConfigArea[VEHICLE_CONFIG_BUFFER_SIZE];\n\nvoid initVehicleConfigArea() {\n    memset(g_vehicleConfigArea, 0x00, VEHICLE_CONFIG_BUFFER_SIZE);\n}\n\n#define CMD_UPDATE_CONFIG_DATA 0x05\n#define CMD_READ_CONFIG_DATA   0x06\n\nint processVehicleCommand(const VehicleCommand* cmd) {\n    if (cmd == NULL) {\n        return -1;\n    }\n\n    if (cmd->command_id == CMD_UPDATE_CONFIG_DATA) {\n        uint8_t start_offset = cmd->parameter_idx;\n        uint8_t data_to_copy = cmd->data_length;\n\n        if (start_offset >= VEHICLE_CONFIG_BUFFER_SIZE) {\n            return -2;\n        }\n\n        if (data_to_copy > (MAX_COMMAND_PAYLOAD_SIZE - (sizeof(cmd->command_id) + sizeof(cmd->parameter_idx) + sizeof(cmd->data_length)))) {\n             return -3;\n        }\n\n        memcpy(g_vehicleConfigArea + start_offset, cmd->data, data_to_copy);\n\n        return 0;\n    } else if (cmd->command_id == CMD_READ_CONFIG_DATA) {\n        return 0;\n    }\n    \n    return -4;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define RECORD_BUFFER_SIZE 256\n#define HEADER_MAGIC_BYTE 0xAA\n#define FOOTER_MAGIC_BYTE 0x55\n#define MIN_RECORD_SIZE 8\n\nstatic uint8_t g_diagnostic_record_buffer[RECORD_BUFFER_SIZE];\nstatic int32_t g_last_record_start_offset = -1;\n\nbool parse_record(uint32_t offset) {\n    if (offset < 0 || offset >= RECORD_BUFFER_SIZE) return false;\n    volatile uint8_t magic = g_diagnostic_record_buffer[offset];\n    (void)magic;\n    return true;\n}\n\nvoid init_diagnostic_buffer() {\n    memset(g_diagnostic_record_buffer, 0, RECORD_BUFFER_SIZE);\n    g_last_record_start_offset = -1;\n}\n\nbool add_diagnostic_record(const uint8_t* payload, uint8_t payload_len) {\n    uint32_t record_total_len = 1 + 1 + payload_len + 1;\n    if (record_total_len > RECORD_BUFFER_SIZE || record_total_len < MIN_RECORD_SIZE) {\n        return false;\n    }\n\n    int32_t next_write_offset;\n    if (g_last_record_start_offset == -1) {\n        next_write_offset = 0;\n    } else {\n        uint8_t prev_payload_len = g_diagnostic_record_buffer[g_last_record_start_offset + 1];\n        next_write_offset = g_last_record_start_offset + (1 + 1 + prev_payload_len + 1);\n    }\n\n    if (next_write_offset + record_total_len > RECORD_BUFFER_SIZE) {\n        next_write_offset = 0;\n    }\n\n    g_diagnostic_record_buffer[next_write_offset] = HEADER_MAGIC_BYTE;\n    g_diagnostic_record_buffer[next_write_offset + 1] = payload_len;\n    memcpy(g_diagnostic_record_buffer + next_write_offset + 2, payload, payload_len);\n    g_diagnostic_record_buffer[next_write_offset + 2 + payload_len] = FOOTER_MAGIC_BYTE;\n\n    g_last_record_start_offset = next_write_offset;\n    return true;\n}\n\nvoid update_segment_marker_vulnerable(int16_t offset_from_last_record_start, uint8_t marker_value) {\n    if (g_last_record_start_offset == -1) {\n        return;\n    }\n\n    int32_t target_index = g_last_record_start_offset + offset_from_last_record_start;\n\n    g_diagnostic_record_buffer[target_index] = marker_value;\n\n    parse_record(g_last_record_start_offset);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\ntypedef uint32_t CalibrationParameter;\n\n#define TOTAL_CALIBRATION_AREA_SIZE 256\n\nstatic CalibrationParameter g_calibration_area[TOTAL_CALIBRATION_AREA_SIZE];\n\nstatic uint16_t g_active_cal_data_end_idx = 0;\n\nvoid init_calibration_system() {\n    memset(g_calibration_area, 0x00, sizeof(g_calibration_area));\n    g_active_cal_data_end_idx = 0;\n}\n\nint16_t add_calibration_block(const CalibrationParameter* data, uint16_t num_params) {\n    if (g_active_cal_data_end_idx + num_params > TOTAL_CALIBRATION_AREA_SIZE) {\n        return -1;\n    }\n    uint16_t start_idx = g_active_cal_data_end_idx;\n    for (uint16_t i = 0; i < num_params; ++i) {\n        g_calibration_area[start_idx + i] = data[i];\n    }\n    g_active_cal_data_end_idx += num_params;\n    return start_idx;\n}\n\nCalibrationParameter get_calibration_param(uint16_t index) {\n    if (index < TOTAL_CALIBRATION_AREA_SIZE) {\n        return g_calibration_area[index];\n    }\n    return 0;\n}\n\nvoid rollback_calibration_value_vulnerable(uint16_t offset_from_end, CalibrationParameter new_value) {\n    if (g_active_cal_data_end_idx == 0) {\n        return;\n    }\n\n    int32_t target_idx = (int32_t)g_active_cal_data_end_idx - 1 - (int32_t)offset_from_end;\n\n    g_calibration_area[target_idx] = new_value;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <limits>\n\n// Represents a single sensor reading record.\n// The padding is added to ensure sizeof(SensorReading) is a value\n// that facilitates integer overflow demonstration with a large uint32_t count.\nstruct SensorReading {\n    uint32_t timestamp;\n    int16_t  value_x;\n    int16_t  value_y;\n    int16_t  value_z;\n    uint8_t  status_flags;\n    uint8_t  _padding[13]; // Padding to make total size 24 bytes\n};\n\n// Represents a packet received by the vehicle's telemetry system.\nstruct SensorDataPacketHeader {\n    uint16_t packet_id;\n    uint32_t num_readings;  // Number of SensorReading structures in this packet (can be maliciously large)\n    uint32_t total_payload_size_bytes; // Advertised total size of all readings combined\n};\n\nclass SensorDataCollection {\npublic:\n    SensorDataCollection() : m_readings_buffer(nullptr), m_current_num_readings(0), m_allocated_max_readings(0) {}\n\n    ~SensorDataCollection() {\n        clearData();\n    }\n\n    void clearData() {\n        if (m_readings_buffer) {\n            free(m_readings_buffer);\n            m_readings_buffer = nullptr;\n        }\n        m_current_num_readings = 0;\n        m_allocated_max_readings = 0;\n    }\n\n    bool processSensorDataPacketVulnerable(const uint8_t* raw_packet, size_t raw_len) {\n        clearData();\n\n        if (!raw_packet || raw_len < sizeof(SensorDataPacketHeader)) {\n            return false;\n        }\n\n        const SensorDataPacketHeader* header = reinterpret_cast<const SensorDataPacketHeader*>(raw_packet);\n\n        // Basic sanity checks for packet header values\n        if (header->packet_id != 0xABCD) {\n            return false;\n        }\n        if (header->num_readings == 0 && header->total_payload_size_bytes > 0) {\n            return false;\n        }\n\n        // VULNERABILITY: Integer overflow in allocation size calculation leading to heap overflow.\n        // If 'header->num_readings' is maliciously large (e.g., 200,000,000) and 'sizeof(SensorReading)' is 24 bytes,\n        // their product (200,000,000 * 24 = 4,800,000,000) will overflow a 32-bit unsigned integer\n        // (max value approx 4.29 billion). The result will wrap around (e.g., 505,032,704 bytes).\n        // This significantly smaller, wrapped-around value is then used for malloc.\n        uint32_t calculated_alloc_bytes_u32 = header->num_readings * sizeof(SensorReading);\n\n        m_readings_buffer = (SensorReading*)malloc(calculated_alloc_bytes_u32);\n        if (!m_readings_buffer && calculated_alloc_bytes_u32 > 0) {\n            return false; // Allocation failed or zero-size requested for non-zero data\n        }\n\n        // m_allocated_max_readings is set based on the potentially undersized allocated memory.\n        // If overflow occurred, this value will be smaller than the true 'header->num_readings'.\n        m_allocated_max_readings = calculated_alloc_bytes_u32 / sizeof(SensorReading);\n        m_current_num_readings = 0;\n\n        size_t current_packet_read_offset = sizeof(SensorDataPacketHeader);\n\n        // Loop iterates 'header->num_readings' times, which can be the malicious large value.\n        // The internal buffer 'm_readings_buffer' was allocated based on the potentially\n        // overflowed smaller size.\n        for (uint32_t i = 0; i < header->num_readings; ++i) {\n            // Source packet bounds check. This check prevents reading past raw_len,\n            // but does not prevent writing past the allocated heap buffer.\n            if (current_packet_read_offset + sizeof(SensorReading) > raw_len) {\n                clearData();\n                return false;\n            }\n\n            // Direct assignment of SensorReading structure into the heap buffer.\n            // This write operation will cause a heap-based buffer overflow\n            // when 'i' exceeds 'm_allocated_max_readings' due to the undersized allocation.\n            m_readings_buffer[i] = *reinterpret_cast<const SensorReading*>(raw_packet + current_packet_read_offset);\n\n            m_current_num_readings++;\n            current_packet_read_offset += sizeof(SensorReading);\n        }\n        \n        // This consistency check does not prevent the overflow, which already happened during the loop.\n        if (m_current_num_readings != header->num_readings) {\n            clearData();\n            return false;\n        }\n\n        return true;\n    }\n\nprivate:\n    SensorReading* m_readings_buffer;\n    size_t m_current_num_readings;\n    size_t m_allocated_max_readings;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_PACKET_SIZE 1500\n#define PARAMETER_RECORD_FIXED_HEADER_SIZE (sizeof(uint16_t) + sizeof(uint8_t)) \n\nstatic uint8_t g_vehicleConfigMemory[512];\n\nint processVehicleConfigUpdate(const uint8_t* message_data, uint16_t message_len) {\n    if (message_data == NULL || message_len < sizeof(uint16_t)) {\n        return -1;\n    }\n\n    uint16_t num_params = (message_data[0] << 8) | message_data[1];\n    uint16_t current_read_offset = sizeof(uint16_t);\n\n    uint16_t total_payload_bytes_expected = 0;\n\n    for (uint16_t i = 0; i < num_params; ++i) {\n        if (current_read_offset + PARAMETER_RECORD_FIXED_HEADER_SIZE > message_len) {\n            return -2;\n        }\n\n        uint8_t data_len = message_data[current_read_offset + sizeof(uint16_t)];\n\n        if (current_read_offset + PARAMETER_RECORD_FIXED_HEADER_SIZE + data_len > message_len) {\n            return -3;\n        }\n\n        uint16_t param_record_size = PARAMETER_RECORD_FIXED_HEADER_SIZE + data_len;\n        total_payload_bytes_expected += param_record_size;\n\n        current_read_offset += param_record_size;\n    }\n\n    if (current_read_offset != message_len) {\n        return -4;\n    }\n\n    uint8_t* temp_stage_buffer = (uint8_t*)malloc(total_payload_bytes_expected);\n    if (temp_stage_buffer == NULL) {\n        return -5;\n    }\n\n    memcpy(temp_stage_buffer, message_data + sizeof(uint16_t), message_len - sizeof(uint16_t));\n\n    free(temp_stage_buffer);\n\n    return 0;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_PACKET_SIZE 1500\n#define PARAMETER_RECORD_FIXED_HEADER_SIZE (sizeof(uint16_t) + sizeof(uint8_t)) \n#define MAX_TOTAL_CONFIG_PAYLOAD_SIZE (MAX_PACKET_SIZE - sizeof(uint16_t))\n\nstatic uint8_t g_vehicleConfigMemory[512];\n\nint processVehicleConfigUpdate(const uint8_t* message_data, uint16_t message_len) {\n    if (message_data == NULL || message_len < sizeof(uint16_t)) {\n        return -1;\n    }\n\n    uint16_t num_params = (message_data[0] << 8) | message_data[1];\n    uint16_t current_read_offset = sizeof(uint16_t);\n\n    uint32_t total_payload_bytes_expected = 0;\n\n    for (uint16_t i = 0; i < num_params; ++i) {\n        if (current_read_offset + PARAMETER_RECORD_FIXED_HEADER_SIZE > message_len) {\n            return -2;\n        }\n\n        uint8_t data_len = message_data[current_read_offset + sizeof(uint16_t)];\n\n        if (current_read_offset + PARAMETER_RECORD_FIXED_HEADER_SIZE + data_len > message_len) {\n            return -3;\n        }\n\n        uint32_t param_record_size = (uint32_t)PARAMETER_RECORD_FIXED_HEADER_SIZE + data_len;\n        \n        if (total_payload_bytes_expected > (MAX_TOTAL_CONFIG_PAYLOAD_SIZE - param_record_size)) {\n            return -6;\n        }\n        total_payload_bytes_expected += param_record_size;\n\n        current_read_offset += param_record_size;\n    }\n\n    if (current_read_offset != message_len) {\n        return -4;\n    }\n\n    if (total_payload_bytes_expected > MAX_TOTAL_CONFIG_PAYLOAD_SIZE) {\n        return -8;\n    }\n    \n    uint8_t* temp_stage_buffer = (uint8_t*)malloc(total_payload_bytes_expected);\n    if (temp_stage_buffer == NULL) {\n        return -5;\n    }\n\n    memcpy(temp_stage_buffer, message_data + sizeof(uint16_t), total_payload_bytes_expected);\n\n    free(temp_stage_buffer);\n\n    return 0;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_DIAG_EVENTS 50\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp_ms;\n    uint8_t status_flags;\n} DiagEvent;\n\nstatic DiagEvent g_diag_event_log[MAX_DIAG_EVENTS];\nstatic uint32_t g_event_log_count = 0;\n\nvoid init_event_log_fixed() {\n    memset(g_diag_event_log, 0, sizeof(g_diag_event_log));\n    g_event_log_count = 0;\n}\n\nbool add_diag_event_fixed(uint16_t id, uint32_t timestamp) {\n    if (g_event_log_count < MAX_DIAG_EVENTS) {\n        g_diag_event_log[g_event_log_count].event_id = id;\n        g_diag_event_log[g_event_log_count].timestamp_ms = timestamp;\n        g_diag_event_log[g_event_log_count].status_flags = 0x00;\n        g_event_log_count++;\n        return true;\n    }\n    return false;\n}\n\nvoid classify_recent_events_fixed(uint32_t window_size, uint8_t classification_status) {\n    if (g_event_log_count == 0 || window_size == 0) {\n        return;\n    }\n\n    uint32_t actual_start_index;\n    uint32_t actual_window_size;\n\n    if (window_size >= g_event_log_count) {\n        actual_start_index = 0;\n        actual_window_size = g_event_log_count;\n    } else {\n        actual_start_index = g_event_log_count - window_size;\n        actual_window_size = window_size;\n    }\n\n    for (uint32_t i = 0; i < actual_window_size; ++i) {\n        g_diag_event_log[actual_start_index + i].status_flags |= classification_status;\n    }\n\n    g_event_log_count = actual_start_index;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_RECORDER_BUFFER_SIZE 250 \n#define MAX_PAYLOAD_CHUNK_SIZE 60   \n\nstatic uint8_t g_diagRecordBuffer[DIAG_RECORDER_BUFFER_SIZE];\nstatic uint8_t g_currentRecordOffset = 0; \n\nvoid initDiagRecorder() {\n    memset(g_diagRecordBuffer, 0, DIAG_RECORDER_BUFFER_SIZE);\n    g_currentRecordOffset = 0;\n}\n\nint appendDiagDataChunk(const uint8_t* data_chunk, uint8_t chunk_len) {\n    if (data_chunk == NULL || chunk_len == 0 || chunk_len > MAX_PAYLOAD_CHUNK_SIZE) {\n        return -1; \n    }\n\n    uint8_t next_offset = g_currentRecordOffset + chunk_len;\n\n    if (next_offset > DIAG_RECORDER_BUFFER_SIZE) { \n        return -2; \n    }\n\n    for (uint8_t i = 0; i < chunk_len; ++i) {\n        g_diagRecordBuffer[g_currentRecordOffset + i] = data_chunk[i];\n    }\n\n    g_currentRecordOffset = next_offset; \n\n    return 0; \n}\n\nvoid processDiagnosticDataStream(const uint8_t* stream_data, uint16_t stream_len) {\n    initDiagRecorder(); \n\n    uint8_t fill_data[10];\n    memset(fill_data, 0x01, sizeof(fill_data));\n    \n    for (int k = 0; k < 20; ++k) {\n        appendDiagDataChunk(fill_data, 10); \n    }\n    \n    uint8_t evil_chunk_data[60];\n    memset(evil_chunk_data, 0xAA, sizeof(evil_chunk_data));\n\n    appendDiagDataChunk(evil_chunk_data, 60);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_MESSAGE_BUFFER_SIZE 16\n#define MAX_MESSAGE_LEN 64\n\ntypedef struct {\n    char message[MAX_MESSAGE_LEN];\n    uint32_t timestamp;\n    bool processed;\n    uint8_t status_flags;\n} DiagnosticMessage;\n\nstatic DiagnosticMessage g_diag_message_buffer_fixed[DIAG_MESSAGE_BUFFER_SIZE];\nstatic uint8_t g_current_write_idx_fixed = 0;\nstatic uint8_t g_active_message_count_fixed = 0;\n\nvoid init_diag_system_fixed() {\n    for (uint8_t i = 0; i < DIAG_MESSAGE_BUFFER_SIZE; ++i) {\n        memset(&g_diag_message_buffer_fixed[i], 0, sizeof(DiagnosticMessage));\n        g_diag_message_buffer_fixed[i].processed = true;\n        g_diag_message_buffer_fixed[i].status_flags = 0x00;\n    }\n    g_current_write_idx_fixed = 0;\n    g_active_message_count_fixed = 0;\n}\n\nvoid add_diag_message_fixed(const char* msg_str, uint32_t timestamp) {\n    strncpy(g_diag_message_buffer_fixed[g_current_write_idx_fixed].message, msg_str, MAX_MESSAGE_LEN - 1);\n    g_diag_message_buffer_fixed[g_current_write_idx_fixed].message[MAX_MESSAGE_LEN - 1] = '\\0';\n    g_diag_message_buffer_fixed[g_current_write_idx_fixed].timestamp = timestamp;\n    g_diag_message_buffer_fixed[g_current_write_idx_fixed].processed = false;\n    g_diag_message_buffer_fixed[g_current_write_idx_fixed].status_flags = 0x01;\n\n    g_current_write_idx_fixed = (g_current_write_idx_fixed + 1) % DIAG_MESSAGE_BUFFER_SIZE;\n    if (g_active_message_count_fixed < DIAG_MESSAGE_BUFFER_SIZE) {\n        g_active_message_count_fixed++;\n    }\n}\n\nvoid revert_message_processing_fixed(int16_t messages_to_revert) {\n    if (messages_to_revert <= 0 || g_active_message_count_fixed == 0) {\n        return;\n    }\n\n    int16_t actual_messages_to_revert = (messages_to_revert > g_active_message_count_fixed) ?\n                                         g_active_message_count_fixed : messages_to_revert;\n\n    int16_t last_message_physical_idx = (g_current_write_idx_fixed == 0 && g_active_message_count_fixed == DIAG_MESSAGE_BUFFER_SIZE) ?\n                                        (DIAG_MESSAGE_BUFFER_SIZE - 1) : (g_current_write_idx_fixed - 1);\n\n    for (int16_t i = 0; i < actual_messages_to_revert; ++i) {\n        int16_t target_idx = (last_message_physical_idx - i + DIAG_MESSAGE_BUFFER_SIZE) % DIAG_MESSAGE_BUFFER_SIZE;\n\n        g_diag_message_buffer_fixed[target_idx].processed = false;\n        g_diag_message_buffer_fixed[target_idx].status_flags = 0x02;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t details_length_bytes;\n} EventLogHeader;\n\nclass VehicleEventLogger {\npublic:\n    VehicleEventLogger() : m_log_buffer(nullptr), m_current_buffer_pos(0), m_allocated_capacity(0) {}\n\n    ~VehicleEventLogger() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n    }\n\n    void clearLogs() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n        m_log_buffer = nullptr;\n        m_current_buffer_pos = 0;\n        m_allocated_capacity = 0;\n    }\n\n    bool appendEventFixed(const uint8_t* raw_event_data, size_t data_packet_length) {\n        if (!raw_event_data || data_packet_length < sizeof(EventLogHeader)) {\n            return false;\n        }\n\n        const EventLogHeader* header = reinterpret_cast<const EventLogHeader*>(raw_event_data);\n        uint16_t details_len = header->details_length_bytes;\n\n        static const uint16_t MAX_DETAILS_LENGTH = 4096;\n        if (details_len > MAX_DETAILS_LENGTH) {\n            return false;\n        }\n\n        if (data_packet_length < sizeof(EventLogHeader) + details_len) {\n            return false;\n        }\n\n        size_t padded_details_len = (details_len + 3) & ~3;\n        size_t current_record_size_padded = sizeof(EventLogHeader) + padded_details_len;\n        \n        size_t required_total_size;\n        if (m_current_buffer_pos > (SIZE_MAX - current_record_size_padded)) { \n            return false; \n        }\n        required_total_size = m_current_buffer_pos + current_record_size_padded;\n        \n        if (required_total_size > m_allocated_capacity) {\n            size_t new_capacity = required_total_size;\n            if (new_capacity < 256) new_capacity = 256;\n            if (new_capacity < required_total_size) new_capacity = required_total_size;\n\n            uint8_t* temp_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n            if (!temp_buffer) {\n                if (m_log_buffer) {\n                    free(m_log_buffer);\n                    m_log_buffer = nullptr;\n                }\n                m_allocated_capacity = 0;\n                m_current_buffer_pos = 0;\n                return false;\n            }\n            m_log_buffer = temp_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        for (size_t i = 0; i < sizeof(EventLogHeader); ++i) {\n            m_log_buffer[m_current_buffer_pos + i] = raw_event_data[i];\n        }\n\n        const uint8_t* details_src_ptr = raw_event_data + sizeof(EventLogHeader);\n        uint8_t* details_dest_ptr = m_log_buffer + m_current_buffer_pos + sizeof(EventLogHeader);\n\n        for (uint16_t i = 0; i < details_len; ++i) {\n            details_dest_ptr[i] = details_src_ptr[i];\n        }\n\n        size_t padding_bytes = padded_details_len - details_len;\n        if (padding_bytes > 0) {\n            memset(details_dest_ptr + details_len, 0, padding_bytes);\n        }\n\n        m_current_buffer_pos += current_record_size_padded;\n\n        return true;\n    }\n\n    size_t getTotalLoggedBytes() const {\n        return m_current_buffer_pos;\n    }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t   m_current_buffer_pos;\n    size_t   m_allocated_capacity;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\ntypedef uint32_t CalibrationParameter;\n\n#define TOTAL_CALIBRATION_AREA_SIZE 256\n\nstatic CalibrationParameter g_calibration_area[TOTAL_CALIBRATION_AREA_SIZE];\n\nstatic uint16_t g_active_cal_data_end_idx = 0;\n\nvoid init_calibration_system_fixed() {\n    memset(g_calibration_area, 0x00, sizeof(g_calibration_area));\n    g_active_cal_data_end_idx = 0;\n}\n\nint16_t add_calibration_block_fixed(const CalibrationParameter* data, uint16_t num_params) {\n    if (g_active_cal_data_end_idx + num_params > TOTAL_CALIBRATION_AREA_SIZE) {\n        return -1;\n    }\n    uint16_t start_idx = g_active_cal_data_end_idx;\n    for (uint16_t i = 0; i < num_params; ++i) {\n        g_calibration_area[start_idx + i] = data[i];\n    }\n    g_active_cal_data_end_idx += num_params;\n    return start_idx;\n}\n\nCalibrationParameter get_calibration_param_fixed(uint16_t index) {\n    if (index < TOTAL_CALIBRATION_AREA_SIZE) {\n        return g_calibration_area[index];\n    }\n    return 0;\n}\n\nvoid rollback_calibration_value_fixed(uint16_t offset_from_end, CalibrationParameter new_value) {\n    if (g_active_cal_data_end_idx == 0) {\n        return;\n    }\n\n    int32_t potential_target_idx = (int32_t)g_active_cal_data_end_idx - 1 - (int32_t)offset_from_end;\n\n    if (potential_target_idx < 0 || potential_target_idx >= (int32_t)g_active_cal_data_end_idx) {\n        return;\n    }\n\n    uint16_t target_idx = (uint16_t)potential_target_idx;\n    g_calibration_area[target_idx] = new_value;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_EVENT_BUFFER_SIZE 512\n\nstatic uint8_t g_event_data_buffer[MAX_EVENT_BUFFER_SIZE];\nstatic int32_t g_current_event_sequence_start = 0;\nstatic uint16_t g_active_buffer_length = 0;\n\nvoid init_event_recorder() {\n    memset(g_event_data_buffer, 0, MAX_EVENT_BUFFER_SIZE);\n    g_current_event_sequence_start = 0;\n    g_active_buffer_length = 0;\n}\n\nbool record_raw_event_data(const uint8_t* data, uint16_t len) {\n    if (len == 0 || data == NULL) return false;\n    if (g_active_buffer_length + len > MAX_EVENT_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_event_data_buffer + g_active_buffer_length, data, len);\n    g_active_buffer_length += len;\n    return true;\n}\n\nconst uint8_t* get_event_data_at_offset(int32_t offset, uint16_t* len) {\n    if (offset < 0 || offset >= g_active_buffer_length) {\n        if (len) *len = 0;\n        return NULL;\n    }\n    if (len) *len = (uint16_t)(g_active_buffer_length - offset);\n    return g_event_data_buffer + offset;\n}\n\nvoid set_event_sequence_start_backward_vulnerable(uint16_t relative_back_offset_bytes) {\n    g_current_event_sequence_start -= relative_back_offset_bytes;\n}\n\nvoid mark_current_event_status_vulnerable(uint8_t status_code) {\n    g_event_data_buffer[g_current_event_sequence_start] = status_code;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MEMORY_POOL_SIZE 512\n#define MAX_POOL_ALLOCATIONS 16\n\nstatic uint8_t s_ecu_memory_pool[MEMORY_POOL_SIZE];\nstatic int32_t s_pool_current_offset = 0;\n\ntypedef struct {\n    int32_t offset;\n    uint16_t size;\n    bool active;\n} PoolAllocationEntry;\n\nstatic PoolAllocationEntry s_allocation_table[MAX_POOL_ALLOCATIONS];\nstatic uint8_t s_num_active_allocations = 0;\n\nvoid init_ecu_memory_pool_fixed() {\n    memset(s_ecu_memory_pool, 0, MEMORY_POOL_SIZE);\n    s_pool_current_offset = 0;\n    for (int i = 0; i < MAX_POOL_ALLOCATIONS; ++i) {\n        s_allocation_table[i].active = false;\n        s_allocation_table[i].offset = 0;\n        s_allocation_table[i].size = 0;\n    }\n    s_num_active_allocations = 0;\n}\n\nvoid* allocate_pool_block_fixed(uint16_t size) {\n    if (s_num_active_allocations >= MAX_POOL_ALLOCATIONS) {\n        return NULL;\n    }\n    if ((s_pool_current_offset + size) > MEMORY_POOL_SIZE) {\n        return NULL;\n    }\n\n    void* ptr = &s_ecu_memory_pool[s_pool_current_offset];\n    s_allocation_table[s_num_active_allocations].offset = s_pool_current_offset;\n    s_allocation_table[s_num_active_allocations].size = size;\n    s_allocation_table[s_num_active_allocations].active = true;\n    s_num_active_allocations++;\n    s_pool_current_offset += size;\n    return ptr;\n}\n\nvoid reclaim_last_pool_block_fixed(uint16_t size_to_reclaim) {\n    if (s_pool_current_offset == 0) {\n        return;\n    }\n\n    if ((int32_t)size_to_reclaim > s_pool_current_offset) {\n        s_pool_current_offset = 0;\n        return;\n    }\n\n    s_pool_current_offset -= size_to_reclaim;\n\n    s_ecu_memory_pool[s_pool_current_offset] = 0xAD;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define TEMP_DATA_SCRATCHPAD_SIZE 128\n#define DATA_SECTION_START_OFFSET 8\n\nstatic uint8_t g_processing_scratchpad[TEMP_DATA_SCRATCHPAD_SIZE];\nstatic uint16_t g_current_scratchpad_data_len = 0;\n\nvoid init_scratchpad_processing() {\n    memset(g_processing_scratchpad, 0, TEMP_DATA_SCRATCHPAD_SIZE);\n    g_current_scratchpad_data_len = 0;\n}\n\nbool load_data_to_scratchpad(const uint8_t* data, uint16_t len) {\n    if (len > (TEMP_DATA_SCRATCHPAD_SIZE - DATA_SECTION_START_OFFSET)) {\n        return false;\n    }\n    memcpy(g_processing_scratchpad + DATA_SECTION_START_OFFSET, data, len);\n    g_current_scratchpad_data_len = len;\n    return true;\n}\n\nvoid apply_data_transform_vulnerable(uint8_t transform_type_marker, int16_t relative_start_offset) {\n    if (g_current_scratchpad_data_len == 0) {\n        return;\n    }\n\n    int32_t target_absolute_index = DATA_SECTION_START_OFFSET + relative_start_offset;\n\n    g_processing_scratchpad[target_absolute_index] = transform_type_marker;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define COMMAND_QUEUE_SIZE 10\n\ntypedef enum {\n    CMD_NONE = 0,\n    CMD_LOCK_DOOR,\n    CMD_UNLOCK_DOOR,\n    CMD_ADJUST_SEAT,\n    CMD_PERFORM_DIAG,\n    CMD_TOTAL\n} VehicleCommandId;\n\ntypedef struct {\n    VehicleCommandId id;\n    int16_t param1;\n    int16_t param2;\n    uint8_t flags;\n    bool processed;\n} VehicleCommand;\n\nstatic VehicleCommand g_command_queue[COMMAND_QUEUE_SIZE];\nstatic int g_command_queue_head = 0;\nstatic int g_command_queue_tail = 0;\nstatic int g_command_queue_count = 0;\n\nvoid init_command_queue_vulnerable() {\n    memset(g_command_queue, 0, sizeof(g_command_queue));\n    g_command_queue_head = 0;\n    g_command_queue_tail = 0;\n    g_command_queue_count = 0;\n}\n\nbool enqueue_command_vulnerable(VehicleCommandId id, int16_t p1, int16_t p2) {\n    if (g_command_queue_count >= COMMAND_QUEUE_SIZE) {\n        return false;\n    }\n\n    g_command_queue[g_command_queue_tail].id = id;\n    g_command_queue[g_command_queue_tail].param1 = p1;\n    g_command_queue[g_command_queue_tail].param2 = p2;\n    g_command_queue[g_command_queue_tail].flags = 0;\n    g_command_queue[g_command_queue_tail].processed = false;\n\n    g_command_queue_tail = (g_command_queue_tail + 1) % COMMAND_QUEUE_SIZE;\n    g_command_queue_count++;\n    return true;\n}\n\nbool dequeue_command_vulnerable(VehicleCommand* cmd_out) {\n    if (g_command_queue_count == 0) {\n        return false;\n    }\n\n    *cmd_out = g_command_queue[g_command_queue_head];\n    g_command_queue_head = (g_command_queue_head + 1) % COMMAND_QUEUE_SIZE;\n    g_command_queue_count--;\n    return true;\n}\n\nvoid reinsert_critical_command_vulnerable(VehicleCommand cmd) {\n    if (g_command_queue_count >= COMMAND_QUEUE_SIZE) {\n        return;\n    }\n\n    g_command_queue_head--;\n\n    g_command_queue[g_command_queue_head] = cmd;\n\n    g_command_queue_count++;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_MODES 3\n#define MAX_PARAMS_PER_MODE 10\n\ntypedef enum {\n    MODE_ECO = 0,\n    MODE_SPORT,\n    MODE_OFFROAD,\n    MODE_COUNT\n} VehicleMode;\n\ntypedef struct {\n    uint16_t id;\n    uint16_t value;\n    bool configurable;\n} VehicleParameter;\n\nstatic VehicleParameter g_vehicleModeParameters[MAX_VEHICLE_MODES][MAX_PARAMS_PER_MODE];\n\nstatic uint8_t g_activeParamCounts[MAX_VEHICLE_MODES];\n\nvoid vehicle_log_vulnerable(const char* msg) {\n    fprintf(stderr, \"VULN_LOG: %s\\n\", msg);\n}\n\nvoid initializeVehicleParameters_vulnerable() {\n    for (uint8_t i = 0; i < MAX_VEHICLE_MODES; ++i) {\n        for (uint8_t j = 0; j < MAX_PARAMS_PER_MODE; ++j) {\n            g_vehicleModeParameters[i][j] = (VehicleParameter){0, 0, false};\n        }\n        g_activeParamCounts[i] = 0; \n    }\n\n    g_vehicleModeParameters[MODE_ECO][0] = (VehicleParameter){0x0001, 100, true};\n    g_vehicleModeParameters[MODE_ECO][1] = (VehicleParameter){0x0002, 50, true};\n    g_vehicleModeParameters[MODE_ECO][2] = (VehicleParameter){0x0003, 1, false};\n    g_activeParamCounts[MODE_ECO] = 3;\n\n    g_vehicleModeParameters[MODE_SPORT][0] = (VehicleParameter){0x0001, 250, true};\n    g_vehicleModeParameters[MODE_SPORT][1] = (VehicleParameter){0x0002, 90, true};\n    g_vehicleModeParameters[MODE_SPORT][2] = (VehicleParameter){0x0003, 0, false};\n    g_vehicleModeParameters[MODE_SPORT][3] = (VehicleParameter){0x0004, 1, true};\n    g_activeParamCounts[MODE_SPORT] = 4;\n\n    g_vehicleModeParameters[MODE_OFFROAD][0] = (VehicleParameter){0x0001, 80, true};\n    g_vehicleModeParameters[MODE_OFFROAD][1] = (VehicleParameter){0x0002, 70, true};\n    g_vehicleModeParameters[MODE_OFFROAD][2] = (VehicleParameter){0x0005, 1, true};\n    g_activeParamCounts[MODE_OFFROAD] = 3;\n\n    vehicle_log_vulnerable(\"Vehicle parameter system initialized (vulnerable).\");\n}\n\ntypedef struct {\n    uint8_t mode;\n    uint8_t param_idx;\n    uint16_t new_val;\n} RemoteUpdateCommand_Vulnerable;\n\nRemoteUpdateCommand_Vulnerable getRemoteUpdateCommand_vulnerable() {\n    RemoteUpdateCommand_Vulnerable cmd;\n    cmd.mode = MODE_ECO;\n    cmd.param_idx = 5; \n    cmd.new_val = 0xDEAD;\n    return cmd;\n}\n\nvoid processRemoteParameterUpdate_vulnerable() {\n    RemoteUpdateCommand_Vulnerable cmd = getRemoteUpdateCommand_vulnerable();\n\n    if (cmd.mode < MODE_COUNT) {\n        if (cmd.param_idx < MAX_PARAMS_PER_MODE) {\n            if (g_vehicleModeParameters[cmd.mode][cmd.param_idx].configurable) {\n                g_vehicleModeParameters[cmd.mode][cmd.param_idx].value = cmd.new_val;\n                vehicle_log_vulnerable(\"Vehicle parameter updated successfully (vulnerable).\");\n            } else {\n                vehicle_log_vulnerable(\"Attempted to update non-configurable parameter (vulnerable).\");\n            }\n        } else {\n            vehicle_log_vulnerable(\"Parameter index out of global array bounds (vulnerable).\");\n        }\n    } else {\n        vehicle_log_vulnerable(\"Invalid vehicle mode ID (vulnerable).\");\n    }\n}\n\nvoid main_vulnerable_system() {\n    initializeVehicleParameters_vulnerable();\n    processRemoteParameterUpdate_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n\n#define NUM_SENSOR_GROUPS 5\n#define MAX_PARAMETERS_PER_GROUP 10\n\ntypedef struct {\n    uint16_t parameter_values[MAX_PARAMETERS_PER_GROUP];\n    uint32_t last_update_timestamp;\n    uint8_t  status_flags;\n} SensorGroupData;\n\nstatic SensorGroupData g_sensorData_vulnerable[NUM_SENSOR_GROUPS];\n\ntypedef struct {\n    uint8_t  sensor_group_id;\n    uint8_t  parameter_index;\n    uint16_t new_value;\n} TelemetryUpdateCommand_vulnerable;\n\nvoid logTelemetryError_vulnerable(const char* msg) {\n}\n\nvoid initializeTelemetrySystem_vulnerable() {\n    for (int i = 0; i < NUM_SENSOR_GROUPS; ++i) {\n        for (int j = 0; j < MAX_PARAMETERS_PER_GROUP; ++j) {\n            g_sensorData_vulnerable[i].parameter_values[j] = 0;\n        }\n        g_sensorData_vulnerable[i].last_update_timestamp = 0;\n        g_sensorData_vulnerable[i].status_flags = 0;\n    }\n}\n\nTelemetryUpdateCommand_vulnerable receiveTelemetryCommand_vulnerable() {\n    TelemetryUpdateCommand_vulnerable cmd;\n    cmd.sensor_group_id = 0;\n    cmd.parameter_index = MAX_PARAMETERS_PER_GROUP; \n    cmd.new_value = 0xDEAD;\n    return cmd;\n}\n\nvoid processTelemetryUpdate_vulnerable() {\n    TelemetryUpdateCommand_vulnerable cmd = receiveTelemetryCommand_vulnerable();\n\n    if (cmd.sensor_group_id < NUM_SENSOR_GROUPS) {\n        g_sensorData_vulnerable[cmd.sensor_group_id].parameter_values[cmd.parameter_index] = cmd.new_value;\n        g_sensorData_vulnerable[cmd.sensor_group_id].last_update_timestamp = 12345; \n        logTelemetryError_vulnerable(\"Telemetry parameter updated.\");\n    } else {\n        logTelemetryError_vulnerable(\"Invalid sensor group ID received for telemetry update.\");\n    }\n}\n\nvoid telemetrySystemMain_vulnerable() {\n    initializeTelemetrySystem_vulnerable();\n    processTelemetryUpdate_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_DTC_ENTRIES_PER_PRIORITY_LEVEL 10\n\ntypedef enum {\n    DIAG_SEVERITY_UNKNOWN = 0,\n    DIAG_SEVERITY_LOW = 1,\n    DIAG_SEVERITY_MEDIUM = 2,\n    DIAG_SEVERITY_HIGH = 3,\n    _DIAG_SEVERITY_COUNT \n} DiagnosticSeverity_Vulnerable;\n\n#define NUM_PRIORITY_LEVELS_VULNERABLE 4\n\ntypedef struct {\n    uint16_t dtc_code;\n    uint32_t timestamp;\n    uint8_t current_status;\n} DTC_Record_Vulnerable;\n\nstatic DTC_Record_Vulnerable g_dtcRecords_vulnerable[NUM_PRIORITY_LEVELS_VULNERABLE][MAX_DTC_ENTRIES_PER_PRIORITY_LEVEL];\nstatic uint8_t g_dtcCounts_vulnerable[NUM_PRIORITY_LEVELS_VULNERABLE];\n\nvoid logECU_vulnerable(const char* msg) {\n    fprintf(stderr, \"VULNERABLE_LOG: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint16_t id;\n    DiagnosticSeverity_Vulnerable severity_raw;\n    uint32_t data;\n} IncomingDiagnosticMessage_Vulnerable;\n\nIncomingDiagnosticMessage_Vulnerable receiveDiagnosticMessage_vulnerable() {\n    IncomingDiagnosticMessage_Vulnerable msg;\n    msg.id = 0xDEAD;\n    msg.severity_raw = (DiagnosticSeverity_Vulnerable)_DIAG_SEVERITY_COUNT; \n    msg.data = 0xCAFEBABE;\n    return msg;\n}\n\nvoid processDiagnosticMessage_vulnerable() {\n    IncomingDiagnosticMessage_Vulnerable msg = receiveDiagnosticMessage_vulnerable();\n\n    DiagnosticSeverity_Vulnerable effective_severity_idx = msg.severity_raw;\n\n    if (g_dtcCounts_vulnerable[effective_severity_idx] < MAX_DTC_ENTRIES_PER_PRIORITY_LEVEL) {\n        DTC_Record_Vulnerable new_record;\n        new_record.dtc_code = msg.id;\n        new_record.timestamp = msg.data;\n        new_record.current_status = 1;\n\n        g_dtcRecords_vulnerable[effective_severity_idx][g_dtcCounts_vulnerable[effective_severity_idx]] = new_record;\n        g_dtcCounts_vulnerable[effective_severity_idx]++;\n        logECU_vulnerable(\"DTC record added based on severity.\");\n    } else {\n        logECU_vulnerable(\"DTC storage full for this severity level.\");\n    }\n}\n\nvoid diagnosticSubsystemInit_vulnerable() {\n    for (int i = 0; i < NUM_PRIORITY_LEVELS_VULNERABLE; ++i) {\n        g_dtcCounts_vulnerable[i] = 0;\n        for (int j = 0; j < MAX_DTC_ENTRIES_PER_PRIORITY_LEVEL; ++j) {\n            g_dtcRecords_vulnerable[i][j] = (DTC_Record_Vulnerable){0, 0, 0};\n        }\n    }\n    logECU_vulnerable(\"Diagnostic subsystem initialized (vulnerable).\");\n}\n\nvoid runECUDiagnostics_vulnerable() {\n    diagnosticSubsystemInit_vulnerable();\n    processDiagnosticMessage_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_BUFFER_SIZE 256\n#define MAX_PAYLOAD_PER_EVENT 64 \n\nstatic uint8_t g_telemetryCircularBuffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_writeIndex = 0; \nstatic uint16_t g_dataLength = 0; \n\ntypedef struct {\n    uint16_t timestamp;   \n    uint8_t event_id;     \n    uint8_t payload_len;  \n} TelemetryEventHeader;\n\nvoid initTelemetryBuffer() {\n    memset(g_telemetryCircularBuffer, 0, TELEMETRY_BUFFER_SIZE);\n    g_writeIndex = 0;\n    g_dataLength = 0;\n}\n\nint addTelemetryEvent(const uint8_t* event_data, uint16_t data_len) {\n    if (event_data == NULL || data_len < sizeof(TelemetryEventHeader)) {\n        return -1; \n    }\n\n    uint16_t received_timestamp = (event_data[0] << 8) | event_data[1];\n    uint8_t received_event_id = event_data[2];\n    uint8_t received_payload_len = event_data[3];\n\n    uint16_t total_event_size = sizeof(TelemetryEventHeader) + received_payload_len;\n\n    if (received_payload_len > MAX_PAYLOAD_PER_EVENT) {\n        return -2; \n    }\n\n    if (total_event_size != data_len) {\n        return -3; \n    }\n\n    for (uint16_t i = 0; i < total_event_size; ++i) {\n        g_telemetryCircularBuffer[g_writeIndex + i] = event_data[i]; \n    }\n\n    g_writeIndex = (g_writeIndex + total_event_size) % TELEMETRY_BUFFER_SIZE;\n\n    g_dataLength += total_event_size;\n    if (g_dataLength > TELEMETRY_BUFFER_SIZE) {\n        g_dataLength = TELEMETRY_BUFFER_SIZE; \n    }\n\n    return 0; \n}\n\nvoid receiveTelemetryData(const uint8_t* data, uint16_t len) {\n    addTelemetryEvent(data, len);\n}\n\nuint8_t getTelemetryByte(uint16_t index) {\n    if (index < TELEMETRY_BUFFER_SIZE) {\n        return g_telemetryCircularBuffer[index];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n#include <stdbool.h>\n\nvoid automotiveLog_vulnerable(const char* msg) {\n}\n\n#define NUM_SENSOR_CHANNELS_VULNERABLE 3\n#define MAX_PROCESSING_STEPS_PER_CHANNEL_VULNERABLE 8\n\ntypedef enum {\n    SENSOR_CHANNEL_ENGINE_TEMP_VULNERABLE = 0,\n    SENSOR_CHANNEL_BRAKE_PRESSURE_VULNERABLE,\n    SENSOR_CHANNEL_STEERING_ANGLE_VULNERABLE,\n    SENSOR_CHANNEL_COUNT_VULNERABLE\n} SensorChannelID_vulnerable;\n\ntypedef float (*SensorProcessor_vulnerable)(float);\n\nfloat process_identity_vulnerable(float val) {\n    automotiveLog_vulnerable(\"  Identity processing.\");\n    return val;\n}\n\nfloat process_filter_vulnerable(float val) {\n    automotiveLog_vulnerable(\"  Filtering data.\");\n    return val * 0.95f;\n}\n\nfloat process_calibrate_vulnerable(float val) {\n    automotiveLog_vulnerable(\"  Calibrating data.\");\n    return val + 10.0f;\n}\n\nfloat process_transform_vulnerable(float val) {\n    automotiveLog_vulnerable(\"  Transforming data.\");\n    return val * 2.0f - 5.0f;\n}\n\nfloat process_security_critical_vulnerable(float val) {\n    automotiveLog_vulnerable(\"  WARNING: Executed security-critical dummy function!\");\n    return val;\n}\n\ntypedef struct {\n    SensorProcessor_vulnerable steps_vulnerable[MAX_PROCESSING_STEPS_PER_CHANNEL_VULNERABLE];\n    uint8_t num_active_steps_vulnerable;\n} ProcessingPipeline_vulnerable;\n\nstatic ProcessingPipeline_vulnerable g_sensorPipelines_vulnerable[SENSOR_CHANNEL_COUNT_VULNERABLE];\n\ntypedef struct {\n    SensorChannelID_vulnerable channel_id_vulnerable;\n    uint8_t step_index_vulnerable;\n    float input_value_vulnerable;\n} SensorProcessCommand_vulnerable;\n\nSensorProcessCommand_vulnerable receiveSensorProcessCommand_vulnerable() {\n    SensorProcessCommand_vulnerable cmd;\n    cmd.channel_id_vulnerable = SENSOR_CHANNEL_BRAKE_PRESSURE_VULNERABLE;\n    cmd.step_index_vulnerable = 5;\n    cmd.input_value_vulnerable = 50.5f;\n    return cmd;\n}\n\nvoid initializeSensorPipelines_vulnerable() {\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_ENGINE_TEMP_VULNERABLE].steps_vulnerable[0] = process_filter_vulnerable;\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_ENGINE_TEMP_VULNERABLE].steps_vulnerable[1] = process_calibrate_vulnerable;\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_ENGINE_TEMP_VULNERABLE].num_active_steps_vulnerable = 2;\n\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_BRAKE_PRESSURE_VULNERABLE].steps_vulnerable[0] = process_identity_vulnerable;\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_BRAKE_PRESSURE_VULNERABLE].steps_vulnerable[1] = process_filter_vulnerable;\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_BRAKE_PRESSURE_VULNERABLE].num_active_steps_vulnerable = 2;\n\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_STEERING_ANGLE_VULNERABLE].steps_vulnerable[0] = process_calibrate_vulnerable;\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_STEERING_ANGLE_VULNERABLE].steps_vulnerable[1] = process_transform_vulnerable;\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_STEERING_ANGLE_VULNERABLE].steps_vulnerable[2] = process_filter_vulnerable;\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_STEERING_ANGLE_VULNERABLE].num_active_steps_vulnerable = 3;\n\n    for (int i = 0; i < NUM_SENSOR_CHANNELS_VULNERABLE; ++i) {\n        for (int j = g_sensorPipelines_vulnerable[i].num_active_steps_vulnerable; j < MAX_PROCESSING_STEPS_PER_CHANNEL_VULNERABLE; ++j) {\n            g_sensorPipelines_vulnerable[i].steps_vulnerable[j] = process_identity_vulnerable;\n        }\n    }\n\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_BRAKE_PRESSURE_VULNERABLE].steps_vulnerable[5] = process_security_critical_vulnerable;\n\n    automotiveLog_vulnerable(\"Sensor processing pipelines initialized (vulnerable).\");\n}\n\nvoid executeSensorProcessingStep_vulnerable(SensorProcessCommand_vulnerable cmd) {\n    automotiveLog_vulnerable(\"Attempting to execute sensor processing step (vulnerable).\");\n\n    if (cmd.channel_id_vulnerable >= SENSOR_CHANNEL_COUNT_VULNERABLE) {\n        automotiveLog_vulnerable(\"Error: Invalid sensor channel ID received.\");\n        return;\n    }\n\n    if (cmd.step_index_vulnerable < MAX_PROCESSING_STEPS_PER_CHANNEL_VULNERABLE) {\n        SensorProcessor_vulnerable processor_func = g_sensorPipelines_vulnerable[cmd.channel_id_vulnerable].steps_vulnerable[cmd.step_index_vulnerable];\n        \n        float result = processor_func(cmd.input_value_vulnerable);\n        (void)result;\n        automotiveLog_vulnerable(\"Sensor processing step executed.\");\n    } else {\n        automotiveLog_vulnerable(\"Error: Requested step index out of global bounds.\");\n    }\n}\n\nvoid automotiveSensorProcessingUnit_vulnerable_main() {\n    initializeSensorPipelines_vulnerable();\n    SensorProcessCommand_vulnerable command = receiveSensorProcessCommand_vulnerable();\n    executeSensorProcessingStep_vulnerable(command);\n    automotiveLog_vulnerable(\"Vulnerable sensor processing unit finished.\");\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#define MAX_SENSORS 128\n\ntypedef struct {\n    unsigned int timestamp;\n    int value;\n    unsigned char status;\n} SensorReading;\n\ntypedef struct {\n    unsigned int sensor_id;\n    unsigned int new_timestamp;\n    int new_value;\n    unsigned char new_status;\n} SensorUpdateCommand;\n\nstatic SensorReading g_sensorReadings[MAX_SENSORS];\n\nSensorUpdateCommand receiveSensorUpdateCommand_fixed() {\n    SensorUpdateCommand cmd;\n    cmd.sensor_id = 128;\n    cmd.new_timestamp = 1678886400;\n    cmd.new_value = 2500;\n    cmd.new_status = 0x01;\n    return cmd;\n}\n\nvoid logErrorEvent(const char* msg) {\n}\n\nvoid processSensorUpdate_fixed() {\n    SensorUpdateCommand cmd = receiveSensorUpdateCommand_fixed();\n\n    if (cmd.sensor_id < MAX_SENSORS) {\n        g_sensorReadings[cmd.sensor_id].timestamp = cmd.new_timestamp;\n        g_sensorReadings[cmd.sensor_id].value = cmd.new_value;\n        g_sensorReadings[cmd.sensor_id].status = cmd.new_status;\n    } else {\n        logErrorEvent(\"Received sensor update with out-of-bounds sensor ID. Ignoring command.\");\n    }\n}\n\nvoid initializeSensorData_fixed() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        g_sensorReadings[i].timestamp = 0;\n        g_sensorReadings[i].value = 0;\n        g_sensorReadings[i].status = 0;\n    }\n}\n\nvoid sensorDataHandlerMain_fixed() {\n    initializeSensorData_fixed();\n    processSensorUpdate_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CONFIG_MEMORY_SIZE 512\n#define CONFIG_BLOCK_DATA_SIZE 26\n#define CONFIG_BLOCK_HEADER_SIZE 4\n#define CONFIG_BLOCK_CHECKSUM_SIZE 2\n#define CONFIG_BLOCK_SIZE (CONFIG_BLOCK_HEADER_SIZE + CONFIG_BLOCK_DATA_SIZE + CONFIG_BLOCK_CHECKSUM_SIZE)\n\n#define CONFIG_BLOCK_ID_OFFSET 0\n#define CONFIG_BLOCK_STATUS_OFFSET 2\n#define CONFIG_BLOCK_DATA_OFFSET 4\n#define CONFIG_BLOCK_DATA_MAX_LEN (CONFIG_BLOCK_SIZE - CONFIG_BLOCK_HEADER_SIZE - CONFIG_BLOCK_CHECKSUM_SIZE)\n#define CONFIG_BLOCK_CHECKSUM_OFFSET (CONFIG_BLOCK_SIZE - CONFIG_BLOCK_CHECKSUM_SIZE)\n\n#define MAX_CONFIG_BLOCKS (CONFIG_MEMORY_SIZE / CONFIG_BLOCK_SIZE)\n\nstatic uint8_t g_config_bank[CONFIG_MEMORY_SIZE];\nstatic bool g_block_in_use[MAX_CONFIG_BLOCKS];\n\nvoid init_config_manager() {\n    memset(g_config_bank, 0xFF, CONFIG_MEMORY_SIZE);\n    for (uint16_t i = 0; i < MAX_CONFIG_BLOCKS; ++i) {\n        g_block_in_use[i] = false;\n    }\n}\n\nbool allocate_config_block(uint16_t block_id, uint8_t initial_status) {\n    if (block_id >= MAX_CONFIG_BLOCKS || g_block_in_use[block_id]) {\n        return false;\n    }\n    uint16_t block_start_offset = block_id * CONFIG_BLOCK_SIZE;\n    if (block_start_offset + CONFIG_BLOCK_SIZE > CONFIG_MEMORY_SIZE) {\n        return false;\n    }\n    g_block_in_use[block_id] = true;\n    *(uint16_t*)(g_config_bank + block_start_offset + CONFIG_BLOCK_ID_OFFSET) = block_id;\n    g_config_bank[block_start_offset + CONFIG_BLOCK_STATUS_OFFSET] = initial_status;\n    memset(g_config_bank + block_start_offset + CONFIG_BLOCK_DATA_OFFSET, 0, CONFIG_BLOCK_DATA_MAX_LEN);\n    *(uint16_t*)(g_config_bank + block_start_offset + CONFIG_BLOCK_CHECKSUM_OFFSET) = 0;\n    return true;\n}\n\nbool write_config_data(uint16_t block_id, const uint8_t* data, uint8_t data_len) {\n    if (block_id >= MAX_CONFIG_BLOCKS || !g_block_in_use[block_id] || data_len > CONFIG_BLOCK_DATA_MAX_LEN) {\n        return false;\n    }\n    uint16_t data_start_offset = block_id * CONFIG_BLOCK_SIZE + CONFIG_BLOCK_DATA_OFFSET;\n    memcpy(g_config_bank + data_start_offset, data, data_len);\n    return true;\n}\n\nvoid update_config_checksum_vulnerable(uint16_t block_index, int16_t relative_checksum_offset, uint16_t new_checksum_value) {\n    if (block_index >= MAX_CONFIG_BLOCKS || !g_block_in_use[block_index]) {\n        return;\n    }\n\n    uint8_t* block_base_ptr = g_config_bank + (block_index * CONFIG_BLOCK_SIZE);\n\n    uint8_t* target_checksum_ptr = block_base_ptr + relative_checksum_offset;\n\n    *(uint16_t*)target_checksum_ptr = new_checksum_value;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_TRIP_SEGMENTS_FIXED 20\n#define TRIP_DATA_SIZE_BYTES_FIXED 8\n\ntypedef struct {\n    uint16_t segment_id;\n    uint32_t start_time_ms;\n    uint8_t  segment_data[TRIP_DATA_SIZE_BYTES_FIXED];\n    bool     is_valid;\n} TripSegmentFixed;\n\nstatic TripSegmentFixed g_trip_segment_buffer_fixed[MAX_TRIP_SEGMENTS_FIXED];\nstatic uint8_t g_current_segment_count_fixed = 0;\n\nvoid init_trip_logger_fixed() {\n    memset(g_trip_segment_buffer_fixed, 0, sizeof(g_trip_segment_buffer_fixed));\n    g_current_segment_count_fixed = 0;\n}\n\nbool add_trip_segment_fixed(uint16_t id, uint32_t time, const uint8_t* data, uint8_t data_len) {\n    if (g_current_segment_count_fixed >= MAX_TRIP_SEGMENTS_FIXED) {\n        return false;\n    }\n    if (data_len > TRIP_DATA_SIZE_BYTES_FIXED) {\n        data_len = TRIP_DATA_SIZE_BYTES_FIXED;\n    }\n\n    TripSegmentFixed* current_segment = &g_trip_segment_buffer_fixed[g_current_segment_count_fixed];\n    current_segment->segment_id = id;\n    current_segment->start_time_ms = time;\n    if (data) {\n        memcpy(current_segment->segment_data, data, data_len);\n    }\n    current_segment->is_valid = true;\n    g_current_segment_count_fixed++;\n    return true;\n}\n\nvoid process_active_segment_fixed(uint8_t index) {\n    if (index < g_current_segment_count_fixed && g_trip_segment_buffer_fixed[index].is_valid) {\n        volatile uint16_t id = g_trip_segment_buffer_fixed[index].segment_id;\n        (void)id;\n    }\n}\n\nvoid clear_N_latest_segments_fixed(uint8_t n_to_clear) {\n    if (g_current_segment_count_fixed == 0 || n_to_clear == 0) {\n        return;\n    }\n\n    uint8_t actual_segments_to_clear = n_to_clear;\n    if (actual_segments_to_clear > g_current_segment_count_fixed) {\n        actual_segments_to_clear = g_current_segment_count_fixed;\n    }\n\n    int32_t start_clear_idx = (int32_t)g_current_segment_count_fixed - actual_segments_to_clear;\n\n    for (int32_t i = 0; i < actual_segments_to_clear; ++i) {\n        g_trip_segment_buffer_fixed[start_clear_idx + i].is_valid = false;\n    }\n    \n    g_current_segment_count_fixed -= actual_segments_to_clear;\n\n    if (g_current_segment_count_fixed > 0) {\n        process_active_segment_fixed(0);\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n\n#define MAX_UINT32_STR_LEN (10 + 1)\n\nstruct LoggedEvent {\n    uint32_t event_id;\n    char*    parameter_str;\n    size_t   parameter_str_capacity;\n};\n\nsize_t uint32_to_string_fixed(uint32_t value, char* buffer, size_t buffer_capacity) {\n    if (!buffer || buffer_capacity == 0) {\n        return 0;\n    }\n\n    if (value == 0) {\n        if (buffer_capacity < 2) {\n            return 0;\n        }\n        buffer[0] = '0';\n        buffer[1] = '\\0';\n        return 1;\n    }\n\n    char temp_buffer[MAX_UINT32_STR_LEN];\n    int i = 0;\n    \n    uint32_t temp_val = value;\n    while (temp_val > 0) {\n        if (i >= MAX_UINT32_STR_LEN - 1) {\n            return 0;\n        }\n        temp_buffer[i++] = (temp_val % 10) + '0';\n        temp_val /= 10;\n    }\n\n    size_t len = i;\n    if (len >= buffer_capacity) {\n        return 0;\n    }\n\n    for (int j = 0; j < len; j++) {\n        buffer[j] = temp_buffer[i - 1 - j];\n    }\n    buffer[len] = '\\0';\n    return len;\n}\n\nclass DiagnosticMessageProcessorFixed {\npublic:\n    DiagnosticMessageProcessorFixed() {}\n\n    ~DiagnosticMessageProcessorFixed() {\n        clearLoggedEvents();\n    }\n\n    void clearLoggedEvents() {\n        for (auto& event : m_logged_events) {\n            if (event.parameter_str) {\n                free(event.parameter_str);\n            }\n        }\n        m_logged_events.clear();\n    }\n\n    bool logNumericEventFixed(uint32_t event_id, uint32_t numeric_value) {\n        LoggedEvent new_event;\n        new_event.event_id = event_id;\n        \n        new_event.parameter_str_capacity = MAX_UINT32_STR_LEN;\n        new_event.parameter_str = (char*)malloc(new_event.parameter_str_capacity);\n        if (!new_event.parameter_str && new_event.parameter_str_capacity > 0) {\n            return false;\n        }\n\n        size_t actual_len = uint32_to_string_fixed(numeric_value, new_event.parameter_str, new_event.parameter_str_capacity);\n        \n        if (actual_len == 0 && numeric_value != 0) {\n            if (new_event.parameter_str) {\n                free(new_event.parameter_str);\n            }\n            return false;\n        }\n        \n        m_logged_events.push_back(new_event);\n        return true;\n    }\n\n    const std::vector<LoggedEvent>& getLoggedEvents() const {\n        return m_logged_events;\n    }\n\nprivate:\n    std::vector<LoggedEvent> m_logged_events;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define CALIBRATION_DATA_SIZE 1024\n#define MAX_CALIBRATION_PATCH_LEN 64\n\nstatic uint8_t g_vehicleCalibrationData[CALIBRATION_DATA_SIZE];\n\nvoid initCalibrationData() {\n    memset(g_vehicleCalibrationData, 0xAA, CALIBRATION_DATA_SIZE);\n}\n\nint applyCalibrationPatch(uint16_t offset, uint8_t length, const uint8_t* patch_data) {\n    if (patch_data == NULL || length == 0) {\n        return -1;\n    }\n\n    if (length > MAX_CALIBRATION_PATCH_LEN) {\n        return -2;\n    }\n\n    for (uint8_t i = 0; i < length; ++i) {\n        g_vehicleCalibrationData[offset + i] = patch_data[i];\n    }\n\n    return 0;\n}\n\nvoid receiveCalibrationCommand(uint16_t offset, uint8_t length, const uint8_t* data) {\n    applyCalibrationPatch(offset, length, data);\n}\n\nuint8_t getCalibrationByte(uint16_t index) {\n    if (index < CALIBRATION_DATA_SIZE) {\n        return g_vehicleCalibrationData[index];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_FAULT_CATEGORIES        4\n#define MAX_FAULTS_PER_CATEGORY_GLOBAL 30\n\ntypedef uint8_t FaultStatus;\n#define FAULT_STATUS_ACTIVE    0x01\n#define FAULT_STATUS_INACTIVE  0x00\n\nstatic FaultStatus g_faultStatusData[MAX_FAULT_CATEGORIES][MAX_FAULTS_PER_CATEGORY_GLOBAL];\n\nstatic const uint8_t g_actualFaultCountPerCategory[MAX_FAULT_CATEGORIES] = {\n    10,\n    25,\n    5,\n    15\n};\n\nvoid logEvent(const char* msg) {\n}\n\nuint16_t receiveDiagnosticFaultReport_vulnerable() {\n    return 0x020A;\n}\n\nvoid initializeFaultSystem_vulnerable() {\n    for (uint8_t i = 0; i < MAX_FAULT_CATEGORIES; ++i) {\n        for (uint8_t j = 0; j < MAX_FAULTS_PER_CATEGORY_GLOBAL; ++j) {\n            g_faultStatusData[i][j] = FAULT_STATUS_INACTIVE;\n        }\n    }\n    logEvent(\"Fault system initialized.\");\n}\n\nvoid updateFaultStatus_vulnerable() {\n    uint16_t reportedFaultId = receiveDiagnosticFaultReport_vulnerable();\n\n    uint8_t categoryIdx = (uint8_t)((reportedFaultId >> 8) & 0xFF);\n    uint8_t faultIdxWithinCategory = (uint8_t)(reportedFaultId & 0xFF);\n\n    if (categoryIdx < MAX_FAULT_CATEGORIES) {\n        if (faultIdxWithinCategory < MAX_FAULTS_PER_CATEGORY_GLOBAL) {\n            g_faultStatusData[categoryIdx][faultIdxWithinCategory] = FAULT_STATUS_ACTIVE;\n            logEvent(\"Fault status updated.\");\n        } else {\n            logEvent(\"Attempt to update fault with global out-of-bounds index. Ignored.\");\n        }\n    } else {\n        logEvent(\"Attempt to update fault with invalid category ID. Ignored.\");\n    }\n}\n\nvoid faultManagementModule_vulnerable() {\n    initializeFaultSystem_vulnerable();\n    updateFaultStatus_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define FIRMWARE_UPDATE_BUFFER_SIZE 1024\n#define NUM_FIRMWARE_SECTIONS 4\n\ntypedef struct {\n    uint16_t base_address;\n    uint16_t size;\n} FirmwareSectionInfo;\n\nstatic uint8_t g_firmwareUpdateBuffer[FIRMWARE_UPDATE_BUFFER_SIZE];\n\nstatic const FirmwareSectionInfo g_firmwareSections[NUM_FIRMWARE_SECTIONS] = {\n    {0, 200},\n    {200, 300},\n    {500, 100},\n    {600, 424}\n};\n\nvoid initFirmwareUpdater() {\n    memset(g_firmwareUpdateBuffer, 0xFF, FIRMWARE_UPDATE_BUFFER_SIZE);\n}\n\nint writeFirmwareBlock(uint8_t section_id, uint8_t block_offset_in_section, uint8_t block_len, const uint8_t* data_payload) {\n    if (data_payload == NULL || block_len == 0) {\n        return -1;\n    }\n\n    if (section_id >= NUM_FIRMWARE_SECTIONS) {\n        return -2;\n    }\n\n    const FirmwareSectionInfo* section = &g_firmwareSections[section_id];\n\n    uint16_t required_section_end_offset = (uint16_t)block_offset_in_section + block_len;\n\n    if (block_offset_in_section >= section->size || required_section_end_offset > section->size) {\n        return -3;\n    }\n\n    uint16_t dest_address = section->base_address + block_offset_in_section;\n\n    if ((uint32_t)dest_address + block_len > FIRMWARE_UPDATE_BUFFER_SIZE) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < block_len; ++i) {\n        g_firmwareUpdateBuffer[dest_address + i] = data_payload[i];\n    }\n\n    return 0;\n}\n\nvoid updateFirmwareSection(uint8_t section_id, uint8_t offset, uint8_t len, const uint8_t* data) {\n    if (g_firmwareUpdateBuffer[0] == 0xFF) {\n        initFirmwareUpdater();\n    }\n    writeFirmwareBlock(section_id, offset, len, data);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <algorithm>\n\ntypedef struct {\n    uint32_t offset;\n    uint16_t length;\n    uint16_t chunk_id;\n} FirmwareChunkHeader;\n\nclass FirmwareUpdaterFixed {\nprivate:\n    uint8_t* m_firmware_image_buffer;\n    size_t   m_allocated_size;\n    uint32_t m_expected_total_firmware_size;\n    bool     m_is_initialized;\n\npublic:\n    FirmwareUpdaterFixed() : m_firmware_image_buffer(nullptr), m_allocated_size(0), m_expected_total_firmware_size(0), m_is_initialized(false) {}\n\n    ~FirmwareUpdaterFixed() {\n        if (m_firmware_image_buffer) {\n            free(m_firmware_image_buffer);\n            m_firmware_image_buffer = nullptr;\n        }\n    }\n\n    bool initializeUpdater(uint32_t total_firmware_size) {\n        if (total_firmware_size == 0 || total_firmware_size > (1024U * 1024U * 10U)) {\n            return false;\n        }\n        if (m_firmware_image_buffer) {\n            free(m_firmware_image_buffer);\n        }\n        m_firmware_image_buffer = (uint8_t*)malloc(total_firmware_size);\n        if (!m_firmware_image_buffer) {\n            m_allocated_size = 0;\n            m_expected_total_firmware_size = 0;\n            m_is_initialized = false;\n            return false;\n        }\n        m_allocated_size = total_firmware_size;\n        m_expected_total_firmware_size = total_firmware_size;\n        m_is_initialized = true;\n        return true;\n    }\n\n    bool applyFirmwareChunkFixed(const uint8_t* raw_chunk_data, size_t raw_chunk_data_len) {\n        if (!m_is_initialized || !m_firmware_image_buffer || raw_chunk_data_len < sizeof(FirmwareChunkHeader)) {\n            return false;\n        }\n\n        const FirmwareChunkHeader* header = reinterpret_cast<const FirmwareChunkHeader*>(raw_chunk_data);\n\n        if (raw_chunk_data_len < (sizeof(FirmwareChunkHeader) + header->length)) {\n            return false;\n        }\n\n        if (static_cast<size_t>(header->offset) >= m_allocated_size) {\n            return false;\n        }\n        if (header->length > (m_allocated_size - static_cast<size_t>(header->offset))) {\n            return false;\n        }\n\n        const uint8_t* chunk_payload_start = raw_chunk_data + sizeof(FirmwareChunkHeader);\n\n        for (uint16_t i = 0; i < header->length; ++i) {\n            m_firmware_image_buffer[header->offset + i] = chunk_payload_start[i];\n        }\n\n        return true;\n    }\n\n    const uint8_t* getFirmwareBuffer() const {\n        return m_firmware_image_buffer;\n    }\n\n    size_t getAllocatedSize() const {\n        return m_allocated_size;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <new>\n\nstruct DiagnosticLogEntry {\n    uint32_t timestamp;\n    uint16_t event_code;\n    char*    description;\n    size_t   description_buffer_capacity;\n};\n\nstruct LogBatchPacketHeader {\n    uint16_t num_messages;\n    uint16_t global_max_description_len;\n    uint32_t total_payload_bytes;\n};\n\nstruct IndividualMessageData {\n    uint32_t timestamp;\n    uint16_t event_code;\n    uint16_t actual_description_len;\n};\n\nclass DiagnosticLogger {\npublic:\n    DiagnosticLogger() = default;\n\n    ~DiagnosticLogger() {\n        clearLogEntries();\n    }\n\n    void clearLogEntries() {\n        for (auto& entry : m_log_entries) {\n            if (entry.description) {\n                delete[] entry.description;\n            }\n        }\n        m_log_entries.clear();\n    }\n\n    bool processLogBatchVulnerable(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(LogBatchPacketHeader)) {\n            return false;\n        }\n\n        const LogBatchPacketHeader* header = reinterpret_cast<const LogBatchPacketHeader*>(packet_data);\n\n        if (header->total_payload_bytes > (packet_length - sizeof(LogBatchPacketHeader))) {\n            return false;\n        }\n\n        clearLogEntries();\n\n        const uint8_t* current_payload_ptr = packet_data + sizeof(LogBatchPacketHeader);\n        size_t remaining_payload_data = header->total_payload_bytes;\n\n        for (uint16_t i = 0; i < header->num_messages; ++i) {\n            if (remaining_payload_data < sizeof(IndividualMessageData)) {\n                return false;\n            }\n\n            const IndividualMessageData* msg_header = reinterpret_cast<const IndividualMessageData*>(current_payload_ptr);\n            \n            size_t alloc_size_for_description = header->global_max_description_len + 1;\n            if (alloc_size_for_description == 0) {\n                 alloc_size_for_description = 1;\n            }\n            \n            DiagnosticLogEntry new_entry;\n            new_entry.timestamp = msg_header->timestamp;\n            new_entry.event_code = msg_header->event_code;\n            new_entry.description = new (std::nothrow) char[alloc_size_for_description];\n            new_entry.description_buffer_capacity = alloc_size_for_description;\n\n            if (!new_entry.description) {\n                clearLogEntries();\n                return false;\n            }\n\n            current_payload_ptr += sizeof(IndividualMessageData);\n            remaining_payload_data -= sizeof(IndividualMessageData);\n\n            if (remaining_payload_data < msg_header->actual_description_len) {\n                delete[] new_entry.description;\n                return false;\n            }\n            \n            for (uint16_t k = 0; k < msg_header->actual_description_len; ++k) {\n                new_entry.description[k] = static_cast<char>(current_payload_ptr[k]);\n            }\n            new_entry.description[msg_header->actual_description_len] = '\\0';\n\n            current_payload_ptr += msg_header->actual_description_len;\n            remaining_payload_data -= msg_header->actual_description_len;\n\n            m_log_entries.push_back(new_entry);\n        }\n\n        return true;\n    }\n\n    const std::vector<DiagnosticLogEntry>& getLogEntries() const {\n        return m_log_entries;\n    }\n\nprivate:\n    std::vector<DiagnosticLogEntry> m_log_entries;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t data_len;\n} LogEntryHeader;\n\nclass CircularLogBufferFixed {\npublic:\n    CircularLogBufferFixed(size_t capacity) :\n        m_buffer(nullptr),\n        m_capacity(capacity),\n        m_write_pos(0)\n    {\n        if (m_capacity > 0) {\n            m_buffer = (uint8_t*)malloc(m_capacity);\n        }\n    }\n\n    ~CircularLogBufferFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    bool appendEntryFixed(const uint8_t* entry_data, size_t data_packet_len) {\n        if (!entry_data || data_packet_len < sizeof(LogEntryHeader)) {\n            return false;\n        }\n\n        const LogEntryHeader* header = reinterpret_cast<const LogEntryHeader*>(entry_data);\n        uint16_t payload_len = header->data_len;\n\n        static const uint16_t MAX_ALLOWED_PAYLOAD_LEN = 2048;\n        if (payload_len > MAX_ALLOWED_PAYLOAD_LEN) {\n            return false;\n        }\n        \n        size_t total_entry_size = sizeof(LogEntryHeader) + payload_len;\n\n        if (total_entry_size > m_capacity) {\n            return false;\n        }\n\n        if (data_packet_len < total_entry_size) {\n            return false;\n        }\n        \n        if (m_write_pos + total_entry_size > m_capacity) {\n            m_write_pos = 0;\n        }\n        \n        if (!m_buffer) {\n            return false;\n        }\n\n        for (size_t i = 0; i < total_entry_size; ++i) {\n            m_buffer[m_write_pos + i] = entry_data[i];\n        }\n\n        m_write_pos = (m_write_pos + total_entry_size) % m_capacity;\n\n        return true;\n    }\n\n    size_t getCurrentWritePosition() const {\n        return m_write_pos;\n    }\n\n    size_t getBufferCapacity() const {\n        return m_capacity;\n    }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_capacity;\n    size_t m_write_pos;\n};\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DATA_BUFFER_SIZE 128\n#define MIN_DATA_AREA_START 16 // Start of actual data after some header/metadata\n\nstatic uint8_t g_data_buffer[DATA_BUFFER_SIZE];\nstatic int16_t g_cursor_pos = MIN_DATA_AREA_START; // Current write position, initialized to start of data area\n\nvoid init_data_processor() {\n    memset(g_data_buffer, 0x00, DATA_BUFFER_SIZE);\n    // Initialize some header bytes that must not be overwritten\n    g_data_buffer[0] = 0xAA; // Magic byte\n    g_data_buffer[1] = 0x55; // Version byte\n    // ... (other header bytes up to MIN_DATA_AREA_START - 1)\n    g_cursor_pos = MIN_DATA_AREA_START;\n}\n\n// Simulates adding data to the buffer, moving the cursor forward\nvoid add_processed_data(const uint8_t* data, uint8_t len) {\n    if (g_cursor_pos + len <= DATA_BUFFER_SIZE) {\n        memcpy(&g_data_buffer[g_cursor_pos], data, len);\n        g_cursor_pos += len;\n    }\n}\n\n// Vulnerable function: Moves the cursor backward by 'steps' bytes\n// and attempts to \"invalidate\" the byte immediately preceding the new cursor position.\n// If 'steps' is large enough, 'g_cursor_pos' can become less than MIN_DATA_AREA_START,\n// causing 'temp_cursor_pos - 1' to underwrite into the header/metadata area (index < MIN_DATA_AREA_START)\n// or even before the start of the buffer (index < 0).\nvoid rollback_data_state_vulnerable(uint16_t steps) {\n    if (g_cursor_pos <= MIN_DATA_AREA_START) {\n        // No data to roll back or already at the beginning of the data area\n        return;\n    }\n\n    int16_t temp_cursor_pos = g_cursor_pos;\n\n    // Calculate the new cursor position\n    temp_cursor_pos -= steps;\n\n    // Update global cursor (potentially now negative or inside header area)\n    g_cursor_pos = temp_cursor_pos;\n\n    // Attempt to \"invalidate\" the byte immediately preceding the new cursor position.\n    // This is the vulnerable write. If temp_cursor_pos becomes 0, then temp_cursor_pos - 1 is -1,\n    // leading to a buffer underwrite. If temp_cursor_pos is positive but < MIN_DATA_AREA_START,\n    // it writes into the protected header area, which is also an underwrite relative to the data segment.\n    g_data_buffer[temp_cursor_pos - 1] = 0x00; // Invalidate previous byte\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_COMMAND_PACKET_SIZE 512\n#define VEHICLE_STATUS_BUFFER_SIZE 128\n#define COMMAND_HEADER_SIZE (sizeof(uint16_t) * 2)\n\nstatic uint8_t g_vehicleStatusData[VEHICLE_STATUS_BUFFER_SIZE];\n\nvoid initializeVehicleStatus() {\n    memset(g_vehicleStatusData, 0, VEHICLE_STATUS_BUFFER_SIZE);\n}\n\nint processStatusUpdatePayload(uint8_t target_offset, const uint8_t* source_data_ptr, uint16_t data_to_copy_len) {\n    if (source_data_ptr == NULL || data_to_copy_len == 0) {\n        return -1;\n    }\n\n    if (target_offset >= VEHICLE_STATUS_BUFFER_SIZE) {\n        return -3;\n    }\n\n    for (uint16_t i = 0; i < data_to_copy_len; ++i) {\n        g_vehicleStatusData[target_offset + i] = source_data_ptr[i];\n    }\n\n    return 0;\n}\n\nint handleVehicleCommandPacket(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len < COMMAND_HEADER_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_read_offset = 0;\n\n    while (current_read_offset + COMMAND_HEADER_SIZE <= packet_len) {\n        uint16_t cmd_id = (packet_data[current_read_offset] << 8) | packet_data[current_read_offset + 1];\n        uint16_t cmd_payload_len = (packet_data[current_read_offset + 2] << 8) | packet_data[current_read_offset + 3];\n        current_read_offset += COMMAND_HEADER_SIZE;\n\n        if (cmd_payload_len > (packet_len - current_read_offset)) {\n            return -2;\n        }\n\n        const uint8_t* command_payload_data_ptr = packet_data + current_read_offset;\n\n        if (cmd_id == 0x0101) {\n            if (cmd_payload_len >= 1) {\n                uint8_t target_offset = command_payload_data_ptr[0];\n                const uint8_t* data_to_copy_ptr = command_payload_data_ptr + 1;\n                uint16_t actual_data_len = cmd_payload_len - 1;\n\n                int res = processStatusUpdatePayload(target_offset, data_to_copy_ptr, actual_data_len);\n                if (res != 0) {\n                    return res;\n                }\n            }\n        }\n        \n        current_read_offset += cmd_payload_len;\n    }\n    return 0;\n}\n\nuint8_t getVehicleStatusByte(uint8_t index) {\n    if (index < VEHICLE_STATUS_BUFFER_SIZE) {\n        return g_vehicleStatusData[index];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DATA_LOG_BUFFER_SIZE 256\n#define MAX_LOG_ENTRY_PAYLOAD_SIZE 60\n\ntypedef struct {\n    uint8_t  type;\n    uint8_t  payload_len;\n} LogEntryHeader;\n\nstatic uint8_t g_logBuffer[DATA_LOG_BUFFER_SIZE];\nstatic uint16_t g_logBufferWriteHead = 0;\n\nvoid initDataLogger() {\n    memset(g_logBuffer, 0, DATA_LOG_BUFFER_SIZE);\n    g_logBufferWriteHead = 0;\n}\n\nint addLogEntry(uint8_t type, const uint8_t* payload_data, uint8_t payload_len) {\n    if (payload_data == NULL) {\n        return -1;\n    }\n\n    if (payload_len > MAX_LOG_ENTRY_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    uint16_t required_total_entry_size = sizeof(LogEntryHeader) + payload_len;\n\n    if (required_total_entry_size > DATA_LOG_BUFFER_SIZE) {\n        return -3;\n    }\n\n    // Construct the header\n    LogEntryHeader header = { .type = type, .payload_len = payload_len };\n\n    // Write header to current position\n    memcpy(g_logBuffer + g_logBufferWriteHead, &header, sizeof(LogEntryHeader));\n    uint16_t current_entry_payload_offset = g_logBufferWriteHead + sizeof(LogEntryHeader);\n\n    // Write payload data following the header\n    // VULNERABILITY: If current_entry_payload_offset + payload_len extends beyond DATA_LOG_BUFFER_SIZE,\n    // this memcpy will write out-of-bounds, even though the total required_total_entry_size fits\n    // into the conceptual circular buffer space. The single memcpy doesn't handle wrapping.\n    memcpy(g_logBuffer + current_entry_payload_offset, payload_data, payload_len);\n\n    // Update write head for the next entry, correctly handling circular buffer logic\n    g_logBufferWriteHead = (g_logBufferWriteHead + required_total_entry_size) % DATA_LOG_BUFFER_SIZE;\n\n    return 0;\n}\n\n// Dummy function to simulate usage in a larger context (e.g., error handling)\nvoid simulateSensorDTCLog(uint8_t dtc_code, const uint8_t* dtc_data, uint8_t data_len) {\n    // In a real scenario, dtc_data might contain additional diagnostic info\n    // The dtc_code itself could be part of the payload or processed separately.\n    // Here, we just pass the raw data.\n    addLogEntry(dtc_code, dtc_data, data_len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\n// Max theoretical size for a decoded data block to prevent extreme allocation.\n#define MAX_DECODED_BLOCK_SIZE 65536 // 64KB\n\n// Represents the header for an incoming telemetry data block\nstruct TelemetryBlockHeaderFixed {\n    uint16_t block_id;\n    uint16_t num_entries;\n    uint32_t total_decoded_size; // Advertised total size of ALL decoded data entries in this block\n};\n\n// Represents the header for an individual entry within the block\nstruct TelemetryEntryHeaderFixed {\n    uint8_t  entry_type;\n    uint16_t encoded_data_length; // Length of the *encoded* data that follows this header\n};\n\nenum TelemetryEntryTypeFixed : uint8_t {\n    RAW_DATA_FIXED = 0x01,\n    RLE_DATA_FIXED = 0x02\n};\n\nclass VehicleTelemetryProcessorFixed {\npublic:\n    VehicleTelemetryProcessorFixed() : m_decoded_buffer(nullptr), m_current_buffer_pos(0), m_allocated_capacity(0) {}\n\n    ~VehicleTelemetryProcessorFixed() {\n        if (m_decoded_buffer) {\n            free(m_decoded_buffer);\n        }\n    }\n\n    void resetBuffer() {\n        if (m_decoded_buffer) {\n            free(m_decoded_buffer);\n            m_decoded_buffer = nullptr;\n        }\n        m_current_buffer_pos = 0;\n        m_allocated_capacity = 0;\n    }\n\n    // Processes a raw telemetry data packet and appends decoded data to an internal buffer.\n    bool processTelemetryBlockFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(TelemetryBlockHeaderFixed)) {\n            return false;\n        }\n\n        const TelemetryBlockHeaderFixed* block_header = reinterpret_cast<const TelemetryBlockHeaderFixed*>(raw_packet);\n\n        // FIX: Calculate the *actual* maximum possible decoded size based on entries in a pre-pass.\n        size_t calculated_max_decoded_size = 0;\n        size_t current_packet_offset_for_calc = sizeof(TelemetryBlockHeaderFixed);\n\n        for (uint16_t i = 0; i < block_header->num_entries; ++i) {\n            // Ensure enough data for header itself in the packet\n            if (current_packet_offset_for_calc + sizeof(TelemetryEntryHeaderFixed) > packet_len) {\n                return false; \n            }\n            const TelemetryEntryHeaderFixed* entry_header_calc = reinterpret_cast<const TelemetryEntryHeaderFixed*>(raw_packet + current_packet_offset_for_calc);\n\n            // Ensure encoded data length does not exceed packet boundary\n            if (current_packet_offset_for_calc + sizeof(TelemetryEntryHeaderFixed) + entry_header_calc->encoded_data_length > packet_len) {\n                return false;\n            }\n            \n            size_t max_decoded_bytes_for_entry = 0;\n            if (entry_header_calc->entry_type == RAW_DATA_FIXED) {\n                max_decoded_bytes_for_entry = entry_header_calc->encoded_data_length;\n            } else if (entry_header_calc->entry_type == RLE_DATA_FIXED) {\n                // RLE: each 2 bytes (value, count) can expand to up to 255 bytes.\n                // So, encoded_data_length bytes can expand to (encoded_data_length / 2) * 255.\n                if (entry_header_calc->encoded_data_length % 2 != 0) {\n                    return false; // Malformed RLE data (odd number of bytes)\n                }\n                size_t num_rle_pairs = entry_header_calc->encoded_data_length / 2;\n                // Check for integer overflow before multiplication\n                if (num_rle_pairs > (std::numeric_limits<size_t>::max() / 255)) {\n                    return false; // Resulting size too large\n                }\n                max_decoded_bytes_for_entry = num_rle_pairs * 255;\n            } else {\n                return false; // Unknown or unsupported entry type\n            }\n\n            // Check for integer overflow when summing total calculated size\n            if (calculated_max_decoded_size > std::numeric_limits<size_t>::max() - max_decoded_bytes_for_entry) {\n                return false; // Total calculated size overflow\n            }\n            calculated_max_decoded_size += max_decoded_bytes_for_entry;\n\n            current_packet_offset_for_calc += sizeof(TelemetryEntryHeaderFixed) + entry_header_calc->encoded_data_length;\n        }\n\n        // FIX: Verify advertised total_decoded_size against the *calculated* max required size.\n        // If the advertised size is less than what's potentially needed, it's a malformed/malicious packet.\n        if (block_header->total_decoded_size < calculated_max_decoded_size) {\n            return false;\n        }\n        \n        // Final sanity check on calculated size against hard limit\n        if (calculated_max_decoded_size > MAX_DECODED_BLOCK_SIZE) {\n            return false;\n        }\n\n        // Ensure the entire packet is provided as expected (header + total encoded data bytes).\n        // `current_packet_offset_for_calc` now holds the total size of header + all encoded data.\n        if (packet_len < current_packet_offset_for_calc) {\n             return false;\n        }\n\n        // Allocate buffer based on the *calculated* maximum required size to ensure sufficient space.\n        size_t desired_alloc_size = calculated_max_decoded_size;\n        if (desired_alloc_size == 0) {\n             resetBuffer();\n             return true;\n        }\n        \n        uint8_t* new_buffer = (uint8_t*)realloc(m_decoded_buffer, desired_alloc_size);\n        if (!new_buffer) {\n            if (m_decoded_buffer) free(m_decoded_buffer);\n            m_decoded_buffer = nullptr;\n            m_current_buffer_pos = 0;\n            m_allocated_capacity = 0;\n            return false;\n        }\n        m_decoded_buffer = new_buffer;\n        m_allocated_capacity = desired_alloc_size;\n        m_current_buffer_pos = 0; // Reset position for new block processing\n\n        size_t current_packet_offset = sizeof(TelemetryBlockHeaderFixed);\n\n        for (uint16_t i = 0; i < block_header->num_entries; ++i) {\n            // These checks are implicitly handled by the initial `current_packet_offset_for_calc` checks,\n            // but are repeated here for robustness as `current_packet_offset` advances.\n            if (current_packet_offset + sizeof(TelemetryEntryHeaderFixed) > packet_len) { resetBuffer(); return false; }\n            const TelemetryEntryHeaderFixed* entry_header = reinterpret_cast<const TelemetryEntryHeaderFixed*>(raw_packet + current_packet_offset);\n            if (current_packet_offset + sizeof(TelemetryEntryHeaderFixed) + entry_header->encoded_data_length > packet_len) { resetBuffer(); return false; }\n\n            const uint8_t* entry_data_ptr = raw_packet + current_packet_offset + sizeof(TelemetryEntryHeaderFixed);\n            size_t bytes_to_read = entry_header->encoded_data_length;\n\n            switch (entry_header->entry_type) {\n                case RAW_DATA_FIXED: {\n                    // FIX: Ensure enough space before copying data.\n                    if (m_current_buffer_pos > m_allocated_capacity - bytes_to_read) {\n                        resetBuffer();\n                        return false;\n                    }\n                    std::memcpy(m_decoded_buffer + m_current_buffer_pos, entry_data_ptr, bytes_to_read);\n                    m_current_buffer_pos += bytes_to_read;\n                    break;\n                }\n                case RLE_DATA_FIXED: {\n                    size_t rle_current_read_offset = 0;\n                    while (rle_current_read_offset + 1 < bytes_to_read) { \n                        uint8_t value_to_repeat = entry_data_ptr[rle_current_read_offset];\n                        uint8_t repeat_count = entry_data_ptr[rle_current_read_offset + 1];\n\n                        // FIX: Explicitly check bounds before writing repeated bytes.\n                        // This is the critical fix for the RLE expansion vulnerability.\n                        if (m_current_buffer_pos > m_allocated_capacity - repeat_count) {\n                            resetBuffer();\n                            return false;\n                        }\n\n                        for (uint8_t k = 0; k < repeat_count; ++k) {\n                            m_decoded_buffer[m_current_buffer_pos + k] = value_to_repeat;\n                        }\n                        m_current_buffer_pos += repeat_count;\n\n                        rle_current_read_offset += 2;\n                    }\n                    break;\n                }\n                default:\n                    resetBuffer();\n                    return false;\n            }\n            current_packet_offset += sizeof(TelemetryEntryHeaderFixed) + bytes_to_read;\n        }\n\n        // Final check: ensure the total size written matches the advertised size from the header.\n        // This helps detect any inconsistencies or truncation.\n        if (m_current_buffer_pos != block_header->total_decoded_size) {\n            resetBuffer(); \n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getDecodedBuffer() const { return m_decoded_buffer; }\n    size_t getCurrentDecodedSize() const { return m_current_buffer_pos; }\n\nprivate:\n    uint8_t* m_decoded_buffer;\n    size_t   m_current_buffer_pos;\n    size_t   m_allocated_capacity;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_STATE_HISTORY_SIZE 64\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t speed_kmh;\n    uint16_t rpm;\n    uint8_t gear;\n    bool valid;\n} VehicleStateEntry;\n\nstatic VehicleStateEntry g_vehicle_state_log_fixed[VEHICLE_STATE_HISTORY_SIZE];\nstatic uint16_t g_current_log_entries_fixed = 0;\nstatic uint16_t g_next_write_idx_fixed = 0;\n\nvoid init_vehicle_state_log_fixed() {\n    memset(g_vehicle_state_log_fixed, 0, sizeof(g_vehicle_state_log_fixed));\n    g_current_log_entries_fixed = 0;\n    g_next_write_idx_fixed = 0;\n}\n\nvoid add_vehicle_state_entry_fixed(uint32_t timestamp, uint16_t speed, uint16_t rpm, uint8_t gear) {\n    g_vehicle_state_log_fixed[g_next_write_idx_fixed].timestamp = timestamp;\n    g_vehicle_state_log_fixed[g_next_write_idx_fixed].speed_kmh = speed;\n    g_vehicle_state_log_fixed[g_next_write_idx_fixed].rpm = rpm;\n    g_vehicle_state_log_fixed[g_next_write_idx_fixed].gear = gear;\n    g_vehicle_state_log_fixed[g_next_write_idx_fixed].valid = true;\n\n    g_next_write_idx_fixed = (g_next_write_idx_fixed + 1) % VEHICLE_STATE_HISTORY_SIZE;\n    if (g_current_log_entries_fixed < VEHICLE_STATE_HISTORY_SIZE) {\n        g_current_log_entries_fixed++;\n    }\n}\n\nvoid apply_historical_state_correction_fixed(uint16_t relative_offset_from_last, int16_t correction_value_speed) {\n    if (g_current_log_entries_fixed == 0) {\n        return;\n    }\n\n    if (relative_offset_from_last >= g_current_log_entries_fixed) {\n        return;\n    }\n\n    uint16_t last_valid_idx = (g_next_write_idx_fixed - 1 + VEHICLE_STATE_HISTORY_SIZE) % VEHICLE_STATE_HISTORY_SIZE;\n\n    uint16_t target_idx = (last_valid_idx - relative_offset_from_last + VEHICLE_STATE_HISTORY_SIZE) % VEHICLE_STATE_HISTORY_SIZE;\n\n    g_vehicle_state_log_fixed[target_idx].speed_kmh += correction_value_speed;\n    g_vehicle_state_log_fixed[target_idx].valid = true;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_DATA_STORAGE_SIZE 250\n\nstatic uint8_t g_diagDataStore[DIAG_DATA_STORAGE_SIZE];\n\nvoid initDiagnosticDataStore() {\n    memset(g_diagDataStore, 0, DIAG_DATA_STORAGE_SIZE);\n}\n\nint updateDiagnosticBlock(uint16_t offset, uint8_t len, const uint8_t* data) {\n    if (data == NULL || len == 0) {\n        return -1;\n    }\n\n    if (offset >= DIAG_DATA_STORAGE_SIZE) {\n        return -2;\n    }\n\n    for (uint8_t i = 0; i < len; ++i) {\n        g_diagDataStore[offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid handleDiagnosticUpdateMessage(const uint8_t* msg_raw, uint16_t msg_raw_len) {\n    if (msg_raw == NULL || msg_raw_len < 3) {\n        return;\n    }\n\n    uint16_t current_read_pos = 0;\n\n    uint16_t block_offset = (msg_raw[current_read_pos] << 8) | msg_raw[current_read_pos + 1];\n    current_read_pos += 2;\n\n    uint8_t block_len = msg_raw[current_read_pos];\n    current_read_pos += 1;\n\n    if (current_read_pos + block_len > msg_raw_len) {\n        return;\n    }\n\n    const uint8_t* payload_ptr = msg_raw + current_read_pos;\n\n    updateDiagnosticBlock(block_offset, block_len, payload_ptr);\n}\n\nuint8_t getDiagDataByte(uint16_t index) {\n    if (index < DIAG_DATA_STORAGE_SIZE) {\n        return g_diagDataStore[index];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MEMORY_POOL_SIZE 512\n#define MAX_POOL_ALLOCATIONS 16\n\nstatic uint8_t s_ecu_memory_pool[MEMORY_POOL_SIZE];\nstatic int32_t s_pool_current_offset = 0;\n\ntypedef struct {\n    int32_t offset;\n    uint16_t size;\n    bool active;\n} PoolAllocationEntry;\n\nstatic PoolAllocationEntry s_allocation_table[MAX_POOL_ALLOCATIONS];\nstatic uint8_t s_num_active_allocations = 0;\n\nvoid init_ecu_memory_pool() {\n    memset(s_ecu_memory_pool, 0, MEMORY_POOL_SIZE);\n    s_pool_current_offset = 0;\n    for (int i = 0; i < MAX_POOL_ALLOCATIONS; ++i) {\n        s_allocation_table[i].active = false;\n        s_allocation_table[i].offset = 0;\n        s_allocation_table[i].size = 0;\n    }\n    s_num_active_allocations = 0;\n}\n\nvoid* allocate_pool_block(uint16_t size) {\n    if (s_num_active_allocations >= MAX_POOL_ALLOCATIONS) {\n        return NULL;\n    }\n    if ((s_pool_current_offset + size) > MEMORY_POOL_SIZE) {\n        return NULL;\n    }\n\n    void* ptr = &s_ecu_memory_pool[s_pool_current_offset];\n    s_allocation_table[s_num_active_allocations].offset = s_pool_current_offset;\n    s_allocation_table[s_num_active_allocations].size = size;\n    s_allocation_table[s_num_active_allocations].active = true;\n    s_num_active_allocations++;\n    s_pool_current_offset += size;\n    return ptr;\n}\n\nvoid reclaim_last_pool_block_vulnerable(uint16_t size_to_reclaim) {\n    if (s_pool_current_offset == 0) {\n        return;\n    }\n\n    s_pool_current_offset -= size_to_reclaim;\n\n    s_ecu_memory_pool[s_pool_current_offset] = 0xDE;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_DIAG_LOG_BUFFER_SIZE 256\n#define DIAG_RECORD_MAX_DATA_LEN 100 \n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t flags;\n    uint8_t data_len; \n} DiagLogRecordHeader;\n\nstatic uint8_t g_diagLogBuffer[VEHICLE_DIAG_LOG_BUFFER_SIZE];\nstatic uint16_t g_logWriteCursor = 0; \n\nvoid initDiagLogger() {\n    memset(g_diagLogBuffer, 0, VEHICLE_DIAG_LOG_BUFFER_SIZE);\n    g_logWriteCursor = 0;\n}\n\nint storeDiagEvent(const uint8_t* record_payload, uint16_t payload_total_len) {\n    if (record_payload == NULL || payload_total_len < sizeof(DiagLogRecordHeader)) {\n        return -1;\n    }\n\n    uint8_t record_type = record_payload[0];\n    uint8_t flags = record_payload[1];\n    uint8_t data_len = record_payload[2];\n\n    if (data_len > DIAG_RECORD_MAX_DATA_LEN) {\n        return -2;\n    }\n    \n    uint16_t current_record_size = sizeof(DiagLogRecordHeader) + data_len;\n\n    if (payload_total_len < current_record_size) {\n        return -3;\n    }\n\n    uint16_t effective_write_pos = g_logWriteCursor;\n\n    if (effective_write_pos + current_record_size > VEHICLE_DIAG_LOG_BUFFER_SIZE) { \n        effective_write_pos = 0;\n        if (current_record_size > VEHICLE_DIAG_LOG_BUFFER_SIZE) {\n            return -4;\n        }\n    }\n\n    g_diagLogBuffer[effective_write_pos++] = record_type;\n    g_diagLogBuffer[effective_write_pos++] = flags;\n    g_diagLogBuffer[effective_write_pos++] = data_len;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_diagLogBuffer[effective_write_pos + i] = record_payload[sizeof(DiagLogRecordHeader) + i];\n    }\n\n    g_logWriteCursor = (effective_write_pos + data_len) % VEHICLE_DIAG_LOG_BUFFER_SIZE;\n\n    return 0;\n}\n\nvoid receiveNewDiagEventMessage(const uint8_t* msg, uint16_t len) {\n    if (g_logWriteCursor == 0) {\n        initDiagLogger();\n    }\n    storeDiagEvent(msg, len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdio.h>\n#include <stdint.h>\n\n#define MAX_STORED_DTCS 5\n\ntypedef struct {\n    uint16_t dtcCode;\n    uint8_t  statusByte;\n    uint32_t eventCount;\n} DTC_Entry;\n\nstatic DTC_Entry g_storedDTCs[MAX_STORED_DTCS];\nstatic uint8_t g_currentDTC_count = 3;\n\nvoid logDiagnosticError(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t queryType;\n    uint8_t dtcIndex;\n} DiagnosticQuery;\n\nDiagnosticQuery receiveDiagnosticQuery_vulnerable() {\n    DiagnosticQuery query;\n    query.queryType = 0x01;\n    query.dtcIndex = 5;\n    return query;\n}\n\nvoid initializeDTCs_vulnerable() {\n    g_storedDTCs[0] = (DTC_Entry){0xC010, 0x01, 5};\n    g_storedDTCs[1] = (DTC_Entry){0xC021, 0x0A, 2};\n    g_storedDTCs[2] = (DTC_Entry){0xC035, 0x40, 1};\n}\n\nvoid processDTCQuery_vulnerable() {\n    DiagnosticQuery query = receiveDiagnosticQuery_vulnerable();\n\n    if (query.queryType == 0x01) {\n        DTC_Entry requestedDTC = g_storedDTCs[query.dtcIndex];\n    } else {\n        logDiagnosticError(\"Unsupported diagnostic query type.\");\n    }\n}\n\nvoid main_vulnerable() {\n    initializeDTCs_vulnerable();\n    processDTCQuery_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <cstdlib>\n#include <new>\n\nstruct DiagnosticEntryHeader {\n    uint32_t timestamp;\n    uint16_t event_code;\n    uint16_t data_payload_length;\n};\n\nstruct DiagnosticStreamPacket {\n    uint32_t  stream_id;\n    uint16_t  num_entries_in_packet;\n    uint32_t  total_packet_payload_bytes;\n};\n\nclass DiagnosticLogStreamVulnerable {\npublic:\n    DiagnosticLogStreamVulnerable() : m_log_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {}\n\n    ~DiagnosticLogStreamVulnerable() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n    }\n\n    void resetStream() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n        m_current_size = 0;\n        m_allocated_capacity = 0;\n    }\n\n    bool appendDiagnosticDataVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticStreamPacket)) {\n            return false;\n        }\n\n        const DiagnosticStreamPacket* packet_header = reinterpret_cast<const DiagnosticStreamPacket*>(raw_packet);\n        \n        if (packet_len < sizeof(DiagnosticStreamPacket) + packet_header->total_packet_payload_bytes) {\n            return false;\n        }\n\n        const uint8_t* current_data_ptr = raw_packet + sizeof(DiagnosticStreamPacket);\n        size_t bytes_remaining_in_packet = packet_header->total_packet_payload_bytes;\n\n        for (uint16_t i = 0; i < packet_header->num_entries_in_packet; ++i) {\n            if (bytes_remaining_in_packet < sizeof(DiagnosticEntryHeader)) {\n                return false;\n            }\n\n            const DiagnosticEntryHeader* entry_header = reinterpret_cast<const DiagnosticEntryHeader*>(current_data_ptr);\n\n            size_t entry_total_size = sizeof(DiagnosticEntryHeader) + entry_header->data_payload_length;\n\n            if (bytes_remaining_in_packet < entry_total_size) {\n                return false;\n            }\n\n            size_t required_capacity = m_current_size + entry_total_size;\n\n            if (required_capacity > m_allocated_capacity) {\n                size_t new_capacity = m_allocated_capacity * 2;\n\n                if (new_capacity < required_capacity) {\n                    new_capacity = required_capacity;\n                }\n                \n                uint8_t* temp_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n                if (!temp_buffer) {\n                    if (m_log_buffer) {\n                        free(m_log_buffer);\n                        m_log_buffer = nullptr;\n                    }\n                    m_current_size = 0;\n                    m_allocated_capacity = 0;\n                    return false;\n                }\n                m_log_buffer = temp_buffer;\n                m_allocated_capacity = new_capacity;\n            }\n\n            for (size_t k = 0; k < sizeof(DiagnosticEntryHeader); ++k) {\n                m_log_buffer[m_current_size + k] = current_data_ptr[k];\n            }\n            m_current_size += sizeof(DiagnosticEntryHeader);\n\n            for (size_t k = 0; k < entry_header->data_payload_length; ++k) {\n                m_log_buffer[m_current_size + k] = current_data_ptr[sizeof(DiagnosticEntryHeader) + k];\n            }\n            m_current_size += entry_header->data_payload_length;\n\n            current_data_ptr += entry_total_size;\n            bytes_remaining_in_packet -= entry_total_size;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getLogBuffer() const {\n        return m_log_buffer;\n    }\n\n    size_t getCurrentSize() const {\n        return m_current_size;\n    }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_RESPONSE_BUFFER_SIZE 256\n#define MAX_DIAG_ITEMS 10\n#define DIAG_ITEM_DATA_MAX_LEN 30 \n\nstatic uint8_t g_unpackedDiagData[DIAG_RESPONSE_BUFFER_SIZE];\nstatic uint16_t g_currentUnpackedOffset = 0;\n\ntypedef struct {\n    uint16_t item_id;\n    uint8_t  item_len; \n} DiagnosticItemHeader;\n\nvoid initDiagnosticSystem() {\n    memset(g_unpackedDiagData, 0, DIAG_RESPONSE_BUFFER_SIZE);\n    g_currentUnpackedOffset = 0;\n}\n\nint processDiagResponse(const uint8_t* response_msg, uint16_t msg_len) {\n    if (response_msg == NULL || msg_len < (sizeof(uint8_t) + sizeof(uint8_t))) {\n        return -1; \n    }\n\n    uint16_t current_msg_offset = 0;\n\n    uint8_t num_items = response_msg[current_msg_offset++];\n\n    uint8_t status_flag = response_msg[current_msg_offset++];\n\n    if (num_items == 0) {\n        g_currentUnpackedOffset = 0; \n        return 0;\n    }\n\n    if (num_items > MAX_DIAG_ITEMS) {\n        return -2; \n    }\n\n    g_currentUnpackedOffset = 0;\n\n    for (uint8_t i = 0; i < num_items; ++i) {\n        if (current_msg_offset + sizeof(DiagnosticItemHeader) > msg_len) {\n            return -3; \n        }\n\n        DiagnosticItemHeader header;\n        header.item_id = (response_msg[current_msg_offset] << 8) | response_msg[current_msg_offset + 1];\n        current_msg_offset += 2; \n\n        header.item_len = response_msg[current_msg_offset++]; \n        \n        if (header.item_len > DIAG_ITEM_DATA_MAX_LEN) {\n            return -6; \n        }\n\n        if (current_msg_offset + header.item_len > msg_len) {\n            return -4; \n        }\n\n        for (uint8_t j = 0; j < header.item_len; ++j) {\n            g_unpackedDiagData[g_currentUnpackedOffset + j] = response_msg[current_msg_offset + j];\n        }\n        g_currentUnpackedOffset += header.item_len; \n        current_msg_offset += header.item_len;      \n    }\n\n    return 0;\n}\n\nvoid simulateDiagMessageReceive(const uint8_t* data, uint16_t len) {\n    initDiagnosticSystem();\n    processDiagResponse(data, len);\n}\n\nvoid triggerVulnerability() {\n    uint8_t malicious_msg[332]; \n    uint16_t offset = 0;\n\n    malicious_msg[offset++] = MAX_DIAG_ITEMS; \n    malicious_msg[offset++] = 0; \n\n    for (uint8_t i = 0; i < MAX_DIAG_ITEMS; ++i) {\n        malicious_msg[offset++] = (uint8_t)(0x0001 >> 8); \n        malicious_msg[offset++] = (uint8_t)(0x0001 & 0xFF); \n        malicious_msg[offset++] = DIAG_ITEM_DATA_MAX_LEN; \n\n        for (uint8_t j = 0; j < DIAG_ITEM_DATA_MAX_LEN; ++j) {\n            malicious_msg[offset++] = 'A'; \n        }\n    }\n\n    simulateDiagMessageReceive(malicious_msg, offset);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n// Max number of distinct sensor data types\n#define MAX_SENSORS 4\n\n// Fixed size buffer for each sensor's aggregated data\n// This is intentionally smaller than MAX_TELEMETRY_PACKET_PAYLOAD\n#define SENSOR_DATA_BUFFER_SIZE 32\n\n// Maximum payload size for an incoming telemetry packet\n// This represents the maximum data that can be carried by the communication protocol.\n#define MAX_TELEMETRY_PACKET_PAYLOAD 64\n\n// Storage for sensor data. Each sensor has its own fixed-size buffer.\nstatic uint8_t g_sensorDataBuffers[MAX_SENSORS][SENSOR_DATA_BUFFER_SIZE];\n// Current valid length for each sensor's buffer\nstatic uint8_t g_sensorDataLengths[MAX_SENSORS];\n\n// Structure representing an incoming telemetry packet\ntypedef struct {\n    uint8_t  sensor_id;  // Identifier for the sensor (0 to MAX_SENSORS-1)\n    uint16_t data_len;   // Length of the data payload in this packet\n    uint8_t  data[MAX_TELEMETRY_PACKET_PAYLOAD]; // Raw data payload\n} TelemetryPacket;\n\n// Initialize sensor data buffers to zeros and lengths to zero\nvoid initSensorDataStorage() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        memset(g_sensorDataBuffers[i], 0, SENSOR_DATA_BUFFER_SIZE);\n        g_sensorDataLengths[i] = 0;\n    }\n}\n\n// Process an incoming telemetry packet\n// This function stores the sensor data into the respective buffer based on sensor_id.\nint processTelemetryPacket(const TelemetryPacket* packet) {\n    if (packet == NULL) {\n        return -1; // Invalid packet pointer\n    }\n\n    // 1. Validate sensor ID against the maximum number of sensors\n    if (packet->sensor_id >= MAX_SENSORS) {\n        return -2; // Invalid sensor ID, out of bounds for the array of buffers\n    }\n\n    // 2. Validate incoming data length against the packet's maximum allowed payload size.\n    // This check ensures the data doesn't exceed what the packet structure can hold.\n    if (packet->data_len > MAX_TELEMETRY_PACKET_PAYLOAD) {\n        return -3; // Data length exceeds the maximum payload defined for the packet format\n    }\n\n    // FIX: Add a bounds check to ensure the incoming data length does not exceed\n    // the actual capacity of the destination buffer for the specific sensor.\n    if (packet->data_len > SENSOR_DATA_BUFFER_SIZE) {\n        // Option: Return an error indicating that the data is too large for this sensor's buffer.\n        // Alternatively, one could truncate the data, but returning an error is often safer.\n        return -4; // Data length too large for the specific sensor's buffer\n    }\n\n    memcpy(g_sensorDataBuffers[packet->sensor_id], packet->data, packet->data_len);\n    \n    // Update the stored length after successful copy.\n    g_sensorDataLengths[packet->sensor_id] = (uint8_t)packet->data_len;\n\n    return 0; // Success\n}\n\n// Dummy function to simulate receiving a raw data buffer from a communication interface.\n// In a real system, 'raw_data_buffer' would be parsed into a 'TelemetryPacket' structure.\nvoid receiveSensorData(const uint8_t* raw_data_buffer) {\n    processTelemetryPacket((const TelemetryPacket*)raw_data_buffer);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define GLOBAL_DATA_BUFFER_SIZE_FIXED 180\n#define PARAM_TYPE_COUNT_FIXED 3\n\ntypedef enum {\n    PARAM_ENGINE_TEMP_HISTORY_FIXED = 0,\n    PARAM_BATTERY_VOLTAGE_HISTORY_FIXED,\n    PARAM_TRANSMISSION_SLIP_HISTORY_FIXED,\n    PARAM_TYPE_MAX_FIXED\n} VehicleParameterType_Fixed;\n\ntypedef struct {\n    uint16_t value;\n    uint32_t timestamp;\n} ParameterEntry_Fixed;\n\nstatic uint8_t g_globalParamDataBuffer_fixed[GLOBAL_DATA_BUFFER_SIZE_FIXED];\n\ntypedef struct {\n    uint16_t start_offset_bytes;\n    uint16_t max_entries;\n    uint16_t current_entry_idx;\n} ParameterTypeConfig_Fixed;\n\nstatic ParameterTypeConfig_Fixed g_paramTypeConfigs_fixed[PARAM_TYPE_COUNT_FIXED];\n\nvoid logVehicleInfo_fixed(const char* msg) {\n}\n\nvoid logVehicleError_fixed(const char* msg) {\n}\n\nvoid initParamLogger_fixed() {\n    g_paramTypeConfigs_fixed[PARAM_ENGINE_TEMP_HISTORY_FIXED] = (ParameterTypeConfig_Fixed){\n        .start_offset_bytes = 0,\n        .max_entries = 5,\n        .current_entry_idx = 0\n    };\n\n    g_paramTypeConfigs_fixed[PARAM_BATTERY_VOLTAGE_HISTORY_FIXED] = (ParameterTypeConfig_Fixed){\n        .start_offset_bytes = g_paramTypeConfigs_fixed[PARAM_ENGINE_TEMP_HISTORY_FIXED].max_entries * sizeof(ParameterEntry_Fixed),\n        .max_entries = 5,\n        .current_entry_idx = 0\n    };\n\n    g_paramTypeConfigs_fixed[PARAM_TRANSMISSION_SLIP_HISTORY_FIXED] = (ParameterTypeConfig_Fixed){\n        .start_offset_bytes = g_paramTypeConfigs_fixed[PARAM_ENGINE_TEMP_HISTORY_FIXED].max_entries * sizeof(ParameterEntry_Fixed) +\n                              g_paramTypeConfigs_fixed[PARAM_BATTERY_VOLTAGE_HISTORY_FIXED].max_entries * sizeof(ParameterEntry_Fixed),\n        .max_entries = 5,\n        .current_entry_idx = 0\n    };\n\n    for (uint16_t i = 0; i < GLOBAL_DATA_BUFFER_SIZE_FIXED; ++i) {\n        g_globalParamDataBuffer_fixed[i] = 0;\n    }\n\n    logVehicleInfo_fixed(\"Parameter logger initialized (fixed).\");\n}\n\nvoid logParameterEntry_fixed(VehicleParameterType_Fixed type, uint16_t value, uint32_t timestamp) {\n    if (type >= PARAM_TYPE_MAX_FIXED) {\n        logVehicleError_fixed(\"Invalid parameter type for logging (fixed).\");\n        return;\n    }\n\n    ParameterTypeConfig_Fixed* config = &g_paramTypeConfigs_fixed[type];\n    ParameterEntry_Fixed new_entry = { .value = value, .timestamp = timestamp };\n\n    if (config->current_entry_idx >= config->max_entries) {\n        logVehicleError_fixed(\"Parameter history buffer full for this type. Entry dropped (fixed).\");\n        return;\n    }\n\n    uint16_t relative_offset_bytes = config->current_entry_idx * sizeof(ParameterEntry_Fixed);\n    uint16_t absolute_byte_offset = config->start_offset_bytes + relative_offset_bytes;\n\n    if (absolute_byte_offset + sizeof(ParameterEntry_Fixed) <= GLOBAL_DATA_BUFFER_SIZE_FIXED) {\n        *(ParameterEntry_Fixed*)(g_globalParamDataBuffer_fixed + absolute_byte_offset) = new_entry;\n        logVehicleInfo_fixed(\"Parameter entry logged (fixed).\");\n        config->current_entry_idx++;\n    } else {\n        logVehicleError_fixed(\"Fatal: Calculated absolute offset exceeds global buffer size (fixed).\");\n    }\n}\n\nvoid automotiveParameterLogging_fixed_main() {\n    initParamLogger_fixed();\n\n    logVehicleInfo_fixed(\"Simulating excessive ENGINE_TEMP_HISTORY logging (fixed)...\");\n    for (int i = 0; i < 7; ++i) {\n        logParameterEntry_fixed(PARAM_ENGINE_TEMP_HISTORY_FIXED, 80 + i, 0x1000 + i);\n    }\n\n    logVehicleInfo_fixed(\"Logging a BATTERY_VOLTAGE_HISTORY entry (fixed)...\");\n    logParameterEntry_fixed(PARAM_BATTERY_VOLTAGE_HISTORY_FIXED, 125, 0x2001);\n\n    logParameterEntry_fixed(PARAM_TRANSMISSION_SLIP_HISTORY_FIXED, 10, 0x3001);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_MESSAGE_TYPE_HANDLERS 10\n#define MESSAGE_DATA_SIZE 64\n\nvoid log_warning(const char* msg) {}\nvoid log_error(const char* msg) {}\n\ntypedef struct {\n    uint16_t message_id;\n    uint8_t  message_type;\n    uint8_t  sequence_num;\n    uint32_t timestamp;\n    uint8_t  data[MESSAGE_DATA_SIZE];\n    uint16_t data_len;\n} VehicleMessage;\n\ntypedef void (*MessageHandler)(const VehicleMessage*);\nstatic MessageHandler g_message_handlers_vulnerable[MAX_MESSAGE_TYPE_HANDLERS];\n\nvoid handle_engine_status(const VehicleMessage* msg) {\n    log_warning(\"Processing Engine Status message.\");\n}\n\nvoid handle_brake_status(const VehicleMessage* msg) {\n    log_warning(\"Processing Brake Status message.\");\n}\n\nvoid handle_door_status(const VehicleMessage* msg) {\n    log_warning(\"Processing Door Status message.\");\n}\n\nvoid handle_tire_pressure(const VehicleMessage* msg) {\n    log_warning(\"Processing Tire Pressure message.\");\n}\n\nvoid handle_undefined_message(const VehicleMessage* msg) {\n    log_warning(\"Processing Undefined/Reserved Message Type.\");\n}\n\nVehicleMessage receive_vehicle_message_vulnerable() {\n    VehicleMessage msg;\n    msg.message_type = MAX_MESSAGE_TYPE_HANDLERS; \n    msg.message_id = 0x1234;\n    msg.sequence_num = 1;\n    msg.timestamp = 0;\n    msg.data_len = 0;\n    return msg;\n}\n\nvoid init_message_handlers_vulnerable() {\n    g_message_handlers_vulnerable[0] = handle_engine_status;\n    g_message_handlers_vulnerable[1] = handle_brake_status;\n    g_message_handlers_vulnerable[2] = handle_door_status;\n    g_message_handlers_vulnerable[3] = handle_tire_pressure;\n    for (int i = 4; i < MAX_MESSAGE_TYPE_HANDLERS; ++i) {\n        g_message_handlers_vulnerable[i] = handle_undefined_message;\n    }\n}\n\nvoid process_incoming_vehicle_messages_vulnerable() {\n    VehicleMessage msg = receive_vehicle_message_vulnerable();\n    g_message_handlers_vulnerable[msg.message_type](&msg);\n}\n\nvoid vehicle_gateway_main_vulnerable() {\n    init_message_handlers_vulnerable();\n    process_incoming_vehicle_messages_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#define DTC_MAX_COUNT 100\n#define DIAG_CMD_GET_DTC_STATUS 0x01\n#define DTC_STATUS_INACTIVE 0x00\n#define DTC_STATUS_ACTIVE 0x01\n#define DTC_STATUS_CONFIRMED 0x03\ntypedef struct {\n    unsigned short command_id;\n    unsigned short dtc_index;\n    unsigned char  padding[4];\n} DiagnosticRequest;\ntypedef struct {\n    unsigned short command_id;\n    unsigned char  dtc_status;\n    unsigned char  response_code;\n    unsigned char  padding[3];\n} DiagnosticResponse;\nstatic unsigned char g_dtcStatus[DTC_MAX_COUNT];\nDiagnosticRequest getSimulatedDiagnosticRequest() {\n    DiagnosticRequest req;\n    req.command_id = DIAG_CMD_GET_DTC_STATUS;\n    req.dtc_index = 101;\n    req.padding[0] = req.padding[1] = req.padding[2] = req.padding[3] = 0;\n    return req;\n}\nvoid sendDiagnosticResponse(const DiagnosticResponse* res) {}\nvoid logSecurityEvent(const char* event) {}\nvoid initializeDTCStates() {\n    for (int i = 0; i < DTC_MAX_COUNT; ++i) {\n        g_dtcStatus[i] = DTC_STATUS_INACTIVE;\n    }\n    g_dtcStatus[0] = DTC_STATUS_ACTIVE;\n    g_dtcStatus[50] = DTC_STATUS_CONFIRMED;\n}\nvoid handleDiagnosticRequest() {\n    DiagnosticRequest request = getSimulatedDiagnosticRequest();\n    DiagnosticResponse response;\n    response.command_id = request.command_id;\n    response.response_code = 0x00;\n    if (request.command_id == DIAG_CMD_GET_DTC_STATUS) {\n        if (request.dtc_index < DTC_MAX_COUNT) {\n            response.dtc_status = g_dtcStatus[request.dtc_index];\n        } else {\n            response.response_code = 0x02;\n            response.dtc_status = 0x00;\n            logSecurityEvent(\"DIAG: Out-of-bounds DTC index request received. Ignoring.\");\n        }\n    } else {\n        response.response_code = 0x01;\n        response.dtc_status = 0x00;\n    }\n    sendDiagnosticResponse(&response);\n}\nvoid diagnosticModuleLoop() {\n    initializeDTCStates();\n    handleDiagnosticRequest();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_VEHICLE_PROFILES_FIXED 10\n\ntypedef struct {\n    uint16_t engine_torque_factor;\n    uint16_t transmission_shift_aggressiveness;\n    uint8_t suspension_damping_level;\n    char profile_name[32];\n} DrivingProfile_Fixed;\n\nstatic DrivingProfile_Fixed g_allVehicleProfiles_Fixed[MAX_VEHICLE_PROFILES_FIXED];\nstatic uint8_t g_configuredProfileCount_Fixed;\n\nvoid automotive_log_Fixed(const char* msg) {\n    (void)msg;\n}\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t requested_profile_id;\n    uint16_t checksum;\n} VehicleControlCommand_Fixed;\n\nVehicleControlCommand_Fixed receiveVehicleControlCommand_Fixed() {\n    VehicleControlCommand_Fixed cmd;\n    cmd.command_id = 0x01;\n    cmd.requested_profile_id = 6;\n    cmd.checksum = 0xAAAA;\n    automotive_log_Fixed(\"Simulating incoming vehicle control command.\");\n    return cmd;\n}\n\nvoid initializeVehicleProfiles_Fixed() {\n    g_configuredProfileCount_Fixed = 5;\n\n    g_allVehicleProfiles_Fixed[0] = (DrivingProfile_Fixed){100, 50, 10, \"Eco Mode\"};\n    g_allVehicleProfiles_Fixed[1] = (DrivingProfile_Fixed){120, 70, 20, \"Comfort Mode\"};\n    g_allVehicleProfiles_Fixed[2] = (DrivingProfile_Fixed){150, 90, 40, \"Normal Mode\"};\n    g_allVehicleProfiles_Fixed[3] = (DrivingProfile_Fixed){180, 110, 60, \"Sport Mode\"};\n    g_allVehicleProfiles_Fixed[4] = (DrivingProfile_Fixed){200, 130, 80, \"Race Mode\"};\n\n    automotive_log_Fixed(\"Vehicle profiles initialized for variant (fixed).\");\n}\n\nvoid activateDrivingProfile_Fixed(uint8_t profile_id) {\n    if (profile_id < g_configuredProfileCount_Fixed) {\n        DrivingProfile_Fixed active_profile = g_allVehicleProfiles_Fixed[profile_id];\n        automotive_log_Fixed(\"Successfully activated driving profile (fixed).\");\n        (void)active_profile;\n    } else {\n        automotive_log_Fixed(\"Invalid profile ID received (out of configured bounds). Ignoring command.\");\n    }\n}\n\nvoid vehicleProfileManager_main_Fixed() {\n    initializeVehicleProfiles_Fixed();\n    VehicleControlCommand_Fixed cmd = receiveVehicleControlCommand_Fixed();\n\n    if (cmd.command_id == 0x01) {\n        activateDrivingProfile_Fixed(cmd.requested_profile_id);\n    } else {\n        automotive_log_Fixed(\"Unhandled vehicle control command.\");\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_LOG_BUFFER_SIZE 4096\n#define MAX_DTC_SNAPSHOT_DATA 1024\n\ntypedef struct {\n    uint16_t dtcCode;\n    uint32_t timestamp;\n    uint16_t snapshotDataLen;\n} DiagLogEntryHeader;\n\nstatic uint8_t g_diagLogBuffer[DIAG_LOG_BUFFER_SIZE];\nstatic uint32_t g_logWritePointer = 0;\n\nvoid initDiagnosticLog() {\n    memset(g_diagLogBuffer, 0, DIAG_LOG_BUFFER_SIZE);\n    g_logWritePointer = 0;\n}\n\nint addDiagnosticEventToLog(uint16_t dtc, uint32_t timestamp, const uint8_t* snapshot_data, uint16_t snapshot_data_len) {\n    if (snapshot_data == NULL && snapshot_data_len > 0) {\n        return -1;\n    }\n\n    uint32_t entry_header_size = sizeof(DiagLogEntryHeader);\n    uint32_t entry_total_size = entry_header_size + snapshot_data_len;\n\n    if (g_logWritePointer + entry_total_size > DIAG_LOG_BUFFER_SIZE) {\n        g_logWritePointer = 0;\n    }\n\n    DiagLogEntryHeader header;\n    header.dtcCode = dtc;\n    header.timestamp = timestamp;\n    header.snapshotDataLen = snapshot_data_len;\n\n    memcpy(g_diagLogBuffer + g_logWritePointer, &header, entry_header_size);\n    g_logWritePointer += entry_header_size;\n\n    memcpy(g_diagLogBuffer + g_logWritePointer, snapshot_data, snapshot_data_len);\n    g_logWritePointer += snapshot_data_len;\n\n    return 0;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_TIRE_SENSORS 8\n#define SENSOR_DATA_HISTORY_SIZE 10\n\ntypedef struct {\n    uint16_t pressure_kPa;\n    int8_t   temperature_celsius;\n    uint8_t  battery_status;\n    bool     alarm_active;\n} TPMS_SensorData;\n\nstatic TPMS_SensorData g_tpms_sensor_data_vulnerable[MAX_TIRE_SENSORS];\n\nstatic uint8_t g_active_tire_sensors_count_vulnerable = 4;\n\nvoid log_tpms_error_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t  sensor_id;\n    uint16_t pressure;\n    int8_t   temperature;\n    uint8_t  battery;\n} TPMS_IncomingMessage_Vulnerable;\n\nTPMS_IncomingMessage_Vulnerable receive_tpms_message_vulnerable() {\n    TPMS_IncomingMessage_Vulnerable msg;\n    msg.sensor_id = 4;\n    msg.pressure = 250;\n    msg.temperature = 25;\n    msg.battery = 90;\n    return msg;\n}\n\nvoid initialize_tpms_data_vulnerable() {\n    for (uint8_t i = 0; i < MAX_TIRE_SENSORS; ++i) {\n        g_tpms_sensor_data_vulnerable[i] = (TPMS_SensorData){0, 0, 0, false};\n    }\n    for (uint8_t i = 0; i < g_active_tire_sensors_count_vulnerable; ++i) {\n        g_tpms_sensor_data_vulnerable[i].pressure_kPa = 220;\n        g_tpms_sensor_data_vulnerable[i].temperature_celsius = 20;\n        g_tpms_sensor_data_vulnerable[i].battery_status = 100;\n    }\n}\n\nvoid process_tpms_reading_vulnerable() {\n    TPMS_IncomingMessage_Vulnerable msg = receive_tpms_message_vulnerable();\n\n    if (msg.sensor_id < MAX_TIRE_SENSORS) {\n        g_tpms_sensor_data_vulnerable[msg.sensor_id].pressure_kPa = msg.pressure;\n        g_tpms_sensor_data_vulnerable[msg.sensor_id].temperature_celsius = msg.temperature;\n        g_tpms_sensor_data_vulnerable[msg.sensor_id].battery_status = msg.battery;\n        g_tpms_sensor_data_vulnerable[msg.sensor_id].alarm_active = (msg.pressure < 150 || msg.pressure > 300);\n        log_tpms_error_vulnerable(\"TPMS data updated (vulnerable).\");\n    } else {\n        log_tpms_error_vulnerable(\"Received TPMS message with out-of-bounds sensor ID. Ignoring.\");\n    }\n}\n\nvoid tpms_module_main_vulnerable() {\n    initialize_tpms_data_vulnerable();\n    process_tpms_reading_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_SENSOR_PROFILES 4\n#define SENSOR_PROFILE_BUFFER_SIZE 64\n#define MAX_CALIBRATION_PAYLOAD_SIZE 32\n\nstatic uint8_t g_sensorCalibrationProfiles[NUM_SENSOR_PROFILES][SENSOR_PROFILE_BUFFER_SIZE];\n\nvoid initSensorCalibrationProfiles() {\n    for (int i = 0; i < NUM_SENSOR_PROFILES; ++i) {\n        memset(g_sensorCalibrationProfiles[i], 0x00, SENSOR_PROFILE_BUFFER_SIZE);\n        g_sensorCalibrationProfiles[i][0] = i;\n    }\n}\n\ntypedef struct {\n    uint8_t  profile_index;\n    uint8_t  data_offset;\n    uint8_t  data_length;\n    uint8_t  payload[MAX_CALIBRATION_PAYLOAD_SIZE];\n} SensorCalibrationUpdateMsg;\n\nint applyCalibrationUpdate(const SensorCalibrationUpdateMsg* msg) {\n    if (msg == NULL) {\n        return -1;\n    }\n\n    uint8_t profile_idx = msg->profile_index;\n    uint8_t offset = msg->data_offset;\n    uint8_t length = msg->data_length;\n    const uint8_t* data = msg->payload;\n\n    if (profile_idx >= NUM_SENSOR_PROFILES) {\n        return -2;\n    }\n\n    if (length == 0 || length > MAX_CALIBRATION_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    if (offset >= SENSOR_PROFILE_BUFFER_SIZE) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < length; ++i) {\n        g_sensorCalibrationProfiles[profile_idx][offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid simulateCalibrationMessage(uint8_t p_idx, uint8_t off, uint8_t len, const uint8_t* payload_data) {\n    SensorCalibrationUpdateMsg msg;\n    msg.profile_index = p_idx;\n    msg.data_offset = off;\n    msg.data_length = len;\n    if (len > MAX_CALIBRATION_PAYLOAD_SIZE) {\n        len = MAX_CALIBRATION_PAYLOAD_SIZE; \n    }\n    for (uint8_t i = 0; i < len; ++i) {\n        msg.payload[i] = payload_data[i];\n    }\n    applyCalibrationUpdate(&msg);\n}\n\nuint8_t getCalibrationByte(uint8_t profile_idx, uint8_t offset) {\n    if (profile_idx < NUM_SENSOR_PROFILES && offset < SENSOR_PROFILE_BUFFER_SIZE) {\n        return g_sensorCalibrationProfiles[profile_idx][offset];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <numeric>\n\nstruct CommandPacketHeader {\n    uint16_t command_id;\n    uint16_t payload_length;\n    uint8_t flags;\n};\n\nstruct ProcessedCommand {\n    uint16_t command_id;\n    size_t   data_size;\n    uint8_t* data;\n};\n\nclass CommandProcessorVulnerable {\npublic:\n    CommandProcessorVulnerable() : m_processed_cmd_data(nullptr), m_allocated_size(0) {}\n\n    ~CommandProcessorVulnerable() {\n        if (m_processed_cmd_data) {\n            delete[] m_processed_cmd_data;\n            m_processed_cmd_data = nullptr;\n        }\n    }\n\n    bool processCommandVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(CommandPacketHeader)) {\n            return false;\n        }\n\n        const CommandPacketHeader* header = reinterpret_cast<const CommandPacketHeader*>(raw_packet);\n\n        static const uint16_t MAX_ALLOWED_PAYLOAD = 1024;\n        if (header->payload_length == 0 || header->payload_length > MAX_ALLOWED_PAYLOAD) {\n            return false;\n        }\n\n        if (packet_len < (sizeof(CommandPacketHeader) + header->payload_length)) {\n            return false;\n        }\n\n        if (m_processed_cmd_data) {\n            delete[] m_processed_cmd_data;\n            m_processed_cmd_data = nullptr;\n            m_allocated_size = 0;\n        }\n\n        m_processed_cmd_data = new (std::nothrow) uint8_t[header->payload_length];\n        if (!m_processed_cmd_data) {\n            return false;\n        }\n        m_allocated_size = header->payload_length;\n\n        const uint8_t* payload_src = raw_packet + sizeof(CommandPacketHeader);\n        for (uint16_t i = 0; i < header->payload_length; ++i) {\n            m_processed_cmd_data[i] = payload_src[i];\n        }\n\n        if (header->command_id == 0x101 || header->command_id == 0x202) {\n            uint8_t checksum = 0;\n            for (uint16_t i = 0; i < header->payload_length; ++i) {\n                checksum ^= m_processed_cmd_data[i];\n            }\n            m_processed_cmd_data[header->payload_length] = checksum;\n        }\n\n        m_last_processed_cmd.command_id = header->command_id;\n        m_last_processed_cmd.data_size = header->payload_length;\n        m_last_processed_cmd.data = m_processed_cmd_data;\n\n        return true;\n    }\n\n    const ProcessedCommand& getLastProcessedCommand() const {\n        return m_last_processed_cmd;\n    }\n\nprivate:\n    uint8_t* m_processed_cmd_data;\n    size_t m_allocated_size;\n    ProcessedCommand m_last_processed_cmd;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>#include <stddef.h>typedef struct {uint32_t id;uint8_t data[8];uint8_t dlc;} CanMessage;#define MAX_SUB_COMMANDS 5#define MAIN_CMD_DIAGNOSTIC_QUERY 0x10typedef void (*DiagnosticHandler)(uint16_t param1, uint16_t param2);static DiagnosticHandler g_diagnosticHandlers_vulnerable[MAX_SUB_COMMANDS];void logSecurityViolation(const char* msg) {}void diagHandler_ReadSensor_vulnerable(uint16_t sensorId, uint16_t unused) {}void diagHandler_ResetModule_vulnerable(uint16_t moduleId, uint16_t unused) {}void diagHandler_GetStatus_vulnerable(uint16_t statusType, uint16_t unused) {}void diagHandler_ClearDTC_vulnerable(uint16_t dtcCode, uint16_t unused) {}void diagHandler_PerformSelfTest_vulnerable(uint16_t testId, uint16_t unused) {}CanMessage receiveCanMessage_Vulnerable() {CanMessage msg;msg.id = 0x7E1;msg.dlc = 8;msg.data[0] = MAIN_CMD_DIAGNOSTIC_QUERY;msg.data[1] = 5;msg.data[2] = 0x01;msg.data[3] = 0x02;msg.data[4] = 0x00;msg.data[5] = 0x00;msg.data[6] = 0x00;msg.data[7] = 0x00;return msg;}void initDiagnosticHandlers_Vulnerable() {g_diagnosticHandlers_vulnerable[0] = diagHandler_ReadSensor_vulnerable;g_diagnosticHandlers_vulnerable[1] = diagHandler_ResetModule_vulnerable;g_diagnosticHandlers_vulnerable[2] = diagHandler_GetStatus_vulnerable;g_diagnosticHandlers_vulnerable[3] = diagHandler_ClearDTC_vulnerable;g_diagnosticHandlers_vulnerable[4] = diagHandler_PerformSelfTest_vulnerable;}void processDiagnosticCommand_Vulnerable() {CanMessage msg = receiveCanMessage_Vulnerable();if (msg.id == 0x7E1 && msg.dlc >= 4) {uint8_t mainCommandId = msg.data[0];uint8_t subCommandId = msg.data[1];uint16_t param1 = (uint16_t)msg.data[2];uint16_t param2 = (uint16_t)msg.data[3];if (mainCommandId == MAIN_CMD_DIAGNOSTIC_QUERY) {if (g_diagnosticHandlers_vulnerable[subCommandId] != NULL) {g_diagnosticHandlers_vulnerable[subCommandId](param1, param2);} else {logSecurityViolation(\"Diagnostic: Unregistered sub-command handler called (possibly invalid index).\");}} else {logSecurityViolation(\"Diagnostic: Unsupported main command ID received.\");}} else {logSecurityViolation(\"Diagnostic: Invalid CAN message format or ID.\");}}void vehicleDiagnosticModule_Vulnerable() {initDiagnosticHandlers_Vulnerable();processDiagnosticCommand_Vulnerable();}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_VEHICLE_PROFILES_VULNERABLE 10\n\ntypedef struct {\n    uint16_t engine_torque_factor;\n    uint16_t transmission_shift_aggressiveness;\n    uint8_t suspension_damping_level;\n    char profile_name[32];\n} DrivingProfile_Vulnerable;\n\nstatic DrivingProfile_Vulnerable g_allVehicleProfiles_Vulnerable[MAX_VEHICLE_PROFILES_VULNERABLE];\nstatic uint8_t g_configuredProfileCount_Vulnerable;\n\nvoid automotive_log_Vulnerable(const char* msg) {\n    (void)msg;\n}\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t requested_profile_id;\n    uint16_t checksum;\n} VehicleControlCommand_Vulnerable;\n\nVehicleControlCommand_Vulnerable receiveVehicleControlCommand_Vulnerable() {\n    VehicleControlCommand_Vulnerable cmd;\n    cmd.command_id = 0x01;\n    cmd.requested_profile_id = 6;\n    cmd.checksum = 0xAAAA;\n    automotive_log_Vulnerable(\"Simulating incoming vehicle control command.\");\n    return cmd;\n}\n\nvoid initializeVehicleProfiles_Vulnerable() {\n    g_configuredProfileCount_Vulnerable = 5;\n\n    g_allVehicleProfiles_Vulnerable[0] = (DrivingProfile_Vulnerable){100, 50, 10, \"Eco Mode\"};\n    g_allVehicleProfiles_Vulnerable[1] = (DrivingProfile_Vulnerable){120, 70, 20, \"Comfort Mode\"};\n    g_allVehicleProfiles_Vulnerable[2] = (DrivingProfile_Vulnerable){150, 90, 40, \"Normal Mode\"};\n    g_allVehicleProfiles_Vulnerable[3] = (DrivingProfile_Vulnerable){180, 110, 60, \"Sport Mode\"};\n    g_allVehicleProfiles_Vulnerable[4] = (DrivingProfile_Vulnerable){200, 130, 80, \"Race Mode\"};\n\n    automotive_log_Vulnerable(\"Vehicle profiles initialized for variant (vulnerable).\");\n}\n\nvoid activateDrivingProfile_Vulnerable(uint8_t profile_id) {\n    if (profile_id < MAX_VEHICLE_PROFILES_VULNERABLE) {\n        DrivingProfile_Vulnerable active_profile = g_allVehicleProfiles_Vulnerable[profile_id];\n        automotive_log_Vulnerable(\"Attempting to activate driving profile (vulnerable).\");\n        (void)active_profile;\n    } else {\n        automotive_log_Vulnerable(\"Invalid profile ID received (out of max bounds).\");\n    }\n}\n\nvoid vehicleProfileManager_main_Vulnerable() {\n    initializeVehicleProfiles_Vulnerable();\n    VehicleControlCommand_Vulnerable cmd = receiveVehicleControlCommand_Vulnerable();\n\n    if (cmd.command_id == 0x01) {\n        activateDrivingProfile_Vulnerable(cmd.requested_profile_id);\n    } else {\n        automotive_log_Vulnerable(\"Unhandled vehicle control command.\");\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <string.h>\n\n#define MAX_DIAG_EVENTS 10\n#define DIAG_EVENT_DATA_SIZE 16\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp;\n    uint8_t  data_len;\n    uint8_t  diag_data[DIAG_EVENT_DATA_SIZE];\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diag_event_buffer[MAX_DIAG_EVENTS];\nstatic uint8_t g_num_active_events = 0;\n\nvoid init_diag_system_fixed() {\n    for (uint8_t i = 0; i < MAX_DIAG_EVENTS; ++i) {\n        memset(&g_diag_event_buffer[i], 0, sizeof(DiagnosticEvent));\n    }\n    g_num_active_events = 0;\n}\n\nbool add_diag_event_fixed(uint16_t event_id, uint32_t timestamp, const uint8_t* initial_data, uint8_t initial_data_len) {\n    if (g_num_active_events >= MAX_DIAG_EVENTS) {\n        return false;\n    }\n    if (initial_data_len > DIAG_EVENT_DATA_SIZE) {\n        initial_data_len = DIAG_EVENT_DATA_SIZE;\n    }\n\n    g_diag_event_buffer[g_num_active_events].event_id = event_id;\n    g_diag_event_buffer[g_num_active_events].timestamp = timestamp;\n    g_diag_event_buffer[g_num_active_events].data_len = initial_data_len;\n    if (initial_data && initial_data_len > 0) {\n        for (uint8_t i = 0; i < initial_data_len; ++i) {\n            g_diag_event_buffer[g_num_active_events].diag_data[i] = initial_data[i];\n        }\n    }\n    g_num_active_events++;\n    return true;\n}\n\nvoid clear_diag_data_byte_fixed(uint16_t target_event_id, int16_t relative_offset_from_data_end) {\n    int event_idx = -1;\n    for (int i = 0; i < g_num_active_events; ++i) {\n        if (g_diag_event_buffer[i].event_id == target_event_id) {\n            event_idx = i;\n            break;\n        }\n    }\n\n    if (event_idx == -1 || g_diag_event_buffer[event_idx].data_len == 0) {\n        return;\n    }\n\n    int32_t target_byte_index = (int32_t)g_diag_event_buffer[event_idx].data_len - 1 - relative_offset_from_data_end;\n\n    if (target_byte_index < 0 || target_byte_index >= g_diag_event_buffer[event_idx].data_len) {\n        return;\n    }\n\n    g_diag_event_buffer[event_idx].diag_data[target_byte_index] = 0x00;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_EVENT_BUFFER_SIZE 16\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t event_id;\n    uint8_t  severity;\n    uint8_t  status;\n    uint8_t  data[4];\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diag_event_history_fixed[DIAG_EVENT_BUFFER_SIZE];\nstatic uint16_t g_write_idx_fixed = 0;\nstatic uint16_t g_num_events_fixed = 0;\n\nvoid init_diag_history_fixed() {\n    memset(g_diag_event_history_fixed, 0, sizeof(g_diag_event_history_fixed));\n    g_write_idx_fixed = 0;\n    g_num_events_fixed = 0;\n}\n\nbool add_diag_event_fixed(uint32_t timestamp, uint16_t id, uint8_t severity, uint8_t status, const uint8_t* data) {\n    if (data == NULL) {\n        return false;\n    }\n\n    g_diag_event_history_fixed[g_write_idx_fixed].timestamp_ms = timestamp;\n    g_diag_event_history_fixed[g_write_idx_fixed].event_id = id;\n    g_diag_event_history_fixed[g_write_idx_fixed].severity = severity;\n    g_diag_event_history_fixed[g_write_idx_fixed].status = status;\n    memcpy(g_diag_event_history_fixed[g_write_idx_fixed].data, data, sizeof(g_diag_event_history_fixed[g_write_idx_fixed].data));\n\n    g_write_idx_fixed = (g_write_idx_fixed + 1) % DIAG_EVENT_BUFFER_SIZE;\n    if (g_num_events_fixed < DIAG_EVENT_BUFFER_SIZE) {\n        g_num_events_fixed++;\n    }\n    return true;\n}\n\nvoid update_event_status_by_relative_offset_fixed(uint16_t offset_from_latest, uint8_t new_status) {\n    if (g_num_events_fixed == 0) {\n        return;\n    }\n\n    uint16_t latest_event_idx = (g_write_idx_fixed == 0) ? (DIAG_EVENT_BUFFER_SIZE - 1) : (g_write_idx_fixed - 1);\n\n    if (offset_from_latest >= g_num_events_fixed) {\n        return;\n    }\n\n    int32_t conceptual_idx = (int32_t)latest_event_idx - offset_from_latest;\n    uint16_t target_idx = (uint16_t)((conceptual_idx % DIAG_EVENT_BUFFER_SIZE + DIAG_EVENT_BUFFER_SIZE) % DIAG_EVENT_BUFFER_SIZE);\n    \n    g_diag_event_history_fixed[target_idx].status = new_status;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define FIRMWARE_UPDATE_BUFFER_SIZE 1024\n#define NUM_FIRMWARE_SECTIONS 4\n\ntypedef struct {\n    uint16_t base_address;\n    uint16_t size;\n} FirmwareSectionInfo;\n\nstatic uint8_t g_firmwareUpdateBuffer[FIRMWARE_UPDATE_BUFFER_SIZE];\n\nstatic const FirmwareSectionInfo g_firmwareSections[NUM_FIRMWARE_SECTIONS] = {\n    {0, 200},\n    {200, 300},\n    {500, 100},\n    {600, 424}\n};\n\nvoid initFirmwareUpdater() {\n    memset(g_firmwareUpdateBuffer, 0xFF, FIRMWARE_UPDATE_BUFFER_SIZE);\n}\n\nint writeFirmwareBlock(uint8_t section_id, uint8_t block_offset_in_section, uint8_t block_len, const uint8_t* data_payload) {\n    if (data_payload == NULL || block_len == 0) {\n        return -1;\n    }\n\n    if (section_id >= NUM_FIRMWARE_SECTIONS) {\n        return -2;\n    }\n\n    const FirmwareSectionInfo* section = &g_firmwareSections[section_id];\n\n    uint8_t end_offset_check = block_offset_in_section + block_len;\n\n    if (block_offset_in_section >= section->size || end_offset_check > section->size) {\n        return -3;\n    }\n\n    uint16_t dest_address = section->base_address + block_offset_in_section;\n\n    for (uint8_t i = 0; i < block_len; ++i) {\n        g_firmwareUpdateBuffer[dest_address + i] = data_payload[i];\n    }\n\n    return 0;\n}\n\nvoid updateFirmwareSection(uint8_t section_id, uint8_t offset, uint8_t len, const uint8_t* data) {\n    if (g_firmwareUpdateBuffer[0] == 0xFF) {\n        initFirmwareUpdater();\n    }\n    writeFirmwareBlock(section_id, offset, len, data);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <algorithm>\n#include <limits>\n\nstruct DiagnosticRecordHeader {\n    uint16_t record_id;\n    uint16_t data_length; \n};\n\nclass DiagnosticDataStoreVulnerable {\npublic:\n    DiagnosticDataStoreVulnerable() : m_buffer(nullptr), m_current_data_size(0), m_allocated_capacity(0) {}\n\n    ~DiagnosticDataStoreVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool appendDiagnosticRecordVulnerable(const uint8_t* raw_record_data, size_t raw_record_len) {\n        if (!raw_record_data || raw_record_len < sizeof(DiagnosticRecordHeader)) {\n            return false;\n        }\n\n        const DiagnosticRecordHeader* header = reinterpret_cast<const DiagnosticRecordHeader*>(raw_record_data);\n        uint16_t advertised_data_length = header->data_length;\n\n        if (raw_record_len != (sizeof(DiagnosticRecordHeader) + advertised_data_length)) {\n            return false;\n        }\n\n        size_t new_required_capacity = m_current_data_size + advertised_data_length;\n\n        const size_t MAX_TOTAL_BUFFER_SIZE = 16 * 1024 * 1024;\n        if (new_required_capacity > MAX_TOTAL_BUFFER_SIZE) {\n            return false;\n        }\n        \n        uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_required_capacity);\n\n        if (!new_buffer && new_required_capacity > 0) {\n            return false;\n        }\n        \n        m_buffer = new_buffer;\n        m_allocated_capacity = new_required_capacity;\n\n        std::memcpy(m_buffer + m_current_data_size, raw_record_data, raw_record_len);\n        \n        m_current_data_size += raw_record_len;\n\n        return true;\n    }\n\n    const uint8_t* getRawDataBuffer() const {\n        return m_buffer;\n    }\n\n    size_t getCurrentDataSize() const {\n        return m_current_data_size;\n    }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_current_data_size;\n    size_t m_allocated_capacity;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define TOTAL_SENSOR_DATA_POOL_SIZE 256\n#define SENSOR_TYPE_COUNT 3\n#define READING_SIZE sizeof(int16_t)\n\ntypedef enum {\n    SENSOR_TYPE_TEMPERATURE = 0,\n    SENSOR_TYPE_PRESSURE,\n    SENSOR_TYPE_HUMIDITY\n} SensorType;\n\nstatic uint8_t g_sensorDataPool_vulnerable[TOTAL_SENSOR_DATA_POOL_SIZE];\n\nstatic uint16_t g_sensorTypeDataStartOffset_vulnerable[SENSOR_TYPE_COUNT];\n\nstatic uint16_t g_sensorTypeDataCapacity_vulnerable[SENSOR_TYPE_COUNT];\n\nvoid logSystemAlert(const char* msg) {\n}\n\ntypedef struct {\n    SensorType type;\n    uint16_t   reading_index;\n    int16_t    value;\n} SensorUpdateCommand_vulnerable;\n\nSensorUpdateCommand_vulnerable getIncomingSensorUpdate_vulnerable() {\n    SensorUpdateCommand_vulnerable cmd;\n    cmd.type = SENSOR_TYPE_TEMPERATURE;\n    cmd.reading_index = 40;\n    cmd.value = 0xAAAA;\n    return cmd;\n}\n\nvoid initializeSensorDataManager_vulnerable() {\n    g_sensorTypeDataStartOffset_vulnerable[SENSOR_TYPE_TEMPERATURE] = 0;\n    g_sensorTypeDataCapacity_vulnerable[SENSOR_TYPE_TEMPERATURE] = 30;\n\n    g_sensorTypeDataStartOffset_vulnerable[SENSOR_TYPE_PRESSURE] = 60;\n    g_sensorTypeDataCapacity_vulnerable[SENSOR_TYPE_PRESSURE] = 50;\n\n    g_sensorTypeDataStartOffset_vulnerable[SENSOR_TYPE_HUMIDITY] = 160;\n    g_sensorTypeDataCapacity_vulnerable[SENSOR_TYPE_HUMIDITY] = 40;\n\n    for (uint16_t i = 0; i < TOTAL_SENSOR_DATA_POOL_SIZE; ++i) {\n        g_sensorDataPool_vulnerable[i] = 0;\n    }\n\n    logSystemAlert(\"Sensor data manager initialized (vulnerable).\");\n}\n\nvoid processSensorUpdateCommand_vulnerable() {\n    SensorUpdateCommand_vulnerable cmd = getIncomingSensorUpdate_vulnerable();\n\n    if (cmd.type >= SENSOR_TYPE_COUNT) {\n        logSystemAlert(\"Error: Invalid sensor type in update command.\");\n        return;\n    }\n\n    uint16_t base_offset = g_sensorTypeDataStartOffset_vulnerable[cmd.type];\n    uint16_t target_byte_offset = base_offset + (cmd.reading_index * READING_SIZE);\n\n    if (target_byte_offset + READING_SIZE <= TOTAL_SENSOR_DATA_POOL_SIZE) {\n        *(int16_t*)(g_sensorDataPool_vulnerable + target_byte_offset) = cmd.value;\n        logSystemAlert(\"Sensor reading updated (vulnerable).\");\n    } else {\n        logSystemAlert(\"Error: Calculated offset out of global sensor data pool bounds.\");\n    }\n}\n\nvoid main_vehicle_sensor_system_vulnerable() {\n    initializeSensorDataManager_vulnerable();\n    processSensorUpdateCommand_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_LIGHTING_ZONES 5\n\ntypedef enum {\n    LIGHT_MODE_OFF = 0,\n    LIGHT_MODE_ON_LOW,\n    LIGHT_MODE_ON_HIGH,\n    LIGHT_MODE_AMBIENT,\n    LIGHT_MODE_COUNT\n} LightingMode;\n\ntypedef struct {\n    LightingMode current_mode;\n    uint8_t brightness;\n    uint16_t color_temp_kelvin;\n} LightingZoneConfig_Fixed;\n\nstatic LightingZoneConfig_Fixed g_lightingZoneConfigs_fixed[MAX_LIGHTING_ZONES];\n\nvoid lightingLog_fixed(const char* msg) {\n    printf(\"LIGHT_FIXED: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t zone_id;\n    LightingMode new_mode;\n    uint8_t new_brightness;\n    uint16_t new_color_temp;\n} LightingCommand_Fixed;\n\nLightingCommand_Fixed getSimulatedLightingCommand_fixed() {\n    LightingCommand_Fixed cmd;\n    cmd.zone_id = MAX_LIGHTING_ZONES; \n    cmd.new_mode = LIGHT_MODE_ON_HIGH;\n    cmd.new_brightness = 85;\n    cmd.new_color_temp = 4500;\n    lightingLog_fixed(\"Simulating reception of lighting command (fixed).\");\n    return cmd;\n}\n\nvoid initializeLightingSystem_fixed() {\n    for (uint8_t i = 0; i < MAX_LIGHTING_ZONES; ++i) {\n        g_lightingZoneConfigs_fixed[i].current_mode = LIGHT_MODE_OFF;\n        g_lightingZoneConfigs_fixed[i].brightness = 0;\n        g_lightingZoneConfigs_fixed[i].color_temp_kelvin = 0;\n    }\n    lightingLog_fixed(\"Lighting system initialized (fixed).\");\n}\n\nvoid applyLightingCommand_fixed(LightingCommand_Fixed cmd) {\n    if (cmd.zone_id < MAX_LIGHTING_ZONES) {\n        g_lightingZoneConfigs_fixed[cmd.zone_id].current_mode = cmd.new_mode;\n        g_lightingZoneConfigs_fixed[cmd.zone_id].brightness = cmd.new_brightness;\n        g_lightingZoneConfigs_fixed[cmd.zone_id].color_temp_kelvin = cmd.new_color_temp;\n        lightingLog_fixed(\"Lighting command applied successfully (fixed).\");\n    } else {\n        lightingLog_fixed(\"Invalid lighting zone ID received. Command ignored (fixed).\");\n    }\n}\n\nvoid renderCurrentLightingState_fixed() {\n    lightingLog_fixed(\"Rendering current lighting state (fixed).\");\n}\n\nvoid lightingControlUnitMain_fixed() {\n    initializeLightingSystem_fixed();\n    LightingCommand_Fixed command = getSimulatedLightingCommand_fixed();\n    applyLightingCommand_fixed(command);\n    renderCurrentLightingState_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAG_EVENT_BUFFER_SIZE_FIXED 256\n#define DIAG_EVENT_ENTRY_BYTE_SIZE_FIXED 8\n\nstatic uint8_t g_diag_event_buffer_fixed[DIAG_EVENT_BUFFER_SIZE_FIXED];\nstatic uint16_t g_active_event_count_fixed = 0;\nstatic uint16_t g_next_event_write_byte_idx_fixed = 0;\n\nvoid init_diag_event_manager_fixed() {\n    memset(g_diag_event_buffer_fixed, 0, DIAG_EVENT_BUFFER_SIZE_FIXED);\n    g_active_event_count_fixed = 0;\n    g_next_event_write_byte_idx_fixed = 0;\n}\n\nbool record_diagnostic_event_fixed(uint32_t timestamp, uint32_t event_code) {\n    if ((g_next_event_write_byte_idx_fixed + DIAG_EVENT_ENTRY_BYTE_SIZE_FIXED) > DIAG_EVENT_BUFFER_SIZE_FIXED) {\n        return false;\n    }\n    \n    memcpy(g_diag_event_buffer_fixed + g_next_event_write_byte_idx_fixed, &timestamp, sizeof(timestamp));\n    memcpy(g_diag_event_buffer_fixed + g_next_event_write_byte_idx_fixed + sizeof(timestamp), &event_code, sizeof(event_code));\n    \n    g_next_event_write_byte_idx_fixed += DIAG_EVENT_ENTRY_BYTE_SIZE_FIXED;\n    g_active_event_count_fixed++;\n    \n    return true;\n}\n\nvoid clear_recent_diag_events_and_mark_fixed(uint16_t events_to_purge, int16_t marker_byte_offset_from_new_end) {\n    if (g_active_event_count_fixed == 0) {\n        return;\n    }\n\n    uint16_t actual_events_to_purge = events_to_purge;\n    if (actual_events_to_purge > g_active_event_count_fixed) {\n        actual_events_to_purge = g_active_event_count_fixed;\n    }\n\n    g_active_event_count_fixed -= actual_events_to_purge;\n    g_next_event_write_byte_idx_fixed = g_active_event_count_fixed * DIAG_EVENT_ENTRY_BYTE_SIZE_FIXED;\n\n    int32_t target_marker_byte_idx = (int32_t)g_next_event_write_byte_idx_fixed + marker_byte_offset_from_new_end;\n\n    if (target_marker_byte_idx >= 0 && target_marker_byte_idx < DIAG_EVENT_BUFFER_SIZE_FIXED) {\n        g_diag_event_buffer_fixed[target_marker_byte_idx] = 0xDE;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define VEHICLE_EVENT_LOG_BUFFER_SIZE 1024 \n#define FIXED_RECORD_PAYLOAD_SIZE 32 \n#define LOG_RECORD_TOTAL_SIZE (sizeof(uint16_t) + FIXED_RECORD_PAYLOAD_SIZE) \n#define NUM_EVENT_LOG_TYPES 5 \n\nstatic uint8_t g_eventLogBuffer_fixed[VEHICLE_EVENT_LOG_BUFFER_SIZE];\n\ntypedef struct {\n    uint16_t start_byte_offset;   \n    uint16_t max_records;         \n    uint16_t current_record_idx;  \n} EventLogSegmentInfo_fixed;\n\nstatic EventLogSegmentInfo_fixed g_logSegmentTable_fixed[NUM_EVENT_LOG_TYPES];\n\nvoid vehicleSystemLog_fixed(const char* message) {\n}\n\ntypedef struct {\n    uint8_t  eventTypeID;\n    uint16_t timestamp;\n    uint8_t  payload[FIXED_RECORD_PAYLOAD_SIZE];\n} IncomingLogRequest_fixed;\n\nIncomingLogRequest_fixed simulateIncomingLogRequest_fixed() {\n    IncomingLogRequest_fixed req;\n    req.eventTypeID = 3; \n    req.timestamp = 0xABCD;\n    for (int i = 0; i < FIXED_RECORD_PAYLOAD_SIZE; ++i) {\n        req.payload[i] = (uint8_t)(0xAA + i);\n    }\n    return req;\n}\n\nvoid initializeEventLogSystem_fixed() {\n    g_logSegmentTable_fixed[0] = (EventLogSegmentInfo_fixed){0, 5, 0};\n    g_logSegmentTable_fixed[1] = (EventLogSegmentInfo_fixed){170, 10, 0};\n    g_logSegmentTable_fixed[2] = (EventLogSegmentInfo_fixed){510, 8, 0};\n    g_logSegmentTable_fixed[3] = (EventLogSegmentInfo_fixed){782, 3, 0};\n    g_logSegmentTable_fixed[4] = (EventLogSegmentInfo_fixed){884, 4, 0};\n\n    for (int i = 0; i < VEHICLE_EVENT_LOG_BUFFER_SIZE; ++i) {\n        g_eventLogBuffer_fixed[i] = 0;\n    }\n    vehicleSystemLog_fixed(\"Event log system initialized.\");\n}\n\nvoid processAndStoreEvent_fixed() {\n    IncomingLogRequest_fixed req = simulateIncomingLogRequest_fixed();\n\n    if (req.eventTypeID >= NUM_EVENT_LOG_TYPES) {\n        vehicleSystemLog_fixed(\"Received log request with invalid event type ID.\");\n        return;\n    }\n\n    EventLogSegmentInfo_fixed* segment = &g_logSegmentTable_fixed[req.eventTypeID];\n\n    if (segment->current_record_idx >= segment->max_records) {\n        vehicleSystemLog_fixed(\"Error: Event log segment for this type is full.\");\n        return;\n    }\n\n    uint16_t target_physical_offset = segment->start_byte_offset +\n                                     (segment->current_record_idx * LOG_RECORD_TOTAL_SIZE);\n\n    if ((target_physical_offset + LOG_RECORD_TOTAL_SIZE) <= VEHICLE_EVENT_LOG_BUFFER_SIZE) {\n        *(uint16_t*)(g_eventLogBuffer_fixed + target_physical_offset) = req.timestamp;\n        for (int i = 0; i < FIXED_RECORD_PAYLOAD_SIZE; ++i) {\n            g_eventLogBuffer_fixed[target_physical_offset + sizeof(uint16_t) + i] = req.payload[i];\n        }\n        segment->current_record_idx++;\n        vehicleSystemLog_fixed(\"Event log entry stored.\");\n    } else {\n        vehicleSystemLog_fixed(\"Internal Error: Calculated physical offset exceeds total buffer size.\");\n    }\n}\n\nvoid vehicleMainLoop_fixed() {\n    initializeEventLogSystem_fixed();\n\n    processAndStoreEvent_fixed();\n    processAndStoreEvent_fixed();\n    processAndStoreEvent_fixed();\n    processAndStoreEvent_fixed(); \n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_RESPONSE_BUFFER_SIZE 256\n#define MAX_RAW_DIAG_DATA_LEN 100\n\nstatic uint8_t g_diagResponseBuffer[DIAG_RESPONSE_BUFFER_SIZE];\nstatic uint16_t g_responseWritePos = 0;\n\nvoid initDiagResponseSystem() {\n    memset(g_diagResponseBuffer, 0, DIAG_RESPONSE_BUFFER_SIZE);\n    g_responseWritePos = 0;\n}\n\nint buildDiagnosticResponse(const uint8_t* raw_data, uint16_t raw_data_len) {\n    if (raw_data == NULL || raw_data_len == 0 || raw_data_len > MAX_RAW_DIAG_DATA_LEN) {\n        return -1;\n    }\n\n    g_responseWritePos = 0;\n\n    for (uint16_t i = 0; i < raw_data_len; ++i) {\n        uint8_t current_byte = raw_data[i];\n\n        if (current_byte == 0xCC || current_byte == 0xEE) {\n            if (g_responseWritePos + 1 > DIAG_RESPONSE_BUFFER_SIZE) {\n                return -2;\n            }\n            g_diagResponseBuffer[g_responseWritePos++] = 0x1B;\n            g_diagResponseBuffer[g_responseWritePos++] = 0x01;\n            g_diagResponseBuffer[g_responseWritePos++] = current_byte;\n        } else {\n            if (g_responseWritePos + 1 > DIAG_RESPONSE_BUFFER_SIZE) {\n                return -2;\n            }\n            g_diagResponseBuffer[g_responseWritePos++] = current_byte;\n        }\n    }\n\n    return g_responseWritePos;\n}\n\nvoid sendDiagResponse(const uint8_t* data, uint16_t len) {\n    buildDiagnosticResponse(data, len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_FAULT_CATEGORIES        4\n#define MAX_FAULTS_PER_CATEGORY_GLOBAL 30\n\ntypedef uint8_t FaultStatus;\n#define FAULT_STATUS_ACTIVE    0x01\n#define FAULT_STATUS_INACTIVE  0x00\n\nstatic FaultStatus g_faultStatusData[MAX_FAULT_CATEGORIES][MAX_FAULTS_PER_CATEGORY_GLOBAL];\n\nstatic const uint8_t g_actualFaultCountPerCategory[MAX_FAULT_CATEGORIES] = {\n    10,\n    25,\n    5,\n    15\n};\n\nvoid logEvent(const char* msg) {\n}\n\nuint16_t receiveDiagnosticFaultReport_fixed() {\n    return 0x020A;\n}\n\nvoid initializeFaultSystem_fixed() {\n    for (uint8_t i = 0; i < MAX_FAULT_CATEGORIES; ++i) {\n        for (uint8_t j = 0; j < MAX_FAULTS_PER_CATEGORY_GLOBAL; ++j) {\n            g_faultStatusData[i][j] = FAULT_STATUS_INACTIVE;\n        }\n    }\n    logEvent(\"Fault system initialized.\");\n}\n\nvoid updateFaultStatus_fixed() {\n    uint16_t reportedFaultId = receiveDiagnosticFaultReport_fixed();\n\n    uint8_t categoryIdx = (uint8_t)((reportedFaultId >> 8) & 0xFF);\n    uint8_t faultIdxWithinCategory = (uint8_t)(reportedFaultId & 0xFF);\n\n    if (categoryIdx < MAX_FAULT_CATEGORIES) {\n        if (faultIdxWithinCategory < g_actualFaultCountPerCategory[categoryIdx]) {\n            g_faultStatusData[categoryIdx][faultIdxWithinCategory] = FAULT_STATUS_ACTIVE;\n            logEvent(\"Fault status updated.\");\n        } else {\n            logEvent(\"Attempt to update fault with category-specific out-of-bounds index. Ignored.\");\n        }\n    } else {\n        logEvent(\"Attempt to update fault with invalid category ID. Ignored.\");\n    }\n}\n\nvoid faultManagementModule_fixed() {\n    initializeFaultSystem_fixed();\n    updateFaultStatus_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CAL_DATA_BUFFER_SIZE 256\n#define CAL_PAGE_SIZE 16\n\nclass VehicleCalibrationManagerVulnerable {\nprivate:\n    uint8_t m_calibration_data[CAL_DATA_BUFFER_SIZE];\n    uint16_t m_current_data_size;\n\npublic:\n    VehicleCalibrationManagerVulnerable() : m_current_data_size(0) {\n        memset(m_calibration_data, 0xFF, CAL_DATA_BUFFER_SIZE);\n    }\n\n    bool write_calibration_segment(const uint8_t* data, uint16_t len) {\n        if (m_current_data_size + len > CAL_DATA_BUFFER_SIZE) {\n            return false;\n        }\n        memcpy(m_calibration_data + m_current_data_size, data, len);\n        m_current_data_size += len;\n        return true;\n    }\n\n    void reset_leading_segment_vulnerable(uint8_t segment_id, int16_t metadata_adjust, uint16_t reset_length) {\n        if (reset_length == 0) {\n            return;\n        }\n\n        uint32_t base_offset_bytes = (uint32_t)segment_id * CAL_PAGE_SIZE;\n        int32_t target_start_index = (int32_t)base_offset_bytes + metadata_adjust;\n\n        for (uint32_t i = 0; i < reset_length; ++i) {\n            m_calibration_data[target_start_index + i] = 0x00;\n        }\n\n        if (target_start_index >= 0 && target_start_index < m_current_data_size) {\n            volatile uint8_t check_byte = m_calibration_data[target_start_index];\n            (void)check_byte;\n        }\n    }\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits> // For std::numeric_limits\n\n// Represents a sub-message header within a larger diagnostic packet\nstruct DiagnosticSubMessageHeader {\n    uint16_t message_id;\n    uint16_t payload_length; // Actual length of payload for this sub-message\n};\n\n// Represents the overall diagnostic packet header\nstruct DiagnosticPacketHeader {\n    uint16_t packet_type;\n    uint16_t num_sub_messages;\n    uint32_t max_expected_sub_message_payload_len; // Max payload size for ANY sub-message in this packet\n};\n\nclass DiagnosticDataProcessorFixed {\npublic:\n    DiagnosticDataProcessorFixed() : m_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~DiagnosticDataProcessorFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool processPacketFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeader* header = reinterpret_cast<const DiagnosticPacketHeader*>(raw_packet);\n\n        // Calculate total space needed for all sub-messages' payloads based on the MAX expected length.\n        // Use size_t for calculations to prevent intermediate overflow of smaller types,\n        // and explicitly check for overflow against SIZE_MAX.\n        size_t total_payload_data_space;\n        if (header->num_sub_messages != 0 &&\n            header->max_expected_sub_message_payload_len > std::numeric_limits<size_t>::max() / header->num_sub_messages) {\n            return false; // Integer overflow detected for payload space during multiplication\n        }\n        total_payload_data_space = (size_t)header->num_sub_messages * header->max_expected_sub_message_payload_len;\n\n        // Add space for all sub-message headers\n        size_t total_headers_space = (size_t)header->num_sub_messages * sizeof(DiagnosticSubMessageHeader);\n        \n        // Check for integer overflow when adding total_headers_space\n        if (total_payload_data_space > std::numeric_limits<size_t>::max() - total_headers_space) {\n            return false; // Integer overflow detected for total size during addition\n        }\n\n        size_t total_allocation_size = total_payload_data_space + total_headers_space;\n\n        // Ensure total_allocation_size is not zero if there are messages expected\n        if (header->num_sub_messages > 0 && total_allocation_size == 0) {\n            return false; // Calculation resulted in zero size for a non-empty packet\n        }\n\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n        \n        // Allocate the buffer. This size is now correctly calculated and checked.\n        m_buffer = (uint8_t*)malloc(total_allocation_size);\n        if (!m_buffer) {\n            m_buffer_capacity = 0;\n            return false;\n        }\n        m_buffer_capacity = total_allocation_size;\n\n        uint8_t* current_write_ptr = m_buffer;\n        const uint8_t* current_read_ptr = raw_packet + sizeof(DiagnosticPacketHeader);\n        size_t remaining_packet_data = packet_len - sizeof(DiagnosticPacketHeader);\n\n        for (uint16_t i = 0; i < header->num_sub_messages; ++i) {\n            // Validate minimum required data for sub-message header in source packet\n            if (remaining_packet_data < sizeof(DiagnosticSubMessageHeader)) {\n                return false; // Malformed packet or truncated\n            }\n\n            const DiagnosticSubMessageHeader* sub_header = reinterpret_cast<const DiagnosticSubMessageHeader*>(current_read_ptr);\n            uint16_t actual_payload_len = sub_header->payload_length;\n\n            // Validate that an individual message's payload length does not exceed the globally advertised maximum\n            if (actual_payload_len > header->max_expected_sub_message_payload_len) {\n                return false; // Individual message payload exceeds global max declared in header\n            }\n\n            size_t current_sub_message_total_len = sizeof(DiagnosticSubMessageHeader) + actual_payload_len;\n\n            // Crucial: Check if there's enough space in the *destination* buffer for the current sub-message data.\n            // This prevents heap-based buffer overflow by ensuring the memcpy destination is within bounds.\n            // Also checks for pointer arithmetic wrap-around for current_write_ptr + current_sub_message_total_len.\n            if (current_write_ptr > m_buffer + m_buffer_capacity ||\n                current_sub_message_total_len > m_buffer_capacity - (current_write_ptr - m_buffer)) \n            {\n                return false; // Not enough allocated buffer space remaining for this entry\n            }\n            \n            // Check if there's enough data in the source packet for this complete sub-message (header + payload)\n            if (remaining_packet_data < current_sub_message_total_len) {\n                return false; // Not enough source data for declared payload\n            }\n            \n            // Copy sub-message header and payload in one contiguous block\n            memcpy(current_write_ptr, current_read_ptr, current_sub_message_total_len);\n            \n            current_write_ptr += current_sub_message_total_len;\n            current_read_ptr += current_sub_message_total_len;\n            remaining_packet_data -= current_sub_message_total_len;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedData() const { return m_buffer; }\n    size_t getProcessedDataCapacity() const { return m_buffer_capacity; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_buffer_capacity;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#define BCU_COUNT 8\n#define STATUS_PARAM_COUNT 16\n\ntypedef enum {\n    TEMP_SENSOR_1 = 0,\n    VOLTAGE_CELL_1,\n    CURRENT_MEASUREMENT,\n    FAN_SPEED,\n    STATUS_PARAM_MAX\n} BcuStatusParameter;\n\nstatic int g_bcuStatus[BCU_COUNT][STATUS_PARAM_COUNT];\n\ntypedef struct {\n    unsigned char bcu_id;\n    unsigned char param_index;\n    int           value;\n    unsigned char write_operation;\n} DiagnosticRequest;\n\nvoid logDiagnosticAlert(const char* msg) {\n}\n\nDiagnosticRequest receiveDiagnosticRequest_vulnerable() {\n    DiagnosticRequest req;\n    req.bcu_id = 0;\n    req.param_index = STATUS_PARAM_COUNT; \n    req.value = 0xABCD;\n    req.write_operation = 1;\n    return req;\n}\n\nvoid processBcuDiagnostic_vulnerable() {\n    DiagnosticRequest req = receiveDiagnosticRequest_vulnerable();\n\n    if (req.bcu_id < BCU_COUNT) {\n        g_bcuStatus[req.bcu_id][req.param_index] = req.value;\n    } else {\n        logDiagnosticAlert(\"Invalid BCU ID in diagnostic request.\");\n    }\n}\n\nvoid bmsInit_vulnerable() {\n    for (int i = 0; i < BCU_COUNT; ++i) {\n        for (int j = 0; j < STATUS_PARAM_COUNT; ++j) {\n            g_bcuStatus[i][j] = 0;\n        }\n    }\n}\n\nvoid bmsMainLoop_vulnerable() {\n    bmsInit_vulnerable();\n    processBcuDiagnostic_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAG_MESSAGE_MAX_SIZE 1024\n#define MAX_RECORD_PAYLOAD_SIZE 128\n#define TEMP_PROCESSING_BUFFER_SIZE 64\n\ntypedef struct {\n    uint16_t message_id;\n    uint16_t total_payload_len;\n} DiagnosticMessageHeader;\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_len;\n} DiagnosticRecordMinimalHeader;\n\nint processDiagnosticMessage(const uint8_t* msg_buffer, uint16_t msg_len) {\n    if (msg_buffer == NULL || msg_len < sizeof(DiagnosticMessageHeader)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n    \n    uint16_t message_id = (msg_buffer[0] << 8) | msg_buffer[1];\n    current_offset += sizeof(uint16_t);\n\n    uint16_t total_payload_len = (msg_buffer[current_offset] << 8) | msg_buffer[current_offset+1];\n    current_offset += sizeof(uint16_t);\n\n    if (current_offset + total_payload_len > msg_len) {\n        return -2;\n    }\n\n    uint16_t payload_bytes_processed = 0;\n    while (payload_bytes_processed < total_payload_len) {\n        if (payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader) > total_payload_len) {\n            return -3;\n        }\n\n        const DiagnosticRecordMinimalHeader* record_header = \n            (const DiagnosticRecordMinimalHeader*)(msg_buffer + current_offset + payload_bytes_processed);\n        \n        uint8_t record_type = record_header->record_type;\n        uint8_t record_data_len = record_header->record_len; \n\n        if (record_data_len > MAX_RECORD_PAYLOAD_SIZE ||\n            payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader) + record_data_len > total_payload_len) {\n            return -4;\n        }\n\n        const uint8_t* record_data_ptr = msg_buffer + current_offset + payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader);\n\n        if (record_type == 0x05) {\n            char temp_processing_buffer[TEMP_PROCESSING_BUFFER_SIZE];\n\n            memcpy(temp_processing_buffer, record_data_ptr, record_data_len);\n\n            if (record_data_len < TEMP_PROCESSING_BUFFER_SIZE) {\n                temp_processing_buffer[record_data_len] = '\\0';\n            } else {\n                temp_processing_buffer[TEMP_PROCESSING_BUFFER_SIZE - 1] = '\\0';\n            }\n        }\n\n        payload_bytes_processed += sizeof(DiagnosticRecordMinimalHeader) + record_data_len;\n    }\n\n    return 0;\n}\n\nvoid simulateIncomingDiagnosticFrame(const uint8_t* data, uint16_t length) {\n    processDiagnosticMessage(data, length);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_TELEMETRY_PACKET_SIZE 100\n#define FIXED_LOG_BUFFER_SIZE 32\n#define MAX_LOG_ENTRIES 5\n\ntypedef struct {\n    uint16_t packet_id;\n    uint8_t  dynamic_payload_len;\n    uint8_t  payload_data[MAX_TELEMETRY_PACKET_SIZE - 3];\n} TelemetryDataPacket;\n\ntypedef struct {\n    uint16_t log_id;\n    uint8_t  actual_payload_len;\n    uint8_t  fixed_log_buffer[FIXED_LOG_BUFFER_SIZE];\n    uint32_t timestamp;\n} TelemetryLogEntry;\n\nstatic TelemetryLogEntry g_telemetryLog[MAX_LOG_ENTRIES];\nstatic uint8_t g_currentLogEntryIndex = 0;\n\nvoid initTelemetryLog() {\n    for (int i = 0; i < MAX_LOG_ENTRIES; ++i) {\n        g_telemetryLog[i].log_id = 0;\n        g_telemetryLog[i].actual_payload_len = 0;\n        for (int j = 0; j < FIXED_LOG_BUFFER_SIZE; ++j) {\n            g_telemetryLog[i].fixed_log_buffer[j] = 0;\n        }\n        g_telemetryLog[i].timestamp = 0;\n    }\n    g_currentLogEntryIndex = 0;\n}\n\nint processTelemetryPacket(const TelemetryDataPacket* packet, uint32_t current_timestamp) {\n    if (packet == NULL) {\n        return -1;\n    }\n\n    if (g_currentLogEntryIndex >= MAX_LOG_ENTRIES) {\n        return -2;\n    }\n\n    TelemetryLogEntry* current_entry = &g_telemetryLog[g_currentLogEntryIndex];\n\n    current_entry->log_id = packet->packet_id;\n    current_entry->timestamp = current_timestamp;\n\n    for (uint8_t i = 0; i < packet->dynamic_payload_len; ++i) {\n        current_entry->fixed_log_buffer[i] = packet->payload_data[i];\n    }\n\n    current_entry->actual_payload_len = packet->dynamic_payload_len;\n\n    g_currentLogEntryIndex++;\n\n    return 0;\n}\n\nvoid simulateTelemetryReception() {\n    initTelemetryLog();\n\n    TelemetryDataPacket packet1 = {0};\n    packet1.packet_id = 0x101;\n    packet1.dynamic_payload_len = 20;\n    for (int i = 0; i < 20; ++i) {\n        packet1.payload_data[i] = (uint8_t)i;\n    }\n    processTelemetryPacket(&packet1, 1000);\n\n    TelemetryDataPacket packet2 = {0};\n    packet2.packet_id = 0x102;\n    packet2.dynamic_payload_len = 40;\n    for (int i = 0; i < 40; ++i) {\n        packet2.payload_data[i] = 0xAA;\n    }\n    processTelemetryPacket(&packet2, 1001);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_MESSAGE_SIZE 256\n#define VEHICLE_ID_BUFFER_SIZE 32\n#define CALIBRATION_VERSION_BUFFER_SIZE 16\n\nstatic char g_vehicleIdentifier[VEHICLE_ID_BUFFER_SIZE];\nstatic char g_calibrationVersion[CALIBRATION_VERSION_BUFFER_SIZE];\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_length;\n} DiagnosticRecordHeader;\n\ntypedef enum {\n    RECORD_TYPE_INVALID = 0,\n    RECORD_TYPE_VEHICLE_ID = 1,\n    RECORD_TYPE_CALIBRATION_VERSION = 2,\n    RECORD_TYPE_STATUS_CODE = 3\n} DiagnosticRecordType;\n\nvoid initVehicleInfoStore() {\n    memset(g_vehicleIdentifier, 0, VEHICLE_ID_BUFFER_SIZE);\n    memset(g_calibrationVersion, 0, CALIBRATION_VERSION_BUFFER_SIZE);\n}\n\nint processDiagnosticInfoMessage(const uint8_t* message, uint16_t message_len) {\n    if (message == NULL || message_len < sizeof(DiagnosticRecordHeader)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    while (current_offset + sizeof(DiagnosticRecordHeader) <= message_len) {\n        const DiagnosticRecordHeader* header = (const DiagnosticRecordHeader*)(message + current_offset);\n        \n        uint8_t type = header->record_type;\n        uint8_t length = header->record_length;\n\n        if (current_offset + sizeof(DiagnosticRecordHeader) + length > message_len) {\n            return -2;\n        }\n\n        const uint8_t* data_ptr = message + current_offset + sizeof(DiagnosticRecordHeader);\n\n        switch (type) {\n            case RECORD_TYPE_VEHICLE_ID: {\n                for (uint8_t i = 0; i < length; ++i) {\n                    g_vehicleIdentifier[i] = data_ptr[i];\n                }\n                if (length < VEHICLE_ID_BUFFER_SIZE) {\n                    g_vehicleIdentifier[length] = '\\0';\n                }\n                break;\n            }\n            case RECORD_TYPE_CALIBRATION_VERSION: {\n                for (uint8_t i = 0; i < length; ++i) {\n                    g_calibrationVersion[i] = data_ptr[i];\n                }\n                if (length < CALIBRATION_VERSION_BUFFER_SIZE) {\n                    g_calibrationVersion[length] = '\\0';\n                }\n                break;\n            }\n            case RECORD_TYPE_STATUS_CODE: {\n                if (length != sizeof(uint16_t)) return -3;\n                break;\n            }\n            default:\n                break;\n        }\n\n        current_offset += sizeof(DiagnosticRecordHeader) + length;\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticMessage(const uint8_t* msg_data, uint16_t msg_len) {\n    initVehicleInfoStore();\n    processDiagnosticInfoMessage(msg_data, msg_len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <cstring> \n#include <limits>  \n\nstruct TelemetryParameterFixed {\n    uint16_t id;\n    const char* value_str;\n};\n\nclass TelemetryMessageBuilderFixed {\npublic:\n    TelemetryMessageBuilderFixed() : m_message_buffer(nullptr), m_buffer_size(0) {}\n\n    ~TelemetryMessageBuilderFixed() {\n        if (m_message_buffer) {\n            free(m_message_buffer);\n        }\n    }\n\n    void addParameter(uint16_t id, const char* value) {\n        if (value) {\n            m_parameters.push_back({id, value});\n        }\n    }\n\n    bool buildMessageFixed() {\n        if (m_message_buffer) {\n            free(m_message_buffer);\n            m_message_buffer = nullptr;\n            m_buffer_size = 0;\n        }\n\n        size_t calculated_total_len = 0;\n        for (const auto& param : m_parameters) {\n            size_t current_param_entry_size;\n            size_t string_len = strlen(param.value_str);\n\n            // FIX: Check for overflow before adding components to current_param_entry_size\n            if (string_len > std::numeric_limits<size_t>::max() - sizeof(param.id) - 1) {\n                return false; \n            }\n            // FIX: Account for the null terminator (+1) for each string.\n            current_param_entry_size = sizeof(param.id) + string_len + 1;\n\n            // FIX: Check for overflow when summing up total length\n            if (calculated_total_len > std::numeric_limits<size_t>::max() - current_param_entry_size) {\n                return false; \n            }\n            calculated_total_len += current_param_entry_size;\n        }\n\n        if (m_parameters.empty()) {\n            if (calculated_total_len != 0) {\n                return false;\n            }\n            return true;\n        }\n\n        if (calculated_total_len == 0) {\n            return false;\n        }\n\n        m_message_buffer = (uint8_t*)malloc(calculated_total_len);\n        if (!m_message_buffer) {\n            return false;\n        }\n        m_buffer_size = calculated_total_len;\n\n        size_t current_offset = 0;\n        for (const auto& param : m_parameters) {\n            // Write parameter ID (manual byte copy)\n            uint16_t network_order_id = param.id; \n            \n            // FIX: Bounds check before writing ID\n            if (current_offset > m_buffer_size - sizeof(network_order_id)) {\n                free(m_message_buffer); m_message_buffer = nullptr; m_buffer_size = 0;\n                return false;\n            }\n            for (size_t i = 0; i < sizeof(network_order_id); ++i) {\n                m_message_buffer[current_offset + i] = ((uint8_t*)&network_order_id)[i];\n            }\n            current_offset += sizeof(network_order_id);\n\n            // Write parameter value string (includes null terminator)\n            size_t value_len = strlen(param.value_str);\n            \n            // FIX: Explicit bounds check before writing string + null terminator\n            if (current_offset > m_buffer_size - (value_len + 1)) {\n                free(m_message_buffer); m_message_buffer = nullptr; m_buffer_size = 0;\n                return false;\n            }\n            for (size_t i = 0; i <= value_len; ++i) {\n                m_message_buffer[current_offset + i] = param.value_str[i];\n            }\n            current_offset += (value_len + 1);\n        }\n\n        if (current_offset != m_buffer_size) {\n            free(m_message_buffer);\n            m_message_buffer = nullptr;\n            m_buffer_size = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getMessageBuffer() const {\n        return m_message_buffer;\n    }\n\n    size_t getBufferSize() const {\n        return m_buffer_size;\n    }\n\nprivate:\n    std::vector<TelemetryParameterFixed> m_parameters;\n    uint8_t* m_message_buffer;\n    size_t m_buffer_size;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_ROUTABLE_NODES 10\n#define MESSAGE_PAYLOAD_SIZE 8\n\ntypedef struct {\n    uint8_t destination_node_id;\n    uint8_t source_node_id;\n    uint8_t payload[MESSAGE_PAYLOAD_SIZE];\n    uint8_t payload_len;\n} NetworkMessage;\n\nvoid handleNode0Message(const uint8_t* data, uint8_t len) {}\nvoid handleNode1Message(const uint8_t* data, uint8_t len) {}\nvoid handleNode2Message(const uint8_t* data, uint8_t len) {}\nvoid handleDefaultMessage(const uint8_t* data, uint8_t len) {}\n\ntypedef void (*NodeMessageHandler)(const uint8_t* data, uint8_t len);\n\nvoid logGatewayEvent(const char* msg) {}\nvoid logGatewayError(const char* msg) {}\n\nstatic NodeMessageHandler g_nodeHandlers_fixed[MAX_ROUTABLE_NODES];\n\nNetworkMessage receiveNetworkMessage_fixed() {\n    NetworkMessage msg;\n    msg.destination_node_id = MAX_ROUTABLE_NODES;\n    msg.source_node_id = 0x01;\n    msg.payload[0] = 0xDE;\n    msg.payload_len = 1;\n    return msg;\n}\n\nvoid initializeGatewayHandlers_fixed() {\n    for (int i = 0; i < MAX_ROUTABLE_NODES; ++i) {\n        g_nodeHandlers_fixed[i] = handleDefaultMessage;\n    }\n    g_nodeHandlers_fixed[0] = handleNode0Message;\n    g_nodeHandlers_fixed[1] = handleNode1Message;\n    g_nodeHandlers_fixed[2] = handleNode2Message;\n    logGatewayEvent(\"Gateway handlers initialized (fixed).\");\n}\n\nvoid processIncomingNetworkMessage_fixed() {\n    NetworkMessage incoming_msg = receiveNetworkMessage_fixed();\n\n    NodeMessageHandler handler = NULL;\n\n    if (incoming_msg.destination_node_id < MAX_ROUTABLE_NODES) {\n        handler = g_nodeHandlers_fixed[incoming_msg.destination_node_id];\n    } else {\n        logGatewayError(\"Invalid destination node ID received. Index out of bounds.\");\n        handler = handleDefaultMessage;\n    }\n    \n    if (handler != NULL) {\n        handler(incoming_msg.payload, incoming_msg.payload_len);\n        logGatewayEvent(\"Message processed by handler (fixed).\");\n    } else {\n        logGatewayError(\"Handler is NULL (fixed), potential configuration error or invalid index.\");\n    }\n}\n\nvoid gatewayApplicationLoop_fixed() {\n    initializeGatewayHandlers_fixed();\n    processIncomingNetworkMessage_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdlib.h>\n#include <stdint.h>\n\n#define MAX_ERROR_DESC_LEN 64\n\ntypedef struct {\n    uint32_t errorCode;\n    uint8_t severity;\n    char description[MAX_ERROR_DESC_LEN];\n} DiagnosticErrorEntry;\n\nclass ErrorLogManager {\npublic:\n    ErrorLogManager() : current_capacity(0), num_errors(0), error_entries(NULL) {\n        current_capacity = 4;\n        error_entries = (DiagnosticErrorEntry*)malloc(current_capacity * sizeof(DiagnosticErrorEntry));\n        if (!error_entries) {\n            // Handle allocation failure\n        }\n    }\n\n    ~ErrorLogManager() {\n        if (error_entries) {\n            free(error_entries);\n            error_entries = NULL;\n        }\n    }\n\n    bool addErrorEntryVulnerable(uint32_t code, uint8_t sev, const char* desc) {\n        if (!desc) {\n            return false;\n        }\n\n        if (num_errors >= current_capacity) {\n            size_t new_capacity = current_capacity * 2;\n            DiagnosticErrorEntry* new_entries = (DiagnosticErrorEntry*)realloc(error_entries, new_capacity * sizeof(DiagnosticErrorEntry));\n            if (!new_entries) {\n                return false;\n            }\n            error_entries = new_entries;\n            current_capacity = new_capacity;\n        }\n\n        error_entries[num_errors].errorCode = code;\n        error_entries[num_errors].severity = sev;\n\n        size_t desc_idx = 0;\n        // Vulnerable: No bounds check for 'desc_idx' against 'MAX_ERROR_DESC_LEN'\n        while (desc[desc_idx] != '\\0') {\n            error_entries[num_errors].description[desc_idx] = desc[desc_idx];\n            desc_idx++;\n        }\n        // If 'desc' is too long, 'desc_idx' can exceed 'MAX_ERROR_DESC_LEN - 1',\n        // leading to writing past the end of the 'description' array in heap-allocated memory.\n        // The null terminator write may also be out of bounds if desc_idx == MAX_ERROR_DESC_LEN.\n        error_entries[num_errors].description[desc_idx] = '\\0';\n\n        num_errors++;\n        return true;\n    }\n\nprivate:\n    size_t current_capacity;\n    size_t num_errors;\n    DiagnosticErrorEntry* error_entries;\n};\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLES_FIXED 100\n\ntypedef struct {\n    uint32_t firmware_version;\n    uint8_t  diagnostic_mode;\n    bool     feature_X_enabled;\n    uint16_t checksum;\n} VehicleECUConfig_Fixed;\n\nstatic VehicleECUConfig_Fixed g_fleetECUConfigs_fixed[MAX_VEHICLES_FIXED];\n\nvoid ecuLog_fixed(const char* message) {\n}\n\ntypedef struct {\n    uint16_t command_id;\n    uint16_t start_vehicle_idx;\n    uint16_t num_vehicles_to_update;\n    VehicleECUConfig_Fixed config_data;\n} BatchUpdateCommand_Fixed;\n\nBatchUpdateCommand_Fixed receiveBatchUpdateCommand_fixed() {\n    BatchUpdateCommand_Fixed cmd;\n    cmd.command_id = 0x5001;\n    cmd.start_vehicle_idx = 90;\n    cmd.num_vehicles_to_update = 15;\n    cmd.config_data = (VehicleECUConfig_Fixed){\n        .firmware_version = 0x01020304,\n        .diagnostic_mode = 1,\n        .feature_X_enabled = true,\n        .checksum = 0xABCD\n    };\n    return cmd;\n}\n\nvoid initializeFleetConfigs_fixed() {\n    for (int i = 0; i < MAX_VEHICLES_FIXED; ++i) {\n        g_fleetECUConfigs_fixed[i] = (VehicleECUConfig_Fixed){\n            .firmware_version = 0x00000000,\n            .diagnostic_mode = 0,\n            .feature_X_enabled = false,\n            .checksum = 0x0000\n        };\n    }\n    ecuLog_fixed(\"Fleet ECU configurations initialized (fixed).\");\n}\n\nvoid processBatchECUConfigUpdate_fixed() {\n    BatchUpdateCommand_Fixed cmd = receiveBatchUpdateCommand_fixed();\n\n    if (cmd.command_id == 0x5001) {\n        uint16_t end_idx_exclusive = cmd.start_vehicle_idx + cmd.num_vehicles_to_update;\n\n        if (cmd.start_vehicle_idx < MAX_VEHICLES_FIXED && end_idx_exclusive <= MAX_VEHICLES_FIXED) {\n            for (uint16_t i = 0; i < cmd.num_vehicles_to_update; ++i) {\n                g_fleetECUConfigs_fixed[cmd.start_vehicle_idx + i] = cmd.config_data;\n            }\n            ecuLog_fixed(\"Batch ECU configuration update processed successfully (fixed).\");\n        } else {\n            ecuLog_fixed(\"Invalid range for batch ECU configuration update. Command ignored (fixed).\");\n        }\n    } else {\n        ecuLog_fixed(\"Unknown batch update command ID (fixed).\");\n    }\n}\n\nvoid mainECUController_fixed() {\n    initializeFleetConfigs_fixed();\n    processBatchECUConfigUpdate_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_TELEMATICS_PROFILES 5\n#define MAX_PROFILE_PARAMS_PER_TYPE 8\n#define CONFIG_DATA_SIZE 16\n\ntypedef struct {\n    uint16_t param_id;\n    uint8_t  data[CONFIG_DATA_SIZE];\n    uint32_t checksum;\n} TelematicsConfigParam;\n\ntypedef struct {\n    uint8_t profile_type_id;\n    uint8_t active_param_count;\n    TelematicsConfigParam params[MAX_PROFILE_PARAMS_PER_TYPE];\n} TelematicsProfile;\n\nstatic TelematicsProfile g_telematicsProfiles[MAX_TELEMATICS_PROFILES];\n\nvoid telematicsLogError_fixed(const char* message) {\n}\n\ntypedef struct {\n    uint8_t target_profile_idx;\n    uint8_t num_params_to_update;\n    TelematicsConfigParam param_updates[MAX_PROFILE_PARAMS_PER_TYPE + 1];\n} TelematicsConfigCommand_fixed;\n\nTelematicsConfigCommand_fixed receiveConfigCommand_fixed() {\n    TelematicsConfigCommand_fixed cmd;\n    cmd.target_profile_idx = 0;\n    cmd.num_params_to_update = MAX_PROFILE_PARAMS_PER_TYPE + 1;\n    \n    for (int i = 0; i < MAX_PROFILE_PARAMS_PER_TYPE + 1; ++i) {\n        cmd.param_updates[i].param_id = 0x1000 + i;\n        memset(cmd.param_updates[i].data, (uint8_t)i, CONFIG_DATA_SIZE);\n        cmd.param_updates[i].checksum = 0xDEADBEEF;\n    }\n    return cmd;\n}\n\nvoid initializeTelematicsProfiles_fixed() {\n    g_telematicsProfiles[0].profile_type_id = 0x01;\n    g_telematicsProfiles[0].active_param_count = 3;\n    for(int i = 0; i < 3; ++i) {\n        g_telematicsProfiles[0].params[i].param_id = 0x100 + i;\n        memset(g_telematicsProfiles[0].params[i].data, (uint8_t)(0xA0 + i), CONFIG_DATA_SIZE);\n        g_telematicsProfiles[0].params[i].checksum = 0xCCCCCCCC;\n    }\n    g_telematicsProfiles[1].profile_type_id = 0x02;\n    g_telematicsProfiles[1].active_param_count = 5;\n}\n\nvoid processTelematicsConfig_fixed() {\n    TelematicsConfigCommand_fixed cmd = receiveConfigCommand_fixed();\n\n    if (cmd.target_profile_idx < MAX_TELEMATICS_PROFILES) {\n        TelematicsProfile* profile = &g_telematicsProfiles[cmd.target_profile_idx];\n        \n        uint8_t actual_params_to_process = cmd.num_params_to_update;\n        if (actual_params_to_process > MAX_PROFILE_PARAMS_PER_TYPE) {\n            actual_params_to_process = MAX_PROFILE_PARAMS_PER_TYPE;\n            telematicsLogError_fixed(\"Attempted to update too many parameters. Truncating (fixed).\");\n        }\n\n        for (int i = 0; i < actual_params_to_process; ++i) {\n            profile->params[i] = cmd.param_updates[i];\n        }\n        telematicsLogError_fixed(\"Telematics profile updated (fixed).\");\n    } else {\n        telematicsLogError_fixed(\"Invalid telematics profile index received (fixed).\");\n    }\n}\n\nvoid telematicsManagerMain_fixed() {\n    initializeTelematicsProfiles_fixed();\n    processTelematicsConfig_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n// Define sizes for buffers and maximums\n#define MAX_COMMAND_PAYLOAD_SIZE 128\n#define COMMAND_FRAME_HEADER_SIZE (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t)) // command_id + payload_length + reserved_byte\n#define COMMAND_BUFFER_TOTAL_SIZE 256 // Total buffer for received raw command data\n\n// Structure representing the layout of a diagnostic command frame\n// This is used for interpretation of the raw byte stream\ntypedef struct {\n    uint16_t command_id;      // Unique identifier for the command\n    uint8_t  payload_length;  // Actual length of the payload data\n    uint8_t  reserved_byte;   // Reserved for future use or alignment\n    // The 'payload' and 'final_status_marker' fields are conceptual for layout.\n    // The actual payload size varies, and final_status_marker is placed based on payload_length.\n    uint8_t  payload[MAX_COMMAND_PAYLOAD_SIZE]; // Placeholder for payload data\n    uint8_t  final_status_marker; // A byte that's expected to be written at the end of the payload section\n} DiagnosticCommandFrame;\n\n// Global buffer to hold raw received command data\nstatic uint8_t g_rx_command_buffer[COMMAND_BUFFER_TOTAL_SIZE];\n// Current valid length of data in g_rx_command_buffer\nstatic uint32_t g_rx_data_length = 0;\n\n// Function to simulate receiving raw command data into the buffer\nvoid receive_raw_command(const uint8_t* data, uint32_t len) {\n    if (len > COMMAND_BUFFER_TOTAL_SIZE) {\n        len = COMMAND_BUFFER_TOTAL_SIZE;\n    }\n    memcpy(g_rx_command_buffer, data, len);\n    g_rx_data_length = len;\n}\n\n// Dummy function to simulate processing a command frame\nvoid process_parsed_command(const DiagnosticCommandFrame* frame) {\n    // In a real system, this would parse and execute the command logic\n    // For demonstration, we just access a member to avoid unused variable warnings\n    volatile uint16_t cmd_id = frame->command_id;\n    (void)cmd_id;\n}\n\n// Vulnerable function: Updates a status byte at a calculated position relative to the end of the command's payload.\n// The 'external_status_offset' is provided by a higher layer, potentially influenced by external input.\n// The vulnerability arises if 'external_status_offset' is large enough to make the calculated\n// target index negative, leading to a buffer underwrite.\nvoid update_command_final_status_vulnerable(uint8_t status_value, uint8_t external_status_offset) {\n    // Ensure at least header size is present before accessing frame fields\n    if (g_rx_data_length < COMMAND_FRAME_HEADER_SIZE) {\n        return;\n    }\n\n    // Cast the raw buffer to the frame structure for easier field access\n    DiagnosticCommandFrame* current_frame = (DiagnosticCommandFrame*)g_rx_command_buffer;\n\n    // Get the effective payload length from the received command data. This value is attacker-controlled.\n    uint8_t effective_payload_len = current_frame->payload_length;\n\n    // Calculate the intended base position for the status byte:\n    // This is the start of the buffer + size of header + effective payload length.\n    // From this base, 'external_status_offset' moves the write position backwards.\n    // Example: If payload_length is 0, base_pos is COMMAND_FRAME_HEADER_SIZE (4 bytes).\n    // If external_status_offset is 5, target_idx becomes 4 - 5 = -1.\n    // No bounds check on effective_payload_len or the resulting target_idx.\n    int32_t target_idx = (int32_t)(COMMAND_FRAME_HEADER_SIZE + effective_payload_len) - external_status_offset;\n\n    // Perform the write operation directly to the raw buffer.\n    // This is where the buffer underwrite occurs if target_idx is negative.\n    g_rx_command_buffer[target_idx] = status_value;\n\n    // Simulate subsequent command processing\n    process_parsed_command(current_frame);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n\n// Maximum allowed length for a sanitized string in the UI\n#define MAX_SANITIZED_STRING_LENGTH 2048\n\n// Represents a diagnostic log message structure received from a vehicle ECU\nstruct DiagnosticLogMessage {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t raw_string_length; // Length of the raw description string\n    // raw_description_data follows this struct in the packet\n};\n\n// Represents a processed, sanitized log entry\nstruct SanitizedLogEntry {\n    uint32_t timestamp;\n    uint16_t event_id;\n    char*    sanitized_description; // Heap-allocated, null-terminated\n};\n\nclass TelemetryLogProcessor {\npublic:\n    TelemetryLogProcessor() {}\n\n    ~TelemetryLogProcessor() {\n        clearProcessedLogs();\n    }\n\n    void clearProcessedLogs() {\n        for (auto& entry : m_processed_entries) {\n            if (entry.sanitized_description) {\n                free(entry.sanitized_description);\n            }\n        }\n        m_processed_entries.clear();\n    }\n\n    // Vulnerable function\n    // Parses a raw packet containing multiple diagnostic log messages\n    // and sanitizes their descriptions for display.\n    bool processRawTelemetryLogsVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticLogMessage)) {\n            return false;\n        }\n\n        clearProcessedLogs();\n\n        size_t current_offset = 0;\n\n        while (current_offset + sizeof(DiagnosticLogMessage) <= packet_len) {\n            const DiagnosticLogMessage* msg_header = reinterpret_cast<const DiagnosticLogMessage*>(raw_packet + current_offset);\n            \n            // Check if the claimed raw_string_length extends beyond the packet boundary\n            if (current_offset + sizeof(DiagnosticLogMessage) + msg_header->raw_string_length > packet_len) {\n                clearProcessedLogs();\n                return false;\n            }\n\n            // Vulnerability: Allocation based on raw_string_length + 1 (for null terminator).\n            // This does not account for character expansion during sanitization.\n            size_t allocated_desc_len = msg_header->raw_string_length + 1;\n            if (allocated_desc_len > MAX_SANITIZED_STRING_LENGTH) {\n                allocated_desc_len = MAX_SANITIZED_STRING_LENGTH;\n            }\n            if (allocated_desc_len == 0) allocated_desc_len = 1; // At least space for null terminator\n\n            char* sanitized_buffer = (char*)malloc(allocated_desc_len);\n            if (!sanitized_buffer) {\n                clearProcessedLogs();\n                return false;\n            }\n\n            SanitizedLogEntry new_entry;\n            new_entry.timestamp = msg_header->timestamp;\n            new_entry.event_id = msg_header->event_id;\n            new_entry.sanitized_description = sanitized_buffer;\n\n            const uint8_t* raw_desc_ptr = raw_packet + current_offset + sizeof(DiagnosticLogMessage);\n            size_t current_sanitized_pos = 0;\n\n            // Loop iterates 'raw_string_length' times.\n            // If a character expands (e.g., '\\n' -> '\\\\n' or 0x01 -> '[01]'), \n            // current_sanitized_pos increments by more than 1. This can exceed \n            // 'allocated_desc_len' before the loop finishes, leading to a heap overflow.\n            for (uint16_t i = 0; i < msg_header->raw_string_length; ++i) {\n                uint8_t char_code = raw_desc_ptr[i];\n\n                if (char_code >= 0x20 && char_code <= 0x7E) { // Printable ASCII\n                    sanitized_buffer[current_sanitized_pos++] = static_cast<char>(char_code);\n                } else {\n                    // Non-printable or control character. These expansions cause the overflow.\n                    if (char_code == '\\n') {\n                        sanitized_buffer[current_sanitized_pos++] = '\\\\';\n                        sanitized_buffer[current_sanitized_pos++] = 'n';\n                    } else if (char_code == '\\r') {\n                        sanitized_buffer[current_sanitized_pos++] = '\\\\';\n                        sanitized_buffer[current_sanitized_pos++] = 'r';\n                    } else if (char_code == '\\t') {\n                        sanitized_buffer[current_sanitized_pos++] = '\\\\';\n                        sanitized_buffer[current_sanitized_pos++] = 't';\n                    } else {\n                        // This specific expansion (e.g., 0x01 -> \"[01]\") leads to 4 characters.\n                        // If the raw string contains many such characters and allocated_desc_len\n                        // only accounts for 1:1 or 2:1 expansion, this will cause the heap overflow.\n                        sanitized_buffer[current_sanitized_pos++] = '[';\n                        sanitized_buffer[current_sanitized_pos++] = (char_code / 16 < 10 ? '0' + char_code / 16 : 'A' + char_code / 16 - 10);\n                        sanitized_buffer[current_sanitized_pos++] = (char_code % 16 < 10 ? '0' + char_code % 16 : 'A' + char_code % 16 - 10);\n                        sanitized_buffer[current_sanitized_pos++] = ']';\n                    }\n                }\n            }\n            sanitized_buffer[current_sanitized_pos] = '\\0'; // Null-terminate, potentially overflowing if loop already wrote past buffer\n\n            m_processed_entries.push_back(new_entry);\n\n            current_offset += sizeof(DiagnosticLogMessage) + msg_header->raw_string_length;\n        }\n\n        return true;\n    }\n\n    const std::vector<SanitizedLogEntry>& getProcessedEntries() const {\n        return m_processed_entries;\n    }\n\nprivate:\n    std::vector<SanitizedLogEntry> m_processed_entries;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_CAN_FRAME_DATA_LENGTH 8\n#define VEHICLE_STATE_SENSOR_ID 0x01\n#define TIRE_PRESSURE_SENSOR_ID 0x02\n#define FUEL_LEVEL_SENSOR_ID 0x03\n#define VEHICLE_DIAGNOSTIC_DATA_ID 0x04\n\n#define MAX_SENSOR_DATA_PAYLOAD 60 \n\n#define DIAGNOSTIC_STRING_BUFFER_SIZE 30\n\ntypedef struct {\n    uint8_t sensor_id;\n    uint8_t data_length; \n    uint8_t data[MAX_SENSOR_DATA_PAYLOAD]; \n} SensorPacketSegment;\n\nint processSensorTelemetryStream(const uint8_t* msg_buffer, uint16_t msg_len) {\n    if (msg_buffer == NULL || msg_len < (sizeof(uint8_t) * 2)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    while (current_offset < msg_len) {\n        if (current_offset + sizeof(uint8_t) * 2 > msg_len) {\n            return -2;\n        }\n\n        uint8_t sensor_id = msg_buffer[current_offset];\n        uint8_t data_len = msg_buffer[current_offset + 1];\n\n        if (current_offset + sizeof(uint8_t) * 2 + data_len > msg_len) {\n            return -3;\n        }\n        \n        const uint8_t* sensor_data_ptr = msg_buffer + current_offset + sizeof(uint8_t) * 2;\n\n        if (sensor_id == VEHICLE_DIAGNOSTIC_DATA_ID) {\n            char diagnostic_buffer[DIAGNOSTIC_STRING_BUFFER_SIZE];\n            memset(diagnostic_buffer, 0, DIAGNOSTIC_STRING_BUFFER_SIZE); \n\n            uint8_t bytes_to_copy = data_len;\n            if (bytes_to_copy >= DIAGNOSTIC_STRING_BUFFER_SIZE) {\n                bytes_to_copy = DIAGNOSTIC_STRING_BUFFER_SIZE - 1; \n            }\n\n            for (int i = 0; i < bytes_to_copy; ++i) {\n                diagnostic_buffer[i] = (char)sensor_data_ptr[i];\n            }\n            diagnostic_buffer[bytes_to_copy] = '\\0'; \n\n        }\n\n        current_offset += (sizeof(uint8_t) * 2 + data_len);\n    }\n\n    return 0;\n}\n\nvoid handleTelemetryStream(const uint8_t* stream, uint16_t len) {\n    processSensorTelemetryStream(stream, len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_EVENT_BUFFER_SIZE_FIXED 512\n\nstatic uint8_t g_event_data_buffer_fixed[MAX_EVENT_BUFFER_SIZE_FIXED];\nstatic int32_t g_current_event_sequence_start_fixed = 0;\nstatic uint16_t g_active_buffer_length_fixed = 0;\n\nvoid init_event_recorder_fixed() {\n    memset(g_event_data_buffer_fixed, 0, MAX_EVENT_BUFFER_SIZE_FIXED);\n    g_current_event_sequence_start_fixed = 0;\n    g_active_buffer_length_fixed = 0;\n}\n\nbool record_raw_event_data_fixed(const uint8_t* data, uint16_t len) {\n    if (len == 0 || data == NULL) return false;\n    if (g_active_buffer_length_fixed + len > MAX_EVENT_BUFFER_SIZE_FIXED) {\n        return false;\n    }\n    memcpy(g_event_data_buffer_fixed + g_active_buffer_length_fixed, data, len);\n    g_active_buffer_length_fixed += len;\n    return true;\n}\n\nconst uint8_t* get_event_data_at_offset_fixed(int32_t offset, uint16_t* len) {\n    if (offset < 0 || offset >= g_active_buffer_length_fixed) {\n        if (len) *len = 0;\n        return NULL;\n    }\n    if (len) *len = (uint16_t)(g_active_buffer_length_fixed - offset);\n    return g_event_data_buffer_fixed + offset;\n}\n\nvoid set_event_sequence_start_backward_fixed(uint16_t relative_back_offset_bytes) {\n    int32_t proposed_offset = g_current_event_sequence_start_fixed - relative_back_offset_bytes;\n\n    if (proposed_offset < 0) {\n        g_current_event_sequence_start_fixed = 0;\n    } else {\n        g_current_event_sequence_start_fixed = proposed_offset;\n    }\n}\n\nvoid mark_current_event_status_fixed(uint8_t status_code) {\n    if (g_current_event_sequence_start_fixed < 0 || g_current_event_sequence_start_fixed >= MAX_EVENT_BUFFER_SIZE_FIXED) {\n        return;\n    }\n    g_event_data_buffer_fixed[g_current_event_sequence_start_fixed] = status_code;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_CAN_MESSAGE_HANDLERS 10\n#define NUM_INITIALIZED_HANDLERS 5\n\ntypedef struct {\n    uint16_t id;\n    uint8_t data[8];\n    uint8_t length;\n} CanFrame;\n\ntypedef void (*CanMessageHandler)(uint16_t message_id, const uint8_t* data, uint8_t length);\n\ntypedef struct {\n    CanMessageHandler func;\n    bool is_active;\n} HandlerEntry;\n\nstatic HandlerEntry g_canMessageDispatchTable[MAX_CAN_MESSAGE_HANDLERS];\n\nvoid logCanEvent(const char* msg) {\n    printf(\"CAN_LOG: %s\\n\", msg);\n}\n\nvoid logCanError(const char* msg) {\n    printf(\"CAN_ERROR: %s\\n\", msg);\n}\n\nvoid handleEngineData(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Engine data processed.\");\n}\n\nvoid handleBrakeStatus(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Brake status processed.\");\n}\n\nvoid handleSteeringAngle(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Steering angle processed.\");\n}\n\nvoid handleVehicleSpeed(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Vehicle speed processed.\");\n}\n\nvoid handleDoorLockStatus(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Door lock status processed.\");\n}\n\nvoid handleCriticalSystemReset(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanError(\"SECURITY ALERT: Critical system reset attempted via CAN message!\");\n}\n\nvoid initializeCanDispatchTable_fixed() {\n    g_canMessageDispatchTable[0].func = handleEngineData;\n    g_canMessageDispatchTable[0].is_active = true;\n\n    g_canMessageDispatchTable[1].func = handleBrakeStatus;\n    g_canMessageDispatchTable[1].is_active = true;\n\n    g_canMessageDispatchTable[2].func = handleSteeringAngle;\n    g_canMessageDispatchTable[2].is_active = true;\n\n    g_canMessageDispatchTable[3].func = handleVehicleSpeed;\n    g_canMessageDispatchTable[3].is_active = true;\n\n    g_canMessageDispatchTable[4].func = handleDoorLockStatus;\n    g_canMessageDispatchTable[4].is_active = true;\n\n    g_canMessageDispatchTable[7].func = handleCriticalSystemReset;\n    g_canMessageDispatchTable[7].is_active = false;\n\n    for (int i = NUM_INITIALIZED_HANDLERS; i < MAX_CAN_MESSAGE_HANDLERS; ++i) {\n        if (i != 7) {\n            g_canMessageDispatchTable[i].func = NULL;\n            g_canMessageDispatchTable[i].is_active = false;\n        }\n    }\n    logCanEvent(\"CAN message dispatch table initialized (fixed).\");\n}\n\nCanFrame receiveSimulatedCanFrame_fixed() {\n    CanFrame frame;\n    frame.id = 7;\n    frame.data[0] = 0xDE;\n    frame.data[1] = 0xAD;\n    frame.length = 2;\n    logCanEvent(\"Simulated CAN frame received for ID 7.\");\n    return frame;\n}\n\nvoid processCanFrame_fixed() {\n    CanFrame frame = receiveSimulatedCanFrame_fixed();\n\n    if (frame.id < MAX_CAN_MESSAGE_HANDLERS && g_canMessageDispatchTable[frame.id].is_active) {\n        CanMessageHandler handler = g_canMessageDispatchTable[frame.id].func;\n        if (handler != NULL) {\n            handler(frame.id, frame.data, frame.length);\n        } else {\n            logCanError(\"Received CAN message for unhandled ID (NULL handler, despite being marked active).\");\n        }\n    } else {\n        logCanError(\"Received CAN message with invalid or inactive handler ID.\");\n    }\n}\n\nvoid canBusManager_fixed_main() {\n    initializeCanDispatchTable_fixed();\n    processCanFrame_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_FRAME_BUFFER_SIZE 256\n#define MAX_ERROR_MESSAGE_LEN 60\n\n// Fixed offsets and sizes for telemetry frame components\n#define FRAME_HEADER_SIZE 4\n#define SENSOR_DATA_BLOCK_OFFSET FRAME_HEADER_SIZE\n#define SENSOR_DATA_BLOCK_SIZE 200\n#define ERROR_MESSAGE_OFFSET (SENSOR_DATA_BLOCK_OFFSET + SENSOR_DATA_BLOCK_SIZE)\n\n// Global buffer for assembling the telemetry frame\nstatic uint8_t g_telemetryFrameBuffer[TELEMETRY_FRAME_BUFFER_SIZE];\n\nvoid initTelemetryFrameAssembler() {\n    memset(g_telemetryFrameBuffer, 0, TELEMETRY_FRAME_BUFFER_SIZE);\n}\n\n// Function to assemble a telemetry frame containing header, sensor data, and an error message.\n// sensor_data: Pointer to a fixed-size block of sensor readings.\n// error_msg: Pointer to a null-terminated error message string.\n// msg_len: The actual length of the error message (excluding null terminator).\n//\n// The frame structure is [Header (4 bytes)] [Sensor Data (200 bytes)] [Error Message (variable, up to MAX_ERROR_MESSAGE_LEN)]\n//\n// FIX: Introduce a comprehensive bounds check for the error message segment\n// to ensure it does not overflow the global telemetry buffer.\nint assembleTelemetryFrame(const uint8_t* sensor_data, const char* error_msg, uint8_t msg_len) {\n    if (sensor_data == NULL || error_msg == NULL) {\n        return -1; // Invalid input\n    }\n\n    // Populate fixed header fields\n    g_telemetryFrameBuffer[0] = 0xAA;\n    g_telemetryFrameBuffer[1] = 0x55;\n    g_telemetryFrameBuffer[2] = 0x01;\n    // Update total frame length field based on the 'actual_msg_len_to_copy'\n    g_telemetryFrameBuffer[3] = (uint8_t)(FRAME_HEADER_SIZE + SENSOR_DATA_BLOCK_SIZE + msg_len);\n\n    // Copy sensor data block\n    // Assumes sensor_data is at least SENSOR_DATA_BLOCK_SIZE bytes\n    for (uint8_t i = 0; i < SENSOR_DATA_BLOCK_SIZE; ++i) {\n        g_telemetryFrameBuffer[SENSOR_DATA_BLOCK_OFFSET + i] = sensor_data[i];\n    }\n\n    // Determine the actual number of bytes to copy for the error message.\n    // It must not exceed MAX_ERROR_MESSAGE_LEN AND must fit within the remaining buffer space.\n    uint8_t actual_msg_len_to_copy = msg_len;\n\n    if (actual_msg_len_to_copy > MAX_ERROR_MESSAGE_LEN) {\n        actual_msg_len_to_copy = MAX_ERROR_MESSAGE_LEN;\n    }\n\n    // Calculate the maximum number of bytes that can actually fit from ERROR_MESSAGE_OFFSET\n    // to the end of the telemetry buffer.\n    uint16_t available_space_for_error_msg = 0;\n    if (TELEMETRY_FRAME_BUFFER_SIZE > ERROR_MESSAGE_OFFSET) {\n        available_space_for_error_msg = TELEMETRY_FRAME_BUFFER_SIZE - ERROR_MESSAGE_OFFSET;\n    }\n\n    if (actual_msg_len_to_copy > available_space_for_error_msg) {\n        actual_msg_len_to_copy = (uint8_t)available_space_for_error_msg;\n    }\n\n    // Copy error message data into the telemetry frame using the safe length.\n    for (uint8_t i = 0; i < actual_msg_len_to_copy; ++i) {\n        g_telemetryFrameBuffer[ERROR_MESSAGE_OFFSET + i] = (uint8_t)error_msg[i];\n    }\n\n    // Update the total frame length in the header with the actual copied length\n    g_telemetryFrameBuffer[3] = (uint8_t)(FRAME_HEADER_SIZE + SENSOR_DATA_BLOCK_SIZE + actual_msg_len_to_copy);\n\n    return 0; // Success\n}\n\n// Dummy function to simulate receiving data from an internal module\nvoid simulateDataReception(const uint8_t* s_data, const char* e_msg, uint8_t e_len) {\n    assembleTelemetryFrame(s_data, e_msg, e_len);\n}\n\n// Dummy function to retrieve a byte from the assembled frame\nuint8_t getFrameByte(uint16_t index) {\n    if (index < TELEMETRY_FRAME_BUFFER_SIZE) {\n        return g_telemetryFrameBuffer[index];\n    }\n    return 0xFF; // Out of bounds read indication\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define ENGINE_PARAM_MAP_SIZE 256\n#define MAX_PARAM_UPDATE_LENGTH 64\n\nstatic uint8_t g_engineParamMap[ENGINE_PARAM_MAP_SIZE];\n\nvoid initializeEngineParameters() {\n    memset(g_engineParamMap, 0x00, ENGINE_PARAM_MAP_SIZE);\n    for (uint16_t i = 0; i < ENGINE_PARAM_MAP_SIZE; ++i) {\n        g_engineParamMap[i] = (uint8_t)(i % 0xFF);\n    }\n}\n\nint updateEngineParameterSegment(uint8_t param_offset, const uint8_t* update_data, uint8_t update_len) {\n    if (update_data == NULL || update_len == 0) {\n        return -1;\n    }\n\n    if (param_offset >= ENGINE_PARAM_MAP_SIZE) {\n        return -2;\n    }\n\n    if (update_len > MAX_PARAM_UPDATE_LENGTH) {\n        return -3;\n    }\n\n    for (uint8_t i = 0; i < update_len; ++i) {\n        g_engineParamMap[param_offset + i] = update_data[i];\n    }\n\n    return 0;\n}\n\nvoid handleParamUpdateMessage(uint8_t offset, const uint8_t* data, uint8_t len) {\n    updateEngineParameterSegment(offset, data, len);\n}\n\nuint8_t getEngineParameter(uint8_t index) {\n    if (index < ENGINE_PARAM_MAP_SIZE) {\n        return g_engineParamMap[index];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define GLOBAL_CONFIG_BUFFER_SIZE 512\n\nstatic uint8_t g_vehicleConfiguration[GLOBAL_CONFIG_BUFFER_SIZE];\n\ntypedef struct {\n    uint16_t param_did;\n    uint16_t offset_in_buffer;\n    uint16_t param_size;\n} ConfigurationParameterInfo;\n\nstatic const ConfigurationParameterInfo g_configParams[] = {\n    {0x1001, 0,    128},\n    {0x1002, 128,  64},\n    {0x1003, 192,  32},\n    {0x1004, 224,  256}\n};\n#define NUM_CONFIG_PARAMS (sizeof(g_configParams) / sizeof(g_configParams[0]))\n\nvoid initVehicleConfiguration() {\n    memset(g_vehicleConfiguration, 0, GLOBAL_CONFIG_BUFFER_SIZE);\n    for (uint16_t i = 0; i < GLOBAL_CONFIG_BUFFER_SIZE; ++i) {\n        g_vehicleConfiguration[i] = (uint8_t)(i % 256);\n    }\n}\n\nint updateConfigurationSegment(uint16_t did, uint16_t segment_offset, uint16_t segment_length, const uint8_t* data) {\n    if (data == NULL || segment_length == 0) {\n        return -1;\n    }\n\n    uint16_t param_idx = (uint16_t)-1;\n    for (uint16_t i = 0; i < NUM_CONFIG_PARAMS; ++i) {\n        if (g_configParams[i].param_did == did) {\n            param_idx = i;\n            break;\n        }\n    }\n\n    if (param_idx == (uint16_t)-1) {\n        return -2;\n    }\n\n    const ConfigurationParameterInfo* param_info = &g_configParams[param_idx];\n\n    if (segment_offset >= param_info->param_size) {\n        return -3;\n    }\n\n    uint16_t dest_abs_offset = param_info->offset_in_buffer + segment_offset;\n\n    for (uint16_t i = 0; i < segment_length; ++i) {\n        g_vehicleConfiguration[dest_abs_offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid handleDiagnosticRequest(uint16_t did, uint16_t offset, uint16_t len, const uint8_t* payload) {\n    updateConfigurationSegment(did, offset, len, payload);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_PACKET_PAYLOAD_SIZE 500\n#define TELEMETRY_HEADER_SIZE 5\n\n#define TEMP_DISPLAY_BUFFER_CAPACITY 80\n\ntypedef enum {\n    TELEMETRY_TYPE_INVALID = 0x00,\n    TELEMETRY_TYPE_SENSOR_READING = 0x01,\n    TELEMETRY_TYPE_EVENT_LOG = 0x02,\n    TELEMETRY_TYPE_DIAGNOSTIC_FAULT = 0x03\n} TelemetryPacketType;\n\nvoid displayEventDescription(const uint8_t* description_data, uint8_t description_len) {\n    char temp_display_buffer[TEMP_DISPLAY_BUFFER_CAPACITY];\n\n    if (description_data == NULL) {\n        return;\n    }\n\n    uint8_t bytes_to_copy = description_len;\n    if (bytes_to_copy >= TEMP_DISPLAY_BUFFER_CAPACITY) {\n        bytes_to_copy = TEMP_DISPLAY_BUFFER_CAPACITY - 1;\n    }\n    \n    memcpy(temp_display_buffer, description_data, bytes_to_copy);\n    temp_display_buffer[bytes_to_copy] = '\\0';\n}\n\nint handleIncomingTelemetryFrame(const uint8_t* frame_data, uint16_t frame_len) {\n    if (frame_data == NULL || frame_len < TELEMETRY_HEADER_SIZE) {\n        return -1;\n    }\n\n    uint16_t packet_id = (frame_data[0] << 8) | frame_data[1];\n    uint8_t packet_type = frame_data[2];\n    uint16_t payload_len = (frame_data[3] << 8) | frame_data[4];\n\n    if (TELEMETRY_HEADER_SIZE + payload_len > frame_len) {\n        return -1;\n    }\n\n    if (payload_len > MAX_PACKET_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    const uint8_t* payload_ptr = frame_data + TELEMETRY_HEADER_SIZE;\n\n    switch (packet_type) {\n        case TELEMETRY_TYPE_EVENT_LOG: {\n            uint16_t min_event_payload_size = sizeof(uint32_t) + sizeof(uint16_t) + sizeof(uint8_t);\n            if (payload_len < min_event_payload_size) {\n                return -1;\n            }\n\n            uint32_t timestamp = (payload_ptr[0] << 24) | (payload_ptr[1] << 16) |\n                                 (payload_ptr[2] << 8) | payload_ptr[3];\n            uint16_t event_code = (payload_ptr[4] << 8) | payload_ptr[5];\n            uint8_t description_len = payload_ptr[6];\n\n            if (description_len > (payload_len - min_event_payload_size)) {\n                return -1;\n            }\n\n            const uint8_t* description_ptr = payload_ptr + min_event_payload_size;\n\n            displayEventDescription(description_ptr, description_len);\n            break;\n        }\n        case TELEMETRY_TYPE_SENSOR_READING:\n            break;\n        case TELEMETRY_TYPE_DIAGNOSTIC_FAULT:\n            break;\n        default:\n            return -1;\n    }\n\n    return 0;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_TOTAL_PARAMETERS 100\n#define MAX_SUBSYSTEMS 3 \n\ntypedef uint16_t VehicleParameterValue_Vulnerable;\n\nstatic VehicleParameterValue_Vulnerable g_allVehicleParameters_vulnerable[MAX_TOTAL_PARAMETERS];\n\nstatic uint8_t g_subsystemParameterOffsets_vulnerable[MAX_SUBSYSTEMS]; \nstatic uint8_t g_subsystemParameterCounts_vulnerable[MAX_SUBSYSTEMS];   \n\nvoid logVehicleStatus_vulnerable(const char* msg) {\n    printf(\"STATUS VULN: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t subsystem_id;\n    uint8_t parameter_index;\n} StatusRequest_Vulnerable;\n\nStatusRequest_Vulnerable receiveStatusRequest_vulnerable() {\n    StatusRequest_Vulnerable req;\n    req.subsystem_id = 3; \n    req.parameter_index = 0; \n    return req;\n}\n\nvoid initializeVehicleParameters_vulnerable() {\n    for (int i = 0; i < MAX_TOTAL_PARAMETERS; ++i) {\n        g_allVehicleParameters_vulnerable[i] = (uint16_t)(i * 10);\n    }\n\n    g_subsystemParameterOffsets_vulnerable[0] = 0;  \n    g_subsystemParameterCounts_vulnerable[0] = 20;  \n\n    g_subsystemParameterOffsets_vulnerable[1] = 20; \n    g_subsystemParameterCounts_vulnerable[1] = 15;  \n\n    g_subsystemParameterOffsets_vulnerable[2] = 35; \n    g_subsystemParameterCounts_vulnerable[2] = 10;  \n\n    logVehicleStatus_vulnerable(\"Vehicle parameters initialized.\");\n}\n\nuint16_t getVehicleParameter_vulnerable(uint8_t subsystem_id, uint8_t param_idx) {\n    logVehicleStatus_vulnerable(\"Attempting to get vehicle parameter.\");\n\n    uint8_t base_offset = g_subsystemParameterOffsets_vulnerable[subsystem_id]; \n    uint8_t param_count = g_subsystemParameterCounts_vulnerable[subsystem_id];   \n\n    if (param_idx < param_count) {\n        uint16_t value = g_allVehicleParameters_vulnerable[base_offset + param_idx];\n        printf(\"STATUS VULN: Read parameter [subsystem=%u, index=%u]: %u\\n\", subsystem_id, param_idx, value);\n        return value;\n    } else {\n        logVehicleStatus_vulnerable(\"Parameter index out of bounds for the specified subsystem (or corrupted).\");\n        return 0xFFFF;\n    }\n}\n\nvoid vehicleStatusModule_vulnerable_main() {\n    initializeVehicleParameters_vulnerable();\n    StatusRequest_Vulnerable req = receiveStatusRequest_vulnerable();\n    getVehicleParameter_vulnerable(req.subsystem_id, req.parameter_index);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_BUFFER_SIZE 256\n#define MAX_TELEMETRY_PACKET_SIZE 512\n\nstatic uint8_t g_telemetryBuffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_telemetryCurrentOffset = 0;\n\ntypedef struct {\n    uint8_t sensor_id;\n    uint8_t data_type;\n    uint16_t data_len;\n} TelemetryDataHeader;\n\nvoid initTelemetryAggregator() {\n    memset(g_telemetryBuffer, 0x00, TELEMETRY_BUFFER_SIZE);\n    g_telemetryCurrentOffset = 0;\n}\n\nint appendSingleTelemetryEntry(const uint8_t* raw_entry_data, uint16_t raw_entry_len) {\n    if (raw_entry_data == NULL || raw_entry_len < sizeof(TelemetryDataHeader)) {\n        return -1;\n    }\n\n    uint8_t sensor_id = raw_entry_data[0];\n    uint8_t data_type = raw_entry_data[1];\n    uint16_t received_data_len = (raw_entry_data[2] << 8) | raw_entry_data[3];\n    const uint8_t* actual_data_ptr = raw_entry_data + sizeof(TelemetryDataHeader);\n\n    if (sizeof(TelemetryDataHeader) + received_data_len > raw_entry_len) {\n        return -2;\n    }\n\n    uint16_t entry_total_size = sizeof(TelemetryDataHeader) + received_data_len;\n\n    if (g_telemetryCurrentOffset + entry_total_size > TELEMETRY_BUFFER_SIZE) {\n        return -3;\n    }\n\n    uint8_t* write_ptr = g_telemetryBuffer + g_telemetryCurrentOffset;\n    *write_ptr++ = sensor_id;\n    *write_ptr++ = data_type;\n    *write_ptr++ = (uint8_t)(received_data_len >> 8);\n    *write_ptr++ = (uint8_t)(received_data_len & 0xFF);\n\n    for (uint16_t i = 0; i < received_data_len; ++i) {\n        *write_ptr++ = actual_data_ptr[i];\n    }\n\n    g_telemetryCurrentOffset += entry_total_size;\n\n    return 0;\n}\n\nint processTelemetryPacket(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len == 0) {\n        return -1;\n    }\n    if (packet_len > MAX_TELEMETRY_PACKET_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_packet_offset = 0;\n    while (current_packet_offset < packet_len) {\n        if (current_packet_offset + sizeof(TelemetryDataHeader) > packet_len) {\n            return -2;\n        }\n\n        uint16_t entry_data_len_in_header = (packet_data[current_packet_offset + 2] << 8) | packet_data[current_packet_offset + 3];\n        uint16_t entry_expected_total_len = sizeof(TelemetryDataHeader) + entry_data_len_in_header;\n\n        if (current_packet_offset + entry_expected_total_len > packet_len) {\n            return -3;\n        }\n\n        int result = appendSingleTelemetryEntry(packet_data + current_packet_offset, entry_expected_total_len);\n        if (result != 0) {\n            return result;\n        }\n        current_packet_offset += entry_expected_total_len;\n    }\n    return 0;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <limits>\n\nstruct SensorSample {\n    uint32_t timestamp;\n    int16_t  value_x;\n    int16_t  value_y;\n    int16_t  value_z;\n    uint8_t  status;\n};\n\nstruct SensorPacketHeader {\n    uint16_t packet_id;\n    uint32_t offset_in_total_stream;\n    uint32_t num_samples_in_packet;\n};\n\nclass SensorDataRecorderFixed {\npublic:\n    SensorDataRecorderFixed(size_t max_recording_bytes)\n        : m_recording_buffer(nullptr), m_allocated_size(0) {\n        if (max_recording_bytes > 0) {\n            m_recording_buffer = (uint8_t*)malloc(max_recording_bytes);\n            if (m_recording_buffer) {\n                m_allocated_size = max_recording_bytes;\n            }\n        }\n    }\n\n    ~SensorDataRecorderFixed() {\n        if (m_recording_buffer) {\n            free(m_recording_buffer);\n            m_recording_buffer = nullptr;\n        }\n    }\n\n    bool processSensorDataPacketFixed(const uint8_t* packet_data, size_t packet_len) {\n        if (!packet_data || packet_len < sizeof(SensorPacketHeader)) {\n            return false;\n        }\n\n        const SensorPacketHeader* header = reinterpret_cast<const SensorPacketHeader*>(packet_data);\n\n        size_t samples_data_length;\n        if (header->num_samples_in_packet > std::numeric_limits<size_t>::max() / sizeof(SensorSample)) {\n            return false;\n        }\n        samples_data_length = (size_t)header->num_samples_in_packet * sizeof(SensorSample);\n\n        size_t dest_offset = header->offset_in_total_stream;\n\n        if (dest_offset > std::numeric_limits<size_t>::max() - samples_data_length) {\n            return false;\n        }\n        size_t end_write_pos = dest_offset + samples_data_length;\n\n        if (end_write_pos > m_allocated_size) {\n            return false;\n        }\n\n        if (packet_len < sizeof(SensorPacketHeader) + samples_data_length) {\n            return false;\n        }\n\n        size_t source_data_read_offset = sizeof(SensorPacketHeader);\n\n        for (uint32_t i = 0; i < header->num_samples_in_packet; ++i) {\n            size_t current_sample_size = sizeof(SensorSample);\n            \n            size_t current_source_pos = source_data_read_offset + (size_t)i * current_sample_size;\n            size_t current_dest_pos = dest_offset + (size_t)i * current_sample_size;\n\n            for (size_t k = 0; k < current_sample_size; ++k) {\n                m_recording_buffer[current_dest_pos + k] = packet_data[current_source_pos + k];\n            }\n        }\n\n        return true;\n    }\n\n    size_t getAllocatedSize() const {\n        return m_allocated_size;\n    }\n\n    const uint8_t* getRecordingBuffer() const {\n        return m_recording_buffer;\n    }\n\nprivate:\n    uint8_t* m_recording_buffer;\n    size_t m_allocated_size;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n#define MAX_GEAR_RATIOS 6\n#define MAX_SUSPENSION_SETTINGS 4\n#define MAX_DIAG_THRESHOLDS 8\n\ntypedef enum {\n    VEHICLE_ATTRIBUTE_GEAR_RATIOS = 0,\n    VEHICLE_ATTRIBUTE_SUSPENSION_SETTINGS,\n    VEHICLE_ATTRIBUTE_DIAGNOSTIC_THRESHOLDS,\n    VEHICLE_ATTRIBUTE_COUNT\n} VehicleAttributeType;\n\nstatic float g_gearRatios_vulnerable[MAX_GEAR_RATIOS];\nstatic float g_suspensionSettings_vulnerable[MAX_SUSPENSION_SETTINGS];\nstatic uint16_t g_diagThresholds_vulnerable[MAX_DIAG_THRESHOLDS];\n\ntypedef struct {\n    void*  buffer_ptr;\n    size_t element_size;\n    size_t max_elements;\n} AttributeInfo_vulnerable;\n\nstatic AttributeInfo_vulnerable g_attributeMap_vulnerable[VEHICLE_ATTRIBUTE_COUNT];\n\nvoid logVehicleError(const char* msg) {\n}\n\nvoid logVehicleEvent(const char* msg) {\n}\n\ntypedef struct {\n    VehicleAttributeType type;\n    uint16_t index;\n    uint32_t raw_value;\n} AttributeUpdateCommand_vulnerable;\n\nAttributeUpdateCommand_vulnerable receiveAttributeUpdateCommand_vulnerable() {\n    AttributeUpdateCommand_vulnerable cmd;\n    cmd.type = VEHICLE_ATTRIBUTE_GEAR_RATIOS;\n    cmd.index = MAX_GEAR_RATIOS;\n    cmd.raw_value = (uint32_t)(*(uint32_t*)(&(float){99.9f}));\n    return cmd;\n}\n\nvoid initializeVehicleAttributeSystem_vulnerable() {\n    g_attributeMap_vulnerable[VEHICLE_ATTRIBUTE_GEAR_RATIOS] = (AttributeInfo_vulnerable){\n        .buffer_ptr = g_gearRatios_vulnerable,\n        .element_size = sizeof(float),\n        .max_elements = MAX_GEAR_RATIOS\n    };\n    g_attributeMap_vulnerable[VEHICLE_ATTRIBUTE_SUSPENSION_SETTINGS] = (AttributeInfo_vulnerable){\n        .buffer_ptr = g_suspensionSettings_vulnerable,\n        .element_size = sizeof(float),\n        .max_elements = MAX_SUSPENSION_SETTINGS\n    };\n    g_attributeMap_vulnerable[VEHICLE_ATTRIBUTE_DIAGNOSTIC_THRESHOLDS] = (AttributeInfo_vulnerable){\n        .buffer_ptr = g_diagThresholds_vulnerable,\n        .element_size = sizeof(uint16_t),\n        .max_elements = MAX_DIAG_THRESHOLDS\n    };\n\n    for (int i = 0; i < MAX_GEAR_RATIOS; ++i) g_gearRatios_vulnerable[i] = 1.0f + i * 0.5f;\n    for (int i = 0; i < MAX_SUSPENSION_SETTINGS; ++i) g_suspensionSettings_vulnerable[i] = 10.0f + i * 1.0f;\n    for (int i = 0; i < MAX_DIAG_THRESHOLDS; ++i) g_diagThresholds_vulnerable[i] = 100 + i * 10;\n\n    logVehicleEvent(\"Vehicle attribute system initialized (vulnerable).\");\n}\n\nvoid updateVehicleAttribute_vulnerable(AttributeUpdateCommand_vulnerable cmd) {\n    if (cmd.type < VEHICLE_ATTRIBUTE_COUNT) {\n        AttributeInfo_vulnerable info = g_attributeMap_vulnerable[cmd.type];\n\n        if (info.buffer_ptr != NULL) {\n            if (info.element_size == sizeof(float)) {\n                ((float*)info.buffer_ptr)[cmd.index] = *(float*)&cmd.raw_value;\n                logVehicleEvent(\"Float attribute updated.\");\n            } else if (info.element_size == sizeof(uint16_t)) {\n                ((uint16_t*)info.buffer_ptr)[cmd.index] = (uint16_t)cmd.raw_value;\n                logVehicleEvent(\"Uint16 attribute updated.\");\n            } else {\n                logVehicleError(\"Unsupported element size for attribute buffer.\");\n            }\n        } else {\n            logVehicleError(\"Attribute map entry buffer_ptr is null for valid type.\");\n        }\n    } else {\n        logVehicleError(\"Invalid vehicle attribute type received.\");\n    }\n}\n\nvoid vehicleConfigManager_vulnerable_main() {\n    initializeVehicleAttributeSystem_vulnerable();\n    AttributeUpdateCommand_vulnerable cmd = receiveAttributeUpdateCommand_vulnerable();\n    updateVehicleAttribute_vulnerable(cmd);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_ENGINE_MAPS 5\n\ntypedef struct {\n    uint16_t fuel_injection_timing;\n    uint16_t ignition_advance;\n    uint16_t throttle_response_curve_id;\n    uint8_t  turbo_boost_pressure_level;\n} EnginePerformanceMap;\n\nstatic EnginePerformanceMap g_engineMaps_fixed[MAX_ENGINE_MAPS];\nstatic uint8_t g_currentEngineMapIndex_fixed;\n\nvoid automotiveLog_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint32_t can_id;\n    uint8_t  data[8];\n    uint8_t  dlc;\n} CANMessage_fixed;\n\nCANMessage_fixed receiveCANMessage_fixed() {\n    CANMessage_fixed msg;\n    msg.can_id = 0x123;\n    msg.data[0] = MAX_ENGINE_MAPS; \n    msg.dlc = 1;\n    return msg;\n}\n\nvoid initializeEngineMaps_fixed() {\n    for (uint8_t i = 0; i < MAX_ENGINE_MAPS; ++i) {\n        g_engineMaps_fixed[i] = (EnginePerformanceMap){150 + i*10, 20 + i*2, i, (uint8_t)(i % 5)};\n    }\n    g_currentEngineMapIndex_fixed = 0;\n    automotiveLog_fixed(\"Engine maps initialized (fixed).\");\n}\n\nvoid setEngineMode_fixed(uint8_t mode_id) {\n    if (mode_id < MAX_ENGINE_MAPS) {\n        g_currentEngineMapIndex_fixed = mode_id;\n        EnginePerformanceMap selectedMap = g_engineMaps_fixed[g_currentEngineMapIndex_fixed];\n        automotiveLog_fixed(\"Engine mode successfully set (fixed).\");\n    } else {\n        automotiveLog_fixed(\"Attempted to set engine mode with an invalid ID. Ignoring command (fixed).\");\n    }\n}\n\nvoid engineControlUnit_fixed_main() {\n    initializeEngineMaps_fixed();\n\n    CANMessage_fixed command_msg = receiveCANMessage_fixed();\n    uint8_t requested_mode_id = command_msg.data[0];\n\n    setEngineMode_fixed(requested_mode_id);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_FEATURE_GROUPS 8\n#define MAX_FEATURES_PER_GROUP 16\n#define CAN_PAYLOAD_SIZE 8\n\ntypedef struct {\n    uint8_t feature_status_byte;\n    uint16_t feature_config_value;\n} FeatureConfig;\n\nstatic FeatureConfig g_featureConfigurations_vulnerable[MAX_FEATURE_GROUPS][MAX_FEATURES_PER_GROUP];\n\nvoid logVehicleEvent_vulnerable(const char* event_msg) {\n}\n\ntypedef struct {\n    uint16_t message_id;\n    uint8_t data[CAN_PAYLOAD_SIZE];\n    uint8_t data_len;\n} CanMessage;\n\nCanMessage receiveCanMessage_vulnerable() {\n    CanMessage msg;\n    msg.message_id = 0x100;\n    msg.data[0] = 0;\n    msg.data[1] = 20;\n    msg.data[2] = 0xDE;\n    msg.data[3] = 0xAD;\n    msg.data_len = 4;\n    return msg;\n}\n\nvoid initializeFeatureConfigs_vulnerable() {\n    for (uint8_t i = 0; i < MAX_FEATURE_GROUPS; ++i) {\n        for (uint8_t j = 0; j < MAX_FEATURES_PER_GROUP; ++j) {\n            g_featureConfigurations_vulnerable[i][j].feature_status_byte = 0;\n            g_featureConfigurations_vulnerable[i][j].feature_config_value = 0;\n        }\n    }\n    g_featureConfigurations_vulnerable[0][0].feature_config_value = 100;\n    g_featureConfigurations_vulnerable[0][1].feature_config_value = 200;\n}\n\nvoid processCanMessage_vulnerable() {\n    CanMessage msg = receiveCanMessage_vulnerable();\n\n    if (msg.message_id == 0x100) {\n        if (msg.data_len >= 4) {\n            uint8_t group_idx = msg.data[0];\n            uint8_t feature_idx = msg.data[1];\n            uint16_t config_value = (msg.data[2] << 8) | msg.data[3];\n\n            if (group_idx < MAX_FEATURE_GROUPS) {\n                g_featureConfigurations_vulnerable[group_idx][feature_idx].feature_config_value = config_value;\n                g_featureConfigurations_vulnerable[group_idx][feature_idx].feature_status_byte = 0x01;\n                logVehicleEvent_vulnerable(\"Feature configuration updated (vulnerable).\");\n            } else {\n                logVehicleEvent_vulnerable(\"Invalid feature group index in configuration message (vulnerable).\");\n            }\n        } else {\n            logVehicleEvent_vulnerable(\"Insufficient data for feature config update (vulnerable).\");\n        }\n    } else if (msg.message_id == 0x101) {\n        if (msg.data_len >= 2) {\n            uint8_t group_idx = msg.data[0];\n            uint8_t feature_idx = msg.data[1];\n\n            if (group_idx < MAX_FEATURE_GROUPS) {\n                uint8_t current_status = g_featureConfigurations_vulnerable[group_idx][feature_idx].feature_status_byte;\n                logVehicleEvent_vulnerable(\"Feature status queried (vulnerable).\");\n            } else {\n                logVehicleEvent_vulnerable(\"Invalid feature group index in status request (vulnerable).\");\n            }\n        } else {\n            logVehicleEvent_vulnerable(\"Insufficient data for feature status request (vulnerable).\");\n        }\n    } else {\n        logVehicleEvent_vulnerable(\"Unknown CAN message ID received (vulnerable).\");\n    }\n}\n\nvoid main_ecu_loop_vulnerable() {\n    initializeFeatureConfigs_vulnerable();\n    processCanMessage_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n\ntypedef enum {\n    MODE_PARK = 0,\n    MODE_DRIVE,\n    MODE_REVERSE,\n    MODE_NEUTRAL,\n    NUM_VEHICLE_MODES\n} VehicleMode;\n\ntypedef enum {\n    INPUT_SHIFT_P = 0,\n    INPUT_SHIFT_D,\n    INPUT_SHIFT_R,\n    INPUT_SHIFT_N,\n    INPUT_ACCEL,\n    INPUT_BRAKE,\n    INPUT_CRUISE_ON,\n    INPUT_CRUISE_OFF,\n    NUM_VEHICLE_INPUTS\n} VehicleInput;\n\nvoid logSystemError(const char* msg) {\n}\n\nstatic VehicleMode g_currentVehicleMode = MODE_PARK;\n\nstatic const VehicleMode g_transition_table[NUM_VEHICLE_MODES][NUM_VEHICLE_INPUTS] = {\n    { MODE_PARK, MODE_DRIVE, MODE_REVERSE, MODE_NEUTRAL, MODE_PARK, MODE_PARK, MODE_PARK, MODE_PARK },\n    { MODE_PARK, MODE_DRIVE, MODE_DRIVE,   MODE_NEUTRAL, MODE_DRIVE,MODE_DRIVE,MODE_DRIVE,MODE_DRIVE },\n    { MODE_PARK, MODE_REVERSE, MODE_REVERSE, MODE_NEUTRAL, MODE_REVERSE,MODE_REVERSE,MODE_REVERSE,MODE_REVERSE },\n    { MODE_PARK, MODE_DRIVE, MODE_REVERSE, MODE_NEUTRAL, MODE_NEUTRAL,MODE_NEUTRAL,MODE_NEUTRAL,MODE_NEUTRAL }\n};\n\nVehicleInput receiveSimulatedInputEvent_vulnerable() {\n    return (VehicleInput)NUM_VEHICLE_INPUTS;\n}\n\nvoid processVehicleInput_vulnerable() {\n    VehicleInput inputEvent = receiveSimulatedInputEvent_vulnerable();\n    VehicleMode newMode = g_currentVehicleMode;\n\n    newMode = g_transition_table[g_currentVehicleMode][inputEvent];\n\n    g_currentVehicleMode = newMode;\n}\n\nvoid vehicleStateManager_vulnerable_main() {\n    g_currentVehicleMode = MODE_PARK;\n    processVehicleInput_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <new>\n\ntypedef struct {\n    uint32_t config_id;\n    uint32_t data_length;\n} ConfigBlockHeader;\n\nclass VehicleConfigUpdater {\npublic:\n    VehicleConfigUpdater() : current_config_data(nullptr), current_config_size(0) {}\n\n    ~VehicleConfigUpdater() {\n        if (current_config_data) {\n            delete[] current_config_data;\n            current_config_data = nullptr;\n        }\n    }\n\n    const uint8_t* getCurrentConfigData() const {\n        return current_config_data;\n    }\n\n    uint32_t getCurrentConfigSize() const {\n        return current_config_size;\n    }\n\n    bool processConfigBlockVulnerable(const uint8_t* block_data, size_t block_len) {\n        if (!block_data || block_len < sizeof(ConfigBlockHeader)) {\n            return false;\n        }\n\n        const ConfigBlockHeader* header = reinterpret_cast<const ConfigBlockHeader*>(block_data);\n        uint32_t advertised_data_len = header->data_length;\n\n        uint8_t* temp_buffer = new (std::nothrow) uint8_t[advertised_data_len];\n        if (!temp_buffer) {\n            return false;\n        }\n\n        size_t actual_payload_bytes_in_block = block_len - sizeof(ConfigBlockHeader);\n\n        for (size_t i = 0; i < actual_payload_bytes_in_block; ++i) {\n            temp_buffer[i] = block_data[sizeof(ConfigBlockHeader) + i];\n        }\n\n        if (current_config_data) {\n            delete[] current_config_data;\n        }\n\n        current_config_data = temp_buffer;\n        current_config_size = advertised_data_len;\n\n        return true;\n    }\n\nprivate:\n    uint8_t* current_config_data;\n    uint32_t current_config_size;\n};\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n// Represents a single diagnostic event's metadata\nstruct EventMetadata {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t payload_length; // Actual length of this specific event's payload\n};\n\n// --- Vulnerable Class --- \n// Designed to store a stream of diagnostic events in a pre-allocated contiguous buffer.\nclass DiagnosticStorageVulnerable {\npublic:\n    // Constructor: Allocates a buffer based on an expected maximum number of events\n    // and a 'configured' maximum payload size per event. This 'configured' size\n    // is used to determine the fixed slot size for each event in the buffer.\n    DiagnosticStorageVulnerable(uint32_t max_total_events, uint16_t configured_max_payload_per_event)\n        : m_buffer(nullptr), m_buffer_capacity_bytes(0), m_current_event_count(0),\n          m_configured_max_payload_size(configured_max_payload_per_event) {\n\n        if (max_total_events == 0 || configured_max_payload_per_event == 0) {\n            return;\n        }\n\n        // Calculate the fixed size of each slot in the buffer.\n        // This size includes the EventMetadata and a fixed-size payload area\n        // based on 'configured_max_payload_per_event'.\n        size_t bytes_per_event_slot = sizeof(EventMetadata) + configured_max_payload_per_event;\n        \n        // Basic overflow check for the size_t calculation\n        if (max_total_events > SIZE_MAX / bytes_per_event_slot) {\n            // Prevent immediate integer overflow during allocation size calculation\n            return;\n        }\n\n        m_buffer_capacity_bytes = max_total_events * bytes_per_event_slot;\n        m_buffer = (uint8_t*)malloc(m_buffer_capacity_bytes);\n\n        if (m_buffer == nullptr && m_buffer_capacity_bytes > 0) {\n            m_buffer_capacity_bytes = 0; // Allocation failed\n        }\n    }\n\n    ~DiagnosticStorageVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    // Stores a single diagnostic event into the internal buffer.\n    // 'event_data' points to a byte stream containing EventMetadata followed by its payload.\n    // 'data_len' is the total length of 'event_data' (metadata + payload).\n    bool storeEventVulnerable(const uint8_t* event_data, size_t data_len) {\n        if (!event_data || data_len < sizeof(EventMetadata) || m_buffer == nullptr) {\n            return false;\n        }\n\n        const EventMetadata* incoming_meta = reinterpret_cast<const EventMetadata*>(event_data);\n        uint16_t actual_payload_len = incoming_meta->payload_length;\n        size_t total_incoming_event_size = sizeof(EventMetadata) + actual_payload_len;\n\n        // Ensure the incoming data itself is complete and not truncated\n        if (data_len < total_incoming_event_size) {\n            return false;\n        }\n\n        // Calculate the target offset in the internal buffer for the new event.\n        // This calculation relies on m_configured_max_payload_size for the slot size.\n        size_t bytes_per_event_slot = sizeof(EventMetadata) + m_configured_max_payload_size;\n        size_t write_offset = m_current_event_count * bytes_per_event_slot;\n\n        // This check validates if there's enough overall allocated space for the *next slot*\n        // based on the 'configured' size. It DOES NOT check if the *actual* incoming event's\n        // payload length exceeds the individual slot's configured size.\n        if (write_offset + bytes_per_event_slot > m_buffer_capacity_bytes) {\n            return false; // Not enough total capacity for another event slot at configured size\n        }\n\n        // VULNERABILITY:\n        // The 'memcpy' copies 'total_incoming_event_size' bytes. If 'actual_payload_len'\n        // (from the incoming data) is greater than 'm_configured_max_payload_size'\n        // (used for allocation and slot size calculation), then 'total_incoming_event_size'\n        // will be larger than 'bytes_per_event_slot'.\n        // This will cause 'memcpy' to write beyond the bounds of the current event's\n        // allocated slot in 'm_buffer', overflowing into the subsequent event's slot,\n        // or potentially past the end of 'm_buffer' if it's the last event.\n        // There is no check to ensure 'actual_payload_len <= m_configured_max_payload_size' here.\n        memcpy(m_buffer + write_offset, event_data, total_incoming_event_size);\n\n        m_current_event_count++;\n        return true;\n    }\n\n    size_t getStoredEventCount() const { return m_current_event_count; }\n    size_t getAllocatedCapacityBytes() const { return m_buffer_capacity_bytes; }\n    const uint8_t* getBuffer() const { return m_buffer; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_buffer_capacity_bytes;\n    uint32_t m_current_event_count;\n    uint16_t m_configured_max_payload_size; // Maximum payload size assumed for each slot during allocation\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define LOG_BUFFER_SIZE 32\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t event_id;\n    uint8_t severity;\n    bool active;\n    uint8_t data[4];\n} VehicleLogEntry;\n\nstatic VehicleLogEntry g_vehicle_event_log[LOG_BUFFER_SIZE];\nstatic uint32_t g_write_head_idx = 0;\nstatic uint32_t g_num_active_entries = 0;\n\nvoid init_vehicle_log() {\n    for (uint32_t i = 0; i < LOG_BUFFER_SIZE; ++i) {\n        memset(&g_vehicle_event_log[i], 0, sizeof(VehicleLogEntry));\n        g_vehicle_event_log[i].active = false;\n    }\n    g_write_head_idx = 0;\n    g_num_active_entries = 0;\n}\n\nvoid add_log_entry(uint16_t event_id, uint8_t severity, const uint8_t* data, uint32_t timestamp) {\n    g_vehicle_event_log[g_write_head_idx].timestamp_ms = timestamp;\n    g_vehicle_event_log[g_write_head_idx].event_id = event_id;\n    g_vehicle_event_log[g_write_head_idx].severity = severity;\n    g_vehicle_event_log[g_write_head_idx].active = true;\n    if (data) {\n        memcpy(g_vehicle_event_log[g_write_head_idx].data, data, sizeof(g_vehicle_event_log[g_write_head_idx].data));\n    }\n\n    g_write_head_idx = (g_write_head_idx + 1) % LOG_BUFFER_SIZE;\n    if (g_num_active_entries < LOG_BUFFER_SIZE) {\n        g_num_active_entries++;\n    }\n}\n\nvoid update_historical_log_status_vulnerable(int relative_offset_from_newest, bool new_active_status) {\n    if (g_num_active_entries == 0) {\n        return;\n    }\n\n    int newest_entry_absolute_idx = (int)g_write_head_idx - 1;\n    if (newest_entry_absolute_idx < 0) {\n        newest_entry_absolute_idx = LOG_BUFFER_SIZE - 1;\n    }\n\n    int target_log_idx_signed = newest_entry_absolute_idx - relative_offset_from_newest;\n\n    g_vehicle_event_log[target_log_idx_signed].active = new_active_status;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <algorithm>\n#include <limits>\n\nstruct DiagnosticRecordHeader {\n    uint16_t record_id;\n    uint16_t data_length; \n};\n\nclass DiagnosticDataStoreFixed {\npublic:\n    DiagnosticDataStoreFixed() : m_buffer(nullptr), m_current_data_size(0), m_allocated_capacity(0) {}\n\n    ~DiagnosticDataStoreFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool appendDiagnosticRecordFixed(const uint8_t* raw_record_data, size_t raw_record_len) {\n        if (!raw_record_data || raw_record_len < sizeof(DiagnosticRecordHeader)) {\n            return false;\n        }\n\n        const DiagnosticRecordHeader* header = reinterpret_cast<const DiagnosticRecordHeader*>(raw_record_data);\n        uint16_t advertised_data_length = header->data_length;\n\n        if (raw_record_len != (sizeof(DiagnosticRecordHeader) + advertised_data_length)) {\n            return false;\n        }\n\n        size_t new_required_capacity;\n        if (m_current_data_size > (std::numeric_limits<size_t>::max() - raw_record_len)) {\n            return false;\n        }\n        new_required_capacity = m_current_data_size + raw_record_len;\n\n        const size_t MAX_TOTAL_BUFFER_SIZE = 16 * 1024 * 1024;\n        if (new_required_capacity > MAX_TOTAL_BUFFER_SIZE) {\n            return false;\n        }\n        \n        uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_required_capacity);\n\n        if (!new_buffer && new_required_capacity > 0) {\n            return false;\n        }\n        \n        m_buffer = new_buffer;\n        m_allocated_capacity = new_required_capacity;\n\n        std::memcpy(m_buffer + m_current_data_size, raw_record_data, raw_record_len);\n        \n        m_current_data_size += raw_record_len;\n\n        return true;\n    }\n\n    const uint8_t* getRawDataBuffer() const {\n        return m_buffer;\n    }\n\n    size_t getCurrentDataSize() const {\n        return m_current_data_size;\n    }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_current_data_size;\n    size_t m_allocated_capacity;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_DRIVING_PROFILES 10\n#define NUM_PROFILE_PARAMS 4\n\ntypedef struct {\n    uint16_t speed_limit;\n    uint8_t  throttle_response;\n    uint8_t  suspension_mode;\n    bool     traction_control_active;\n} DrivingProfile;\n\nstatic DrivingProfile g_drivingProfiles[MAX_DRIVING_PROFILES];\n\nstatic uint8_t g_currentActiveProfiles = 5;\n\ntypedef struct {\n    uint8_t command_type;\n    uint8_t profile_id;\n    DrivingProfile new_config;\n} DrivingModeCommand;\n\nvoid logVehicleError(const char* msg) {\n}\n\nDrivingModeCommand receiveDrivingModeCommand_vulnerable() {\n    DrivingModeCommand cmd;\n    cmd.command_type = 0x01;\n    cmd.profile_id = 7;\n    cmd.new_config.speed_limit = 180;\n    cmd.new_config.throttle_response = 0xFF;\n    cmd.new_config.suspension_mode = 0x02;\n    cmd.new_config.traction_control_active = false;\n    return cmd;\n}\n\nvoid initializeDrivingProfiles_vulnerable() {\n    for (uint8_t i = 0; i < MAX_DRIVING_PROFILES; ++i) {\n        g_drivingProfiles[i] = (DrivingProfile){0, 0, 0, false};\n    }\n    for (uint8_t i = 0; i < g_currentActiveProfiles; ++i) {\n        g_drivingProfiles[i].speed_limit = 120 + (i * 10);\n        g_drivingProfiles[i].throttle_response = 0x50 + (i * 0x10);\n        g_drivingProfiles[i].suspension_mode = i % 3;\n        g_drivingProfiles[i].traction_control_active = true;\n    }\n}\n\nvoid processDrivingModeCommand_vulnerable() {\n    DrivingModeCommand cmd = receiveDrivingModeCommand_vulnerable();\n\n    if (cmd.command_type == 0x01) {\n        if (cmd.profile_id < MAX_DRIVING_PROFILES) {\n            g_drivingProfiles[cmd.profile_id] = cmd.new_config;\n            logVehicleError(\"Driving profile updated.\");\n        } else {\n            logVehicleError(\"Profile ID out of array bounds.\");\n        }\n    } else if (cmd.command_type == 0x02) {\n        if (cmd.profile_id < MAX_DRIVING_PROFILES) {\n            DrivingProfile queriedProfile = g_drivingProfiles[cmd.profile_id];\n            logVehicleError(\"Driving profile queried.\");\n        } else {\n            logVehicleError(\"Profile ID out of array bounds for query.\");\n        }\n    } else {\n        logVehicleError(\"Unknown driving mode command type.\");\n    }\n}\n\nvoid vehicleControlMain_vulnerable() {\n    initializeDrivingProfiles_vulnerable();\n    processDrivingModeCommand_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_SUPPORTED_SENSOR_TYPES_VULN 3\n\ntypedef struct {\n    uint32_t processing_flags;\n    int16_t offset_calibration;\n    float gain_calibration;\n    bool enable_filter;\n} SensorProcessingConfig_Vulnerable;\n\nstatic SensorProcessingConfig_Vulnerable g_sensorConfigs_vulnerable[MAX_SUPPORTED_SENSOR_TYPES_VULN];\n\nvoid system_log_vulnerable(const char* msg) {\n    fprintf(stdout, \"VULN_LOG: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t sensor_type_id;\n    uint16_t raw_value;\n    uint32_t timestamp;\n} SensorDataPacket_Vulnerable;\n\nSensorDataPacket_Vulnerable getSimulatedSensorData_vulnerable() {\n    SensorDataPacket_Vulnerable packet;\n    packet.sensor_type_id = MAX_SUPPORTED_SENSOR_TYPES_VULN; \n    packet.raw_value = 4096;\n    packet.timestamp = 0x12345678;\n    system_log_vulnerable(\"Simulated incoming sensor data with potentially malicious sensor_type_id.\");\n    return packet;\n}\n\nvoid initializeSensorConfigurations_vulnerable() {\n    g_sensorConfigs_vulnerable[0] = (SensorProcessingConfig_Vulnerable){.processing_flags = 0x01, .offset_calibration = 10, .gain_calibration = 1.0, .enable_filter = true};\n    g_sensorConfigs_vulnerable[1] = (SensorProcessingConfig_Vulnerable){.processing_flags = 0x02, .offset_calibration = 5, .gain_calibration = 0.9, .enable_filter = false};\n    g_sensorConfigs_vulnerable[2] = (SensorProcessingConfig_Vulnerable){.processing_flags = 0x04, .offset_calibration = 0, .gain_calibration = 1.1, .enable_filter = true};\n    system_log_vulnerable(\"Sensor configurations initialized.\");\n}\n\nvoid processSensorData_vulnerable() {\n    SensorDataPacket_Vulnerable packet = getSimulatedSensorData_vulnerable();\n\n    SensorProcessingConfig_Vulnerable current_config = g_sensorConfigs_vulnerable[packet.sensor_type_id];\n\n    float processed_value = (float)packet.raw_value * current_config.gain_calibration + current_config.offset_calibration;\n    system_log_vulnerable(\"Sensor data processed (vulnerable).\");\n}\n\nvoid automotiveSensorProcessingModule_vulnerable() {\n    initializeSensorConfigurations_vulnerable();\n    processSensorData_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define FIRMWARE_CONFIG_BUFFER_SIZE 256\n#define MAX_INCOMING_PARAM_DATA_SIZE 64\n\nstatic uint8_t g_firmwareConfigData[FIRMWARE_CONFIG_BUFFER_SIZE];\n\nvoid initFirmwareConfig() {\n    memset(g_firmwareConfigData, 0x00, FIRMWARE_CONFIG_BUFFER_SIZE);\n    g_firmwareConfigData[0] = 0xAA;\n    g_firmwareConfigData[1] = 0xBB;\n}\n\nint updateFirmwareConfigSegment(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len < 2) {\n        return -1;\n    }\n\n    uint8_t config_area_offset = packet_data[0];\n    uint8_t data_segment_length = packet_data[1];\n\n    if (2 + data_segment_length > packet_len) {\n        return -2;\n    }\n\n    if (data_segment_length > MAX_INCOMING_PARAM_DATA_SIZE) {\n        return -3;\n    }\n\n    if (config_area_offset >= FIRMWARE_CONFIG_BUFFER_SIZE) {\n        return -4;\n    }\n\n    if (config_area_offset + data_segment_length > FIRMWARE_CONFIG_BUFFER_SIZE) {\n        return -5;\n    }\n\n    const uint8_t* actual_data_ptr = packet_data + 2;\n\n    for (uint8_t i = 0; i < data_segment_length; ++i) {\n        g_firmwareConfigData[config_area_offset + i] = actual_data_ptr[i];\n    }\n\n    return 0;\n}\n\nvoid handleFirmwareUpdateMessage(const uint8_t* msg_payload, uint16_t payload_size) {\n    updateFirmwareConfigSegment(msg_payload, payload_size);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_SUB_COMPONENTS_ENGINE         8\n#define MAX_SUB_COMPONENTS_TRANSMISSION   4\n#define MAX_SUB_COMPONENTS_BRAKE          6\n#define MAX_SUB_COMPONENTS_INFOTAINMENT   10\n\ntypedef enum {\n    VEHICLE_COMPONENT_ENGINE = 0,\n    VEHICLE_COMPONENT_TRANSMISSION,\n    VEHICLE_COMPONENT_BRAKE,\n    VEHICLE_COMPONENT_INFOTAINMENT,\n    NUM_VEHICLE_COMPONENTS\n} VehicleComponentType;\n\ntypedef struct {\n    uint8_t  status_code;\n    uint32_t last_update_timestamp;\n    bool     is_active;\n} SubComponentStatus;\n\ntypedef struct {\n    SubComponentStatus* status_array_ptr;\n    uint8_t             max_size;\n} ComponentDataStorage;\n\nstatic SubComponentStatus g_engineSubComponentStatuses[MAX_SUB_COMPONENTS_ENGINE];\nstatic SubComponentStatus g_transmissionSubComponentStatuses[MAX_SUB_COMPONENTS_TRANSMISSION];\nstatic SubComponentStatus g_brakeSubComponentStatuses[MAX_SUB_COMPONENTS_BRAKE];\nstatic SubComponentStatus g_infotainmentSubComponentStatuses[MAX_SUB_COMPONENTS_INFOTAINMENT];\n\nstatic ComponentDataStorage g_componentDataRegistry[NUM_VEHICLE_COMPONENTS];\n\ntypedef struct {\n    VehicleComponentType component_type;\n    uint8_t              sub_component_id;\n    uint8_t              new_status_code;\n    uint32_t             timestamp;\n} ComponentStatusMessage;\n\nvoid logAutomotiveEvent(const char* msg) {\n}\n\nvoid initializeComponentStatusSystem_fixed() {\n    g_componentDataRegistry[VEHICLE_COMPONENT_ENGINE].status_array_ptr = g_engineSubComponentStatuses;\n    g_componentDataRegistry[VEHICLE_COMPONENT_ENGINE].max_size = MAX_SUB_COMPONENTS_ENGINE;\n\n    g_componentDataRegistry[VEHICLE_COMPONENT_TRANSMISSION].status_array_ptr = g_transmissionSubComponentStatuses;\n    g_componentDataRegistry[VEHICLE_COMPONENT_TRANSMISSION].max_size = MAX_SUB_COMPONENTS_TRANSMISSION;\n\n    g_componentDataRegistry[VEHICLE_COMPONENT_BRAKE].status_array_ptr = g_brakeSubComponentStatuses;\n    g_componentDataRegistry[VEHICLE_COMPONENT_BRAKE].max_size = MAX_SUB_COMPONENTS_BRAKE;\n\n    g_componentDataRegistry[VEHICLE_COMPONENT_INFOTAINMENT].status_array_ptr = g_infotainmentSubComponentStatuses;\n    g_componentDataRegistry[VEHICLE_COMPONENT_INFOTAINMENT].max_size = MAX_SUB_COMPONENTS_INFOTAINMENT;\n\n    for (int i = 0; i < MAX_SUB_COMPONENTS_ENGINE; ++i) g_engineSubComponentStatuses[i] = (SubComponentStatus){0, 0, false};\n    for (int i = 0; i < MAX_SUB_COMPONENTS_TRANSMISSION; ++i) g_transmissionSubComponentStatuses[i] = (SubComponentStatus){0, 0, false};\n    for (int i = 0; i < MAX_SUB_COMPONENTS_BRAKE; ++i) g_brakeSubComponentStatuses[i] = (SubComponentStatus){0, 0, false};\n    for (int i = 0; i < MAX_SUB_COMPONENTS_INFOTAINMENT; ++i) g_infotainmentSubComponentStatuses[i] = (SubComponentStatus){0, 0, false};\n\n    logAutomotiveEvent(\"Component status system initialized (fixed).\");\n}\n\nComponentStatusMessage simulateIncomingStatusMessage_fixed() {\n    ComponentStatusMessage msg;\n    msg.component_type = VEHICLE_COMPONENT_TRANSMISSION;\n    msg.sub_component_id = 4;\n    msg.new_status_code = 0xAA;\n    msg.timestamp = 0x12345678;\n    return msg;\n}\n\nvoid processComponentStatusUpdate_fixed(ComponentStatusMessage msg) {\n    if (msg.component_type < NUM_VEHICLE_COMPONENTS) {\n        ComponentDataStorage* target_storage = &g_componentDataRegistry[msg.component_type];\n        if (msg.sub_component_id < target_storage->max_size) {\n            target_storage->status_array_ptr[msg.sub_component_id].status_code = msg.new_status_code;\n            target_storage->status_array_ptr[msg.sub_component_id].last_update_timestamp = msg.timestamp;\n            target_storage->status_array_ptr[msg.sub_component_id].is_active = true;\n            logAutomotiveEvent(\"Component status update processed successfully (fixed).\");\n        } else {\n            logAutomotiveEvent(\"Sub-component ID out of bounds for specified component. Update ignored (fixed).\");\n        }\n    } else {\n        logAutomotiveEvent(\"Received status update for invalid component type (fixed).\");\n    }\n}\n\nvoid vehicleStatusMonitor_fixed_main() {\n    initializeComponentStatusSystem_fixed();\n    ComponentStatusMessage update_msg = simulateIncomingStatusMessage_fixed();\n    processComponentStatusUpdate_fixed(update_msg);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_CALIBRATION_TABLE_SIZE_FIXED 256\n\nstatic uint16_t g_vehicle_calibration_table_fixed[VEHICLE_CALIBRATION_TABLE_SIZE_FIXED];\nstatic uint16_t g_current_base_cal_idx_fixed = 0;\n\nvoid init_vehicle_calibration_system_fixed() {\n    for (uint16_t i = 0; i < VEHICLE_CALIBRATION_TABLE_SIZE_FIXED; ++i) {\n        g_vehicle_calibration_table_fixed[i] = i * 2;\n    }\n    g_current_base_cal_idx_fixed = 0;\n}\n\nbool set_base_calibration_index_fixed(uint16_t base_idx) {\n    if (base_idx < VEHICLE_CALIBRATION_TABLE_SIZE_FIXED) {\n        g_current_base_cal_idx_fixed = base_idx;\n        return true;\n    }\n    return false;\n}\n\nvoid apply_relative_calibration_adjustment_fixed(int16_t fine_tune_offset, uint16_t adjustment_value) {\n    int32_t target_index = (int32_t)g_current_base_cal_idx_fixed + fine_tune_offset;\n\n    if (target_index >= 0 && target_index < VEHICLE_CALIBRATION_TABLE_SIZE_FIXED) {\n        g_vehicle_calibration_table_fixed[target_index] = adjustment_value;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_PENDING_TASKS 128\n#define TASK_DESCRIPTION_MAX_LEN 32\n\ntypedef enum {\n    TASK_STATE_IDLE,\n    TASK_STATE_PENDING,\n    TASK_STATE_RUNNING,\n    TASK_STATE_COMPLETED,\n    TASK_STATE_ERROR\n} TaskState;\n\ntypedef struct {\n    uint16_t task_id;\n    uint16_t priority;\n    TaskState state;\n    char description[TASK_DESCRIPTION_MAX_LEN];\n    void (*task_handler)(void);\n} TaskDescriptor;\n\nstatic TaskDescriptor g_task_queue[MAX_PENDING_TASKS];\nstatic uint16_t g_current_task_count = 0;\n\nvoid dummy_veh_handler(void) {\n    // Simulate some vehicle operation\n}\n\nuint16_t scheduleVehicleTask(uint16_t priority, const char* desc) {\n    if (g_current_task_count < MAX_PENDING_TASKS) {\n        g_task_queue[g_current_task_count].task_id = g_current_task_count;\n        g_task_queue[g_current_task_count].priority = priority;\n        g_task_queue[g_current_task_count].state = TASK_STATE_PENDING;\n        strncpy(g_task_queue[g_current_task_count].description, desc, TASK_DESCRIPTION_MAX_LEN - 1);\n        g_task_queue[g_current_task_count].description[TASK_DESCRIPTION_MAX_LEN - 1] = '\\0';\n        g_task_queue[g_current_task_count].task_handler = dummy_veh_handler;\n        g_current_task_count++;\n        return g_current_task_count - 1;\n    }\n    return (uint16_t)-1;\n}\n\nvoid cancelLastVehicleTasks_Vulnerable(int rollback_count) {\n    if (rollback_count <= 0) {\n        return;\n    }\n\n    // This loop intends to mark the last 'rollback_count' tasks as IDLE and clear their IDs.\n    // However, if 'rollback_count' is greater than 'g_current_task_count', the calculated\n    // 'target_idx' will become negative, leading to a buffer underwrite.\n    for (int i = 0; i < rollback_count; ++i) {\n        // g_current_task_count is unsigned, but subtraction with signed 'i' and '1'\n        // will cause implicit conversion to int, potentially resulting in a negative 'target_idx'.\n        int target_idx = (int)g_current_task_count - 1 - i;\n\n        // Buffer underwrite occurs here if target_idx is negative.\n        // Example: If g_current_task_count is 1 (meaning task at index 0 is valid),\n        // and rollback_count is 5:\n        // i=0: target_idx = 0. g_task_queue[0].state = TASK_STATE_IDLE; OK.\n        // i=1: target_idx = -1. g_task_queue[-1].state = TASK_STATE_IDLE; BUFFER UNDERWRITE!\n        // i=2: target_idx = -2. g_task_queue[-2].state = TASK_STATE_IDLE; BUFFER UNDERWRITE!\n        g_task_queue[target_idx].state = TASK_STATE_IDLE;\n        g_task_queue[target_idx].task_id = 0;\n    }\n\n    // After the loop, update the total count of active tasks.\n    // This part is conceptually separate from the loop's underwrite, but part of the overall logic.\n    if (g_current_task_count < rollback_count) {\n        g_current_task_count = 0;\n    } else {\n        g_current_task_count -= rollback_count;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_COMMAND_POOL_SIZE 256 \n\ntypedef struct {\n    uint8_t command_id;\n    uint16_t param_a;\n    uint16_t param_b;\n} VehicleCommand;\n\nstatic VehicleCommand g_commandPool_fixed[MAX_COMMAND_POOL_SIZE];\n\nvoid logECUEvent_fixed(const char* msg) {\n    fprintf(stderr, \"ECU_FIXED_LOG: %s\\n\", msg);\n}\n\nvoid executeVehicleCommand_fixed(VehicleCommand cmd) {\n    logECUEvent_fixed(\"Executing vehicle command.\");\n}\n\ntypedef struct {\n    uint16_t start_idx;\n    uint16_t length;\n} SequenceConfigMsg_Fixed;\n\nSequenceConfigMsg_Fixed receiveSequenceConfig_fixed() {\n    SequenceConfigMsg_Fixed config;\n    config.start_idx = 200;\n    config.length = 60;\n    return config;\n}\n\nvoid processActiveCommandSequence_fixed() {\n    SequenceConfigMsg_Fixed config = receiveSequenceConfig_fixed();\n    \n    uint16_t sequence_start_idx = config.start_idx;\n    uint16_t sequence_length = config.length;\n\n    logECUEvent_fixed(\"Processing active command sequence (fixed).\");\n\n    // Fixed: Validate the entire range (start_idx + length) against the pool size\n    // Use uint32_t for the sum to prevent potential integer overflow during the check itself\n    // before comparing with MAX_COMMAND_POOL_SIZE.\n    if (sequence_length == 0) {\n        logECUEvent_fixed(\"Zero-length sequence received. Nothing to process.\");\n        return;\n    }\n    \n    if (sequence_start_idx < MAX_COMMAND_POOL_SIZE && \n        (uint32_t)sequence_start_idx + sequence_length <= MAX_COMMAND_POOL_SIZE) {\n        \n        for (uint16_t i = 0; i < sequence_length; ++i) {\n            // The individual index access is now guaranteed to be within bounds\n            VehicleCommand cmd = g_commandPool_fixed[sequence_start_idx + i];\n            executeVehicleCommand_fixed(cmd);\n        }\n    } else {\n        logECUEvent_fixed(\"Invalid sequence configuration received: range out of bounds or arithmetic overflow. Ignoring sequence.\");\n    }\n}\n\nvoid automotiveECU_CommandProcessor_fixed_main() {\n    // Initialize the command pool with dummy data\n    for (uint16_t i = 0; i < MAX_COMMAND_POOL_SIZE; ++i) {\n        g_commandPool_fixed[i] = (VehicleCommand){(uint8_t)i, i, (uint16_t)(i * 2)};\n    }\n    logECUEvent_fixed(\"Command pool initialized.\");\n    \n    // Process a command sequence configuration with robust validation\n    processActiveCommandSequence_fixed();\n}\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DATA_BUFFER_SIZE 128\n#define MIN_DATA_AREA_START 16 // Start of actual data after some header/metadata\n\nstatic uint8_t g_data_buffer[DATA_BUFFER_SIZE];\nstatic int16_t g_cursor_pos = MIN_DATA_AREA_START; // Current write position, initialized to start of data area\n\nvoid init_data_processor() {\n    memset(g_data_buffer, 0x00, DATA_BUFFER_SIZE);\n    g_data_buffer[0] = 0xAA; // Magic byte\n    g_data_buffer[1] = 0x55; // Version byte\n    g_cursor_pos = MIN_DATA_AREA_START;\n}\n\nvoid add_processed_data(const uint8_t* data, uint8_t len) {\n    if (g_cursor_pos + len <= DATA_BUFFER_SIZE) {\n        memcpy(&g_data_buffer[g_cursor_pos], data, len);\n        g_cursor_pos += len;\n    }\n}\n\n// Fixed function: Moves the cursor backward by 'steps' bytes safely.\n// It ensures that the new cursor position does not go below MIN_DATA_AREA_START\n// and prevents writing into the header/metadata area or before the buffer.\nvoid rollback_data_state_fixed(uint16_t steps) {\n    if (g_cursor_pos <= MIN_DATA_AREA_START) {\n        return; // No data to roll back or already at the beginning of the data area\n    }\n\n    int16_t proposed_new_cursor_pos = g_cursor_pos - steps;\n\n    // Clamp the new cursor position to not go below MIN_DATA_AREA_START.\n    // This ensures that the cursor always stays within or at the beginning of the intended data area.\n    int16_t actual_new_cursor_pos = (proposed_new_cursor_pos < MIN_DATA_AREA_START) ? MIN_DATA_AREA_START : proposed_new_cursor_pos;\n\n    // Update the global cursor position\n    g_cursor_pos = actual_new_cursor_pos;\n\n    // Only attempt to \"invalidate\" the byte if the new cursor position means there's\n    // a valid data byte immediately preceding it (i.e., not in the header section).\n    // The target index for the write (g_cursor_pos - 1) must be >= MIN_DATA_AREA_START.\n    if (g_cursor_pos > MIN_DATA_AREA_START) {\n        g_data_buffer[g_cursor_pos - 1] = 0x00; // Safely invalidate previous byte\n    }\n    // If g_cursor_pos is now MIN_DATA_AREA_START, it means all data has been logically\n    // rolled back, and there is no \"previous\" data byte in the data section to invalidate.\n    // The header area remains untouched.\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define VEHICLE_SETTINGS_BANK_SIZE_BYTES 1024\n#define SETTINGS_BLOCK_SIZE_BYTES        64\n\ntypedef struct {\n    uint16_t version;\n    uint16_t crc;\n    uint8_t  active_flag; \n    uint8_t  _reserved[59]; \n} SettingsBlockHeader;\n\nstatic uint8_t g_settings_bank[VEHICLE_SETTINGS_BANK_SIZE_BYTES];\nstatic uint8_t* g_active_settings_block_ptr = NULL;\nstatic uint16_t g_last_stored_offset = 0;\n\nvoid init_settings_manager_vulnerable() {\n    memset(g_settings_bank, 0, VEHICLE_SETTINGS_BANK_SIZE_BYTES);\n    g_active_settings_block_ptr = g_settings_bank;\n    g_last_stored_offset = 0;\n    ((SettingsBlockHeader*)g_active_settings_block_ptr)->active_flag = 0xAA;\n}\n\nbool store_new_settings_vulnerable(const uint8_t* new_settings_data) {\n    if (g_last_stored_offset + SETTINGS_BLOCK_SIZE_BYTES > VEHICLE_SETTINGS_BANK_SIZE_BYTES) {\n        return false;\n    }\n\n    if (g_active_settings_block_ptr != NULL) {\n        ((SettingsBlockHeader*)g_active_settings_block_ptr)->active_flag = 0x55;\n    }\n\n    uint8_t* new_block_location = g_settings_bank + g_last_stored_offset;\n    memcpy(new_block_location, new_settings_data, SETTINGS_BLOCK_SIZE_BYTES);\n\n    ((SettingsBlockHeader*)new_block_location)->active_flag = 0xAA;\n\n    g_active_settings_block_ptr = new_block_location;\n    g_last_stored_offset += SETTINGS_BLOCK_SIZE_BYTES;\n    return true;\n}\n\nconst uint8_t* get_active_settings_vulnerable() {\n    return g_active_settings_block_ptr;\n}\n\nvoid rollback_settings_vulnerable(uint8_t steps_back) {\n    if (g_active_settings_block_ptr == NULL) {\n        return;\n    }\n\n    uint8_t* target_block_ptr = g_active_settings_block_ptr - (steps_back * SETTINGS_BLOCK_SIZE_BYTES);\n\n    ((SettingsBlockHeader*)target_block_ptr)->active_flag = 0xAA;\n\n    g_active_settings_block_ptr = target_block_ptr;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#define CAN_DATA_MAX_LEN 8\n#define CAN_MSG_ID_BASE 0x100\n#define NUM_CAN_HANDLERS 5\n\ntypedef struct {\n    uint16_t message_id;\n    uint8_t data[CAN_DATA_MAX_LEN];\n    uint8_t data_len;\n} CanMessage;\n\nvoid automotiveCanLog_fixed(const char* msg) {\n    fprintf(stderr, \"CAN_FIXED_LOG: %s\\n\", msg);\n}\n\nvoid handleEngineRPM_fixed(const uint8_t* data, uint8_t len) {\n    if (len >= 2) {\n        uint16_t rpm = (data[0] << 8) | data[1];\n        automotiveCanLog_fixed(\"Engine RPM handler: RPM processed.\");\n    } else {\n        automotiveCanLog_fixed(\"Engine RPM handler: Invalid data length.\");\n    }\n}\n\nvoid handleVehicleSpeed_fixed(const uint8_t* data, uint8_t len) {\n    if (len >= 1) {\n        uint8_t speed = data[0];\n        automotiveCanLog_fixed(\"Vehicle Speed handler: Speed processed.\");\n    } else {\n        automotiveCanLog_fixed(\"Vehicle Speed handler: Invalid data length.\");\n    }\n}\n\nvoid handleBrakePressure_fixed(const uint8_t* data, uint8_t len) {\n    if (len >= 4) {\n        int32_t pressure = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | data[3];\n        automotiveCanLog_fixed(\"Brake Pressure handler: Pressure processed.\");\n    } else {\n        automotiveCanLog_fixed(\"Brake Pressure handler: Invalid data length.\");\n    }\n}\n\nvoid handleSteeringAngle_fixed(const uint8_t* data, uint8_t len) {\n    if (len >= 2) {\n        int16_t angle = (data[0] << 8) | data[1];\n        automotiveCanLog_fixed(\"Steering Angle handler: Angle processed.\");\n    } else {\n        automotiveCanLog_fixed(\"Steering Angle handler: Invalid data length.\");\n    }\n}\n\nvoid handleDoorStatus_fixed(const uint8_t* data, uint8_t len) {\n    if (len >= 1) {\n        uint8_t status = data[0];\n        automotiveCanLog_fixed(\"Door Status handler: Status processed.\");\n    } else {\n        automotiveCanLog_fixed(\"Door Status handler: Invalid data length.\");\n    }\n}\n\ntypedef void (*CanHandlerFunc)(const uint8_t* data, uint8_t len);\n\nstatic CanHandlerFunc g_canHandlers_fixed[NUM_CAN_HANDLERS];\n\nvoid initializeCanHandlers_fixed() {\n    g_canHandlers_fixed[0] = handleEngineRPM_fixed;\n    g_canHandlers_fixed[1] = handleVehicleSpeed_fixed;\n    g_canHandlers_fixed[2] = handleBrakePressure_fixed;\n    g_canHandlers_fixed[3] = handleSteeringAngle_fixed;\n    g_canHandlers_fixed[4] = handleDoorStatus_fixed;\n    automotiveCanLog_fixed(\"CAN handlers initialized (Fixed).\");\n}\n\nCanMessage receiveCanMessage_fixed() {\n    CanMessage msg;\n    msg.message_id = CAN_MSG_ID_BASE - 1;\n    msg.data_len = 2;\n    msg.data[0] = 0xAA;\n    msg.data[1] = 0xBB;\n    automotiveCanLog_fixed(\"Simulating reception of malicious CAN message (fixed).\");\n    return msg;\n}\n\nvoid processCanMessage_fixed(CanMessage msg) {\n    if (msg.message_id >= CAN_MSG_ID_BASE && msg.message_id < (CAN_MSG_ID_BASE + NUM_CAN_HANDLERS)) {\n        uint16_t handler_index = msg.message_id - CAN_MSG_ID_BASE;\n        if (handler_index < NUM_CAN_HANDLERS) {\n            g_canHandlers_fixed[handler_index](msg.data, msg.data_len);\n            automotiveCanLog_fixed(\"CAN message processed successfully (fixed).\");\n        } else {\n            automotiveCanLog_fixed(\"CAN message processing failed: Calculated handler index out of bounds (fixed).\");\n        }\n    } else {\n        automotiveCanLog_fixed(\"CAN message processing failed: Message ID out of expected range (fixed).\");\n    }\n}\n\nvoid canCommunicationModuleMain_fixed() {\n    initializeCanHandlers_fixed();\n    CanMessage incoming_msg = receiveCanMessage_fixed();\n    processCanMessage_fixed(incoming_msg);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_INCOMING_FAULT_MSG_SIZE 256\n#define MAX_FAULT_DESCRIPTION_LEN 64\n\ntypedef enum {\n    SEVERITY_INFO = 0,\n    SEVERITY_WARNING,\n    SEVERITY_CRITICAL\n} FaultSeverity;\n\ntypedef struct {\n    uint16_t      fault_id;\n    FaultSeverity severity;\n    char          description[MAX_FAULT_DESCRIPTION_LEN];\n} ParsedFaultEntry;\n\nstatic ParsedFaultEntry g_lastFaultEntry;\n\nvoid initFaultEntry() {\n    memset(&g_lastFaultEntry, 0, sizeof(ParsedFaultEntry));\n}\n\nint processFaultMessage(const uint8_t* raw_msg, uint16_t msg_len) {\n    if (raw_msg == NULL || msg_len < (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    if (msg_len > MAX_INCOMING_FAULT_MSG_SIZE) {\n        return -2;\n    }\n\n    uint16_t current_offset = 0;\n\n    g_lastFaultEntry.fault_id = (raw_msg[current_offset] << 8) | raw_msg[current_offset + 1];\n    current_offset += sizeof(uint16_t);\n\n    g_lastFaultEntry.severity = (FaultSeverity)raw_msg[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    uint8_t incoming_description_len = raw_msg[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    if (current_offset + incoming_description_len > msg_len) {\n        return -3;\n    }\n\n    uint8_t bytes_to_copy = incoming_description_len;\n    if (bytes_to_copy >= MAX_FAULT_DESCRIPTION_LEN) {\n        bytes_to_copy = MAX_FAULT_DESCRIPTION_LEN - 1;\n    }\n    \n    memcpy(g_lastFaultEntry.description, raw_msg + current_offset, bytes_to_copy);\n    g_lastFaultEntry.description[bytes_to_copy] = '\\0';\n\n    return 0;\n}\n\nconst ParsedFaultEntry* getLastFaultEntry() {\n    return &g_lastFaultEntry;\n}\n\nvoid receiveSimulatedFaultData(const uint8_t* data, uint16_t len) {\n    processFaultMessage(data, len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_CONFIG_STATES 10\n#define CONFIG_DATA_BLOCK_SIZE 24\n#define CONFIG_VERSION_BYTE_SIZE 1\n#define CONFIG_STATE_TOTAL_SIZE (CONFIG_VERSION_BYTE_SIZE + CONFIG_DATA_BLOCK_SIZE)\n\nstatic uint8_t g_config_state_storage[MAX_CONFIG_STATES * CONFIG_STATE_TOTAL_SIZE];\nstatic int16_t g_current_active_config_idx = 0;\n\nvoid init_config_storage() {\n    memset(g_config_state_storage, 0, sizeof(g_config_state_storage));\n    g_current_active_config_idx = 0;\n    for (int i = 0; i < MAX_CONFIG_STATES; ++i) {\n        g_config_state_storage[i * CONFIG_STATE_TOTAL_SIZE] = 0x00;\n    }\n}\n\nbool store_config_state(const uint8_t* config_data, uint8_t version) {\n    if (config_data == NULL || version == 0x00) {\n        return false;\n    }\n    if (g_current_active_config_idx >= MAX_CONFIG_STATES) {\n        return false;\n    }\n\n    uint32_t write_offset = g_current_active_config_idx * CONFIG_STATE_TOTAL_SIZE;\n    g_config_state_storage[write_offset] = version;\n    memcpy(&g_config_state_storage[write_offset + CONFIG_VERSION_BYTE_SIZE], config_data, CONFIG_DATA_BLOCK_SIZE);\n\n    g_current_active_config_idx++;\n    return true;\n}\n\nvoid decrement_config_version_vulnerable(uint16_t offset_from_current) {\n    if (g_current_active_config_idx == 0 || offset_from_current == 0) {\n        return;\n    }\n\n    int32_t target_logical_idx = (g_current_active_config_idx - 1) - offset_from_current;\n\n    uint8_t current_version = g_config_state_storage[target_logical_idx * CONFIG_STATE_TOTAL_SIZE];\n    if (current_version > 0x01) {\n        g_config_state_storage[target_logical_idx * CONFIG_STATE_TOTAL_SIZE] = current_version - 1;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_MESSAGE_TYPE_HANDLERS 10\n#define MESSAGE_DATA_SIZE 64\n\nvoid log_warning(const char* msg) {}\nvoid log_error(const char* msg) {}\n\ntypedef struct {\n    uint16_t message_id;\n    uint8_t  message_type;\n    uint8_t  sequence_num;\n    uint32_t timestamp;\n    uint8_t  data[MESSAGE_DATA_SIZE];\n    uint16_t data_len;\n} VehicleMessage;\n\ntypedef void (*MessageHandler)(const VehicleMessage*);\nstatic MessageHandler g_message_handlers_fixed[MAX_MESSAGE_TYPE_HANDLERS];\n\nvoid handle_engine_status(const VehicleMessage* msg) {\n    log_warning(\"Processing Engine Status message.\");\n}\n\nvoid handle_brake_status(const VehicleMessage* msg) {\n    log_warning(\"Processing Brake Status message.\");\n}\n\nvoid handle_door_status(const VehicleMessage* msg) {\n    log_warning(\"Processing Door Status message.\");\n}\n\nvoid handle_tire_pressure(const VehicleMessage* msg) {\n    log_warning(\"Processing Tire Pressure message.\");\n}\n\nvoid handle_undefined_message(const VehicleMessage* msg) {\n    log_warning(\"Processing Undefined/Reserved Message Type.\");\n}\n\nvoid handle_invalid_message_type(const VehicleMessage* msg) {\n    log_error(\"Received message with invalid type. Index out of bounds.\");\n}\n\nVehicleMessage receive_vehicle_message_fixed() {\n    VehicleMessage msg;\n    msg.message_type = MAX_MESSAGE_TYPE_HANDLERS; \n    msg.message_id = 0x1234;\n    msg.sequence_num = 1;\n    msg.timestamp = 0;\n    msg.data_len = 0;\n    return msg;\n}\n\nvoid init_message_handlers_fixed() {\n    g_message_handlers_fixed[0] = handle_engine_status;\n    g_message_handlers_fixed[1] = handle_brake_status;\n    g_message_handlers_fixed[2] = handle_door_status;\n    g_message_handlers_fixed[3] = handle_tire_pressure;\n    for (int i = 4; i < MAX_MESSAGE_TYPE_HANDLERS; ++i) {\n        g_message_handlers_fixed[i] = handle_undefined_message;\n    }\n}\n\nvoid process_incoming_vehicle_messages_fixed() {\n    VehicleMessage msg = receive_vehicle_message_fixed();\n\n    if (msg.message_type < MAX_MESSAGE_TYPE_HANDLERS) {\n        g_message_handlers_fixed[msg.message_type](&msg);\n    } else {\n        handle_invalid_message_type(&msg);\n    }\n}\n\nvoid vehicle_gateway_main_fixed() {\n    init_message_handlers_fixed();\n    process_incoming_vehicle_messages_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_TEMPERATURE_SENSORS 10\n#define MAX_PRESSURE_SENSORS 5\n#define MAX_FUEL_LEVEL_SENSORS 2\n\ntypedef struct {\n    int16_t offset;\n    float gain;\n    uint8_t status_flags;\n} TemperatureCalibration;\n\ntypedef struct {\n    int16_t offset_low;\n    int16_t offset_high;\n    float gain;\n    uint8_t checksum;\n} PressureCalibration;\n\ntypedef struct {\n    uint16_t empty_resistance_ohm;\n    uint16_t full_resistance_ohm;\n} FuelLevelCalibration;\n\nstatic TemperatureCalibration g_tempCalibData_fixed[MAX_TEMPERATURE_SENSORS];\nstatic PressureCalibration g_pressureCalibData_fixed[MAX_PRESSURE_SENSORS];\nstatic FuelLevelCalibration g_fuelLevelCalibData_fixed[MAX_FUEL_LEVEL_SENSORS];\n\ntypedef enum {\n    SENSOR_TYPE_TEMP = 0,\n    SENSOR_TYPE_PRESSURE,\n    SENSOR_TYPE_FUEL_LEVEL,\n    NUM_SENSOR_TYPES_CALIB\n} SensorCalibrationType;\n\ntypedef struct {\n    uint8_t command_type;\n    uint8_t sensor_type_id;\n    uint8_t sensor_instance_id;\n    union {\n        TemperatureCalibration temp_cal;\n        PressureCalibration pres_cal;\n        FuelLevelCalibration fuel_cal;\n    } cal_data;\n} CalibrationCommand;\n\nvoid systemLog(const char* msg) {\n}\n\nCalibrationCommand receiveCalibrationCommand_fixed() {\n    CalibrationCommand cmd;\n    cmd.command_type = 0x01;\n    cmd.sensor_type_id = SENSOR_TYPE_TEMP;\n    cmd.sensor_instance_id = MAX_TEMPERATURE_SENSORS;\n    cmd.cal_data.temp_cal = (TemperatureCalibration){-5, 1.05f, 0x0F};\n    return cmd;\n}\n\nvoid initializeCalibrationData_fixed() {\n    for (uint8_t i = 0; i < MAX_TEMPERATURE_SENSORS; ++i) {\n        g_tempCalibData_fixed[i] = (TemperatureCalibration){0, 1.0f, 0};\n    }\n    for (uint8_t i = 0; i < MAX_PRESSURE_SENSORS; ++i) {\n        g_pressureCalibData_fixed[i] = (PressureCalibration){0, 0, 1.0f, 0};\n    }\n    for (uint8_t i = 0; i < MAX_FUEL_LEVEL_SENSORS; ++i) {\n        g_fuelLevelCalibData_fixed[i] = (FuelLevelCalibration){0, 0};\n    }\n    systemLog(\"Calibration data initialized (fixed).\");\n}\n\nvoid processCalibrationCommand_fixed() {\n    CalibrationCommand cmd = receiveCalibrationCommand_fixed();\n\n    if (cmd.command_type == 0x01) {\n        switch (cmd.sensor_type_id) {\n            case SENSOR_TYPE_TEMP:\n                if (cmd.sensor_instance_id < MAX_TEMPERATURE_SENSORS) {\n                    g_tempCalibData_fixed[cmd.sensor_instance_id] = cmd.cal_data.temp_cal;\n                    systemLog(\"Temperature sensor calibration updated successfully (fixed).\");\n                } else {\n                    systemLog(\"Temperature sensor instance ID out of bounds. Update ignored (fixed).\");\n                }\n                break;\n            case SENSOR_TYPE_PRESSURE:\n                if (cmd.sensor_instance_id < MAX_PRESSURE_SENSORS) {\n                    g_pressureCalibData_fixed[cmd.sensor_instance_id] = cmd.cal_data.pres_cal;\n                    systemLog(\"Pressure sensor calibration updated successfully (fixed).\");\n                } else {\n                    systemLog(\"Pressure sensor instance ID out of bounds. Update ignored (fixed).\");\n                }\n                break;\n            case SENSOR_TYPE_FUEL_LEVEL:\n                if (cmd.sensor_instance_id < MAX_FUEL_LEVEL_SENSORS) {\n                    g_fuelLevelCalibData_fixed[cmd.sensor_instance_id] = cmd.cal_data.fuel_cal;\n                    systemLog(\"Fuel level sensor calibration updated successfully (fixed).\");\n                } else {\n                    systemLog(\"Fuel level sensor instance ID out of bounds. Update ignored (fixed).\");\n                }\n                break;\n            default:\n                systemLog(\"Unknown sensor type ID in calibration command. Command ignored (fixed).\");\n                break;\n        }\n    } else {\n        systemLog(\"Unsupported calibration command type. Command ignored (fixed).\");\n    }\n}\n\nvoid sensorCalibrationManager_fixed_main() {\n    initializeCalibrationData_fixed();\n    processCalibrationCommand_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#define MAX_BATTERY_CELLS 96\n#define BMS_CMD_UPDATE_VOLTAGE 0x01\n#define BMS_CMD_UPDATE_TEMP    0x02\n\ntypedef struct {\n    unsigned short voltage_mV;\n    short temperature_C;\n    unsigned char state_of_charge_percent;\n} BatteryCellInfo;\n\nstatic BatteryCellInfo g_batteryCellInfo[MAX_BATTERY_CELLS];\n\ntypedef struct {\n    unsigned char commandType;\n    unsigned char cellId;\n    unsigned short dataValue;\n} BMS_Command;\n\nvoid logBMSWarning(const char* msg) {\n}\n\nBMS_Command receiveBMSCommand_simulated_fixed() {\n    BMS_Command cmd;\n    cmd.commandType = BMS_CMD_UPDATE_VOLTAGE;\n    cmd.cellId = 100;\n    cmd.dataValue = 3800;\n    return cmd;\n}\n\nvoid initializeBMSData() {\n    for (unsigned int i = 0; i < MAX_BATTERY_CELLS; ++i) {\n        g_batteryCellInfo[i].voltage_mV = 0;\n        g_batteryCellInfo[i].temperature_C = 0;\n        g_batteryCellInfo[i].state_of_charge_percent = 0;\n    }\n}\n\nvoid processBMSCommand_fixed() {\n    BMS_Command cmd = receiveBMSCommand_simulated_fixed();\n\n    if (cmd.cellId >= MAX_BATTERY_CELLS) {\n        logBMSWarning(\"Received BMS command with out-of-bounds cell ID. Ignoring.\");\n        return;\n    }\n\n    if (cmd.commandType == BMS_CMD_UPDATE_VOLTAGE) {\n        g_batteryCellInfo[cmd.cellId].voltage_mV = cmd.dataValue;\n    } else if (cmd.commandType == BMS_CMD_UPDATE_TEMP) {\n        g_batteryCellInfo[cmd.cellId].temperature_C = (short)cmd.dataValue;\n    } else {\n        logBMSWarning(\"Unknown BMS command received.\");\n    }\n}\n\nvoid bmsModuleMain_fixed() {\n    initializeBMSData();\n    processBMSCommand_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_VEHICLE_EVENTS 100\n#define EVENT_ENTRY_WORD_SIZE 4\n\ntypedef struct {\n    uint32_t event_id;\n    uint32_t timestamp_ms;\n    uint32_t flags;\n    uint32_t reserved;\n} VehicleEventEntry;\n\nstatic uint32_t g_event_log_words[MAX_VEHICLE_EVENTS * EVENT_ENTRY_WORD_SIZE];\nstatic uint16_t g_next_write_word_idx = 0;\nstatic uint16_t g_num_logged_events = 0;\n\nvoid init_event_logger() {\n    memset(g_event_log_words, 0, sizeof(g_event_log_words));\n    g_next_write_word_idx = 0;\n    g_num_logged_events = 0;\n}\n\nbool log_vehicle_event(uint32_t event_id, uint32_t timestamp, uint32_t flags) {\n    if (g_num_logged_events >= MAX_VEHICLE_EVENTS) {\n        return false;\n    }\n\n    uint16_t current_entry_start_word_idx = g_next_write_word_idx;\n\n    g_event_log_words[current_entry_start_word_idx + 0] = event_id;\n    g_event_log_words[current_entry_start_word_idx + 1] = timestamp;\n    g_event_log_words[current_entry_start_word_idx + 2] = flags;\n    g_event_log_words[current_entry_start_word_idx + 3] = 0;\n\n    g_next_write_word_idx += EVENT_ENTRY_WORD_SIZE;\n    g_num_logged_events++;\n    return true;\n}\n\nvoid update_event_flags_vulnerable(uint16_t event_index_from_latest, uint32_t new_flags) {\n    if (g_num_logged_events == 0) {\n        return;\n    }\n\n    uint16_t latest_event_start_word_idx = g_next_write_word_idx - EVENT_ENTRY_WORD_SIZE;\n\n    int32_t target_event_start_word_idx = (int32_t)latest_event_start_word_idx - ((int32_t)event_index_from_latest * EVENT_ENTRY_WORD_SIZE);\n\n    g_event_log_words[target_event_start_word_idx + 2] = new_flags;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_FIRMWARE_CHUNK_SIZE 256\n#define FIRMWARE_BLOCK_BUFFER_SIZE 4096\n#define TOTAL_FIRMWARE_IMAGE_SIZE 1048576\n\ntypedef struct {\n    uint32_t address_offset;\n    uint16_t data_length;\n    uint8_t  data[MAX_FIRMWARE_CHUNK_SIZE];\n} FirmwarePacket;\n\ntypedef struct {\n    uint32_t current_block_address;\n    uint8_t  firmware_block_buffer[FIRMWARE_BLOCK_BUFFER_SIZE];\n    uint32_t bytes_in_current_block;\n    bool     update_in_progress;\n} FirmwareUpdateContext;\n\nstatic FirmwareUpdateContext g_fwUpdateContext = {0};\n\nvoid initFirmwareUpdater() {\n    memset(&g_fwUpdateContext, 0, sizeof(FirmwareUpdateContext));\n    g_fwUpdateContext.update_in_progress = false;\n}\n\nint handleFirmwarePacket(const FirmwarePacket* packet) {\n    if (packet == NULL || packet->data_length == 0 || packet->data_length > MAX_FIRMWARE_CHUNK_SIZE) {\n        return -1;\n    }\n\n    if (!g_fwUpdateContext.update_in_progress) {\n        return -1;\n    }\n\n    uint32_t global_target_offset = packet->address_offset;\n    uint16_t chunk_len = packet->data_length;\n\n    if (global_target_offset + chunk_len > TOTAL_FIRMWARE_IMAGE_SIZE) {\n        return -2;\n    }\n\n    uint32_t packet_block_base_address = global_target_offset / FIRMWARE_BLOCK_BUFFER_SIZE * FIRMWARE_BLOCK_BUFFER_SIZE;\n    uint32_t offset_within_block = global_target_offset % FIRMWARE_BLOCK_BUFFER_SIZE;\n\n    if (g_fwUpdateContext.current_block_address != packet_block_base_address) {\n        memset(g_fwUpdateContext.firmware_block_buffer, 0, FIRMWARE_BLOCK_BUFFER_SIZE);\n        g_fwUpdateContext.bytes_in_current_block = 0;\n        g_fwUpdateContext.current_block_address = packet_block_base_address;\n    }\n\n    memcpy(g_fwUpdateContext.firmware_block_buffer + offset_within_block, packet->data, chunk_len);\n\n    if (offset_within_block + chunk_len > g_fwUpdateContext.bytes_in_current_block) {\n        g_fwUpdateContext.bytes_in_current_block = offset_within_block + chunk_len;\n    }\n\n    return 0;\n}\n\nvoid startFirmwareUpdate() {\n    g_fwUpdateContext.update_in_progress = true;\n    g_fwUpdateContext.current_block_address = 0;\n    g_fwUpdateContext.bytes_in_current_block = 0;\n    memset(g_fwUpdateContext.firmware_block_buffer, 0, FIRMWARE_BLOCK_BUFFER_SIZE);\n}\n\nvoid endFirmwareUpdate() {\n    g_fwUpdateContext.update_in_progress = false;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#define DTC_MAX_COUNT 100\n#define DIAG_CMD_GET_DTC_STATUS 0x01\n#define DTC_STATUS_INACTIVE 0x00\n#define DTC_STATUS_ACTIVE 0x01\n#define DTC_STATUS_CONFIRMED 0x03\ntypedef struct {\n    unsigned short command_id;\n    unsigned short dtc_index;\n    unsigned char  padding[4];\n} DiagnosticRequest;\ntypedef struct {\n    unsigned short command_id;\n    unsigned char  dtc_status;\n    unsigned char  response_code;\n    unsigned char  padding[3];\n} DiagnosticResponse;\nstatic unsigned char g_dtcStatus[DTC_MAX_COUNT];\nDiagnosticRequest getSimulatedDiagnosticRequest() {\n    DiagnosticRequest req;\n    req.command_id = DIAG_CMD_GET_DTC_STATUS;\n    req.dtc_index = 101;\n    req.padding[0] = req.padding[1] = req.padding[2] = req.padding[3] = 0;\n    return req;\n}\nvoid sendDiagnosticResponse(const DiagnosticResponse* res) {}\nvoid logSecurityEvent(const char* event) {}\nvoid initializeDTCStates() {\n    for (int i = 0; i < DTC_MAX_COUNT; ++i) {\n        g_dtcStatus[i] = DTC_STATUS_INACTIVE;\n    }\n    g_dtcStatus[0] = DTC_STATUS_ACTIVE;\n    g_dtcStatus[50] = DTC_STATUS_CONFIRMED;\n}\nvoid handleDiagnosticRequest() {\n    DiagnosticRequest request = getSimulatedDiagnosticRequest();\n    DiagnosticResponse response;\n    response.command_id = request.command_id;\n    response.response_code = 0x00;\n    if (request.command_id == DIAG_CMD_GET_DTC_STATUS) {\n        response.dtc_status = g_dtcStatus[request.dtc_index];\n    } else {\n        response.response_code = 0x01;\n        response.dtc_status = 0x00;\n    }\n    sendDiagnosticResponse(&response);\n}\nvoid diagnosticModuleLoop() {\n    initializeDTCStates();\n    handleDiagnosticRequest();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SENSOR_DATA_BUFFER_SIZE 32\n#define MAX_SENSOR_VALUE 1023\n\ntypedef struct {\n    uint16_t value;\n    uint32_t timestamp_ms;\n    uint8_t  status_flags;\n} SensorSample;\n\nstatic SensorSample g_sensor_data_buffer_fixed[SENSOR_DATA_BUFFER_SIZE];\nstatic uint8_t g_next_write_idx_fixed = 0;\nstatic bool g_buffer_full_fixed = false;\n\nvoid init_sensor_data_buffer_fixed() {\n    memset(g_sensor_data_buffer_fixed, 0, sizeof(g_sensor_data_buffer_fixed));\n    g_next_write_idx_fixed = 0;\n    g_buffer_full_fixed = false;\n}\n\nvoid add_sensor_sample_fixed(uint16_t value, uint32_t timestamp, uint8_t flags) {\n    g_sensor_data_buffer_fixed[g_next_write_idx_fixed].value = value;\n    g_sensor_data_buffer_fixed[g_next_write_idx_fixed].timestamp_ms = timestamp;\n    g_sensor_data_buffer_fixed[g_next_write_idx_fixed].status_flags = flags;\n\n    g_next_write_idx_fixed = (g_next_write_idx_fixed + 1) % SENSOR_DATA_BUFFER_SIZE;\n    if (g_next_write_idx_fixed == 0) {\n        g_buffer_full_fixed = true;\n    }\n}\n\nvoid update_historical_sensor_value_fixed(int32_t sample_offset_from_last, uint16_t new_value) {\n    if (!g_buffer_full_fixed && g_next_write_idx_fixed == 0) {\n        return;\n    }\n\n    int32_t last_sample_idx = (g_next_write_idx_fixed == 0 && g_buffer_full_fixed) ?\n                              (SENSOR_DATA_BUFFER_SIZE - 1) :\n                              (g_next_write_idx_fixed - 1);\n\n    int32_t current_samples_count = g_buffer_full_fixed ? SENSOR_DATA_BUFFER_SIZE : g_next_write_idx_fixed;\n\n    if (sample_offset_from_last < 0 || sample_offset_from_last >= current_samples_count) {\n        return;\n    }\n\n    int32_t target_idx = (last_sample_idx - sample_offset_from_last + SENSOR_DATA_BUFFER_SIZE) % SENSOR_DATA_BUFFER_SIZE;\n\n    g_sensor_data_buffer_fixed[target_idx].value = new_value;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\ntypedef enum {\n    DIAG_GROUP_ENGINE_FIXED = 0,\n    DIAG_GROUP_TRANSMISSION_FIXED,\n    DIAG_GROUP_SAFETY_FIXED,\n    DIAG_GROUP_INFOTAINMENT_FIXED,\n    NUM_DIAG_GROUPS_FIXED\n} DiagnosticEventGroup_Fixed;\n\ntypedef struct {\n    uint16_t event_code;\n    const char* description;\n    bool is_critical;\n} EventDefinition_Fixed;\n\nstatic EventDefinition_Fixed engineEventDefinitions_fixed[] = {\n    {0x1001, \"Engine Overheat\", true},\n    {0x1002, \"Misfire Cylinder 1\", true},\n    {0x1003, \"Low Oil Pressure\", true},\n    {0x1004, \"High Exhaust Temp\", false},\n    {0x1005, \"Idle Speed Deviation\", false}\n};\n#define ACTUAL_ENGINE_EVENTS_FIXED (sizeof(engineEventDefinitions_fixed) / sizeof(EventDefinition_Fixed))\n\nstatic EventDefinition_Fixed transmissionEventDefinitions_fixed[] = {\n    {0x2001, \"Transmission Overload\", true},\n    {0x2002, \"Gear Shift Malfunction\", true},\n    {0x2003, \"Clutch Slip Detected\", false}\n};\n#define ACTUAL_TRANSMISSION_EVENTS_FIXED (sizeof(transmissionEventDefinitions_fixed) / sizeof(EventDefinition_Fixed))\n\nstatic EventDefinition_Fixed safetyEventDefinitions_fixed[] = {\n    {0x3001, \"ABS Sensor Fault FL\", true},\n    {0x3002, \"Airbag Deployment Trigger\", true},\n    {0x3003, \"Seatbelt Pretensioner Fault\", false},\n    {0x3004, \"ESC System Error\", true},\n    {0x3005, \"Blind Spot Monitor Malf.\", false}\n};\n#define ACTUAL_SAFETY_EVENTS_FIXED (sizeof(safetyEventDefinitions_fixed) / sizeof(EventDefinition_Fixed))\n\nstatic EventDefinition_Fixed infotainmentEventDefinitions_fixed[] = {\n    {0x4001, \"Navigation System Error\", false},\n    {0x4002, \"Audio System Fault\", false}\n};\n#define ACTUAL_INFOTAINMENT_EVENTS_FIXED (sizeof(infotainmentEventDefinitions_fixed) / sizeof(EventDefinition_Fixed))\n\ntypedef struct {\n    EventDefinition_Fixed* events_ptr;\n    uint8_t count;\n} EventGroupRegistryEntry_Fixed;\n\nstatic EventGroupRegistryEntry_Fixed g_eventGroupRegistry_fixed[NUM_DIAG_GROUPS_FIXED];\n\nvoid diagnosticLog_fixed(const char* msg) {\n}\n\nvoid initializeDiagnosticSystem_fixed() {\n    g_eventGroupRegistry_fixed[DIAG_GROUP_ENGINE_FIXED] = (EventGroupRegistryEntry_Fixed){engineEventDefinitions_fixed, ACTUAL_ENGINE_EVENTS_FIXED};\n    g_eventGroupRegistry_fixed[DIAG_GROUP_TRANSMISSION_FIXED] = (EventGroupRegistryEntry_Fixed){transmissionEventDefinitions_fixed, ACTUAL_TRANSMISSION_EVENTS_FIXED};\n    g_eventGroupRegistry_fixed[DIAG_GROUP_SAFETY_FIXED] = (EventGroupRegistryEntry_Fixed){safetyEventDefinitions_fixed, ACTUAL_SAFETY_EVENTS_FIXED};\n    g_eventGroupRegistry_fixed[DIAG_GROUP_INFOTAINMENT_FIXED] = (EventGroupRegistryEntry_Fixed){infotainmentEventDefinitions_fixed, ACTUAL_INFOTAINMENT_EVENTS_FIXED};\n    diagnosticLog_fixed(\"Diagnostic system initialized (fixed).\");\n}\n\ntypedef struct {\n    DiagnosticEventGroup_Fixed group_id;\n    uint8_t event_type_idx;\n} EventLookupRequest_Fixed;\n\nEventLookupRequest_Fixed receiveEventLookupRequest_fixed() {\n    EventLookupRequest_Fixed req;\n    req.group_id = DIAG_GROUP_TRANSMISSION_FIXED;\n    req.event_type_idx = 4;\n    return req;\n}\n\nvoid getEventDetails_fixed() {\n    EventLookupRequest_Fixed req = receiveEventLookupRequest_fixed();\n\n    if (req.group_id >= NUM_DIAG_GROUPS_FIXED) {\n        diagnosticLog_fixed(\"Error: Invalid event group ID.\");\n        return;\n    }\n\n    if (req.event_type_idx >= g_eventGroupRegistry_fixed[req.group_id].count) {\n        diagnosticLog_fixed(\"Error: Event type index out of bounds for the selected group.\");\n        return;\n    }\n    \n    EventDefinition_Fixed selected_event = g_eventGroupRegistry_fixed[req.group_id].events_ptr[req.event_type_idx];\n    diagnosticLog_fixed(\"Attempted to retrieve event details (fixed).\");\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits> // For SIZE_MAX\n\n// Represents a single diagnostic event's metadata\nstruct EventMetadata {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t payload_length; // Actual length of this specific event's payload\n};\n\n// --- Fixed Class ---\n// Designed to store a stream of diagnostic events in a pre-allocated contiguous buffer.\nclass DiagnosticStorageFixed {\npublic:\n    // Constructor: Allocates a buffer based on an expected maximum number of events\n    // and a 'configured' maximum payload size per event. This 'configured' size\n    // is used to determine the fixed slot size for each event in the buffer.\n    DiagnosticStorageFixed(uint32_t max_total_events, uint16_t configured_max_payload_per_event)\n        : m_buffer(nullptr), m_buffer_capacity_bytes(0), m_current_event_count(0),\n          m_configured_max_payload_size(configured_max_payload_per_event) {\n\n        if (max_total_events == 0 || configured_max_payload_per_event == 0) {\n            return;\n        }\n\n        // Calculate the fixed size of each slot in the buffer.\n        // This size includes the EventMetadata and a fixed-size payload area\n        // based on 'configured_max_payload_per_event'.\n        size_t bytes_per_event_slot = sizeof(EventMetadata) + configured_max_payload_per_event;\n        \n        // Basic overflow check for the size_t calculation\n        if (max_total_events > SIZE_MAX / bytes_per_event_slot) {\n            // Prevent immediate integer overflow during allocation size calculation\n            return;\n        }\n\n        m_buffer_capacity_bytes = max_total_events * bytes_per_event_slot;\n        m_buffer = (uint8_t*)malloc(m_buffer_capacity_bytes);\n\n        if (m_buffer == nullptr && m_buffer_capacity_bytes > 0) {\n            m_buffer_capacity_bytes = 0; // Allocation failed\n        }\n    }\n\n    ~DiagnosticStorageFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    // Stores a single diagnostic event into the internal buffer.\n    // 'event_data' points to a byte stream containing EventMetadata followed by its payload.\n    // 'data_len' is the total length of 'event_data' (metadata + payload).\n    bool storeEventFixed(const uint8_t* event_data, size_t data_len) {\n        if (!event_data || data_len < sizeof(EventMetadata) || m_buffer == nullptr) {\n            return false;\n        }\n\n        const EventMetadata* incoming_meta = reinterpret_cast<const EventMetadata*>(event_data);\n        uint16_t actual_payload_len = incoming_meta->payload_length;\n        \n        // FIX: Add a crucial check to ensure that the actual payload length of the\n        // incoming event does not exceed the 'configured_max_payload_size'.\n        // This prevents an individual event from overflowing its pre-allocated slot.\n        if (actual_payload_len > m_configured_max_payload_size) {\n            return false; // Reject event as its payload is too large for the configured slot size\n        }\n\n        size_t total_incoming_event_size = sizeof(EventMetadata) + actual_payload_len;\n\n        // Ensure the incoming data itself is complete and not truncated\n        if (data_len < total_incoming_event_size) {\n            return false;\n        }\n\n        // Calculate the target offset in the internal buffer for the new event.\n        // This calculation relies on m_configured_max_payload_size for the slot size.\n        size_t bytes_per_event_slot = sizeof(EventMetadata) + m_configured_max_payload_size;\n        size_t write_offset = m_current_event_count * bytes_per_event_slot;\n\n        // Ensure there is enough overall buffer capacity for the current event's slot.\n        // This check is now effective, as 'total_incoming_event_size' is guaranteed\n        // to be less than or equal to 'bytes_per_event_slot' after the fix.\n        if (write_offset > m_buffer_capacity_bytes ||\n            write_offset + bytes_per_event_slot > m_buffer_capacity_bytes) {\n            return false;\n        }\n        \n        // memcpy is now safe because total_incoming_event_size is guaranteed to fit within the slot.\n        memcpy(m_buffer + write_offset, event_data, total_incoming_event_size);\n\n        m_current_event_count++;\n        return true;\n    }\n\n    size_t getStoredEventCount() const { return m_current_event_count; }\n    size_t getAllocatedCapacityBytes() const { return m_buffer_capacity_bytes; }\n    const uint8_t* getBuffer() const { return m_buffer; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_buffer_capacity_bytes;\n    uint32_t m_current_event_count;\n    uint16_t m_configured_max_payload_size; // Maximum payload size assumed for each slot during allocation\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#define NUM_VEHICLE_MODES 4\n#define NUM_MODE_PARAMS 3\n\ntypedef enum {\n    MODE_PARAM_THROTTLE = 0,\n    MODE_PARAM_SUSPENSION,\n    MODE_PARAM_STEERING\n} ModeParameterIndex;\n\ntypedef struct {\n    int parameters[NUM_MODE_PARAMS];\n} VehicleModeConfig;\n\nstatic VehicleModeConfig g_vehicleModeConfigurations[NUM_VEHICLE_MODES];\n\ntypedef struct {\n    unsigned char mode_id;\n    unsigned char parameter_idx;\n    int new_value;\n} ConfigurationUpdateCommand;\n\nConfigurationUpdateCommand receiveConfigUpdateCommand_vulnerable() {\n    ConfigurationUpdateCommand cmd;\n    cmd.mode_id = 0;\n    cmd.parameter_idx = 3;\n    cmd.new_value = 123;\n    return cmd;\n}\n\nvoid logSystemDiagnostic(const char* msg) {\n}\n\nvoid initializeVehicleConfigs_vulnerable() {\n    for (unsigned char i = 0; i < NUM_VEHICLE_MODES; ++i) {\n        for (unsigned char j = 0; j < NUM_MODE_PARAMS; ++j) {\n            g_vehicleModeConfigurations[i].parameters[j] = 50;\n        }\n    }\n}\n\nvoid applyVehicleConfigUpdate_vulnerable() {\n    ConfigurationUpdateCommand cmd = receiveConfigUpdateCommand_vulnerable();\n\n    if (cmd.mode_id < NUM_VEHICLE_MODES) {\n        g_vehicleModeConfigurations[cmd.mode_id].parameters[cmd.parameter_idx] = cmd.new_value;\n    } else {\n        logSystemDiagnostic(\"ERROR: Invalid mode ID received for configuration update.\");\n    }\n}\n\nvoid vehicleControlMain_vulnerable() {\n    initializeVehicleConfigs_vulnerable();\n    applyVehicleConfigUpdate_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#define MAX_DRIVING_MODES 4\ntypedef struct {\n    float throttle_response_factor;\n    unsigned char transmission_shift_aggressiveness;\n    unsigned char suspension_damping_level;\n    unsigned short steering_assist_level;\n} DrivingProfile;\nstatic DrivingProfile g_drivingProfiles[MAX_DRIVING_MODES] = {\n    {0.5f, 20, 0, 800},\n    {0.7f, 50, 1, 500},\n    {0.9f, 80, 2, 200},\n    {0.6f, 40, 3, 900}\n};\ntypedef struct {\n    unsigned char command_id;\n    unsigned char mode_index;\n    unsigned short reserved;\n} VehicleControlCommand;\nvoid log_vehicle_event(const char* event_msg) {}\nVehicleControlCommand receive_vehicle_command_fixed() {\n    VehicleControlCommand cmd;\n    cmd.command_id = 0x01;\n    cmd.mode_index = 5;\n    cmd.reserved = 0;\n    return cmd;\n}\nvoid apply_driving_mode_fixed(unsigned char mode_id) {\n    DrivingProfile selected_profile = g_drivingProfiles[mode_id];\n    log_vehicle_event(\"Applied driving mode profile.\");\n}\nvoid vehicle_control_loop_fixed() {\n    VehicleControlCommand command = receive_vehicle_command_fixed();\n    if (command.command_id == 0x01) {\n        if (command.mode_index < MAX_DRIVING_MODES) {\n            apply_driving_mode_fixed(command.mode_index);\n        } else {\n            log_vehicle_event(\"Received invalid driving mode index. Ignoring command.\");\n        }\n    } else {\n        log_vehicle_event(\"Unknown vehicle control command received.\");\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_FEATURES 10\n\ntypedef enum {\n    FEATURE_CRUISE_CONTROL = 0,\n    FEATURE_LANE_KEEP_ASSIST,\n    FEATURE_AEB,\n    FEATURE_PARKING_ASSIST,\n    FEATURE_INFOTAINMENT_MODE,\n    FEATURE_DRIVING_MODE,\n    FEATURE_HEADLIGHT_SENSITIVITY,\n    FEATURE_RAIN_SENSOR_ACTIVE,\n    FEATURE_TIRE_PRESSURE_MONITOR,\n    FEATURE_VEHICLE_DIAG_MODE,\n    FEATURE_COUNT\n} VehicleFeatureID_fixed;\n\ntypedef struct {\n    VehicleFeatureID_fixed id;\n    int32_t config_value;\n    bool is_active;\n} FeatureConfig_fixed;\n\nstatic FeatureConfig_fixed g_featureConfigurations_fixed[MAX_FEATURES];\n\nvoid systemLog_fixed(const char* message) {\n}\n\nvoid initializeFeatureSystem_fixed() {\n    for (uint16_t i = 0; i < MAX_FEATURES; ++i) {\n        g_featureConfigurations_fixed[i].id = (VehicleFeatureID_fixed)i;\n        g_featureConfigurations_fixed[i].config_value = 0;\n        g_featureConfigurations_fixed[i].is_active = false;\n    }\n    g_featureConfigurations_fixed[FEATURE_CRUISE_CONTROL].config_value = 100;\n    g_featureConfigurations_fixed[FEATURE_CRUISE_CONTROL].is_active = true;\n    g_featureConfigurations_fixed[FEATURE_DRIVING_MODE].config_value = 0;\n}\n\ntypedef struct {\n    uint16_t feature_id_raw;\n    int32_t value;\n    bool active_state;\n} FeatureUpdateCommand_fixed;\n\nFeatureUpdateCommand_fixed getSimulatedFeatureUpdateCommand_fixed() {\n    FeatureUpdateCommand_fixed cmd;\n    cmd.feature_id_raw = 10;\n    cmd.value = 500;\n    cmd.active_state = true;\n    return cmd;\n}\n\nvoid applyFeatureUpdate_fixed() {\n    FeatureUpdateCommand_fixed command = getSimulatedFeatureUpdateCommand_fixed();\n\n    if (command.feature_id_raw < MAX_FEATURES) {\n        g_featureConfigurations_fixed[command.feature_id_raw].config_value = command.value;\n        g_featureConfigurations_fixed[command.feature_id_raw].is_active = command.active_state;\n        systemLog_fixed(\"Feature update applied (fixed).\");\n    } else {\n        systemLog_fixed(\"Error: Received out-of-bounds feature ID for update. Ignoring command.\");\n    }\n}\n\nvoid featureManagerMain_fixed() {\n    initializeFeatureSystem_fixed();\n    applyFeatureUpdate_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define REASM_BUFFER_SIZE 256\n#define MIN_MESSAGE_HEADER_SIZE 4\n\ntypedef struct {\n    uint16_t id;\n    uint16_t length;\n    uint8_t  payload[1]; \n} MessageHeader;\n\nstatic uint8_t g_reasm_buffer[REASM_BUFFER_SIZE];\nstatic uint16_t g_filled_size = 0;\n\nvoid init_reasm_buffer() {\n    memset(g_reasm_buffer, 0, REASM_BUFFER_SIZE);\n    g_filled_size = 0;\n}\n\nbool add_reasm_data(const uint8_t* data, uint16_t len) {\n    if (g_filled_size + len > REASM_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_reasm_buffer + g_filled_size, data, len);\n    g_filled_size += len;\n    return true;\n}\n\nvoid finalize_message_block_vulnerable(int16_t message_start_offset) {\n    if (message_start_offset < 0 || message_start_offset >= g_filled_size) {\n        return;\n    }\n\n    if (message_start_offset + MIN_MESSAGE_HEADER_SIZE > g_filled_size) {\n        return;\n    }\n\n    MessageHeader* msg_header = (MessageHeader*)(g_reasm_buffer + message_start_offset);\n    uint16_t message_length = msg_header->length;\n\n    if (message_start_offset + message_length > g_filled_size || message_length == 0) {\n        return;\n    }\n\n    uint8_t calculated_status_byte = 0xAF;\n\n    g_reasm_buffer[message_start_offset - 1] = calculated_status_byte;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdlib.h>\n#include <limits> \n\n#define CHUNK_SIZE_BYTES 64\n\ntypedef struct {\n    uint32_t block_id;\n    uint32_t num_chunks; \n    uint32_t reserved; \n} DataBlockHeader;\n\nclass FirmwareUpdaterFixed {\npublic:\n    FirmwareUpdaterFixed() : firmware_buffer(nullptr), current_buffer_size(0) {}\n\n    ~FirmwareUpdaterFixed() {\n        if (firmware_buffer) {\n            free(firmware_buffer);\n            firmware_buffer = nullptr;\n        }\n    }\n\n    bool processFirmwareBlockFixed(const uint8_t* block_data, size_t data_len) {\n        if (!block_data || data_len < sizeof(DataBlockHeader)) {\n            return false;\n        }\n\n        const DataBlockHeader* header = reinterpret_cast<const DataBlockHeader*>(block_data);\n        uint32_t num_chunks = header->num_chunks;\n\n        if (CHUNK_SIZE_BYTES == 0 || num_chunks > (std::numeric_limits<uint32_t>::max() / CHUNK_SIZE_BYTES)) {\n            return false;\n        }\n\n        uint32_t total_payload_size = num_chunks * CHUNK_SIZE_BYTES;\n\n        if (data_len < sizeof(DataBlockHeader) + total_payload_size) {\n            return false;\n        }\n\n        if (firmware_buffer) {\n            free(firmware_buffer);\n            firmware_buffer = nullptr;\n        }\n\n        firmware_buffer = (uint8_t*)malloc(total_payload_size);\n        if (!firmware_buffer) {\n            return false;\n        }\n        current_buffer_size = total_payload_size;\n\n        const uint8_t* source_data_ptr = block_data + sizeof(DataBlockHeader);\n        for (uint32_t i = 0; i < total_payload_size; ++i) {\n            firmware_buffer[i] = source_data_ptr[i];\n        }\n\n        return true;\n    }\n\n    const uint8_t* getFirmwareBuffer() const { return firmware_buffer; }\n    size_t getBufferSize() const { return current_buffer_size; }\n\nprivate:\n    uint8_t* firmware_buffer;\n    size_t current_buffer_size;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define ECU_CONFIG_DATA_MAX_SIZE 128\n#define PARAM_ID_CUSTOM_SETTING 0x1A\n#define PARAM_ID_DIAG_MODE 0x05\n\nstatic uint8_t g_ecuConfigData[ECU_CONFIG_DATA_MAX_SIZE];\n\nvoid initEcuConfig() {\n    for (size_t i = 0; i < ECU_CONFIG_DATA_MAX_SIZE; ++i) {\n        g_ecuConfigData[i] = 0x00;\n    }\n    g_ecuConfigData[0] = 0xAA;\n    g_ecuConfigData[1] = 0xBB;\n    g_ecuConfigData[2] = 0xCC;\n}\n\nint processConfigParameter(const uint8_t* param_stream, uint16_t stream_len) {\n    if (param_stream == NULL || stream_len < 4) {\n        return -1;\n    }\n\n    uint16_t param_id = (param_stream[0] << 8) | param_stream[1];\n    uint16_t data_len = (param_stream[2] << 8) | param_stream[3];\n    const uint8_t* data_src_ptr = param_stream + 4;\n\n    if (4 + data_len > stream_len) {\n        return -2;\n    }\n\n    if (param_id == PARAM_ID_CUSTOM_SETTING) {\n        const uint8_t CUSTOM_SETTING_OFFSET = 10; \n\n        if (CUSTOM_SETTING_OFFSET >= ECU_CONFIG_DATA_MAX_SIZE) {\n            return -3;\n        }\n\n        if ((uint16_t)CUSTOM_SETTING_OFFSET + data_len > ECU_CONFIG_DATA_MAX_SIZE) {\n            return -5; \n        }\n        \n        uint8_t* dest_ptr = &g_ecuConfigData[CUSTOM_SETTING_OFFSET];\n        for (uint16_t i = 0; i < data_len; ++i) {\n            *dest_ptr = data_src_ptr[i];\n            dest_ptr++;\n        }\n    } else if (param_id == PARAM_ID_DIAG_MODE) {\n        if (data_len != 1) return -4;\n        g_ecuConfigData[0] = data_src_ptr[0];\n    } else {\n        return -99;\n    }\n\n    return 0;\n}\n\nuint8_t getEcuConfigByte(uint8_t index) {\n    if (index < ECU_CONFIG_DATA_MAX_SIZE) {\n        return g_ecuConfigData[index];\n    }\n    return 0xFF;\n}\n\nvoid receiveConfigUpdate(const uint8_t* msg_data, uint16_t msg_len) {\n    processConfigParameter(msg_data, msg_len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_ANOMALIES 64\n#define STATUS_BUFFER_START_OFFSET 10\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t sensor_id;\n    int32_t  value;\n    uint8_t  flags;\n} AnomalyEvent;\n\nstatic AnomalyEvent g_anomaly_events[MAX_ANOMALIES];\nstatic int g_num_anomalies = 0;\n\nstatic uint8_t g_event_processing_status[MAX_ANOMALIES + STATUS_BUFFER_START_OFFSET];\n\nvoid init_anomaly_system() {\n    memset(g_anomaly_events, 0, sizeof(g_anomaly_events));\n    memset(g_event_processing_status, 0, sizeof(g_event_processing_status));\n    g_num_anomalies = 0;\n}\n\nbool add_anomaly_event(uint32_t ts, uint16_t sid, int32_t val, uint8_t flgs) {\n    if (g_num_anomalies >= MAX_ANOMALIES) {\n        return false;\n    }\n    g_anomaly_events[g_num_anomalies].timestamp = ts;\n    g_anomaly_events[g_num_anomalies].sensor_id = sid;\n    g_anomaly_events[g_num_anomalies].value = val;\n    g_anomaly_events[g_num_anomalies].flags = flgs;\n    g_event_processing_status[STATUS_BUFFER_START_OFFSET + g_num_anomalies] = 0x01;\n    g_num_anomalies++;\n    return true;\n}\n\nstatic int find_anomaly_event_index(uint32_t ts, uint16_t sid) {\n    for (int i = 0; i < g_num_anomalies; ++i) {\n        if (g_anomaly_events[i].timestamp == ts && g_anomaly_events[i].sensor_id == sid) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid update_anomaly_status_property_vulnerable(uint32_t ts, uint16_t sid, int16_t offset_from_base_status, uint8_t new_value) {\n    int event_idx = find_anomaly_event_index(ts, sid);\n    if (event_idx == -1) {\n        return;\n    }\n\n    int base_status_idx = STATUS_BUFFER_START_OFFSET + event_idx;\n\n    int target_status_idx = base_status_idx + offset_from_base_status;\n\n    g_event_processing_status[target_status_idx] = new_value;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#define DATA_BUFFER_SIZE 256\n\nstatic uint8_t g_data_buffer[DATA_BUFFER_SIZE];\nstatic size_t g_data_stored_len = 0;\n\nvoid initialize_data_buffer() {\n    for (size_t i = 0; i < DATA_BUFFER_SIZE; ++i) {\n        g_data_buffer[i] = 0;\n    }\n    g_data_stored_len = 0;\n}\n\nbool append_data_block(const uint8_t* data, size_t len) {\n    if (g_data_stored_len + len > DATA_BUFFER_SIZE) {\n        return false;\n    }\n    for (size_t i = 0; i < len; ++i) {\n        g_data_buffer[g_data_stored_len + i] = data[i];\n    }\n    g_data_stored_len += len;\n    return true;\n}\n\nvoid process_data_block_status_vulnerable(int32_t relative_offset) {\n    if (g_data_stored_len == 0) {\n        return;\n    }\n\n    int32_t target_idx = (int32_t)g_data_stored_len - 1 + relative_offset;\n\n    g_data_buffer[target_idx] = 0xFF;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\nstatic uint16_t engine_params[5] = {1000, 85, 50, 1200, 0};\nstatic uint16_t chassis_params[10] = {300, 305, 302, 301, 100, 101, 102, 103, 0, 0};\nstatic uint16_t infotainment_params[3] = {1, 0, 15};\n\n#define MAX_RESPONSE_DATA_SIZE 64\n#define NUM_PARAM_GROUPS 3\n\ntypedef struct {\n    uint16_t* data_ptr;\n    uint16_t count;\n} ParameterGroup;\n\nstatic ParameterGroup g_paramGroups[NUM_PARAM_GROUPS];\n\nvoid initDiagnosticSystem() {\n    g_paramGroups[0].data_ptr = engine_params;\n    g_paramGroups[0].count = sizeof(engine_params) / sizeof(uint16_t);\n\n    g_paramGroups[1].data_ptr = chassis_params;\n    g_paramGroups[1].count = sizeof(chassis_params) / sizeof(uint16_t);\n\n    g_paramGroups[2].data_ptr = infotainment_params;\n    g_paramGroups[2].count = sizeof(infotainment_params) / sizeof(uint16_t);\n}\n\nint handleDiagnosticParamRequest(const uint8_t* request_packet, uint16_t packet_len, uint8_t* response_buffer, uint16_t response_buffer_size) {\n    if (request_packet == NULL || packet_len < 5 || response_buffer == NULL || response_buffer_size < 3) {\n        return -1;\n    }\n\n    uint8_t group_id = request_packet[0];\n    uint16_t start_index = (request_packet[1] << 8) | request_packet[2];\n    uint16_t count = (request_packet[3] << 8) | request_packet[4];\n\n    if (group_id >= NUM_PARAM_GROUPS) {\n        return -2;\n    }\n\n    ParameterGroup* target_group = &g_paramGroups[group_id];\n    \n    uint16_t required_response_payload_bytes = count * sizeof(uint16_t);\n    if (3 + required_response_payload_bytes > response_buffer_size) {\n        return -3;\n    }\n\n    response_buffer[0] = group_id;\n    response_buffer[1] = (uint8_t)(count >> 8);\n    response_buffer[2] = (uint8_t)(count & 0xFF);\n\n    uint16_t current_response_offset = 3;\n\n    for (uint16_t i = 0; i < count; ++i) {\n        uint16_t param_value = target_group->data_ptr[start_index + i]; \n        response_buffer[current_response_offset++] = (uint8_t)(param_value >> 8);\n        response_buffer[current_response_offset++] = (uint8_t)(param_value & 0xFF);\n    }\n\n    return current_response_offset;\n}\n\nvoid simulateDiagnosticQuery(const uint8_t* req_data, uint16_t req_len) {\n    uint8_t response_data[MAX_RESPONSE_DATA_SIZE + 3];\n    memset(response_data, 0, sizeof(response_data));\n    handleDiagnosticParamRequest(req_data, req_len, response_data, sizeof(response_data));\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_VEHICLE_EVENTS 100\n#define EVENT_NAME_MAX_LEN 16\n\ntypedef enum {\n    EVENT_TYPE_NONE = 0,\n    EVENT_TYPE_SENSOR_ERROR,\n    EVENT_TYPE_DIAGNOSTIC_REQUEST,\n    EVENT_TYPE_CRITICAL_ALERT,\n    EVENT_TYPE_PERFORMANCE_LOG\n} VehicleEventType;\n\ntypedef struct {\n    VehicleEventType type;\n    uint32_t timestamp;\n    char name[EVENT_NAME_MAX_LEN];\n    uint8_t severity;\n    bool active;\n} VehicleEvent;\n\nstatic VehicleEvent vehicle_event_log[MAX_VEHICLE_EVENTS];\nstatic int next_event_idx = 0;\n\nvoid initEventLog() {\n    for (int i = 0; i < MAX_VEHICLE_EVENTS; ++i) {\n        memset(&vehicle_event_log[i], 0, sizeof(VehicleEvent));\n        vehicle_event_log[i].type = EVENT_TYPE_NONE;\n        vehicle_event_log[i].active = false;\n    }\n    next_event_idx = 0;\n}\n\nvoid addVehicleEvent(VehicleEventType type, uint32_t timestamp, const char* name, uint8_t severity) {\n    if (next_event_idx < MAX_VEHICLE_EVENTS) {\n        vehicle_event_log[next_event_idx].type = type;\n        vehicle_event_log[next_event_idx].timestamp = timestamp;\n        strncpy(vehicle_event_log[next_event_idx].name, name, EVENT_NAME_MAX_LEN - 1);\n        vehicle_event_log[next_event_idx].name[EVENT_NAME_MAX_LEN - 1] = '\\0';\n        vehicle_event_log[next_event_idx].severity = severity;\n        vehicle_event_log[next_event_idx].active = true;\n        next_event_idx++;\n    }\n}\n\nvoid promoteVehicleEvent_Vulnerable(int current_event_index, int priority_offset) {\n    if (current_event_index < 0 || current_event_index >= next_event_idx || next_event_idx == 0) {\n        return;\n    }\n\n    int target_idx = current_event_index - priority_offset;\n\n    vehicle_event_log[target_idx] = vehicle_event_log[current_event_index];\n\n    vehicle_event_log[current_event_index].active = false;\n    vehicle_event_log[current_event_index].type = EVENT_TYPE_NONE;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define FIRMWARE_SCRATCHPAD_SIZE 1024\n\nstatic uint8_t g_firmware_scratchpad[FIRMWARE_SCRATCHPAD_SIZE];\nstatic size_t g_active_data_size = 0;\n\nvoid init_firmware_scratchpad() {\n    memset(g_firmware_scratchpad, 0xFF, FIRMWARE_SCRATCHPAD_SIZE);\n    g_active_data_size = 0;\n}\n\nbool write_firmware_block(const uint8_t* data, size_t len) {\n    if (g_active_data_size + len > FIRMWARE_SCRATCHPAD_SIZE) {\n        return false;\n    }\n    memcpy(g_firmware_scratchpad + g_active_data_size, data, len);\n    g_active_data_size += len;\n    return true;\n}\n\nvoid apply_firmware_patch_Vulnerable(const uint8_t* patch_data, size_t patch_len, int rewind_bytes) {\n    if (patch_data == NULL || patch_len == 0) {\n        return;\n    }\n\n    int target_start_offset = (int)g_active_data_size - rewind_bytes;\n\n    memcpy(g_firmware_scratchpad + target_start_offset, patch_data, patch_len);\n\n    if (target_start_offset + patch_len > g_active_data_size) {\n        g_active_data_size = target_start_offset + patch_len;\n    }\n    if (g_active_data_size > FIRMWARE_SCRATCHPAD_SIZE) {\n        g_active_data_size = FIRMWARE_SCRATCHPAD_SIZE;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_FAULT_ENTRIES 64\n#define DTC_CODE_LEN 6 \n\ntypedef enum {\n    FAULT_STATUS_ACTIVE,\n    FAULT_STATUS_CLEARED,\n    FAULT_STATUS_HISTORY\n} FaultStatus;\n\ntypedef struct {\n    char dtc_code[DTC_CODE_LEN + 1]; \n    uint32_t timestamp;\n    uint8_t severity;\n    FaultStatus status;\n} FaultEntry;\n\nstatic FaultEntry g_fault_log[MAX_FAULT_ENTRIES];\nstatic int g_fault_count = 0; \nstatic int g_write_ptr = 0; \n\nvoid init_fault_log() {\n    for (int i = 0; i < MAX_FAULT_ENTRIES; ++i) {\n        memset(&g_fault_log[i], 0, sizeof(FaultEntry));\n        g_fault_log[i].status = FAULT_STATUS_CLEARED;\n    }\n    g_fault_count = 0;\n    g_write_ptr = 0;\n}\n\nvoid log_dtc(const char* dtc, uint32_t timestamp, uint8_t severity) {\n    strncpy(g_fault_log[g_write_ptr].dtc_code, dtc, DTC_CODE_LEN);\n    g_fault_log[g_write_ptr].dtc_code[DTC_CODE_LEN] = '\\0';\n    g_fault_log[g_write_ptr].timestamp = timestamp;\n    g_fault_log[g_write_ptr].severity = severity;\n    g_fault_log[g_write_ptr].status = FAULT_STATUS_ACTIVE;\n\n    g_write_ptr = (g_write_ptr + 1) % MAX_FAULT_ENTRIES;\n    if (g_fault_count < MAX_FAULT_ENTRIES) {\n        g_fault_count++;\n    }\n}\n\nvoid revert_last_faults_vulnerable(int num_to_revert) {\n    if (num_to_revert <= 0) {\n        return;\n    }\n\n    if (g_fault_count == 0) {\n        return;\n    }\n\n    int current_tail_idx = (g_write_ptr - 1 + MAX_FAULT_ENTRIES) % MAX_FAULT_ENTRIES;\n\n    for (int i = 0; i < num_to_revert; ++i) {\n        \n        int target_idx_vulnerable = current_tail_idx - i;\n\n        g_fault_log[target_idx_vulnerable].status = FAULT_STATUS_CLEARED;\n        memset(g_fault_log[target_idx_vulnerable].dtc_code, 0, DTC_CODE_LEN + 1);\n        g_fault_log[target_idx_vulnerable].timestamp = 0;\n        g_fault_log[target_idx_vulnerable].severity = 0;\n\n        if (g_fault_count > 0) {\n            g_fault_count--;\n        } else {\n            g_fault_count = 0;\n        }\n    }\n\n    g_write_ptr = (g_write_ptr - num_to_revert + MAX_FAULT_ENTRIES) % MAX_FAULT_ENTRIES;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_DIAG_MESSAGE_TYPES 10\n#define DIAG_DATA_BUFFER_SIZE 32\n\ntypedef struct {\n    uint8_t messageType;\n    uint8_t payload[DIAG_DATA_BUFFER_SIZE];\n    uint8_t payload_len;\n} DiagnosticMessage;\n\nstatic uint32_t g_diagCounters_fixed[MAX_DIAG_MESSAGE_TYPES];\nstatic uint16_t g_diagData_fixed[MAX_DIAG_MESSAGE_TYPES][DIAG_DATA_BUFFER_SIZE];\n\nvoid logDiagnosticError_fixed(const char* msg) {\n}\n\nDiagnosticMessage receiveDiagnosticMessage_fixed() {\n    DiagnosticMessage msg;\n    msg.messageType = MAX_DIAG_MESSAGE_TYPES;\n    msg.payload_len = 4;\n    msg.payload[0] = 0xAA;\n    msg.payload[1] = 0xBB;\n    msg.payload[2] = 0xCC;\n    msg.payload[3] = 0xDD;\n    return msg;\n}\n\nvoid processDiagnosticMessage_fixed() {\n    DiagnosticMessage msg = receiveDiagnosticMessage_fixed();\n\n    if (msg.messageType < MAX_DIAG_MESSAGE_TYPES) {\n        g_diagCounters_fixed[msg.messageType]++;\n\n        for (uint8_t i = 0; i < msg.payload_len; ++i) {\n            if (i < DIAG_DATA_BUFFER_SIZE) {\n                g_diagData_fixed[msg.messageType][i] = msg.payload[i];\n            }\n        }\n    } else {\n        logDiagnosticError_fixed(\"Invalid diagnostic message type received. Ignoring message.\");\n    }\n}\n\nvoid initializeDiagnosticSystem_fixed() {\n    for (uint8_t i = 0; i < MAX_DIAG_MESSAGE_TYPES; ++i) {\n        g_diagCounters_fixed[i] = 0;\n        for (uint8_t j = 0; j < DIAG_DATA_BUFFER_SIZE; ++j) {\n            g_diagData_fixed[i][j] = 0;\n        }\n    }\n}\n\nvoid diagnosticSystem_fixed_main() {\n    initializeDiagnosticSystem_fixed();\n    processDiagnosticMessage_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_LOG_BUFFER_SIZE 1024\n#define MAX_LOG_ENTRIES 50\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t sensor_id;\n    uint16_t value;\n    uint8_t  crc;\n} SensorLogEntry;\n\nstatic uint8_t g_sensor_data_log[MAX_LOG_BUFFER_SIZE];\nstatic uint16_t g_log_entry_offsets[MAX_LOG_ENTRIES];\nstatic uint16_t g_num_log_entries = 0;\nstatic uint16_t g_current_data_ptr = 0;\n\nvoid init_sensor_logger_vulnerable() {\n    memset(g_sensor_data_log, 0, MAX_LOG_BUFFER_SIZE);\n    memset(g_log_entry_offsets, 0, sizeof(g_log_entry_offsets));\n    g_num_log_entries = 0;\n    g_current_data_ptr = 0;\n}\n\nbool add_sensor_log_entry_vulnerable(uint32_t timestamp, uint16_t sensor_id, uint16_t value, uint8_t crc) {\n    if (g_num_log_entries >= MAX_LOG_ENTRIES) {\n        return false;\n    }\n\n    if (g_current_data_ptr + sizeof(SensorLogEntry) > MAX_LOG_BUFFER_SIZE) {\n        return false;\n    }\n\n    g_log_entry_offsets[g_num_log_entries] = g_current_data_ptr;\n\n    SensorLogEntry new_entry = {timestamp, sensor_id, value, crc};\n    memcpy(&g_sensor_data_log[g_current_data_ptr], &new_entry, sizeof(SensorLogEntry));\n\n    g_current_data_ptr += sizeof(SensorLogEntry);\n    g_num_log_entries++;\n    return true;\n}\n\nvoid set_entry_status_vulnerable(uint16_t entry_index, uint8_t status_byte) {\n    if (entry_index >= g_num_log_entries) {\n        return;\n    }\n\n    uint16_t entry_start_offset = g_log_entry_offsets[entry_index];\n\n    g_sensor_data_log[entry_start_offset - 1] = status_byte;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define COMMAND_QUEUE_SIZE 10\n#define COMMAND_PAYLOAD_SIZE 16\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t payload[COMMAND_PAYLOAD_SIZE];\n} CommandPacket;\n\n#define META_BUFFER_SIZE 4\n#define CMD_QUEUE_START_OFFSET META_BUFFER_SIZE\n#define TOTAL_SYSTEM_MEMORY_SIZE (META_BUFFER_SIZE + sizeof(CommandPacket) * COMMAND_QUEUE_SIZE)\n\nstatic uint8_t g_system_memory[TOTAL_SYSTEM_MEMORY_SIZE];\nstatic uint16_t g_cmd_queue_head = 0;\nstatic uint16_t g_cmd_queue_count = 0;\n\nvoid init_command_system_vulnerable() {\n    memset(g_system_memory, 0, TOTAL_SYSTEM_MEMORY_SIZE);\n    g_cmd_queue_head = 0;\n    g_cmd_queue_count = 0;\n    g_system_memory[0] = 0xAA;\n    g_system_memory[1] = 0xBB;\n    g_system_memory[2] = 0xCC;\n    g_system_memory[3] = 0xDD;\n}\n\nbool enqueue_command_vulnerable(const CommandPacket* cmd) {\n    if (g_cmd_queue_count >= COMMAND_QUEUE_SIZE) {\n        return false;\n    }\n    uint16_t tail_idx = (g_cmd_queue_head + g_cmd_queue_count) % COMMAND_QUEUE_SIZE;\n    ((CommandPacket*)(g_system_memory + CMD_QUEUE_START_OFFSET))[tail_idx] = *cmd;\n    g_cmd_queue_count++;\n    return true;\n}\n\nvoid process_and_mark_command_vulnerable(uint8_t processed_status_val, int16_t status_offset_from_head) {\n    if (g_cmd_queue_count == 0) {\n        return;\n    }\n\n    uint16_t actual_cmd_idx = g_cmd_queue_head;\n\n    CommandPacket current_cmd = ((CommandPacket*)(g_system_memory + CMD_QUEUE_START_OFFSET))[actual_cmd_idx];\n    (void)current_cmd;\n\n    g_cmd_queue_head = (g_cmd_queue_head + 1) % COMMAND_QUEUE_SIZE;\n    g_cmd_queue_count--;\n\n    int32_t target_byte_offset_from_system_start = (int32_t)CMD_QUEUE_START_OFFSET + (int32_t)(actual_cmd_idx * sizeof(CommandPacket)) + status_offset_from_head;\n    \n    g_system_memory[target_byte_offset_from_system_start] = processed_status_val;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#define MAX_MODES 3\n#define MAX_NORMAL_PARAMS 5\n#define MAX_SPORT_PARAMS 7\n#define MAX_ECO_PARAMS 4\n\ntypedef union {\n    uint16_t u16_val;\n    int16_t  s16_val;\n    float    f_val;\n} ParameterValue_Fixed;\n\ntypedef struct {\n    uint8_t      param_type;\n    ParameterValue_Fixed value;\n    uint16_t     min_limit;\n    uint16_t     max_limit;\n} ModeParameter_Fixed;\n\nstatic ModeParameter_Fixed g_normalModeParams_fixed[MAX_NORMAL_PARAMS];\nstatic ModeParameter_Fixed g_sportModeParams_fixed[MAX_SPORT_PARAMS];\nstatic ModeParameter_Fixed g_ecoModeParams_fixed[MAX_ECO_PARAMS];\n\ntypedef struct {\n    ModeParameter_Fixed* params_ptr;\n    uint8_t        max_params_count;\n} ModeConfigTableEntry_Fixed;\n\nstatic ModeConfigTableEntry_Fixed g_modeConfigs_fixed[MAX_MODES];\n\nstatic uint8_t g_currentVehicleMode_fixed; \n\nvoid vehicleDebugLog_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t  mode_id;\n    uint8_t  parameter_idx;\n    uint16_t new_uint_value;\n} ParameterAdjustmentCommand_Fixed;\n\nParameterAdjustmentCommand_Fixed receiveAdjustmentCommand_fixed() {\n    ParameterAdjustmentCommand_Fixed cmd;\n    cmd.mode_id = 0;\n    cmd.parameter_idx = 5;\n    cmd.new_uint_value = 1234;\n    return cmd;\n}\n\nvoid initializeVehicleModes_fixed() {\n    g_modeConfigs_fixed[0] = (ModeConfigTableEntry_Fixed){g_normalModeParams_fixed, MAX_NORMAL_PARAMS};\n    g_modeConfigs_fixed[1] = (ModeConfigTableEntry_Fixed){g_sportModeParams_fixed, MAX_SPORT_PARAMS};\n    g_modeConfigs_fixed[2] = (ModeConfigTableEntry_Fixed){g_ecoModeParams_fixed, MAX_ECO_PARAMS};\n\n    for (uint8_t i = 0; i < MAX_NORMAL_PARAMS; ++i) g_normalModeParams_fixed[i].value.u16_val = 100 + i;\n    for (uint8_t i = 0; i < MAX_SPORT_PARAMS; ++i) g_sportModeParams_fixed[i].value.u16_val = 200 + i;\n    for (uint8_t i = 0; i < MAX_ECO_PARAMS; ++i) g_ecoModeParams_fixed[i].value.u16_val = 300 + i;\n\n    g_currentVehicleMode_fixed = 0;\n    vehicleDebugLog_fixed(\"Vehicle modes initialized.\");\n}\n\nvoid adjustVehicleParameter_fixed() {\n    ParameterAdjustmentCommand_Fixed cmd = receiveAdjustmentCommand_fixed();\n\n    if (g_currentVehicleMode_fixed < MAX_MODES) {\n        ModeConfigTableEntry_Fixed mode_entry = g_modeConfigs_fixed[g_currentVehicleMode_fixed];\n        \n        if (cmd.parameter_idx < mode_entry.max_params_count) {\n            ModeParameter_Fixed* active_params = mode_entry.params_ptr;\n            active_params[cmd.parameter_idx].value.u16_val = cmd.new_uint_value;\n            vehicleDebugLog_fixed(\"Vehicle parameter adjusted.\");\n        } else {\n            vehicleDebugLog_fixed(\"Parameter index out of bounds for current vehicle mode.\");\n        }\n    } else {\n        vehicleDebugLog_fixed(\"Invalid current vehicle mode for adjustment.\");\n    }\n}\n\nvoid vehicleControlMain_fixed() {\n    initializeVehicleModes_fixed();\n    adjustVehicleParameter_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_MODES 4\n\ntypedef enum {\n    MODE_ECO = 0,\n    MODE_SPORT,\n    MODE_COMFORT,\n    MODE_OFFROAD,\n    MODE_COUNT\n} VehicleOperatingMode;\n\ntypedef struct {\n    uint16_t engine_power_limit_kW;\n    uint16_t battery_discharge_rate_A;\n    uint8_t throttle_response_curve_idx;\n    bool enable_regenerative_braking;\n} PowerManagementProfile;\n\nstatic PowerManagementProfile g_powerProfiles_fixed[MAX_VEHICLE_MODES];\n\nvoid logSystemStatus_fixed(const char* message) {\n}\n\ntypedef struct {\n    uint8_t command_type;\n    uint8_t requested_mode_id;\n    uint8_t reserved[6];\n} VehicleModeCommand;\n\nVehicleModeCommand receiveVehicleModeCommand_fixed() {\n    VehicleModeCommand cmd;\n    cmd.command_type = 0x01;\n    cmd.requested_mode_id = 5;\n    return cmd;\n}\n\nvoid initializePowerProfiles_fixed() {\n    g_powerProfiles_fixed[MODE_ECO] = (PowerManagementProfile){80, 50, 1, true};\n    g_powerProfiles_fixed[MODE_SPORT] = (PowerManagementProfile){150, 100, 3, true};\n    g_powerProfiles_fixed[MODE_COMFORT] = (PowerManagementProfile){100, 70, 2, true};\n    g_powerProfiles_fixed[MODE_OFFROAD] = (PowerManagementProfile){120, 80, 2, false};\n    logSystemStatus_fixed(\"Power profiles initialized (fixed).\");\n}\n\nvoid activateVehicleMode_fixed() {\n    VehicleModeCommand cmd = receiveVehicleModeCommand_fixed();\n\n    if (cmd.command_type == 0x01) {\n        if (cmd.requested_mode_id < MAX_VEHICLE_MODES) {\n            PowerManagementProfile selectedProfile = g_powerProfiles_fixed[cmd.requested_mode_id];\n\n            logSystemStatus_fixed(\"Applying selected power profile (fixed).\");\n            if (selectedProfile.enable_regenerative_braking) {\n            } else {\n            }\n        } else {\n            logSystemStatus_fixed(\"Received requested mode ID out of bounds. Command ignored (fixed).\");\n        }\n    } else {\n        logSystemStatus_fixed(\"Invalid command type received (fixed).\");\n    }\n}\n\nvoid vehicleEMU_fixed_main() {\n    initializePowerProfiles_fixed();\n    activateVehicleMode_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_CONFIG_HISTORY 10\n\ntypedef struct {\n    uint32_t configId;\n    int32_t  paramA;\n    uint16_t paramB;\n} SensorConfiguration;\n\nstatic SensorConfiguration g_activeConfig;\nstatic SensorConfiguration g_configHistory[MAX_CONFIG_HISTORY];\nstatic int16_t g_latestConfigIdx = -1;\nstatic uint16_t g_numStoredConfigs = 0;\n\nvoid logSystemEvent(const char* msg) {\n    (void)msg;\n}\n\nvoid initializeConfigurationSystem() {\n    g_activeConfig = (SensorConfiguration){1001, 500, 100};\n    g_latestConfigIdx = 0;\n    g_configHistory[g_latestConfigIdx] = g_activeConfig;\n    g_numStoredConfigs = 1;\n    logSystemEvent(\"Configuration system initialized with default settings.\");\n}\n\nvoid applyAndStoreNewConfiguration(uint32_t newConfigId, int32_t newParamA, uint16_t newParamB) {\n    g_activeConfig = (SensorConfiguration){newConfigId, newParamA, newParamB};\n\n    g_latestConfigIdx = (g_latestConfigIdx + 1);\n    if (g_latestConfigIdx >= MAX_CONFIG_HISTORY) {\n        g_latestConfigIdx = 0;\n    }\n    g_configHistory[g_latestConfigIdx] = g_activeConfig;\n\n    if (g_numStoredConfigs < MAX_CONFIG_HISTORY) {\n        g_numStoredConfigs++;\n    }\n    logSystemEvent(\"New configuration applied and stored in history.\");\n}\n\nvoid revertConfigurationFromHistory_Fixed(int16_t steps_back) {\n    if (g_numStoredConfigs == 0) {\n        logSystemEvent(\"Cannot revert: Configuration history is empty.\");\n        return;\n    }\n\n    if (steps_back < 0 || steps_back >= g_numStoredConfigs) {\n        logSystemEvent(\"Revert failed: Invalid number of steps back requested.\");\n        return;\n    }\n\n    int16_t target_history_idx = (g_latestConfigIdx - steps_back + MAX_CONFIG_HISTORY) % MAX_CONFIG_HISTORY;\n    \n    g_activeConfig = g_configHistory[target_history_idx];\n    logSystemEvent(\"Configuration reverted from history.\");\n}\n\nvoid vehicleConfigManager_Fixed() {\n    initializeConfigurationSystem();\n\n    applyAndStoreNewConfiguration(1002, 600, 110);\n\n    revertConfigurationFromHistory_Fixed(2);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define REASSEMBLY_BUFFER_SIZE 256\n#define MAX_FRAGMENT_PAYLOAD_SIZE 64\n#define FRAGMENT_HEADER_SIZE 6\n\ntypedef struct {\n    uint16_t fragment_id;\n    uint16_t offset;\n    uint16_t length;\n} FragmentHeader;\n\nstatic uint8_t g_reassemblyBuffer[REASSEMBLY_BUFFER_SIZE];\nstatic uint16_t g_reassembledLength = 0;\n\nvoid initReassemblyBuffer() {\n    memset(g_reassemblyBuffer, 0, REASSEMBLY_BUFFER_SIZE);\n    g_reassembledLength = 0;\n}\n\nint processDataFragment(const uint8_t* raw_fragment_data, uint16_t raw_fragment_len) {\n    if (raw_fragment_data == NULL || raw_fragment_len < FRAGMENT_HEADER_SIZE) {\n        return -1;\n    }\n\n    FragmentHeader header;\n    header.fragment_id = (raw_fragment_data[0] << 8) | raw_fragment_data[1];\n    header.offset      = (raw_fragment_data[2] << 8) | raw_fragment_data[3];\n    header.length      = (raw_fragment_data[4] << 8) | raw_fragment_data[5];\n\n    if (FRAGMENT_HEADER_SIZE + header.length > raw_fragment_len) {\n        return -2;\n    }\n\n    if (header.length > MAX_FRAGMENT_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    for (uint16_t i = 0; i < header.length; ++i) {\n        g_reassemblyBuffer[header.offset + i] = raw_fragment_data[FRAGMENT_HEADER_SIZE + i];\n    }\n\n    if (header.offset + header.length > g_reassembledLength) {\n        g_reassembledLength = header.offset + header.length;\n    }\n\n    return 0;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\nuint32_t get_current_timestamp() {\n    return 0xDEADBEEF; \n}\n\n#define DIAG_DATA_POINTS_HISTORY_SIZE 20\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t engine_runtime_hrs;\n    uint16_t km_driven_hundreds;\n    uint8_t  error_code_count;\n    bool     valid_entry;\n} DiagnosticSnapshot;\n\nstatic DiagnosticSnapshot g_diag_history_buffer_fixed[DIAG_DATA_POINTS_HISTORY_SIZE];\nstatic uint16_t g_diag_write_head_idx_fixed = 0;\nstatic uint16_t g_num_active_snapshots_fixed = 0;\n\nvoid init_diagnostic_history_fixed() {\n    for (uint16_t i = 0; i < DIAG_DATA_POINTS_HISTORY_SIZE; ++i) {\n        g_diag_history_buffer_fixed[i].valid_entry = false;\n    }\n    g_diag_write_head_idx_fixed = 0;\n    g_num_active_snapshots_fixed = 0;\n}\n\nvoid add_diag_snapshot_fixed(uint16_t runtime, uint16_t km_driven, uint8_t error_count) {\n    g_diag_history_buffer_fixed[g_diag_write_head_idx_fixed].timestamp_ms = get_current_timestamp();\n    g_diag_history_buffer_fixed[g_diag_write_head_idx_fixed].engine_runtime_hrs = runtime;\n    g_diag_history_buffer_fixed[g_diag_write_head_idx_fixed].km_driven_hundreds = km_driven;\n    g_diag_history_buffer_fixed[g_diag_write_head_idx_fixed].error_code_count = error_count;\n    g_diag_history_buffer_fixed[g_diag_write_head_idx_fixed].valid_entry = true;\n\n    g_diag_write_head_idx_fixed = (g_diag_write_head_idx_fixed + 1) % DIAG_DATA_POINTS_HISTORY_SIZE;\n    if (g_num_active_snapshots_fixed < DIAG_DATA_POINTS_HISTORY_SIZE) {\n        g_num_active_snapshots_fixed++;\n    }\n}\n\nvoid invalidate_recent_diag_snapshots_fixed(uint16_t num_to_invalidate) {\n    if (g_num_active_snapshots_fixed == 0 || num_to_invalidate == 0) {\n        return;\n    }\n\n    uint16_t actual_invalidate_count = num_to_invalidate;\n    if (actual_invalidate_count > g_num_active_snapshots_fixed) {\n        actual_invalidate_count = g_num_active_snapshots_fixed;\n    }\n\n    uint16_t latest_snapshot_idx;\n    if (g_diag_write_head_idx_fixed == 0) {\n        latest_snapshot_idx = DIAG_DATA_POINTS_HISTORY_SIZE - 1;\n    } else {\n        latest_snapshot_idx = g_diag_write_head_idx_fixed - 1;\n    }\n\n    for (uint16_t i = 0; i < actual_invalidate_count; ++i) {\n        uint16_t target_phys_idx = (latest_snapshot_idx - i + DIAG_DATA_POINTS_HISTORY_SIZE) % DIAG_DATA_POINTS_HISTORY_SIZE;\n\n        g_diag_history_buffer_fixed[target_phys_idx].valid_entry = false;\n        g_diag_history_buffer_fixed[target_phys_idx].engine_runtime_hrs = 0;\n        g_diag_history_buffer_fixed[target_phys_idx].km_driven_hundreds = 0;\n        g_diag_history_buffer_fixed[target_phys_idx].error_code_count = 0;\n    }\n\n    g_num_active_snapshots_fixed -= actual_invalidate_count;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_VEHICLE_COMPONENTS 10\n#define BASE_INTERVAL_ARRAY_SIZE NUM_VEHICLE_COMPONENTS\n#define PROFILE_MODIFIER_ARRAY_SIZE (NUM_VEHICLE_COMPONENTS * 2) \n\nstatic uint16_t g_componentBaseIntervals[BASE_INTERVAL_ARRAY_SIZE];\nstatic int16_t g_componentProfileModifiers[PROFILE_MODIFIER_ARRAY_SIZE];\n\ntypedef struct {\n    uint8_t component_idx;\n    uint8_t profile_offset;\n    int8_t adjustment_value;\n} MaintenanceUpdateReq;\n\nvoid initMaintenanceSystem() {\n    memset(g_componentBaseIntervals, 0, sizeof(g_componentBaseIntervals));\n    memset(g_componentProfileModifiers, 0, sizeof(g_componentProfileModifiers));\n    for (uint8_t i = 0; i < NUM_VEHICLE_COMPONENTS; ++i) {\n        g_componentBaseIntervals[i] = 1000 + (i * 10);\n        g_componentProfileModifiers[i * 2] = 0;\n        g_componentProfileModifiers[i * 2 + 1] = -50;\n    }\n}\n\nint applyMaintenanceScheduleUpdate(const MaintenanceUpdateReq* req) {\n    if (req == NULL) {\n        return -1;\n    }\n\n    if (req->component_idx >= NUM_VEHICLE_COMPONENTS) {\n        return -2;\n    }\n\n    uint16_t effective_modifier_index = (uint16_t)(req->component_idx * 2) + req->profile_offset;\n\n    g_componentProfileModifiers[effective_modifier_index] += req->adjustment_value;\n\n    g_componentBaseIntervals[req->component_idx] += (req->adjustment_value / 2);\n\n    return 0;\n}\n\nvoid simulateMaintenanceRequest(uint8_t comp_id, uint8_t profile_off, int8_t adj_val) {\n    MaintenanceUpdateReq request = { .component_idx = comp_id, .profile_offset = profile_off, .adjustment_value = adj_val };\n    applyMaintenanceScheduleUpdate(&request);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_VEHICLE_COMPONENTS 10\n#define BASE_INTERVAL_ARRAY_SIZE NUM_VEHICLE_COMPONENTS\n#define PROFILE_MODIFIER_ARRAY_SIZE (NUM_VEHICLE_COMPONENTS * 2) \n\nstatic uint16_t g_componentBaseIntervals[BASE_INTERVAL_ARRAY_SIZE];\nstatic int16_t g_componentProfileModifiers[PROFILE_MODIFIER_ARRAY_SIZE];\n\ntypedef struct {\n    uint8_t component_idx;\n    uint8_t profile_offset;\n    int8_t adjustment_value;\n} MaintenanceUpdateReq;\n\nvoid initMaintenanceSystem() {\n    memset(g_componentBaseIntervals, 0, sizeof(g_componentBaseIntervals));\n    memset(g_componentProfileModifiers, 0, sizeof(g_componentProfileModifiers));\n    for (uint8_t i = 0; i < NUM_VEHICLE_COMPONENTS; ++i) {\n        g_componentBaseIntervals[i] = 1000 + (i * 10);\n        g_componentProfileModifiers[i * 2] = 0;\n        g_componentProfileModifiers[i * 2 + 1] = -50;\n    }\n}\n\nint applyMaintenanceScheduleUpdate(const MaintenanceUpdateReq* req) {\n    if (req == NULL) {\n        return -1;\n    }\n\n    if (req->component_idx >= NUM_VEHICLE_COMPONENTS) {\n        return -2;\n    }\n\n    uint16_t effective_modifier_index = (uint16_t)(req->component_idx * 2) + req->profile_offset;\n\n    if (effective_modifier_index >= PROFILE_MODIFIER_ARRAY_SIZE) {\n        return -3;\n    }\n\n    g_componentProfileModifiers[effective_modifier_index] += req->adjustment_value;\n\n    g_componentBaseIntervals[req->component_idx] += (req->adjustment_value / 2);\n\n    return 0;\n}\n\nvoid simulateMaintenanceRequest(uint8_t comp_id, uint8_t profile_off, int8_t adj_val) {\n    MaintenanceUpdateReq request = { .component_idx = comp_id, .profile_offset = profile_off, .adjustment_value = adj_val };\n    applyMaintenanceScheduleUpdate(&request);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\nstruct CalibrationPointWireFormatFixed {\n    uint16_t id;\n    uint32_t value;\n};\n#pragma pack(pop)\n\nstruct CalibrationPointStorageFixed {\n    uint16_t id;\n    uint32_t value;\n};\n\nclass CalibrationManagerFixed {\npublic:\n    CalibrationManagerFixed() : m_calibration_data(nullptr), m_num_stored_points(0) {}\n\n    ~CalibrationManagerFixed() {\n        if (m_calibration_data) {\n            free(m_calibration_data);\n            m_calibration_data = nullptr;\n        }\n    }\n\n    bool processCalibrationPacketFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(uint16_t)) {\n            return false;\n        }\n\n        uint16_t num_points = *reinterpret_cast<const uint16_t*>(raw_packet);\n        size_t expected_packet_payload_len = (size_t)num_points * sizeof(CalibrationPointWireFormatFixed);\n        size_t total_expected_packet_len = sizeof(uint16_t) + expected_packet_payload_len;\n\n        if (packet_len < total_expected_packet_len) {\n            return false;\n        }\n\n        if (m_calibration_data) {\n            free(m_calibration_data);\n            m_calibration_data = nullptr;\n        }\n\n        size_t allocation_size_bytes = (size_t)num_points * sizeof(CalibrationPointStorageFixed);\n        \n        m_calibration_data = (CalibrationPointStorageFixed*)malloc(allocation_size_bytes);\n        if (!m_calibration_data && allocation_size_bytes > 0) {\n            m_num_stored_points = 0;\n            return false;\n        }\n\n        const uint8_t* current_read_ptr = raw_packet + sizeof(uint16_t);\n        \n        for (uint16_t i = 0; i < num_points; ++i) {\n            CalibrationPointWireFormatFixed temp_wire_point;\n            memcpy(&temp_wire_point, current_read_ptr, sizeof(CalibrationPointWireFormatFixed));\n\n            m_calibration_data[i].id = temp_wire_point.id;\n            m_calibration_data[i].value = temp_wire_point.value;\n            \n            current_read_ptr += sizeof(CalibrationPointWireFormatFixed);\n        }\n\n        m_num_stored_points = num_points;\n        return true;\n    }\n\n    const CalibrationPointStorageFixed* getCalibrationData() const {\n        return m_calibration_data;\n    }\n\n    uint16_t getNumStoredPoints() const {\n        return m_num_stored_points;\n}\n\nprivate:\n    CalibrationPointStorageFixed* m_calibration_data;\n    uint16_t m_num_stored_points;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n\n#define MAX_CONFIG_PAYLOAD_SIZE 4096\n\ntypedef struct {\n    uint16_t total_payload_size;\n    uint16_t num_entries;\n} PacketHeaderFixed;\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t data_length;\n} ConfigEntryHeaderFixed;\n\nclass VehicleConfigProcessorFixed {\npublic:\n    VehicleConfigProcessorFixed() : processed_config_data(nullptr), current_data_offset(0), allocated_payload_size(0) {}\n\n    ~VehicleConfigProcessorFixed() {\n        if (processed_config_data) {\n            free(processed_config_data);\n            processed_config_data = nullptr;\n        }\n    }\n\n    bool processConfigPacketFixed(const uint8_t* raw_packet, size_t raw_len) {\n        if (processed_config_data) {\n            free(processed_config_data);\n            processed_config_data = nullptr;\n            allocated_payload_size = 0;\n        }\n\n        if (!raw_packet || raw_len < sizeof(PacketHeaderFixed)) {\n            return false;\n        }\n\n        const PacketHeaderFixed* pkt_header = reinterpret_cast<const PacketHeaderFixed*>(raw_packet);\n\n        if (pkt_header->total_payload_size > MAX_CONFIG_PAYLOAD_SIZE || pkt_header->total_payload_size == 0) {\n            return false;\n        }\n        \n        size_t expected_min_raw_len = sizeof(PacketHeaderFixed) + (size_t)pkt_header->num_entries * sizeof(ConfigEntryHeaderFixed);\n        if (raw_len < expected_min_raw_len) {\n            return false;\n        }\n\n        processed_config_data = (uint8_t*)malloc(pkt_header->total_payload_size);\n        if (!processed_config_data) {\n            allocated_payload_size = 0;\n            return false;\n        }\n        allocated_payload_size = pkt_header->total_payload_size;\n        current_data_offset = 0;\n\n        size_t current_parse_offset = sizeof(PacketHeaderFixed);\n\n        for (uint16_t i = 0; i < pkt_header->num_entries; ++i) {\n            if (current_parse_offset + sizeof(ConfigEntryHeaderFixed) > raw_len) {\n                free(processed_config_data); processed_config_data = nullptr; allocated_payload_size = 0;\n                return false;\n            }\n\n            const ConfigEntryHeaderFixed* entry_header = \n                reinterpret_cast<const ConfigEntryHeaderFixed*>(raw_packet + current_parse_offset);\n            \n            if (entry_header->data_length > allocated_payload_size - current_data_offset) {\n                free(processed_config_data); processed_config_data = nullptr; allocated_payload_size = 0;\n                return false;\n            }\n\n            if (current_parse_offset + sizeof(ConfigEntryHeaderFixed) + entry_header->data_length > raw_len) {\n                free(processed_config_data); processed_config_data = nullptr; allocated_payload_size = 0;\n                return false;\n            }\n            \n            for (uint16_t k = 0; k < entry_header->data_length; ++k) {\n                processed_config_data[current_data_offset + k] = \n                    raw_packet[current_parse_offset + sizeof(ConfigEntryHeaderFixed) + k];\n            }\n            current_data_offset += entry_header->data_length;\n            current_parse_offset += sizeof(ConfigEntryHeaderFixed) + entry_header->data_length;\n        }\n        \n        if (current_data_offset != pkt_header->total_payload_size) {\n            free(processed_config_data); processed_config_data = nullptr; allocated_payload_size = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedConfigData() const { return processed_config_data; }\n    size_t getProcessedDataLength() const { return current_data_offset; }\n\nprivate:\n    uint8_t* processed_config_data;\n    size_t current_data_offset;\n    size_t allocated_payload_size;\n};\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\n\nstruct DiagnosticReportPacketHeader {\n    uint16_t report_id;\n    uint16_t num_data_elements;\n    uint32_t total_payload_bytes;\n};\n\nstruct DiagnosticDataElement {\n    uint16_t element_tag;\n    uint16_t data_length;\n};\n\nstruct AggregatedDataEntry {\n    uint16_t element_tag;\n    uint16_t actual_data_length;\n};\n\n#pragma pack(pop)\n\nclass DiagnosticDataAggregatorFixed {\npublic:\n    DiagnosticDataAggregatorFixed() : m_aggregated_buffer(nullptr), m_buffer_capacity(0), m_current_write_offset(0) {}\n\n    ~DiagnosticDataAggregatorFixed() {\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n        }\n    }\n\n    bool processDiagnosticReportFixed(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(DiagnosticReportPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticReportPacketHeader* packet_header = reinterpret_cast<const DiagnosticReportPacketHeader*>(raw_packet);\n\n        static const uint16_t MAX_ALLOWED_DATA_ELEMENTS = 1000; \n        if (packet_header->num_data_elements > MAX_ALLOWED_DATA_ELEMENTS) {\n            return false;\n        }\n\n        size_t actual_parsed_payload_sum = 0;\n        size_t temp_read_offset = sizeof(DiagnosticReportPacketHeader);\n\n        for (uint16_t i = 0; i < packet_header->num_data_elements; ++i) {\n            if (temp_read_offset + sizeof(DiagnosticDataElement) > packet_length) {\n                return false;\n            }\n            const DiagnosticDataElement* temp_element_header = \n                reinterpret_cast<const DiagnosticDataElement*>(raw_packet + temp_read_offset);\n            \n            uint16_t element_data_len = temp_element_header->data_length;\n\n            if (temp_read_offset + sizeof(DiagnosticDataElement) + element_data_len > packet_length) {\n                return false;\n            }\n\n            if (element_data_len > (std::numeric_limits<size_t>::max() - actual_parsed_payload_sum)) {\n                 return false;\n            }\n            actual_parsed_payload_sum += element_data_len;\n            temp_read_offset += sizeof(DiagnosticDataElement) + element_data_len;\n        }\n\n        if (actual_parsed_payload_sum != packet_header->total_payload_bytes) {\n            return false;\n        }\n\n        size_t metadata_overhead_per_element = sizeof(AggregatedDataEntry);\n        \n        if (packet_header->num_data_elements > (std::numeric_limits<size_t>::max() / metadata_overhead_per_element)) {\n            return false;\n        }\n        size_t total_metadata_overhead = static_cast<size_t>(packet_header->num_data_elements) * metadata_overhead_per_element;\n\n        if (packet_header->total_payload_bytes > (std::numeric_limits<size_t>::max() - total_metadata_overhead)) {\n            return false;\n        }\n        size_t required_internal_buffer_size = packet_header->total_payload_bytes + total_metadata_overhead;\n\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n            m_current_write_offset = 0;\n            m_buffer_capacity = 0;\n        }\n\n        if (required_internal_buffer_size == 0) {\n            m_aggregated_buffer = nullptr;\n            m_buffer_capacity = 0;\n            return true;\n        }\n\n        m_aggregated_buffer = (uint8_t*)malloc(required_internal_buffer_size);\n        if (!m_aggregated_buffer) {\n            return false;\n        }\n        m_buffer_capacity = required_internal_buffer_size;\n        \n        size_t current_raw_read_offset = sizeof(DiagnosticReportPacketHeader);\n        m_current_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_header->num_data_elements; ++i) {\n            const DiagnosticDataElement* incoming_element_header = \n                reinterpret_cast<const DiagnosticDataElement*>(raw_packet + current_raw_read_offset);\n            uint16_t current_data_len = incoming_element_header->data_length;\n\n            size_t space_needed_for_this_entry = sizeof(AggregatedDataEntry) + current_data_len;\n            if (m_current_write_offset > m_buffer_capacity - space_needed_for_this_entry) {\n                return false; \n            }\n\n            uint16_t tag_to_copy = incoming_element_header->element_tag;\n            memcpy(m_aggregated_buffer + m_current_write_offset, &tag_to_copy, sizeof(tag_to_copy));\n            m_current_write_offset += sizeof(tag_to_copy);\n\n            uint16_t len_to_copy = incoming_element_header->data_length;\n            memcpy(m_aggregated_buffer + m_current_write_offset, &len_to_copy, sizeof(len_to_copy));\n            m_current_write_offset += sizeof(len_to_copy);\n\n            memcpy(m_aggregated_buffer + m_current_write_offset, \n                   raw_packet + current_raw_read_offset + sizeof(DiagnosticDataElement), \n                   current_data_len);\n            m_current_write_offset += current_data_len;\n\n            current_raw_read_offset += sizeof(DiagnosticDataElement) + current_data_len;\n        }\n\n        if (m_current_write_offset != m_buffer_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedBuffer() const { return m_aggregated_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n    size_t getCurrentWriteOffset() const { return m_current_write_offset; }\n\nprivate:\n    uint8_t* m_aggregated_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_write_offset;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_BUFFER_SIZE 256\n#define MAX_PAYLOAD_PER_EVENT 64 \n\nstatic uint8_t g_telemetryCircularBuffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_writeIndex = 0; \nstatic uint16_t g_dataLength = 0; \n\ntypedef struct {\n    uint16_t timestamp;   \n    uint8_t event_id;     \n    uint8_t payload_len;  \n} TelemetryEventHeader;\n\nvoid initTelemetryBuffer() {\n    memset(g_telemetryCircularBuffer, 0, TELEMETRY_BUFFER_SIZE);\n    g_writeIndex = 0;\n    g_dataLength = 0;\n}\n\nint addTelemetryEvent(const uint8_t* event_data, uint16_t data_len) {\n    if (event_data == NULL || data_len < sizeof(TelemetryEventHeader)) {\n        return -1; \n    }\n\n    uint16_t received_timestamp = (event_data[0] << 8) | event_data[1];\n    uint8_t received_event_id = event_data[2];\n    uint8_t received_payload_len = event_data[3];\n\n    uint16_t total_event_size = sizeof(TelemetryEventHeader) + received_payload_len;\n\n    if (received_payload_len > MAX_PAYLOAD_PER_EVENT) {\n        return -2; \n    }\n\n    if (total_event_size != data_len) {\n        return -3; \n    }\n\n    uint16_t space_to_end = TELEMETRY_BUFFER_SIZE - g_writeIndex;\n\n    if (total_event_size <= space_to_end) {\n        memcpy(&g_telemetryCircularBuffer[g_writeIndex], event_data, total_event_size);\n    } else {\n        memcpy(&g_telemetryCircularBuffer[g_writeIndex], event_data, space_to_end);\n        memcpy(&g_telemetryCircularBuffer[0], event_data + space_to_end, total_event_size - space_to_end);\n    }\n\n    g_writeIndex = (g_writeIndex + total_event_size) % TELEMETRY_BUFFER_SIZE;\n\n    if (g_dataLength < TELEMETRY_BUFFER_SIZE) {\n        g_dataLength += total_event_size;\n        if (g_dataLength > TELEMETRY_BUFFER_SIZE) {\n            g_dataLength = TELEMETRY_BUFFER_SIZE;\n        }\n    }\n\n    return 0; \n}\n\nvoid receiveTelemetryData(const uint8_t* data, uint16_t len) {\n    addTelemetryEvent(data, len);\n}\n\nuint8_t getTelemetryByte(uint16_t index) {\n    if (index < TELEMETRY_BUFFER_SIZE) {\n        return g_telemetryCircularBuffer[index];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stbool.h>\n#include <string.h>\n\n#define CONFIG_BUFFER_SIZE_FIXED 512\n#define MAX_BLOCK_PAYLOAD_SIZE_FIXED 128\n#define BLOCK_HEADER_SIZE_FIXED (sizeof(uint16_t) + sizeof(uint8_t))\n\nstatic uint8_t g_config_store_fixed[CONFIG_BUFFER_SIZE_FIXED];\nstatic uint32_t g_current_data_end_fixed = 0;\n\nvoid init_config_store_fixed() {\n    memset(g_config_store_fixed, 0, CONFIG_BUFFER_SIZE_FIXED);\n    g_current_data_end_fixed = 0;\n}\n\nbool add_config_block_fixed(uint16_t type, const uint8_t* payload, uint8_t payload_len) {\n    if (payload_len > MAX_BLOCK_PAYLOAD_SIZE_FIXED) {\n        return false;\n    }\n    uint32_t block_total_size = BLOCK_HEADER_SIZE_FIXED + payload_len;\n\n    if (g_current_data_end_fixed + block_total_size > CONFIG_BUFFER_SIZE_FIXED) {\n        return false;\n    }\n\n    uint8_t* dest_ptr = g_config_store_fixed + g_current_data_end_fixed;\n\n    *(uint16_t*)dest_ptr = type;\n    dest_ptr[2] = payload_len;\n    memcpy(dest_ptr + BLOCK_HEADER_SIZE_FIXED, payload, payload_len);\n\n    g_current_data_end_fixed += block_total_size;\n    return true;\n}\n\nvoid process_config_block_at_offset_fixed(uint32_t offset) {\n    if (offset >= g_current_data_end_fixed) return;\n    volatile uint16_t block_type_val = *(uint16_t*)(g_config_store_fixed + offset);\n    (void)block_type_val;\n}\n\nvoid rewind_config_buffer_fixed(uint8_t rewind_level) {\n    if (g_current_data_end_fixed == 0) {\n        return;\n    }\n\n    #define CONCEPTUAL_SEGMENT_SIZE_FIXED 32\n\n    uint32_t total_rewind_bytes = (uint32_t)rewind_level * CONCEPTUAL_SEGMENT_SIZE_FIXED;\n\n    uint32_t actual_start_clear_idx;\n    uint32_t bytes_to_clear_in_buffer;\n\n    if (total_rewind_bytes >= g_current_data_end_fixed) {\n        actual_start_clear_idx = 0;\n        bytes_to_clear_in_buffer = g_current_data_end_fixed;\n    } else {\n        actual_start_clear_idx = g_current_data_end_fixed - total_rewind_bytes;\n        bytes_to_clear_in_buffer = total_rewind_bytes;\n    }\n\n    for (uint32_t i = 0; i < bytes_to_clear_in_buffer; ++i) {\n        g_config_store_fixed[actual_start_clear_idx + i] = 0x00;\n    }\n\n    g_current_data_end_fixed = actual_start_clear_idx;\n\n    process_config_block_at_offset_fixed(g_current_data_end_fixed > 0 ? g_current_data_end_fixed - 1 : 0);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_FAULT_HISTORY_ENTRIES 32\n#define FAULT_DATA_SIZE 8\n\ntypedef struct {\n    uint32_t fault_code;\n    uint32_t timestamp;\n    uint8_t  data[FAULT_DATA_SIZE];\n    uint8_t  status_flags; \n} FaultHistoryEntry;\n\nstatic FaultHistoryEntry g_fault_history[MAX_FAULT_HISTORY_ENTRIES];\nstatic uint16_t g_current_history_idx = 0; \nstatic uint16_t g_num_active_faults = 0; \n\nvoid init_fault_history() {\n    memset(g_fault_history, 0, sizeof(g_fault_history));\n    g_current_history_idx = 0;\n    g_num_active_faults = 0;\n}\n\nvoid log_fault_event(uint32_t code, uint32_t timestamp, const uint8_t* data) {\n    if (g_num_active_faults < MAX_FAULT_HISTORY_ENTRIES) {\n        g_num_active_faults++;\n    }\n\n    FaultHistoryEntry* entry = &g_fault_history[g_current_history_idx];\n    entry->fault_code = code;\n    entry->timestamp = timestamp;\n    memcpy(entry->data, data, FAULT_DATA_SIZE);\n    entry->status_flags = 0x01; \n\n    g_current_history_idx = (g_current_history_idx + 1) % MAX_FAULT_HISTORY_ENTRIES;\n}\n\nvoid reactivate_cleared_faults_vulnerable(uint16_t num_to_reactivate) {\n    if (num_to_reactivate == 0 || g_num_active_faults == 0) {\n        return;\n    }\n\n    int16_t start_reactivate_idx = (g_current_history_idx == 0) ? \n                                   (MAX_FAULT_HISTORY_ENTRIES - 1) : \n                                   (g_current_history_idx - 1);\n\n    for (uint16_t i = 0; i < num_to_reactivate; ++i) {\n        uint16_t target_idx = (uint16_t)(start_reactivate_idx - i);\n        \n        g_fault_history[target_idx].status_flags = 0x01;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_SCRATCHPAD_BUFFER_SIZE 512\n\nstatic uint8_t g_diag_scratchpad_buffer[DIAG_SCRATCHPAD_BUFFER_SIZE];\nstatic int16_t g_current_diag_data_start_offset = 0;\nstatic uint16_t g_current_diag_data_size = 0;\n\nvoid init_diag_scratchpad() {\n    memset(g_diag_scratchpad_buffer, 0x00, DIAG_SCRATCHPAD_BUFFER_SIZE);\n    g_current_diag_data_start_offset = 0;\n    g_current_diag_data_size = 0;\n}\n\nbool append_diag_data(const uint8_t* data, uint16_t len) {\n    if (data == NULL || len == 0) {\n        return false;\n    }\n    if ((g_current_diag_data_start_offset + g_current_diag_data_size + len) > DIAG_SCRATCHPAD_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_diag_scratchpad_buffer + g_current_diag_data_start_offset + g_current_diag_data_size, data, len);\n    g_current_diag_data_size += len;\n    return true;\n}\n\nvoid trim_diag_data_start_fixed(uint16_t data_units_to_trim, uint16_t unit_nominal_size) {\n    if (data_units_to_trim == 0 || unit_nominal_size == 0) {\n        return;\n    }\n\n    uint32_t bytes_to_shift_calc = (uint32_t)data_units_to_trim * unit_nominal_size;\n\n    if (bytes_to_shift_calc > g_current_diag_data_size) {\n        bytes_to_shift_calc = g_current_diag_data_size;\n    }\n\n    int16_t actual_bytes_to_shift = (int16_t)bytes_to_shift_calc;\n\n    if ((int32_t)g_current_diag_data_start_offset + actual_bytes_to_shift < 0) {\n        g_current_diag_data_start_offset = 0;\n        g_current_diag_data_size = 0;\n        return;\n    }\n\n    g_current_diag_data_start_offset += actual_bytes_to_shift;\n    g_current_diag_data_size -= actual_bytes_to_shift;\n\n    if (g_current_diag_data_start_offset >= DIAG_SCRATCHPAD_BUFFER_SIZE) {\n        g_current_diag_data_start_offset = 0;\n        g_current_diag_data_size = 0;\n    }\n}\n\nvoid set_first_unit_status_fixed(uint8_t new_status) {\n    if (g_current_diag_data_size == 0) {\n        return;\n    }\n\n    if (g_current_diag_data_start_offset < 0 || g_current_diag_data_start_offset >= DIAG_SCRATCHPAD_BUFFER_SIZE) {\n        return;\n    }\n\n    g_diag_scratchpad_buffer[g_current_diag_data_start_offset] = new_status;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_CHASSIS_PROFILES 5\n\ntypedef struct {\n    float damping_ratio;\n    float steering_response;\n    uint16_t throttle_map_id;\n    bool traction_control_active;\n} ChassisProfile_fixed;\n\ntypedef struct {\n    uint8_t slipperiness_index;\n    uint8_t roughness_index;\n} SensorInput_fixed;\n\ntypedef struct {\n    int8_t profile_adjustment_offset;\n} DriverPreferenceInput_fixed;\n\nstatic ChassisProfile_fixed g_chassisProfiles_fixed[MAX_CHASSIS_PROFILES];\n\nvoid logChassisControlError_fixed(const char* msg) {\n}\n\nSensorInput_fixed getSimulatedSensorInput_fixed() {\n    SensorInput_fixed input;\n    input.slipperiness_index = 30;\n    input.roughness_index = 20;\n    return input;\n}\n\nDriverPreferenceInput_fixed getSimulatedDriverPreference_fixed() {\n    DriverPreferenceInput_fixed pref;\n    pref.profile_adjustment_offset = 5;\n    return pref;\n}\n\nvoid initializeChassisProfiles_fixed() {\n    for (int i = 0; i < MAX_CHASSIS_PROFILES; ++i) {\n        g_chassisProfiles_fixed[i].damping_ratio = 0.5f + (float)i * 0.1f;\n        g_chassisProfiles_fixed[i].steering_response = 0.3f + (float)i * 0.05f;\n        g_chassisProfiles_fixed[i].throttle_map_id = 100 + i;\n        g_chassisProfiles_fixed[i].traction_control_active = true;\n    }\n}\n\nvoid applyChassisSettings_fixed(const ChassisProfile_fixed* profile) {\n}\n\nvoid updateChassisControl_fixed() {\n    SensorInput_fixed sensor_data = getSimulatedSensorInput_fixed();\n    DriverPreferenceInput_fixed driver_data = getSimulatedDriverPreference_fixed();\n\n    int base_mode_index;\n    int averaged_sensor_value = (sensor_data.slipperiness_index + sensor_data.roughness_index) / 2;\n\n    if (averaged_sensor_value < 33) {\n        base_mode_index = 0;\n    } else if (averaged_sensor_value < 67) {\n        base_mode_index = 1;\n    } else {\n        base_mode_index = 2;\n    }\n\n    int final_profile_index = base_mode_index + driver_data.profile_adjustment_offset;\n\n    if (final_profile_index >= 0 && final_profile_index < MAX_CHASSIS_PROFILES) {\n        applyChassisSettings_fixed(&g_chassisProfiles_fixed[final_profile_index]);\n    } else {\n        logChassisControlError_fixed(\"Calculated profile index is out of bounds. Using default profile.\");\n        applyChassisSettings_fixed(&g_chassisProfiles_fixed[0]);\n    }\n}\n\nvoid chassisControlMain_fixed() {\n    initializeChassisProfiles_fixed();\n    updateChassisControl_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define GLOBAL_CONFIG_BUFFER_SIZE 512\n\nstatic uint8_t g_vehicleConfiguration[GLOBAL_CONFIG_BUFFER_SIZE];\n\ntypedef struct {\n    uint16_t param_did;\n    uint16_t offset_in_buffer;\n    uint16_t param_size;\n} ConfigurationParameterInfo;\n\nstatic const ConfigurationParameterInfo g_configParams[] = {\n    {0x1001, 0,    128},\n    {0x1002, 128,  64},\n    {0x1003, 192,  32},\n    {0x1004, 224,  256}\n};\n#define NUM_CONFIG_PARAMS (sizeof(g_configParams) / sizeof(g_configParams[0]))\n\nvoid initVehicleConfiguration() {\n    memset(g_vehicleConfiguration, 0, GLOBAL_CONFIG_BUFFER_SIZE);\n    for (uint16_t i = 0; i < GLOBAL_CONFIG_BUFFER_SIZE; ++i) {\n        g_vehicleConfiguration[i] = (uint8_t)(i % 256);\n    }\n}\n\nint updateConfigurationSegment(uint16_t did, uint16_t segment_offset, uint16_t segment_length, const uint8_t* data) {\n    if (data == NULL || segment_length == 0) {\n        return -1;\n    }\n\n    uint16_t param_idx = (uint16_t)-1;\n    for (uint16_t i = 0; i < NUM_CONFIG_PARAMS; ++i) {\n        if (g_configParams[i].param_did == did) {\n            param_idx = i;\n            break;\n        }\n    }\n\n    if (param_idx == (uint16_t)-1) {\n        return -2;\n    }\n\n    const ConfigurationParameterInfo* param_info = &g_configParams[param_idx];\n\n    if ((uint32_t)segment_offset + segment_length > param_info->param_size) {\n        return -3;\n    }\n\n    uint16_t dest_abs_offset = param_info->offset_in_buffer + segment_offset;\n\n    if ((uint32_t)dest_abs_offset + segment_length > GLOBAL_CONFIG_BUFFER_SIZE) {\n        return -4;\n    }\n\n    for (uint16_t i = 0; i < segment_length; ++i) {\n        g_vehicleConfiguration[dest_abs_offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid handleDiagnosticRequest(uint16_t did, uint16_t offset, uint16_16t len, const uint8_t* payload) {\n    updateConfigurationSegment(did, offset, len, payload);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_EVENT_BUFFER_SIZE 16\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t event_id;\n    uint8_t  severity;\n    uint8_t  status;\n    uint8_t  data[4];\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diag_event_history[DIAG_EVENT_BUFFER_SIZE];\nstatic uint16_t g_write_idx = 0;\nstatic uint16_t g_num_events = 0;\n\nvoid init_diag_history() {\n    memset(g_diag_event_history, 0, sizeof(g_diag_event_history));\n    g_write_idx = 0;\n    g_num_events = 0;\n}\n\nbool add_diag_event(uint32_t timestamp, uint16_t id, uint8_t severity, uint8_t status, const uint8_t* data) {\n    if (data == NULL) {\n        return false;\n    }\n\n    g_diag_event_history[g_write_idx].timestamp_ms = timestamp;\n    g_diag_event_history[g_write_idx].event_id = id;\n    g_diag_event_history[g_write_idx].severity = severity;\n    g_diag_event_history[g_write_idx].status = status;\n    memcpy(g_diag_event_history[g_write_idx].data, data, sizeof(g_diag_event_history[g_write_idx].data));\n\n    g_write_idx = (g_write_idx + 1) % DIAG_EVENT_BUFFER_SIZE;\n    if (g_num_events < DIAG_EVENT_BUFFER_SIZE) {\n        g_num_events++;\n    }\n    return true;\n}\n\nvoid update_event_status_by_relative_offset_vulnerable(uint16_t offset_from_latest, uint8_t new_status) {\n    if (g_num_events == 0) {\n        return;\n    }\n\n    uint16_t latest_event_idx = (g_write_idx == 0) ? (DIAG_EVENT_BUFFER_SIZE - 1) : (g_write_idx - 1);\n\n    int16_t target_idx = latest_event_idx - offset_from_latest;\n\n    g_diag_event_history[target_idx].status = new_status;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_PAYLOAD_SIZE 256\n#define MAX_VEHICLE_FEATURES 32\n\ntypedef struct {\n    uint8_t feature_index; \n    uint8_t new_state;     \n} FeatureUpdateRequest;\n\nstatic uint8_t g_vehicleFeatureStates[MAX_VEHICLE_FEATURES]; \n\nvoid initVehicleFeatures() {\n    memset(g_vehicleFeatureStates, 0, sizeof(g_vehicleFeatureStates));\n}\n\nint processFeatureUpdateCommand(const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len < 1) {\n        return -1; \n    }\n\n    uint8_t num_updates = payload[0];\n    uint16_t expected_len = 1 + (num_updates * sizeof(FeatureUpdateRequest));\n\n    if (expected_len > payload_len) {\n        return -1; \n    }\n\n    for (uint8_t i = 0; i < num_updates; ++i) {\n        uint16_t current_offset = 1 + (i * sizeof(FeatureUpdateRequest));\n        \n        if (current_offset + sizeof(FeatureUpdateRequest) > payload_len) {\n            return -1; \n        }\n\n        FeatureUpdateRequest current_request;\n        current_request.feature_index = payload[current_offset];\n        current_request.new_state = payload[current_offset + 1];\n\n        g_vehicleFeatureStates[current_request.feature_index] = current_request.new_state;\n    }\n\n    return 0; \n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMAND_LOG_ENTRIES 64\n#define LOG_ENTRY_WORD_SIZE 2\n\nstatic uint16_t g_command_log_buffer[MAX_COMMAND_LOG_ENTRIES * LOG_ENTRY_WORD_SIZE];\nstatic uint32_t g_log_current_idx = 0;\n\nvoid init_command_logger_fixed() {\n    memset(g_command_log_buffer, 0, sizeof(g_command_log_buffer));\n    g_log_current_idx = 0;\n}\n\nbool log_command_execution_fixed(uint16_t command_id, uint16_t timestamp_ms) {\n    if (g_log_current_idx + LOG_ENTRY_WORD_SIZE > MAX_COMMAND_LOG_ENTRIES * LOG_ENTRY_WORD_SIZE) {\n        return false;\n    }\n    g_command_log_buffer[g_log_current_idx] = command_id;\n    g_command_log_buffer[g_log_current_idx + 1] = timestamp_ms;\n    g_log_current_idx += LOG_ENTRY_WORD_SIZE;\n    return true;\n}\n\nvoid process_log_entry_conceptually_fixed(uint16_t cmd_id, uint16_t ts) {\n    volatile uint16_t dummy_cmd = cmd_id;\n    volatile uint16_t dummy_ts = ts;\n    (void)dummy_cmd;\n    (void)dummy_ts;\n}\n\nvoid clear_log_segment_and_mark_boundary_fixed(int32_t offset_from_end_words, uint32_t words_to_clear) {\n    if (g_log_current_idx == 0 || words_to_clear == 0) {\n        return;\n    }\n\n    int32_t segment_start_idx = (int32_t)g_log_current_idx - offset_from_end_words;\n\n    uint32_t actual_words_to_clear = words_to_clear;\n    if (segment_start_idx < 0) {\n        if (segment_start_idx + (int32_t)words_to_clear < 0) {\n            actual_words_to_clear = 0;\n        } else {\n            actual_words_to_clear = words_to_clear + segment_start_idx;\n            if (actual_words_to_clear < 0) actual_words_to_clear = 0;\n            segment_start_idx = 0;\n        }\n    }\n    \n    for (uint32_t i = 0; i < actual_words_to_clear; ++i) {\n        if (segment_start_idx + i < (int32_t)(MAX_COMMAND_LOG_ENTRIES * LOG_ENTRY_WORD_SIZE)) {\n            g_command_log_buffer[segment_start_idx + i] = 0x0000;\n        }\n    }\n\n    if (segment_start_idx - 1 >= 0 && (uint32_t)(segment_start_idx - 1) < (MAX_COMMAND_LOG_ENTRIES * LOG_ENTRY_WORD_SIZE)) {\n        g_command_log_buffer[segment_start_idx - 1] = 0xC0DE;\n    }\n\n    g_log_current_idx = (uint32_t)segment_start_idx;\n    if (g_log_current_idx + 1 < MAX_COMMAND_LOG_ENTRIES * LOG_ENTRY_WORD_SIZE) {\n        process_log_entry_conceptually_fixed(g_command_log_buffer[g_log_current_idx], g_command_log_buffer[g_log_current_idx + 1]);\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VCU_PARAM_STAGE_BUFFER_SIZE 256\nstatic uint8_t g_vcuParamStageBuffer[VCU_PARAM_STAGE_BUFFER_SIZE];\nstatic uint16_t g_currentStagedParamOffset = 0;\n\ntypedef struct {\n    uint8_t paramId;\n    uint16_t valueOffset;\n    uint8_t valueLength;\n} VcuParameterEntry;\n\n#define MAX_VCU_PARAM_ENTRIES 10\nstatic VcuParameterEntry g_vcuParamTable[MAX_VCU_PARAM_ENTRIES];\nstatic uint8_t g_numVcuParamEntries = 0;\n\nvoid initVcuParamStaging() {\n    memset(g_vcuParamStageBuffer, 0, VCU_PARAM_STAGE_BUFFER_SIZE);\n    g_currentStagedParamOffset = 0;\n    g_numVcuParamEntries = 0;\n}\n\nint processVcuParameterUpdateStream(const uint8_t* update_stream, uint16_t stream_len) {\n    if (update_stream == NULL || stream_len < 2) {\n        return -1;\n    }\n\n    uint16_t current_stream_pos = 0;\n    g_currentStagedParamOffset = 0;\n\n    while (current_stream_pos < stream_len) {\n        if (current_stream_pos + 2 > stream_len) {\n            return -2;\n        }\n\n        uint8_t param_id = update_stream[current_stream_pos++];\n        uint8_t value_len = update_stream[current_stream_pos++];\n\n        if (current_stream_pos + value_len > stream_len) {\n            return -3;\n        }\n\n        if (g_numVcuParamEntries >= MAX_VCU_PARAM_ENTRIES) {\n            return -4;\n        }\n\n        g_vcuParamTable[g_numVcuParamEntries].paramId = param_id;\n        g_vcuParamTable[g_numVcuParamEntries].valueOffset = g_currentStagedParamOffset;\n        g_vcuParamTable[g_numVcuParamEntries].valueLength = value_len;\n\n        for (uint8_t i = 0; i < value_len; ++i) {\n            g_vcuParamStageBuffer[g_currentStagedParamOffset + i] = update_stream[current_stream_pos + i];\n        }\n\n        g_currentStagedParamOffset += value_len;\n        current_stream_pos += value_len;\n        g_numVcuParamEntries++;\n    }\n\n    return 0;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_SENSOR_DATA_ENTRIES 20\n#define MAX_CALIBRATION_CURVE_POINTS 15\n#define MAX_EVENT_LOG_ENTRIES 10\n\ntypedef struct {\n    uint16_t value_raw;\n    int16_t  value_processed;\n    uint8_t  sensor_status;\n} SensorDataType;\n\ntypedef struct {\n    float    coeff_a;\n    float    coeff_b;\n    uint32_t revision_id;\n} CalibrationCurvePointType;\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp;\n    uint8_t  severity_level;\n} EventLogEntryType;\n\nstatic SensorDataType g_sensorDataTable_fixed[MAX_SENSOR_DATA_ENTRIES];\nstatic CalibrationCurvePointType g_calibrationCurveTable_fixed[MAX_CALIBRATION_CURVE_POINTS];\nstatic EventLogEntryType g_eventLogTable_fixed[MAX_EVENT_LOG_ENTRIES];\n\ntypedef enum {\n    DATA_TYPE_SENSOR = 0,\n    DATA_TYPE_CALIBRATION,\n    DATA_TYPE_EVENT_LOG,\n    DATA_TYPE_COUNT\n} DataTypeId;\n\ntypedef struct {\n    DataTypeId data_type_id;\n    uint8_t    index;\n    uint32_t   update_value;\n} DataUpdateCommand;\n\nvoid automotiveSystemLog_fixed(const char* message) {\n}\n\nDataUpdateCommand receiveDataUpdateCommand_fixed() {\n    DataUpdateCommand cmd;\n    cmd.data_type_id = DATA_TYPE_CALIBRATION;\n    cmd.index = MAX_CALIBRATION_CURVE_POINTS; \n    cmd.update_value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeDataTables_fixed() {\n    for (int i = 0; i < MAX_SENSOR_DATA_ENTRIES; ++i) {\n        g_sensorDataTable_fixed[i] = (SensorDataType){0, 0, 0};\n    }\n    for (int i = 0; i < MAX_CALIBRATION_CURVE_POINTS; ++i) {\n        g_calibrationCurveTable_fixed[i] = (CalibrationCurvePointType){0.0f, 0.0f, 0};\n    }\n    for (int i = 0; i < MAX_EVENT_LOG_ENTRIES; ++i) {\n        g_eventLogTable_fixed[i] = (EventLogEntryType){0, 0, 0};\n    }\n}\n\nvoid processDataUpdateCommand_fixed() {\n    DataUpdateCommand cmd = receiveDataUpdateCommand_fixed();\n\n    if (cmd.data_type_id < DATA_TYPE_COUNT) {\n        switch (cmd.data_type_id) {\n            case DATA_TYPE_SENSOR:\n                if (cmd.index < MAX_SENSOR_DATA_ENTRIES) {\n                    g_sensorDataTable_fixed[cmd.index].sensor_status = (uint8_t)cmd.update_value;\n                    automotiveSystemLog_fixed(\"Sensor data updated successfully.\");\n                } else {\n                    automotiveSystemLog_fixed(\"Out-of-bounds index for sensor data. Command ignored.\");\n                }\n                break;\n            case DATA_TYPE_CALIBRATION:\n                if (cmd.index < MAX_CALIBRATION_CURVE_POINTS) {\n                    g_calibrationCurveTable_fixed[cmd.index].coeff_a = *(float*)&cmd.update_value;\n                    automotiveSystemLog_fixed(\"Calibration curve point updated successfully.\");\n                } else {\n                    automotiveSystemLog_fixed(\"Out-of-bounds index for calibration data. Command ignored.\");\n                }\n                break;\n            case DATA_TYPE_EVENT_LOG:\n                if (cmd.index < MAX_EVENT_LOG_ENTRIES) {\n                    g_eventLogTable_fixed[cmd.index].event_id = (uint16_t)cmd.update_value;\n                    automotiveSystemLog_fixed(\"Event log entry updated successfully.\");\n                } else {\n                    automotiveSystemLog_fixed(\"Out-of-bounds index for event log. Command ignored.\");\n                }\n                break;\n            default:\n                automotiveSystemLog_fixed(\"Internal error: Unhandled data type ID in switch.\");\n                break;\n        }\n    } else {\n        automotiveSystemLog_fixed(\"Received command with invalid data type ID.\");\n    }\n}\n\nvoid vehicleControlUnitMain_fixed() {\n    initializeDataTables_fixed();\n    processDataUpdateCommand_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct DiagnosticChunkHeaderFixed {\n    uint16_t chunk_id;\n    uint16_t chunk_data_length;\n};\n\nstruct DiagnosticPacketHeaderFixed {\n    uint32_t packet_sequence_num;\n    uint16_t num_chunks;\n    uint32_t total_expected_chunk_data_bytes;\n};\n#pragma pack(pop)\n\nclass DiagnosticAggregatorFixed {\npublic:\n    DiagnosticAggregatorFixed() : m_aggregated_data(nullptr), m_allocated_size(0), m_current_write_offset(0) {}\n\n    ~DiagnosticAggregatorFixed() {\n        if (m_aggregated_data) {\n            free(m_aggregated_data);\n            m_aggregated_data = nullptr;\n        }\n    }\n\n    bool processDiagnosticPacketFixed(const uint8_t* raw_packet_data, size_t packet_len) {\n        if (!raw_packet_data || packet_len < sizeof(DiagnosticPacketHeaderFixed)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeaderFixed* packet_header = reinterpret_cast<const DiagnosticPacketHeaderFixed*>(raw_packet_data);\n\n        size_t total_required_aggregated_size = 0;\n        static const uint32_t MAX_AGGREGATED_DATA_SIZE = 128 * 1024;\n\n        if (packet_header->num_chunks > (std::numeric_limits<size_t>::max() / sizeof(DiagnosticChunkHeaderFixed))) {\n            return false;\n        }\n        total_required_aggregated_size = (size_t)packet_header->num_chunks * sizeof(DiagnosticChunkHeaderFixed);\n\n        if (packet_header->total_expected_chunk_data_bytes > (std::numeric_limits<size_t>::max() - total_required_aggregated_size)) {\n            return false;\n        }\n        total_required_aggregated_size += packet_header->total_expected_chunk_data_bytes;\n\n        if (total_required_aggregated_size > MAX_AGGREGATED_DATA_SIZE) {\n            return false;\n        }\n\n        size_t expected_packet_payload_size = 0;\n        if (packet_header->num_chunks > (std::numeric_limits<size_t>::max() / sizeof(DiagnosticChunkHeaderFixed))) {\n            return false;\n        }\n        expected_packet_payload_size = (size_t)packet_header->num_chunks * sizeof(DiagnosticChunkHeaderFixed);\n        if (packet_header->total_expected_chunk_data_bytes > (std::numeric_limits<size_t>::max() - expected_packet_payload_size)) {\n            return false;\n        }\n        expected_packet_payload_size += packet_header->total_expected_chunk_data_bytes;\n\n        if (packet_len < (sizeof(DiagnosticPacketHeaderFixed) + expected_packet_payload_size)) {\n             return false;\n        }\n\n        if (m_aggregated_data) {\n            free(m_aggregated_data);\n            m_aggregated_data = nullptr;\n        }\n        m_allocated_size = 0;\n        m_current_write_offset = 0;\n        \n        m_aggregated_data = (uint8_t*)malloc(total_required_aggregated_size);\n        if (!m_aggregated_data && total_required_aggregated_size > 0) {\n            return false;\n        }\n        m_allocated_size = total_required_aggregated_size;\n\n        const uint8_t* current_read_ptr = raw_packet_data + sizeof(DiagnosticPacketHeaderFixed);\n        size_t remaining_packet_bytes = packet_len - sizeof(DiagnosticPacketHeaderFixed);\n\n        for (uint16_t i = 0; i < packet_header->num_chunks; ++i) {\n            if (remaining_packet_bytes < sizeof(DiagnosticChunkHeaderFixed)) {\n                if (m_aggregated_data) { free(m_aggregated_data); m_aggregated_data = nullptr; }\n                m_allocated_size = 0;\n                return false;\n            }\n\n            const DiagnosticChunkHeaderFixed* chunk_header = reinterpret_cast<const DiagnosticChunkHeaderFixed*>(current_read_ptr);\n            uint16_t current_chunk_data_len = chunk_header->chunk_data_length;\n\n            size_t total_chunk_len_in_packet = sizeof(DiagnosticChunkHeaderFixed) + current_chunk_data_len;\n\n            if (remaining_packet_bytes < total_chunk_len_in_packet) {\n                if (m_aggregated_data) { free(m_aggregated_data); m_aggregated_data = nullptr; }\n                m_allocated_size = 0;\n                return false;\n            }\n\n            if (m_current_write_offset > (std::numeric_limits<size_t>::max() - total_chunk_len_in_packet) ||\n                m_current_write_offset + total_chunk_len_in_packet > m_allocated_size) {\n                if (m_aggregated_data) { free(m_aggregated_data); m_aggregated_data = nullptr; }\n                m_allocated_size = 0;\n                return false;\n            }\n            \n            for (size_t j = 0; j < total_chunk_len_in_packet; ++j) {\n                m_aggregated_data[m_current_write_offset + j] = current_read_ptr[j];\n            }\n            m_current_write_offset += total_chunk_len_in_packet;\n\n            current_read_ptr += total_chunk_len_in_packet;\n            remaining_packet_bytes -= total_chunk_len_in_packet;\n        }\n        \n        if (m_current_write_offset != m_allocated_size && total_required_aggregated_size > 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedData() const {\n        return m_aggregated_data;\n    }\n\n    size_t getAllocatedSize() const {\n        return m_allocated_size;\n    }\n\n    size_t getCurrentWriteOffset() const {\n        return m_current_write_offset;\n    }\n\nprivate:\n    uint8_t* m_aggregated_data;\n    size_t m_allocated_size;\n    size_t m_current_write_offset;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define EVENT_LOG_BUFFER_SIZE 256\n#define MAX_EVENT_CODE 0xFFF\n\ntypedef struct {\n    uint16_t eventCode;\n    uint32_t timestamp;\n    uint8_t  severity;\n    uint8_t  data[4];\n} VehicleEventEntry_Vulnerable;\n\nstatic VehicleEventEntry_Vulnerable g_eventLogBuffer_vulnerable[EVENT_LOG_BUFFER_SIZE];\nstatic uint16_t g_eventLogWriteIndex_vulnerable = 0;\nstatic bool g_eventLogWrapped_vulnerable = false;\n\nvoid logRecorderError_vulnerable(const char* msg) {\n}\n\nVehicleEventEntry_Vulnerable receiveVehicleEvent_vulnerable() {\n    VehicleEventEntry_Vulnerable event;\n    event.eventCode = 0x100;\n    event.timestamp = 0xDEADBEEF;\n    event.severity = 5;\n    event.data[0] = 0xAA; event.data[1] = 0xBB; event.data[2] = 0xCC; event.data[3] = 0xDD;\n    return event;\n}\n\nvoid initializeEventLog_vulnerable() {\n    for (uint16_t i = 0; i < EVENT_LOG_BUFFER_SIZE; ++i) {\n        g_eventLogBuffer_vulnerable[i] = (VehicleEventEntry_Vulnerable){0, 0, 0, {0,0,0,0}};\n    }\n    g_eventLogWriteIndex_vulnerable = EVENT_LOG_BUFFER_SIZE - 1;\n    g_eventLogWrapped_vulnerable = false;\n    logRecorderError_vulnerable(\"Vehicle event log initialized.\");\n}\n\nvoid recordVehicleEvent_vulnerable(VehicleEventEntry_Vulnerable event) {\n    g_eventLogBuffer_vulnerable[g_eventLogWriteIndex_vulnerable] = event;\n\n    g_eventLogWriteIndex_vulnerable++;\n\n    if (g_eventLogWriteIndex_vulnerable >= EVENT_LOG_BUFFER_SIZE) {\n        g_eventLogWriteIndex_vulnerable = EVENT_LOG_BUFFER_SIZE;\n        g_eventLogWrapped_vulnerable = true;\n    }\n    logRecorderError_vulnerable(\"Vehicle event recorded.\");\n}\n\nvoid vehicleEventRecorderMain_vulnerable() {\n    initializeEventLog_vulnerable();\n\n    VehicleEventEntry_Vulnerable receivedEvent = receiveVehicleEvent_vulnerable();\n    recordVehicleEvent_vulnerable(receivedEvent);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\nstatic uint16_t engine_params[5] = {1000, 85, 50, 1200, 0};\nstatic uint16_t chassis_params[10] = {300, 305, 302, 301, 100, 101, 102, 103, 0, 0};\nstatic uint16_t infotainment_params[3] = {1, 0, 15};\n\n#define MAX_RESPONSE_DATA_SIZE 64\n#define NUM_PARAM_GROUPS 3\n\ntypedef struct {\n    uint16_t* data_ptr;\n    uint16_t count;\n} ParameterGroup;\n\nstatic ParameterGroup g_paramGroups[NUM_PARAM_GROUPS];\n\nvoid initDiagnosticSystem() {\n    g_paramGroups[0].data_ptr = engine_params;\n    g_paramGroups[0].count = sizeof(engine_params) / sizeof(uint16_t);\n\n    g_paramGroups[1].data_ptr = chassis_params;\n    g_paramGroups[1].count = sizeof(chassis_params) / sizeof(uint16_t);\n\n    g_paramGroups[2].data_ptr = infotainment_params;\n    g_paramGroups[2].count = sizeof(infotainment_params) / sizeof(uint16_t);\n}\n\nint handleDiagnosticParamRequest(const uint8_t* request_packet, uint16_t packet_len, uint8_t* response_buffer, uint16_t response_buffer_size) {\n    if (request_packet == NULL || packet_len < 5 || response_buffer == NULL || response_buffer_size < 3) {\n        return -1;\n    }\n\n    uint8_t group_id = request_packet[0];\n    uint16_t start_index = (request_packet[1] << 8) | request_packet[2];\n    uint16_t count = (request_packet[3] << 8) | request_packet[4];\n\n    if (group_id >= NUM_PARAM_GROUPS) {\n        return -2;\n    }\n\n    ParameterGroup* target_group = &g_paramGroups[group_id];\n    \n    if (start_index >= target_group->count) {\n        return -4;\n    }\n    \n    uint16_t actual_count_to_retrieve = count;\n    if (start_index + actual_count_to_retrieve > target_group->count) {\n        actual_count_to_retrieve = target_group->count - start_index;\n    }\n    \n    uint16_t required_response_payload_bytes = actual_count_to_retrieve * sizeof(uint16_t);\n    if (3 + required_response_payload_bytes > response_buffer_size) {\n        return -3;\n    }\n\n    response_buffer[0] = group_id;\n    response_buffer[1] = (uint8_t)(actual_count_to_retrieve >> 8);\n    response_buffer[2] = (uint8_t)(actual_count_to_retrieve & 0xFF);\n\n    uint16_t current_response_offset = 3;\n\n    for (uint16_t i = 0; i < actual_count_to_retrieve; ++i) {\n        uint16_t param_value = target_group->data_ptr[start_index + i]; \n        response_buffer[current_response_offset++] = (uint8_t)(param_value >> 8);\n        response_buffer[current_response_offset++] = (uint8_t)(param_value & 0xFF);\n    }\n\n    return current_response_offset;\n}\n\nvoid simulateDiagnosticQuery(const uint8_t* req_data, uint16_t req_len) {\n    uint8_t response_data[MAX_RESPONSE_DATA_SIZE + 3];\n    memset(response_data, 0, sizeof(response_data));\n    handleDiagnosticParamRequest(req_data, req_len, response_data, sizeof(response_data));\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#define MAX_DRIVER_PROFILES 3\n\ntypedef struct {\n    uint16_t throttle_response_map_id;\n    uint8_t  regen_braking_level;\n} PowertrainSettings;\n\ntypedef struct {\n    uint16_t damping_force_preset_id;\n    uint16_t ride_height_offset_mm;\n} SuspensionSettings;\n\ntypedef struct {\n    uint8_t  steering_assist_level;\n    bool     lane_keeping_active;\n} SteeringSettings;\n\ntypedef struct {\n    PowertrainSettings* powertrain_config;\n    SuspensionSettings* suspension_config;\n    SteeringSettings*   steering_config;\n} DriverProfileConfig;\n\nstatic PowertrainSettings g_powertrainProfiles_vulnerable[MAX_DRIVER_PROFILES];\nstatic SuspensionSettings g_suspensionProfiles_vulnerable[MAX_DRIVER_PROFILES];\nstatic SteeringSettings   g_steeringProfiles_vulnerable[MAX_DRIVER_PROFILES];\n\nstatic DriverProfileConfig g_driverProfileConfigs_vulnerable[MAX_DRIVER_PROFILES];\n\nstatic uint8_t g_activeProfileIndex_vulnerable;\n\nvoid automotiveLog_vulnerable(const char* message) {}\n\nuint8_t receiveProfileSelectionCommand_vulnerable() {\n    return MAX_DRIVER_PROFILES;\n}\n\nvoid initializeVehicleProfiles_vulnerable() {\n    g_powertrainProfiles_vulnerable[0] = (PowertrainSettings){100, 3};\n    g_powertrainProfiles_vulnerable[1] = (PowertrainSettings){200, 1};\n    g_powertrainProfiles_vulnerable[2] = (PowertrainSettings){150, 2};\n\n    g_suspensionProfiles_vulnerable[0] = (SuspensionSettings){1, 0};\n    g_suspensionProfiles_vulnerable[1] = (SuspensionSettings){3, -10};\n    g_suspensionProfiles_vulnerable[2] = (SuspensionSettings){2, 5};\n\n    g_steeringProfiles_vulnerable[0] = (SteeringSettings){1, true};\n    g_steeringProfiles_vulnerable[1] = (SteeringSettings){3, false};\n    g_steeringProfiles_vulnerable[2] = (SteeringSettings){2, true};\n\n    for (uint8_t i = 0; i < MAX_DRIVER_PROFILES; ++i) {\n        g_driverProfileConfigs_vulnerable[i].powertrain_config = &g_powertrainProfiles_vulnerable[i];\n        g_driverProfileConfigs_vulnerable[i].suspension_config = &g_suspensionProfiles_vulnerable[i];\n        g_driverProfileConfigs_vulnerable[i].steering_config = &g_steeringProfiles_vulnerable[i];\n    }\n\n    g_activeProfileIndex_vulnerable = 0;\n}\n\nvoid setActiveDriverProfile_vulnerable(uint8_t profile_id) {\n    g_activeProfileIndex_vulnerable = profile_id;\n    automotiveLog_vulnerable(\"Driver profile selection attempted (vulnerable).\");\n}\n\nvoid applyActiveProfileToECUs_vulnerable() {\n    PowertrainSettings* current_pt_config = g_driverProfileConfigs_vulnerable[g_activeProfileIndex_vulnerable].powertrain_config;\n    SuspensionSettings* current_susp_config = g_driverProfileConfigs_vulnerable[g_activeProfileIndex_vulnerable].suspension_config;\n    SteeringSettings*   current_steer_config = g_driverProfileConfigs_vulnerable[g_activeProfileIndex_vulnerable].steering_config;\n\n    if (current_pt_config != NULL) {\n        automotiveLog_vulnerable(\"Powertrain settings applied.\");\n    }\n    if (current_susp_config != NULL) {\n        automotiveLog_vulnerable(\"Suspension settings applied.\");\n    }\n    if (current_steer_config != NULL) {\n        automotiveLog_vulnerable(\"Steering settings applied.\");\n    }\n    automotiveLog_vulnerable(\"Active profile settings applied to ECUs (vulnerable).\");\n}\n\nvoid vehicleMainLoop_vulnerable() {\n    initializeVehicleProfiles_vulnerable();\n\n    uint8_t cmd_profile_id = receiveProfileSelectionCommand_vulnerable();\n    setActiveDriverProfile_vulnerable(cmd_profile_id);\n\n    applyActiveProfileToECUs_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CAL_DATA_BANK_SIZE_BYTES 1024\n#define CAL_BLOCK_SIZE_BYTES 16\n\nstatic uint8_t g_calibration_bank[CAL_DATA_BANK_SIZE_BYTES];\nstatic size_t g_next_free_offset = 0;\n\nvoid init_calibration_bank() {\n    memset(g_calibration_bank, 0xFF, CAL_DATA_BANK_SIZE_BYTES);\n    g_next_free_offset = 0;\n}\n\nbool write_calibration_block(uint16_t id, const uint8_t* data) {\n    if (g_next_free_offset + CAL_BLOCK_SIZE_BYTES > CAL_DATA_BANK_SIZE_BYTES) {\n        return false;\n    }\n\n    uint8_t* block_ptr = g_calibration_bank + g_next_free_offset;\n    *((uint16_t*)block_ptr) = id; \n    *((uint16_t*)(block_ptr + 2)) = 0; \n    memcpy(block_ptr + 4, data, CAL_BLOCK_SIZE_BYTES - 4);\n\n    g_next_free_offset += CAL_BLOCK_SIZE_BYTES;\n    return true;\n}\n\nvoid invalidate_previous_cal_block_vulnerable(uint16_t blocks_ago_to_invalidate) {\n    if (g_next_free_offset == 0) {\n        return;\n    }\n\n    int32_t target_offset_signed = (int32_t)g_next_free_offset - ((int32_t)blocks_ago_to_invalidate * CAL_BLOCK_SIZE_BYTES);\n\n    *((uint16_t*)(g_calibration_bank + target_offset_signed)) = 0x0000;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define NUM_SENSOR_TYPES        8       \n#define NUM_CALIB_SUBTYPES      4       \n#define TOTAL_CALIBRATION_ENTRIES (NUM_SENSOR_TYPES * NUM_CALIB_SUBTYPES)\n\ntypedef struct {\n    int16_t offset_value;\n    uint16_t gain_factor;\n    uint8_t crc_check;\n} SensorCalibrationData;\n\nstatic SensorCalibrationData g_sensorCalibrationTable[TOTAL_CALIBRATION_ENTRIES];\n\nvoid logSensorError(const char* msg) {\n}\n\nuint8_t receiveSensorConfigPacket_vulnerable() {\n    return 0x74;\n}\n\nvoid initializeCalibrationData_vulnerable() {\n    for (uint8_t i = 0; i < TOTAL_CALIBRATION_ENTRIES; ++i) {\n        g_sensorCalibrationTable[i].offset_value = (int16_t)(i * 10);\n        g_sensorCalibrationTable[i].gain_factor = (uint16_t)(1000 + i);\n        g_sensorCalibrationTable[i].crc_check = (uint8_t)(i % 255);\n    }\n    logSensorError(\"Sensor calibration data initialized.\");\n}\n\nvoid applySensorCalibration_vulnerable() {\n    uint8_t config_byte = receiveSensorConfigPacket_vulnerable();\n\n    uint8_t sensor_id = (config_byte >> 4) & 0x0F;\n\n    uint8_t calibration_subtype = config_byte & 0x0F;\n\n    if (sensor_id < NUM_SENSOR_TYPES) {\n        uint16_t array_index = (uint16_t)(sensor_id * NUM_CALIB_SUBTYPES) + calibration_subtype;\n        \n        SensorCalibrationData current_calib = g_sensorCalibrationTable[array_index];\n        logSensorError(\"Calibration applied from sensor config.\");\n    } else {\n        logSensorError(\"Invalid sensor ID in config packet.\");\n    }\n}\n\nvoid sensorManagementMain_vulnerable() {\n    initializeCalibrationData_vulnerable();\n    applySensorCalibration_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <cstring>\n#include <new>\n#include <limits> // For std::numeric_limits\n\n// Represents a packet containing multiple string-based configuration entries.\n// total_string_bytes_in_packet: The sum of lengths of all strings present in this packet, WITHOUT null terminators.\n// num_strings: The count of individual strings in this packet.\nstruct ConfigPacketHeader {\n    uint32_t total_string_bytes_in_packet;\n    uint16_t num_strings;\n};\n\n// Each string entry within the packet payload has its own length.\nstruct StringEntryHeader {\n    uint16_t string_len; // Length of the string data, WITHOUT null terminator.\n};\n\nclass VehicleConfigLoaderFixed {\npublic:\n    VehicleConfigLoaderFixed() : m_config_strings_buffer(nullptr), m_buffer_capacity(0), m_current_offset(0) {}\n\n    ~VehicleConfigLoaderFixed() {\n        if (m_config_strings_buffer) {\n            free(m_config_strings_buffer);\n            m_config_strings_buffer = nullptr;\n        }\n    }\n\n    // Loads configuration strings from a raw packet.\n    // The packet is assumed to contain a ConfigPacketHeader followed by\n    // 'num_strings' entries, where each entry is a StringEntryHeader\n    // followed by its 'string_len' bytes of data.\n    bool loadConfigurationFixed(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(ConfigPacketHeader)) {\n            return false;\n        }\n\n        const ConfigPacketHeader* header = reinterpret_cast<const ConfigPacketHeader*>(packet_data);\n\n        // FIX:\n        // 1. Calculate the required total buffer size, accounting for null terminators for each string.\n        // 2. Add an integer overflow check for this calculation.\n        if (header->num_strings > (std::numeric_limits<size_t>::max() - header->total_string_bytes_in_packet)) {\n            return false; // Integer overflow if num_strings + total_string_bytes_in_packet exceeds size_t max.\n        }\n        size_t required_total_buffer_size = static_cast<size_t>(header->total_string_bytes_in_packet) + header->num_strings;\n\n        // Check if the input packet length is sufficient for all expected string data + individual string headers.\n        if (header->num_strings > (std::numeric_limits<size_t>::max() / sizeof(StringEntryHeader))) {\n            return false; // Prevent integer overflow in string entry header size calculation\n        }\n        size_t expected_packet_payload_size = static_cast<size_t>(header->num_strings) * sizeof(StringEntryHeader) + header->total_string_bytes_in_packet;\n\n        if (packet_length < sizeof(ConfigPacketHeader) + expected_packet_payload_size) {\n            return false;\n        }\n        \n        // Deallocate existing buffer if any.\n        if (m_config_strings_buffer) {\n            free(m_config_strings_buffer);\n            m_config_strings_buffer = nullptr;\n        }\n\n        // FIX: Allocate buffer with enough space for strings AND their null terminators.\n        m_buffer_capacity = required_total_buffer_size;\n        \n        m_config_strings_buffer = (char*)malloc(m_buffer_capacity);\n        if (!m_config_strings_buffer && m_buffer_capacity > 0) { // Check if allocation failed for non-zero sized buffer.\n            return false;\n        }\n        \n        m_current_offset = 0;\n\n        const uint8_t* current_payload_ptr = packet_data + sizeof(ConfigPacketHeader);\n        size_t remaining_payload_data = packet_length - sizeof(ConfigPacketHeader);\n\n        for (uint16_t i = 0; i < header->num_strings; ++i) {\n            if (remaining_payload_data < sizeof(StringEntryHeader)) {\n                if (m_config_strings_buffer) { free(m_config_strings_buffer); m_config_strings_buffer = nullptr; }\n                return false;\n            }\n\n            const StringEntryHeader* string_hdr = reinterpret_cast<const StringEntryHeader*>(current_payload_ptr);\n            uint16_t current_string_len = string_hdr->string_len;\n\n            // Advance past the StringEntryHeader\n            current_payload_ptr += sizeof(StringEntryHeader);\n            remaining_payload_data -= sizeof(StringEntryHeader);\n\n            // Check if enough payload data remains for the string content in the input packet.\n            if (remaining_payload_data < current_string_len) {\n                if (m_config_strings_buffer) { free(m_config_strings_buffer); m_config_strings_buffer = nullptr; }\n                return false;\n            }\n\n            // Check if there is enough space in the destination buffer for the current string AND its null terminator.\n            // This guards against malicious inputs where individual string lengths might exceed what's implied by total_string_bytes_in_packet\n            // or general inconsistencies, even after the initial buffer size calculation.\n            if (m_current_offset > (m_buffer_capacity - (current_string_len + 1))) {\n                 if (m_config_strings_buffer) { free(m_config_strings_buffer); m_config_strings_buffer = nullptr; }\n                 return false;\n            }\n            \n            // Copy string data to the internal buffer.\n            memcpy(m_config_strings_buffer + m_current_offset, current_payload_ptr, current_string_len);\n            \n            // Add null terminator after the string data. This is now safe as space was explicitly allocated.\n            m_config_strings_buffer[m_current_offset + current_string_len] = '\\0'; \n            \n            m_current_offset += current_string_len + 1; // Advance offset, accounting for null terminator\n\n            // Advance past the string data in the input packet.\n            current_payload_ptr += current_string_len;\n            remaining_payload_data -= current_string_len;\n        }\n\n        return true;\n    }\n\n    const char* getConfigStringsBuffer() const { return m_config_strings_buffer; }\n    size_t getBufferSize() const { return m_current_offset; } // Return actual used size (including nulls)\n\nprivate:\n    char*  m_config_strings_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_offset;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n\n#pragma pack(push, 1)\nstruct SensorBatchHeader {\n    uint32_t timestamp;\n    uint16_t num_entries;\n};\n\nstruct SensorEntryHeader {\n    uint8_t  sensor_id;\n    uint16_t data_len; \n};\n#pragma pack(pop)\n\nclass VehicleSensorLoggerVulnerable {\npublic:\n    VehicleSensorLoggerVulnerable() :\n        m_log_buffer(nullptr),\n        m_current_buffer_size(0),\n        m_allocated_capacity(0)\n    {\n        m_allocated_capacity = 1024;\n        m_log_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_log_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~VehicleSensorLoggerVulnerable() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n    }\n\n    bool addSensorBatchVulnerable(const uint8_t* raw_data_packet, size_t packet_length) {\n        if (!raw_data_packet || packet_length < sizeof(SensorBatchHeader)) {\n            return false;\n        }\n\n        const SensorBatchHeader* batch_hdr = reinterpret_cast<const SensorBatchHeader*>(raw_data_packet);\n        size_t current_packet_offset = sizeof(SensorBatchHeader);\n        size_t total_new_data_size = 0;\n\n        for (uint16_t i = 0; i < batch_hdr->num_entries; ++i) {\n            if (current_packet_offset + sizeof(SensorEntryHeader) > packet_length) {\n                return false;\n            }\n            const SensorEntryHeader* entry_hdr = reinterpret_cast<const SensorEntryHeader*>(raw_data_packet + current_packet_offset);\n            uint16_t entry_data_len = entry_hdr->data_len;\n\n            size_t required_entry_size = sizeof(SensorEntryHeader) + entry_data_len;\n            total_new_data_size += required_entry_size;\n            \n            if (current_packet_offset + required_entry_size > packet_length) {\n                return false;\n            }\n            current_packet_offset += required_entry_size;\n        }\n\n        // VULNERABILITY: Integer overflow in required_total_space calculation.\n        // If m_current_buffer_size is already very large (e.g., near SIZE_MAX) and\n        // total_new_data_size is also large, their sum can wrap around, resulting\n        // in a significantly smaller 'required_total_space' than actually needed.\n        size_t required_total_space = m_current_buffer_size + total_new_data_size;\n        \n        if (required_total_space > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity * 2; \n            if (new_capacity < required_total_space) {\n                new_capacity = required_total_space + 256; \n            }\n            // If required_total_space wrapped around, new_capacity will also be small.\n            \n            uint8_t* new_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n            if (!new_buffer) {\n                return false;\n            }\n            m_log_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        current_packet_offset = sizeof(SensorBatchHeader);\n        \n        for (uint16_t i = 0; i < batch_hdr->num_entries; ++i) {\n            const SensorEntryHeader* entry_hdr = reinterpret_cast<const SensorEntryHeader*>(raw_data_packet + current_packet_offset);\n            uint16_t entry_data_len = entry_hdr->data_len;\n            size_t bytes_to_copy_for_entry = sizeof(SensorEntryHeader) + entry_data_len;\n\n            m_log_buffer[m_current_buffer_size] = entry_hdr->sensor_id;\n            m_log_buffer[m_current_buffer_size + 1] = (uint8_t)(entry_hdr->data_len & 0xFF);\n            m_log_buffer[m_current_buffer_size + 2] = (uint8_t)((entry_hdr->data_len >> 8) & 0xFF);\n            \n            const uint8_t* payload_src = raw_data_packet + current_packet_offset + sizeof(SensorEntryHeader);\n            // VULNERABILITY: If the buffer was undersized due to the integer overflow above,\n            // this loop will write past the end of the allocated 'm_log_buffer' in the heap.\n            for (uint16_t j = 0; j < entry_data_len; ++j) {\n                m_log_buffer[m_current_buffer_size + sizeof(SensorEntryHeader) + j] = payload_src[j];\n            }\n            \n            m_current_buffer_size += bytes_to_copy_for_entry;\n            current_packet_offset += bytes_to_copy_for_entry;\n        }\n\n        return true;\n    }\n\n    size_t getCurrentBufferSize() const { return m_current_buffer_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n    const uint8_t* getLogBuffer() const { return m_log_buffer; }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t m_current_buffer_size;\n    size_t m_allocated_capacity;\n};\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define CRITICAL_CALIBRATION_VALUES_COUNT 10 \n#define CALIBRATION_BUFFER_SIZE (CRITICAL_CALIBRATION_VALUES_COUNT * sizeof(uint16_t))\n\nstatic uint16_t g_criticalCalibrationValues[CRITICAL_CALIBRATION_VALUES_COUNT];\n\nvoid initCalibrationValues() {\n    memset(g_criticalCalibrationValues, 0, CALIBRATION_BUFFER_SIZE);\n    for (uint8_t i = 0; i < CRITICAL_CALIBRATION_VALUES_COUNT; ++i) {\n        g_criticalCalibrationValues[i] = (i + 1) * 100;\n    }\n}\n\ntypedef struct {\n    uint8_t  group_id;\n    uint8_t  item_offset;\n    uint16_t new_value;\n} CalibrationUpdateCommand;\n\nint applyCalibrationUpdate(const CalibrationUpdateCommand* command) {\n    if (command == NULL) {\n        return -1;\n    }\n\n    uint8_t group_id = command->group_id;\n    uint8_t item_offset = command->item_offset;\n    uint16_t new_value = command->new_value;\n\n    uint16_t effective_index_base; \n\n    switch (group_id) {\n        case 0:\n            effective_index_base = 0;\n            break;\n        case 1:\n            effective_index_base = 5;\n            break;\n        case 2:\n            effective_index_base = 250;\n            break;\n        default:\n            return -2;\n    }\n\n    uint16_t final_index = effective_index_base + item_offset;\n\n    if (final_index >= CRITICAL_CALIBRATION_VALUES_COUNT) {\n        return -3;\n    }\n\n    g_criticalCalibrationValues[final_index] = new_value;\n\n    return 0;\n}\n\nvoid simulateExternalCalibrationUpdate(uint8_t group, uint8_t offset, uint16_t value) {\n    CalibrationUpdateCommand cmd = { .group_id = group, .item_offset = offset, .new_value = value };\n    applyCalibrationUpdate(&cmd);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SENSOR_HISTORY_BUFFER_SIZE 8\n#define INITIAL_OFFSET_VALUE 0\n\nstatic int16_t g_sensor_readings_history_fixed[SENSOR_HISTORY_BUFFER_SIZE];\nstatic int16_t g_current_history_idx_fixed = -1;\nstatic uint8_t g_filled_count_fixed = 0;\n\nvoid init_sensor_history_module_fixed() {\n    memset(g_sensor_readings_history_fixed, INITIAL_OFFSET_VALUE, sizeof(g_sensor_readings_history_fixed));\n    g_current_history_idx_fixed = -1;\n    g_filled_count_fixed = 0;\n}\n\nvoid record_sensor_reading_fixed(int16_t reading) {\n    if (g_filled_count_fixed < SENSOR_HISTORY_BUFFER_SIZE) {\n        g_current_history_idx_fixed++;\n        g_filled_count_fixed++;\n    } else {\n        g_current_history_idx_fixed = (g_current_history_idx_fixed + 1) % SENSOR_HISTORY_BUFFER_SIZE;\n    }\n    g_sensor_readings_history_fixed[g_current_history_idx_fixed] = reading;\n}\n\nvoid adjust_historical_sensor_value_fixed(int16_t correction_value, uint8_t lookback_depth) {\n    if (g_filled_count_fixed == 0) {\n        return;\n    }\n\n    if (lookback_depth >= g_filled_count_fixed) {\n        return;\n    }\n\n    int32_t raw_target_idx = (int32_t)g_current_history_idx_fixed - (int32_t)lookback_depth;\n    int16_t source_idx = (raw_target_idx % SENSOR_HISTORY_BUFFER_SIZE + SENSOR_HISTORY_BUFFER_SIZE) % SENSOR_HISTORY_BUFFER_SIZE;\n\n    g_sensor_readings_history_fixed[source_idx] += correction_value;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_LOG_ENTRIES 50\n#define DIAG_LOG_ENTRY_SIZE 8\n\ntypedef struct {\n    uint16_t eventId;\n    uint16_t subId;\n    uint32_t timestamp;\n} DiagnosticLogEntry;\n\nstatic DiagnosticLogEntry g_diagnosticLogBuffer[MAX_DIAG_LOG_ENTRIES];\nstatic uint16_t g_currentStoredLogCount = 0;\n\nvoid initDiagnosticLogger() {\n    memset(g_diagnosticLogBuffer, 0, sizeof(g_diagnosticLogBuffer));\n    g_currentStoredLogCount = 0;\n}\n\nint processAndStoreLogBlock(const uint8_t* raw_log_block, uint16_t block_byte_len) {\n    if (raw_log_block == NULL || block_byte_len == 0) {\n        return -1;\n    }\n\n    if (block_byte_len % DIAG_LOG_ENTRY_SIZE != 0) {\n        return -2;\n    }\n\n    uint16_t num_entries_in_block = block_byte_len / DIAG_LOG_ENTRY_SIZE;\n\n    uint16_t entries_to_write;\n    if (g_currentStoredLogCount >= MAX_DIAG_LOG_ENTRIES) {\n        entries_to_write = 0;\n    } else {\n        uint16_t remaining_space = MAX_DIAG_LOG_ENTRIES - g_currentStoredLogCount;\n        if (num_entries_in_block > remaining_space) {\n            entries_to_write = remaining_space;\n        } else {\n            entries_to_write = num_entries_in_block;\n        }\n    }\n    \n    if (entries_to_write == 0) {\n        return -3;\n    }\n\n    for (uint16_t i = 0; i < entries_to_write; ++i) {\n        uint16_t target_log_idx = g_currentStoredLogCount + i;\n\n        g_diagnosticLogBuffer[target_log_idx].eventId = (raw_log_block[i * DIAG_LOG_ENTRY_SIZE] << 8) |\n                                                            raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 1];\n        g_diagnosticLogBuffer[target_log_idx].subId = (raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 2] << 8) |\n                                                          raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 3];\n        g_diagnosticLogBuffer[target_log_idx].timestamp = (raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 4] << 24) |\n                                                              (raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 5] << 16) |\n                                                              (raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 6] << 8) |\n                                                              raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 7];\n    }\n\n    g_currentStoredLogCount += entries_to_write;\n\n    return 0;\n}\n\nDiagnosticLogEntry getLogEntry(uint16_t index) {\n    if (index < MAX_DIAG_LOG_ENTRIES) {\n        return g_diagnosticLogBuffer[index];\n    }\n    DiagnosticLogEntry empty = {0,0,0};\n    return empty;\n}\n\nvoid simulateCanLogMessage(const uint8_t* data, uint16_t len) {\n    processAndStoreLogBlock(data, len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#define CONFIG_TYPE_A_COUNT 10\n#define CONFIG_TYPE_B_COUNT 15\n#define CONFIG_TYPE_C_COUNT 8\n#define MAX_CONFIG_TYPES 3\n\ntypedef struct {\n    unsigned int param1;\n    unsigned short param2;\n} ConfigItemA;\n\ntypedef struct {\n    unsigned char status;\n    unsigned int data;\n    unsigned short checksum;\n} ConfigItemB;\n\ntypedef struct {\n    float value;\n} ConfigItemC;\n\nstatic ConfigItemA g_configA[CONFIG_TYPE_A_COUNT];\nstatic ConfigItemB g_configB[CONFIG_TYPE_B_COUNT];\nstatic ConfigItemC g_configC[CONFIG_TYPE_C_COUNT];\n\nstatic unsigned short g_configSizes[MAX_CONFIG_TYPES] = {\n    CONFIG_TYPE_A_COUNT,\n    CONFIG_TYPE_B_COUNT,\n    CONFIG_TYPE_C_COUNT\n};\n\ntypedef struct {\n    unsigned char config_type_id;\n    unsigned char sub_index;\n    unsigned int value;\n} DiagnosticCommand;\n\nDiagnosticCommand receiveDiagnosticCommand_fixed() {\n    DiagnosticCommand cmd;\n    cmd.config_type_id = 0;\n    cmd.sub_index = 10; \n    cmd.value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid logDiagnosticError(const char* msg) {\n}\n\nvoid processDiagnosticCommand_fixed() {\n    DiagnosticCommand cmd = receiveDiagnosticCommand_fixed();\n\n    if (cmd.config_type_id < MAX_CONFIG_TYPES) {\n        unsigned short max_index = g_configSizes[cmd.config_type_id];\n        \n        if (cmd.sub_index < max_index) {\n            switch (cmd.config_type_id) {\n                case 0:\n                    g_configA[cmd.sub_index].param1 = cmd.value;\n                    break;\n                case 1:\n                    g_configB[cmd.sub_index].data = cmd.value;\n                    break;\n                case 2:\n                    g_configC[cmd.sub_index].value = (float)cmd.value;\n                    break;\n                default:\n                    logDiagnosticError(\"Internal error: Reached default case in config type switch.\");\n                    break;\n            }\n        } else {\n            logDiagnosticError(\"Out-of-bounds sub-index for configuration update. Ignoring command.\");\n        }\n    } else {\n        logDiagnosticError(\"Invalid config type ID received.\");\n    }\n}\n\nvoid diagnosticModuleMain_fixed() {\n    for (int i = 0; i < CONFIG_TYPE_A_COUNT; ++i) g_configA[i] = (ConfigItemA){0,0};\n    for (int i = 0; i < CONFIG_TYPE_B_COUNT; ++i) g_configB[i] = (ConfigItemB){0,0,0};\n    for (int i = 0; i < CONFIG_TYPE_C_COUNT; ++i) g_configC[i] = (ConfigItemC){0.0f};\n\n    processDiagnosticCommand_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_VEHICLE_EVENT_TYPES 5\n#define EVENT_PAYLOAD_SIZE 8\n\nvoid logSystemError(const char* msg) {\n}\n\ntypedef enum {\n    EVENT_TYPE_IGNITION_ON = 0,\n    EVENT_TYPE_GEAR_CHANGE,\n    EVENT_TYPE_DOOR_OPEN,\n    EVENT_TYPE_BRAKE_PEDAL,\n    EVENT_TYPE_ACCELERATOR_PEDAL\n} VehicleEventType;\n\ntypedef struct {\n    uint8_t eventType;\n    uint8_t payload[EVENT_PAYLOAD_SIZE];\n} VehicleEvent;\n\nvoid handleIgnitionOn(const uint8_t* payload) {\n}\n\nvoid handleGearChange(const uint8_t* payload) {\n}\n\nvoid handleDoorOpen(const uint8_t* payload) {\n}\n\nvoid handleBrakePedal(const uint8_t* payload) {\n}\n\nvoid handleAcceleratorPedal(const uint8_t* payload) {\n}\n\nvoid (*g_vulnerableEventHandlers[MAX_VEHICLE_EVENT_TYPES])(const uint8_t* payload) = {\n    handleIgnitionOn,\n    handleGearChange,\n    handleDoorOpen,\n    handleBrakePedal,\n    handleAcceleratorPedal\n};\n\nVehicleEvent getNextVehicleEvent_vulnerable() {\n    VehicleEvent event;\n    event.eventType = MAX_VEHICLE_EVENT_TYPES; \n    event.payload[0] = 0xFF;\n    for (int i = 1; i < EVENT_PAYLOAD_SIZE; ++i) {\n        event.payload[i] = 0;\n    }\n    return event;\n}\n\nvoid processVehicleEvent_vulnerable() {\n    VehicleEvent currentEvent = getNextVehicleEvent_vulnerable();\n\n    g_vulnerableEventHandlers[currentEvent.eventType](currentEvent.payload);\n}\n\nvoid automotiveECU_vulnerable_main() {\n    processVehicleEvent_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 64\n#define MAX_COMMAND_PAYLOAD_SIZE 128\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t parameter_idx;\n    uint8_t data_length;\n    uint8_t data[MAX_COMMAND_PAYLOAD_SIZE - 3];\n} VehicleCommand;\n\nstatic uint8_t g_vehicleConfigArea[VEHICLE_CONFIG_BUFFER_SIZE];\n\nvoid initVehicleConfigArea() {\n    memset(g_vehicleConfigArea, 0x00, VEHICLE_CONFIG_BUFFER_SIZE);\n}\n\n#define CMD_UPDATE_CONFIG_DATA 0x05\n#define CMD_READ_CONFIG_DATA   0x06\n\nint processVehicleCommand(const VehicleCommand* cmd) {\n    if (cmd == NULL) {\n        return -1;\n    }\n\n    if (cmd->command_id == CMD_UPDATE_CONFIG_DATA) {\n        uint8_t start_offset = cmd->parameter_idx;\n        uint8_t data_to_copy = cmd->data_length;\n\n        if (start_offset >= VEHICLE_CONFIG_BUFFER_SIZE) {\n            return -2;\n        }\n\n        if (data_to_copy > (MAX_COMMAND_PAYLOAD_SIZE - (sizeof(cmd->command_id) + sizeof(cmd->parameter_idx) + sizeof(cmd->data_length)))) {\n             return -3;\n        }\n\n        uint8_t available_space = VEHICLE_CONFIG_BUFFER_SIZE - start_offset;\n        uint8_t actual_bytes_to_copy = data_to_copy;\n\n        if (actual_bytes_to_copy > available_space) {\n            actual_bytes_to_copy = available_space;\n        }\n\n        memcpy(g_vehicleConfigArea + start_offset, cmd->data, actual_bytes_to_copy);\n\n        if (data_to_copy > actual_bytes_to_copy) {\n            return -5;\n        }\n\n        return 0;\n    } else if (cmd->command_id == CMD_READ_CONFIG_DATA) {\n        return 0;\n    }\n    \n    return -4;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_TRANSPORT_BUFFER_SIZE 128\n#define FIRMWARE_SEGMENT_PAYLOAD_BUFFER_SIZE 10\n\ntypedef struct {\n    uint16_t address;\n    uint8_t  data_length; \n    uint8_t  payload[FIRMWARE_SEGMENT_PAYLOAD_BUFFER_SIZE];\n    uint16_t checksum;\n} FirmwareSegment;\n\nvoid initFirmwareStorage() {\n    \n}\n\nint deserializeFirmwareSegment_Vulnerable(const uint8_t* raw_buffer, uint16_t buffer_len, FirmwareSegment* out_segment) {\n    if (raw_buffer == NULL || out_segment == NULL || buffer_len < (sizeof(uint16_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    out_segment->address = (raw_buffer[current_offset] << 8) | raw_buffer[current_offset + 1];\n    current_offset += sizeof(uint16_t);\n\n    out_segment->data_length = raw_buffer[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    if (current_offset + out_segment->data_length > buffer_len) {\n        return -2;\n    }\n\n    for (uint8_t i = 0; i < out_segment->data_length; ++i) {\n        out_segment->payload[i] = raw_buffer[current_offset + i];\n    }\n\n    out_segment->checksum = 0;\n\n    return 0;\n}\n\nvoid handleIncomingFirmwarePacket_Vulnerable(const uint8_t* packet_data, uint16_t packet_len) {\n    FirmwareSegment segment;\n    deserializeFirmwareSegment_Vulnerable(packet_data, packet_len, &segment);\n}\n", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#define MAX_MODES 3\n#define MAX_NORMAL_PARAMS 5\n#define MAX_SPORT_PARAMS 7\n#define MAX_ECO_PARAMS 4\n\ntypedef union {\n    uint16_t u16_val;\n    int16_t  s16_val;\n    float    f_val;\n} ParameterValue_Vulnerable;\n\ntypedef struct {\n    uint8_t      param_type;\n    ParameterValue_Vulnerable value;\n    uint16_t     min_limit;\n    uint16_t     max_limit;\n} ModeParameter_Vulnerable;\n\nstatic ModeParameter_Vulnerable g_normalModeParams_vulnerable[MAX_NORMAL_PARAMS];\nstatic ModeParameter_Vulnerable g_sportModeParams_vulnerable[MAX_SPORT_PARAMS];\nstatic ModeParameter_Vulnerable g_ecoModeParams_vulnerable[MAX_ECO_PARAMS];\n\ntypedef struct {\n    ModeParameter_Vulnerable* params_ptr;\n    uint8_t        max_params_count;\n} ModeConfigTableEntry_Vulnerable;\n\nstatic ModeConfigTableEntry_Vulnerable g_modeConfigs_vulnerable[MAX_MODES];\n\nstatic uint8_t g_currentVehicleMode_vulnerable; \n\nvoid vehicleDebugLog_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t  mode_id;\n    uint8_t  parameter_idx;\n    uint16_t new_uint_value;\n} ParameterAdjustmentCommand_Vulnerable;\n\nParameterAdjustmentCommand_Vulnerable receiveAdjustmentCommand_vulnerable() {\n    ParameterAdjustmentCommand_Vulnerable cmd;\n    cmd.mode_id = 0;\n    cmd.parameter_idx = 5;\n    cmd.new_uint_value = 1234;\n    return cmd;\n}\n\nvoid initializeVehicleModes_vulnerable() {\n    g_modeConfigs_vulnerable[0] = (ModeConfigTableEntry_Vulnerable){g_normalModeParams_vulnerable, MAX_NORMAL_PARAMS};\n    g_modeConfigs_vulnerable[1] = (ModeConfigTableEntry_Vulnerable){g_sportModeParams_vulnerable, MAX_SPORT_PARAMS};\n    g_modeConfigs_vulnerable[2] = (ModeConfigTableEntry_Vulnerable){g_ecoModeParams_vulnerable, MAX_ECO_PARAMS};\n\n    for (uint8_t i = 0; i < MAX_NORMAL_PARAMS; ++i) g_normalModeParams_vulnerable[i].value.u16_val = 100 + i;\n    for (uint8_t i = 0; i < MAX_SPORT_PARAMS; ++i) g_sportModeParams_vulnerable[i].value.u16_val = 200 + i;\n    for (uint8_t i = 0; i < MAX_ECO_PARAMS; ++i) g_ecoModeParams_vulnerable[i].value.u16_val = 300 + i;\n\n    g_currentVehicleMode_vulnerable = 0;\n    vehicleDebugLog_vulnerable(\"Vehicle modes initialized.\");\n}\n\nvoid adjustVehicleParameter_vulnerable() {\n    ParameterAdjustmentCommand_Vulnerable cmd = receiveAdjustmentCommand_vulnerable();\n\n    if (g_currentVehicleMode_vulnerable < MAX_MODES) {\n        ModeParameter_Vulnerable* active_params = g_modeConfigs_vulnerable[g_currentVehicleMode_vulnerable].params_ptr;\n        active_params[cmd.parameter_idx].value.u16_val = cmd.new_uint_value;\n        vehicleDebugLog_vulnerable(\"Vehicle parameter adjusted.\");\n    } else {\n        vehicleDebugLog_vulnerable(\"Invalid vehicle mode specified for adjustment.\");\n    }\n}\n\nvoid vehicleControlMain_vulnerable() {\n    initializeVehicleModes_vulnerable();\n    adjustVehicleParameter_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define CALIBRATION_DATA_SIZE 256\n#define MAX_CAN_DLC 8\n\ntypedef struct {\n    uint8_t  command_id;\n    uint8_t  segment_offset_high;\n    uint8_t  segment_offset_low;\n    uint8_t  segment_length;\n    uint8_t  data[MAX_CAN_DLC - 4];\n} CanCalibrationUpdatePacket;\n\nstatic uint8_t g_calibrationData[CALIBRATION_DATA_SIZE];\n\nvoid initCalibrationSystem() {\n    memset(g_calibrationData, 0xFF, CALIBRATION_DATA_SIZE);\n}\n\nint processCalibrationUpdate(const CanCalibrationUpdatePacket* packet_data, uint8_t actual_can_dlc) {\n    if (packet_data == NULL || actual_can_dlc < 4) {\n        return -1;\n    }\n\n    if (packet_data->command_id != 0x01) {\n        return -2;\n    }\n\n    uint16_t segment_offset = ((uint16_t)packet_data->segment_offset_high << 8) | packet_data->segment_offset_low;\n    uint8_t segment_length = packet_data->segment_length;\n\n    if (segment_length > (actual_can_dlc - 4)) {\n        return -3;\n    }\n\n    if (segment_offset >= CALIBRATION_DATA_SIZE) {\n        return -4;\n    }\n\n    if (segment_length > (CALIBRATION_DATA_SIZE - segment_offset)) {\n        return -5;\n    }\n\n    memcpy(g_calibrationData + segment_offset, packet_data->data, segment_length);\n\n    return 0;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>#include <stddef.h>typedef struct {uint32_t code;uint16_t timestamp;uint8_t severity;uint8_t _padding;} DtcEntry;#define MAX_DTC_TYPES 5#define TOTAL_DTC_HISTORY_BUFFER_SIZE 256static uint8_t g_dtcHistoryBuffer_vulnerable[TOTAL_DTC_HISTORY_BUFFER_SIZE];typedef struct {uint16_t start_offset_bytes;uint16_t max_entries;} DtcHistorySegmentConfig;static DtcHistorySegmentConfig g_dtcSegmentConfigs_vulnerable[MAX_DTC_TYPES] = {{0, 7},{56, 8},{120, 8},{184, 8},{248, 1}};#ifndef DUMMY_LOG_ERROR_VULNERABLE_DEFINED#define DUMMY_LOG_ERROR_VULNERABLE_DEFINEDvoid logError_vulnerable(const char* msg) {}#endifstatic uint16_t g_currentDtcEntryCount_vulnerable[MAX_DTC_TYPES];typedef struct {uint8_t dtc_type_id;uint32_t dtc_code;uint16_t timestamp;uint8_t severity;} IncomingDtcLogRequest_vulnerable;IncomingDtcLogRequest_vulnerable receiveDtcLogRequest_vulnerable() {IncomingDtcLogRequest_vulnerable req;req.dtc_type_id = 3;req.dtc_code = 0xDEADBEEF;req.timestamp = 12345;req.severity = 2;return req;}void initializeDtcHistory_vulnerable() {for (int i = 0; i < TOTAL_DTC_HISTORY_BUFFER_SIZE; ++i) {g_dtcHistoryBuffer_vulnerable[i] = 0;}for (int i = 0; i < MAX_DTC_TYPES; ++i) {g_currentDtcEntryCount_vulnerable[i] = 0;}}void logDtcEntry_vulnerable() {IncomingDtcLogRequest_vulnerable request = receiveDtcLogRequest_vulnerable();if (request.dtc_type_id >= MAX_DTC_TYPES) {logError_vulnerable(", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SENSOR_HISTORY_BUFFER_SIZE 8\n#define INITIAL_OFFSET_VALUE 0\n\nstatic int16_t g_sensor_readings_history[SENSOR_HISTORY_BUFFER_SIZE];\nstatic int16_t g_current_history_idx = -1; \nstatic uint8_t g_filled_count = 0; \n\nvoid init_sensor_history_module() {\n    memset(g_sensor_readings_history, INITIAL_OFFSET_VALUE, sizeof(g_sensor_readings_history));\n    g_current_history_idx = -1;\n    g_filled_count = 0;\n}\n\nvoid record_sensor_reading(int16_t reading) {\n    if (g_filled_count < SENSOR_HISTORY_BUFFER_SIZE) {\n        g_current_history_idx++;\n        g_filled_count++;\n    } else {\n        g_current_history_idx = (g_current_history_idx + 1) % SENSOR_HISTORY_BUFFER_SIZE;\n    }\n    g_sensor_readings_history[g_current_history_idx] = reading;\n}\n\nvoid adjust_historical_sensor_value_vulnerable(int16_t correction_value, uint8_t lookback_depth) {\n    if (g_filled_count == 0) {\n        return;\n    }\n\n    if (lookback_depth == 0 || lookback_depth > g_filled_count) {\n        return;\n    }\n\n    int16_t source_idx = g_current_history_idx - (int16_t)lookback_depth;\n\n    g_sensor_readings_history[source_idx] += correction_value;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_MAX_SIZE 256\n#define CONFIG_CHUNK_SIZE 16\n\nstatic uint8_t g_vehicle_config_store[VEHICLE_CONFIG_MAX_SIZE];\nstatic size_t g_current_config_size = 0;\n\nvoid init_vehicle_config_store_fixed() {\n    memset(g_vehicle_config_store, 0xFF, VEHICLE_CONFIG_MAX_SIZE);\n    g_current_config_size = 0;\n}\n\nbool write_config_chunk_fixed(const uint8_t* data, size_t len) {\n    if (len == 0 || len > CONFIG_CHUNK_SIZE || g_current_config_size + len > VEHICLE_CONFIG_MAX_SIZE) {\n        return false;\n    }\n    memcpy(g_vehicle_config_store + g_current_config_size, data, len);\n    g_current_config_size += len;\n    return true;\n}\n\nvoid purge_config_segment_Fixed(int16_t offset_chunks_from_end, uint16_t chunks_to_purge) {\n    if (g_current_config_size == 0 || chunks_to_purge == 0) {\n        return;\n    }\n\n    int32_t total_bytes_to_clear = (int32_t)chunks_to_purge * CONFIG_CHUNK_SIZE;\n\n    int32_t potential_start_byte_to_clear = (int32_t)g_current_config_size - ((int32_t)offset_chunks_from_end * CONFIG_CHUNK_SIZE) - total_bytes_to_clear;\n\n    if (potential_start_byte_to_clear < 0) {\n        return;\n    }\n\n    if (potential_start_byte_to_clear + total_bytes_to_clear > g_current_config_size) {\n        total_bytes_to_clear = g_current_config_size - potential_start_byte_to_clear;\n        if (total_bytes_to_clear <= 0) return;\n    }\n\n    for (int32_t i = 0; i < total_bytes_to_clear; ++i) {\n        g_vehicle_config_store[potential_start_byte_to_clear + i] = 0x00;\n    }\n}\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n// Configuration for the telemetry system\n#define TELEMETRY_BUFFER_SIZE 128 // Small buffer to easily demonstrate overflow\n#define MAX_DIAG_DATA_LENGTH 15   // Max length for custom diagnostic data payload\n\n// Sensor Type Definitions\n#define SENSOR_TYPE_TEMPERATURE     0x01 // 1 byte value\n#define SENSOR_TYPE_PRESSURE        0x02 // 2 bytes value\n#define SENSOR_TYPE_RPM             0x03 // 4 bytes value\n#define SENSOR_TYPE_CUSTOM_DIAG     0x04 // Variable length (1 byte length + up to MAX_DIAG_DATA_LENGTH bytes data)\n#define SENSOR_TYPE_IGNITION_STATUS 0x05 // 1 byte value for simplicity of packing\n\n// Global telemetry buffer and current write offset\nstatic uint8_t g_telemetry_data_buffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_current_telemetry_write_offset;\n\n// Function to initialize the telemetry buffer\nvoid initializeTelemetryBuffer() {\n    memset(g_telemetry_data_buffer, 0, TELEMETRY_BUFFER_SIZE);\n    g_current_telemetry_write_offset = 0;\n}\n\n// Function to pack sensor data into the global telemetry buffer.\n// Returns 0 on success, or a negative value on error.\n// Fix: Comprehensive bounds checking is performed before any data is written for an item,\n// ensuring that the entire item (type ID + payload) fits within the buffer.\nint packSensorDataToBuffer(uint8_t sensor_type, uint32_t sensor_value) {\n    uint16_t current_pos = g_current_telemetry_write_offset;\n    uint8_t bytes_needed_for_payload = 0; // Bytes for the value data, not including type byte\n    uint8_t actual_diag_len = 0;\n\n    // Calculate bytes needed for the payload data based on sensor type\n    switch (sensor_type) {\n        case SENSOR_TYPE_TEMPERATURE:\n            bytes_needed_for_payload = 1;\n            break;\n        case SENSOR_TYPE_PRESSURE:\n            bytes_needed_for_payload = 2;\n            break;\n        case SENSOR_TYPE_RPM:\n            bytes_needed_for_payload = 4;\n            break;\n        case SENSOR_TYPE_CUSTOM_DIAG:\n            actual_diag_len = (uint8_t)(sensor_value & 0x0F);\n            if (actual_diag_len > MAX_DIAG_DATA_LENGTH) {\n                actual_diag_len = MAX_DIAG_DATA_LENGTH;\n            }\n            bytes_needed_for_payload = 1 + actual_diag_len; // 1 for length byte + data bytes\n            break;\n        case SENSOR_TYPE_IGNITION_STATUS:\n            bytes_needed_for_payload = 1;\n            break;\n        default:\n            return -2; // Unknown sensor type\n    }\n\n    // Comprehensive bounds check: Ensure there is enough space for the type ID AND the entire payload\n    if (current_pos + 1 + bytes_needed_for_payload > TELEMETRY_BUFFER_SIZE) {\n        return -1; // Not enough space for this telemetry item\n    }\n\n    // Now it's safe to write the type ID and payload\n    g_telemetry_data_buffer[current_pos++] = sensor_type; // Write type ID\n\n    switch (sensor_type) {\n        case SENSOR_TYPE_TEMPERATURE:\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value & 0xFF);\n            break;\n        case SENSOR_TYPE_PRESSURE:\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)((sensor_value >> 8) & 0xFF);\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value & 0xFF);\n            break;\n        case SENSOR_TYPE_RPM:\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)((sensor_value >> 24) & 0xFF);\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)((sensor_value >> 16) & 0xFF);\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)((sensor_value >> 8) & 0xFF);\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value & 0xFF);\n            break;\n        case SENSOR_TYPE_CUSTOM_DIAG:\n            // actual_diag_len was already calculated\n            g_telemetry_data_buffer[current_pos++] = actual_diag_len; // Write length byte\n            for (int i = 0; i < actual_diag_len; ++i) {\n                // All writes in this loop are now guaranteed to be in bounds due to the earlier check\n                g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value >> (8 * (actual_diag_len - 1 - i)));\n            }\n            break;\n        case SENSOR_TYPE_IGNITION_STATUS:\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value & 0x01);\n            break;\n        default:\n            // This case should ideally not be reached due to the initial check for unknown type.\n            // If it is, something else is wrong, or the type changed between checks.\n            // Defensive coding: revert the type ID write.\n            g_current_telemetry_write_offset = current_pos - 1;\n            return -3; // Internal error or race condition\n    }\n    \n    g_current_telemetry_write_offset = current_pos;\n    return 0; // Success\n}\n\n// Main function to simulate telemetry data collection and transmission cycle\nvoid prepareAndTransmitSensorData() {\n    initializeTelemetryBuffer();\n\n    // Populate with some initial data\n    packSensorDataToBuffer(SENSOR_TYPE_TEMPERATURE, 75);\n    packSensorDataToBuffer(SENSOR_TYPE_PRESSURE, 2560);\n    packSensorDataToBuffer(SENSOR_TYPE_RPM, 3500);\n\n    // Fill the buffer until there are exactly 10 bytes remaining.\n    // A CUSTOM_DIAG item with MAX_DIAG_DATA_LENGTH (15) requires 1+1+15=17 bytes.\n    // If only 10 bytes are remaining, the fix will prevent the write.\n    while (g_current_telemetry_write_offset < TELEMETRY_BUFFER_SIZE - 10) {\n        packSensorDataToBuffer(SENSOR_TYPE_TEMPERATURE, 20);\n    }\n\n    // This call attempts to write 17 bytes when only 10 bytes remain.\n    // The fixed packSensorDataToBuffer will now return an error (-1) and not write out of bounds.\n    int result = packSensorDataToBuffer(SENSOR_TYPE_CUSTOM_DIAG, MAX_DIAG_DATA_LENGTH);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_HISTORICAL_PARAMS 5\n#define MAX_RECORDS_PER_PARAM 10\n\ntypedef struct {\n    uint16_t value;\n    uint32_t timestamp;\n} ParameterDataEntry;\n\n// Stored historical data for each parameter\nstatic ParameterDataEntry g_historicalData_vulnerable[MAX_HISTORICAL_PARAMS][MAX_RECORDS_PER_PARAM];\n// Current actual count of records for each parameter (can be less than MAX_RECORDS_PER_PARAM)\nstatic uint8_t g_currentRecordCount_vulnerable[MAX_HISTORICAL_PARAMS];\n\ntypedef struct {\n    uint8_t paramId;\n    uint8_t recordIndex;\n} DiagnosticQuery;\n\nvoid automotiveLog_vulnerable(const char* msg) {\n}\n\n// Simulates receiving a diagnostic query from an external source (e.g., CAN bus)\nDiagnosticQuery receiveDiagnosticQuery_vulnerable() {\n    DiagnosticQuery query;\n    query.paramId = 1; \n    query.recordIndex = 7; \n    return query;\n}\n\n// Initializes historical data and actual record counts\nvoid initializeHistoricalData_vulnerable() {\n    for (uint8_t i = 0; i < MAX_HISTORICAL_PARAMS; ++i) {\n        g_currentRecordCount_vulnerable[i] = 0;\n        for (uint8_t j = 0; j < MAX_RECORDS_PER_PARAM; ++j) {\n            g_historicalData_vulnerable[i][j] = (ParameterDataEntry){0, 0};\n        }\n    }\n\n    // Populate some data for paramId 1 with 5 actual records\n    g_currentRecordCount_vulnerable[1] = 5;\n    for (uint8_t j = 0; j < g_currentRecordCount_vulnerable[1]; ++j) {\n        g_historicalData_vulnerable[1][j] = (ParameterDataEntry){100 + j, 0x12345678 + j};\n    }\n\n    // Populate some data for paramId 0 with MAX_RECORDS_PER_PARAM records\n    g_currentRecordCount_vulnerable[0] = MAX_RECORDS_PER_PARAM;\n    for (uint8_t j = 0; j < g_currentRecordCount_vulnerable[0]; ++j) {\n        g_historicalData_vulnerable[0][j] = (ParameterDataEntry){200 + j, 0xAABBCCDD + j};\n    }\n}\n\n// Processes a diagnostic query to retrieve historical data\nvoid processDiagnosticQuery_vulnerable() {\n    DiagnosticQuery query = receiveDiagnosticQuery_vulnerable();\n\n    if (query.paramId < MAX_HISTORICAL_PARAMS) { // Check if parameter ID is within bounds\n        // Vulnerability: recordIndex is NOT checked against g_currentRecordCount_vulnerable[query.paramId].\n        // An attacker can request a recordIndex that is within MAX_RECORDS_PER_PARAM \n        // but beyond the actual number of records stored for this specific paramId,\n        // leading to an out-of-bounds read within the g_historicalData_vulnerable[query.paramId] row.\n        ParameterDataEntry requestedData = g_historicalData_vulnerable[query.paramId][query.recordIndex];\n        automotiveLog_vulnerable(\"Historical data retrieved (vulnerable).\");\n        // In a real system, requestedData would be sent back or processed, potentially exposing stale/uninitialized memory.\n    } else {\n        automotiveLog_vulnerable(\"Invalid parameter ID received (vulnerable).\");\n    }\n}\n\nvoid automotiveMain_vulnerable() {\n    initializeHistoricalData_vulnerable();\n    processDiagnosticQuery_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SENSOR_READING_BUFFER_SIZE 256\n#define MAX_SENSOR_VALUE 4095\n\ntypedef struct {\n    uint16_t value;\n    uint32_t timestamp;\n    uint8_t sensor_id;\n    bool valid;\n} SensorReading;\n\nstatic SensorReading g_sensor_data_buffer[SENSOR_READING_BUFFER_SIZE];\nstatic uint16_t g_write_head_idx = 0; \nstatic bool g_buffer_wrapped = false; \n\nvoid initSensorBuffer() {\n    for (int i = 0; i < SENSOR_READING_BUFFER_SIZE; ++i) {\n        memset(&g_sensor_data_buffer[i], 0, sizeof(SensorReading));\n        g_sensor_data_buffer[i].valid = false;\n    }\n    g_write_head_idx = 0;\n    g_buffer_wrapped = false;\n}\n\nvoid addSensorReading(uint16_t value, uint8_t sensor_id, uint32_t timestamp) {\n    g_sensor_data_buffer[g_write_head_idx].value = value;\n    g_sensor_data_buffer[g_write_head_idx].timestamp = timestamp;\n    g_sensor_data_buffer[g_write_head_idx].sensor_id = sensor_id;\n    g_sensor_data_buffer[g_write_head_idx].valid = true;\n\n    g_write_head_idx++;\n    if (g_write_head_idx >= SENSOR_READING_BUFFER_SIZE) {\n        g_write_head_idx = 0;\n        g_buffer_wrapped = true;\n    }\n}\n\nvoid adjustHistoricalSensorReading_Fixed(int32_t backward_offset_steps, uint16_t new_value) {\n    if (g_write_head_idx == 0 && !g_buffer_wrapped) {\n        return;\n    }\n\n    if (backward_offset_steps < 0) {\n        return;\n    }\n\n    uint16_t last_written_actual_idx;\n    if (g_write_head_idx == 0 && g_buffer_wrapped) {\n        last_written_actual_idx = SENSOR_READING_BUFFER_SIZE - 1;\n    } else if (g_write_head_idx > 0) {\n        last_written_actual_idx = g_write_head_idx - 1;\n    } else {\n        return;\n    }\n\n    uint16_t valid_entries_count = g_buffer_wrapped ? SENSOR_READING_BUFFER_SIZE : g_write_head_idx;\n\n    if (backward_offset_steps >= valid_entries_count) {\n        return;\n    }\n\n    uint16_t target_idx = (last_written_actual_idx - backward_offset_steps + SENSOR_READING_BUFFER_SIZE) % SENSOR_READING_BUFFER_SIZE;\n\n    g_sensor_data_buffer[target_idx].value = new_value;\n    g_sensor_data_buffer[target_idx].valid = true;\n}\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <limits> // For std::numeric_limits\n\n// Represents a single sensor reading record.\nstruct SensorReading {\n    uint32_t timestamp;\n    int16_t  value_x;\n    int16_t  value_y;\n    int16_t  value_z;\n    uint8_t  status_flags;\n    uint8_t  _padding[13]; // Padding to make total size 24 bytes\n};\n\n// Represents a packet received by the vehicle's telemetry system.\nstruct SensorDataPacketHeader {\n    uint16_t packet_id;\n    uint32_t num_readings;\n    uint32_t total_payload_size_bytes;\n};\n\nclass SensorDataCollection {\npublic:\n    SensorDataCollection() : m_readings_buffer(nullptr), m_current_num_readings(0), m_allocated_max_readings(0) {}\n\n    ~SensorDataCollection() {\n        clearData();\n    }\n\n    void clearData() {\n        if (m_readings_buffer) {\n            free(m_readings_buffer);\n            m_readings_buffer = nullptr;\n        }\n        m_current_num_readings = 0;\n        m_allocated_max_readings = 0;\n    }\n\n    bool processSensorDataPacketFixed(const uint8_t* raw_packet, size_t raw_len) {\n        clearData();\n\n        if (!raw_packet || raw_len < sizeof(SensorDataPacketHeader)) {\n            return false;\n        }\n\n        const SensorDataPacketHeader* header = reinterpret_cast<const SensorDataPacketHeader*>(raw_packet);\n\n        // Basic sanity checks for packet header values\n        if (header->packet_id != 0xABCD) {\n            return false;\n        }\n        if (header->num_readings == 0 && header->total_payload_size_bytes > 0) {\n            return false;\n        }\n\n        // FIXED: Prevent integer overflow in allocation size calculation.\n        // Use 'size_t' for calculations to utilize the largest possible integer type for size.\n        // Explicitly check for potential overflow before multiplication.\n        size_t required_total_bytes_for_readings;\n        // Check if `num_readings * sizeof(SensorReading)` would overflow `size_t`.\n        // This indicates an excessive memory request that cannot be safely handled.\n        if (header->num_readings > (std::numeric_limits<size_t>::max() / sizeof(SensorReading))) {\n            return false;\n        }\n        required_total_bytes_for_readings = (size_t)header->num_readings * sizeof(SensorReading);\n        \n        // Additional consistency check: Ensure the advertised total_payload_size_bytes\n        // matches the calculated size based on 'num_readings' and 'sizeof(SensorReading)'.\n        // This catches malformed packets where these two fields are inconsistent.\n        if (required_total_bytes_for_readings != header->total_payload_size_bytes && header->num_readings > 0) {\n            return false;\n        }\n\n        // Critical check: Ensure the source packet actually contains enough data for all readings.\n        // This prevents reading out-of-bounds from the source 'raw_packet'.\n        if (raw_len < sizeof(SensorDataPacketHeader) + required_total_bytes_for_readings) {\n            return false;\n        }\n        \n        // Handle zero-allocation case explicitly.\n        if (required_total_bytes_for_readings == 0) {\n            // No readings, nothing to process/allocate. If num_readings > 0 but size is 0, it's an error.\n            return header->num_readings == 0;\n        }\n\n        m_readings_buffer = (SensorReading*)malloc(required_total_bytes_for_readings);\n        if (!m_readings_buffer) {\n            return false; // Allocation failed\n        }\n        // m_allocated_max_readings is now correctly set based on the truly allocated memory.\n        m_allocated_max_readings = required_total_bytes_for_readings / sizeof(SensorReading);\n        m_current_num_readings = 0;\n\n        size_t current_packet_read_offset = sizeof(SensorDataPacketHeader);\n\n        for (uint32_t i = 0; i < header->num_readings; ++i) {\n            // Explicit bounds check on the destination buffer.\n            // This check is now effective because 'm_allocated_max_readings' is correctly calculated,\n            // preventing writes beyond the allocated heap memory.\n            if (i >= m_allocated_max_readings) {\n                // This condition should ideally not be met if previous checks are sufficient.\n                // It acts as a robust final safeguard.\n                clearData();\n                return false;\n            }\n            \n            // Source buffer bounds check (redundant with earlier check, but good for robustness)\n            if (current_packet_read_offset > (std::numeric_limits<size_t>::max() - sizeof(SensorReading)) ||\n                current_packet_read_offset + sizeof(SensorReading) > raw_len) {\n                clearData();\n                return false;\n            }\n\n            m_readings_buffer[i] = *reinterpret_cast<const SensorReading*>(raw_packet + current_packet_read_offset);\n\n            m_current_num_readings++;\n            current_packet_read_offset += sizeof(SensorReading);\n        }\n        \n        // Final consistency check (ensures all advertised readings were processed and written).\n        if (m_current_num_readings != header->num_readings) {\n            clearData();\n            return false;\n        }\n\n        return true;\n    }\n\nprivate:\n    SensorReading* m_readings_buffer;\n    size_t m_current_num_readings;\n    size_t m_allocated_max_readings;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define NUM_SUB_MODULES 3\n#define MAX_ENGINE_PARAMS 20\n#define MAX_TRANSMISSION_PARAMS 10\n#define MAX_INFOTAINMENT_PARAMS 5\n\ntypedef enum {\n    SUB_MODULE_ENGINE = 0,\n    SUB_MODULE_TRANSMISSION,\n    SUB_MODULE_INFOTAINMENT,\n    SUB_MODULE_INVALID\n} SubModuleID;\n\ntypedef struct {\n    SubModuleID module_id;\n    uint8_t     parameter_index;\n    uint32_t    new_value;\n    uint8_t     command_type;\n} DiagnosticCommand_Fixed;\n\nstatic uint32_t g_engineParameters_fixed[MAX_ENGINE_PARAMS];\nstatic uint32_t g_transmissionParameters_fixed[MAX_TRANSMISSION_PARAMS];\nstatic uint32_t g_infotainmentParameters_fixed[MAX_INFOTAINMENT_PARAMS];\n\nstatic uint32_t* g_moduleParameterArrays_fixed[NUM_SUB_MODULES] = {\n    g_engineParameters_fixed,\n    g_transmissionParameters_fixed,\n    g_infotainmentParameters_fixed\n};\n\nstatic const uint8_t g_moduleParameterSizes_fixed[NUM_SUB_MODULES] = {\n    MAX_ENGINE_PARAMS,\n    MAX_TRANSMISSION_PARAMS,\n    MAX_INFOTAINMENT_PARAMS\n};\n\nvoid logDiagnosticError_fixed(const char* msg) {\n}\n\nDiagnosticCommand_Fixed receiveDiagnosticCommand_fixed() {\n    DiagnosticCommand_Fixed cmd;\n    cmd.module_id = SUB_MODULE_TRANSMISSION; \n    cmd.parameter_index = 15; \n    cmd.new_value = 0xDEADBEEF;\n    cmd.command_type = 0x02;\n    return cmd;\n}\n\nvoid initializeSystemParameters_fixed() {\n    for (int i = 0; i < MAX_ENGINE_PARAMS; ++i) g_engineParameters_fixed[i] = i;\n    for (int i = 0; i < MAX_TRANSMISSION_PARAMS; ++i) g_transmissionParameters_fixed[i] = i + 100;\n    for (int i = 0; i < MAX_INFOTAINMENT_PARAMS; ++i) g_infotainmentParameters_fixed[i] = i + 200;\n}\n\nvoid processDiagnosticCommand_fixed() {\n    DiagnosticCommand_Fixed cmd = receiveDiagnosticCommand_fixed();\n\n    if (cmd.module_id < NUM_SUB_MODULES) {\n        uint32_t* target_array = g_moduleParameterArrays_fixed[cmd.module_id];\n        uint8_t max_index = g_moduleParameterSizes_fixed[cmd.module_id]; \n\n        if (cmd.parameter_index < max_index) { \n            if (cmd.command_type == 0x02) {\n                target_array[cmd.parameter_index] = cmd.new_value;\n                logDiagnosticError_fixed(\"Parameter update processed successfully.\");\n            } else if (cmd.command_type == 0x01) {\n                uint32_t value = target_array[cmd.parameter_index];\n                logDiagnosticError_fixed(\"Parameter read processed successfully.\");\n            } else {\n                logDiagnosticError_fixed(\"Unknown command type.\");\n            }\n        } else {\n            logDiagnosticError_fixed(\"Parameter index out of bounds for selected sub-module. Command ignored.\");\n        }\n    } else {\n        logDiagnosticError_fixed(\"Invalid sub-module ID received.\");\n    }\n}\n\nvoid main_fixed() {\n    initializeSystemParameters_fixed();\n    processDiagnosticCommand_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_BATTERY_MODULES 4\n#define CELLS_PER_MODULE 12\n#define TOTAL_BATTERY_CELLS (MAX_BATTERY_MODULES * CELLS_PER_MODULE)\n\n#define BMS_CMD_UPDATE_CELL_DATA 0x01\n\ntypedef struct {\n    uint16_t voltage_mV;\n    int8_t   temperature_C;\n    uint8_t  charge_status_percent;\n    bool     fault_active;\n} BatteryCell_Fixed;\n\nstatic BatteryCell_Fixed g_batteryCells_fixed[TOTAL_BATTERY_CELLS];\n\ntypedef struct {\n    uint8_t command_type;\n    uint8_t module_id;\n    uint8_t cell_in_module_id;\n    uint16_t voltage_mV;\n    int8_t   temperature_C;\n    uint8_t  charge_status_percent;\n} CellUpdateCommand_Fixed;\n\nvoid logBMS_fixed(const char* msg) {\n}\n\nCellUpdateCommand_Fixed receiveCellUpdateCommand_fixed() {\n    CellUpdateCommand_Fixed cmd;\n    cmd.command_type = BMS_CMD_UPDATE_CELL_DATA;\n    cmd.module_id = MAX_BATTERY_MODULES; \n    cmd.cell_in_module_id = 0;\n    cmd.voltage_mV = 3800;\n    cmd.temperature_C = 25;\n    cmd.charge_status_percent = 85;\n    return cmd;\n}\n\nvoid initializeBMS_fixed() {\n    for (int i = 0; i < TOTAL_BATTERY_CELLS; ++i) {\n        g_batteryCells_fixed[i] = (BatteryCell_Fixed){3700, 20, 70, false};\n    }\n}\n\nvoid processCellUpdate_fixed() {\n    CellUpdateCommand_Fixed cmd = receiveCellUpdateCommand_fixed();\n\n    if (cmd.command_type == BMS_CMD_UPDATE_CELL_DATA) {\n        if (cmd.module_id < MAX_BATTERY_MODULES && cmd.cell_in_module_id < CELLS_PER_MODULE) {\n            int absolute_cell_idx = cmd.module_id * CELLS_PER_MODULE + cmd.cell_in_module_id;\n\n            g_batteryCells_fixed[absolute_cell_idx].voltage_mV = cmd.voltage_mV;\n            g_batteryCells_fixed[absolute_cell_idx].temperature_C = cmd.temperature_C;\n            g_batteryCells_fixed[absolute_cell_idx].charge_status_percent = cmd.charge_status_percent;\n            logBMS_fixed(\"Battery cell data updated successfully.\");\n        } else {\n            logBMS_fixed(\"Invalid module ID or cell ID in command. Ignoring update.\");\n        }\n    } else {\n        logBMS_fixed(\"Unknown BMS command received.\");\n    }\n}\n\nvoid bmsMainLoop_fixed() {\n    initializeBMS_fixed();\n    processCellUpdate_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_TRANSPORT_BUFFER_SIZE 128\n#define FIRMWARE_SEGMENT_PAYLOAD_BUFFER_SIZE 10\n\ntypedef struct {\n    uint16_t address;\n    uint8_t  data_length;\n    uint8_t  payload[FIRMWARE_SEGMENT_PAYLOAD_BUFFER_SIZE];\n    uint16_t checksum;\n} FirmwareSegment;\n\nvoid initFirmwareStorage() {\n    \n}\n\nint deserializeFirmwareSegment_Fixed(const uint8_t* raw_buffer, uint16_t buffer_len, FirmwareSegment* out_segment) {\n    if (raw_buffer == NULL || out_segment == NULL || buffer_len < (sizeof(uint16_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    out_segment->address = (raw_buffer[current_offset] << 8) | raw_buffer[current_offset + 1];\n    current_offset += sizeof(uint16_t);\n\n    out_segment->data_length = raw_buffer[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    if (current_offset + out_segment->data_length > buffer_len) {\n        return -2;\n    }\n\n    uint8_t bytes_to_copy = out_segment->data_length;\n    if (bytes_to_copy > FIRMWARE_SEGMENT_PAYLOAD_BUFFER_SIZE) {\n        bytes_to_copy = FIRMWARE_SEGMENT_PAYLOAD_BUFFER_SIZE;\n    }\n\n    for (uint8_t i = 0; i < bytes_to_copy; ++i) {\n        out_segment->payload[i] = raw_buffer[current_offset + i];\n    }\n\n    if (bytes_to_copy < FIRMWARE_SEGMENT_PAYLOAD_BUFFER_SIZE) {\n        memset(out_segment->payload + bytes_to_copy, 0, FIRMWARE_SEGMENT_PAYLOAD_BUFFER_SIZE - bytes_to_copy);\n    }\n\n    out_segment->checksum = 0;\n\n    return 0;\n}\n\nvoid handleIncomingFirmwarePacket_Fixed(const uint8_t* packet_data, uint16_t packet_len) {\n    FirmwareSegment segment;\n    deserializeFirmwareSegment_Fixed(packet_data, packet_len, &segment);\n}\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n\nstruct DTC_Entry {\n    uint32_t code;\n    uint16_t status_flags;\n    uint8_t  occurrence_count;\n    char     reserved[5];\n};\n\nstruct DiagnosticPacketHeader {\n    uint16_t packet_id;\n    uint16_t num_dtc_entries;\n    uint32_t payload_data_bytes;\n};\n\nclass VehicleDiagnosticLoggerVulnerable {\npublic:\n    VehicleDiagnosticLoggerVulnerable() : m_dtc_buffer(nullptr), m_buffer_capacity(0), m_actual_dtc_count(0) {}\n\n    ~VehicleDiagnosticLoggerVulnerable() {\n        if (m_dtc_buffer) {\n            delete[] m_dtc_buffer;\n            m_dtc_buffer = nullptr;\n        }\n    }\n\n    bool processDiagnosticPacketVulnerable(const uint8_t* raw_packet_data, size_t packet_data_len) {\n        if (!raw_packet_data || packet_data_len < sizeof(DiagnosticPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeader* header = reinterpret_cast<const DiagnosticPacketHeader*>(raw_packet_data);\n\n        if (packet_data_len < sizeof(DiagnosticPacketHeader) + header->payload_data_bytes) {\n            return false;\n        }\n\n        if (m_dtc_buffer) {\n            delete[] m_dtc_buffer;\n            m_dtc_buffer = nullptr;\n            m_buffer_capacity = 0;\n            m_actual_dtc_count = 0;\n        }\n\n        m_buffer_capacity = header->num_dtc_entries;\n        if (m_buffer_capacity == 0) {\n            return true;\n        }\n        \n        if (m_buffer_capacity > (SIZE_MAX / sizeof(DTC_Entry))) {\n            return false;\n        }\n\n        m_dtc_buffer = new (std::nothrow) DTC_Entry[m_buffer_capacity];\n        if (!m_dtc_buffer) {\n            return false;\n        }\n\n        const uint8_t* current_payload_ptr = raw_packet_data + sizeof(DiagnosticPacketHeader);\n        size_t current_payload_offset = 0;\n        uint16_t dtc_processed_count = 0;\n\n        while (current_payload_offset + sizeof(DTC_Entry) <= header->payload_data_bytes) {\n            \n            if (current_payload_ptr + current_payload_offset + sizeof(DTC_Entry) > raw_packet_data + packet_data_len) {\n                delete[] m_dtc_buffer;\n                m_dtc_buffer = nullptr;\n                m_buffer_capacity = 0;\n                m_actual_dtc_count = 0;\n                return false;\n            }\n\n            const DTC_Entry* incoming_dtc = reinterpret_cast<const DTC_Entry*>(current_payload_ptr + current_payload_offset);\n            \n            m_dtc_buffer[dtc_processed_count].code = incoming_dtc->code;\n            m_dtc_buffer[dtc_processed_count].status_flags = incoming_dtc->status_flags;\n            m_dtc_buffer[dtc_processed_count].occurrence_count = incoming_dtc->occurrence_count;\n            std::memcpy(m_dtc_buffer[dtc_processed_count].reserved, incoming_dtc->reserved, sizeof(incoming_dtc->reserved));\n\n            current_payload_offset += sizeof(DTC_Entry);\n            dtc_processed_count++;\n        }\n\n        m_actual_dtc_count = dtc_processed_count;\n\n        return true;\n    }\n\n    const DTC_Entry* getDTCBuffer() const { return m_dtc_buffer; }\n    uint16_t getBufferCapacity() const { return m_buffer_capacity; }\n    uint16_t getActualDTCCount() const { return m_actual_dtc_count; }\n\nprivate:\n    DTC_Entry* m_dtc_buffer;\n    uint16_t   m_buffer_capacity;\n    uint16_t   m_actual_dtc_count;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_FILE_SIZE 2048\n#define ECU_CONFIG_BUFFER_SIZE 256\n#define PARAMETER_BLOCK_SIZE 64 // Fixed size for processing parameters within a section\n\n// Global buffer holding the raw configuration data for an ECU\nstatic uint8_t g_ecuConfigData[ECU_CONFIG_BUFFER_SIZE];\n\n// Simulates a header for a configuration section within the main config file\ntypedef struct {\n    uint16_t section_id;\n    uint16_t section_length; // Total length of this section including this header\n    uint16_t num_parameters;\n} ConfigSectionHeader;\n\n// Function to process a specific configuration section from a larger config stream\n// raw_config_stream: Pointer to the start of the configuration section\n// stream_available_len: Total bytes available from raw_config_stream until end of message/file\nint processEcuConfigSection(const uint8_t* raw_config_stream, uint16_t stream_available_len) {\n    if (raw_config_stream == NULL || stream_available_len < sizeof(ConfigSectionHeader)) {\n        return -1; // Invalid input\n    }\n\n    const ConfigSectionHeader* header = (const ConfigSectionHeader*)raw_config_stream;\n\n    // Validate overall section length from the header against the available stream length.\n    if (header->section_length > stream_available_len || header->section_length < sizeof(ConfigSectionHeader)) {\n        return -2; // Section length inconsistent with available stream or too small\n    }\n\n    uint16_t data_offset = sizeof(ConfigSectionHeader); // Offset to the actual data within the section\n\n    // Calculate the length of the raw parameter data block within this section.\n    // This length is determined by the total section length declared in the header.\n    uint16_t raw_parameter_data_len = header->section_length - data_offset;\n\n    uint8_t temp_param_block[PARAMETER_BLOCK_SIZE]; // Fixed-size buffer for processing a parameter block\n\n    if (raw_parameter_data_len > 0) {\n        // FIX: Add a bounds check to ensure the data to be copied fits within 'temp_param_block'.\n        // If 'raw_parameter_data_len' exceeds PARAMETER_BLOCK_SIZE, truncate it to prevent overflow.\n        uint16_t bytes_to_copy_to_temp = raw_parameter_data_len;\n        if (bytes_to_copy_to_temp > PARAMETER_BLOCK_SIZE) {\n            bytes_to_copy_to_temp = PARAMETER_BLOCK_SIZE; // Truncate to fit the temporary buffer\n            // Optionally, return an error or log a warning if data is truncated, depending on requirements.\n        }\n\n        memcpy(temp_param_block, raw_config_stream + data_offset, bytes_to_copy_to_temp);\n\n        // Simulate further processing on temp_param_block, then copy to global ECU config.\n        // Ensure the data copied from temp_param_block to g_ecuConfigData also respects its bounds.\n        if (bytes_to_copy_to_temp <= ECU_CONFIG_BUFFER_SIZE) {\n             memcpy(g_ecuConfigData, temp_param_block, bytes_to_copy_to_temp);\n        } else {\n            // This case should ideally not be reached if PARAMETER_BLOCK_SIZE <= ECU_CONFIG_BUFFER_SIZE\n            // and the logic is consistent, but kept for robustness.\n            return -3; // Parameter data too large for global ECU_CONFIG_BUFFER_SIZE (after truncation)\n        }\n    }\n\n    // Simulate further processing based on parameters if needed\n\n    return 0; // Success\n}\n\n// Dummy function to simulate receiving a configuration update from a vehicle network.\nvoid receiveConfigUpdate(const uint8_t* full_config_msg, uint16_t msg_len) {\n    processEcuConfigSection(full_config_msg, msg_len);\n}\n\n// Function to retrieve a config value for testing/demonstration.\nuint8_t getEcuConfigByte(uint16_t index) {\n    if (index < ECU_CONFIG_BUFFER_SIZE) {\n        return g_ecuConfigData[index];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define NUM_SUBSYSTEM_LOGGERS 3\n#define MAX_EVENTS_ENGINE 10\n#define MAX_EVENTS_TRANSMISSION 5\n#define MAX_EVENTS_ABS 8\n\ntypedef struct {\n    uint32_t event_id;\n    uint32_t timestamp;\n    uint8_t  severity;\n} DiagnosticEvent;\n\ntypedef enum {\n    SUBSYSTEM_ENGINE = 0,\n    SUBSYSTEM_TRANSMISSION,\n    SUBSYSTEM_ABS,\n    SUBSYSTEM_COUNT\n} SubsystemType;\n\nstatic DiagnosticEvent g_engineEvents[MAX_EVENTS_ENGINE];\nstatic DiagnosticEvent g_transmissionEvents[MAX_EVENTS_TRANSMISSION];\nstatic DiagnosticEvent g_absEvents[MAX_EVENTS_ABS];\n\ntypedef struct {\n    DiagnosticEvent* buffer;\n    uint8_t  current_count;\n    uint8_t  max_size;\n} SubsystemLoggerConfig;\n\nstatic SubsystemLoggerConfig g_subsystemLoggers[SUBSYSTEM_COUNT];\n\nvoid logSystemNotification(const char* msg) {\n}\n\nvoid initializeLoggers_vulnerable() {\n    g_subsystemLoggers[SUBSYSTEM_ENGINE].buffer = g_engineEvents;\n    g_subsystemLoggers[SUBSYSTEM_ENGINE].max_size = MAX_EVENTS_ENGINE;\n    g_subsystemLoggers[SUBSYSTEM_ENGINE].current_count = 0;\n\n    g_subsystemLoggers[SUBSYSTEM_TRANSMISSION].buffer = g_transmissionEvents;\n    g_subsystemLoggers[SUBSYSTEM_TRANSMISSION].max_size = MAX_EVENTS_TRANSMISSION;\n    g_subsystemLoggers[SUBSYSTEM_TRANSMISSION].current_count = 0;\n\n    g_subsystemLoggers[SUBSYSTEM_ABS].buffer = g_absEvents;\n    g_subsystemLoggers[SUBSYSTEM_ABS].max_size = MAX_EVENTS_ABS;\n    g_subsystemLoggers[SUBSYSTEM_ABS].current_count = 0;\n}\n\ntypedef struct {\n    SubsystemType subsystem;\n    DiagnosticEvent event_data;\n} NewDiagnosticEvent_vulnerable;\n\nvoid processAndLogDiagnosticEvent_vulnerable(NewDiagnosticEvent_vulnerable received_event) {\n    if (received_event.subsystem < SUBSYSTEM_COUNT) {\n        SubsystemLoggerConfig* logger = &g_subsystemLoggers[received_event.subsystem];\n\n        logger->buffer[logger->current_count] = received_event.event_data;\n        logger->current_count++;\n        logSystemNotification(\"Diagnostic event added to log.\");\n    } else {\n        logSystemNotification(\"Received event for invalid subsystem type.\");\n    n}\n}\n\nvoid diagnosticMonitorLoop_vulnerable() {\n    initializeLoggers_vulnerable();\n\n    for (int i = 0; i <= MAX_EVENTS_TRANSMISSION; ++i) {\n        NewDiagnosticEvent_vulnerable event_to_process;\n        event_to_process.subsystem = SUBSYSTEM_TRANSMISSION;\n        event_to_process.event_data.event_id = 0xA000 + i;\n        event_to_process.event_data.timestamp = 1000 + i;\n        event_to_process.event_data.severity = (uint8_t)(i % 4 + 1);\n        processAndLogDiagnosticEvent_vulnerable(event_to_process);\n    }\n\n    NewDiagnosticEvent_vulnerable engine_event;\n    engine_event.subsystem = SUBSYSTEM_ENGINE;\n    engine_event.event_data.event_id = 0xB001;\n    engine_event.event_data.timestamp = 2000;\n    engine_event.event_data.severity = 3;\n    processAndLogDiagnosticEvent_vulnerable(engine_event);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define CONFIG_STORAGE_BUFFER_SIZE 256\n#define MAX_CONFIG_PACKET_SIZE 128\n#define MAX_SUPPORTED_VALUE_LENGTH 64\n\ntypedef struct {\n    uint8_t key_id;\n    uint8_t value_type;\n    uint8_t value_length;\n} ConfigEntryHeader;\n\nstatic uint8_t g_configStorageBuffer[CONFIG_STORAGE_BUFFER_SIZE];\nstatic uint16_t g_currentStorageOffset = 0;\n\nvoid initConfigManager() {\n    memset(g_configStorageBuffer, 0, CONFIG_STORAGE_BUFFER_SIZE);\n    g_currentStorageOffset = 0;\n}\n\nint applyConfigUpdate(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len == 0 || packet_len > MAX_CONFIG_PACKET_SIZE) {\n        return -1;\n    }\n\n    uint16_t packet_parse_offset = 0;\n\n    while (packet_parse_offset < packet_len) {\n        if (packet_parse_offset + sizeof(ConfigEntryHeader) > packet_len) {\n            return -2;\n        }\n\n        const ConfigEntryHeader* current_header = (const ConfigEntryHeader*)(packet + packet_parse_offset);\n        uint8_t entry_value_len = current_header->value_length;\n\n        if (entry_value_len > MAX_SUPPORTED_VALUE_LENGTH) {\n            return -3;\n        }\n\n        if (packet_parse_offset + sizeof(ConfigEntryHeader) + entry_value_len > packet_len) {\n            return -4;\n        }\n\n        for (uint8_t i = 0; i < entry_value_len; ++i) {\n            g_configStorageBuffer[g_currentStorageOffset + i] = packet[packet_parse_offset + sizeof(ConfigEntryHeader) + i];\n        }\n\n        g_currentStorageOffset += entry_value_len;\n        packet_parse_offset += sizeof(ConfigEntryHeader) + entry_value_len;\n    }\n\n    return 0;\n}\n\nuint8_t getConfigByte(uint16_t offset) {\n    if (offset < CONFIG_STORAGE_BUFFER_SIZE) {\n        return g_configStorageBuffer[offset];\n    }\n    return 0xFF;\n}\n\nvoid simulateIncomingConfigPacket(const uint8_t* data, uint16_t len) {\n    applyConfigUpdate(data, len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <new>\n\nstruct ProcessedTelemetryData {\n    uint32_t timestamp;\n    int32_t  engine_rpm;\n    int16_t  vehicle_speed;\n    uint8_t  gear_position;\n    bool     is_engine_on;\n};\n\nstruct RawTelemetryPacketHeader {\n    uint16_t packet_type;\n    uint16_t num_readings;\n    uint32_t total_payload_bytes;\n};\n\nclass TelemetryDataManager {\npublic:\n    TelemetryDataManager() : data_buffer(nullptr), buffer_capacity(0), current_data_count(0) {}\n\n    ~TelemetryDataManager() {\n        if (data_buffer) {\n            delete[] data_buffer;\n            data_buffer = nullptr;\n        }\n    }\n\n    bool processRawTelemetryPacketVulnerable(const uint8_t* raw_packet, size_t raw_packet_len) {\n        if (!raw_packet || raw_packet_len < sizeof(RawTelemetryPacketHeader)) {\n            return false;\n        }\n\n        const RawTelemetryPacketHeader* header = reinterpret_cast<const RawTelemetryPacketHeader*>(raw_packet);\n\n        if (static_cast<size_t>(header->total_payload_bytes) > (raw_packet_len - sizeof(RawTelemetryPacketHeader))) {\n            return false;\n        }\n\n        if (data_buffer) {\n            delete[] data_buffer;\n            data_buffer = nullptr;\n        }\n\n        buffer_capacity = header->num_readings;\n        data_buffer = new (std::nothrow) ProcessedTelemetryData[buffer_capacity];\n        if (!data_buffer) {\n            return false;\n        }\n\n        const uint8_t* payload_start = raw_packet + sizeof(RawTelemetryPacketHeader);\n        size_t bytes_to_copy = static_cast<size_t>(header->total_payload_bytes);\n\n        for (size_t i = 0; i < bytes_to_copy; ++i) {\n            reinterpret_cast<uint8_t*>(data_buffer)[i] = payload_start[i];\n        }\n\n        current_data_count = header->num_readings;\n\n        return true;\n    }\n\n    const ProcessedTelemetryData* getTelemetryData() const { return data_buffer; }\n    uint16_t getTelemetryCount() const { return current_data_count; }\n\nprivate:\n    ProcessedTelemetryData* data_buffer;\n    uint16_t                buffer_capacity;\n    uint16_t                current_data_count;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CALIBRATION_SIZE 512\n#define MAX_PROTOCOL_DATA_LENGTH 128\n#define MAX_PACKET_PROCESS_SIZE 64\n\nstatic uint8_t g_calibrationTable[MAX_CALIBRATION_SIZE];\nstatic uint8_t g_packetProcessingBuffer[MAX_PACKET_PROCESS_SIZE];\n\nvoid initCalibrationSystem() {\n    memset(g_calibrationTable, 0xFF, MAX_CALIBRATION_SIZE);\n    memset(g_packetProcessingBuffer, 0x00, MAX_PACKET_PROCESS_SIZE);\n}\n\ntypedef struct {\n    uint16_t table_id;\n    uint16_t start_offset;\n    uint8_t  data_len;\n    const uint8_t* payload;\n} CalibrationUpdateCommand;\n\nint processCalibrationUpdate(const CalibrationUpdateCommand* cmd) {\n    if (cmd == NULL || cmd->payload == NULL) {\n        return -1;\n    }\n\n    if (cmd->table_id != 0) {\n        return -2;\n    }\n\n    if (cmd->data_len > MAX_PROTOCOL_DATA_LENGTH || cmd->data_len == 0) {\n        return -3;\n    }\n\n    if (cmd->start_offset + cmd->data_len > MAX_CALIBRATION_SIZE) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < cmd->data_len; ++i) {\n        g_packetProcessingBuffer[i] = cmd->payload[i];\n    }\n\n    for (uint8_t i = 0; i < cmd->data_len; ++i) {\n        g_calibrationTable[cmd->start_offset + i] = g_packetProcessingBuffer[i];\n    }\n\n    return 0;\n}\n\nint receiveAndProcessCalibrationMessage(uint16_t table_id, uint16_t offset, uint8_t len, const uint8_t* data) {\n    CalibrationUpdateCommand cmd;\n    cmd.table_id = table_id;\n    cmd.start_offset = offset;\n    cmd.data_len = len;\n    cmd.payload = data;\n    return processCalibrationUpdate(&cmd);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdlib.h>\n\n#define CHUNK_SIZE_BYTES 64\n\ntypedef struct {\n    uint32_t block_id;\n    uint32_t num_chunks; \n    uint32_t reserved; \n} DataBlockHeader;\n\nclass FirmwareUpdaterVulnerable {\npublic:\n    FirmwareUpdaterVulnerable() : firmware_buffer(nullptr), current_buffer_size(0) {}\n\n    ~FirmwareUpdaterVulnerable() {\n        if (firmware_buffer) {\n            free(firmware_buffer);\n            firmware_buffer = nullptr;\n        }\n    }\n\n    bool processFirmwareBlockVulnerable(const uint8_t* block_data, size_t data_len) {\n        if (!block_data || data_len < sizeof(DataBlockHeader)) {\n            return false;\n        }\n\n        const DataBlockHeader* header = reinterpret_cast<const DataBlockHeader*>(block_data);\n        uint32_t num_chunks = header->num_chunks;\n\n        uint32_t total_payload_size = num_chunks * CHUNK_SIZE_BYTES;\n\n        if (data_len < sizeof(DataBlockHeader) + total_payload_size) {\n            return false;\n        }\n\n        if (firmware_buffer) {\n            free(firmware_buffer);\n            firmware_buffer = nullptr;\n        }\n\n        firmware_buffer = (uint8_t*)malloc(total_payload_size);\n        if (!firmware_buffer) {\n            return false;\n        }\n        current_buffer_size = total_payload_size;\n\n        const uint8_t* source_data_ptr = block_data + sizeof(DataBlockHeader);\n        for (uint32_t i = 0; i < total_payload_size; ++i) {\n            firmware_buffer[i] = source_data_ptr[i];\n        }\n\n        return true;\n    }\n\n    const uint8_t* getFirmwareBuffer() const { return firmware_buffer; }\n    size_t getBufferSize() const { return current_buffer_size; }\n\nprivate:\n    uint8_t* firmware_buffer;\n    size_t current_buffer_size;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_TELEMETRY_BUFFER_SIZE 1024\n#define EVENT_BLOCK_SIZE 32\n\nstatic uint8_t g_telemetry_buffer_fixed[MAX_TELEMETRY_BUFFER_SIZE];\nstatic int32_t g_active_event_start_offset_fixed = 0;\n\nvoid init_telemetry_system_fixed() {\n    memset(g_telemetry_buffer_fixed, 0, MAX_TELEMETRY_BUFFER_SIZE);\n    g_active_event_start_offset_fixed = 0;\n}\n\nbool log_telemetry_event_fixed(const uint8_t* event_data) {\n    static uint32_t current_write_pos_fixed = 0;\n\n    if (current_write_pos_fixed + EVENT_BLOCK_SIZE > MAX_TELEMETRY_BUFFER_SIZE) {\n        current_write_pos_fixed = 0;\n    }\n\n    memcpy(g_telemetry_buffer_fixed + current_write_pos_fixed, event_data, EVENT_BLOCK_SIZE);\n    \n    current_write_pos_fixed += EVENT_BLOCK_SIZE;\n    return true;\n}\n\nvoid process_telemetry_block_at_offset_fixed(int32_t offset) {\n    if (offset < 0 || offset + EVENT_BLOCK_SIZE > MAX_TELEMETRY_BUFFER_SIZE) {\n        return;\n    }\n    volatile uint32_t timestamp_ms = *(uint32_t*)(g_telemetry_buffer_fixed + offset);\n    (void)timestamp_ms;\n}\n\nvoid shift_telemetry_pointer_backward_fixed(uint16_t blocks_to_shift) {\n    if (blocks_to_shift == 0) {\n        return;\n    }\n\n    int32_t new_offset = g_active_event_start_offset_fixed - ((int32_t)blocks_to_shift * EVENT_BLOCK_SIZE);\n\n    if (new_offset < 0) {\n        new_offset = 0;\n    }\n    \n    g_active_event_start_offset_fixed = new_offset;\n\n    if (g_active_event_start_offset_fixed > 0 && g_active_event_start_offset_fixed - 1 >= 0) {\n        g_telemetry_buffer_fixed[g_active_event_start_offset_fixed - 1] = 0xAD;\n    }\n\n    if (g_active_event_start_offset_fixed >= 0 && g_active_event_start_offset_fixed < MAX_TELEMETRY_BUFFER_SIZE) {\n        process_telemetry_block_at_offset_fixed(g_active_event_start_offset_fixed);\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_RESPONSE_BUFFER_SIZE 256\n#define MAX_RAW_DIAG_DATA_LEN 100\n\nstatic uint8_t g_diagResponseBuffer[DIAG_RESPONSE_BUFFER_SIZE];\nstatic uint16_t g_responseWritePos = 0;\n\nvoid initDiagResponseSystem() {\n    memset(g_diagResponseBuffer, 0, DIAG_RESPONSE_BUFFER_SIZE);\n    g_responseWritePos = 0;\n}\n\nint buildDiagnosticResponse(const uint8_t* raw_data, uint16_t raw_data_len) {\n    if (raw_data == NULL || raw_data_len == 0 || raw_data_len > MAX_RAW_DIAG_DATA_LEN) {\n        return -1;\n    }\n\n    g_responseWritePos = 0;\n\n    for (uint16_t i = 0; i < raw_data_len; ++i) {\n        uint8_t current_byte = raw_data[i];\n\n        if (current_byte == 0xCC || current_byte == 0xEE) {\n            if (g_responseWritePos + 3 > DIAG_RESPONSE_BUFFER_SIZE) {\n                return -2;\n            }\n            g_diagResponseBuffer[g_responseWritePos++] = 0x1B;\n            g_diagResponseBuffer[g_responseWritePos++] = 0x01;\n            g_diagResponseBuffer[g_responseWritePos++] = current_byte;\n        } else {\n            if (g_responseWritePos + 1 > DIAG_RESPONSE_BUFFER_SIZE) {\n                return -2;\n            }\n            g_diagResponseBuffer[g_responseWritePos++] = current_byte;\n        }\n    }\n\n    return g_responseWritePos;\n}\n\nvoid sendDiagResponse(const uint8_t* data, uint16_t len) {\n    buildDiagnosticResponse(data, len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_SUPPORTED_SENSOR_TYPES_FIXED 3\n\ntypedef struct {\n    uint32_t processing_flags;\n    int16_t offset_calibration;\n    float gain_calibration;\n    bool enable_filter;\n} SensorProcessingConfig_Fixed;\n\nstatic SensorProcessingConfig_Fixed g_sensorConfigs_fixed[MAX_SUPPORTED_SENSOR_TYPES_FIXED];\n\nvoid system_log_fixed(const char* msg) {\n    fprintf(stdout, \"FIXED_LOG: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t sensor_type_id;\n    uint16_t raw_value;\n    uint32_t timestamp;\n} SensorDataPacket_Fixed;\n\nSensorDataPacket_Fixed getSimulatedSensorData_fixed() {\n    SensorDataPacket_Fixed packet;\n    packet.sensor_type_id = MAX_SUPPORTED_SENSOR_TYPES_FIXED; \n    packet.raw_value = 4096;\n    packet.timestamp = 0x12345678;\n    system_log_fixed(\"Simulated incoming sensor data with potentially malicious sensor_type_id.\");\n    return packet;\n}\n\nvoid initializeSensorConfigurations_fixed() {\n    g_sensorConfigs_fixed[0] = (SensorProcessingConfig_Fixed){.processing_flags = 0x01, .offset_calibration = 10, .gain_calibration = 1.0, .enable_filter = true};\n    g_sensorConfigs_fixed[1] = (SensorProcessingConfig_Fixed){.processing_flags = 0x02, .offset_calibration = 5, .gain_calibration = 0.9, .enable_filter = false};\n    g_sensorConfigs_fixed[2] = (SensorProcessingConfig_Fixed){.processing_flags = 0x04, .offset_calibration = 0, .gain_calibration = 1.1, .enable_filter = true};\n    system_log_fixed(\"Sensor configurations initialized.\");\n}\n\nvoid processSensorData_fixed() {\n    SensorDataPacket_Fixed packet = getSimulatedSensorData_fixed();\n\n    if (packet.sensor_type_id < MAX_SUPPORTED_SENSOR_TYPES_FIXED) {\n        SensorProcessingConfig_Fixed current_config = g_sensorConfigs_fixed[packet.sensor_type_id];\n\n        float processed_value = (float)packet.raw_value * current_config.gain_calibration + current_config.offset_calibration;\n        system_log_fixed(\"Sensor data processed (fixed).\");\n    } else {\n        system_log_fixed(\"ERROR: Invalid sensor type ID received. Ignoring data.\");\n    }\n}\n\nvoid automotiveSensorProcessingModule_fixed() {\n    initializeSensorConfigurations_fixed();\n    processSensorData_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_TOTAL_LOG_ENTRIES 200\n\ntypedef struct {\n    uint8_t event_id;\n    uint16_t data_value;\n    uint32_t timestamp;\n} LogEntry;\n\nstatic LogEntry g_vehicleEventLog_fixed[MAX_TOTAL_LOG_ENTRIES];\n\ntypedef enum {\n    DOMAIN_POWERTRAIN_FIXED = 0,\n    DOMAIN_CHASSIS_FIXED,\n    DOMAIN_BODY_FIXED,\n    DOMAIN_INFOTAINMENT_FIXED,\n    DOMAIN_COUNT_FIXED\n} VehicleDomainType_Fixed;\n\nstatic const size_t g_domainOffsets_fixed[DOMAIN_COUNT_FIXED] = {\n    0,\n    50,\n    100,\n    150\n};\n\nstatic const size_t g_domainMaxEntries_fixed[DOMAIN_COUNT_FIXED] = {\n    50, 50, 50, 50\n};\n\nstatic size_t g_domainCurrentRelativeIndex_fixed[DOMAIN_COUNT_FIXED];\n\nvoid logSystemCriticalEvent_fixed(const char* msg) {\n}\n\nvoid initVehicleLogSystem_fixed() {\n    for (int i = 0; i < DOMAIN_COUNT_FIXED; ++i) {\n        g_domainCurrentRelativeIndex_fixed[i] = 0;\n    }\n    for (int i = 0; i < MAX_TOTAL_LOG_ENTRIES; ++i) {\n        g_vehicleEventLog_fixed[i] = (LogEntry){0, 0, 0};\n    }\n    logSystemCriticalEvent_fixed(\"Vehicle log system initialized (fixed).\");\n}\n\nvoid logVehicleDomainEvent_fixed(VehicleDomainType_Fixed domain, uint8_t event_id, uint16_t data_value, uint32_t timestamp) {\n    if (domain >= DOMAIN_COUNT_FIXED) {\n        logSystemCriticalEvent_fixed(\"Attempted to log event for invalid domain (fixed).\");\n        return;\n    }\n\n    size_t target_relative_idx = g_domainCurrentRelativeIndex_fixed[domain];\n\n    g_domainCurrentRelativeIndex_fixed[domain] = (g_domainCurrentRelativeIndex_fixed[domain] + 1) % g_domainMaxEntries_fixed[domain];\n\n    size_t global_target_idx = g_domainOffsets_fixed[domain] + target_relative_idx;\n\n    if (global_target_idx >= MAX_TOTAL_LOG_ENTRIES) {\n        logSystemCriticalEvent_fixed(\"Internal error: Calculated global index out of total bounds. Report this bug.\");\n        return;\n    }\n\n    g_vehicleEventLog_fixed[global_target_idx] = (LogEntry){event_id, data_value, timestamp};\n}\n\nvoid simulatePowertrainFaults_fixed() {\n    for (int i = 0; i < 60; ++i) {\n        logVehicleDomainEvent_fixed(DOMAIN_POWERTRAIN_FIXED, 0x10 + i, 100 + i, 0x12345000 + i);\n    }\n}\n\nvoid runFixedLogSystem() {\n    initVehicleLogSystem_fixed();\n    simulatePowertrainFaults_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#define CAN_DATA_MAX_LEN 8\n#define CAN_MSG_ID_BASE 0x100\n#define NUM_CAN_HANDLERS 5\n\ntypedef struct {\n    uint16_t message_id;\n    uint8_t data[CAN_DATA_MAX_LEN];\n    uint8_t data_len;\n} CanMessage;\n\nvoid automotiveCanLog_vulnerable(const char* msg) {\n    fprintf(stderr, \"CAN_VULN_LOG: %s\\n\", msg);\n}\n\nvoid handleEngineRPM(const uint8_t* data, uint8_t len) {\n    if (len >= 2) {\n        uint16_t rpm = (data[0] << 8) | data[1];\n        automotiveCanLog_vulnerable(\"Engine RPM handler: RPM processed.\");\n    } else {\n        automotiveCanLog_vulnerable(\"Engine RPM handler: Invalid data length.\");\n    }\n}\n\nvoid handleVehicleSpeed(const uint8_t* data, uint8_t len) {\n    if (len >= 1) {\n        uint8_t speed = data[0];\n        automotiveCanLog_vulnerable(\"Vehicle Speed handler: Speed processed.\");\n    } else {\n        automotiveCanLog_vulnerable(\"Vehicle Speed handler: Invalid data length.\");\n    }\n}\n\nvoid handleBrakePressure(const uint8_t* data, uint8_t len) {\n    if (len >= 4) {\n        int32_t pressure = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | data[3];\n        automotiveCanLog_vulnerable(\"Brake Pressure handler: Pressure processed.\");\n    } else {\n        automotiveCanLog_vulnerable(\"Brake Pressure handler: Invalid data length.\");\n    }\n}\n\nvoid handleSteeringAngle(const uint8_t* data, uint8_t len) {\n    if (len >= 2) {\n        int16_t angle = (data[0] << 8) | data[1];\n        automotiveCanLog_vulnerable(\"Steering Angle handler: Angle processed.\");\n    } else {\n        automotiveCanLog_vulnerable(\"Steering Angle handler: Invalid data length.\");\n    }\n}\n\nvoid handleDoorStatus(const uint8_t* data, uint8_t len) {\n    if (len >= 1) {\n        uint8_t status = data[0];\n        automotiveCanLog_vulnerable(\"Door Status handler: Status processed.\");\n    } else {\n        automotiveCanLog_vulnerable(\"Door Status handler: Invalid data length.\");\n    }\n}\n\ntypedef void (*CanHandlerFunc)(const uint8_t* data, uint8_t len);\n\nstatic CanHandlerFunc g_canHandlers_vulnerable[NUM_CAN_HANDLERS];\n\nvoid initializeCanHandlers_vulnerable() {\n    g_canHandlers_vulnerable[0] = handleEngineRPM;\n    g_canHandlers_vulnerable[1] = handleVehicleSpeed;\n    g_canHandlers_vulnerable[2] = handleBrakePressure;\n    g_canHandlers_vulnerable[3] = handleSteeringAngle;\n    g_canHandlers_vulnerable[4] = handleDoorStatus;\n    automotiveCanLog_vulnerable(\"CAN handlers initialized (Vulnerable).\");\n}\n\nCanMessage receiveCanMessage_vulnerable() {\n    CanMessage msg;\n    msg.message_id = CAN_MSG_ID_BASE - 1;\n    msg.data_len = 2;\n    msg.data[0] = 0xAA;\n    msg.data[1] = 0xBB;\n    automotiveCanLog_vulnerable(\"Simulating reception of malicious CAN message (vulnerable).\");\n    return msg;\n}\n\nvoid processCanMessage_vulnerable(CanMessage msg) {\n    uint16_t handler_index = msg.message_id - CAN_MSG_ID_BASE;\n    g_canHandlers_vulnerable[handler_index](msg.data, msg.data_len);\n    automotiveCanLog_vulnerable(\"CAN message processing attempted (vulnerable).\");\n}\n\nvoid canCommunicationModuleMain_vulnerable() {\n    initializeCanHandlers_vulnerable();\n    CanMessage incoming_msg = receiveCanMessage_vulnerable();\n    processCanMessage_vulnerable(incoming_msg);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_DATA_STORAGE_SIZE 250\n\nstatic uint8_t g_diagDataStore[DIAG_DATA_STORAGE_SIZE];\n\nvoid initDiagnosticDataStore() {\n    memset(g_diagDataStore, 0, DIAG_DATA_STORAGE_SIZE);\n}\n\nint updateDiagnosticBlock(uint16_t offset, uint8_t len, const uint8_t* data) {\n    if (data == NULL || len == 0) {\n        return -1;\n    }\n\n    if (offset >= DIAG_DATA_STORAGE_SIZE) {\n        return -2;\n    }\n\n    if ((uint32_t)offset + len > DIAG_DATA_STORAGE_SIZE) {\n        return -3;\n    }\n\n    for (uint8_t i = 0; i < len; ++i) {\n        g_diagDataStore[offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid handleDiagnosticUpdateMessage(const uint8_t* msg_raw, uint16_t msg_raw_len) {\n    if (msg_raw == NULL || msg_raw_len < 3) {\n        return;\n    }\n\n    uint16_t current_read_pos = 0;\n\n    uint16_t block_offset = (msg_raw[current_read_pos] << 8) | msg_raw[current_read_pos + 1];\n    current_read_pos += 2;\n\n    uint8_t block_len = msg_raw[current_read_pos];\n    current_read_pos += 1;\n\n    if (current_read_pos + block_len > msg_raw_len) {\n        return;\n    }\n\n    const uint8_t* payload_ptr = msg_raw + current_read_pos;\n\n    updateDiagnosticBlock(block_offset, block_len, payload_ptr);\n}\n\nuint8_t getDiagDataByte(uint16_t index) {\n    if (index < DIAG_DATA_STORAGE_SIZE) {\n        return g_diagDataStore[index];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n\n#pragma pack(push, 1)\n\nstruct ConfigPacketHeader {\n    uint32_t magic_id;\n    uint16_t num_entries;\n    uint32_t total_declared_size; \n};\n\nstruct ConfigEntryHeader {\n    uint16_t param_id;\n    uint16_t data_length; \n};\n\n#pragma pack(pop)\n\nclass VehicleConfigStoreVulnerable {\npublic:\n    VehicleConfigStoreVulnerable() : m_config_buffer(nullptr), m_current_buffer_size(0), m_allocated_capacity(0) {}\n\n    ~VehicleConfigStoreVulnerable() {\n        clearConfig();\n    }\n\n    void clearConfig() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n            m_config_buffer = nullptr;\n        }\n        m_current_buffer_size = 0;\n        m_allocated_capacity = 0;\n    }\n\n    bool processConfigPacketVulnerable(const uint8_t* raw_packet_data, size_t packet_length) {\n        if (!raw_packet_data || packet_length < sizeof(ConfigPacketHeader)) {\n            return false;\n        }\n\n        const ConfigPacketHeader* packet_hdr = reinterpret_cast<const ConfigPacketHeader*>(raw_packet_data);\n\n        if (packet_hdr->magic_id != 0xFEEDC0DE) {\n            return false;\n        }\n\n        if (packet_hdr->total_declared_size == 0) {\n            clearConfig();\n            return true; \n        }\n\n        uint8_t* new_buffer = (uint8_t*)realloc(m_config_buffer, packet_hdr->total_declared_size);\n        if (!new_buffer) {\n            clearConfig();\n            return false;\n        }\n        m_config_buffer = new_buffer;\n        m_allocated_capacity = packet_hdr->total_declared_size;\n        m_current_buffer_size = 0; \n\n        size_t current_read_offset = sizeof(ConfigPacketHeader);\n        size_t current_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_hdr->num_entries; ++i) {\n            if (current_read_offset + sizeof(ConfigEntryHeader) > packet_length) {\n                clearConfig();\n                return false;\n            }\n\n            const ConfigEntryHeader* entry_hdr = reinterpret_cast<const ConfigEntryHeader*>(raw_packet_data + current_read_offset);\n            uint16_t data_len = entry_hdr->data_length;\n\n            if (current_read_offset + sizeof(ConfigEntryHeader) + data_len > packet_length) {\n                clearConfig();\n                return false;\n            }\n\n            size_t entry_content_size_without_padding = sizeof(ConfigEntryHeader) + data_len;\n            size_t padding_bytes = (4 - (entry_content_size_without_padding % 4)) % 4;\n            if (entry_content_size_without_padding % 4 == 0) {\n                padding_bytes = 0;\n            }\n\n            size_t total_entry_storage_size = entry_content_size_without_padding + padding_bytes;\n            \n            memcpy(m_config_buffer + current_write_offset, entry_hdr, sizeof(ConfigEntryHeader));\n            current_write_offset += sizeof(ConfigEntryHeader);\n\n            memcpy(m_config_buffer + current_write_offset, raw_packet_data + current_read_offset + sizeof(ConfigEntryHeader), data_len);\n            current_write_offset += data_len;\n\n            if (padding_bytes > 0) {\n                memset(m_config_buffer + current_write_offset, 0, padding_bytes);\n                current_write_offset += padding_bytes;\n            }\n\n            current_read_offset += total_entry_storage_size;\n            m_current_buffer_size = current_write_offset; \n        }\n\n        return true;\n    }\n\n    const uint8_t* getConfigBuffer() const {\n        return m_config_buffer;\n    }\n\n    size_t getCurrentBufferSize() const {\n        return m_current_buffer_size;\n    }\n\n    size_t getAllocatedCapacity() const {\n        return m_allocated_capacity;\n    }\n\nprivate:\n    uint8_t* m_config_buffer;\n    size_t m_current_buffer_size;\n    size_t m_allocated_capacity;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_FAULT_TYPES 3\n#define MAX_LOG_ENTRIES_PER_TYPE 5\n\ntypedef struct {\n    uint16_t code;\n    uint32_t timestamp;\n} FaultLogEntry;\n\nstatic FaultLogEntry g_faultLog_vulnerable[MAX_FAULT_TYPES][MAX_LOG_ENTRIES_PER_TYPE];\nstatic uint8_t g_currentLogCount_vulnerable[MAX_FAULT_TYPES];\n\nvoid logSystemActivity_Vulnerable(const char* msg) {\n    fprintf(stderr, \"VULN_LOG: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t fault_type_id;\n    uint16_t fault_code;\n    uint32_t event_timestamp;\n} IncomingFaultReport_Vulnerable;\n\nstatic uint8_t s_simulated_fault_count_vulnerable = 0;\nIncomingFaultReport_Vulnerable simulateIncomingFault_Vulnerable() {\n    IncomingFaultReport_Vulnerable report;\n    report.fault_type_id = 0;\n    report.fault_code = 0x1234 + s_simulated_fault_count_vulnerable;\n    report.event_timestamp = 0xABCDEF00 + s_simulated_fault_count_vulnerable;\n    s_simulated_fault_count_vulnerable++;\n    return report;\n}\n\nvoid initializeFaultLoggingSystem_Vulnerable() {\n    for (uint8_t i = 0; i < MAX_FAULT_TYPES; ++i) {\n        g_currentLogCount_vulnerable[i] = 0;\n        for (uint8_t j = 0; j < MAX_LOG_ENTRIES_PER_TYPE; ++j) {\n            g_faultLog_vulnerable[i][j] = (FaultLogEntry){0, 0};\n        }\n    }\n    s_simulated_fault_count_vulnerable = 0;\n    logSystemActivity_Vulnerable(\"Fault logging system initialized (vulnerable).\");\n}\n\nvoid recordFault_Vulnerable(IncomingFaultReport_Vulnerable report) {\n    if (report.fault_type_id < MAX_FAULT_TYPES) {\n        FaultLogEntry new_entry;\n        new_entry.code = report.fault_code;\n        new_entry.timestamp = report.event_timestamp;\n\n        g_faultLog_vulnerable[report.fault_type_id][g_currentLogCount_vulnerable[report.fault_type_id]] = new_entry;\n        g_currentLogCount_vulnerable[report.fault_type_id]++;\n        logSystemActivity_Vulnerable(\"Fault recorded (vulnerable).\");\n    } else {\n        logSystemActivity_Vulnerable(\"Invalid fault type ID received. Ignoring report.\");\n    }\n}\n\nvoid automotiveFaultManager_Vulnerable() {\n    initializeFaultLoggingSystem_Vulnerable();\n\n    for (int i = 0; i < MAX_LOG_ENTRIES_PER_TYPE + 1; ++i) {\n        IncomingFaultReport_Vulnerable fault = simulateIncomingFault_Vulnerable();\n        recordFault_Vulnerable(fault);\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_DTC_STORAGE_CAPACITY_VULNERABLE 10\n\ntypedef struct {\n    uint32_t dtc_code;\n    uint8_t  status_byte;\n    uint16_t occurrence_count;\n    bool     is_active;\n} DTC_Entry_Vulnerable;\n\nstatic DTC_Entry_Vulnerable g_dtc_entries_vulnerable[MAX_DTC_STORAGE_CAPACITY_VULNERABLE];\nstatic uint8_t g_current_active_dtc_count_vulnerable = 0;\n\nvoid logDiagnosticMessage_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t requested_dtc_index;\n} DTC_QueryRequest_Vulnerable;\n\nDTC_QueryRequest_Vulnerable receiveDTCQuery_vulnerable() {\n    DTC_QueryRequest_Vulnerable query;\n    query.requested_dtc_index = g_current_active_dtc_count_vulnerable; \n    return query;\n}\n\nvoid initializeDTCStorage_vulnerable() {\n    for (uint8_t i = 0; i < MAX_DTC_STORAGE_CAPACITY_VULNERABLE; ++i) {\n        g_dtc_entries_vulnerable[i] = (DTC_Entry_Vulnerable){0, 0, 0, false};\n    }\n\n    g_dtc_entries_vulnerable[0] = (DTC_Entry_Vulnerable){0xF001, 0x0A, 1, true};\n    g_dtc_entries_vulnerable[1] = (DTC_Entry_Vulnerable){0xF002, 0x0B, 3, true};\n    g_dtc_entries_vulnerable[2] = (DTC_Entry_Vulnerable){0xF003, 0x0C, 1, true};\n    g_current_active_dtc_count_vulnerable = 3;\n\n    logDiagnosticMessage_vulnerable(\"DTC storage initialized (vulnerable).\");\n}\n\nvoid addDTC_vulnerable(uint32_t code, uint8_t status) {\n    if (g_current_active_dtc_count_vulnerable < MAX_DTC_STORAGE_CAPACITY_VULNERABLE) {\n        DTC_Entry_Vulnerable new_dtc = {code, status, 1, true};\n        g_dtc_entries_vulnerable[g_current_active_dtc_count_vulnerable] = new_dtc;\n        g_current_active_dtc_count_vulnerable++;\n        logDiagnosticMessage_vulnerable(\"DTC added.\");\n    } else {\n        logDiagnosticMessage_vulnerable(\"DTC storage full.\");\n    }\n}\n\nDTC_Entry_Vulnerable getDTCDetails_vulnerable(uint8_t index) {\n    if (index < MAX_DTC_STORAGE_CAPACITY_VULNERABLE) {\n        logDiagnosticMessage_vulnerable(\"Accessing DTC entry (vulnerable).\");\n        return g_dtc_entries_vulnerable[index];\n    } else {\n        logDiagnosticMessage_vulnerable(\"DTC query index out of physical array bounds (vulnerable).\");\n        return (DTC_Entry_Vulnerable){0, 0, 0, false};\n    }\n}\n\nvoid diagnosticModuleMain_vulnerable() {\n    initializeDTCStorage_vulnerable();\n    addDTC_vulnerable(0xF004, 0x0D);\n    \n    DTC_QueryRequest_Vulnerable query = receiveDTCQuery_vulnerable();\n    DTC_Entry_Vulnerable retrieved_dtc = getDTCDetails_vulnerable(query.requested_dtc_index);\n    logDiagnosticMessage_vulnerable(\"DTC query processed (vulnerable).\");\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_LOG_CAPACITY 64\n\ntypedef struct {\n    uint32_t fault_code;\n    uint32_t timestamp;\n    uint8_t  level; \n    uint8_t  param_count;\n    uint16_t params[2];\n} DiagnosticLogEntry;\n\nstatic DiagnosticLogEntry g_diag_log_buffer[DIAG_LOG_CAPACITY];\nstatic uint16_t g_log_write_idx = 0;\nstatic uint16_t g_num_logged_entries = 0;\n\nvoid init_diag_logger_fixed() {\n    memset(g_diag_log_buffer, 0, sizeof(g_diag_log_buffer));\n    g_log_write_idx = 0;\n    g_num_logged_entries = 0;\n}\n\nvoid add_diag_entry_fixed(uint32_t code, uint32_t ts, uint8_t level, uint8_t p_count, uint16_t p1, uint16_t p2) {\n    if (g_num_logged_entries < DIAG_LOG_CAPACITY) {\n        g_diag_log_buffer[g_log_write_idx].fault_code = code;\n        g_diag_log_buffer[g_log_write_idx].timestamp = ts;\n        g_diag_log_buffer[g_log_write_idx].level = level;\n        g_diag_log_buffer[g_log_write_idx].param_count = p_count;\n        g_diag_log_buffer[g_log_write_idx].params[0] = p1;\n        g_diag_log_buffer[g_log_write_idx].params[1] = p2;\n        \n        g_log_write_idx = (g_log_write_idx + 1) % DIAG_LOG_CAPACITY;\n        g_num_logged_entries++;\n    } else {\n        g_diag_log_buffer[g_log_write_idx].fault_code = code;\n        g_diag_log_buffer[g_log_write_idx].timestamp = ts;\n        g_diag_log_buffer[g_log_write_idx].level = level;\n        g_diag_log_buffer[g_log_write_idx].param_count = p_count;\n        g_diag_log_buffer[g_log_write_idx].params[0] = p1;\n        g_diag_log_buffer[g_log_write_idx].params[1] = p2;\n        g_log_write_idx = (g_log_write_idx + 1) % DIAG_LOG_CAPACITY;\n    }\n}\n\nvoid clear_recent_diag_level_entries_fixed(uint8_t level_to_clear, uint16_t search_depth) {\n    if (g_num_logged_entries == 0 || search_depth == 0) {\n        return;\n    }\n\n    uint16_t current_logical_tail_idx = (g_log_write_idx == 0) ? (DIAG_LOG_CAPACITY - 1) : (g_log_write_idx - 1);\n\n    uint16_t effective_search_depth = (search_depth > g_num_logged_entries) ? g_num_logged_entries : search_depth;\n\n    for (uint16_t k = 0; k < effective_search_depth; ++k) {\n        uint16_t target_idx = (current_logical_tail_idx - k + DIAG_LOG_CAPACITY) % DIAG_LOG_CAPACITY;\n\n        if (g_diag_log_buffer[target_idx].level == level_to_clear) {\n            memset(&g_diag_log_buffer[target_idx], 0, sizeof(DiagnosticLogEntry));\n        }\n    }\n}\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CONFIG_BUFFER_SIZE 512\n#define MAX_BLOCK_PAYLOAD_SIZE 128\n#define BLOCK_HEADER_SIZE (sizeof(uint16_t) + sizeof(uint8_t))\n\nstatic uint8_t g_config_store[CONFIG_BUFFER_SIZE];\nstatic uint32_t g_current_data_end = 0;\n\nvoid init_config_store() {\n    memset(g_config_store, 0, CONFIG_BUFFER_SIZE);\n    g_current_data_end = 0;\n}\n\nbool add_config_block(uint16_t type, const uint8_t* payload, uint8_t payload_len) {\n    if (payload_len > MAX_BLOCK_PAYLOAD_SIZE) {\n        return false;\n    }\n    uint32_t block_total_size = BLOCK_HEADER_SIZE + payload_len;\n\n    if (g_current_data_end + block_total_size > CONFIG_BUFFER_SIZE) {\n        return false;\n    }\n\n    uint8_t* dest_ptr = g_config_store + g_current_data_end;\n\n    *(uint16_t*)dest_ptr = type;\n    dest_ptr[2] = payload_len;\n    memcpy(dest_ptr + BLOCK_HEADER_SIZE, payload, payload_len);\n\n    g_current_data_end += block_total_size;\n    return true;\n}\n\nvoid process_config_block_at_offset(uint32_t offset) {\n    if (offset >= g_current_data_end) return;\n    volatile uint16_t block_type_val = *(uint16_t*)(g_config_store + offset);\n    (void)block_type_val;\n}\n\nvoid rewind_config_buffer_vulnerable(uint8_t rewind_level) {\n    if (g_current_data_end == 0) {\n        return;\n    }\n\n    #define CONCEPTUAL_SEGMENT_SIZE 32\n\n    uint32_t total_rewind_bytes = (uint32_t)rewind_level * CONCEPTUAL_SEGMENT_SIZE;\n\n    int32_t start_clear_idx_signed = (int32_t)g_current_data_end - total_rewind_bytes;\n\n    for (uint32_t i = 0; i < total_rewind_bytes; ++i) {\n        g_config_store[start_clear_idx_signed + i] = 0x00;\n    }\n\n    if (start_clear_idx_signed < 0) {\n        g_current_data_end = 0;\n    } else {\n        g_current_data_end = (uint32_t)start_clear_idx_signed;\n    }\n\n    process_config_block_at_offset(g_current_data_end > 0 ? g_current_data_end - 1 : 0);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <limits>\n\nstruct SensorSample {\n    uint32_t timestamp;\n    int16_t  value_x;\n    int16_t  value_y;\n    int16_t  value_z;\n    uint8_t  status;\n};\n\nstruct SensorPacketHeader {\n    uint16_t packet_id;\n    uint32_t offset_in_total_stream;\n    uint32_t num_samples_in_packet;\n};\n\nclass SensorDataRecorderVulnerable {\npublic:\n    SensorDataRecorderVulnerable(size_t max_recording_bytes)\n        : m_recording_buffer(nullptr), m_allocated_size(0) {\n        if (max_recording_bytes > 0) {\n            m_recording_buffer = (uint8_t*)malloc(max_recording_bytes);\n            if (m_recording_buffer) {\n                m_allocated_size = max_recording_bytes;\n            }\n        }\n    }\n\n    ~SensorDataRecorderVulnerable() {\n        if (m_recording_buffer) {\n            free(m_recording_buffer);\n            m_recording_buffer = nullptr;\n        }\n    }\n\n    bool processSensorDataPacketVulnerable(const uint8_t* packet_data, size_t packet_len) {\n        if (!packet_data || packet_len < sizeof(SensorPacketHeader)) {\n            return false;\n        }\n\n        const SensorPacketHeader* header = reinterpret_cast<const SensorPacketHeader*>(packet_data);\n\n        uint32_t expected_packet_data_length_bytes = header->num_samples_in_packet * sizeof(SensorSample);\n\n        uint32_t dest_offset = header->offset_in_total_stream;\n\n        if (dest_offset + expected_packet_data_length_bytes > m_allocated_size) {\n            return false;\n        }\n\n        if (packet_len < sizeof(SensorPacketHeader) + (size_t)header->num_samples_in_packet * sizeof(SensorSample)) {\n            return false;\n        }\n\n        size_t source_data_read_offset = sizeof(SensorPacketHeader);\n\n        for (uint32_t i = 0; i < header->num_samples_in_packet; ++i) {\n            size_t current_sample_size = sizeof(SensorSample);\n            \n            size_t current_source_pos = source_data_read_offset + (size_t)i * current_sample_size;\n            size_t current_dest_pos = dest_offset + (size_t)i * current_sample_size;\n\n            for (size_t k = 0; k < current_sample_size; ++k) {\n                m_recording_buffer[current_dest_pos + k] = packet_data[current_source_pos + k];\n            }\n        }\n\n        return true;\n    }\n\n    size_t getAllocatedSize() const {\n        return m_allocated_size;\n    }\n\n    const uint8_t* getRecordingBuffer() const {\n        return m_recording_buffer;\n    }\n\nprivate:\n    uint8_t* m_recording_buffer;\n    size_t m_allocated_size;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define PARAM_NAME_MAX_LEN          16\n#define PARAM_VALUE_BUFFER_SIZE     32\n\n#define PROTOCOL_MAX_VALUE_LEN      60\n\ntypedef enum {\n    PARAM_TYPE_UINT8,\n    PARAM_TYPE_UINT16,\n    PARAM_TYPE_STRING,\n    PARAM_TYPE_BYTE_ARRAY\n} ParameterType;\n\ntypedef struct {\n    char name[PARAM_NAME_MAX_LEN];\n    ParameterType type;\n    uint8_t value_len;\n    union {\n        uint8_t  u8_val;\n        uint16_t u16_val;\n        char     str_val[PARAM_VALUE_BUFFER_SIZE];\n        uint8_t  byte_array_val[PARAM_VALUE_BUFFER_SIZE];\n    } value;\n} VehicleParameter;\n\nstatic uint8_t g_message_rx_buffer[256];\n\nstatic uint8_t get_byte_from_stream(const uint8_t* stream_data, uint32_t* offset, uint32_t total_length) {\n    if (stream_data == NULL || *offset >= total_length) {\n        return 0;\n    }\n    return stream_data[(*offset)++];\n}\n\nint parseVehicleParameter(const uint8_t* raw_message_stream, uint32_t stream_total_len, VehicleParameter* param_out) {\n    uint32_t current_stream_pos = 0;\n\n    if (raw_message_stream == NULL || param_out == NULL || stream_total_len < (1 + 1 + 1)) {\n        return -1;\n    }\n\n    memset(param_out, 0, sizeof(VehicleParameter));\n\n    if (current_stream_pos + 1 > stream_total_len) return -2;\n    uint8_t name_len = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n    \n    if (name_len == 0 || name_len >= PARAM_NAME_MAX_LEN) {\n        return -3;\n    }\n\n    if (current_stream_pos + name_len > stream_total_len) {\n        return -4;\n    }\n    for (int i = 0; i < name_len; ++i) {\n        param_out->name[i] = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n    }\n    param_out->name[name_len] = '\\0';\n\n    if (current_stream_pos + 1 > stream_total_len) return -5;\n    param_out->type = (ParameterType)get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n\n    switch (param_out->type) {\n        case PARAM_TYPE_UINT8:\n            if (current_stream_pos + sizeof(uint8_t) > stream_total_len) return -6;\n            param_out->value.u8_val = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n            param_out->value_len = sizeof(uint8_t);\n            break;\n        case PARAM_TYPE_UINT16:\n            if (current_stream_pos + sizeof(uint16_t) > stream_total_len) return -6;\n            param_out->value.u16_val = (uint16_t)((get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len) << 8) |\n                                                   get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len));\n            param_out->value_len = sizeof(uint16_t);\n            break;\n        case PARAM_TYPE_STRING:\n        case PARAM_TYPE_BYTE_ARRAY:\n            if (current_stream_pos + 1 > stream_total_len) return -6;\n            uint8_t declared_value_len = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n            \n            param_out->value_len = declared_value_len;\n\n            if (declared_value_len > PROTOCOL_MAX_VALUE_LEN) {\n                return -7;\n            }\n            \n            if (current_stream_pos + declared_value_len > stream_total_len) {\n                return -8;\n            }\n\n            for (int i = 0; i < declared_value_len; ++i) {\n                if (param_out->type == PARAM_TYPE_STRING) {\n                    param_out->value.str_val[i] = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n                } else {\n                    param_out->value.byte_array_val[i] = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n                }\n            }\n            if (param_out->type == PARAM_TYPE_STRING) {\n                param_out->value.str_val[declared_value_len] = '\\0';\n            }\n            break;\n        default:\n            return -9;\n    }\n\n    return current_stream_pos;\n}\n\nvoid simulateConfigUpdate() {\n    uint8_t malicious_message_data[51];\n    memset(malicious_message_data, 0, sizeof(malicious_message_data));\n\n    uint32_t offset = 0;\n    malicious_message_data[offset++] = strlen(\"SensorSetting\");\n    memcpy(malicious_message_data + offset, \"SensorSetting\", strlen(\"SensorSetting\"));\n    offset += strlen(\"SensorSetting\");\n    malicious_message_data[offset++] = PARAM_TYPE_STRING;\n    malicious_message_data[offset++] = 35;\n    for (int i = 0; i < 35; ++i) {\n        malicious_message_data[offset++] = 'A';\n    }\n\n    VehicleParameter param;\n    (void)parseVehicleParameter(malicious_message_data, sizeof(malicious_message_data), &param);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define EVENT_BUFFER_SIZE_BYTES 512\n#define MAX_EVENT_PAYLOAD_BYTES 250\n\nstatic uint8_t g_vehicle_event_buffer_fixed[EVENT_BUFFER_SIZE_BYTES];\nstatic uint16_t g_event_write_head_offset_fixed = 0;\nstatic uint16_t g_num_active_events_fixed = 0;\n\ntypedef struct {\n    uint8_t  status_flags;\n    uint8_t  event_type_id;\n    uint16_t payload_len;\n} EventHeader;\n\n#define EVENT_HEADER_BYTE_SIZE (sizeof(EventHeader))\n\nuint32_t calculate_data_crc_dummy_fixed(const uint8_t* data, uint16_t len) {\n    uint32_t crc = 0;\n    if (data == NULL) return 0;\n    for (uint16_t i = 0; i < len; ++i) {\n        crc += data[i];\n    }\n    return crc;\n}\n\nvoid event_buffer_init_fixed() {\n    memset(g_vehicle_event_buffer_fixed, 0, sizeof(g_vehicle_event_buffer_fixed));\n    g_event_write_head_offset_fixed = 0;\n    g_num_active_events_fixed = 0;\n}\n\nbool event_buffer_add_event_fixed(uint8_t type_id, const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len == 0 || payload_len > MAX_EVENT_PAYLOAD_BYTES) {\n        return false;\n    }\n\n    if (g_event_write_head_offset_fixed + EVENT_HEADER_BYTE_SIZE + payload_len > EVENT_BUFFER_SIZE_BYTES) {\n        g_event_write_head_offset_fixed = 0;\n        if (g_event_write_head_offset_fixed + EVENT_HEADER_BYTE_SIZE + payload_len > EVENT_BUFFER_SIZE_BYTES) {\n            return false;\n        }\n    }\n\n    EventHeader* header_ptr = (EventHeader*)(g_vehicle_event_buffer_fixed + g_event_write_head_offset_fixed);\n    header_ptr->status_flags = 0x01;\n    header_ptr->event_type_id = type_id;\n    header_ptr->payload_len = payload_len;\n\n    memcpy(g_vehicle_event_buffer_fixed + g_event_write_head_offset_fixed + EVENT_HEADER_BYTE_SIZE, payload, payload_len);\n\n    g_event_write_head_offset_fixed += (EVENT_HEADER_BYTE_SIZE + payload_len);\n    g_num_active_events_fixed++;\n    return true;\n}\n\nvoid mark_event_as_processed_fixed(uint16_t event_data_offset, uint8_t new_status) {\n    int32_t status_byte_index = (int32_t)event_data_offset - EVENT_HEADER_BYTE_SIZE;\n\n    if (status_byte_index < 0 || status_byte_index >= EVENT_BUFFER_SIZE_BYTES) {\n        return;\n    }\n    \n    g_vehicle_event_buffer_fixed[status_byte_index] = new_status;\n}\n\nbool get_event_payload_fixed(uint16_t event_data_offset, uint8_t* buffer, uint16_t* len) {\n    if (event_data_offset >= EVENT_BUFFER_SIZE_BYTES) return false;\n\n    int32_t header_offset = (int32_t)event_data_offset - EVENT_HEADER_BYTE_SIZE;\n    if (header_offset < 0) return false;\n\n    EventHeader* header_ptr = (EventHeader*)(g_vehicle_event_buffer_fixed + header_offset);\n\n    if (header_offset + EVENT_HEADER_BYTE_SIZE + header_ptr->payload_len > EVENT_BUFFER_SIZE_BYTES) {\n        return false;\n    }\n\n    if (buffer && len) {\n        if (*len < header_ptr->payload_len) {\n            *len = header_ptr->payload_len;\n            return false;\n        }\n        memcpy(buffer, g_vehicle_event_buffer_fixed + event_data_offset, header_ptr->payload_len);\n        *len = header_ptr->payload_len;\n        return true;\n    }\n    return false;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define TEMP_DATA_SCRATCHPAD_SIZE_FIXED 128\n#define DATA_SECTION_START_OFFSET_FIXED 8\n\nstatic uint8_t g_processing_scratchpad_fixed[TEMP_DATA_SCRATCHPAD_SIZE_FIXED];\nstatic uint16_t g_current_scratchpad_data_len_fixed = 0;\n\nvoid init_scratchpad_processing_fixed() {\n    memset(g_processing_scratchpad_fixed, 0, TEMP_DATA_SCRATCHPAD_SIZE_FIXED);\n    g_current_scratchpad_data_len_fixed = 0;\n}\n\nbool load_data_to_scratchpad_fixed(const uint8_t* data, uint16_t len) {\n    if (len > (TEMP_DATA_SCRATCHPAD_SIZE_FIXED - DATA_SECTION_START_OFFSET_FIXED)) {\n        return false;\n    }\n    memcpy(g_processing_scratchpad_fixed + DATA_SECTION_START_OFFSET_FIXED, data, len);\n    g_current_scratchpad_data_len_fixed = len;\n    return true;\n}\n\nvoid apply_data_transform_fixed(uint8_t transform_type_marker, int16_t relative_start_offset) {\n    if (g_current_scratchpad_data_len_fixed == 0) {\n        return;\n    }\n\n    int32_t target_absolute_index = DATA_SECTION_START_OFFSET_FIXED + relative_start_offset;\n\n    if (target_absolute_index < 0 || target_absolute_index >= TEMP_DATA_SCRATCHPAD_SIZE_FIXED) {\n        return;\n    }\n\n    g_processing_scratchpad_fixed[target_absolute_index] = transform_type_marker;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n// Define CAN message IDs for specific diagnostic services\n#define CAN_ID_CONFIG_UPDATE_SERVICE 0x18F00100\n#define CAN_ID_STATUS_REQUEST_SERVICE 0x18F00200\n\n// Maximum number of configurable parameters\n#define MAX_CONFIG_PARAMETERS 64\n\n// Structure for a single configurable parameter entry\ntypedef struct {\n    uint8_t id;\n    uint8_t value;\n    uint8_t type; \n} ConfigParameterEntry;\n\n// Main ECU configuration storage\nstatic ConfigParameterEntry ecu_config_store[MAX_CONFIG_PARAMETERS];\n\n// Initializes the ECU configuration store with default values\nvoid init_ecu_config_store() {\n    for (int i = 0; i < MAX_CONFIG_PARAMETERS; ++i) {\n        ecu_config_store[i].id = (uint8_t)i;\n        ecu_config_store[i].value = 0x00;\n        ecu_config_store[i].type = 0x00; \n    }\n}\n\n// Function to process a CAN diagnostic message payload\n// This function assumes the msg_id has already been validated to be a config update service.\n// The payload format for config update: [param_index_byte][param_value_byte]\n// This service allows setting a single parameter at a time.\nint process_config_update_payload(const uint8_t* payload, uint8_t payload_len) {\n    if (payload == NULL || payload_len < 2) {\n        return -1; \n    }\n\n    uint8_t param_idx_received = payload[0];\n    uint8_t new_param_value = payload[1];\n\n    // The fix: Add a bounds check for param_idx_received\n    if (param_idx_received >= MAX_CONFIG_PARAMETERS) {\n        return -2; \n    }\n\n    ecu_config_store[param_idx_received].value = new_param_value;\n\n    return 0; \n}\n\n// Main entry point for processing incoming CAN messages\n// This function would typically be called by a CAN driver interrupt or polling loop.\nint handle_can_diagnostic_message(uint32_t can_id, const uint8_t* data_bytes, uint8_t data_len) {\n    if (data_bytes == NULL || data_len == 0) {\n        return -1; \n    }\n\n    switch (can_id) {\n        case CAN_ID_CONFIG_UPDATE_SERVICE:\n            return process_config_update_payload(data_bytes, data_len);\n        case CAN_ID_STATUS_REQUEST_SERVICE:\n            // Placeholder for status request handling logic\n            return 0;\n        default:\n            return -99; \n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define CONFIG_MEM_SIZE 1024\n#define MAX_PATCH_ENTRIES 16\n#define MAX_PATCH_PACKET_SIZE 512\n\nstatic uint8_t g_configMemory[CONFIG_MEM_SIZE];\n\ntypedef struct {\n    uint16_t offset;\n    uint8_t  length;\n} PatchEntryHeader;\n\ntypedef struct {\n    uint8_t          command_id;\n    uint8_t          num_patches;\n} PatchPacketHeader;\n\nvoid initConfigMemory() {\n    memset(g_configMemory, 0xAA, CONFIG_MEM_SIZE);\n}\n\nint applyConfigurationPatches(const uint8_t* raw_packet, uint16_t packet_len) {\n    if (raw_packet == NULL || packet_len < sizeof(PatchPacketHeader)) {\n        return -1;\n    }\n\n    const PatchPacketHeader* header = (const PatchPacketHeader*)raw_packet;\n    if (header->command_id != 0x01) {\n        return -2;\n    }\n\n    if (header->num_patches == 0 || header->num_patches > MAX_PATCH_ENTRIES) {\n        return -3;\n    }\n\n    uint16_t current_payload_offset = sizeof(PatchPacketHeader);\n    for (uint8_t i = 0; i < header->num_patches; ++i) {\n        if (current_payload_offset + sizeof(PatchEntryHeader) > packet_len) {\n            return -4;\n        }\n        \n        const PatchEntryHeader* entry_header = (const PatchEntryHeader*)(raw_packet + current_payload_offset);\n        \n        if (current_payload_offset + sizeof(PatchEntryHeader) + entry_header->length > packet_len) {\n            return -5;\n        }\n\n        if (entry_header->offset >= CONFIG_MEM_SIZE) {\n            return -6;\n        }\n\n        const uint8_t* patch_data_src = raw_packet + current_payload_offset + sizeof(PatchEntryHeader);\n        for (uint8_t j = 0; j < entry_header->length; ++j) {\n            g_configMemory[entry_header->offset + j] = patch_data_src[j];\n        }\n\n        current_payload_offset += sizeof(PatchEntryHeader) + entry_header->length;\n    }\n\n    return 0;\n}\n\nuint8_t getConfigByte(uint16_t offset) {\n    if (offset < CONFIG_MEM_SIZE) {\n        return g_configMemory[offset];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_ENGINE_PARAMS 10\n#define MAX_CHASSIS_PARAMS 15\n#define MAX_INFOTAINMENT_PARAMS 5\n\n#define GLOBAL_MAX_PARAMETER_INDEX 100\n\ntypedef enum {\n    MODULE_ENGINE = 0,\n    MODULE_CHASSIS,\n    MODULE_INFOTAINMENT,\n    NUM_VEHICLE_MODULES_VULNERABLE\n} VehicleModuleType_Vulnerable;\n\ntypedef struct {\n    uint16_t id;\n    int32_t  value;\n    bool     is_calibrated;\n} ParameterData_Vulnerable;\n\nstatic ParameterData_Vulnerable g_engineParameters_Vulnerable[MAX_ENGINE_PARAMS];\nstatic ParameterData_Vulnerable g_chassisParameters_Vulnerable[MAX_CHASSIS_PARAMS];\nstatic ParameterData_Vulnerable g_infotainmentParameters_Vulnerable[MAX_INFOTAINMENT_PARAMS];\n\nstatic ParameterData_Vulnerable* g_moduleParameterArrays_Vulnerable[NUM_VEHICLE_MODULES_VULNERABLE];\nstatic uint16_t g_moduleCapacities_Vulnerable[NUM_VEHICLE_MODULES_VULNERABLE];\n\nvoid logVehicleState_Vulnerable(const char* msg) {\n    printf(\"VULN_LOG: %s\\n\", msg);\n}\n\ntypedef struct {\n    VehicleModuleType_Vulnerable module_id;\n    uint16_t parameter_index;\n    int32_t new_value;\n} ParameterUpdateCommand_Vulnerable;\n\nParameterUpdateCommand_Vulnerable getIncomingParameterUpdate_Vulnerable() {\n    ParameterUpdateCommand_Vulnerable cmd;\n    cmd.module_id = MODULE_INFOTAINMENT;\n    cmd.parameter_index = 5; \n    cmd.new_value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeVehicleParameters_Vulnerable() {\n    g_moduleParameterArrays_Vulnerable[MODULE_ENGINE] = g_engineParameters_Vulnerable;\n    g_moduleCapacities_Vulnerable[MODULE_ENGINE] = MAX_ENGINE_PARAMS;\n\n    g_moduleParameterArrays_Vulnerable[MODULE_CHASSIS] = g_chassisParameters_Vulnerable;\n    g_moduleCapacities_Vulnerable[MODULE_CHASSIS] = MAX_CHASSIS_PARAMS;\n\n    g_moduleParameterArrays_Vulnerable[MODULE_INFOTAINMENT] = g_infotainmentParameters_Vulnerable;\n    g_moduleCapacities_Vulnerable[MODULE_INFOTAINMENT] = MAX_INFOTAINMENT_PARAMS;\n\n    for (int i = 0; i < NUM_VEHICLE_MODULES_VULNERABLE; ++i) {\n        for (uint16_t j = 0; j < g_moduleCapacities_Vulnerable[i]; ++j) {\n            g_moduleParameterArrays_Vulnerable[i][j] = (ParameterData_Vulnerable){0, 0, false};\n        }\n    }\n    logVehicleState_Vulnerable(\"Vehicle parameters initialized.\");\n}\n\nvoid processParameterUpdate_Vulnerable() {\n    ParameterUpdateCommand_Vulnerable cmd = getIncomingParameterUpdate_Vulnerable();\n\n    if (cmd.module_id >= NUM_VEHICLE_MODULES_VULNERABLE) {\n        logVehicleState_Vulnerable(\"Error: Invalid module ID received.\");\n        return;\n    }\n\n    if (cmd.parameter_index < GLOBAL_MAX_PARAMETER_INDEX) {\n        ParameterData_Vulnerable* target_array = g_moduleParameterArrays_Vulnerable[cmd.module_id];\n        \n        target_array[cmd.parameter_index].value = cmd.new_value;\n        target_array[cmd.parameter_index].is_calibrated = true;\n        logVehicleState_Vulnerable(\"Parameter updated successfully.\");\n    } else {\n        logVehicleState_Vulnerable(\"Error: Invalid parameter index received (general check failed).\");\n    }\n}\n\nvoid vehicleControlUnitMain_Vulnerable() {\n    initializeVehicleParameters_Vulnerable();\n    processParameterUpdate_Vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMAND_HISTORY 64\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t status;\n    uint16_t value;\n    uint32_t timestamp_ms;\n} VehicleCommandEntry;\n\nstatic VehicleCommandEntry g_command_history[MAX_COMMAND_HISTORY];\nstatic uint16_t g_current_command_count = 0;\nstatic uint32_t g_current_time_ms = 0;\n\nvoid init_command_history_system() {\n    memset(g_command_history, 0, sizeof(g_command_history));\n    g_current_command_count = 0;\n    g_current_time_ms = 0;\n}\n\nvoid increment_system_time(uint32_t ms) {\n    g_current_time_ms += ms;\n}\n\nbool record_vehicle_command(uint8_t cmd_id, uint16_t val) {\n    if (g_current_command_count >= MAX_COMMAND_HISTORY) {\n        return false;\n    }\n\n    g_command_history[g_current_command_count].command_id = cmd_id;\n    g_command_history[g_current_command_count].status = 0x01;\n    g_command_history[g_current_command_count].value = val;\n    g_command_history[g_current_command_count].timestamp_ms = g_current_time_ms;\n    g_current_command_count++;\n    return true;\n}\n\n#define CMD_TYPE_BRAKE 0x05\n#define CMD_TYPE_ACCELERATE 0x06\n#define CMD_TYPE_PARK 0x07\n\n#define STATUS_PROCESSED 0x02\n#define STATUS_CANCELED_IMPACT 0x04\n\nvoid process_recent_commands_vulnerable() {\n    if (g_current_command_count == 0) {\n        return;\n    }\n\n    for (int i = (int)g_current_command_count - 1; i >= 0; --i) {\n        switch (g_command_history[i].command_id) {\n            case CMD_TYPE_BRAKE:\n                g_command_history[i - 1].status |= STATUS_CANCELED_IMPACT;\n                g_command_history[i].status = STATUS_PROCESSED;\n                break;\n            case CMD_TYPE_ACCELERATE:\n                g_command_history[i].status = STATUS_PROCESSED;\n                break;\n            case CMD_TYPE_PARK:\n                g_command_history[i].status = STATUS_PROCESSED;\n                break;\n            default:\n                break;\n        }\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CALIBRATION_BLOCK_SIZE 64\n#define NUM_CALIBRATION_BLOCKS 8\n#define TOTAL_CALIBRATION_SIZE (CALIBRATION_BLOCK_SIZE * NUM_CALIBRATION_BLOCKS)\n\nstatic uint8_t g_calibrationData[TOTAL_CALIBRATION_SIZE];\nstatic bool g_calibrationInitialized = false;\n\nvoid initCalibrationSystem() {\n    memset(g_calibrationData, 0, TOTAL_CALIBRATION_SIZE);\n    g_calibrationInitialized = true;\n}\n\nint processCalibrationFragment(const uint8_t* msg_payload, uint16_t payload_len) {\n    if (!g_calibrationInitialized || msg_payload == NULL || payload_len < 5) {\n        return -1;\n    }\n\n    uint8_t block_idx = msg_payload[0];\n    uint16_t block_offset = (msg_payload[1] << 8) | msg_payload[2];\n    uint16_t data_len = (msg_payload[3] << 8) | msg_payload[4];\n\n    if (payload_len < (5 + data_len)) {\n        return -2;\n    }\n\n    if (block_idx >= NUM_CALIBRATION_BLOCKS) {\n        return -3;\n    }\n\n    const uint8_t* data_payload = msg_payload + 5;\n\n    uint16_t global_start_offset = (uint16_t)block_idx * CALIBRATION_BLOCK_SIZE + block_offset;\n\n    if (global_start_offset >= TOTAL_CALIBRATION_SIZE || \n        global_start_offset + data_len > TOTAL_CALIBRATION_SIZE) {\n        return -5;\n    }\n\n    for (uint16_t i = 0; i < data_len; ++i) {\n        g_calibrationData[global_start_offset + i] = data_payload[i];\n    }\n    \n    return 0;\n}\n\nvoid handleCANCalibrationMessage(const uint8_t* can_data, uint16_t can_dlc) {\n    processCalibrationFragment(can_data, can_dlc);\n}\n\nuint8_t getCalibrationByte(uint16_t index) {\n    if (index < TOTAL_CALIBRATION_SIZE) {\n        return g_calibrationData[index];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define VEHICLE_SENSOR_HISTORY_SIZE 10\n\ntypedef struct {\n    uint16_t sensor_id;\n    int32_t value;\n    uint32_t timestamp_ms;\n    bool valid;\n} VehicleSensorReading;\n\nstatic VehicleSensorReading g_sensor_history_buffer[VEHICLE_SENSOR_HISTORY_SIZE];\nstatic uint8_t g_history_head_idx = 0;\nstatic uint8_t g_history_count = 0;\n\nvoid init_sensor_history_buffer() {\n    for (uint8_t i = 0; i < VEHICLE_SENSOR_HISTORY_SIZE; ++i) {\n        memset(&g_sensor_history_buffer[i], 0, sizeof(VehicleSensorReading));\n        g_sensor_history_buffer[i].valid = false;\n    }\n    g_history_head_idx = 0;\n    g_history_count = 0;\n}\n\nbool add_sensor_reading(uint16_t sensor_id, int32_t value, uint32_t timestamp_ms) {\n    g_sensor_history_buffer[g_history_head_idx].sensor_id = sensor_id;\n    g_sensor_history_buffer[g_history_head_idx].value = value;\n    g_sensor_history_buffer[g_history_head_idx].timestamp_ms = timestamp_ms;\n    g_sensor_history_buffer[g_history_head_idx].valid = true;\n\n    g_history_head_idx = (g_history_head_idx + 1) % VEHICLE_SENSOR_HISTORY_SIZE;\n    if (g_history_count < VEHICLE_SENSOR_HISTORY_SIZE) {\n        g_history_count++;\n    }\n    return true;\n}\n\nvoid invalidate_n_last_readings_vulnerable(int8_t num_to_invalidate) {\n    if (g_history_count == 0 || num_to_invalidate <= 0) {\n        return;\n    }\n\n    int16_t start_logical_idx = (int16_t)g_history_head_idx - num_to_invalidate;\n\n    for (int8_t i = 0; i < num_to_invalidate; ++i) {\n        g_sensor_history_buffer[start_logical_idx + i].valid = false;\n        g_sensor_history_buffer[start_logical_idx + i].value = 0;\n    }\n\n    if (num_to_invalidate >= g_history_count) {\n        g_history_count = 0;\n        g_history_head_idx = 0;\n    } else {\n        g_history_count -= num_to_invalidate;\n        g_history_head_idx = (g_history_head_idx - num_to_invalidate + VEHICLE_SENSOR_HISTORY_SIZE) % VEHICLE_SENSOR_HISTORY_SIZE;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#define DIAG_EVENT_BUFFER_CAPACITY 64\n\ntypedef struct {\n    uint32_t event_timestamp;\n    uint16_t event_type;\n    int16_t event_value;\n    uint8_t event_status;\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diag_event_buffer[DIAG_EVENT_BUFFER_CAPACITY];\nstatic uint16_t g_event_write_ptr = 0;\nstatic uint16_t g_num_stored_events = 0;\n\nvoid init_diag_event_buffer_vulnerable() {\n    memset(g_diag_event_buffer, 0, sizeof(g_diag_event_buffer));\n    g_event_write_ptr = 0;\n    g_num_stored_events = 0;\n}\n\nbool add_diagnostic_event_vulnerable(uint32_t timestamp, uint16_t type, int16_t value) {\n    if (g_num_stored_events >= DIAG_EVENT_BUFFER_CAPACITY) {\n        return false;\n    }\n    g_diag_event_buffer[g_event_write_ptr].event_timestamp = timestamp;\n    g_diag_event_buffer[g_event_write_ptr].event_type = type;\n    g_diag_event_buffer[g_event_write_ptr].event_value = value;\n    g_diag_event_buffer[g_event_write_ptr].event_status = 0;\n    g_event_write_ptr = (g_event_write_ptr + 1) % DIAG_EVENT_BUFFER_CAPACITY;\n    g_num_stored_events++;\n    return true;\n}\n\nDiagnosticEvent* get_event_by_direct_index_vulnerable(uint16_t index) {\n    if (index >= DIAG_EVENT_BUFFER_CAPACITY || index >= g_num_stored_events) {\n        return NULL;\n    }\n    return &g_diag_event_buffer[index];\n}\n\nvoid update_event_status_by_relative_pointer_vulnerable(DiagnosticEvent* current_event_ptr, int16_t relative_steps_back, uint8_t new_status) {\n    if (current_event_ptr == NULL) {\n        return;\n    }\n\n    DiagnosticEvent* target_event_ptr = current_event_ptr - relative_steps_back;\n\n    target_event_ptr->event_status = new_status;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define COMPONENT_STATE_BUFFER_SIZE 512\n#define MAX_STATE_DATA_SEGMENTS 10\n\nstatic uint8_t g_componentStateBuffer[COMPONENT_STATE_BUFFER_SIZE];\n\ntypedef struct {\n    uint8_t segment_id;\n    uint16_t segment_offset;\n    uint8_t segment_length;\n} StateSegmentDescriptor;\n\nstatic const StateSegmentDescriptor g_stateDescriptors[MAX_STATE_DATA_SEGMENTS] = {\n    {0x01, 0,   10},\n    {0x02, 10,  20},\n    {0x03, 30,  15},\n    {0x04, 45,  5},\n    {0x05, 50,  100},\n    {0x06, 150, 10},\n    {0x07, 160, 200},\n    {0x08, 360, 50},\n    {0x09, 410, 100},\n    {0x0A, 510, 3}\n};\n#define NUM_STATE_DESCRIPTORS (sizeof(g_stateDescriptors) / sizeof(StateSegmentDescriptor))\n\nvoid initializeComponentStates() {\n    memset(g_componentStateBuffer, 0, COMPONENT_STATE_BUFFER_SIZE);\n}\n\nint updateComponentStateSegment(uint8_t segment_id, const uint8_t* new_data, uint8_t new_data_len) {\n    if (new_data == NULL) {\n        return -1;\n    }\n\n    const StateSegmentDescriptor* target_desc = NULL;\n    for (int i = 0; i < NUM_STATE_DESCRIPTORS; ++i) {\n        if (g_stateDescriptors[i].segment_id == segment_id) {\n            target_desc = &g_stateDescriptors[i];\n            break;\n        }\n    }\n\n    if (target_desc == NULL) {\n        return -2;\n    }\n\n    if (new_data_len > target_desc->segment_length) {\n        return -3;\n    }\n\n    memcpy(g_componentStateBuffer + target_desc->segment_offset, new_data, new_data_len);\n\n    return 0;\n}\n\nvoid receiveComponentStateUpdate(uint8_t id, const uint8_t* data, uint8_t len) {\n    updateComponentStateSegment(id, data, len);\n}\n\nuint8_t getComponentStateByte(uint16_t index) {\n    if (index < COMPONENT_STATE_BUFFER_SIZE) {\n        return g_componentStateBuffer[index];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_STATE_BUFFER_SIZE_FIXED 256\n#define VEHICLE_STATE_CHUNK_SIZE_FIXED 20\n#define VEHICLE_STATE_HEADER_SIZE_FIXED 4\n\nstatic uint8_t g_vehicle_state_data_buffer_fixed[VEHICLE_STATE_BUFFER_SIZE_FIXED];\nstatic uint8_t* g_next_state_write_ptr_fixed = g_vehicle_state_data_buffer_fixed;\nstatic size_t g_current_state_entries_fixed = 0;\n\nvoid init_vehicle_state_manager_fixed() {\n    memset(g_vehicle_state_data_buffer_fixed, 0, sizeof(g_vehicle_state_data_buffer_fixed));\n    g_next_state_write_ptr_fixed = g_vehicle_state_data_buffer_fixed;\n    g_current_state_entries_fixed = 0;\n}\n\nbool add_vehicle_state_entry_fixed(uint8_t status, const uint8_t* state_data) {\n    if (g_next_state_write_ptr_fixed + VEHICLE_STATE_HEADER_SIZE_FIXED + VEHICLE_STATE_CHUNK_SIZE_FIXED >\n        g_vehicle_state_data_buffer_fixed + VEHICLE_STATE_BUFFER_SIZE_FIXED) {\n        return false;\n    }\n\n    *g_next_state_write_ptr_fixed = status;\n    *(g_next_state_write_ptr_fixed + 1) = 0xDE;\n    *(g_next_state_write_ptr_fixed + 2) = 0xAD;\n    *(g_next_state_write_ptr_fixed + 3) = 0xBE;\n\n    memcpy(g_next_state_write_ptr_fixed + VEHICLE_STATE_HEADER_SIZE_FIXED, state_data, VEHICLE_STATE_CHUNK_SIZE_FIXED);\n\n    g_next_state_write_ptr_fixed += (VEHICLE_STATE_HEADER_SIZE_FIXED + VEHICLE_STATE_CHUNK_SIZE_FIXED);\n    g_current_state_entries_fixed++;\n    return true;\n}\n\nvoid invalidate_oldest_vehicle_state_fixed(uint32_t entries_to_invalidate_from_end) {\n    if (g_current_state_entries_fixed == 0 || entries_to_invalidate_from_end == 0) {\n        return;\n    }\n\n    uint32_t actual_entries_to_invalidate = entries_to_invalidate_from_end;\n    if (actual_entries_to_invalidate > g_current_state_entries_fixed) {\n        actual_entries_to_invalidate = g_current_state_entries_fixed;\n    }\n\n    size_t entry_total_size = VEHICLE_STATE_HEADER_SIZE_FIXED + VEHICLE_STATE_CHUNK_SIZE_FIXED;\n\n    int32_t byte_offset_from_end = (int32_t)actual_entries_to_invalidate * entry_total_size;\n\n    uint8_t* target_entry_header_ptr = g_next_state_write_ptr_fixed - byte_offset_from_end;\n\n    if (target_entry_header_ptr >= g_vehicle_state_data_buffer_fixed) {\n        *target_entry_header_ptr = 0x00;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMAND_LOG_ENTRIES 64\n#define LOG_ENTRY_WORD_SIZE 2\n\nstatic uint16_t g_command_log_buffer[MAX_COMMAND_LOG_ENTRIES * LOG_ENTRY_WORD_SIZE];\nstatic uint32_t g_log_current_idx = 0;\n\nvoid init_command_logger() {\n    memset(g_command_log_buffer, 0, sizeof(g_command_log_buffer));\n    g_log_current_idx = 0;\n}\n\nbool log_command_execution(uint16_t command_id, uint16_t timestamp_ms) {\n    if (g_log_current_idx + LOG_ENTRY_WORD_SIZE > MAX_COMMAND_LOG_ENTRIES * LOG_ENTRY_WORD_SIZE) {\n        return false;\n    }\n    g_command_log_buffer[g_log_current_idx] = command_id;\n    g_command_log_buffer[g_log_current_idx + 1] = timestamp_ms;\n    g_log_current_idx += LOG_ENTRY_WORD_SIZE;\n    return true;\n}\n\nvoid process_log_entry_conceptually(uint16_t cmd_id, uint16_t ts) {\n    volatile uint16_t dummy_cmd = cmd_id;\n    volatile uint16_t dummy_ts = ts;\n    (void)dummy_cmd;\n    (void)dummy_ts;\n}\n\nvoid clear_log_segment_and_mark_boundary_vulnerable(int32_t offset_from_end_words, uint32_t words_to_clear) {\n    if (g_log_current_idx == 0 || words_to_clear == 0) {\n        return;\n    }\n\n    int32_t segment_start_idx = (int32_t)g_log_current_idx - offset_from_end_words;\n\n    uint32_t actual_words_to_clear = words_to_clear;\n    if (segment_start_idx < 0) {\n        if (segment_start_idx + (int32_t)words_to_clear < 0) {\n            actual_words_to_clear = 0;\n        } else {\n            actual_words_to_clear = words_to_clear + segment_start_idx;\n            if (actual_words_to_clear < 0) actual_words_to_clear = 0;\n            segment_start_idx = 0;\n        }\n    }\n    \n    for (uint32_t i = 0; i < actual_words_to_clear; ++i) {\n        if (segment_start_idx + i < (int32_t)(MAX_COMMAND_LOG_ENTRIES * LOG_ENTRY_WORD_SIZE)) {\n            g_command_log_buffer[segment_start_idx + i] = 0x0000;\n        }\n    }\n\n    g_command_log_buffer[segment_start_idx - 1] = 0xC0DE;\n\n    g_log_current_idx = (uint32_t)segment_start_idx;\n    process_log_entry_conceptually(g_command_log_buffer[g_log_current_idx], g_command_log_buffer[g_log_current_idx + 1]);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_CONFIG_STATES 10\n#define CONFIG_DATA_BLOCK_SIZE 24\n#define CONFIG_VERSION_BYTE_SIZE 1\n#define CONFIG_STATE_TOTAL_SIZE (CONFIG_VERSION_BYTE_SIZE + CONFIG_DATA_BLOCK_SIZE)\n\nstatic uint8_t g_config_state_storage_fixed[MAX_CONFIG_STATES * CONFIG_STATE_TOTAL_SIZE];\nstatic int16_t g_current_active_config_idx_fixed = 0;\n\nvoid init_config_storage_fixed() {\n    memset(g_config_state_storage_fixed, 0, sizeof(g_config_state_storage_fixed));\n    g_current_active_config_idx_fixed = 0;\n    for (int i = 0; i < MAX_CONFIG_STATES; ++i) {\n        g_config_state_storage_fixed[i * CONFIG_STATE_TOTAL_SIZE] = 0x00;\n    }\n}\n\nbool store_config_state_fixed(const uint8_t* config_data, uint8_t version) {\n    if (config_data == NULL || version == 0x00) {\n        return false;\n    }\n    if (g_current_active_config_idx_fixed >= MAX_CONFIG_STATES) {\n        return false;\n    }\n\n    uint32_t write_offset = g_current_active_config_idx_fixed * CONFIG_STATE_TOTAL_SIZE;\n    g_config_state_storage_fixed[write_offset] = version;\n    memcpy(&g_config_state_storage_fixed[write_offset + CONFIG_VERSION_BYTE_SIZE], config_data, CONFIG_DATA_BLOCK_SIZE);\n\n    g_current_active_config_idx_fixed++;\n    return true;\n}\n\nvoid decrement_config_version_fixed(uint16_t offset_from_current) {\n    if (g_current_active_config_idx_fixed == 0 || offset_from_current == 0) {\n        return;\n    }\n\n    int32_t target_logical_idx = (g_current_active_config_idx_fixed - 1) - offset_from_current;\n\n    if (target_logical_idx < 0 || target_logical_idx >= MAX_CONFIG_STATES) {\n        return;\n    }\n\n    uint8_t current_version = g_config_state_storage_fixed[target_logical_idx * CONFIG_STATE_TOTAL_SIZE];\n    if (current_version > 0x01) {\n        g_config_state_storage_fixed[target_logical_idx * CONFIG_STATE_TOTAL_SIZE] = current_version - 1;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stddef.h>\n\ntypedef struct {\n    unsigned int message_id;\n    unsigned char data[8];\n    unsigned char data_length;\n    unsigned long long timestamp_us;\n} CanMessage;\n\n#define MAX_CAN_LOG_ENTRIES 256\nstatic CanMessage message_log_buffer[MAX_CAN_LOG_ENTRIES];\nstatic unsigned int latest_entry_index = 0;\n\nvoid logCanMessage(const CanMessage* msg) {\n    if (msg == NULL) {\n        return;\n    }\n    message_log_buffer[latest_entry_index] = *msg;\n    latest_entry_index = (latest_entry_index + 1) % MAX_CAN_LOG_ENTRIES;\n}\n\ntypedef enum {\n    DIAG_GET_STATUS,\n    DIAG_RETRIEVE_PAST_MESSAGE,\n    DIAG_OVERWRITE_HISTORICAL_MESSAGE,\n    DIAG_PERFORM_CHECKSUM_CALC\n} DiagnosticCommandType;\n\ntypedef struct {\n    DiagnosticCommandType type;\n    int historical_offset_steps;\n    CanMessage payload_data;\n} DiagnosticCommand;\n\nvoid processDiagnosticCommand_Fixed(const DiagnosticCommand* cmd) {\n    if (cmd == NULL) {\n        return;\n    }\n\n    switch (cmd->type) {\n        case DIAG_OVERWRITE_HISTORICAL_MESSAGE: {\n            unsigned int current_head_idx = (latest_entry_index == 0) ? (MAX_CAN_LOG_ENTRIES - 1) : (latest_entry_index - 1);\n\n            if (cmd->historical_offset_steps < 0 || cmd->historical_offset_steps >= MAX_CAN_LOG_ENTRIES) {\n                return;\n            }\n\n            unsigned int target_idx_safe = (current_head_idx - (unsigned int)cmd->historical_offset_steps + MAX_CAN_LOG_ENTRIES) % MAX_CAN_LOG_ENTRIES;\n\n            message_log_buffer[target_idx_safe] = cmd->payload_data;\n\n            break;\n        }\n        case DIAG_RETRIEVE_PAST_MESSAGE:\n            break;\n        case DIAG_GET_STATUS:\n            break;\n        case DIAG_PERFORM_CHECKSUM_CALC:\n            break;\n        default:\n            break;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_COMPONENTS 10\n#define MAX_ERROR_CODES_PER_COMPONENT 20\n#define MAX_DTC_SEVERITY_LEVELS 3\n\ntypedef struct {\n    uint32_t handler_id;\n    uint8_t  alert_level;\n    bool     triggers_limp_mode;\n} SeverityHandlerConfig;\n\nstatic SeverityHandlerConfig g_severityHandlers[MAX_DTC_SEVERITY_LEVELS];\n\ntypedef struct {\n    uint16_t code_value;\n    uint32_t timestamp;\n    uint8_t  severity_raw;\n    bool     active;\n} ComponentDTCLogEntry;\n\nstatic ComponentDTCLogEntry g_engineDTCLog[MAX_ERROR_CODES_PER_COMPONENT];\n\nvoid automotiveLogger_vulnerable(const char* message) {\n}\n\nComponentDTCLogEntry getNewDTCReport_vulnerable() {\n    ComponentDTCLogEntry report;\n    report.code_value = 0x01A2;\n    report.timestamp = 0xABCDEFFF;\n    report.severity_raw = 3;\n    report.active = true;\n    return report;\n}\n\nvoid initializeDiagnosticSystem_vulnerable() {\n    g_severityHandlers[0] = (SeverityHandlerConfig){0x1000, 1, false};\n    g_severityHandlers[1] = (SeverityHandlerConfig){0x2000, 5, false};\n    g_severityHandlers[2] = (SeverityHandlerConfig){0x3000, 10, true};\n\n    for (uint8_t i = 0; i < MAX_ERROR_CODES_PER_COMPONENT; ++i) {\n        g_engineDTCLog[i] = (ComponentDTCLogEntry){0, 0, 0, false};\n    }\n    automotiveLogger_vulnerable(\"Diagnostic system initialized (vulnerable).\");\n}\n\nvoid processNewDTCReport_vulnerable(ComponentDTCLogEntry new_dtc) {\n    uint8_t log_idx = new_dtc.code_value % MAX_ERROR_CODES_PER_COMPONENT;\n\n    g_engineDTCLog[log_idx] = new_dtc;\n\n    SeverityHandlerConfig current_handler_config = g_severityHandlers[new_dtc.severity_raw];\n\n    automotiveLogger_vulnerable(\"DTC processed. Attempting to apply handler config.\");\n\n    if (current_handler_config.triggers_limp_mode) {\n        automotiveLogger_vulnerable(\"Limp mode triggered by DTC (vulnerable).\");\n    } else {\n        automotiveLogger_vulnerable(\"DTC handler applied without limp mode (vulnerable).\");\n    }\n}\n\nvoid diagnosticServiceMain_vulnerable() {\n    initializeDiagnosticSystem_vulnerable();\n    ComponentDTCLogEntry report = getNewDTCReport_vulnerable();\n    processNewDTCReport_vulnerable(report);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_VEHICLE_EVENT_TYPES 5\n#define EVENT_PAYLOAD_SIZE 8\n\nvoid logSystemError(const char* msg) {\n}\n\ntypedef enum {\n    EVENT_TYPE_IGNITION_ON = 0,\n    EVENT_TYPE_GEAR_CHANGE,\n    EVENT_TYPE_DOOR_OPEN,\n    EVENT_TYPE_BRAKE_PEDAL,\n    EVENT_TYPE_ACCELERATOR_PEDAL\n} VehicleEventType;\n\ntypedef struct {\n    uint8_t eventType;\n    uint8_t payload[EVENT_PAYLOAD_SIZE];\n} VehicleEvent;\n\nvoid handleIgnitionOn(const uint8_t* payload) {\n}\n\nvoid handleGearChange(const uint8_t* payload) {\n}\n\nvoid handleDoorOpen(const uint8_t* payload) {\n}\n\nvoid handleBrakePedal(const uint8_t* payload) {\n}\n\nvoid handleAcceleratorPedal(const uint8_t* payload) {\n}\n\nvoid (*g_fixedEventHandlers[MAX_VEHICLE_EVENT_TYPES])(const uint8_t* payload) = {\n    handleIgnitionOn,\n    handleGearChange,\n    handleDoorOpen,\n    handleBrakePedal,\n    handleAcceleratorPedal\n};\n\nVehicleEvent getNextVehicleEvent_fixed() {\n    VehicleEvent event;\n    event.eventType = MAX_VEHICLE_EVENT_TYPES; \n    event.payload[0] = 0xFF;\n    for (int i = 1; i < EVENT_PAYLOAD_SIZE; ++i) {\n        event.payload[i] = 0;\n    }\n    return event;\n}\n\nvoid processVehicleEvent_fixed() {\n    VehicleEvent currentEvent = getNextVehicleEvent_fixed();\n\n    if (currentEvent.eventType < MAX_VEHICLE_EVENT_TYPES) {\n        g_fixedEventHandlers[currentEvent.eventType](currentEvent.payload);\n    } else {\n        logSystemError(\"Received invalid vehicle event type. Index out of bounds.\");\n    }\n}\n\nvoid automotiveECU_fixed_main() {\n    processVehicleEvent_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define REASM_BUFFER_SIZE 256\n#define MIN_MESSAGE_HEADER_SIZE 4\n\ntypedef struct {\n    uint16_t id;\n    uint16_t length;\n    uint8_t  payload[1];\n} MessageHeader;\n\nstatic uint8_t g_reasm_buffer_fixed[REASM_BUFFER_SIZE];\nstatic uint16_t g_filled_size_fixed = 0;\n\nvoid init_reasm_buffer_fixed() {\n    memset(g_reasm_buffer_fixed, 0, REASM_BUFFER_SIZE);\n    g_filled_size_fixed = 0;\n}\n\nbool add_reasm_data_fixed(const uint8_t* data, uint16_t len) {\n    if (g_filled_size_fixed + len > REASM_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_reasm_buffer_fixed + g_filled_size_fixed, data, len);\n    g_filled_size_fixed += len;\n    return true;\n}\n\nvoid finalize_message_block_fixed(int16_t message_start_offset) {\n    if (message_start_offset < 0 || message_start_offset >= g_filled_size_fixed) {\n        return;\n    }\n\n    if (message_start_offset + MIN_MESSAGE_HEADER_SIZE > g_filled_size_fixed) {\n        return;\n    }\n\n    MessageHeader* msg_header = (MessageHeader*)(g_reasm_buffer_fixed + message_start_offset);\n    uint16_t message_length = msg_header->length;\n\n    if (message_start_offset + message_length > g_filled_size_fixed || message_length == 0) {\n        return;\n    }\n\n    uint8_t calculated_status_byte = 0xAF;\n\n    if (message_start_offset - 1 < 0) {\n        return; \n    }\n\n    g_reasm_buffer_fixed[message_start_offset - 1] = calculated_status_byte;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_DRIVER_PROFILES 5\n\ntypedef struct {\n    int seat_position;\n    int mirror_angle;\n    int climate_temp_celsius;\n    bool preferred_lighting;\n} DriverProfile;\n\nstatic DriverProfile g_driverProfiles[MAX_DRIVER_PROFILES];\n\nvoid logSystemEvent(const char* event) {\n    printf(\"LOG: %s\\n\", event);\n}\n\nvoid logSystemError(const char* error) {\n    fprintf(stderr, \"ERROR: %s\\n\", error);\n}\n\ntypedef struct {\n    uint8_t profileId;\n    int16_t newSeatPosition;\n    int16_t newMirrorAngle;\n    int8_t newClimateTempCelsius;\n    bool newPreferredLighting;\n} ProfileUpdateCommand;\n\nProfileUpdateCommand receiveProfileUpdateCommand_vulnerable() {\n    ProfileUpdateCommand cmd;\n    cmd.profileId = 5; \n    cmd.newSeatPosition = 150; \n    cmd.newMirrorAngle = 30; \n    cmd.newClimateTempCelsius = 22; \n    cmd.newPreferredLighting = true; \n    logSystemEvent(\"Simulating reception of profile update command (vulnerable).\");\n    return cmd;\n}\n\nvoid initializeDriverProfiles_vulnerable() {\n    for (uint8_t i = 0; i < MAX_DRIVER_PROFILES; ++i) {\n        g_driverProfiles[i].seat_position = 0;\n        g_driverProfiles[i].mirror_angle = 0;\n        g_driverProfiles[i].climate_temp_celsius = 20;\n        g_driverProfiles[i].preferred_lighting = false;\n    }\n    logSystemEvent(\"Driver profiles initialized (vulnerable).\");\n}\n\nvoid updateDriverProfile_vulnerable() {\n    ProfileUpdateCommand command = receiveProfileUpdateCommand_vulnerable();\n\n    g_driverProfiles[command.profileId].seat_position = command.newSeatPosition;\n    g_driverProfiles[command.profileId].mirror_angle = command.newMirrorAngle;\n    g_driverProfiles[command.profileId].climate_temp_celsius = command.newClimateTempCelsius;\n    g_driverProfiles[command.profileId].preferred_lighting = command.newPreferredLighting;\n\n    logSystemEvent(\"Driver profile updated (vulnerable).\");\n}\n\nvoid driverProfileManager_vulnerable_main() {\n    initializeDriverProfiles_vulnerable();\n    updateDriverProfile_vulnerable();\n}\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_SETTINGS_BUFFER_SIZE 128\n#define MAX_SETTINGS_COMMAND_PAYLOAD_SIZE 64\n#define SETTINGS_COMMAND_ID_UPDATE 0x01\n\nstatic uint8_t g_vehicleSettings[VEHICLE_SETTINGS_BUFFER_SIZE];\n\nvoid initVehicleSettings() {\n    memset(g_vehicleSettings, 0, VEHICLE_SETTINGS_BUFFER_SIZE);\n    for (uint8_t i = 0; i < VEHICLE_SETTINGS_BUFFER_SIZE; ++i) {\n        g_vehicleSettings[i] = (uint8_t)(i % 0xFF);\n    }\n}\n\nint applyVehicleSettingsCommand(const uint8_t* raw_command_packet, uint16_t packet_length) {\n    if (raw_command_packet == NULL || packet_length < 4) {\n        return -1;\n    }\n\n    uint8_t command_id = raw_command_packet[0];\n    if (command_id != SETTINGS_COMMAND_ID_UPDATE) {\n        return -2;\n    }\n\n    uint8_t target_start_address = raw_command_packet[1];\n    uint8_t data_block_length = raw_command_packet[2];\n\n    if (data_block_length > MAX_SETTINGS_COMMAND_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    if (packet_length < (3 + data_block_length)) {\n        return -4;\n    }\n    \n    if (target_start_address >= VEHICLE_SETTINGS_BUFFER_SIZE || \n        (uint16_t)target_start_address + data_block_length > VEHICLE_SETTINGS_BUFFER_SIZE) {\n        return -5;\n    }\n\n    for (uint8_t i = 0; i < data_block_length; ++i) {\n        g_vehicleSettings[target_start_address + i] = raw_command_packet[3 + i];\n    }\n\n    return 0;\n}\n\nvoid receiveSettingsUpdateMessage(const uint8_t* message, uint16_t length) {\n    initVehicleSettings();\n    applyVehicleSettingsCommand(message, length);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n#include <limits>\n\n// Represents a raw sensor data packet header received over a bus.\nstruct RawSensorPacketHeader {\n    uint16_t packet_id;\n    uint16_t num_readings; // Number of uint16_t readings following the header\n    uint32_t checksum;     // Simple checksum for integrity\n};\n\n// Class to process raw sensor data into floating-point format for internal use.\nclass SensorDataProcessorFixed {\npublic:\n    SensorDataProcessorFixed() : m_processed_data(nullptr), m_num_elements(0), m_allocated_bytes(0) {}\n\n    ~SensorDataProcessorFixed() {\n        if (m_processed_data) {\n            free(m_processed_data);\n            m_processed_data = nullptr;\n        }\n    }\n\n    // Processes a raw sensor data packet, converting uint16_t readings to float.\n    // FIX: Correctly allocates buffer based on target data type size (float).\n    bool processRawSensorDataFixed(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(RawSensorPacketHeader)) {\n            return false;\n        }\n\n        const RawSensorPacketHeader* header = reinterpret_cast<const RawSensorPacketHeader*>(raw_packet);\n\n        if (header->packet_id != 0xABCD) {\n            return false;\n        }\n\n        // Basic sanity check on packet length for the raw data payload\n        if (header->num_readings > (std::numeric_limits<size_t>::max() / sizeof(uint16_t))) {\n            return false; // Prevent integer overflow for this length calculation\n        }\n        size_t expected_raw_data_size = static_cast<size_t>(header->num_readings) * sizeof(uint16_t);\n\n        if (packet_length < sizeof(RawSensorPacketHeader) + expected_raw_data_size) {\n            return false;\n        }\n\n        // Free existing buffer if any\n        if (m_processed_data) {\n            free(m_processed_data);\n            m_processed_data = nullptr;\n        }\n\n        // FIX:\n        // The allocation size is now correctly calculated based on the *target* data type size (float).\n        // Also, add an integer overflow check for the multiplication.\n        if (header->num_readings > (std::numeric_limits<size_t>::max() / sizeof(float))) {\n            return false; // Prevent integer overflow during allocation size calculation\n        }\n        m_allocated_bytes = static_cast<size_t>(header->num_readings) * sizeof(float);\n        \n        m_processed_data = (float*)malloc(m_allocated_bytes);\n        if (!m_processed_data && m_allocated_bytes > 0) { // If allocation fails for non-zero size\n            return false;\n        }\n        \n        m_num_elements = header->num_readings;\n\n        const uint16_t* raw_readings_ptr = reinterpret_cast<const uint16_t*>(raw_packet + sizeof(RawSensorPacketHeader));\n\n        for (uint16_t i = 0; i < m_num_elements; ++i) {\n            // Now, m_processed_data is allocated with enough space for 'float' elements,\n            // so accessing m_processed_data[i] will be within bounds.\n            m_processed_data[i] = static_cast<float>(raw_readings_ptr[i]);\n        }\n\n        // Additional check for checksum\n        uint32_t calculated_checksum = 0;\n        for (uint16_t i = 0; i < header->num_readings; ++i) {\n            calculated_checksum += raw_readings_ptr[i];\n        }\n        if (calculated_checksum != header->checksum) {\n            if (m_processed_data) {\n                free(m_processed_data);\n                m_processed_data = nullptr;\n            }\n            m_num_elements = 0;\n            m_allocated_bytes = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const float* getProcessedData() const { return m_processed_data; }\n    uint16_t getNumElements() const { return m_num_elements; }\n\nprivate:\n    float*   m_processed_data;\n    uint16_t m_num_elements;\n    size_t   m_allocated_bytes;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_MESSAGE_BUFFER_SIZE 16\n#define MAX_MESSAGE_LEN 64\n\ntypedef struct {\n    char message[MAX_MESSAGE_LEN];\n    uint32_t timestamp;\n    bool processed;\n    uint8_t status_flags;\n} DiagnosticMessage;\n\nstatic DiagnosticMessage g_diag_message_buffer[DIAG_MESSAGE_BUFFER_SIZE];\nstatic uint8_t g_current_write_idx = 0;\nstatic uint8_t g_active_message_count = 0;\n\nvoid init_diag_system_vulnerable() {\n    for (uint8_t i = 0; i < DIAG_MESSAGE_BUFFER_SIZE; ++i) {\n        memset(&g_diag_message_buffer[i], 0, sizeof(DiagnosticMessage));\n        g_diag_message_buffer[i].processed = true;\n        g_diag_message_buffer[i].status_flags = 0x00;\n    }\n    g_current_write_idx = 0;\n    g_active_message_count = 0;\n}\n\nvoid add_diag_message_vulnerable(const char* msg_str, uint32_t timestamp) {\n    strncpy(g_diag_message_buffer[g_current_write_idx].message, msg_str, MAX_MESSAGE_LEN - 1);\n    g_diag_message_buffer[g_current_write_idx].message[MAX_MESSAGE_LEN - 1] = '\\0';\n    g_diag_message_buffer[g_current_write_idx].timestamp = timestamp;\n    g_diag_message_buffer[g_current_write_idx].processed = false;\n    g_diag_message_buffer[g_current_write_idx].status_flags = 0x01;\n\n    g_current_write_idx = (g_current_write_idx + 1) % DIAG_MESSAGE_BUFFER_SIZE;\n    if (g_active_message_count < DIAG_MESSAGE_BUFFER_SIZE) {\n        g_active_message_count++;\n    }\n}\n\nvoid revert_message_processing_vulnerable(int16_t messages_to_revert) {\n    if (messages_to_revert <= 0 || g_active_message_count == 0) {\n        return;\n    }\n\n    int16_t last_message_physical_idx = (g_current_write_idx == 0 && g_active_message_count == DIAG_MESSAGE_BUFFER_SIZE) ?\n                                        (DIAG_MESSAGE_BUFFER_SIZE - 1) : (g_current_write_idx - 1);\n\n    for (int16_t i = 0; i < messages_to_revert; ++i) {\n        int16_t target_idx = last_message_physical_idx - i;\n\n        g_diag_message_buffer[target_idx].processed = false;\n        g_diag_message_buffer[target_idx].status_flags = 0x02;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_DATA_BUFFER_SIZE 512\n#define MAX_DIAG_FRAME_SIZE 256\n#define FRAME_LENGTH_INDICATOR_OFFSET_FROM_END 2\n\nstatic uint8_t g_diag_raw_buffer[DIAG_DATA_BUFFER_SIZE];\nstatic uint32_t g_diag_buffer_current_len = 0;\n\nvoid receiveDiagData(const uint8_t* data, uint32_t len) {\n    if (len > DIAG_DATA_BUFFER_SIZE - g_diag_buffer_current_len) {\n        len = DIAG_DATA_BUFFER_SIZE - g_diag_buffer_current_len;\n    }\n    if (len > 0) {\n        memcpy(g_diag_raw_buffer + g_diag_buffer_current_len, data, len);\n        g_diag_buffer_current_len += len;\n    }\n}\n\nvoid processDiagFrame(const uint8_t* frame_data, uint32_t frame_len) {\n    if (frame_data && frame_len > 0) {\n        volatile uint8_t check_byte = frame_data[0];\n        (void)check_byte;\n    }\n}\n\nvoid extractLastDiagFrame_Fixed() {\n    if (g_diag_buffer_current_len < FRAME_LENGTH_INDICATOR_OFFSET_FROM_END) {\n        return;\n    }\n\n    uint8_t frame_total_len_indicator = g_diag_raw_buffer[g_diag_buffer_current_len - FRAME_LENGTH_INDICATOR_OFFSET_FROM_END];\n\n    int start_idx_signed = (int)g_diag_buffer_current_len - frame_total_len_indicator;\n\n    if (start_idx_signed < 0) {\n        return; \n    }\n\n    if (frame_total_len_indicator > MAX_DIAG_FRAME_SIZE ||\n        (uint32_t)start_idx_signed + frame_total_len_indicator > g_diag_buffer_current_len) {\n        return;\n    }\n\n    uint32_t frame_start_idx = (uint32_t)start_idx_signed;\n\n    uint8_t extracted_frame_buffer[MAX_DIAG_FRAME_SIZE];\n\n    if (frame_total_len_indicator > 0) {\n        g_diag_raw_buffer[frame_start_idx] = 0x00;\n    }\n\n    memcpy(extracted_frame_buffer, g_diag_raw_buffer + frame_start_idx, frame_total_len_indicator);\n    processDiagFrame(extracted_frame_buffer, frame_total_len_indicator);\n\n    g_diag_buffer_current_len -= frame_total_len_indicator;\n    if (g_diag_buffer_current_len < 0) g_diag_buffer_current_len = 0;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>#define MAX_LIGHT_ZONES 5typedef struct {uint8_t brightness;uint8_t red;uint8_t green;uint8_t blue;uint16_t fade_rate_ms;} LightConfig;static LightConfig g_zoneConfigs[MAX_LIGHT_ZONES];typedef struct {uint8_t command_type;uint8_t zone_id;LightConfig new_config;} LightingCommand;void logLightingError(const char* msg) {}void initializeLightingSystem() {for (int i = 0; i < MAX_LIGHT_ZONES; ++i) {g_zoneConfigs[i].brightness = 50;g_zoneConfigs[i].red = 255;g_zoneConfigs[i].green = 255;g_zoneConfigs[i].blue = 255;g_zoneConfigs[i].fade_rate_ms = 100;}}LightingCommand getSimulatedLightingCommand_vulnerable() {LightingCommand cmd;cmd.command_type = 0x01;cmd.zone_id = 7;cmd.new_config.brightness = 100;cmd.new_config.red = 0;cmd.new_config.green = 255;cmd.new_config.blue = 0;cmd.new_config.fade_rate_ms = 500;return cmd;}void processLightingCommand_vulnerable(const LightingCommand* cmd) {if (cmd->command_type == 0x01) {g_zoneConfigs[cmd->zone_id] = cmd->new_config;} else {logLightingError(\"Unknown lighting command type.\");}}void lightingControlUnitMain_vulnerable() {initializeLightingSystem();LightingCommand cmd = getSimulatedLightingCommand_vulnerable();processLightingCommand_vulnerable(&cmd);}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_CAN_FRAME_DATA_LENGTH 8\n#define VEHICLE_STATE_SENSOR_ID 0x01\n#define TIRE_PRESSURE_SENSOR_ID 0x02\n#define FUEL_LEVEL_SENSOR_ID 0x03\n#define VEHICLE_DIAGNOSTIC_DATA_ID 0x04\n\n#define MAX_SENSOR_DATA_PAYLOAD 60 \n\n#define DIAGNOSTIC_STRING_BUFFER_SIZE 30\n\ntypedef struct {\n    uint8_t sensor_id;\n    uint8_t data_length; \n    uint8_t data[MAX_SENSOR_DATA_PAYLOAD]; \n} SensorPacketSegment;\n\nint processSensorTelemetryStream(const uint8_t* msg_buffer, uint16_t msg_len) {\n    if (msg_buffer == NULL || msg_len < (sizeof(uint8_t) * 2)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    while (current_offset < msg_len) {\n        if (current_offset + sizeof(uint8_t) * 2 > msg_len) {\n            return -2;\n        }\n\n        uint8_t sensor_id = msg_buffer[current_offset];\n        uint8_t data_len = msg_buffer[current_offset + 1];\n\n        if (current_offset + sizeof(uint8_t) * 2 + data_len > msg_len) {\n            return -3;\n        }\n        \n        const uint8_t* sensor_data_ptr = msg_buffer + current_offset + sizeof(uint8_t) * 2;\n\n        if (sensor_id == VEHICLE_DIAGNOSTIC_DATA_ID) {\n            char diagnostic_buffer[DIAGNOSTIC_STRING_BUFFER_SIZE];\n            memset(diagnostic_buffer, 0, DIAGNOSTIC_STRING_BUFFER_SIZE); \n\n            for (int i = 0; i < data_len; ++i) {\n                diagnostic_buffer[i] = (char)sensor_data_ptr[i];\n            }\n            diagnostic_buffer[data_len] = '\\0'; \n\n        }\n\n        current_offset += (sizeof(uint8_t) * 2 + data_len);\n    }\n\n    return 0;\n}\n\nvoid handleTelemetryStream(const uint8_t* stream, uint16_t len) {\n    processSensorTelemetryStream(stream, len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_MODES 3\n#define MAX_PARAMS_PER_MODE 10\n\ntypedef enum {\n    MODE_ECO_FIXED = 0,\n    MODE_SPORT_FIXED,\n    MODE_OFFROAD_FIXED,\n    MODE_COUNT_FIXED\n} VehicleMode_Fixed;\n\ntypedef struct {\n    uint16_t id;\n    uint16_t value;\n    bool configurable;\n} VehicleParameter_Fixed;\n\nstatic VehicleParameter_Fixed g_vehicleModeParameters_fixed[MAX_VEHICLE_MODES][MAX_PARAMS_PER_MODE];\n\nstatic uint8_t g_activeParamCounts_fixed[MAX_VEHICLE_MODES];\n\nvoid vehicle_log_fixed(const char* msg) {\n    fprintf(stderr, \"FIXED_LOG: %s\\n\", msg);\n}\n\nvoid initializeVehicleParameters_fixed() {\n    for (uint8_t i = 0; i < MAX_VEHICLE_MODES; ++i) {\n        for (uint8_t j = 0; j < MAX_PARAMS_PER_MODE; ++j) {\n            g_vehicleModeParameters_fixed[i][j] = (VehicleParameter_Fixed){0, 0, false};\n        }\n        g_activeParamCounts_fixed[i] = 0;\n    }\n\n    g_vehicleModeParameters_fixed[MODE_ECO_FIXED][0] = (VehicleParameter_Fixed){0x0001, 100, true};\n    g_vehicleModeParameters_fixed[MODE_ECO_FIXED][1] = (VehicleParameter_Fixed){0x0002, 50, true};\n    g_vehicleModeParameters_fixed[MODE_ECO_FIXED][2] = (VehicleParameter_Fixed){0x0003, 1, false};\n    g_activeParamCounts_fixed[MODE_ECO_FIXED] = 3;\n\n    g_vehicleModeParameters_fixed[MODE_SPORT_FIXED][0] = (VehicleParameter_Fixed){0x0001, 250, true};\n    g_vehicleModeParameters_fixed[MODE_SPORT_FIXED][1] = (VehicleParameter_Fixed){0x0002, 90, true};\n    g_vehicleModeParameters_fixed[MODE_SPORT_FIXED][2] = (VehicleParameter_Fixed){0x0003, 0, false};\n    g_vehicleModeParameters_fixed[MODE_SPORT_FIXED][3] = (VehicleParameter_Fixed){0x0004, 1, true};\n    g_activeParamCounts_fixed[MODE_SPORT_FIXED] = 4;\n\n    g_vehicleModeParameters_fixed[MODE_OFFROAD_FIXED][0] = (VehicleParameter_Fixed){0x0001, 80, true};\n    g_vehicleModeParameters_fixed[MODE_OFFROAD_FIXED][1] = (VehicleParameter_Fixed){0x0002, 70, true};\n    g_vehicleModeParameters_fixed[MODE_OFFROAD_FIXED][2] = (VehicleParameter_Fixed){0x0005, 1, true};\n    g_activeParamCounts_fixed[MODE_OFFROAD_FIXED] = 3;\n\n    vehicle_log_fixed(\"Vehicle parameter system initialized (fixed).\");\n}\n\ntypedef struct {\n    uint8_t mode;\n    uint8_t param_idx;\n    uint16_t new_val;\n} RemoteUpdateCommand_Fixed;\n\nRemoteUpdateCommand_Fixed getRemoteUpdateCommand_fixed() {\n    RemoteUpdateCommand_Fixed cmd;\n    cmd.mode = MODE_ECO_FIXED;\n    cmd.param_idx = 5;\n    cmd.new_val = 0xDEAD;\n    return cmd;\n}\n\nvoid processRemoteParameterUpdate_fixed() {\n    RemoteUpdateCommand_Fixed cmd = getRemoteUpdateCommand_fixed();\n\n    if (cmd.mode < MODE_COUNT_FIXED) {\n        if (cmd.param_idx < g_activeParamCounts_fixed[cmd.mode]) {\n            if (g_vehicleModeParameters_fixed[cmd.mode][cmd.param_idx].configurable) {\n                g_vehicleModeParameters_fixed[cmd.mode][cmd.param_idx].value = cmd.new_val;\n                vehicle_log_fixed(\"Vehicle parameter updated successfully (fixed).\");\n            } else {\n                vehicle_log_fixed(\"Attempted to update non-configurable parameter (fixed).\");\n            }\n        } else {\n            vehicle_log_fixed(\"Parameter index out of active parameters bounds for this mode (fixed).\");\n        }\n    } else {\n        vehicle_log_fixed(\"Invalid vehicle mode ID (fixed).\");\n    }\n}\n\nvoid main_fixed_system() {\n    initializeVehicleParameters_fixed();\n    processRemoteParameterUpdate_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define DTC_TYPE_ENGINE 0\n#define DTC_TYPE_TRANSMISSION 1\n#define DTC_TYPE_BRAKE 2\n#define MAX_DTC_TYPES 3\n\n#define GLOBAL_MAX_INSTANCES_PER_DTC 5\n\ntypedef struct {\n    uint16_t code;\n    uint8_t  instance_id;\n    uint32_t timestamp;\n    uint8_t  status;\n} DTC_Entry;\n\nstatic DTC_Entry g_dtcHistory_fixed[MAX_DTC_TYPES][GLOBAL_MAX_INSTANCES_PER_DTC];\n\nstatic const uint8_t g_dtcCapacities_fixed[MAX_DTC_TYPES] = {\n    3, \n    2, \n    4  \n};\n\nvoid logECUError_fixed(const char* msg) {\n    fprintf(stderr, \"ECU_LOG_FIXED: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t dtc_type_id;\n    uint8_t instance_idx;\n    uint16_t dtc_code;\n    uint8_t dtc_status;\n} IncomingDTC_Message_Fixed;\n\nIncomingDTC_Message_Fixed receiveDiagnosticMessage_fixed() {\n    IncomingDTC_Message_Fixed msg;\n    msg.dtc_type_id = DTC_TYPE_TRANSMISSION;\n    msg.instance_idx = 2;\n    msg.dtc_code = 0xDEAD;\n    msg.dtc_status = 0x01;\n    return msg;\n}\n\nvoid initializeDTCStorage_fixed() {\n    for (uint8_t i = 0; i < MAX_DTC_TYPES; ++i) {\n        for (uint8_t j = 0; j < GLOBAL_MAX_INSTANCES_PER_DTC; ++j) {\n            g_dtcHistory_fixed[i][j] = (DTC_Entry){0, 0, 0, 0};\n        }\n    }\n    logECUError_fixed(\"DTC history storage initialized.\");\n}\n\nvoid processDiagnosticMessage_fixed() {\n    IncomingDTC_Message_Fixed msg = receiveDiagnosticMessage_fixed();\n    uint32_t current_timestamp = 12345;\n\n    if (msg.dtc_type_id < MAX_DTC_TYPES) {\n        if (msg.instance_idx < g_dtcCapacities_fixed[msg.dtc_type_id]) {\n            g_dtcHistory_fixed[msg.dtc_type_id][msg.instance_idx].code = msg.dtc_code;\n            g_dtcHistory_fixed[msg.dtc_type_id][msg.instance_idx].instance_id = msg.instance_idx;\n            g_dtcHistory_fixed[msg.dtc_type_id][msg.instance_idx].timestamp = current_timestamp;\n            g_dtcHistory_fixed[msg.dtc_type_id][msg.instance_idx].status = msg.dtc_status;\n            logECUError_fixed(\"DTC entry processed (fixed).\");\n        } else {\n            logECUError_fixed(\"DTC instance index out of bounds for specified DTC type. Ignoring message.\");\n        }\n    } else {\n        logECUError_fixed(\"Invalid DTC type ID received.\");\n    }\n}\n\nvoid automotiveDiagnosticModule_fixed_main() {\n    initializeDTCStorage_fixed();\n    processDiagnosticMessage_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_MAX_SIZE 256\n#define CONFIG_CHUNK_SIZE 16\n\nstatic uint8_t g_vehicle_config_store[VEHICLE_CONFIG_MAX_SIZE];\nstatic size_t g_current_config_size = 0;\n\nvoid init_vehicle_config_store() {\n    memset(g_vehicle_config_store, 0xFF, VEHICLE_CONFIG_MAX_SIZE);\n    g_current_config_size = 0;\n}\n\nbool write_config_chunk(const uint8_t* data, size_t len) {\n    if (len == 0 || len > CONFIG_CHUNK_SIZE || g_current_config_size + len > VEHICLE_CONFIG_MAX_SIZE) {\n        return false;\n    }\n    memcpy(g_vehicle_config_store + g_current_config_size, data, len);\n    g_current_config_size += len;\n    return true;\n}\n\nvoid purge_config_segment_Vulnerable(int16_t offset_chunks_from_end, uint16_t chunks_to_purge) {\n    if (g_current_config_size == 0 || chunks_to_purge == 0) {\n        return;\n    }\n\n    int32_t total_bytes_to_clear = (int32_t)chunks_to_purge * CONFIG_CHUNK_SIZE;\n\n    int32_t start_byte_to_clear = (int32_t)g_current_config_size - ((int32_t)offset_chunks_from_end * CONFIG_CHUNK_SIZE) - total_bytes_to_clear;\n\n    for (int32_t i = 0; i < total_bytes_to_clear; ++i) {\n        g_vehicle_config_store[start_byte_to_clear + i] = 0x00;\n    }\n}\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define ECU_REG_MAP_SIZE 100\n\nstatic uint8_t g_ecuRegisterMap[ECU_REG_MAP_SIZE];\n\nvoid initEcuRegisterMap() {\n    memset(g_ecuRegisterMap, 0, ECU_REG_MAP_SIZE);\n}\n\nint setEcuRegisterBitfield(uint8_t start_byte_offset, uint8_t start_bit_in_byte, uint8_t num_bits, uint16_t value) {\n    if (start_byte_offset >= ECU_REG_MAP_SIZE || start_bit_in_byte >= 8 || num_bits == 0) {\n        return -1;\n    }\n\n    uint16_t required_bytes_span = (uint16_t)start_bit_in_byte + num_bits;\n    uint8_t last_affected_byte_idx = start_byte_offset + (required_bytes_span - 1) / 8;\n\n    if (last_affected_byte_idx >= ECU_REG_MAP_SIZE) {\n        return -2;\n    }\n\n    uint16_t mask = (1 << num_bits) - 1;\n    if (num_bits > 16) {\n        mask = 0xFFFF;\n    }\n    value &= mask;\n\n    uint8_t current_byte_idx = start_byte_offset;\n    uint8_t bits_written = 0;\n    uint8_t bits_remaining_in_field = num_bits;\n\n    while (bits_remaining_in_field > 0) {\n        uint8_t bits_in_current_chunk;\n        if (bits_written == 0) {\n            bits_in_current_chunk = 8 - start_bit_in_byte;\n        } else {\n            bits_in_current_chunk = 8;\n            start_bit_in_byte = 0;\n        }\n        \n        if (bits_in_current_chunk > bits_remaining_in_field) {\n            bits_in_current_chunk = bits_remaining_in_field;\n        }\n        \n        uint8_t current_byte_value = g_ecuRegisterMap[current_byte_idx];\n\n        uint8_t local_mask = ((1 << bits_in_current_chunk) - 1) << start_bit_in_byte;\n        current_byte_value &= ~local_mask;\n\n        uint8_t value_part = (value >> bits_written) & ((1 << bits_in_current_chunk) - 1);\n        current_byte_value |= (value_part << start_bit_in_byte);\n\n        g_ecuRegisterMap[current_byte_idx] = current_byte_value;\n\n        bits_written += bits_in_current_chunk;\n        bits_remaining_in_field -= bits_in_current_chunk;\n        current_byte_idx++;\n    }\n\n    return 0;\n}\n\nvoid handleEcuConfigCommand(const uint8_t* command_payload, uint8_t payload_len) {\n    if (command_payload == NULL || payload_len < 4) {\n        return;\n    }\n\n    uint8_t byte_offset = command_payload[0];\n    uint8_t bit_offset = command_payload[1] & 0x07;\n    uint8_t num_bits = command_payload[2];\n\n    uint16_t value = 0;\n    if (payload_len >= 5) {\n        value = (command_payload[3] << 8) | command_payload[4];\n    } else if (payload_len == 4) {\n        value = command_payload[3];\n    }\n\n    setEcuRegisterBitfield(byte_offset, bit_offset, num_bits, value);\n}\n\nuint8_t getEcuRegisterByte(uint8_t offset) {\n    if (offset < ECU_REG_MAP_SIZE) {\n        return g_ecuRegisterMap[offset];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_DRIVING_PROFILES 3\n#define MAX_PARAMS_PER_PROFILE 10\n\ntypedef struct {\n    uint16_t value;\n    uint8_t type;\n} ProfileParameter;\n\ntypedef struct {\n    ProfileParameter params[MAX_PARAMS_PER_PROFILE];\n    uint8_t active_param_count;\n} DrivingProfile;\n\nstatic DrivingProfile g_drivingProfiles[MAX_DRIVING_PROFILES];\n\nvoid logSystemEvent(const char* message) {\n}\n\ntypedef struct {\n    uint8_t profile_idx;\n    uint8_t parameter_idx;\n    uint16_t new_param_value;\n} DiagnosticMessage;\n\nvoid initializeDrivingProfiles_fixed() {\n    g_drivingProfiles[0].active_param_count = 5;\n    for (int i = 0; i < g_drivingProfiles[0].active_param_count; ++i) {\n        g_drivingProfiles[0].params[i].value = 100 + i;\n        g_drivingProfiles[0].params[i].type = i % 2;\n    }\n\n    g_drivingProfiles[1].active_param_count = 8;\n    for (int i = 0; i < g_drivingProfiles[1].active_param_count; ++i) {\n        g_drivingProfiles[1].params[i].value = 200 + i;\n        g_drivingProfiles[1].params[i].type = i % 2;\n    }\n\n    g_drivingProfiles[2].active_param_count = 3;\n    for (int i = 0; i < g_drivingProfiles[2].active_param_count; ++i) {\n        g_drivingProfiles[2].params[i].value = 300 + i;\n        g_drivingProfiles[2].params[i].type = i % 2;\n    }\n\n    for (int p = 0; p < MAX_DRIVING_PROFILES; ++p) {\n        for (int i = g_drivingProfiles[p].active_param_count; i < MAX_PARAMS_PER_PROFILE; ++i) {\n            g_drivingProfiles[p].params[i].value = 0;\n            g_drivingProfiles[p].params[i].type = 0;\n        }\n    }\n    logSystemEvent(\"Driving profiles initialized (fixed).\");\n}\n\nDiagnosticMessage receiveDiagnosticMessage_fixed() {\n    DiagnosticMessage msg;\n    msg.profile_idx = 1;\n    msg.parameter_idx = 8;\n    msg.new_param_value = 0xABCD;\n    return msg;\n}\n\nvoid updateProfileParameter_fixed() {\n    DiagnosticMessage msg = receiveDiagnosticMessage_fixed();\n\n    if (msg.profile_idx < MAX_DRIVING_PROFILES) {\n        if (msg.parameter_idx < g_drivingProfiles[msg.profile_idx].active_param_count) {\n            g_drivingProfiles[msg.profile_idx].params[msg.parameter_idx].value = msg.new_param_value;\n            logSystemEvent(\"Profile parameter updated (fixed).\");\n        } else {\n            logSystemEvent(\"Parameter index out of actual bounds for selected profile (fixed).\");\n        }\n    } else {\n        logSystemEvent(\"Invalid profile index received (fixed).\");\n    }\n}\n\nvoid automotiveProfileManager_fixed_main() {\n    initializeDrivingProfiles_fixed();\n    updateProfileParameter_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#define MAX_SENSORS 128\n\ntypedef struct {\n    unsigned int timestamp;\n    int value;\n    unsigned char status;\n} SensorReading;\n\ntypedef struct {\n    unsigned int sensor_id;\n    unsigned int new_timestamp;\n    int new_value;\n    unsigned char new_status;\n} SensorUpdateCommand;\n\nstatic SensorReading g_sensorReadings[MAX_SENSORS];\n\nSensorUpdateCommand receiveSensorUpdateCommand_vulnerable() {\n    SensorUpdateCommand cmd;\n    cmd.sensor_id = 128;\n    cmd.new_timestamp = 1678886400;\n    cmd.new_value = 2500;\n    cmd.new_status = 0x01;\n    return cmd;\n}\n\nvoid processSensorUpdate_vulnerable() {\n    SensorUpdateCommand cmd = receiveSensorUpdateCommand_vulnerable();\n\n    g_sensorReadings[cmd.sensor_id].timestamp = cmd.new_timestamp;\n    g_sensorReadings[cmd.sensor_id].value = cmd.new_value;\n    g_sensorReadings[cmd.sensor_id].status = cmd.new_status;\n}\n\nvoid initializeSensorData_vulnerable() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        g_sensorReadings[i].timestamp = 0;\n        g_sensorReadings[i].value = 0;\n        g_sensorReadings[i].status = 0;\n    }\n}\n\nvoid sensorDataHandlerMain_vulnerable() {\n    initializeSensorData_vulnerable();\n    processSensorUpdate_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_BUFFER_SIZE 256\n#define MAX_TELEMETRY_PAYLOAD_LEN 8 \n\nstatic uint8_t g_telemetryDataBuffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_currentBufferWriteOffset = 0;\n\ntypedef enum {\n    TELEMETRY_TYPE_ENGINE_STATUS = 0,\n    TELEMETRY_TYPE_BATTERY_INFO,\n    TELEMETRY_TYPE_TIRE_PRESSURE,\n    TELEMETRY_TYPE_COUNT\n} TelemetryBlockType;\n\ntypedef struct {\n    uint8_t item_size;\n    uint8_t num_items;\n} TelemetryBlockMetadata;\n\nstatic const TelemetryBlockMetadata g_telemetryMetadata[TELEMETRY_TYPE_COUNT] = {\n    {10, 10}, \n    {5, 5},   \n    {8, 10}   \n};\n\nstatic uint16_t g_telemetryTypeBaseOffsets[TELEMETRY_TYPE_COUNT];\n\nvoid initTelemetrySystem() {\n    memset(g_telemetryDataBuffer, 0, TELEMETRY_BUFFER_SIZE);\n    g_currentBufferWriteOffset = 0;\n\n    uint16_t current_offset = 0;\n    for (int i = 0; i < TELEMETRY_TYPE_COUNT; ++i) {\n        g_telemetryTypeBaseOffsets[i] = current_offset;\n        current_offset += (uint16_t)g_telemetryMetadata[i].item_size * g_telemetryMetadata[i].num_items;\n    }\n    g_currentBufferWriteOffset = current_offset;\n}\n\nint updateTelemetryDataItem(TelemetryBlockType telemetry_type, uint8_t item_index, \n                            uint8_t update_offset, uint8_t data_len, const uint8_t* data_payload) {\n    \n    if (telemetry_type >= TELEMETRY_TYPE_COUNT || data_payload == NULL || data_len == 0) {\n        return -1;\n    }\n\n    if (item_index >= g_telemetryMetadata[telemetry_type].num_items) {\n        return -2;\n    }\n\n    if (data_len > MAX_TELEMETRY_PAYLOAD_LEN) {\n        return -3;\n    }\n\n    uint16_t item_base_addr = g_telemetryTypeBaseOffsets[telemetry_type] + \n                              (uint16_t)item_index * g_telemetryMetadata[telemetry_type].item_size;\n\n    uint16_t dest_offset = item_base_addr + update_offset;\n    \n    if (update_offset >= g_telemetryMetadata[telemetry_type].item_size) {\n        return -4;\n    }\n\n    if ((uint16_t)update_offset + data_len > g_telemetryMetadata[telemetry_type].item_size ||\n        dest_offset + data_len > TELEMETRY_BUFFER_SIZE) {\n        return -5;\n    }\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_telemetryDataBuffer[dest_offset + i] = data_payload[i];\n    }\n\n    return 0;\n}\n\nvoid simulateCanTelemetryUpdate(TelemetryBlockType type, uint8_t index, uint8_t offset, uint8_t len, const uint8_t* data) {\n    updateTelemetryDataItem(type, index, offset, len, data);\n}\n\nuint8_t getTelemetryDataByte(uint16_t global_offset) {\n    if (global_offset < TELEMETRY_BUFFER_SIZE) {\n        return g_telemetryDataBuffer[global_offset];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n#include <limits>\n#include <algorithm>\n\n#pragma pack(push, 1)\n\nstruct VehicleCommandHeader {\n    uint16_t command_id;\n    uint16_t data_length;\n};\n\nstruct CommandBatchHeader {\n    uint32_t batch_id;\n    uint16_t num_commands;\n    uint32_t total_payload_bytes;\n};\n\n#pragma pack(pop)\n\nclass CommandBatchProcessorFixed {\npublic:\n    CommandBatchProcessorFixed() : m_processed_batch_data(nullptr), m_processed_data_size(0) {}\n\n    ~CommandBatchProcessorFixed() {\n        if (m_processed_batch_data) {\n            delete[] m_processed_batch_data;\n            m_processed_batch_data = nullptr;\n        }\n    }\n\n    bool processCommandBatchFixed(const uint8_t* raw_batch_data, size_t raw_batch_data_len) {\n        if (!raw_batch_data || raw_batch_data_len < sizeof(CommandBatchHeader)) {\n            return false;\n        }\n\n        const CommandBatchHeader* batch_header = reinterpret_cast<const CommandBatchHeader*>(raw_batch_data);\n\n        static const uint16_t MAX_COMMANDS_IN_BATCH = 100;\n        if (batch_header->num_commands == 0 || batch_header->num_commands > MAX_COMMANDS_IN_BATCH) {\n            return false;\n        }\n\n        uint32_t calculated_total_required_size = 0;\n        size_t temp_raw_offset = sizeof(CommandBatchHeader);\n\n        for (uint16_t i = 0; i < batch_header->num_commands; ++i) {\n            if (temp_raw_offset + sizeof(VehicleCommandHeader) > raw_batch_data_len) {\n                return false;\n            }\n\n            const VehicleCommandHeader* cmd_header = reinterpret_cast<const VehicleCommandHeader*>(raw_batch_data + temp_raw_offset);\n            uint16_t current_cmd_data_len = cmd_header->data_length;\n\n            if (current_cmd_data_len > (std::numeric_limits<uint32_t>::max() - sizeof(VehicleCommandHeader) - calculated_total_required_size)) {\n                return false;\n            }\n\n            calculated_total_required_size += sizeof(VehicleCommandHeader) + current_cmd_data_len;\n\n            temp_raw_offset += sizeof(VehicleCommandHeader) + current_cmd_data_len;\n\n            if (temp_raw_offset > raw_batch_data_len) {\n                return false;\n            }\n        }\n\n        if (batch_header->total_payload_bytes != calculated_total_required_size) {\n            return false;\n        }\n\n        static const uint32_t MAX_BATCH_DATA_SIZE = 64 * 1024;\n        if (calculated_total_required_size == 0 || calculated_total_required_size > MAX_BATCH_DATA_SIZE) {\n            return false;\n        }\n\n        if (m_processed_batch_data) {\n            delete[] m_processed_batch_data;\n            m_processed_batch_data = nullptr;\n        }\n\n        m_processed_batch_data = new (std::nothrow) uint8_t[calculated_total_required_size];\n        if (!m_processed_batch_data) {\n            m_processed_data_size = 0;\n            return false;\n        }\n        m_processed_data_size = calculated_total_required_size;\n\n        size_t current_raw_offset = sizeof(CommandBatchHeader);\n        size_t current_processed_offset = 0;\n\n        for (uint16_t i = 0; i < batch_header->num_commands; ++i) {\n            if (current_raw_offset + sizeof(VehicleCommandHeader) > raw_batch_data_len) {\n                return false;\n            }\n\n            const VehicleCommandHeader* cmd_header = reinterpret_cast<const VehicleCommandHeader*>(raw_batch_data + current_raw_offset);\n            uint16_t current_cmd_data_len = cmd_header->data_length;\n\n            if (current_raw_offset + sizeof(VehicleCommandHeader) + current_cmd_data_len > raw_batch_data_len) {\n                return false;\n            }\n\n            size_t bytes_to_copy_this_command = sizeof(VehicleCommandHeader) + current_cmd_data_len;\n            if (current_processed_offset > (std::numeric_limits<size_t>::max() - bytes_to_copy_this_command) ||\n                current_processed_offset + bytes_to_copy_this_command > m_processed_data_size) {\n                return false;\n            }\n\n            memcpy(m_processed_batch_data + current_processed_offset, cmd_header, sizeof(VehicleCommandHeader));\n            current_processed_offset += sizeof(VehicleCommandHeader);\n\n            memcpy(m_processed_batch_data + current_processed_offset, raw_batch_data + current_raw_offset + sizeof(VehicleCommandHeader), current_cmd_data_len);\n            current_processed_offset += current_cmd_data_len;\n\n            current_raw_offset += sizeof(VehicleCommandHeader) + current_cmd_data_len;\n        }\n\n        if (current_processed_offset != m_processed_data_size) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedBatchData() const {\n        return m_processed_batch_data;\n    }\n\n    size_t getProcessedDataSize() const {\n        return m_processed_data_size;\n    }\n\nprivate:\n    uint8_t* m_processed_batch_data;\n    size_t m_processed_data_size;\n};\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n// Represents a firmware update packet header\nstruct FirmwarePacketHeader {\n    uint32_t packet_magic;\n    uint32_t total_data_payload_size;\n    uint16_t num_modules;\n    uint8_t  _reserved[2];\n};\n\n// Represents a header for an individual firmware module within the payload\nstruct FirmwareModuleHeader {\n    uint16_t module_id;\n    uint16_t module_version;\n    uint32_t module_data_length;\n};\n\nclass FirmwareUpdater {\nprivate:\n    uint8_t* m_firmware_buffer;\n    size_t   m_allocated_size;\n\npublic:\n    FirmwareUpdater() : m_firmware_buffer(nullptr), m_allocated_size(0) {}\n\n    ~FirmwareUpdater() {\n        if (m_firmware_buffer) {\n            free(m_firmware_buffer);\n        }\n    }\n\n    void clearFirmwareBuffer() {\n        if (m_firmware_buffer) {\n            free(m_firmware_buffer);\n            m_firmware_buffer = nullptr;\n            m_allocated_size = 0;\n        }\n    }\n\n    bool processFirmwareUpdatePacketFixed(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(FirmwarePacketHeader)) {\n            return false;\n        }\n\n        const FirmwarePacketHeader* header = reinterpret_cast<const FirmwarePacketHeader*>(packet_data);\n\n        // Basic sanity check: Is the claimed total payload size within packet bounds?\n        if (header->total_data_payload_size > (packet_length - sizeof(FirmwarePacketHeader))) {\n            return false;\n        }\n        \n        // Add a sanity check for number of modules to prevent excessive loops or unrealistic values\n        static const uint16_t MAX_ALLOWED_MODULES = 100; \n        if (header->num_modules > MAX_ALLOWED_MODULES) {\n            return false;\n        }\n\n        clearFirmwareBuffer();\n\n        // Allocate buffer based on the total_data_payload_size from the packet header\n        // Ensure total_data_payload_size is not zero if modules are expected (or handle empty case).\n        if (header->total_data_payload_size == 0 && header->num_modules > 0) {\n            return false; \n        }\n\n        m_firmware_buffer = (uint8_t*)malloc(header->total_data_payload_size);\n        if (!m_firmware_buffer) {\n            return false;\n        }\n        m_allocated_size = header->total_data_payload_size;\n\n        size_t current_packet_offset = sizeof(FirmwarePacketHeader);\n        size_t current_buffer_write_offset = 0;\n\n        for (uint16_t i = 0; i < header->num_modules; ++i) {\n            // Check if there's enough data in the raw packet for the module header\n            if (current_packet_offset + sizeof(FirmwareModuleHeader) > packet_length) {\n                clearFirmwareBuffer();\n                return false;\n            }\n\n            const FirmwareModuleHeader* module_hdr = reinterpret_cast<const FirmwareModuleHeader*>(packet_data + current_packet_offset);\n\n            // Advance packet offset past the module header\n            current_packet_offset += sizeof(FirmwareModuleHeader);\n            \n            // Check if there's enough data in the raw packet for the module's payload\n            if (current_packet_offset + module_hdr->module_data_length > packet_length) {\n                clearFirmwareBuffer();\n                return false;\n            }\n\n            // FIX: Crucial check to prevent heap buffer overflow.\n            // Ensure the current write operation, including the data to be copied,\n            // does not exceed the bounds of the allocated buffer (m_allocated_size).\n            // Also check for potential integer overflow during the sum before comparison.\n            if (current_buffer_write_offset > SIZE_MAX - module_hdr->module_data_length ||\n                current_buffer_write_offset + module_hdr->module_data_length > m_allocated_size) {\n                clearFirmwareBuffer();\n                return false; \n            }\n            \n            memcpy(m_firmware_buffer + current_buffer_write_offset,\n                   packet_data + current_packet_offset,\n                   module_hdr->module_data_length);\n\n            current_packet_offset += module_hdr->module_data_length;\n            current_buffer_write_offset += module_hdr->module_data_length;\n        }\n        \n        // Final consistency check: Ensure the total data actually copied matches\n        // the total_data_payload_size from the packet header.\n        if (current_buffer_write_offset != header->total_data_payload_size) {\n            clearFirmwareBuffer();\n            return false;\n        }\n\n        return true;\n    }\n\n    size_t getAllocatedFirmwareSize() const {\n        return m_allocated_size;\n    }\n\n    const uint8_t* getFirmwareBuffer() const {\n        return m_firmware_buffer;\n    }\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CALIBRATION_BUFFER_SIZE 256\n#define CALIBRATION_BLOCK_SIZE 16\n\nstatic uint8_t g_calibration_data[CALIBRATION_BUFFER_SIZE];\nstatic size_t g_num_active_blocks = 0;\n\nvoid init_calibration_store() {\n    memset(g_calibration_data, 0, CALIBRATION_BUFFER_SIZE);\n    g_num_active_blocks = 0;\n}\n\nbool add_calibration_block(const uint8_t* block_data) {\n    if ((g_num_active_blocks + 1) * CALIBRATION_BLOCK_SIZE > CALIBRATION_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_calibration_data + (g_num_active_blocks * CALIBRATION_BLOCK_SIZE), block_data, CALIBRATION_BLOCK_SIZE);\n    g_num_active_blocks++;\n    return true;\n}\n\n// This function shifts a block of calibration data within the buffer.\n// The vulnerability exists if 'relative_shift_steps' is a negative value\n// that causes 'effective_destination_byte_offset' to go below zero, leading\n// to a buffer underwrite when memmove attempts to write before the buffer's start.\nvoid rearrange_calibration_block_vulnerable(uint16_t block_index_to_move, int16_t relative_shift_steps) {\n    if (block_index_to_move >= g_num_active_blocks) {\n        return; \n    }\n\n    int32_t source_byte_offset = (int32_t)block_index_to_move * CALIBRATION_BLOCK_SIZE;\n    int32_t effective_destination_byte_offset = source_byte_offset + (relative_shift_steps * CALIBRATION_BLOCK_SIZE);\n\n    uint8_t* source_ptr = g_calibration_data + source_byte_offset;\n    uint8_t* destination_ptr = g_calibration_data + effective_destination_byte_offset;\n\n    memmove(destination_ptr, source_ptr, CALIBRATION_BLOCK_SIZE);\n}\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n#include <limits>\n\n#pragma pack(push, 1)\n\nstruct SensorRecordHeader {\n    uint16_t record_id;\n    uint32_t timestamp_ms;\n    uint16_t metadata_len; \n};\n\nstruct SensorDataBatchHeader {\n    uint16_t num_records;\n    uint32_t total_payload_bytes; \n};\n\n#pragma pack(pop)\n\nclass SensorDataProcessorFixed {\npublic:\n    SensorDataProcessorFixed() : m_processed_data_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~SensorDataProcessorFixed() {\n        if (m_processed_data_buffer) {\n            delete[] m_processed_data_buffer;\n            m_processed_data_buffer = nullptr;\n        }\n    }\n\n    bool processSensorBatchFixed(const uint8_t* raw_batch_packet, size_t packet_length) {\n        if (!raw_batch_packet || packet_length < sizeof(SensorDataBatchHeader)) {\n            return false;\n        }\n\n        const SensorDataBatchHeader* batch_header = reinterpret_cast<const SensorDataBatchHeader*>(raw_batch_packet);\n\n        if (batch_header->total_payload_bytes > (packet_length - sizeof(SensorDataBatchHeader))) {\n            return false;\n        }\n        \n        size_t calculated_payload_size = 0;\n        size_t current_packet_scan_offset = sizeof(SensorDataBatchHeader);\n\n        static const uint16_t MAX_NUM_RECORDS = 100;\n        if (batch_header->num_records > MAX_NUM_RECORDS) {\n            return false;\n        }\n\n        for (uint16_t i = 0; i < batch_header->num_records; ++i) {\n            if (current_packet_scan_offset > (packet_length - sizeof(SensorRecordHeader))) {\n                return false;\n            }\n\n            const SensorRecordHeader* record_header_scan = reinterpret_cast<const SensorRecordHeader*>(raw_batch_packet + current_packet_scan_offset);\n            uint16_t current_metadata_len = record_header_scan->metadata_len;\n            \n            if (sizeof(SensorRecordHeader) > (std::numeric_limits<size_t>::max() - calculated_payload_size) ||\n                current_metadata_len > (std::numeric_limits<size_t>::max() - calculated_payload_size - sizeof(SensorRecordHeader))) {\n                return false;\n            }\n            \n            calculated_payload_size += sizeof(SensorRecordHeader) + current_metadata_len;\n            current_packet_scan_offset += sizeof(SensorRecordHeader) + current_metadata_len;\n\n            if (current_packet_scan_offset > packet_length) {\n                return false;\n            }\n        }\n\n        if (calculated_payload_size != batch_header->total_payload_bytes) {\n            return false;\n        }\n\n        if (m_processed_data_buffer) {\n            delete[] m_processed_data_buffer;\n            m_processed_data_buffer = nullptr;\n        }\n\n        m_buffer_capacity = calculated_payload_size;\n        \n        if (m_buffer_capacity == 0 && batch_header->num_records > 0) {\n            return false;\n        }\n\n        m_processed_data_buffer = new (std::nothrow) uint8_t[m_buffer_capacity];\n        if (!m_processed_data_buffer && m_buffer_capacity > 0) {\n            return false;\n        }\n\n        size_t current_read_offset_in_packet = sizeof(SensorDataBatchHeader);\n        size_t current_write_offset_in_buffer = 0;\n\n        for (uint16_t i = 0; i < batch_header->num_records; ++i) {\n            if (current_read_offset_in_packet > (packet_length - sizeof(SensorRecordHeader))) {\n                return false;\n            }\n\n            const SensorRecordHeader* record_header = reinterpret_cast<const SensorRecordHeader*>(raw_batch_packet + current_read_offset_in_packet);\n            uint16_t current_metadata_len = record_header->metadata_len;\n\n            if (current_read_offset_in_packet > (packet_length - sizeof(SensorRecordHeader) - current_metadata_len)) {\n                return false;\n            }\n\n            size_t bytes_to_copy_this_record = sizeof(SensorRecordHeader) + current_metadata_len;\n            \n            if (current_write_offset_in_buffer > (m_buffer_capacity - bytes_to_copy_this_record)) {\n                return false; \n            }\n\n            memcpy(m_processed_data_buffer + current_write_offset_in_buffer, record_header, bytes_to_copy_this_record);\n\n            current_read_offset_in_packet += bytes_to_copy_this_record;\n            current_write_offset_in_buffer += bytes_to_copy_this_record;\n        }\n        \n        if (current_write_offset_in_buffer != m_buffer_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedDataBuffer() const {\n        return m_processed_data_buffer;\n    }\n\n    size_t getBufferCapacity() const {\n        return m_buffer_capacity;\n    }\n\nprivate:\n    uint8_t* m_processed_data_buffer;\n    size_t m_buffer_capacity;\n};\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n// Configuration for the telemetry system\n#define TELEMETRY_BUFFER_SIZE 128 // Small buffer to easily demonstrate overflow\n#define MAX_DIAG_DATA_LENGTH 15   // Max length for custom diagnostic data payload\n\n// Sensor Type Definitions\n#define SENSOR_TYPE_TEMPERATURE     0x01 // 1 byte value\n#define SENSOR_TYPE_PRESSURE        0x02 // 2 bytes value\n#define SENSOR_TYPE_RPM             0x03 // 4 bytes value\n#define SENSOR_TYPE_CUSTOM_DIAG     0x04 // Variable length (1 byte length + up to MAX_DIAG_DATA_LENGTH bytes data)\n#define SENSOR_TYPE_IGNITION_STATUS 0x05 // 1 byte value for simplicity of packing\n\n// Global telemetry buffer and current write offset\nstatic uint8_t g_telemetry_data_buffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_current_telemetry_write_offset;\n\n// Function to initialize the telemetry buffer\nvoid initializeTelemetryBuffer() {\n    memset(g_telemetry_data_buffer, 0, TELEMETRY_BUFFER_SIZE);\n    g_current_telemetry_write_offset = 0;\n}\n\n// Function to pack sensor data into the global telemetry buffer.\n// Returns 0 on success, or a negative value on error.\n// Vulnerability: Lack of comprehensive bounds checking before and during data writes,\n// especially for SENSOR_TYPE_CUSTOM_DIAG, can lead to out-of-bounds writes.\nint packSensorDataToBuffer(uint8_t sensor_type, uint32_t sensor_value) {\n    uint16_t current_pos = g_current_telemetry_write_offset;\n    uint8_t actual_diag_len = 0;\n\n    // First byte is always sensor type ID\n    if (current_pos >= TELEMETRY_BUFFER_SIZE) {\n        return -1; // Buffer already full before writing type ID\n    }\n    g_telemetry_data_buffer[current_pos++] = sensor_type; // Write type ID (1 byte)\n\n    switch (sensor_type) {\n        case SENSOR_TYPE_TEMPERATURE: // 1 byte value\n            // Vulnerability: If current_pos is now TELEMETRY_BUFFER_SIZE - 1, this writes OOB\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value & 0xFF);\n            break;\n        case SENSOR_TYPE_PRESSURE: // 2 byte value\n            // Vulnerability: If current_pos is now TELEMETRY_BUFFER_SIZE - 1 or -2, this writes OOB\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)((sensor_value >> 8) & 0xFF);\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value & 0xFF);\n            break;\n        case SENSOR_TYPE_RPM: // 4 byte value\n            // Vulnerability: If current_pos is now TELEMETRY_BUFFER_SIZE - 1, -2, -3 or -4, this writes OOB\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)((sensor_value >> 24) & 0xFF);\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)((sensor_value >> 16) & 0xFF);\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)((sensor_value >> 8) & 0xFF);\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value & 0xFF);\n            break;\n        case SENSOR_TYPE_CUSTOM_DIAG: // Variable length: 1 byte for length + data bytes\n            actual_diag_len = (uint8_t)(sensor_value & 0x0F); // Extract length from lower 4 bits\n            if (actual_diag_len > MAX_DIAG_DATA_LENGTH) {\n                actual_diag_len = MAX_DIAG_DATA_LENGTH;\n            }\n\n            // Vulnerability: If current_pos is TELEMETRY_BUFFER_SIZE - 1, this writes OOB\n            g_telemetry_data_buffer[current_pos++] = actual_diag_len; // Write length byte (1 byte)\n\n            // Vulnerability: No bounds check within this loop.\n            // (current_pos + i) can easily exceed TELEMETRY_BUFFER_SIZE if current_pos\n            // was already near the boundary before this loop began, and actual_diag_len is large.\n            for (int i = 0; i < actual_diag_len; ++i) {\n                g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value >> (8 * (actual_diag_len - 1 - i)));\n            }\n            break;\n        case SENSOR_TYPE_IGNITION_STATUS: // 1 byte value\n            // Vulnerability: If current_pos is now TELEMETRY_BUFFER_SIZE - 1, this writes OOB\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value & 0x01);\n            break;\n        default:\n            // Revert the written type ID as this sensor type is unknown\n            g_current_telemetry_write_offset = current_pos - 1;\n            return -2; // Unknown sensor type\n    }\n    \n    g_current_telemetry_write_offset = current_pos;\n    return 0; // Success (return 0 or actual bytes written if needed)\n}\n\n// Main function to simulate telemetry data collection and transmission cycle\nvoid prepareAndTransmitSensorData() {\n    initializeTelemetryBuffer();\n\n    // Populate with some initial data (10 bytes total)\n    packSensorDataToBuffer(SENSOR_TYPE_TEMPERATURE, 75); // 1 type + 1 value = 2 bytes. Offset=2\n    packSensorDataToBuffer(SENSOR_TYPE_PRESSURE, 2560);  // 1 type + 2 value = 3 bytes. Offset=5\n    packSensorDataToBuffer(SENSOR_TYPE_RPM, 3500);       // 1 type + 4 value = 5 bytes. Offset=10\n\n    // Fill the buffer until there are exactly 10 bytes remaining.\n    // A CUSTOM_DIAG item with MAX_DIAG_DATA_LENGTH (15) requires 1+1+15=17 bytes.\n    // If only 10 bytes are remaining, it will write 7 bytes OOB.\n    while (g_current_telemetry_write_offset < TELEMETRY_BUFFER_SIZE - 10) {\n        packSensorDataToBuffer(SENSOR_TYPE_TEMPERATURE, 20); // Each adds 2 bytes (1 type + 1 value)\n    }\n    // At this point, g_current_telemetry_write_offset should be TELEMETRY_BUFFER_SIZE - 10 (i.e., 118)\n\n    // This call attempts to write 17 bytes (1 type + 1 length + 15 data) when only 10 bytes remain.\n    // The 'for' loop inside SENSOR_TYPE_CUSTOM_DIAG in packSensorDataToBuffer will cause an OOB write.\n    packSensorDataToBuffer(SENSOR_TYPE_CUSTOM_DIAG, MAX_DIAG_DATA_LENGTH); // Attempt to pack 15 bytes of diagnostic data\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_PAYLOAD_SIZE 256\n#define MAX_VEHICLE_FEATURES 32\n\ntypedef struct {\n    uint8_t feature_index; \n    uint8_t new_state;     \n} FeatureUpdateRequest;\n\nstatic uint8_t g_vehicleFeatureStates[MAX_VEHICLE_FEATURES]; \n\nvoid initVehicleFeatures() {\n    memset(g_vehicleFeatureStates, 0, sizeof(g_vehicleFeatureStates));\n}\n\nint processFeatureUpdateCommand(const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len < 1) {\n        return -1; \n    }\n\n    uint8_t num_updates = payload[0];\n    uint16_t expected_len = 1 + (num_updates * sizeof(FeatureUpdateRequest));\n\n    if (expected_len > payload_len || expected_len > MAX_DIAG_PAYLOAD_SIZE) {\n        return -1; \n    }\n\n    for (uint8_t i = 0; i < num_updates; ++i) {\n        uint16_t current_offset = 1 + (i * sizeof(FeatureUpdateRequest));\n        \n        if (current_offset + sizeof(FeatureUpdateRequest) > payload_len) {\n            return -1; \n        }\n\n        FeatureUpdateRequest current_request;\n        current_request.feature_index = payload[current_offset];\n        current_request.new_state = payload[current_offset + 1];\n\n        if (current_request.feature_index >= MAX_VEHICLE_FEATURES) {\n            return -2; \n        }\n        \n        g_vehicleFeatureStates[current_request.feature_index] = current_request.new_state;\n    }\n\n    return 0; \n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_PID_CONTROLLERS 5\n\ntypedef struct {\n    float Kp;\n    float Ki;\n    float Kd;\n    int32_t min_output;\n    int32_t max_output;\n    uint8_t loop_status;\n    uint8_t reserved[3];\n} PID_Parameters;\n\nstatic PID_Parameters g_pidConfigs[MAX_PID_CONTROLLERS];\n\nvoid initPIDControllers() {\n    for (int i = 0; i < MAX_PID_CONTROLLERS; ++i) {\n        g_pidConfigs[i].Kp = 0.0f;\n        g_pidConfigs[i].Ki = 0.0f;\n        g_pidConfigs[i].Kd = 0.0f;\n        g_pidConfigs[i].min_output = 0;\n        g_pidConfigs[i].max_output = 0;\n        g_pidConfigs[i].loop_status = 0;\n        memset(g_pidConfigs[i].reserved, 0, sizeof(g_pidConfigs[i].reserved));\n    }\n}\n\nint updatePIDParameter(const uint8_t* msg_data, uint16_t msg_len) {\n    if (msg_data == NULL || msg_len < 3) {\n        return -1;\n    }\n\n    uint8_t controller_id = msg_data[0];\n    uint8_t parameter_offset_bytes = msg_data[1];\n    uint16_t data_value_len = msg_len - 2;\n\n    if (controller_id >= MAX_PID_CONTROLLERS) {\n        return -2;\n    }\n\n    memcpy((uint8_t*)&g_pidConfigs[controller_id] + parameter_offset_bytes, msg_data + 2, data_value_len);\n\n    return 0;\n}\n\nvoid handleVehicleConfigMessage(const uint8_t* network_data, uint16_t network_len) {\n    if (network_len < 3) {\n        return;\n    }\n    updatePIDParameter(network_data, network_len);\n}\n\nfloat getPIDKp(uint8_t id) {\n    if (id < MAX_PID_CONTROLLERS) {\n        return g_pidConfigs[id].Kp;\n    }\n    return 0.0f;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_DIAGNOSTIC_DOMAINS 3\n#define MAX_DTCS_PER_DOMAIN_GLOBAL 20\n\ntypedef enum {\n    DOMAIN_POWERTRAIN = 0,\n    DOMAIN_CHASSIS,\n    DOMAIN_INFOTAINMENT,\n    DOMAIN_COUNT\n} DiagnosticDomainId;\n\ntypedef struct {\n    bool active;\n    bool pending;\n    bool history;\n    uint8_t failure_count;\n} DtcStatus;\n\nstatic DtcStatus g_domainDtcStatuses[MAX_DIAGNOSTIC_DOMAINS][MAX_DTCS_PER_DOMAIN_GLOBAL];\n\nstatic const uint8_t g_actualDtcCountsPerDomain[MAX_DIAGNOSTIC_DOMAINS] = {\n    10,\n    15,\n    5\n};\n\ntypedef struct {\n    DiagnosticDomainId domain_id;\n    uint8_t dtc_index;\n    uint8_t command_type;\n} DiagnosticCommand;\n\nvoid logDiagnosticEvent(const char* msg) {\n}\n\nDiagnosticCommand receiveDiagnosticCommand_vulnerable() {\n    DiagnosticCommand cmd;\n    cmd.domain_id = DOMAIN_POWERTRAIN;\n    cmd.dtc_index = 12;\n    cmd.command_type = 0x01;\n    return cmd;\n}\n\nvoid initializeDtcStatuses_vulnerable() {\n    for (uint8_t i = 0; i < MAX_DIAGNOSTIC_DOMAINS; ++i) {\n        for (uint8_t j = 0; j < MAX_DTCS_PER_DOMAIN_GLOBAL; ++j) {\n            g_domainDtcStatuses[i][j] = (DtcStatus){false, false, false, 0};\n        }\n    }\n}\n\nvoid processDiagnosticCommand_vulnerable() {\n    DiagnosticCommand cmd = receiveDiagnosticCommand_vulnerable();\n\n    if (cmd.domain_id < DOMAIN_COUNT) {\n        if (cmd.dtc_index < MAX_DTCS_PER_DOMAIN_GLOBAL) {\n            switch (cmd.command_type) {\n                case 0x01:\n                    g_domainDtcStatuses[cmd.domain_id][cmd.dtc_index].active = false;\n                    logDiagnosticEvent(\"DTC active flag cleared.\");\n                    break;\n                case 0x02:\n                    g_domainDtcStatuses[cmd.domain_id][cmd.dtc_index].pending = false;\n                    logDiagnosticEvent(\"DTC pending flag cleared.\");\n                    break;\n                default:\n                    logDiagnosticEvent(\"Unknown diagnostic command type received.\");\n                    break;\n            }\n        } else {\n            logDiagnosticEvent(\"Diagnostic command with out-of-bounds DTC index (global max) received. Ignoring.\");\n        }\n    } else {\n        logDiagnosticEvent(\"Diagnostic command with invalid domain ID received. Ignoring.\");\n    }\n}\n\nvoid ecuDiagnosticManager_vulnerable() {\n    initializeDtcStatuses_vulnerable();\n    processDiagnosticCommand_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_LOG_BUFFER_SIZE 1024\n#define MAX_LOG_ENTRIES 50\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t sensor_id;\n    uint16_t value;\n    uint8_t  crc;\n} SensorLogEntry;\n\nstatic uint8_t g_sensor_data_log[MAX_LOG_BUFFER_SIZE];\nstatic uint16_t g_log_entry_offsets[MAX_LOG_ENTRIES];\nstatic uint16_t g_num_log_entries = 0;\nstatic uint16_t g_current_data_ptr = 0;\n\nvoid init_sensor_logger_fixed() {\n    memset(g_sensor_data_log, 0, MAX_LOG_BUFFER_SIZE);\n    memset(g_log_entry_offsets, 0, sizeof(g_log_entry_offsets));\n    g_num_log_entries = 0;\n    g_current_data_ptr = 0;\n}\n\nbool add_sensor_log_entry_fixed(uint32_t timestamp, uint16_t sensor_id, uint16_t value, uint8_t crc) {\n    if (g_num_log_entries >= MAX_LOG_ENTRIES) {\n        return false;\n    }\n\n    if (g_current_data_ptr + sizeof(SensorLogEntry) > MAX_LOG_BUFFER_SIZE) {\n        return false;\n    }\n\n    g_log_entry_offsets[g_num_log_entries] = g_current_data_ptr;\n\n    SensorLogEntry new_entry = {timestamp, sensor_id, value, crc};\n    memcpy(&g_sensor_data_log[g_current_data_ptr], &new_entry, sizeof(SensorLogEntry));\n\n    g_current_data_ptr += sizeof(SensorLogEntry);\n    g_num_log_entries++;\n    return true;\n}\n\nvoid set_entry_status_fixed(uint16_t entry_index, uint8_t status_byte) {\n    if (entry_index >= g_num_log_entries) {\n        return;\n    }\n\n    uint16_t entry_start_offset = g_log_entry_offsets[entry_index];\n\n    if (entry_start_offset > 0) {\n        g_sensor_data_log[entry_start_offset - 1] = status_byte;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define FLASH_CONFIG_TOTAL_SIZE 256 // Total bytes in the simulated flash configuration area\n#define MAX_CONFIG_DATA_ITEMS 10    // Maximum number of configurable data items\n\n// Simulated flash memory area containing various configuration items.\n// This is treated as a read-only area for normal operations, but its contents\n// are accessed based on metadata that can be manipulated.\nstatic const uint8_t g_simulatedFlashMemory[FLASH_CONFIG_TOTAL_SIZE] = {\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,\n    0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,\n    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,\n    0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,\n    0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,\n    0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n    0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF\n};\n\n// Static array defining the starting byte offset of each configuration item within g_simulatedFlashMemory.\n// This array is assumed to be immutable and correctly configured at build time.\nstatic const uint16_t g_configItemOffsets[MAX_CONFIG_DATA_ITEMS] = {\n    0,    // Item 0 starts at offset 0\n    10,   // Item 1 starts at offset 10\n    30,   // Item 2 starts at offset 30\n    35,   // Item 3 starts at offset 35\n    50,   // Item 4 starts at offset 50\n    80,   // Item 5 starts at offset 80\n    120,  // Item 6 starts at offset 120\n    170,  // Item 7 starts at offset 170\n    230,  // Item 8 starts at offset 230\n    250   // Item 9 starts at offset 250\n};\n\n// Mutable array storing the *configured size* of each data item.\n// This array can be updated via diagnostic commands or configuration updates.\n// VULNERABILITY SOURCE: This array is NOT validated against the total flash bounds during updates.\nstatic uint16_t g_configItemSizes[MAX_CONFIG_DATA_ITEMS] = {\n    10,  // Item 0: default size 10 bytes\n    20,  // Item 1: default size 20 bytes\n    5,   // Item 2: default size 5 bytes\n    15,  // Item 3: default size 15 bytes\n    30,  // Item 4: default size 30 bytes\n    40,  // Item 5: default size 40 bytes\n    50,  // Item 6: default size 50 bytes\n    60,  // Item 7: default size 60 bytes\n    20,  // Item 8: default size 20 bytes (offset 230 + size 20 = 250, fits in 256)\n    10   // Item 9: default size 10 bytes (offset 250 + size 10 = 260, would overflow if used)\n};\n\n// Function to initialize system configuration (e.g., at boot).\nvoid initConfigSystem() {\n    // In a real system, flash might be initialized with specific patterns or loaded from NVM.\n    // Here, g_simulatedFlashMemory is 'const' so we don't memset it directly.\n    // g_configItemSizes holds its default values.\n}\n\n// Function to update the size of a specific configuration item.\n// This simulates a diagnostic service command or an authorized configuration tool.\n// param item_id: The identifier for the configuration item to update.\n// param new_size: The new desired size for the item in bytes.\n// Returns 0 on success, or a negative error code on failure.\nint setConfigItemSize(uint8_t item_id, uint16_t new_size) {\n    if (item_id >= MAX_CONFIG_DATA_ITEMS) {\n        return -1; // Invalid item ID\n    }\n\n    // VULNERABILITY: Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-119)\n    // No check is performed here to ensure that the 'new_size', when added to the item's\n    // fixed 'g_configItemOffsets[item_id]', will not cause a subsequent read operation\n    // (e.g., by 'readConfigItem') to exceed the bounds of 'FLASH_CONFIG_TOTAL_SIZE'.\n    // An attacker can set a 'new_size' that leads to an out-of-bounds read in 'readConfigItem'.\n    // For instance, for item_id 8 (offset 230), setting new_size to 30 will lead to a read\n    // attempt at offset 230 for 30 bytes, accessing up to byte 259, which is beyond\n    // FLASH_CONFIG_TOTAL_SIZE (256).\n    g_configItemSizes[item_id] = new_size;\n    return 0; // Success\n}\n\n// Function to read a specific configuration item from the simulated flash memory.\n// This function relies on the sizes stored in g_configItemSizes, which can be vulnerable.\n// param item_id: The identifier for the configuration item to read.\n// param dest_buffer: Pointer to the caller-provided buffer where data will be copied.\n// param dest_buffer_size: The size of the caller-provided destination buffer.\n// Returns the actual bytes read on success, or a negative error code on failure.\nint readConfigItem(uint8_t item_id, uint8_t* dest_buffer, uint16_t dest_buffer_size) {\n    if (item_id >= MAX_CONFIG_DATA_ITEMS || dest_buffer == NULL) {\n        return -1; // Invalid item ID or destination buffer\n    }\n\n    uint16_t item_offset = g_configItemOffsets[item_id];\n    uint16_t item_size = g_configItemSizes[item_id]; // This size can be maliciously inflated\n\n    // Check if the destination buffer is large enough to hold the item.\n    // This check protects the 'dest_buffer' from overflow, but not the source 'g_simulatedFlashMemory'.\n    if (item_size > dest_buffer_size) {\n        return -2; // Destination buffer too small for the item\n    }\n\n    // VULNERABILITY TRIGGER: Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-119)\n    // If 'item_size' was previously set to a malicious value via 'setConfigItemSize',\n    // this memcpy operation will attempt to read 'item_size' bytes starting from 'item_offset'\n    // in 'g_simulatedFlashMemory'. If (item_offset + item_size) exceeds 'FLASH_CONFIG_TOTAL_SIZE',\n    // it results in an out-of-bounds read (CWE-125), potentially leaking sensitive information\n    // from adjacent memory or causing a system crash.\n    memcpy(dest_buffer, &g_simulatedFlashMemory[item_offset], item_size);\n\n    return item_size; // Return actual bytes read\n}\n\n// Dummy function to simulate a diagnostic tool's interaction pattern:\n// 1. Potentially manipulate a config item's size via a diagnostic command.\n// 2. Request to read the config item, triggering the out-of-bounds read.\nvoid simulateDiagnosticConfigAccess(uint8_t item_id_to_read, uint16_t malicious_size_to_set) {\n    // Initialize the system (in a real system, this would be part of bootup)\n    initConfigSystem();\n\n    // Step 1: An attacker or faulty system component sets a malicious size for a config item.\n    // This is where the root vulnerability lies if not properly validated.\n    setConfigItemSize(item_id_to_read, malicious_size_to_set);\n\n    // Prepare a buffer to receive the data.\n    uint8_t read_buffer[100]; // Max buffer size that the client can provide.\n    memset(read_buffer, 0, sizeof(read_buffer));\n\n    // Step 2: Another function (or the same attacker) requests to read the item.\n    // This read will now be vulnerable if the size was maliciously inflated.\n    readConfigItem(item_id_to_read, read_buffer, sizeof(read_buffer));\n}\n", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_FIRMWARE_SIZE 0x10000 \n#define FRAGMENT_MAX_PAYLOAD_SIZE 256 \n\nstatic uint8_t g_firmwareBuffer[VEHICLE_FIRMWARE_SIZE];\n\nvoid initFirmwareBuffer() {\n    memset(g_firmwareBuffer, 0, VEHICLE_FIRMWARE_SIZE);\n}\n\nstatic int processFirmwareFragment(uint16_t fragment_offset, uint8_t fragment_len, const uint8_t* fragment_data) {\n    if (fragment_data == NULL || fragment_len == 0) {\n        return -1;\n    }\n\n    if ((uint32_t)fragment_offset + fragment_len > VEHICLE_FIRMWARE_SIZE) {\n        return -2;\n    }\n\n    for (uint8_t i = 0; i < fragment_len; ++i) {\n        g_firmwareBuffer[fragment_offset + i] = fragment_data[i];\n    }\n\n    return 0;\n}\n\nint handleFirmwareUpdateMessage(const uint8_t* message, uint16_t message_len) {\n    if (message == NULL || message_len < (1 + sizeof(uint16_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    uint8_t service_id = message[0];\n    if (service_id != 0x34) {\n        return -2;\n    }\n\n    uint16_t offset_idx = 1;\n    uint16_t fragment_offset = (message[offset_idx] << 8) | message[offset_idx+1];\n    \n    uint16_t len_idx = offset_idx + sizeof(uint16_t);\n    uint8_t fragment_len = message[len_idx];\n\n    const uint8_t* fragment_data = message + len_idx + sizeof(uint8_t);\n    uint16_t actual_data_in_msg_len = message_len - (len_idx + sizeof(uint8_t));\n\n    if (fragment_len > FRAGMENT_MAX_PAYLOAD_SIZE) {\n        return -3;\n    }\n    \n    return processFirmwareFragment(fragment_offset, fragment_len, fragment_data);\n}\n\nuint8_t getFirmwareByte(uint32_t index) {\n    if (index < VEHICLE_FIRMWARE_SIZE) {\n        return g_firmwareBuffer[index];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define SENSOR_EVENT_DATA_SIZE 8\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_type;\n    uint8_t  details[SENSOR_EVENT_DATA_SIZE];\n} SensorEvent;\n\n#define MAX_EVENT_LOG_ENTRIES 20\n\nstatic SensorEvent g_event_log_fixed[MAX_EVENT_LOG_ENTRIES];\nstatic int32_t g_current_event_count_fixed = 0;\n\nvoid init_event_log_fixed() {\n    memset(g_event_log_fixed, 0, sizeof(g_event_log_fixed));\n    g_current_event_count_fixed = 0;\n}\n\nbool add_sensor_event_fixed(uint16_t type, const uint8_t* details) {\n    if (g_current_event_count_fixed >= MAX_EVENT_LOG_ENTRIES) {\n        return false;\n    }\n    g_event_log_fixed[g_current_event_count_fixed].timestamp = 0x12345678;\n    g_event_log_fixed[g_current_event_count_fixed].event_type = type;\n    memcpy(g_event_log_fixed[g_current_event_count_fixed].details, details, SENSOR_EVENT_DATA_SIZE);\n    g_current_event_count_fixed++;\n    return true;\n}\n\nvoid rewind_event_log_and_update_marker_fixed(uint32_t steps_to_rewind, uint8_t marker_value) {\n    if (g_current_event_count_fixed == 0) {\n        return;\n    }\n\n    int32_t new_logical_end_idx = g_current_event_count_fixed - (int32_t)steps_to_rewind;\n\n    if (new_logical_end_idx < 0) {\n        new_logical_end_idx = 0;\n    }\n\n    g_current_event_count_fixed = new_logical_end_idx;\n\n    int32_t marker_byte_offset = new_logical_end_idx * sizeof(SensorEvent) - 1;\n\n    if (marker_byte_offset >= 0 && (size_t)marker_byte_offset < sizeof(g_event_log_fixed)) {\n        ((uint8_t*)g_event_log_fixed)[marker_byte_offset] = marker_value;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_EVENT_BUFFER_SIZE 512\n#define MAX_EVENT_DESCRIPTION_LEN 100\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp;\n    uint8_t  severity;\n    uint8_t  description_len; \n} DiagnosticEventHeader;\n\nstatic uint8_t g_eventRecordBuffer[DIAG_EVENT_BUFFER_SIZE];\nstatic uint16_t g_bufferWritePointer = 0;\n\nvoid initDiagnosticRecorder() {\n    memset(g_eventRecordBuffer, 0, DIAG_EVENT_BUFFER_SIZE);\n    g_bufferWritePointer = 0;\n}\n\nint recordDiagnosticEvent(uint16_t id, uint32_t ts, uint8_t sev, const char* desc, uint8_t desc_len) {\n    uint16_t fixed_header_size = sizeof(DiagnosticEventHeader);\n    \n    uint8_t actual_desc_bytes_to_copy = desc_len;\n    if (actual_desc_bytes_to_copy > MAX_EVENT_DESCRIPTION_LEN) {\n        actual_desc_bytes_to_copy = MAX_EVENT_DESCRIPTION_LEN;\n    }\n\n    uint16_t total_event_size_to_write = fixed_header_size + actual_desc_bytes_to_copy;\n\n    if (total_event_size_to_write > DIAG_EVENT_BUFFER_SIZE) {\n        return -1;\n    }\n\n    uint16_t write_start_pos = g_bufferWritePointer;\n    if (write_start_pos + total_event_size_to_write > DIAG_EVENT_BUFFER_SIZE) {\n        write_start_pos = 0;\n    }\n\n    uint8_t* current_write_ptr = g_eventRecordBuffer + write_start_pos;\n\n    *(uint16_t*)current_write_ptr = id;\n    current_write_ptr += sizeof(uint16_t);\n    *(uint32_t*)current_write_ptr = ts;\n    current_write_ptr += sizeof(uint32_t);\n    *current_write_ptr = sev;\n    current_write_ptr += sizeof(uint8_t);\n    *current_write_ptr = actual_desc_bytes_to_copy; \n    current_write_ptr += sizeof(uint8_t);\n\n    memcpy(current_write_ptr, desc, actual_desc_bytes_to_copy);\n\n    g_bufferWritePointer = (write_start_pos + total_event_size_to_write) % DIAG_EVENT_BUFFER_SIZE;\n\n    return 0;\n}\n\nvoid simulateIncomingEvent(uint16_t id, uint32_t ts, uint8_t sev, const char* desc, uint8_t desc_len) {\n    recordDiagnosticEvent(id, ts, sev, desc, desc_len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <cstring>\n#include <new>\n\n// Represents a packet containing multiple string-based configuration entries.\n// total_string_bytes_in_packet: The sum of lengths of all strings present in this packet, WITHOUT null terminators.\n// num_strings: The count of individual strings in this packet.\nstruct ConfigPacketHeader {\n    uint32_t total_string_bytes_in_packet;\n    uint16_t num_strings;\n};\n\n// Each string entry within the packet payload has its own length.\nstruct StringEntryHeader {\n    uint16_t string_len; // Length of the string data, WITHOUT null terminator.\n};\n\nclass VehicleConfigLoaderVulnerable {\npublic:\n    VehicleConfigLoaderVulnerable() : m_config_strings_buffer(nullptr), m_buffer_capacity(0), m_current_offset(0) {}\n\n    ~VehicleConfigLoaderVulnerable() {\n        if (m_config_strings_buffer) {\n            free(m_config_strings_buffer);\n            m_config_strings_buffer = nullptr;\n        }\n    }\n\n    // Loads configuration strings from a raw packet.\n    // The packet is assumed to contain a ConfigPacketHeader followed by\n    // 'num_strings' entries, where each entry is a StringEntryHeader\n    // followed by its 'string_len' bytes of data.\n    bool loadConfigurationVulnerable(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(ConfigPacketHeader)) {\n            return false;\n        }\n\n        const ConfigPacketHeader* header = reinterpret_cast<const ConfigPacketHeader*>(packet_data);\n\n        // Basic sanity check: ensure total payload bytes claimed by header fits in the actual packet.\n        if (header->total_string_bytes_in_packet > (packet_length - sizeof(ConfigPacketHeader))) {\n            return false;\n        }\n        \n        // Deallocate existing buffer if any.\n        if (m_config_strings_buffer) {\n            free(m_config_strings_buffer);\n            m_config_strings_buffer = nullptr;\n        }\n\n        // VULNERABILITY:\n        // The buffer is allocated exactly based on 'total_string_bytes_in_packet'.\n        // The definition of 'total_string_bytes_in_packet' explicitly states it's WITHOUT null terminators.\n        // However, the loop below explicitly adds a null terminator after each string (m_config_strings_buffer[...]=\\0).\n        // For each of the 'num_strings' present, an extra byte (the null terminator) will be written\n        // beyond the allocated size, leading to a heap-based buffer overflow.\n        m_buffer_capacity = header->total_string_bytes_in_packet;\n        \n        m_config_strings_buffer = (char*)malloc(m_buffer_capacity);\n        if (!m_config_strings_buffer && m_buffer_capacity > 0) {\n            return false; // Allocation failed for a non-zero sized buffer.\n        }\n        \n        m_current_offset = 0;\n\n        const uint8_t* current_payload_ptr = packet_data + sizeof(ConfigPacketHeader);\n        size_t remaining_payload_data = packet_length - sizeof(ConfigPacketHeader);\n\n        for (uint16_t i = 0; i < header->num_strings; ++i) {\n            if (remaining_payload_data < sizeof(StringEntryHeader)) {\n                if (m_config_strings_buffer) { free(m_config_strings_buffer); m_config_strings_buffer = nullptr; }\n                return false;\n            }\n\n            const StringEntryHeader* string_hdr = reinterpret_cast<const StringEntryHeader*>(current_payload_ptr);\n            uint16_t current_string_len = string_hdr->string_len;\n\n            // Advance past the StringEntryHeader\n            current_payload_ptr += sizeof(StringEntryHeader);\n            remaining_payload_data -= sizeof(StringEntryHeader);\n\n            // Check if enough payload data remains for the string content in the input packet.\n            if (remaining_payload_data < current_string_len) {\n                if (m_config_strings_buffer) { free(m_config_strings_buffer); m_config_strings_buffer = nullptr; }\n                return false;\n            }\n            \n            // Copy string data to the internal buffer.\n            memcpy(m_config_strings_buffer + m_current_offset, current_payload_ptr, current_string_len);\n            \n            // Add null terminator after the string data.\n            // This is the operation that causes the heap-based buffer overflow if\n            // m_buffer_capacity was only calculated from 'total_string_bytes_in_packet'.\n            m_config_strings_buffer[m_current_offset + current_string_len] = '\\0'; \n            \n            m_current_offset += current_string_len + 1; // Advance offset, accounting for null terminator\n\n            // Advance past the string data in the input packet.\n            current_payload_ptr += current_string_len;\n            remaining_payload_data -= current_string_len;\n        }\n\n        return true;\n    }\n\n    const char* getConfigStringsBuffer() const { return m_config_strings_buffer; }\n    size_t getBufferSize() const { return m_current_offset; } // Return actual used size (including nulls)\n\nprivate:\n    char*  m_config_strings_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_offset;\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_TELEMETRY_DATA_BLOCKS 4\n#define TELEMETRY_DATA_BLOCK_SIZE 64\n\nstatic uint8_t g_telemetryDataBlocks[MAX_TELEMETRY_DATA_BLOCKS][TELEMETRY_DATA_BLOCK_SIZE];\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t block_idx;\n    uint8_t start_offset;\n    uint8_t data_len;\n} TelemetryUpdateCommandHeader;\n\nvoid initTelemetryData() {\n    for (int i = 0; i < MAX_TELEMETRY_DATA_BLOCKS; ++i) {\n        memset(g_telemetryDataBlocks[i], 0x00, TELEMETRY_DATA_BLOCK_SIZE);\n    }\n}\n\nint processTelemetryUpdate(const uint8_t* msg_payload, uint16_t payload_total_len) {\n    if (msg_payload == NULL || payload_total_len < sizeof(TelemetryUpdateCommandHeader)) {\n        return -1;\n    }\n\n    const TelemetryUpdateCommandHeader* header = (const TelemetryUpdateCommandHeader*)msg_payload;\n\n    if (header->command_id != 0x01) {\n        return -2;\n    }\n\n    if (header->block_idx >= MAX_TELEMETRY_DATA_BLOCKS) {\n        return -3;\n    }\n    if (header->start_offset >= TELEMETRY_DATA_BLOCK_SIZE) {\n        return -4;\n    }\n\n    if (payload_total_len < sizeof(TelemetryUpdateCommandHeader) + header->data_len) {\n        return -5;\n    }\n\n    const uint8_t* data_to_write = msg_payload + sizeof(TelemetryUpdateCommandHeader);\n\n    for (uint8_t i = 0; i < header->data_len; ++i) {\n        g_telemetryDataBlocks[header->block_idx][header->start_offset + i] = data_to_write[i];\n    }\n\n    return 0;\n}\n\nvoid receiveCANTelemetryCommand(const uint8_t* data, uint16_t len) {\n    initTelemetryData();\n    processTelemetryUpdate(data, len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_SETTINGS_AREA_SIZE 256\n#define SETTING_BLOCK_DATA_SIZE 16\n#define SETTING_HEADER_SIZE 4\n\n#define TOTAL_BLOCK_SIZE (SETTING_HEADER_SIZE + SETTING_BLOCK_DATA_SIZE)\n\nstatic uint8_t g_vehicle_settings_area_fixed[VEHICLE_SETTINGS_AREA_SIZE];\nstatic size_t g_num_stored_blocks_fixed = 0;\n\nvoid init_vehicle_settings_storage_fixed() {\n    memset(g_vehicle_settings_area_fixed, 0, sizeof(g_vehicle_settings_area_fixed));\n    g_num_stored_blocks_fixed = 0;\n}\n\nbool store_new_setting_block_fixed(uint32_t header_flags, const uint8_t* block_data) {\n    if ((g_num_stored_blocks_fixed + 1) * TOTAL_BLOCK_SIZE > VEHICLE_SETTINGS_AREA_SIZE) {\n        return false;\n    }\n\n    size_t current_byte_offset = g_num_stored_blocks_fixed * TOTAL_BLOCK_SIZE;\n    *(uint32_t*)(g_vehicle_settings_area_fixed + current_byte_offset) = header_flags;\n    memcpy(g_vehicle_settings_area_fixed + current_byte_offset + SETTING_HEADER_SIZE, block_data, SETTING_BLOCK_DATA_SIZE);\n    g_num_stored_blocks_fixed++;\n    return true;\n}\n\nvoid adjust_setting_block_active_state_fixed(uint16_t target_block_index, int16_t offset_to_prev_block, bool activate) {\n    if (target_block_index >= g_num_stored_blocks_fixed) {\n        return;\n    }\n\n    size_t base_header_offset = target_block_index * TOTAL_BLOCK_SIZE;\n\n    int32_t potential_effective_byte_offset = (int32_t)base_header_offset - (offset_to_prev_block * TOTAL_BLOCK_SIZE);\n\n    if (potential_effective_byte_offset < 0 || (size_t)potential_effective_byte_offset + sizeof(uint32_t) > VEHICLE_SETTINGS_AREA_SIZE) {\n        return;\n    }\n\n    uint32_t* header_ptr = (uint32_t*)(g_vehicle_settings_area_fixed + potential_effective_byte_offset);\n\n    if (activate) {\n        *header_ptr |= 0x01;\n    } else {\n        *header_ptr &= ~0x01;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_TELEMETRY_BUFFER_SIZE 1024\n#define EVENT_BLOCK_SIZE 32\n\nstatic uint8_t g_telemetry_buffer[MAX_TELEMETRY_BUFFER_SIZE];\nstatic int32_t g_active_event_start_offset = 0;\n\nvoid init_telemetry_system() {\n    memset(g_telemetry_buffer, 0, MAX_TELEMETRY_BUFFER_SIZE);\n    g_active_event_start_offset = 0;\n}\n\nbool log_telemetry_event(const uint8_t* event_data) {\n    static uint32_t current_write_pos = 0;\n\n    if (current_write_pos + EVENT_BLOCK_SIZE > MAX_TELEMETRY_BUFFER_SIZE) {\n        current_write_pos = 0;\n    }\n\n    memcpy(g_telemetry_buffer + current_write_pos, event_data, EVENT_BLOCK_SIZE);\n    \n    current_write_pos += EVENT_BLOCK_SIZE;\n\n    return true;\n}\n\nvoid process_telemetry_block_at_offset(int32_t offset) {\n    if (offset < 0 || offset + EVENT_BLOCK_SIZE > MAX_TELEMETRY_BUFFER_SIZE) {\n        return;\n    }\n    volatile uint32_t timestamp_ms = *(uint32_t*)(g_telemetry_buffer + offset);\n    (void)timestamp_ms;\n}\n\nvoid shift_telemetry_pointer_backward_vulnerable(uint16_t blocks_to_shift) {\n    if (blocks_to_shift == 0) {\n        return;\n    }\n\n    g_active_event_start_offset -= (int32_t)blocks_to_shift * EVENT_BLOCK_SIZE;\n\n    g_telemetry_buffer[g_active_event_start_offset - 1] = 0xDE;\n\n    if (g_active_event_start_offset >= 0 && g_active_event_start_offset < MAX_TELEMETRY_BUFFER_SIZE) {\n        process_telemetry_block_at_offset(g_active_event_start_offset);\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_STATE_HISTORY_SIZE 64\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t speed_kmh;\n    uint16_t rpm;\n    uint8_t gear;\n    bool valid;\n} VehicleStateEntry;\n\nstatic VehicleStateEntry g_vehicle_state_log[VEHICLE_STATE_HISTORY_SIZE];\nstatic uint16_t g_current_log_entries = 0;\nstatic uint16_t g_next_write_idx = 0;\n\nvoid init_vehicle_state_log_vulnerable() {\n    memset(g_vehicle_state_log, 0, sizeof(g_vehicle_state_log));\n    g_current_log_entries = 0;\n    g_next_write_idx = 0;\n}\n\nvoid add_vehicle_state_entry_vulnerable(uint32_t timestamp, uint16_t speed, uint16_t rpm, uint8_t gear) {\n    g_vehicle_state_log[g_next_write_idx].timestamp = timestamp;\n    g_vehicle_state_log[g_next_write_idx].speed_kmh = speed;\n    g_vehicle_state_log[g_next_write_idx].rpm = rpm;\n    g_vehicle_state_log[g_next_write_idx].gear = gear;\n    g_vehicle_state_log[g_next_write_idx].valid = true;\n\n    g_next_write_idx = (g_next_write_idx + 1) % VEHICLE_STATE_HISTORY_SIZE;\n    if (g_current_log_entries < VEHICLE_STATE_HISTORY_SIZE) {\n        g_current_log_entries++;\n    }\n}\n\nvoid apply_historical_state_correction_vulnerable(uint16_t relative_offset_from_last, int16_t correction_value_speed) {\n    if (g_current_log_entries == 0) {\n        return;\n    }\n\n    int32_t last_valid_idx = (int32_t)g_next_write_idx - 1;\n    if (last_valid_idx < 0) {\n        last_valid_idx = VEHICLE_STATE_HISTORY_SIZE - 1;\n    }\n\n    int32_t target_idx = last_valid_idx - relative_offset_from_last;\n\n    g_vehicle_state_log[target_idx].speed_kmh += correction_value_speed;\n    g_vehicle_state_log[target_idx].valid = true;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_TELEMATICS_PROFILES 5\n#define MAX_PROFILE_PARAMS_PER_TYPE 8\n#define CONFIG_DATA_SIZE 16\n\ntypedef struct {\n    uint16_t param_id;\n    uint8_t  data[CONFIG_DATA_SIZE];\n    uint32_t checksum;\n} TelematicsConfigParam;\n\ntypedef struct {\n    uint8_t profile_type_id;\n    uint8_t active_param_count;\n    TelematicsConfigParam params[MAX_PROFILE_PARAMS_PER_TYPE];\n} TelematicsProfile;\n\nstatic TelematicsProfile g_telematicsProfiles[MAX_TELEMATICS_PROFILES];\n\nvoid telematicsLogError_vulnerable(const char* message) {\n}\n\ntypedef struct {\n    uint8_t target_profile_idx;\n    uint8_t num_params_to_update;\n    TelematicsConfigParam param_updates[MAX_PROFILE_PARAMS_PER_TYPE + 1];\n} TelematicsConfigCommand_vulnerable;\n\nTelematicsConfigCommand_vulnerable receiveConfigCommand_vulnerable() {\n    TelematicsConfigCommand_vulnerable cmd;\n    cmd.target_profile_idx = 0;\n    cmd.num_params_to_update = MAX_PROFILE_PARAMS_PER_TYPE + 1;\n    \n    for (int i = 0; i < MAX_PROFILE_PARAMS_PER_TYPE + 1; ++i) {\n        cmd.param_updates[i].param_id = 0x1000 + i;\n        memset(cmd.param_updates[i].data, (uint8_t)i, CONFIG_DATA_SIZE);\n        cmd.param_updates[i].checksum = 0xDEADBEEF;\n    }\n    return cmd;\n}\n\nvoid initializeTelematicsProfiles_vulnerable() {\n    g_telematicsProfiles[0].profile_type_id = 0x01;\n    g_telematicsProfiles[0].active_param_count = 3;\n    for(int i = 0; i < 3; ++i) {\n        g_telematicsProfiles[0].params[i].param_id = 0x100 + i;\n        memset(g_telematicsProfiles[0].params[i].data, (uint8_t)(0xA0 + i), CONFIG_DATA_SIZE);\n        g_telematicsProfiles[0].params[i].checksum = 0xCCCCCCCC;\n    }\n    g_telematicsProfiles[1].profile_type_id = 0x02;\n    g_telematicsProfiles[1].active_param_count = 5;\n}\n\nvoid processTelematicsConfig_vulnerable() {\n    TelematicsConfigCommand_vulnerable cmd = receiveConfigCommand_vulnerable();\n\n    if (cmd.target_profile_idx < MAX_TELEMATICS_PROFILES) {\n        TelematicsProfile* profile = &g_telematicsProfiles[cmd.target_profile_idx];\n        \n        for (int i = 0; i < cmd.num_params_to_update; ++i) {\n            profile->params[i] = cmd.param_updates[i];\n        }\n        telematicsLogError_vulnerable(\"Telematics profile updated (vulnerable).\");\n    } else {\n        telematicsLogError_vulnerable(\"Invalid telematics profile index received (vulnerable).\");\n    }\n}\n\nvoid telematicsManagerMain_vulnerable() {\n    initializeTelematicsProfiles_vulnerable();\n    processTelematicsConfig_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_EVENT_BUFFER_SIZE 32\n#define DIAG_EVENT_DATA_LEN 8\n\ntypedef struct {\n    uint32_t event_timestamp;\n    uint16_t event_id;\n    uint8_t event_data[DIAG_EVENT_DATA_LEN];\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diag_event_buffer[DIAG_EVENT_BUFFER_SIZE];\nstatic int32_t g_diag_write_idx = -1; \nstatic uint32_t g_events_in_buffer = 0;\n\nvoid init_diag_event_recorder() {\n    memset(g_diag_event_buffer, 0, sizeof(g_diag_event_buffer));\n    g_diag_write_idx = -1;\n    g_events_in_buffer = 0;\n}\n\nvoid record_diagnostic_event(uint16_t id, const uint8_t* data) {\n    g_diag_write_idx = (g_diag_write_idx + 1) % DIAG_EVENT_BUFFER_SIZE;\n    g_diag_event_buffer[g_diag_write_idx].event_timestamp = 0xDEADBEEF; \n    g_diag_event_buffer[g_diag_write_idx].event_id = id;\n    memcpy(g_diag_event_buffer[g_diag_write_idx].event_data, data, DIAG_EVENT_DATA_LEN);\n    g_events_in_buffer++;\n}\n\nDiagnosticEvent* get_previous_diag_event_vulnerable(uint32_t steps_back) {\n    if (g_events_in_buffer == 0) {\n        return NULL;\n    }\n\n    int32_t target_idx_raw = g_diag_write_idx - steps_back;\n\n    int32_t final_target_idx = target_idx_raw % DIAG_EVENT_BUFFER_SIZE;\n\n    return &g_diag_event_buffer[final_target_idx];\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define CONFIG_MEM_SIZE 1024\n#define MAX_PATCH_ENTRIES 16\n#define MAX_PATCH_PACKET_SIZE 512\n\nstatic uint8_t g_configMemory[CONFIG_MEM_SIZE];\n\ntypedef struct {\n    uint16_t offset;\n    uint8_t  length;\n} PatchEntryHeader;\n\ntypedef struct {\n    uint8_t          command_id;\n    uint8_t          num_patches;\n} PatchPacketHeader;\n\nvoid initConfigMemory() {\n    memset(g_configMemory, 0xAA, CONFIG_MEM_SIZE);\n}\n\nint applyConfigurationPatches(const uint8_t* raw_packet, uint16_t packet_len) {\n    if (raw_packet == NULL || packet_len < sizeof(PatchPacketHeader)) {\n        return -1;\n    }\n\n    const PatchPacketHeader* header = (const PatchPacketHeader*)raw_packet;\n    if (header->command_id != 0x01) {\n        return -2;\n    }\n\n    if (header->num_patches == 0 || header->num_patches > MAX_PATCH_ENTRIES) {\n        return -3;\n    }\n\n    uint16_t current_payload_offset = sizeof(PatchPacketHeader);\n    for (uint8_t i = 0; i < header->num_patches; ++i) {\n        if (current_payload_offset + sizeof(PatchEntryHeader) > packet_len) {\n            return -4;\n        }\n        \n        const PatchEntryHeader* entry_header = (const PatchEntryHeader*)(raw_packet + current_payload_offset);\n        \n        if (current_payload_offset + sizeof(PatchEntryHeader) + entry_header->length > packet_len) {\n            return -5;\n        }\n\n        if (entry_header->offset >= CONFIG_MEM_SIZE || (uint32_t)entry_header->offset + entry_header->length > CONFIG_MEM_SIZE) {\n            return -6;\n        }\n\n        const uint8_t* patch_data_src = raw_packet + current_payload_offset + sizeof(PatchEntryHeader);\n        for (uint8_t j = 0; j < entry_header->length; ++j) {\n            g_configMemory[entry_header->offset + j] = patch_data_src[j];\n        }\n\n        current_payload_offset += sizeof(PatchEntryHeader) + entry_header->length;\n    }\n\n    return 0;\n}\n\nuint8_t getConfigByte(uint16_t offset) {\n    if (offset < CONFIG_MEM_SIZE) {\n        return g_configMemory[offset];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_FEATURES 5\n#define MAX_PARAMS_PER_FEATURE_SLOT 10 \n\ntypedef struct {\n    uint32_t value;\n    bool     active;\n    uint8_t  access_level;\n} FeatureParameter;\n\nstatic FeatureParameter g_featureConfigurations_vulnerable[MAX_VEHICLE_FEATURES][MAX_PARAMS_PER_FEATURE_SLOT];\n\nstatic const uint8_t g_actualFeatureParameterCounts_vulnerable[MAX_VEHICLE_FEATURES] = {\n    7, \n    3, \n    9, \n    2, \n    5  \n};\n\ntypedef struct {\n    uint8_t feature_id;\n    uint8_t param_index;\n    uint32_t new_value;\n} FeatureUpdateCommand_vulnerable;\n\nvoid logVehicleConfigError_vulnerable(const char* msg) {\n}\n\nFeatureUpdateCommand_vulnerable receiveFeatureUpdateCommand_vulnerable() {\n    FeatureUpdateCommand_vulnerable cmd;\n    cmd.feature_id = 0; \n    cmd.param_index = 8; \n    cmd.new_value = 0xABCDEF00;\n    return cmd;\n}\n\nvoid initializeFeatureConfigs_vulnerable() {\n    for (uint8_t i = 0; i < MAX_VEHICLE_FEATURES; ++i) {\n        for (uint8_t j = 0; j < MAX_PARAMS_PER_FEATURE_SLOT; ++j) {\n            g_featureConfigurations_vulnerable[i][j] = (FeatureParameter){0, false, 0};\n        }\n    }\n    for (uint8_t i = 0; i < MAX_VEHICLE_FEATURES; ++i) {\n        for (uint8_t j = 0; j < g_actualFeatureParameterCounts_vulnerable[i]; ++j) {\n            g_featureConfigurations_vulnerable[i][j].active = true;\n            g_featureConfigurations_vulnerable[i][j].access_level = 1;\n        }\n    }\n}\n\nvoid processFeatureUpdate_vulnerable() {\n    FeatureUpdateCommand_vulnerable cmd = receiveFeatureUpdateCommand_vulnerable();\n\n    if (cmd.feature_id < MAX_VEHICLE_FEATURES) {\n        if (cmd.param_index < MAX_PARAMS_PER_FEATURE_SLOT) { \n            g_featureConfigurations_vulnerable[cmd.feature_id][cmd.param_index].value = cmd.new_value;\n            logVehicleConfigError_vulnerable(\"Feature configuration update processed.\");\n        } else {\n            logVehicleConfigError_vulnerable(\"Parameter index out of global bounds.\");\n        }\n    } else {\n        logVehicleConfigError_vulnerable(\"Invalid feature ID received.\");\n    }\n}\n\nvoid vehicleConfigSystemMain_vulnerable() {\n    initializeFeatureConfigs_vulnerable();\n    processFeatureUpdate_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_DRIVER_PROFILES 5\n\ntypedef struct {\n    int seat_position;\n    int mirror_angle;\n    int climate_temp_celsius;\n    bool preferred_lighting;\n} DriverProfile;\n\nstatic DriverProfile g_driverProfiles_fixed[MAX_DRIVER_PROFILES];\n\nvoid logSystemEvent_fixed(const char* event) {\n    printf(\"LOG: %s\\n\", event);\n}\n\nvoid logSystemError_fixed(const char* error) {\n    fprintf(stderr, \"ERROR: %s\\n\", error);\n}\n\ntypedef struct {\n    uint8_t profileId;\n    int16_t newSeatPosition;\n    int16_t newMirrorAngle;\n    int8_t newClimateTempCelsius;\n    bool newPreferredLighting;\n} ProfileUpdateCommand;\n\nProfileUpdateCommand receiveProfileUpdateCommand_fixed() {\n    ProfileUpdateCommand cmd;\n    cmd.profileId = 5; \n    cmd.newSeatPosition = 150; \n    cmd.newMirrorAngle = 30; \n    cmd.newClimateTempCelsius = 22; \n    cmd.newPreferredLighting = true; \n    logSystemEvent_fixed(\"Simulating reception of profile update command (fixed).\");\n    return cmd;\n}\n\nvoid initializeDriverProfiles_fixed() {\n    for (uint8_t i = 0; i < MAX_DRIVER_PROFILES; ++i) {\n        g_driverProfiles_fixed[i].seat_position = 0;\n        g_driverProfiles_fixed[i].mirror_angle = 0;\n        g_driverProfiles_fixed[i].climate_temp_celsius = 20;\n        g_driverProfiles_fixed[i].preferred_lighting = false;\n    }\n    logSystemEvent_fixed(\"Driver profiles initialized (fixed).\");\n}\n\nvoid updateDriverProfile_fixed() {\n    ProfileUpdateCommand command = receiveProfileUpdateCommand_fixed();\n\n    if (command.profileId < MAX_DRIVER_PROFILES) {\n        g_driverProfiles_fixed[command.profileId].seat_position = command.newSeatPosition;\n        g_driverProfiles_fixed[command.profileId].mirror_angle = command.newMirrorAngle;\n        g_driverProfiles_fixed[command.profileId].climate_temp_celsius = command.newClimateTempCelsius;\n        g_driverProfiles_fixed[command.profileId].preferred_lighting = command.newPreferredLighting;\n        logSystemEvent_fixed(\"Driver profile updated (fixed).\");\n    } else {\n        logSystemError_fixed(\"Invalid profile ID received for update. Index out of bounds.\");\n    }\n}\n\nvoid driverProfileManager_fixed_main() {\n    initializeDriverProfiles_fixed();\n    updateDriverProfile_fixed();\n}\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SENSOR_LOG_BUFFER_SIZE 64\n#define SENSOR_DATA_INVALID_MARKER 0xFF\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t sensor_id;\n    int16_t  value;\n} SensorLogEntry;\n\nstatic SensorLogEntry g_sensor_log_buffer[SENSOR_LOG_BUFFER_SIZE];\nstatic uint16_t g_log_head_idx = 0;\n\nvoid init_sensor_logger() {\n    memset(g_sensor_log_buffer, 0, sizeof(g_sensor_log_buffer));\n    g_log_head_idx = 0;\n}\n\nvoid add_sensor_reading(uint32_t ts, uint16_t id, int16_t val) {\n    g_sensor_log_buffer[g_log_head_idx].timestamp = ts;\n    g_sensor_log_buffer[g_log_head_idx].sensor_id = id;\n    g_sensor_log_buffer[g_log_head_idx].value = val;\n    g_log_head_idx = (g_log_head_idx + 1) % SENSOR_LOG_BUFFER_SIZE;\n}\n\nvoid invalidate_oldest_log_entries_fixed(uint16_t num_entries_to_invalidate) {\n    if (num_entries_to_invalidate == 0) {\n        return;\n    }\n\n    uint16_t actual_entries_to_invalidate = num_entries_to_invalidate;\n    if (actual_entries_to_invalidate > SENSOR_LOG_BUFFER_SIZE) {\n        actual_entries_to_invalidate = SENSOR_LOG_BUFFER_SIZE;\n    }\n\n    for (uint16_t i = 0; i < actual_entries_to_invalidate; ++i) {\n        int32_t conceptual_index_for_modulo = (int32_t)g_log_head_idx - actual_entries_to_invalidate + i;\n        uint16_t target_idx = (uint16_t)(((conceptual_index_for_modulo % SENSOR_LOG_BUFFER_SIZE) + SENSOR_LOG_BUFFER_SIZE) % SENSOR_LOG_BUFFER_SIZE);\n        g_sensor_log_buffer[target_idx].value = SENSOR_DATA_INVALID_MARKER;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAGNOSTIC_BUFFER_SIZE 256\n#define DIAG_DATA_POINT_SIZE 4\n\nstatic uint8_t g_diagnostic_data_buffer[DIAGNOSTIC_BUFFER_SIZE];\nstatic int32_t g_current_read_offset = 0;\nstatic uint32_t g_bytes_stored = 0;\n\nvoid init_diagnostic_system() {\n    memset(g_diagnostic_data_buffer, 0, sizeof(g_diagnostic_data_buffer));\n    g_current_read_offset = 0;\n    g_bytes_stored = 0;\n}\n\nbool add_diagnostic_data(const uint8_t* data, uint32_t len) {\n    if (len == 0 || data == NULL || (g_bytes_stored + len) > DIAGNOSTIC_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_diagnostic_data_buffer + g_bytes_stored, data, len);\n    g_bytes_stored += len;\n    return true;\n}\n\nuint32_t process_diagnostic_data_point() {\n    if (g_current_read_offset < 0 || g_current_read_offset + DIAG_DATA_POINT_SIZE > g_bytes_stored) {\n        return 0xFFFFFFFF;\n    }\n    uint32_t data_point;\n    memcpy(&data_point, g_diagnostic_data_buffer + g_current_read_offset, DIAG_DATA_POINT_SIZE);\n    g_current_read_offset += DIAG_DATA_POINT_SIZE;\n    return data_point;\n}\n\nvoid rewind_and_invalidate_diagnostic_stream_vulnerable(uint32_t num_data_points_to_rewind) {\n    if (g_bytes_stored == 0) {\n        return;\n    }\n\n    uint32_t bytes_to_rewind = num_data_points_to_rewind * DIAG_DATA_POINT_SIZE;\n\n    int32_t new_read_offset = g_current_read_offset - bytes_to_rewind;\n\n    int32_t start_clear_idx = new_read_offset;\n    int32_t end_clear_idx = g_current_read_offset;\n\n    for (int32_t i = start_clear_idx; i < end_clear_idx; ++i) {\n        g_diagnostic_data_buffer[i] = 0x00;\n    }\n\n    if (new_read_offset < 0) {\n        g_current_read_offset = 0;\n    } else {\n        g_current_read_offset = new_read_offset;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define ECU_CONFIG_DATA_MAX_SIZE 128\n#define PARAM_ID_CUSTOM_SETTING 0x1A\n#define PARAM_ID_DIAG_MODE 0x05\n\nstatic uint8_t g_ecuConfigData[ECU_CONFIG_DATA_MAX_SIZE];\n\nvoid initEcuConfig() {\n    for (size_t i = 0; i < ECU_CONFIG_DATA_MAX_SIZE; ++i) {\n        g_ecuConfigData[i] = 0x00;\n    }\n    g_ecuConfigData[0] = 0xAA;\n    g_ecuConfigData[1] = 0xBB;\n    g_ecuConfigData[2] = 0xCC;\n}\n\nint processConfigParameter(const uint8_t* param_stream, uint16_t stream_len) {\n    if (param_stream == NULL || stream_len < 4) {\n        return -1;\n    }\n\n    uint16_t param_id = (param_stream[0] << 8) | param_stream[1];\n    uint16_t data_len = (param_stream[2] << 8) | param_stream[3];\n    const uint8_t* data_src_ptr = param_stream + 4;\n\n    if (4 + data_len > stream_len) {\n        return -2;\n    }\n\n    if (param_id == PARAM_ID_CUSTOM_SETTING) {\n        const uint8_t CUSTOM_SETTING_OFFSET = 10; \n\n        if (CUSTOM_SETTING_OFFSET >= ECU_CONFIG_DATA_MAX_SIZE) {\n            return -3;\n        }\n        \n        uint8_t* dest_ptr = &g_ecuConfigData[CUSTOM_SETTING_OFFSET];\n        for (uint16_t i = 0; i < data_len; ++i) {\n            *dest_ptr = data_src_ptr[i];\n            dest_ptr++;\n        }\n    } else if (param_id == PARAM_ID_DIAG_MODE) {\n        if (data_len != 1) return -4;\n        g_ecuConfigData[0] = data_src_ptr[0];\n    } else {\n        return -99;\n    }\n\n    return 0;\n}\n\nuint8_t getEcuConfigByte(uint8_t index) {\n    if (index < ECU_CONFIG_DATA_MAX_SIZE) {\n        return g_ecuConfigData[index];\n    }\n    return 0xFF;\n}\n\nvoid receiveConfigUpdate(const uint8_t* msg_data, uint16_t msg_len) {\n    processConfigParameter(msg_data, msg_len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define COMMAND_QUEUE_SIZE 10\n\ntypedef enum {\n    CMD_NONE = 0,\n    CMD_LOCK_DOOR,\n    CMD_UNLOCK_DOOR,\n    CMD_ADJUST_SEAT,\n    CMD_PERFORM_DIAG,\n    CMD_TOTAL\n} VehicleCommandId;\n\ntypedef struct {\n    VehicleCommandId id;\n    int16_t param1;\n    int16_t param2;\n    uint8_t flags;\n    bool processed;\n} VehicleCommand;\n\nstatic VehicleCommand g_command_queue_fixed[COMMAND_QUEUE_SIZE];\nstatic int g_command_queue_head_fixed = 0;\nstatic int g_command_queue_tail_fixed = 0;\nstatic int g_command_queue_count_fixed = 0;\n\nvoid init_command_queue_fixed() {\n    memset(g_command_queue_fixed, 0, sizeof(g_command_queue_fixed));\n    g_command_queue_head_fixed = 0;\n    g_command_queue_tail_fixed = 0;\n    g_command_queue_count_fixed = 0;\n}\n\nbool enqueue_command_fixed(VehicleCommandId id, int16_t p1, int16_t p2) {\n    if (g_command_queue_count_fixed >= COMMAND_QUEUE_SIZE) {\n        return false;\n    }\n\n    g_command_queue_fixed[g_command_queue_tail_fixed].id = id;\n    g_command_queue_fixed[g_command_queue_tail_fixed].param1 = p1;\n    g_command_queue_fixed[g_command_queue_tail_fixed].param2 = p2;\n    g_command_queue_fixed[g_command_queue_tail_fixed].flags = 0;\n    g_command_queue_fixed[g_command_queue_tail_fixed].processed = false;\n\n    g_command_queue_tail_fixed = (g_command_queue_tail_fixed + 1) % COMMAND_QUEUE_SIZE;\n    g_command_queue_count_fixed++;\n    return true;\n}\n\nbool dequeue_command_fixed(VehicleCommand* cmd_out) {\n    if (g_command_queue_count_fixed == 0) {\n        return false;\n    }\n\n    *cmd_out = g_command_queue_fixed[g_command_queue_head_fixed];\n    g_command_queue_head_fixed = (g_command_queue_head_fixed + 1) % COMMAND_QUEUE_SIZE;\n    g_command_queue_count_fixed--;\n    return true;\n}\n\nvoid reinsert_critical_command_fixed(VehicleCommand cmd) {\n    if (g_command_queue_count_fixed >= COMMAND_QUEUE_SIZE) {\n        return;\n    }\n\n    g_command_queue_head_fixed = (g_command_queue_head_fixed - 1 + COMMAND_QUEUE_SIZE) % COMMAND_QUEUE_SIZE;\n\n    g_command_queue_fixed[g_command_queue_head_fixed] = cmd;\n\n    g_command_queue_count_fixed++;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_SUB_COMPONENTS_ENGINE         8\n#define MAX_SUB_COMPONENTS_TRANSMISSION   4\n#define MAX_SUB_COMPONENTS_BRAKE          6\n#define MAX_SUB_COMPONENTS_INFOTAINMENT   10\n\ntypedef enum {\n    VEHICLE_COMPONENT_ENGINE = 0,\n    VEHICLE_COMPONENT_TRANSMISSION,\n    VEHICLE_COMPONENT_BRAKE,\n    VEHICLE_COMPONENT_INFOTAINMENT,\n    NUM_VEHICLE_COMPONENTS\n} VehicleComponentType;\n\ntypedef struct {\n    uint8_t  status_code;\n    uint32_t last_update_timestamp;\n    bool     is_active;\n} SubComponentStatus;\n\ntypedef struct {\n    SubComponentStatus* status_array_ptr;\n    uint8_t             max_size;\n} ComponentDataStorage;\n\nstatic SubComponentStatus g_engineSubComponentStatuses[MAX_SUB_COMPONENTS_ENGINE];\nstatic SubComponentStatus g_transmissionSubComponentStatuses[MAX_SUB_COMPONENTS_TRANSMISSION];\nstatic SubComponentStatus g_brakeSubComponentStatuses[MAX_SUB_COMPONENTS_BRAKE];\nstatic SubComponentStatus g_infotainmentSubComponentStatuses[MAX_SUB_COMPONENTS_INFOTAINMENT];\n\nstatic ComponentDataStorage g_componentDataRegistry[NUM_VEHICLE_COMPONENTS];\n\ntypedef struct {\n    VehicleComponentType component_type;\n    uint8_t              sub_component_id;\n    uint8_t              new_status_code;\n    uint32_t             timestamp;\n} ComponentStatusMessage;\n\nvoid logAutomotiveEvent(const char* msg) {\n}\n\nvoid initializeComponentStatusSystem_vulnerable() {\n    g_componentDataRegistry[VEHICLE_COMPONENT_ENGINE].status_array_ptr = g_engineSubComponentStatuses;\n    g_componentDataRegistry[VEHICLE_COMPONENT_ENGINE].max_size = MAX_SUB_COMPONENTS_ENGINE;\n\n    g_componentDataRegistry[VEHICLE_COMPONENT_TRANSMISSION].status_array_ptr = g_transmissionSubComponentStatuses;\n    g_componentDataRegistry[VEHICLE_COMPONENT_TRANSMISSION].max_size = MAX_SUB_COMPONENTS_TRANSMISSION;\n\n    g_componentDataRegistry[VEHICLE_COMPONENT_BRAKE].status_array_ptr = g_brakeSubComponentStatuses;\n    g_componentDataRegistry[VEHICLE_COMPONENT_BRAKE].max_size = MAX_SUB_COMPONENTS_BRAKE;\n\n    g_componentDataRegistry[VEHICLE_COMPONENT_INFOTAINMENT].status_array_ptr = g_infotainmentSubComponentStatuses;\n    g_componentDataRegistry[VEHICLE_COMPONENT_INFOTAINMENT].max_size = MAX_SUB_COMPONENTS_INFOTAINMENT;\n\n    for (int i = 0; i < MAX_SUB_COMPONENTS_ENGINE; ++i) g_engineSubComponentStatuses[i] = (SubComponentStatus){0, 0, false};\n    for (int i = 0; i < MAX_SUB_COMPONENTS_TRANSMISSION; ++i) g_transmissionSubComponentStatuses[i] = (SubComponentStatus){0, 0, false};\n    for (int i = 0; i < MAX_SUB_COMPONENTS_BRAKE; ++i) g_brakeSubComponentStatuses[i] = (SubComponentStatus){0, 0, false};\n    for (int i = 0; i < MAX_SUB_COMPONENTS_INFOTAINMENT; ++i) g_infotainmentSubComponentStatuses[i] = (SubComponentStatus){0, 0, false};\n\n    logAutomotiveEvent(\"Component status system initialized (vulnerable).\");\n}\n\nComponentStatusMessage simulateIncomingStatusMessage_vulnerable() {\n    ComponentStatusMessage msg;\n    msg.component_type = VEHICLE_COMPONENT_TRANSMISSION;\n    msg.sub_component_id = 4;\n    msg.new_status_code = 0xAA;\n    msg.timestamp = 0x12345678;\n    return msg;\n}\n\nvoid processComponentStatusUpdate_vulnerable(ComponentStatusMessage msg) {\n    if (msg.component_type < NUM_VEHICLE_COMPONENTS) {\n        ComponentDataStorage* target_storage = &g_componentDataRegistry[msg.component_type];\n        target_storage->status_array_ptr[msg.sub_component_id].status_code = msg.new_status_code;\n        target_storage->status_array_ptr[msg.sub_component_id].last_update_timestamp = msg.timestamp;\n        target_storage->status_array_ptr[msg.sub_component_id].is_active = true;\n        logAutomotiveEvent(\"Component status update processed (vulnerable).\");\n    } else {\n        logAutomotiveEvent(\"Received status update for invalid component type (vulnerable).\");\n    }\n}\n\nvoid vehicleStatusMonitor_vulnerable_main() {\n    initializeComponentStatusSystem_vulnerable();\n    ComponentStatusMessage update_msg = simulateIncomingStatusMessage_vulnerable();\n    processComponentStatusUpdate_vulnerable(update_msg);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 256\n#define PATCH_BLOCK_MAX_SIZE 64\n#define CONFIG_AREA_START_OFFSET 10\n\nstatic uint8_t g_vehicle_config[VEHICLE_CONFIG_BUFFER_SIZE];\n\nvoid init_vehicle_config() {\n    memset(g_vehicle_config, 0, VEHICLE_CONFIG_BUFFER_SIZE);\n    for (int i = 0; i < (VEHICLE_CONFIG_BUFFER_SIZE - CONFIG_AREA_START_OFFSET); i++) {\n        g_vehicle_config[CONFIG_AREA_START_OFFSET + i] = (uint8_t)i;\n    }\n}\n\nvoid apply_config_patch_vulnerable(const uint8_t* patch_data, uint16_t patch_len, int16_t patch_start_addr_offset) {\n    if (patch_data == NULL || patch_len == 0 || patch_len > PATCH_BLOCK_MAX_SIZE) {\n        return;\n    }\n\n    int32_t absolute_target_address_idx = (int32_t)CONFIG_AREA_START_OFFSET + patch_start_addr_offset;\n\n    if (absolute_target_address_idx + patch_len > VEHICLE_CONFIG_BUFFER_SIZE) {\n        return;\n    }\n    \n    memcpy(g_vehicle_config + absolute_target_address_idx, patch_data, patch_len);\n\n    volatile uint8_t check_byte = g_vehicle_config[CONFIG_AREA_START_OFFSET];\n    (void)check_byte;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_DIAG_HANDLERS_FIXED 16\n\ntypedef struct {\n    uint32_t raw_event_code;\n} DiagnosticEvent_Fixed;\n\ntypedef void (*DiagnosticHandler_Fixed)(uint16_t error_code, uint8_t module_id);\n\nvoid handleSubComponent0_fixed(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent1_fixed(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent2_fixed(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent3_fixed(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent4_fixed(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent5_fixed(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent6_fixed(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent7_fixed(uint16_t error_code, uint8_t module_id) {}\n\nstatic DiagnosticHandler_Fixed g_diagHandlers_fixed[MAX_DIAG_HANDLERS_FIXED];\nstatic const uint8_t actual_num_diag_handlers_fixed = 8;\n\nvoid automotive_system_log_fixed(const char* msg) {\n}\n\nDiagnosticEvent_Fixed receiveDiagnosticEvent_fixed() {\n    DiagnosticEvent_Fixed event;\n    event.raw_event_code = 0x01234508;\n    return event;\n}\n\nvoid initializeDiagnosticSystem_fixed() {\n    g_diagHandlers_fixed[0] = handleSubComponent0_fixed;\n    g_diagHandlers_fixed[1] = handleSubComponent1_fixed;\n    g_diagHandlers_fixed[2] = handleSubComponent2_fixed;\n    g_diagHandlers_fixed[3] = handleSubComponent3_fixed;\n    g_diagHandlers_fixed[4] = handleSubComponent4_fixed;\n    g_diagHandlers_fixed[5] = handleSubComponent5_fixed;\n    g_diagHandlers_fixed[6] = handleSubComponent6_fixed;\n    g_diagHandlers_fixed[7] = handleSubComponent7_fixed;\n\n    for (uint8_t i = actual_num_diag_handlers_fixed; i < MAX_DIAG_HANDLERS_FIXED; ++i) {\n        g_diagHandlers_fixed[i] = NULL;\n    }\n\n    automotive_system_log_fixed(\"Diagnostic system initialized (fixed).\");\n}\n\nvoid processDiagnosticEvent_fixed() {\n    DiagnosticEvent_Fixed event = receiveDiagnosticEvent_fixed();\n\n    uint8_t component_index = (uint8_t)(event.raw_event_code & 0xFF);\n    uint16_t error_code = (uint16_t)((event.raw_event_code >> 8) & 0xFFFF);\n    uint8_t module_id = (uint8_t)((event.raw_event_code >> 24) & 0xFF);\n\n    if (component_index < actual_num_diag_handlers_fixed) {\n        DiagnosticHandler_Fixed handler = g_diagHandlers_fixed[component_index];\n        if (handler != NULL) {\n            handler(error_code, module_id);\n            automotive_system_log_fixed(\"Diagnostic event dispatched (fixed).\");\n        } else {\n            automotive_system_log_fixed(\"No handler found for component index (fixed).\");\n        }\n    } else {\n        automotive_system_log_fixed(\"Invalid component index out of actual handler bounds (fixed).\");\n    }\n}\n\nvoid main_diag_fixed() {\n    initializeDiagnosticSystem_fixed();\n    processDiagnosticEvent_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CONFIG_AREA_SIZE 256\n#define ECU_MAX_PARAM_VALUE 0xFF\n\nstatic uint8_t g_ecu_config_area[CONFIG_AREA_SIZE];\n\ntypedef struct {\n    uint16_t param_id;\n    uint16_t base_offset;\n    uint8_t size;\n    int16_t lock_byte_offset;\n} ConfigParamMetadata;\n\nstatic const ConfigParamMetadata g_param_mapping[] = {\n    {0x0001, 0, 4, -1},\n    {0x0002, 4, 2, -3},\n    {0x0003, 6, 8, -7},\n    {0x0004, 14, 1, 0},\n    {0x0005, 15, 16, 17}\n};\n#define NUM_PARAM_MAPPINGS (sizeof(g_param_mapping) / sizeof(g_param_mapping[0]))\n\nvoid init_ecu_config_area() {\n    memset(g_ecu_config_area, ECU_MAX_PARAM_VALUE, CONFIG_AREA_SIZE);\n}\n\nbool get_config_parameter(uint16_t param_id, uint8_t* buffer, uint32_t buffer_len) {\n    for (int i = 0; i < NUM_PARAM_MAPPINGS; ++i) {\n        if (g_param_mapping[i].param_id == param_id) {\n            const ConfigParamMetadata* meta = &g_param_mapping[i];\n            if (buffer_len < meta->size || meta->base_offset + meta->size > CONFIG_AREA_SIZE) {\n                return false;\n            }\n            memcpy(buffer, g_ecu_config_area + meta->base_offset, meta->size);\n            return true;\n        }\n    }\n    return false;\n}\n\nbool update_config_parameter_fixed(uint16_t param_id, const uint8_t* new_data, uint32_t data_len) {\n    const ConfigParamMetadata* meta = NULL;\n    for (int i = 0; i < NUM_PARAM_MAPPINGS; ++i) {\n        if (g_param_mapping[i].param_id == param_id) {\n            meta = &g_param_mapping[i];\n            break;\n        }\n    }\n\n    if (meta == NULL) {\n        return false;\n    }\n\n    if (data_len != meta->size) {\n        return false;\n    }\n\n    if (meta->base_offset + meta->size > CONFIG_AREA_SIZE) {\n        return false;\n    }\n\n    int32_t lock_byte_absolute_offset = (int32_t)meta->base_offset + meta->lock_byte_offset;\n\n    if (lock_byte_absolute_offset < 0 || lock_byte_absolute_offset >= CONFIG_AREA_SIZE) {\n        return false;\n    }\n\n    g_ecu_config_area[lock_byte_absolute_offset] = 0xAA;\n\n    memcpy(g_ecu_config_area + meta->base_offset, new_data, data_len);\n\n    return true;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_STORAGE_SIZE 1024\n#define DIAG_RESPONSE_BUFFER_SIZE 256\n\nstatic uint8_t g_vehicleConfig[VEHICLE_CONFIG_STORAGE_SIZE];\n\nvoid initVehicleConfig() {\n    for (int i = 0; i < VEHICLE_CONFIG_STORAGE_SIZE; ++i) {\n        g_vehicleConfig[i] = (uint8_t)(i % 0xFF);\n    }\n}\n\ntypedef struct {\n    uint16_t serviceId;\n    uint16_t configAreaOffset;\n    uint16_t bytesToRead;\n} DiagReadConfigRequest;\n\ntypedef struct {\n    uint16_t serviceIdResponse;\n    uint8_t data[DIAG_RESPONSE_BUFFER_SIZE];\n    uint16_t dataLength;\n} DiagReadConfigResponse;\n\nint handleDiagReadConfigRequest(const DiagReadConfigRequest* request, DiagReadConfigResponse* response) {\n    if (request == NULL || response == NULL) {\n        return -1;\n    }\n\n    if (request->serviceId != 0x22) {\n        return -1;\n    }\n\n    uint16_t offset = request->configAreaOffset;\n    uint16_t length = request->bytesToRead;\n\n    uint16_t total_read_end_idx = offset + length;\n\n    if (total_read_end_idx > VEHICLE_CONFIG_STORAGE_SIZE) {\n        return -2;\n    }\n\n    if (offset >= VEHICLE_CONFIG_STORAGE_SIZE) {\n        return -2;\n    }\n\n    uint16_t bytes_to_copy = length;\n    if (bytes_to_copy > DIAG_RESPONSE_BUFFER_SIZE) {\n        bytes_to_copy = DIAG_RESPONSE_BUFFER_SIZE;\n    }\n\n    memcpy(response->data, g_vehicleConfig + offset, bytes_to_copy);\n\n    response->serviceIdResponse = 0x62;\n    response->dataLength = bytes_to_copy;\n\n    return 0;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_ROUTES_FIXED 5\n#define MAX_WAYPOINTS_PER_ROUTE_FIXED 100\n\ntypedef struct {\n    float latitude;\n    float longitude;\n    uint16_t altitude;\n} Waypoint_Fixed;\n\ntypedef struct {\n    uint8_t route_id;\n    uint8_t current_waypoint_idx;\n    uint16_t total_waypoints;\n    Waypoint_Fixed waypoints[MAX_WAYPOINTS_PER_ROUTE_FIXED];\n} RouteData_Fixed;\n\nstatic RouteData_Fixed g_vehicleRoutes_fixed[MAX_ROUTES_FIXED];\n\nvoid vehicleLog_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t route_idx;\n    int16_t offset_from_current;\n} WaypointQuery_Fixed;\n\nWaypointQuery_Fixed receiveWaypointQuery_fixed() {\n    WaypointQuery_Fixed query;\n    query.route_idx = 0;\n    query.offset_from_current = -1;\n    return query;\n}\n\nvoid initializeRoutes_fixed() {\n    for (uint8_t i = 0; i < MAX_ROUTES_FIXED; ++i) {\n        g_vehicleRoutes_fixed[i].route_id = i;\n        g_vehicleRoutes_fixed[i].current_waypoint_idx = 0;\n        g_vehicleRoutes_fixed[i].total_waypoints = (i + 1) * 10;\n        if (g_vehicleRoutes_fixed[i].total_waypoints > MAX_WAYPOINTS_PER_ROUTE_FIXED) {\n            g_vehicleRoutes_fixed[i].total_waypoints = MAX_WAYPOINTS_PER_ROUTE_FIXED;\n        }\n        for (uint16_t j = 0; j < g_vehicleRoutes_fixed[i].total_waypoints; ++j) {\n            g_vehicleRoutes_fixed[i].waypoints[j] = (Waypoint_Fixed){ (float)(10.0 + i + j), (float)(20.0 + i + j), (uint16_t)(100 + j) };\n        }\n    }\n    vehicleLog_fixed(\"Vehicle routes initialized (fixed).\");\n}\n\nvoid processWaypointQuery_fixed() {\n    WaypointQuery_Fixed query = receiveWaypointQuery_fixed();\n\n    if (query.route_idx < MAX_ROUTES_FIXED) {\n        RouteData_Fixed* current_route = &g_vehicleRoutes_fixed[query.route_idx];\n\n        int32_t temp_effective_index = current_route->current_waypoint_idx + query.offset_from_current;\n\n        if (temp_effective_index >= 0 && temp_effective_index < current_route->total_waypoints) {\n            uint16_t effective_index = (uint16_t)temp_effective_index;\n            Waypoint_Fixed requested_waypoint = current_route->waypoints[effective_index];\n            vehicleLog_fixed(\"Waypoint data retrieved (fixed).\");\n        } else {\n            vehicleLog_fixed(\"Requested waypoint index out of bounds for route (fixed).\");\n        }\n    } else {\n        vehicleLog_fixed(\"Invalid route index received (fixed).\");\n    }\n}\n\nvoid navigationSystemMain_fixed() {\n    initializeRoutes_fixed();\n    processWaypointQuery_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t details_length_bytes;\n} EventLogHeader;\n\nclass VehicleEventLogger {\npublic:\n    VehicleEventLogger() : m_log_buffer(nullptr), m_current_buffer_pos(0), m_allocated_capacity(0) {}\n\n    ~VehicleEventLogger() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n    }\n\n    void clearLogs() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n        m_log_buffer = nullptr;\n        m_current_buffer_pos = 0;\n        m_allocated_capacity = 0;\n    }\n\n    bool appendEventVulnerable(const uint8_t* raw_event_data, size_t data_packet_length) {\n        if (!raw_event_data || data_packet_length < sizeof(EventLogHeader)) {\n            return false;\n        }\n\n        const EventLogHeader* header = reinterpret_cast<const EventLogHeader*>(raw_event_data);\n        uint16_t details_len = header->details_length_bytes;\n\n        if (data_packet_length < sizeof(EventLogHeader) + details_len) {\n            return false;\n        }\n\n        size_t current_record_size_raw = sizeof(EventLogHeader) + details_len;\n        size_t padded_details_len = (details_len + 3) & ~3;\n        \n        size_t required_total_size = m_current_buffer_pos + current_record_size_raw;\n\n        if (required_total_size < m_current_buffer_pos) {\n            return false;\n        }\n        \n        if (required_total_size > m_allocated_capacity) {\n            size_t new_capacity = required_total_size;\n            if (new_capacity < 256) new_capacity = 256;\n            if (new_capacity < required_total_size) new_capacity = required_total_size;\n\n            uint8_t* temp_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n            if (!temp_buffer) {\n                if (m_log_buffer) {\n                    free(m_log_buffer);\n                    m_log_buffer = nullptr;\n                }\n                m_allocated_capacity = 0;\n                m_current_buffer_pos = 0;\n                return false;\n            }\n            m_log_buffer = temp_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        for (size_t i = 0; i < sizeof(EventLogHeader); ++i) {\n            m_log_buffer[m_current_buffer_pos + i] = raw_event_data[i];\n        }\n\n        const uint8_t* details_src_ptr = raw_event_data + sizeof(EventLogHeader);\n        uint8_t* details_dest_ptr = m_log_buffer + m_current_buffer_pos + sizeof(EventLogHeader);\n\n        for (uint16_t i = 0; i < details_len; ++i) {\n            details_dest_ptr[i] = details_src_ptr[i];\n        }\n\n        size_t padding_bytes = padded_details_len - details_len;\n        if (padding_bytes > 0) {\n            memset(details_dest_ptr + details_len, 0, padding_bytes);\n        }\n\n        m_current_buffer_pos += (sizeof(EventLogHeader) + padded_details_len);\n\n        return true;\n    }\n\n    size_t getTotalLoggedBytes() const {\n        return m_current_buffer_pos;\n    }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t   m_current_buffer_pos;\n    size_t   m_allocated_capacity;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_BUFFER_SIZE 256\n#define MAX_TELEMETRY_PACKET_SIZE 512\n#define MAX_SINGLE_ENTRY_PAYLOAD_LEN (TELEMETRY_BUFFER_SIZE - sizeof(TelemetryDataHeader)) \n\nstatic uint8_t g_telemetryBuffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_telemetryCurrentOffset = 0;\n\ntypedef struct {\n    uint8_t sensor_id;\n    uint8_t data_type;\n    uint16_t data_len;\n} TelemetryDataHeader;\n\nvoid initTelemetryAggregator() {\n    memset(g_telemetryBuffer, 0x00, TELEMETRY_BUFFER_SIZE);\n    g_telemetryCurrentOffset = 0;\n}\n\nint appendSingleTelemetryEntry(const uint8_t* raw_entry_data, uint16_t raw_entry_len) {\n    if (raw_entry_data == NULL || raw_entry_len < sizeof(TelemetryDataHeader)) {\n        return -1;\n    }\n\n    uint8_t sensor_id = raw_entry_data[0];\n    uint8_t data_type = raw_entry_data[1];\n    uint16_t received_data_len = (raw_entry_data[2] << 8) | raw_entry_data[3];\n    const uint8_t* actual_data_ptr = raw_entry_data + sizeof(TelemetryDataHeader);\n\n    if (sizeof(TelemetryDataHeader) + received_data_len > raw_entry_len) {\n        return -2;\n    }\n\n    uint16_t effective_data_len = received_data_len;\n    if (effective_data_len > MAX_SINGLE_ENTRY_PAYLOAD_LEN) {\n        effective_data_len = MAX_SINGLE_ENTRY_PAYLOAD_LEN;\n    }\n\n    uint32_t entry_total_size_check = (uint32_t)sizeof(TelemetryDataHeader) + effective_data_len;\n\n    if ((uint32_t)g_telemetryCurrentOffset + entry_total_size_check > TELEMETRY_BUFFER_SIZE) {\n        return -3;\n    }\n\n    uint8_t* write_ptr = g_telemetryBuffer + g_telemetryCurrentOffset;\n    *write_ptr++ = sensor_id;\n    *write_ptr++ = data_type;\n    *write_ptr++ = (uint8_t)(effective_data_len >> 8);\n    *write_ptr++ = (uint8_t)(effective_data_len & 0xFF);\n\n    for (uint16_t i = 0; i < effective_data_len; ++i) {\n        *write_ptr++ = actual_data_ptr[i];\n    }\n\n    g_telemetryCurrentOffset += (uint16_t)entry_total_size_check;\n\n    return 0;\n}\n\nint processTelemetryPacket(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len == 0) {\n        return -1;\n    }\n    if (packet_len > MAX_TELEMETRY_PACKET_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_packet_offset = 0;\n    while (current_packet_offset < packet_len) {\n        if (current_packet_offset + sizeof(TelemetryDataHeader) > packet_len) {\n            return -2;\n        }\n\n        uint16_t entry_data_len_in_header = (packet_data[current_packet_offset + 2] << 8) | packet_data[current_packet_offset + 3];\n        \n        uint32_t entry_expected_total_len_check = (uint32_t)sizeof(TelemetryDataHeader) + entry_data_len_in_header;\n        uint16_t entry_expected_total_len;\n\n        if (entry_expected_total_len_check > (uint32_t)packet_len - current_packet_offset) {\n            entry_expected_total_len = packet_len - current_packet_offset;\n        } else {\n            entry_expected_total_len = (uint16_t)entry_expected_total_len_check;\n        }\n\n        if (current_packet_offset + entry_expected_total_len > packet_len) {\n             return -3;\n        }\n\n        int result = appendSingleTelemetryEntry(packet_data + current_packet_offset, entry_expected_total_len);\n        if (result != 0) {\n            return result;\n        }\n        current_packet_offset += entry_expected_total_len;\n    }\n    return 0;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define CONFIG_TABLE_SIZE 256 \n\nstatic uint8_t g_configTable[CONFIG_TABLE_SIZE];\n\ntypedef enum {\n    CFG_TYPE_UINT8 = 0,\n    CFG_TYPE_UINT16,\n    CFG_TYPE_UINT32,\n    CFG_TYPE_MAX\n} ConfigDataType;\n\nstatic uint8_t getConfigTypeSize(ConfigDataType type) {\n    switch (type) {\n        case CFG_TYPE_UINT8:  return 1;\n        case CFG_TYPE_UINT16: return 2;\n        case CFG_TYPE_UINT32: return 4;\n        default: return 0;\n    }\n}\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t offset;\n    ConfigDataType data_type;\n} ConfigEntryDescriptor;\n\nstatic const ConfigEntryDescriptor g_cfgDescriptors[] = {\n    {0x1001, 0, CFG_TYPE_UINT16},\n    {0x1002, 2, CFG_TYPE_UINT8},\n    {0x1003, 3, CFG_TYPE_UINT32},\n    {0x1004, 7, CFG_TYPE_UINT16},\n    {0x2001, 250, CFG_TYPE_UINT8},\n    {0x2002, 255, CFG_TYPE_UINT16}\n};\n#define NUM_CFG_ENTRIES (sizeof(g_cfgDescriptors) / sizeof(ConfigEntryDescriptor))\n\nvoid initConfigTable() {\n    memset(g_configTable, 0, CONFIG_TABLE_SIZE);\n}\n\nint updateConfigEntryValue(uint16_t entry_id, const uint8_t* new_value_bytes, uint8_t max_value_len) {\n    if (new_value_bytes == NULL || max_value_len == 0) {\n        return -1;\n    }\n\n    const ConfigEntryDescriptor* target_entry = NULL;\n    for (int i = 0; i < NUM_CFG_ENTRIES; ++i) {\n        if (g_cfgDescriptors[i].entry_id == entry_id) {\n            target_entry = &g_cfgDescriptors[i];\n            break;\n        }\n    }\n\n    if (target_entry == NULL) {\n        return -2;\n    }\n\n    uint8_t required_size = getConfigTypeSize(target_entry->data_type);\n\n    if (required_size == 0 || required_size > max_value_len) {\n        return -3;\n    }\n\n    if (target_entry->offset >= CONFIG_TABLE_SIZE) {\n        return -5;\n    }\n\n    switch (target_entry->data_type) {\n        case CFG_TYPE_UINT8:\n            g_configTable[target_entry->offset] = new_value_bytes[0];\n            break;\n        case CFG_TYPE_UINT16:\n            *(uint16_t*)(g_configTable + target_entry->offset) = *(uint16_t*)new_value_bytes;\n            break;\n        case CFG_TYPE_UINT32:\n            *(uint32_t*)(g_configTable + target_entry->offset) = *(uint32_t*)new_value_bytes;\n            break;\n        default:\n            return -4;\n    }\n\n    return 0;\n}\n\nvoid simulateConfigUpdate(uint16_t id, const uint8_t* data, uint8_t len) {\n    updateConfigEntryValue(id, data, len);\n}\n\nuint8_t getConfigByte(uint16_t offset) {\n    if (offset < CONFIG_TABLE_SIZE) {\n        return g_configTable[offset];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_VEHICLE_PARAMS 256\n#define CAN_PAYLOAD_MAX_SIZE 8\n\nstatic uint8_t g_vehicleParameters[MAX_VEHICLE_PARAMS];\n\nvoid initVehicleParameters() {\n    memset(g_vehicleParameters, 0, MAX_VEHICLE_PARAMS);\n}\n\nint processParameterUpdate(const uint8_t* can_payload, uint8_t payload_len) {\n    if (can_payload == NULL || payload_len < 3) {\n        return -1;\n    }\n\n    uint16_t param_index = (can_payload[0] << 8) | can_payload[1];\n    uint8_t param_value = can_payload[2];\n\n    if (param_index >= MAX_VEHICLE_PARAMS) {\n        return -2;\n    }\n    \n    g_vehicleParameters[param_index] = param_value;\n\n    return 0;\n}\n\nvoid receiveCANMessage(const uint8_t* data, uint8_t len) {\n    processParameterUpdate(data, len);\n}\n\nuint8_t getVehicleParameter(uint8_t index) {\n    if (index < MAX_VEHICLE_PARAMS) {\n        return g_vehicleParameters[index];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CONFIG_LOG_BUFFER_SIZE 128\n#define CONFIG_ENTRY_SIZE 8 \n\nstatic uint8_t g_config_log_buffer[CONFIG_LOG_BUFFER_SIZE];\nstatic uint32_t g_log_current_offset = 0; \n\nvoid init_config_log() {\n    memset(g_config_log_buffer, 0, CONFIG_LOG_BUFFER_SIZE);\n    g_log_current_offset = 0;\n}\n\nbool log_config_state(uint64_t state_value) {\n    if (g_log_current_offset + CONFIG_ENTRY_SIZE > CONFIG_LOG_BUFFER_SIZE) {\n        return false;\n    }\n    g_config_log_buffer[g_log_current_offset + 0] = (uint8_t)(state_value);\n    g_config_log_buffer[g_log_current_offset + 1] = (uint8_t)(state_value >> 8);\n    g_config_log_buffer[g_log_current_offset + 2] = (uint8_t)(state_value >> 16);\n    g_config_log_buffer[g_log_current_offset + 3] = (uint8_t)(state_value >> 24);\n    g_config_log_buffer[g_log_current_offset + 4] = (uint8_t)(state_value >> 32);\n    g_config_log_buffer[g_log_current_offset + 5] = (uint8_t)(state_value >> 40);\n    g_config_log_buffer[g_log_current_offset + 6] = (uint8_t)(state_value >> 48);\n    g_config_log_buffer[g_log_current_offset + 7] = (uint8_t)(state_value >> 56);\n    g_log_current_offset += CONFIG_ENTRY_SIZE;\n    return true;\n}\n\nvoid revert_and_mark_config_state_vulnerable(uint32_t entry_count_to_revert, uint8_t marker_value) {\n    if (g_log_current_offset == 0) {\n        return;\n    }\n\n    uint32_t bytes_to_revert = entry_count_to_revert * CONFIG_ENTRY_SIZE;\n\n    int32_t target_byte_offset = (int32_t)g_log_current_offset - (int32_t)bytes_to_revert;\n\n    if (target_byte_offset < 0) {\n        g_log_current_offset = 0;\n    } else {\n        g_log_current_offset = (uint32_t)target_byte_offset;\n    }\n\n    g_config_log_buffer[target_byte_offset - 1] = marker_value;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_BATTERY_MODULES 4\n#define CELLS_PER_MODULE 12\n#define TOTAL_BATTERY_CELLS (MAX_BATTERY_MODULES * CELLS_PER_MODULE)\n\n#define BMS_CMD_UPDATE_CELL_DATA 0x01\n\ntypedef struct {\n    uint16_t voltage_mV;\n    int8_t   temperature_C;\n    uint8_t  charge_status_percent;\n    bool     fault_active;\n} BatteryCell_Vulnerable;\n\nstatic BatteryCell_Vulnerable g_batteryCells_vulnerable[TOTAL_BATTERY_CELLS];\n\ntypedef struct {\n    uint8_t command_type;\n    uint8_t module_id;\n    uint8_t cell_in_module_id;\n    uint16_t voltage_mV;\n    int8_t   temperature_C;\n    uint8_t  charge_status_percent;\n} CellUpdateCommand_Vulnerable;\n\nvoid logBMS_vulnerable(const char* msg) {\n}\n\nCellUpdateCommand_Vulnerable receiveCellUpdateCommand_vulnerable() {\n    CellUpdateCommand_Vulnerable cmd;\n    cmd.command_type = BMS_CMD_UPDATE_CELL_DATA;\n    cmd.module_id = MAX_BATTERY_MODULES; \n    cmd.cell_in_module_id = 0; \n    cmd.voltage_mV = 3800;\n    cmd.temperature_C = 25;\n    cmd.charge_status_percent = 85;\n    return cmd;\n}\n\nvoid initializeBMS_vulnerable() {\n    for (int i = 0; i < TOTAL_BATTERY_CELLS; ++i) {\n        g_batteryCells_vulnerable[i] = (BatteryCell_Vulnerable){3700, 20, 70, false};\n    }\n}\n\nvoid processCellUpdate_vulnerable() {\n    CellUpdateCommand_Vulnerable cmd = receiveCellUpdateCommand_vulnerable();\n\n    if (cmd.command_type == BMS_CMD_UPDATE_CELL_DATA) {\n        int absolute_cell_idx = cmd.module_id * CELLS_PER_MODULE + cmd.cell_in_module_id;\n\n        g_batteryCells_vulnerable[absolute_cell_idx].voltage_mV = cmd.voltage_mV;\n        g_batteryCells_vulnerable[absolute_cell_idx].temperature_C = cmd.temperature_C;\n        g_batteryCells_vulnerable[absolute_cell_idx].charge_status_percent = cmd.charge_status_percent;\n        \n        logBMS_vulnerable(\"Battery cell data updated.\");\n    } else {\n        logBMS_vulnerable(\"Unknown BMS command received.\");\n    }\n}\n\nvoid bmsMainLoop_vulnerable() {\n    initializeBMS_vulnerable();\n    processCellUpdate_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_MSG_SIZE 1024\n#define DIAG_DATA_RECORD_BUF_SIZE 100\n\n#define DIAG_CMD_READ_DATA_BY_ID 0x22\n#define DIAG_CMD_WRITE_DATA_BY_ID 0x2E\n#define DIAG_CMD_ROUTINE_CONTROL 0x31\n\ntypedef struct {\n    uint8_t service_id;\n    uint16_t data_identifier;\n    uint16_t data_offset_in_pdu;\n    uint16_t data_length;\n} DiagServiceRecordHeader;\n\nstatic uint8_t g_currentDiagPDU[MAX_DIAG_MSG_SIZE];\nstatic uint16_t g_currentPDULength = 0;\n\nstatic uint8_t g_dataRecordProcessingBuffer[DIAG_DATA_RECORD_BUF_SIZE];\n\nvoid resetDiagnosticPDU() {\n    memset(g_currentDiagPDU, 0, sizeof(g_currentDiagPDU));\n    g_currentPDULength = 0;\n}\n\nint receiveDiagnosticPDU(const uint8_t* pdu_data, uint16_t pdu_len) {\n    if (pdu_data == NULL || pdu_len == 0 || pdu_len > MAX_DIAG_MSG_SIZE) {\n        return -1;\n    }\n    memcpy(g_currentDiagPDU, pdu_data, pdu_len);\n    g_currentPDULength = pdu_len;\n    return 0;\n}\n\nint processDiagDataRecordPayload(const DiagServiceRecordHeader* record_header) {\n    if (record_header == NULL) {\n        return -1;\n    }\n\n    uint16_t payload_offset = record_header->data_offset_in_pdu;\n    uint16_t payload_len = record_header->data_length;\n\n    if (payload_offset + payload_len > g_currentPDULength) {\n        return -1;\n    }\n\n    const uint8_t* source_ptr = g_currentDiagPDU + payload_offset;\n\n    uint16_t bytes_to_copy = payload_len;\n    if (bytes_to_copy > DIAG_DATA_RECORD_BUF_SIZE) {\n        bytes_to_copy = DIAG_DATA_RECORD_BUF_SIZE;\n    }\n    \n    memcpy(g_dataRecordProcessingBuffer, source_ptr, bytes_to_copy);\n\n    if (record_header->service_id == DIAG_CMD_READ_DATA_BY_ID) {\n\n    } else if (record_header->service_id == DIAG_CMD_WRITE_DATA_BY_ID) {\n\n    }\n    \n    return 0;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_LIGHTING_ZONES 5\n\ntypedef enum {\n    LIGHT_MODE_OFF = 0,\n    LIGHT_MODE_ON_LOW,\n    LIGHT_MODE_ON_HIGH,\n    LIGHT_MODE_AMBIENT,\n    LIGHT_MODE_COUNT\n} LightingMode;\n\ntypedef struct {\n    LightingMode current_mode;\n    uint8_t brightness;\n    uint16_t color_temp_kelvin;\n} LightingZoneConfig_Vulnerable;\n\nstatic LightingZoneConfig_Vulnerable g_lightingZoneConfigs_vulnerable[MAX_LIGHTING_ZONES];\n\nvoid lightingLog_vulnerable(const char* msg) {\n    printf(\"LIGHT_VULN: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t zone_id;\n    LightingMode new_mode;\n    uint8_t new_brightness;\n    uint16_t new_color_temp;\n} LightingCommand_Vulnerable;\n\nLightingCommand_Vulnerable getSimulatedLightingCommand_vulnerable() {\n    LightingCommand_Vulnerable cmd;\n    cmd.zone_id = MAX_LIGHTING_ZONES; \n    cmd.new_mode = LIGHT_MODE_ON_HIGH;\n    cmd.new_brightness = 85;\n    cmd.new_color_temp = 4500;\n    lightingLog_vulnerable(\"Simulating reception of lighting command (vulnerable).\");\n    return cmd;\n}\n\nvoid initializeLightingSystem_vulnerable() {\n    for (uint8_t i = 0; i < MAX_LIGHTING_ZONES; ++i) {\n        g_lightingZoneConfigs_vulnerable[i].current_mode = LIGHT_MODE_OFF;\n        g_lightingZoneConfigs_vulnerable[i].brightness = 0;\n        g_lightingZoneConfigs_vulnerable[i].color_temp_kelvin = 0;\n    }\n    lightingLog_vulnerable(\"Lighting system initialized (vulnerable).\");\n}\n\nvoid applyLightingCommand_vulnerable(LightingCommand_Vulnerable cmd) {\n    g_lightingZoneConfigs_vulnerable[cmd.zone_id].current_mode = cmd.new_mode;\n    g_lightingZoneConfigs_vulnerable[cmd.zone_id].brightness = cmd.new_brightness;\n    g_lightingZoneConfigs_vulnerable[cmd.zone_id].color_temp_kelvin = cmd.new_color_temp;\n    lightingLog_vulnerable(\"Lighting command applied (vulnerable).\");\n}\n\nvoid renderCurrentLightingState_vulnerable() {\n    lightingLog_vulnerable(\"Rendering current lighting state (vulnerable).\");\n}\n\nvoid lightingControlUnitMain_vulnerable() {\n    initializeLightingSystem_vulnerable();\n    LightingCommand_Vulnerable command = getSimulatedLightingCommand_vulnerable();\n    applyLightingCommand_vulnerable(command);\n    renderCurrentLightingState_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>#include <stddef.h>typedef struct {uint32_t id;uint8_t data[8];uint8_t dlc;} CanMessage;#define MAX_SUB_COMMANDS 5#define MAIN_CMD_DIAGNOSTIC_QUERY 0x10typedef void (*DiagnosticHandler)(uint16_t param1, uint16_t param2);static DiagnosticHandler g_diagnosticHandlers_fixed[MAX_SUB_COMMANDS];void logSecurityViolation(const char* msg) {}void diagHandler_ReadSensor_fixed(uint16_t sensorId, uint16_t unused) {}void diagHandler_ResetModule_fixed(uint16_t moduleId, uint16_t unused) {}void diagHandler_GetStatus_fixed(uint16_t statusType, uint16_t unused) {}void diagHandler_ClearDTC_fixed(uint16_t dtcCode, uint16_t unused) {}void diagHandler_PerformSelfTest_fixed(uint16_t testId, uint16_t unused) {}CanMessage receiveCanMessage_Fixed() {CanMessage msg;msg.id = 0x7E1;msg.dlc = 8;msg.data[0] = MAIN_CMD_DIAGNOSTIC_QUERY;msg.data[1] = 5;msg.data[2] = 0x01;msg.data[3] = 0x02;msg.data[4] = 0x00;msg.data[5] = 0x00;msg.data[6] = 0x00;msg.data[7] = 0x00;return msg;}void initDiagnosticHandlers_Fixed() {g_diagnosticHandlers_fixed[0] = diagHandler_ReadSensor_fixed;g_diagnosticHandlers_fixed[1] = diagHandler_ResetModule_fixed;g_diagnosticHandlers_fixed[2] = diagHandler_GetStatus_fixed;g_diagnosticHandlers_fixed[3] = diagHandler_ClearDTC_fixed;g_diagnosticHandlers_fixed[4] = diagHandler_PerformSelfTest_fixed;}void processDiagnosticCommand_Fixed() {CanMessage msg = receiveCanMessage_Fixed();if (msg.id == 0x7E1 && msg.dlc >= 4) {uint8_t mainCommandId = msg.data[0];uint8_t subCommandId = msg.data[1];uint16_t param1 = (uint16_t)msg.data[2];uint16_t param2 = (uint16_t)msg.data[3];if (mainCommandId == MAIN_CMD_DIAGNOSTIC_QUERY) {if (subCommandId < MAX_SUB_COMMANDS) {if (g_diagnosticHandlers_fixed[subCommandId] != NULL) {g_diagnosticHandlers_fixed[subCommandId](param1, param2);} else {logSecurityViolation(\"Diagnostic: Requested sub-command handler is uninitialized for a valid index.\");}} else {logSecurityViolation(\"Diagnostic: Received out-of-bounds sub-command ID. Ignoring command.\");}} else {logSecurityViolation(\"Diagnostic: Unsupported main command ID received.\");}} else {logSecurityViolation(\"Diagnostic: Invalid CAN message format or ID.\");}}void vehicleDiagnosticModule_Fixed() {initDiagnosticHandlers_Fixed();processDiagnosticCommand_Fixed();}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CAN_DIAG_BUFFER_SIZE 256\n#define CAN_MSG_HEADER_SIZE  4\n#define MIN_MSG_PAYLOAD_SIZE 1\n#define MAX_MSG_PAYLOAD_SIZE (CAN_DIAG_BUFFER_SIZE - CAN_MSG_HEADER_SIZE)\n\ntypedef struct {\n    uint16_t message_id;\n    uint8_t  payload_len;\n    uint8_t  control_byte;\n    uint8_t  payload_data[MAX_MSG_PAYLOAD_SIZE];\n} CAN_DiagMessage;\n\nstatic uint8_t g_diag_raw_buffer[CAN_DIAG_BUFFER_SIZE];\nstatic int32_t g_current_buffer_offset = 0;\nstatic uint32_t g_data_in_buffer = 0;\n\nvoid init_diag_buffer() {\n    memset(g_diag_raw_buffer, 0, CAN_DIAG_BUFFER_SIZE);\n    g_current_buffer_offset = 0;\n    g_data_in_buffer = 0;\n}\n\nbool append_diag_data(const uint8_t* data, uint16_t len) {\n    if (g_data_in_buffer + len > CAN_DIAG_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_diag_raw_buffer + g_data_in_buffer, data, len);\n    g_data_in_buffer += len;\n    return true;\n}\n\nvoid process_complete_diag_message(const CAN_DiagMessage* msg) {\n    volatile uint16_t id = msg->message_id;\n    (void)id;\n}\n\nvoid mark_message_pre_header_vulnerable(uint8_t marker_byte) {\n    g_diag_raw_buffer[g_current_buffer_offset - 1] = marker_byte;\n    \n    if (g_current_buffer_offset < g_data_in_buffer) {\n        CAN_DiagMessage* current_msg = (CAN_DiagMessage*)(g_diag_raw_buffer + g_current_buffer_offset);\n        process_complete_diag_message(current_msg);\n    }\n}\n\nvoid advance_buffer_offset(uint16_t bytes_consumed) {\n    if (g_current_buffer_offset + bytes_consumed <= g_data_in_buffer) {\n        g_current_buffer_offset += bytes_consumed;\n    } else {\n        g_current_buffer_offset = g_data_in_buffer;\n    }\n    if (g_current_buffer_offset == g_data_in_buffer) {\n        g_current_buffer_offset = 0;\n        g_data_in_buffer = 0;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stbool.h>\n#include <string.h>\n\n#define CALIBRATION_POOL_SIZE 512\n#define NUM_CALIBRATION_BLOCKS 4\n\ntypedef struct {\n    uint16_t base_address; \n    uint16_t length;       \n    bool     is_active;    \n} CalibrationBlock;\n\nstatic uint8_t g_calibration_pool_fixed[CALIBRATION_POOL_SIZE];\n\nstatic CalibrationBlock g_calibration_blocks_fixed[NUM_CALIBRATION_BLOCKS] = {\n    { .base_address = 0,   .length = 100, .is_active = true },  \n    { .base_address = 100, .length = 150, .is_active = true },  \n    { .base_address = 250, .length = 50,  .is_active = true },  \n    { .base_address = 300, .length = 200, .is_active = true }   \n};\n\nvoid init_calibration_manager_fixed() {\n    memset(g_calibration_pool_fixed, 0xFF, CALIBRATION_POOL_SIZE);\n}\n\nuint8_t read_calibration_byte_fixed(uint8_t block_id, int16_t relative_offset) {\n    if (block_id >= NUM_CALIBRATION_BLOCKS || !g_calibration_blocks_fixed[block_id].is_active) {\n        return 0xFF;\n    }\n\n    CalibrationBlock* block = &g_calibration_blocks_fixed[block_id];\n    int32_t absolute_idx = (int32_t)block->base_address + relative_offset;\n\n    if (absolute_idx < 0 || absolute_idx >= CALIBRATION_POOL_SIZE) {\n        return 0xFF;\n    }\n\n    if (relative_offset < 0 || relative_offset >= block->length) {\n        return 0xFF;\n    }\n\n    return g_calibration_pool_fixed[absolute_idx];\n}\n\nvoid update_calibration_value_fixed(uint8_t block_id, int16_t relative_offset, uint8_t new_value) {\n    if (block_id >= NUM_CALIBRATION_BLOCKS || !g_calibration_blocks_fixed[block_id].is_active) {\n        return;\n    }\n\n    CalibrationBlock* block = &g_calibration_blocks_fixed[block_id];\n\n    if (relative_offset < 0 || relative_offset >= block->length) {\n        return;\n    }\n\n    int32_t target_absolute_idx = (int32_t)block->base_address + relative_offset;\n\n    if (target_absolute_idx < 0 || target_absolute_idx >= CALIBRATION_POOL_SIZE) {\n        return;\n    }\n    \n    g_calibration_pool_fixed[target_absolute_idx] = new_value;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <numeric>\n#include <limits>\n\nstruct CommandPacketHeader {\n    uint16_t command_id;\n    uint16_t payload_length;\n    uint8_t flags;\n};\n\nstruct ProcessedCommand {\n    uint16_t command_id;\n    size_t   data_size;\n    uint8_t* data;\n};\n\nclass CommandProcessorFixed {\npublic:\n    CommandProcessorFixed() : m_processed_cmd_data(nullptr), m_allocated_size(0) {}\n\n    ~CommandProcessorFixed() {\n        if (m_processed_cmd_data) {\n            delete[] m_processed_cmd_data;\n            m_processed_cmd_data = nullptr;\n        }\n    }\n\n    bool processCommandFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(CommandPacketHeader)) {\n            return false;\n        }\n\n        const CommandPacketHeader* header = reinterpret_cast<const CommandPacketHeader*>(raw_packet);\n\n        static const uint16_t MAX_ALLOWED_PAYLOAD = 1024;\n        if (header->payload_length == 0 || header->payload_length > MAX_ALLOWED_PAYLOAD) {\n            return false;\n        }\n\n        bool needs_checksum_byte = (header->command_id == 0x101 || header->command_id == 0x202);\n        size_t required_allocation_size = header->payload_length;\n        if (needs_checksum_byte) {\n            if (required_allocation_size >= std::numeric_limits<size_t>::max()) {\n                return false;\n            }\n            required_allocation_size += 1;\n        }\n        \n        if (packet_len < (sizeof(CommandPacketHeader) + header->payload_length)) {\n            return false;\n        }\n\n        if (m_processed_cmd_data) {\n            delete[] m_processed_cmd_data;\n            m_processed_cmd_data = nullptr;\n            m_allocated_size = 0;\n        }\n\n        m_processed_cmd_data = new (std::nothrow) uint8_t[required_allocation_size];\n        if (!m_processed_cmd_data) {\n            return false;\n        }\n        m_allocated_size = required_allocation_size;\n\n        const uint8_t* payload_src = raw_packet + sizeof(CommandPacketHeader);\n        for (uint16_t i = 0; i < header->payload_length; ++i) {\n            m_processed_cmd_data[i] = payload_src[i];\n        }\n\n        if (needs_checksum_byte) {\n            uint8_t checksum = 0;\n            for (uint16_t i = 0; i < header->payload_length; ++i) {\n                checksum ^= m_processed_cmd_data[i];\n            }\n            m_processed_cmd_data[header->payload_length] = checksum;\n        }\n\n        m_last_processed_cmd.command_id = header->command_id;\n        m_last_processed_cmd.data_size = header->payload_length;\n        m_last_processed_cmd.data = m_processed_cmd_data;\n\n        return true;\n    }\n\n    const ProcessedCommand& getLastProcessedCommand() const {\n        return m_last_processed_cmd;\n    }\n\nprivate:\n    uint8_t* m_processed_cmd_data;\n    size_t m_allocated_size;\n    ProcessedCommand m_last_processed_cmd;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define REASSEMBLY_BUFFER_SIZE 512\n#define MAX_RECORDS            4\n#define MAX_RECORD_LEN_BYTES   100 \n\ntypedef struct {\n    uint16_t record_id;\n    uint16_t total_expected_len; \n    uint16_t current_len;        \n    uint16_t buffer_offset;      \n    bool     is_active;          \n} RecordMetadata;\n\nstatic uint8_t g_reassemblyBuffer[REASSEMBLY_BUFFER_SIZE];\nstatic RecordMetadata g_recordMetadata[MAX_RECORDS];\nstatic uint16_t g_nextFreeBufferOffset = 0;\n\nvoid initReassemblyManager() {\n    memset(g_reassemblyBuffer, 0, REASSEMBLY_BUFFER_SIZE);\n    memset(g_recordMetadata, 0, sizeof(g_recordMetadata));\n    g_nextFreeBufferOffset = 0;\n}\n\nint activateRecord(uint16_t id, uint16_t expected_total_len) {\n    if (expected_total_len == 0 || expected_total_len > MAX_RECORD_LEN_BYTES) {\n        return -1; \n    }\n\n    for (int i = 0; i < MAX_RECORDS; ++i) {\n        if (g_recordMetadata[i].is_active && g_recordMetadata[i].record_id == id) {\n            return i;\n        }\n    }\n\n    for (int i = 0; i < MAX_RECORDS; ++i) {\n        if (!g_recordMetadata[i].is_active) {\n            if (g_nextFreeBufferOffset + expected_total_len > REASSEMBLY_BUFFER_SIZE) {\n                return -2; \n            }\n\n            g_recordMetadata[i].record_id = id;\n            g_recordMetadata[i].total_expected_len = expected_total_len;\n            g_recordMetadata[i].current_len = 0;\n            g_recordMetadata[i].buffer_offset = g_nextFreeBufferOffset;\n            g_recordMetadata[i].is_active = true;\n\n            g_nextFreeBufferOffset += expected_total_len; \n\n            return i;\n        }\n    }\n    return -3; \n}\n\nint processRecordFragment(int record_meta_idx, uint16_t fragment_offset, const uint8_t* fragment_data, uint16_t fragment_len) {\n    if (record_meta_idx < 0 || record_meta_idx >= MAX_RECORDS || !g_recordMetadata[record_meta_idx].is_active) {\n        return -1; \n    }\n    if (fragment_data == NULL || fragment_len == 0) {\n        return -2; \n    }\n\n    RecordMetadata* record = &g_recordMetadata[record_meta_idx];\n\n    uint16_t dest_offset = record->buffer_offset + fragment_offset;\n\n    // FIX:\n    // The check now correctly verifies that the entire fragment (start + length)\n    // does not exceed the logical end of the record's allocated space.\n    // Using uint32_t for the sum avoids potential integer overflow if uint16_t values were near max, \n    // although with REASSEMBLY_BUFFER_SIZE of 512, uint16_t for sum is generally safe.\n    if ((uint32_t)dest_offset + fragment_len <= (uint32_t)record->buffer_offset + record->total_expected_len) {\n        for (uint16_t i = 0; i < fragment_len; ++i) {\n            g_reassemblyBuffer[dest_offset + i] = fragment_data[i];\n        }\n\n        uint16_t new_current_len = fragment_offset + fragment_len;\n        if (new_current_len > record->current_len) {\n            record->current_len = new_current_len;\n        }\n        return 0;\n    }\n\n    // If the check fails, return an error indicating out-of-bounds access attempt.\n    return -3; \n}\n\nvoid receiveVehicleDataFrame(uint16_t record_id, uint16_t fragment_offset, const uint8_t* data, uint16_t len) {\n    int record_idx = activateRecord(record_id, 50);\n    if (record_idx >= 0) {\n        processRecordFragment(record_idx, fragment_offset, data, len);\n    }\n}\n\nuint8_t getReassembledByte(uint16_t absolute_offset) {\n    if (absolute_offset < REASSEMBLY_BUFFER_SIZE) {\n        return g_reassemblyBuffer[absolute_offset];\n    }\n    return 0;\n}\n\nvoid runReassemblySimulation() {\n    initReassemblyManager();\n\n    int record_idx1 = activateRecord(101, 50);\n    int record_idx2 = activateRecord(102, 50);\n\n    uint8_t legit_fragment_r2[] = {0xA1, 0xA2, 0xA3, 0xA4, 0xA5}; \n    processRecordFragment(record_idx2, 0, legit_fragment_r2, sizeof(legit_fragment_r2));\n\n    // ATTACK SCENARIO (now prevented):\n    // The call below would have caused an out-of-bounds write in the vulnerable code.\n    // In the fixed code, this call will now correctly return -3 (Fragment offset out of bounds)\n    // because (dest_offset + fragment_len) would exceed record->total_expected_len.\n    uint8_t malicious_fragment_r1[20];\n    memset(malicious_fragment_r1, 0xFF, sizeof(malicious_fragment_r1)); \n    processRecordFragment(record_idx1, 40, malicious_fragment_r1, sizeof(malicious_fragment_r1));\n\n    // g_reassemblyBuffer[50] will retain its legitimate value (0xA1) as the overflow is prevented.\n}\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE_FIXED 256\n#define PATCH_BLOCK_MAX_SIZE_FIXED 64\n#define CONFIG_AREA_START_OFFSET_FIXED 10\n\nstatic uint8_t g_vehicle_config_fixed[VEHICLE_CONFIG_BUFFER_SIZE_FIXED];\n\nvoid init_vehicle_config_fixed() {\n    memset(g_vehicle_config_fixed, 0, VEHICLE_CONFIG_BUFFER_SIZE_FIXED);\n    for (int i = 0; i < (VEHICLE_CONFIG_BUFFER_SIZE_FIXED - CONFIG_AREA_START_OFFSET_FIXED); i++) {\n        g_vehicle_config_fixed[CONFIG_AREA_START_OFFSET_FIXED + i] = (uint8_t)i;\n    }\n}\n\nvoid apply_config_patch_fixed(const uint8_t* patch_data, uint16_t patch_len, int16_t patch_start_addr_offset) {\n    if (patch_data == NULL || patch_len == 0 || patch_len > PATCH_BLOCK_MAX_SIZE_FIXED) {\n        return;\n    }\n\n    int32_t absolute_target_address_idx = (int32_t)CONFIG_AREA_START_OFFSET_FIXED + patch_start_addr_offset;\n\n    if (absolute_target_address_idx < 0 ||\n        (absolute_target_address_idx + patch_len) > VEHICLE_CONFIG_BUFFER_SIZE_FIXED) {\n        return;\n    }\n    \n    memcpy(g_vehicle_config_fixed + absolute_target_address_idx, patch_data, patch_len);\n\n    volatile uint8_t check_byte = g_vehicle_config_fixed[CONFIG_AREA_START_OFFSET_FIXED];\n    (void)check_byte;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_TELEMETRY_PACKET_SIZE   2000 \n#define SENSOR_DATA_ENTRY_SIZE      12   \n#define MAX_INTERNAL_SENSOR_ENTRIES 40   \n#define TELEMETRY_DATA_BUFFER_SIZE  (MAX_INTERNAL_SENSOR_ENTRIES * SENSOR_DATA_ENTRY_SIZE) \n\nstatic uint8_t g_aggregatedSensorData[TELEMETRY_DATA_BUFFER_SIZE]; \n\ntypedef struct {\n    uint16_t packet_id;\n    uint8_t  num_sensor_entries; \n    uint8_t  _reserved; \n} TelemetryPacketHeader;\n\ntypedef struct {\n    uint8_t sensor_type;\n    uint16_t sensor_value;\n    uint32_t timestamp;\n    uint32_t sensor_flags;\n    uint8_t  checksum;\n} SensorDataEntry; \n\nvoid initTelemetryUnit() {\n    memset(g_aggregatedSensorData, 0, TELEMETRY_DATA_BUFFER_SIZE);\n}\n\nint processTelemetryPacket(const uint8_t* raw_packet, uint16_t packet_len) {\n    if (raw_packet == NULL || packet_len < sizeof(TelemetryPacketHeader)) {\n        return -1; \n    }\n\n    const TelemetryPacketHeader* header = (const TelemetryPacketHeader*)raw_packet;\n\n    if (header->num_sensor_entries > MAX_INTERNAL_SENSOR_ENTRIES) { \n        return -2; \n    }\n\n    uint16_t expected_data_len = header->num_sensor_entries * SENSOR_DATA_ENTRY_SIZE;\n\n    if (expected_data_len > TELEMETRY_DATA_BUFFER_SIZE) { \n        return -3; \n    }\n\n    uint16_t minimum_packet_len = sizeof(TelemetryPacketHeader) + expected_data_len;\n\n    if (packet_len < minimum_packet_len) {\n        return -4; \n    }\n\n    for (uint16_t i = 0; i < expected_data_len; ++i) {\n        g_aggregatedSensorData[i] = raw_packet[sizeof(TelemetryPacketHeader) + i];\n    }\n\n    return 0; \n}\n\nvoid receiveTelemetryUpdate(const uint8_t* data, uint16_t length) {\n    processTelemetryPacket(data, length);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define SENSOR_CALIBRATION_MAX_POINTS 128\n#define DIAG_PACKET_MAX_PAYLOAD_SIZE 256\n\nstatic uint16_t g_sensorCalibration[SENSOR_CALIBRATION_MAX_POINTS];\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t sub_command;\n    uint16_t start_index;\n    uint16_t num_points;\n    uint8_t  payload[DIAG_PACKET_MAX_PAYLOAD_SIZE];\n} DiagnosticCommandPacket;\n\nvoid initSensorCalibration() {\n    for (int i = 0; i < SENSOR_CALIBRATION_MAX_POINTS; ++i) {\n        g_sensorCalibration[i] = 0xAAAA;\n    }\n}\n\nint processCalibrationUpdateCommand(const DiagnosticCommandPacket* packet, uint16_t packet_size) {\n    if (packet == NULL || packet_size < sizeof(DiagnosticCommandPacket) - DIAG_PACKET_MAX_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    if (packet->command_id != 0x01 || packet->sub_command != 0x01) {\n        return -2;\n    }\n\n    uint16_t requested_start_index = packet->start_index;\n    uint16_t requested_num_points = packet->num_points;\n\n    if (requested_num_points > (DIAG_PACKET_MAX_PAYLOAD_SIZE / sizeof(uint16_t))) {\n        return -3;\n    }\n\n    if (requested_start_index >= SENSOR_CALIBRATION_MAX_POINTS) {\n        return -4;\n    }\n\n    const uint16_t* new_values = (const uint16_t*)packet->payload;\n\n    for (uint16_t i = 0; i < requested_num_points; ++i) {\n        g_sensorCalibration[requested_start_index + i] = new_values[i];\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticMessage(const uint8_t* raw_message, uint16_t raw_message_len) {\n    initSensorCalibration();\n    processCalibrationUpdateCommand((const DiagnosticCommandPacket*)raw_message, raw_message_len);\n}\n\nuint16_t getSensorCalibrationValue(uint16_t index) {\n    if (index < SENSOR_CALIBRATION_MAX_POINTS) {\n        return g_sensorCalibration[index];\n    }\n    return 0xFFFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#define MAX_SUBSYSTEMS 5\n#define MAX_DATA_POINTS_PER_SUBSYSTEM 10\n\ntypedef enum {\n    SUBSYSTEM_ENGINE = 0,\n    SUBSYSTEM_TRANSMISSION,\n    SUBSYSTEM_BRAKES,\n    SUBSYSTEM_HVAC,\n    SUBSYSTEM_INFOTAINMENT,\n    SUBSYSTEM_COUNT\n} SubsystemType;\n\ntypedef struct {\n    SubsystemType type;\n    int data_index;\n    long value;\n} VehicleMetricPacket;\n\nstatic long g_subsystemMetrics[MAX_SUBSYSTEMS][MAX_DATA_POINTS_PER_SUBSYSTEM];\n\nVehicleMetricPacket receiveMetricPacket_vulnerable() {\n    VehicleMetricPacket packet;\n    packet.type = SUBSYSTEM_ENGINE;\n    packet.data_index = 10;\n    packet.value = 12345L;\n    return packet;\n}\n\nvoid logSystemError(const char* msg) {\n}\n\nvoid processVehicleMetric_vulnerable() {\n    VehicleMetricPacket packet = receiveMetricPacket_vulnerable();\n\n    if (packet.type < SUBSYSTEM_COUNT) {\n        g_subsystemMetrics[packet.type][packet.data_index] = packet.value;\n    } else {\n        logSystemError(\"Received metric for unknown subsystem type.\");\n    }\n}\n\nvoid metricProcessorInit_vulnerable() {\n    for (int i = 0; i < MAX_SUBSYSTEMS; ++i) {\n        for (int j = 0; j < MAX_DATA_POINTS_PER_SUBSYSTEM; ++j) {\n            g_subsystemMetrics[i][j] = 0;\n        }\n    }\n}\n\nvoid simulateMetricProcessing_vulnerable() {\n    metricProcessorInit_vulnerable();\n    processVehicleMetric_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRIES 32\n#define LOG_ENTRY_SIZE 8\n\ntypedef struct {\n    uint32_t event_id;\n    uint32_t timestamp;\n} LogEntry;\n\nstatic LogEntry g_diag_log_buffer_fixed[MAX_LOG_ENTRIES];\nstatic uint16_t g_log_count_fixed = 0;\n\nvoid init_diag_log_fixed() {\n    memset(g_diag_log_buffer_fixed, 0, sizeof(g_diag_log_buffer_fixed));\n    g_log_count_fixed = 0;\n}\n\nbool add_log_entry_fixed(uint32_t event_id, uint32_t timestamp) {\n    if (g_log_count_fixed >= MAX_LOG_ENTRIES) {\n        return false;\n    }\n    g_diag_log_buffer_fixed[g_log_count_fixed].event_id = event_id;\n    g_diag_log_buffer_fixed[g_log_count_fixed].timestamp = timestamp;\n    g_log_count_fixed++;\n    return true;\n}\n\nvoid clear_log_segment_fixed(uint16_t entries_to_clear_from_end) {\n    if (g_log_count_fixed == 0) {\n        return;\n    }\n\n    if (entries_to_clear_from_end > g_log_count_fixed) {\n        g_log_count_fixed = 0;\n    } else {\n        g_log_count_fixed -= entries_to_clear_from_end;\n    }\n\n    int32_t marker_byte_index = (int32_t)g_log_count_fixed * LOG_ENTRY_SIZE - 1;\n\n    if (marker_byte_index >= 0 && marker_byte_index < (int32_t)(MAX_LOG_ENTRIES * LOG_ENTRY_SIZE)) {\n        ((uint8_t*)g_diag_log_buffer_fixed)[marker_byte_index] = 0xDE;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DATA_CACHE_SIZE 256 \n#define SEGMENT_SIZE 16     \n#define METADATA_OFFSET_FROM_SEGMENT_START -4 \n\nstatic uint8_t g_vehicle_data_cache[DATA_CACHE_SIZE];\nstatic uint16_t g_num_active_segments = 0;\n\nvoid init_data_cache() {\n    memset(g_vehicle_data_cache, 0, DATA_CACHE_SIZE);\n    g_num_active_segments = 0;\n}\n\nbool add_data_segment(const uint8_t* segment_data) {\n    if ((g_num_active_segments + 1) * SEGMENT_SIZE > DATA_CACHE_SIZE) {\n        return false;\n    }\n    uint16_t write_offset = g_num_active_segments * SEGMENT_SIZE;\n    memcpy(g_vehicle_data_cache + write_offset, segment_data, SEGMENT_SIZE);\n    g_num_active_segments++;\n    return true;\n}\n\nvoid update_segment_control_byte_vulnerable(uint16_t segment_idx, uint8_t new_control_value) {\n    if (segment_idx >= g_num_active_segments) {\n        return;\n    }\n\n    uint16_t segment_start_offset = segment_idx * SEGMENT_SIZE;\n\n    int32_t control_byte_offset = (int32_t)segment_start_offset + METADATA_OFFSET_FROM_SEGMENT_START;\n\n    g_vehicle_data_cache[control_byte_offset] = new_control_value;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_CALIBRATION_POINTS 16\n#define CALIBRATION_DATA_SIZE 10 \n#define CALIBRATION_HEADER_SIZE 2 \n\n#define SINGLE_CAL_ENTRY_TOTAL_SIZE (CALIBRATION_HEADER_SIZE + CALIBRATION_DATA_SIZE)\n\n#define CAL_ENTRY_PREAMBLE_BYTE_OFFSET -1 \n\nstatic uint8_t g_calibration_buffer[MAX_CALIBRATION_POINTS * SINGLE_CAL_ENTRY_TOTAL_SIZE];\nstatic uint16_t g_active_cal_points = 0; \nstatic uint16_t g_current_calibration_ptr = 0; \n\nvoid initCalibrationBuffer() {\n    memset(g_calibration_buffer, 0, sizeof(g_calibration_buffer));\n    g_active_cal_points = 0;\n    g_current_calibration_ptr = 0;\n}\n\nint16_t addCalibrationEntry(uint16_t id, const uint8_t* data) {\n    if (g_active_cal_points >= MAX_CALIBRATION_POINTS) {\n        return -1; \n    }\n\n    uint32_t current_byte_offset = (uint32_t)g_current_calibration_ptr * SINGLE_CAL_ENTRY_TOTAL_SIZE;\n\n    g_calibration_buffer[current_byte_offset] = (uint8_t)(id >> 8);\n    g_calibration_buffer[current_byte_offset + 1] = (uint8_t)(id & 0xFF);\n\n    memcpy(&g_calibration_buffer[current_byte_offset + CALIBRATION_HEADER_SIZE], data, CALIBRATION_DATA_SIZE);\n\n    int16_t added_idx = g_current_calibration_ptr;\n    g_current_calibration_ptr++;\n    g_active_cal_points++;\n    return added_idx;\n}\n\nvoid updateCalibrationEntryPreamble_Vulnerable(uint16_t target_cal_idx, uint8_t preamble_status) {\n    if (target_cal_idx >= g_active_cal_points) {\n        return; \n    }\n\n    uint32_t entry_start_byte_pos = (uint32_t)target_cal_idx * SINGLE_CAL_ENTRY_TOTAL_SIZE;\n\n    int32_t target_byte_pos = (int32_t)entry_start_byte_pos + CAL_ENTRY_PREAMBLE_BYTE_OFFSET;\n\n    g_calibration_buffer[target_byte_pos] = preamble_status;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define FLASH_CONFIG_TOTAL_SIZE 256 // Total bytes in the simulated flash configuration area\n#define MAX_CONFIG_DATA_ITEMS 10    // Maximum number of configurable data items\n\n// Simulated flash memory area containing various configuration items.\n// This is treated as a read-only area for normal operations, but its contents\n// are accessed based on metadata that can be manipulated.\nstatic const uint8_t g_simulatedFlashMemory[FLASH_CONFIG_TOTAL_SIZE] = {\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,\n    0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,\n    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,\n    0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,\n    0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,\n    0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n    0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF\n};\n\n// Static array defining the starting byte offset of each configuration item within g_simulatedFlashMemory.\nstatic const uint16_t g_configItemOffsets[MAX_CONFIG_DATA_ITEMS] = {\n    0,\n    10,\n    30,\n    35,\n    50,\n    80,\n    120,\n    170,\n    230,\n    250\n};\n\n// Mutable array storing the *configured size* of each data item.\nstatic uint16_t g_configItemSizes[MAX_CONFIG_DATA_ITEMS] = {\n    10,\n    20,\n    5,\n    15,\n    30,\n    40,\n    50,\n    60,\n    20,\n    10\n};\n\nvoid initConfigSystem() {\n    // Initialization logic if needed.\n}\n\n// Function to update the size of a specific configuration item.\n// This simulates a diagnostic service command or an authorized configuration tool.\n// param item_id: The identifier for the configuration item to update.\n// param new_size: The new desired size for the item in bytes.\n// Returns 0 on success, or a negative error code on failure.\nint setConfigItemSize(uint8_t item_id, uint16_t new_size) {\n    if (item_id >= MAX_CONFIG_DATA_ITEMS) {\n        return -1; // Invalid item ID\n    }\n\n    // FIX: Add a bounds check here to prevent setting a size that would lead to an\n    // out-of-bounds read from 'g_simulatedFlashMemory' when later retrieved.\n    // Use uint32_t for intermediate calculation to prevent integer overflow in the check itself.\n    uint32_t potential_end_address = (uint32_t)g_configItemOffsets[item_id] + new_size;\n\n    if (potential_end_address > FLASH_CONFIG_TOTAL_SIZE) {\n        return -2; // New size would cause a read beyond flash memory bounds\n    }\n\n    g_configItemSizes[item_id] = new_size;\n    return 0; // Success\n}\n\n// Function to read a specific configuration item from the simulated flash memory.\n// It uses the sizes stored in g_configItemSizes.\n// param item_id: The identifier for the configuration item to read.\n// param dest_buffer: Pointer to the caller-provided buffer where data will be copied.\n// param dest_buffer_size: The size of the caller-provided destination buffer.\n// Returns the actual bytes read on success, or a negative error code on failure.\nint readConfigItem(uint8_t item_id, uint8_t* dest_buffer, uint16_t dest_buffer_size) {\n    if (item_id >= MAX_CONFIG_DATA_ITEMS || dest_buffer == NULL) {\n        return -1; // Invalid item ID or destination buffer\n    }\n\n    uint16_t item_offset = g_configItemOffsets[item_id];\n    uint16_t item_size = g_configItemSizes[item_id];\n\n    // Defense-in-depth: A redundant check to ensure the read operation stays within\n    // the source buffer's bounds. This handles scenarios where g_configItemSizes\n    // might have been corrupted through other means, or if setConfigItemSize had a flaw.\n    // Using uint32_t for calculation to prevent integer overflow for the bounds check.\n    if ((uint32_t)item_offset + item_size > FLASH_CONFIG_TOTAL_SIZE) {\n        return -3; // Detected corrupted item size/offset leading to out-of-bounds source read\n    }\n\n    // Check if the destination buffer is large enough to hold the item.\n    if (item_size > dest_buffer_size) {\n        return -4; // Destination buffer too small for the item\n    }\n\n    // The memcpy is now safe as both source and destination bounds are validated.\n    memcpy(dest_buffer, &g_simulatedFlashMemory[item_offset], item_size);\n\n    return item_size; // Return actual bytes read\n}\n\n// Dummy function to simulate a diagnostic tool's interaction pattern.\nvoid simulateDiagnosticConfigAccess(uint8_t item_id_to_read, uint16_t malicious_size_to_set) {\n    initConfigSystem();\n\n    // Step 1: An attacker or faulty system component attempts to set a malicious size.\n    // The fix in setConfigItemSize will now prevent this.\n    setConfigItemSize(item_id_to_read, malicious_size_to_set);\n\n    uint8_t read_buffer[100];\n    memset(read_buffer, 0, sizeof(read_buffer));\n\n    // Step 2: Request to read the item. This call is now protected.\n    readConfigItem(item_id_to_read, read_buffer, sizeof(read_buffer));\n}\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\ntypedef enum {\n    EVENT_TYPE_IGNITION = 0,\n    EVENT_TYPE_GEARBOX,\n    EVENT_TYPE_WHEEL_SPEED,\n    EVENT_TYPE_BATTERY,\n    EVENT_TYPE_DIAGNOSTIC,\n    EVENT_TYPE_COUNT\n} EventType;\n\ntypedef struct {\n    EventType type;\n    uint8_t   subtype_idx;\n    uint16_t  data_payload;\n} VehicleEvent_Vulnerable;\n\nvoid handleIgnitionEvent(uint8_t subtype_idx, uint16_t data) { }\nvoid handleGearboxEvent(uint8_t subtype_idx, uint16_t data) { }\nvoid handleWheelSpeedEvent(uint8_t subtype_idx, uint16_t data) { }\nvoid handleBatteryEvent(uint8_t subtype_idx, uint16_t data) { }\nvoid handleDiagnosticEvent(uint8_t subtype_idx, uint16_t data) { }\n\nstatic const char* ignition_subtypes[] = {\n    \"Ignition On\", \"Ignition Off\", \"Engine Start Attempt\"\n};\n#define IGNITION_SUBTYPE_COUNT (sizeof(ignition_subtypes) / sizeof(ignition_subtypes[0]))\n\nstatic const char* gearbox_subtypes[] = {\n    \"Gear Shift Up\", \"Gear Shift Down\", \"Neutral Engaged\", \"Gearbox Fault\"\n};\n#define GEARBOX_SUBTYPE_COUNT (sizeof(gearbox_subtypes) / sizeof(gearbox_subtypes[0]))\n\nstatic const char* wheel_speed_subtypes[] = {\n    \"Wheel Speed FL\", \"Wheel Speed FR\", \"Wheel Speed RL\", \"Wheel Speed RR\", \"All Sensors Valid\"\n};\n#define WHEEL_SPEED_SUBTYPE_COUNT (sizeof(wheel_speed_subtypes) / sizeof(wheel_speed_subtypes[0]))\n\nstatic const char* battery_subtypes[] = {\n    \"Low Battery Voltage\", \"High Battery Voltage\", \"Overcharge Detected\"\n};\n#define BATTERY_SUBTYPE_COUNT (sizeof(battery_subtypes) / sizeof(battery_subtypes[0]))\n\nstatic const char* diagnostic_subtypes[] = {\n    \"Read DTCs\", \"Clear DTCs\", \"Perform Self-Test\", \"Diagnostic Reset\"\n};\n#define DIAGNOSTIC_SUBTYPE_COUNT (sizeof(diagnostic_subtypes) / sizeof(diagnostic_subtypes[0]))\n\nstatic const char** g_vulnerable_subTypeDescriptions[EVENT_TYPE_COUNT] = {\n    ignition_subtypes,\n    gearbox_subtypes,\n    wheel_speed_subtypes,\n    battery_subtypes,\n    diagnostic_subtypes\n};\n\nstatic const uint8_t g_vulnerable_subTypeCounts[EVENT_TYPE_COUNT] = {\n    IGNITION_SUBTYPE_COUNT,\n    GEARBOX_SUBTYPE_COUNT,\n    WHEEL_SPEED_SUBTYPE_COUNT,\n    BATTERY_SUBTYPE_COUNT,\n    DIAGNOSTIC_SUBTYPE_COUNT\n};\n\nvoid systemLog_vulnerable(const char* msg) {\n    printf(\"SYS_LOG: %s\\n\", msg);\n}\n\nVehicleEvent_Vulnerable receiveVehicleEvent_vulnerable() {\n    VehicleEvent_Vulnerable event;\n    event.type = EVENT_TYPE_GEARBOX;\n    event.subtype_idx = GEARBOX_SUBTYPE_COUNT;\n    event.data_payload = 0xABCD;\n    return event;\n}\n\nvoid processVehicleEvent_vulnerable() {\n    VehicleEvent_Vulnerable event = receiveVehicleEvent_vulnerable();\n\n    if (event.type < EVENT_TYPE_COUNT) {\n        const char* subtype_desc = g_vulnerable_subTypeDescriptions[event.type][event.subtype_idx];\n        systemLog_vulnerable(subtype_desc);\n    } else {\n        systemLog_vulnerable(\"Received event with invalid main type.\");\n    }\n}\n\nvoid automotiveApplicationMain_vulnerable() {\n    processVehicleEvent_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\nstruct CalibrationPoint {\n    uint32_t timestamp;\n    int16_t value;\n};\n\nstruct CalibrationPacketHeader {\n    uint16_t packet_magic;\n    uint16_t num_calibration_points;\n    uint8_t  _reserved[4];\n};\n\nclass CalibrationManager {\nprivate:\n    CalibrationPoint* m_current_calibration_data;\n    size_t m_allocated_buffer_size_bytes;\n    size_t m_active_points_count;\n\npublic:\n    CalibrationManager() : m_current_calibration_data(nullptr), m_allocated_buffer_size_bytes(0), m_active_points_count(0) {}\n\n    ~CalibrationManager() {\n        if (m_current_calibration_data) {\n            free(m_current_calibration_data);\n            m_current_calibration_data = nullptr;\n        }\n    }\n\n    void clearCalibrationData() {\n        if (m_current_calibration_data) {\n            free(m_current_calibration_data);\n            m_current_calibration_data = nullptr;\n        }\n        m_allocated_buffer_size_bytes = 0;\n        m_active_points_count = 0;\n    }\n\n    bool processCalibrationPacketVulnerable(const uint8_t* packet_buffer, size_t buffer_length) {\n        if (!packet_buffer || buffer_length < sizeof(CalibrationPacketHeader)) {\n            return false;\n        }\n\n        const CalibrationPacketHeader* header = reinterpret_cast<const CalibrationPacketHeader*>(packet_buffer);\n\n        if (header->packet_magic != 0xABCD) {\n            return false;\n        }\n\n        uint16_t num_points = header->num_calibration_points;\n\n        // This calculation is for validating the *incoming packet's* stated length.\n        // It does not protect against a subsequent heap allocation error.\n        size_t expected_payload_bytes_from_packet = num_points * sizeof(CalibrationPoint);\n        size_t total_expected_packet_size = sizeof(CalibrationPacketHeader) + expected_payload_bytes_from_packet;\n\n        if (buffer_length < total_expected_packet_size) {\n            return false;\n        }\n\n        clearCalibrationData();\n\n        // VULNERABILITY: Incorrect size calculation for malloc.\n        // CalibrationPoint is 6 bytes (uint32_t + int16_t). sizeof(uint16_t) is 2 bytes.\n        // This allocates only 1/3 of the required memory, leading to a heap overflow\n        // when the data points are subsequently written to the undersized buffer.\n        m_current_calibration_data = (CalibrationPoint*)malloc(num_points * sizeof(uint16_t));\n\n        if (!m_current_calibration_data && num_points > 0) {\n            return false;\n        }\n        m_allocated_buffer_size_bytes = num_points * sizeof(uint16_t);\n\n        const uint8_t* data_ptr = packet_buffer + sizeof(CalibrationPacketHeader);\n        size_t current_data_offset = 0;\n\n        for (uint16_t i = 0; i < num_points; ++i) {\n            // The following assignments will write out of bounds because 'm_current_calibration_data'\n            // was allocated assuming each 'CalibrationPoint' is only 2 bytes large,\n            // but each actual 'CalibrationPoint' consumes 6 bytes.\n\n            // Read timestamp (uint32_t) from packet and write to heap buffer\n            m_current_calibration_data[i].timestamp = (uint32_t)data_ptr[current_data_offset] |\n                                                      ((uint32_t)data_ptr[current_data_offset + 1] << 8) |\n                                                      ((uint32_t)data_ptr[current_data_offset + 2] << 16) |\n                                                      ((uint32_t)data_ptr[current_data_offset + 3] << 24);\n            current_data_offset += sizeof(uint32_t);\n\n            // Read value (int16_t) from packet and write to heap buffer\n            m_current_calibration_data[i].value = (int16_t)data_ptr[current_data_offset] |\n                                                  ((int16_t)data_ptr[current_data_offset + 1] << 8);\n            current_data_offset += sizeof(int16_t);\n        }\n\n        m_active_points_count = num_points;\n        return true;\n    }\n\n    size_t getActivePointsCount() const {\n        return m_active_points_count;\n    }\n\n    const CalibrationPoint* getCalibrationData() const {\n        return m_current_calibration_data;\n    }\n};\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define TRANSACTION_LOG_CAPACITY 16\n\ntypedef struct {\n    uint32_t transaction_id;\n    uint32_t timestamp;\n    uint8_t status_flags;\n    uint8_t data[4];\n} TransactionRecord;\n\nstatic TransactionRecord g_transaction_log[TRANSACTION_LOG_CAPACITY];\nstatic uint16_t g_current_transaction_count = 0;\nstatic uint16_t g_next_write_idx = 0;\n\nvoid init_transaction_manager() {\n    memset(g_transaction_log, 0, sizeof(g_transaction_log));\n    g_current_transaction_count = 0;\n    g_next_write_idx = 0;\n}\n\nvoid record_transaction(uint32_t id, uint32_t ts, const uint8_t* data_in) {\n    if (g_current_transaction_count < TRANSACTION_LOG_CAPACITY) {\n        g_current_transaction_count++;\n    }\n\n    TransactionRecord* entry = &g_transaction_log[g_next_write_idx];\n    entry->transaction_id = id;\n    entry->timestamp = ts;\n    entry->status_flags = 0x01;\n    memcpy(entry->data, data_in, sizeof(entry->data));\n\n    g_next_write_idx = (g_next_write_idx + 1) % TRANSACTION_LOG_CAPACITY;\n}\n\nvoid update_transaction_status_by_offset_vulnerable(uint16_t offset_from_current, uint8_t new_status_flag) {\n    if (g_current_transaction_count == 0 || offset_from_current >= g_current_transaction_count) {\n        return;\n    }\n\n    int32_t last_written_idx;\n    if (g_next_write_idx == 0) {\n        last_written_idx = TRANSACTION_LOG_CAPACITY - 1;\n    } else {\n        last_written_idx = g_next_write_idx - 1;\n    }\n\n    int32_t target_idx = last_written_idx - offset_from_current;\n\n    g_transaction_log[target_idx].status_flags = new_status_flag;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\nvoid log_diag_fixed(const char* msg) {\n    printf(\"FIXED LOG: %s\\n\", msg);\n}\n\n#define MAX_MESSAGE_BUFFER_SIZE_FIXED 256\nstatic uint8_t g_messageBuffer_fixed[MAX_MESSAGE_BUFFER_SIZE_FIXED];\nstatic uint16_t g_currentParseOffset_fixed = 0;\n\ntypedef struct {\n    uint8_t command_code;\n    int16_t param_length_bytes; \n    uint8_t data[10]; \n} IncomingDiagMessage_fixed;\n\nIncomingDiagMessage_fixed receiveDiagMessage_fixed() {\n    IncomingDiagMessage_fixed msg;\n    msg.command_code = 0x01;\n    msg.param_length_bytes = -10; \n    for (int i = 0; i < 10; ++i) {\n        msg.data[i] = (uint8_t)i;\n    }\n    return msg;\n}\n\nvoid initializeParser_fixed() {\n    g_currentParseOffset_fixed = 5; \n    for (int i = 0; i < MAX_MESSAGE_BUFFER_SIZE_FIXED; ++i) {\n        g_messageBuffer_fixed[i] = (uint8_t)(i % 0xFF); \n    }\n    log_diag_fixed(\"Parser initialized (fixed).\");\n}\n\nvoid parseVariableLengthParameter_fixed(int16_t param_length_bytes) {\n    log_diag_fixed(\"Attempting to parse variable length parameter (fixed).\");\n\n    if (param_length_bytes < 0) {\n        log_diag_fixed(\"Error: Negative parameter length received. Aborting parse step.\");\n        return;\n    }\n\n    uint16_t proposed_new_offset = g_currentParseOffset_fixed + (uint16_t)param_length_bytes; \n\n    if (proposed_new_offset > MAX_MESSAGE_BUFFER_SIZE_FIXED) {\n        log_diag_fixed(\"Error: Parameter length would cause buffer overflow. Aborting parse step.\");\n        return;\n    }\n\n    g_currentParseOffset_fixed = proposed_new_offset; \n\n    if (g_currentParseOffset_fixed < MAX_MESSAGE_BUFFER_SIZE_FIXED) {\n        log_diag_fixed(\"Offset updated. Attempting to read a byte at new position.\");\n        uint8_t val = g_messageBuffer_fixed[g_currentParseOffset_fixed]; \n        printf(\"FIXED: Read byte: %02X at offset %u\\n\", val, g_currentParseOffset_fixed);\n    } else {\n        log_diag_fixed(\"Assertion failed: Parser offset became out of bounds after update. This should not happen with proper checks.\");\n    }\n}\n\nvoid diagParser_fixed_main() {\n    initializeParser_fixed();\n    IncomingDiagMessage_fixed msg = receiveDiagMessage_fixed();\n    parseVariableLengthParameter_fixed(msg.param_length_bytes);\n    log_diag_fixed(\"Fixed diagnostic parser finished.\");\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_CALIBRATION_RECORDS 100\n#define CALIBRATION_DATA_BLOCK_SIZE 16\n\ntypedef struct {\n    uint32_t record_id;\n    uint32_t timestamp_utc;\n    uint8_t  cal_data[CALIBRATION_DATA_BLOCK_SIZE];\n    uint8_t  record_status;\n    uint8_t  padding[3];\n} CalibrationRecord_t;\n\nstatic CalibrationRecord_t g_calibration_history[MAX_CALIBRATION_RECORDS];\nstatic int16_t g_current_record_count = 0;\n\nuint32_t get_current_timestamp_vulnerable() {\n    static uint32_t s_timestamp = 1000;\n    return s_timestamp++;\n}\n\nvoid CalHistory_Init_Vulnerable() {\n    memset(g_calibration_history, 0, sizeof(g_calibration_history));\n    g_current_record_count = 0;\n}\n\nbool CalHistory_AddRecord_Vulnerable(const uint8_t* data_block, uint32_t record_id) {\n    if (g_current_record_count >= MAX_CALIBRATION_RECORDS) {\n        return false;\n    }\n    if (data_block == NULL) {\n        return false;\n    }\n\n    g_calibration_history[g_current_record_count].record_id = record_id;\n    g_calibration_history[g_current_record_count].timestamp_utc = get_current_timestamp_vulnerable();\n    memcpy(g_calibration_history[g_current_record_count].cal_data, data_block, CALIBRATION_DATA_BLOCK_SIZE);\n    g_calibration_history[g_current_record_count].record_status = 1;\n\n    g_current_record_count++;\n    return true;\n}\n\nvoid CalHistory_MarkRecordInvalid_Vulnerable(uint16_t relative_offset) {\n    if (g_current_record_count == 0) {\n        return;\n    }\n\n    int16_t target_absolute_idx = g_current_record_count - 1 - relative_offset;\n\n    g_calibration_history[target_absolute_idx].record_status = 0;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define CALIBRATION_STORAGE_SIZE 128\n#define INITIAL_CALIBRATION_DATA_LEN 10\n#define MAX_PARAM_PAYLOAD_LEN 60\n\nstatic uint8_t g_calibrationStorage[CALIBRATION_STORAGE_SIZE];\nstatic uint16_t g_currentCalibrationOffset = 0;\n\nvoid initCalibrationManager() {\n    memset(g_calibrationStorage, 0, CALIBRATION_STORAGE_SIZE);\n    for (uint8_t i = 0; i < INITIAL_CALIBRATION_DATA_LEN; ++i) {\n        g_calibrationStorage[i] = i * 2;\n    }\n    g_currentCalibrationOffset = INITIAL_CALIBRATION_DATA_LEN;\n}\n\nint processCalibrationPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len < 1) {\n        return -1;\n    }\n\n    uint16_t current_packet_read_offset = 0;\n    uint8_t num_params = packet[current_packet_read_offset++];\n\n    if (num_params == 0) {\n        return 0;\n    }\n\n    if (current_packet_read_offset >= packet_len) {\n        return -2;\n    }\n\n    uint16_t anticipated_new_data_total_len = 0;\n\n    uint16_t temp_packet_offset_check = current_packet_read_offset;\n    for (uint8_t i = 0; i < num_params; ++i) {\n        if (temp_packet_offset_check + 2 > packet_len) {\n            return -3;\n        }\n\n        uint8_t param_id = packet[temp_packet_offset_check];\n        uint8_t param_len = packet[temp_packet_offset_check + 1];\n        \n        temp_packet_offset_check += 2;\n\n        if (param_len > MAX_PARAM_PAYLOAD_LEN) {\n             return -4;\n        }\n\n        if (temp_packet_offset_check + param_len > packet_len) {\n            return -5;\n        }\n\n        uint16_t entry_size_in_storage = 1 + param_len;\n\n        if (anticipated_new_data_total_len > (0xFFFF - entry_size_in_storage)) { \n            return -7;\n        }\n        anticipated_new_data_total_len += entry_size_in_storage;\n\n        temp_packet_offset_check += param_len;\n    }\n\n    if (g_currentCalibrationOffset + anticipated_new_data_total_len > CALIBRATION_STORAGE_SIZE) {\n        return -6;\n    }\n\n    current_packet_read_offset = 1;\n\n    for (uint8_t i = 0; i < num_params; ++i) {\n        uint8_t param_id = packet[current_packet_read_offset++];\n        uint8_t param_len = packet[current_packet_read_offset++];\n        \n        g_calibrationStorage[g_currentCalibrationOffset++] = param_id;\n\n        for (uint8_t j = 0; j < param_len; ++j) {\n            g_calibrationStorage[g_currentCalibrationOffset++] = packet[current_packet_read_offset++];\n        }\n    }\n\n    return 0;\n}\n\nvoid handleCalibrationUpdate(const uint8_t* data, uint16_t len) {\n    processCalibrationPacket(data, len);\n}\n\nuint8_t getCalibrationByte(uint8_t index) {\n    if (index < CALIBRATION_STORAGE_SIZE) {\n        return g_calibrationStorage[index];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CAL_DATA_BUFFER_SIZE 256\n#define CAL_PAGE_SIZE 16\n\nclass VehicleCalibrationManagerFixed {\nprivate:\n    uint8_t m_calibration_data_fixed[CAL_DATA_BUFFER_SIZE];\n    uint16_t m_current_data_size_fixed;\n\npublic:\n    VehicleCalibrationManagerFixed() : m_current_data_size_fixed(0) {\n        memset(m_calibration_data_fixed, 0xFF, CAL_DATA_BUFFER_SIZE);\n    }\n\n    bool write_calibration_segment_fixed(const uint8_t* data, uint16_t len) {\n        if (m_current_data_size_fixed + len > CAL_DATA_BUFFER_SIZE) {\n            return false;\n        }\n        memcpy(m_calibration_data_fixed + m_current_data_size_fixed, data, len);\n        m_current_data_size_fixed += len;\n        return true;\n    }\n\n    void reset_leading_segment_fixed(uint8_t segment_id, int16_t metadata_adjust, uint16_t reset_length) {\n        if (reset_length == 0) {\n            return;\n        }\n\n        uint32_t base_offset_bytes = (uint32_t)segment_id * CAL_PAGE_SIZE;\n        int32_t calculated_start_index = (int32_t)base_offset_bytes + metadata_adjust;\n\n        uint32_t actual_start_index = 0;\n        uint32_t effective_bytes_to_clear = 0;\n\n        if (calculated_start_index < 0) {\n            actual_start_index = 0;\n            effective_bytes_to_clear = (uint32_t)((int32_t)reset_length + calculated_start_index > 0 ? (int32_t)reset_length + calculated_start_index : 0);\n        } else {\n            actual_start_index = (uint32_t)calculated_start_index;\n            effective_bytes_to_clear = reset_length;\n        }\n\n        if (actual_start_index >= CAL_DATA_BUFFER_SIZE) {\n            return;\n        }\n        if (actual_start_index + effective_bytes_to_clear > CAL_DATA_BUFFER_SIZE) {\n            effective_bytes_to_clear = CAL_DATA_BUFFER_SIZE - actual_start_index;\n        }\n        \n        if (effective_bytes_to_clear == 0) {\n            return;\n        }\n\n        for (uint32_t i = 0; i < effective_bytes_to_clear; ++i) {\n            m_calibration_data_fixed[actual_start_index + i] = 0x00;\n        }\n\n        if (actual_start_index < m_current_data_size_fixed) {\n            volatile uint8_t check_byte = m_calibration_data_fixed[actual_start_index];\n            (void)check_byte;\n        }\n    }\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_BATTERY_PROFILES 4\n#define PMU_HARDWARE_REG_COUNT 8\n\nvoid logPMUError_vulnerable(const char* msg) {\n}\n\nuint32_t g_pmuHardwareRegisters_vulnerable[PMU_HARDWARE_REG_COUNT];\n\nvoid writePMURegister_vulnerable(uint8_t reg_idx, uint32_t value) {\n    if (reg_idx < PMU_HARDWARE_REG_COUNT) {\n        g_pmuHardwareRegisters_vulnerable[reg_idx] = value;\n    } else {\n        logPMUError_vulnerable(\"Attempted to write to out-of-bounds PMU register.\");\n    }\n}\n\ntypedef struct {\n    float charging_voltage_mV;\n    float discharge_cut_off_voltage_mV;\n    uint16_t max_charge_current_mA;\n    uint16_t max_discharge_current_mA;\n    uint8_t  temperature_threshold_C;\n} BatteryProfile_vulnerable;\n\ntypedef enum {\n    BATTERY_TYPE_LEAD_ACID = 0,\n    BATTERY_TYPE_LI_ION = 1,\n    BATTERY_TYPE_NICKEL_METAL_HYDRIDE = 2,\n    BATTERY_TYPE_CUSTOM_PERFORMANCE = 3,\n    BATTERY_TYPE_DIAGNOSTIC_MODE = 4 \n} BatteryProfileIdentifier_vulnerable;\n\nstatic BatteryProfile_vulnerable g_batteryProfiles_vulnerable[MAX_BATTERY_PROFILES];\n\nvoid initializeBatteryProfiles_vulnerable() {\n    g_batteryProfiles_vulnerable[BATTERY_TYPE_LEAD_ACID] = (BatteryProfile_vulnerable){14200.0f, 10500.0f, 5000, 10000, 45};\n    g_batteryProfiles_vulnerable[BATTERY_TYPE_LI_ION] = (BatteryProfile_vulnerable){16800.0f, 12000.0f, 8000, 15000, 55};\n    g_batteryProfiles_vulnerable[BATTERY_TYPE_NICKEL_METAL_HYDRIDE] = (BatteryProfile_vulnerable){15000.0f, 9500.0f, 6000, 12000, 50};\n    g_batteryProfiles_vulnerable[BATTERY_TYPE_CUSTOM_PERFORMANCE] = (BatteryProfile_vulnerable){17000.0f, 11500.0f, 10000, 20000, 60};\n}\n\nBatteryProfileIdentifier_vulnerable getExternalBatteryConfig_vulnerable() {\n    return BATTERY_TYPE_DIAGNOSTIC_MODE;\n}\n\nvoid applyVoltageRegulationProfile_vulnerable() {\n    BatteryProfileIdentifier_vulnerable current_profile_id = getExternalBatteryConfig_vulnerable();\n\n    BatteryProfile_vulnerable profile_to_apply = g_batteryProfiles_vulnerable[current_profile_id];\n\n    writePMURegister_vulnerable(0, (uint32_t)profile_to_apply.charging_voltage_mV);\n    writePMURegister_vulnerable(1, (uint32_t)profile_to_apply.discharge_cut_off_voltage_mV);\n    writePMURegister_vulnerable(2, profile_to_apply.max_charge_current_mA);\n    writePMURegister_vulnerable(3, profile_to_apply.max_discharge_current_mA);\n    writePMURegister_vulnerable(4, profile_to_apply.temperature_threshold_C);\n}\n\nvoid powerManagementUnitMain_vulnerable() {\n    initializeBatteryProfiles_vulnerable();\n    applyVoltageRegulationProfile_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define ECU_REG_MAP_SIZE 100\n\nstatic uint8_t g_ecuRegisterMap[ECU_REG_MAP_SIZE];\n\nvoid initEcuRegisterMap() {\n    memset(g_ecuRegisterMap, 0, ECU_REG_MAP_SIZE);\n}\n\nint setEcuRegisterBitfield(uint8_t start_byte_offset, uint8_t start_bit_in_byte, uint8_t num_bits, uint16_t value) {\n    if (start_byte_offset >= ECU_REG_MAP_SIZE || start_bit_in_byte >= 8 || num_bits == 0) {\n        return -1;\n    }\n\n    uint16_t mask = (1 << num_bits) - 1;\n    if (num_bits > 16) {\n        mask = 0xFFFF;\n    }\n    value &= mask;\n\n    uint8_t current_byte_idx = start_byte_offset;\n    uint8_t bits_written = 0;\n    uint8_t bits_remaining_in_field = num_bits;\n\n    while (bits_remaining_in_field > 0) {\n        uint8_t bits_in_current_chunk;\n        if (bits_written == 0) {\n            bits_in_current_chunk = 8 - start_bit_in_byte;\n        } else {\n            bits_in_current_chunk = 8;\n            start_bit_in_byte = 0;\n        }\n        \n        if (bits_in_current_chunk > bits_remaining_in_field) {\n            bits_in_current_chunk = bits_remaining_in_field;\n        }\n        \n        uint8_t current_byte_value = g_ecuRegisterMap[current_byte_idx];\n\n        uint8_t local_mask = ((1 << bits_in_current_chunk) - 1) << start_bit_in_byte;\n        current_byte_value &= ~local_mask;\n\n        uint8_t value_part = (value >> bits_written) & ((1 << bits_in_current_chunk) - 1);\n        current_byte_value |= (value_part << start_bit_in_byte);\n\n        g_ecuRegisterMap[current_byte_idx] = current_byte_value;\n\n        bits_written += bits_in_current_chunk;\n        bits_remaining_in_field -= bits_in_current_chunk;\n        current_byte_idx++;\n    }\n\n    return 0;\n}\n\nvoid handleEcuConfigCommand(const uint8_t* command_payload, uint8_t payload_len) {\n    if (command_payload == NULL || payload_len < 4) {\n        return;\n    }\n\n    uint8_t byte_offset = command_payload[0];\n    uint8_t bit_offset = command_payload[1] & 0x07;\n    uint8_t num_bits = command_payload[2];\n\n    uint16_t value = 0;\n    if (payload_len >= 5) {\n        value = (command_payload[3] << 8) | command_payload[4];\n    } else if (payload_len == 4) {\n        value = command_payload[3];\n    }\n\n    setEcuRegisterBitfield(byte_offset, bit_offset, num_bits, value);\n}\n\nuint8_t getEcuRegisterByte(uint8_t offset) {\n    if (offset < ECU_REG_MAP_SIZE) {\n        return g_ecuRegisterMap[offset];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define MAX_DIAG_PACKET_SIZE 256\n#define DIAG_DATA_AREA_OFFSET 8\n\ntypedef struct {\n    uint16_t command_id;\n    uint16_t data_length;\n    uint32_t timestamp;\n} DiagnosticHeader;\n\nstatic uint8_t g_diag_packet_buffer[MAX_DIAG_PACKET_SIZE];\nstatic size_t g_current_packet_len = 0;\n\nvoid clear_diag_buffer() {\n    memset(g_diag_packet_buffer, 0, MAX_DIAG_PACKET_SIZE);\n    g_current_packet_len = 0;\n}\n\nvoid receive_diag_packet(const uint8_t* raw_data, size_t len) {\n    if (len > MAX_DIAG_PACKET_SIZE) {\n        len = MAX_DIAG_PACKET_SIZE;\n    }\n    memcpy(g_diag_packet_buffer, raw_data, len);\n    g_current_packet_len = len;\n}\n\ntypedef struct {\n    int16_t relative_offset;\n    uint8_t  field_id;\n    uint8_t  field_size;\n} DataFieldDescriptor;\n\nvoid process_diagnostic_fields_vulnerable(const DataFieldDescriptor* fields, size_t num_fields, uint8_t update_value) {\n    if (g_current_packet_len < DIAG_DATA_AREA_OFFSET) {\n        return;\n    }\n\n    uint8_t* data_ptr = g_diag_packet_buffer + DIAG_DATA_AREA_OFFSET;\n    size_t data_area_size = g_current_packet_len - DIAG_DATA_AREA_OFFSET;\n\n    for (size_t i = 0; i < num_fields; ++i) {\n        const DataFieldDescriptor* field = &fields[i];\n\n        if (field->field_size == 0 || field->field_size > data_area_size) {\n            continue;\n        }\n\n        uint8_t* target_addr = data_ptr + field->relative_offset;\n\n        *target_addr = update_value;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_SETTINGS_BUFFER_SIZE 128\n#define MAX_SETTINGS_COMMAND_PAYLOAD_SIZE 64\n#define SETTINGS_COMMAND_ID_UPDATE 0x01\n\nstatic uint8_t g_vehicleSettings[VEHICLE_SETTINGS_BUFFER_SIZE];\n\nvoid initVehicleSettings() {\n    memset(g_vehicleSettings, 0, VEHICLE_SETTINGS_BUFFER_SIZE);\n    for (uint8_t i = 0; i < VEHICLE_SETTINGS_BUFFER_SIZE; ++i) {\n        g_vehicleSettings[i] = (uint8_t)(i % 0xFF);\n    }\n}\n\nint applyVehicleSettingsCommand(const uint8_t* raw_command_packet, uint16_t packet_length) {\n    if (raw_command_packet == NULL || packet_length < 4) {\n        return -1;\n    }\n\n    uint8_t command_id = raw_command_packet[0];\n    if (command_id != SETTINGS_COMMAND_ID_UPDATE) {\n        return -2;\n    }\n\n    uint8_t target_start_address = raw_command_packet[1];\n    uint8_t data_block_length = raw_command_packet[2];\n\n    if (data_block_length > MAX_SETTINGS_COMMAND_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    if (packet_length < (3 + data_block_length)) {\n        return -4;\n    }\n    \n    for (uint8_t i = 0; i < data_block_length; ++i) {\n        g_vehicleSettings[target_start_address + i] = raw_command_packet[3 + i];\n    }\n\n    return 0;\n}\n\nvoid receiveSettingsUpdateMessage(const uint8_t* message, uint16_t length) {\n    initVehicleSettings();\n    applyVehicleSettingsCommand(message, length);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAGNOSTIC_BUFFER_SIZE_FIXED 256\n#define DIAG_DATA_POINT_SIZE_FIXED 4\n\nstatic uint8_t g_diagnostic_data_buffer_fixed[DIAGNOSTIC_BUFFER_SIZE_FIXED];\nstatic int32_t g_current_read_offset_fixed = 0;\nstatic uint32_t g_bytes_stored_fixed = 0;\n\nvoid init_diagnostic_system_fixed() {\n    memset(g_diagnostic_data_buffer_fixed, 0, sizeof(g_diagnostic_data_buffer_fixed));\n    g_current_read_offset_fixed = 0;\n    g_bytes_stored_fixed = 0;\n}\n\nbool add_diagnostic_data_fixed(const uint8_t* data, uint32_t len) {\n    if (len == 0 || data == NULL || (g_bytes_stored_fixed + len) > DIAGNOSTIC_BUFFER_SIZE_FIXED) {\n        return false;\n    }\n    memcpy(g_diagnostic_data_buffer_fixed + g_bytes_stored_fixed, data, len);\n    g_bytes_stored_fixed += len;\n    return true;\n}\n\nuint32_t process_diagnostic_data_point_fixed() {\n    if (g_current_read_offset_fixed < 0 || g_current_read_offset_fixed + DIAG_DATA_POINT_SIZE_FIXED > g_bytes_stored_fixed) {\n        return 0xFFFFFFFF;\n    }\n    uint32_t data_point;\n    memcpy(&data_point, g_diagnostic_data_buffer_fixed + g_current_read_offset_fixed, DIAG_DATA_POINT_SIZE_FIXED);\n    g_current_read_offset_fixed += DIAG_DATA_POINT_SIZE_FIXED;\n    return data_point;\n}\n\nvoid rewind_and_invalidate_diagnostic_stream_fixed(uint32_t num_data_points_to_rewind) {\n    if (g_bytes_stored_fixed == 0) {\n        return;\n    }\n\n    uint32_t desired_bytes_to_rewind = num_data_points_to_rewind * DIAG_DATA_POINT_SIZE_FIXED;\n\n    uint32_t actual_bytes_to_rewind;\n    if (desired_bytes_to_rewind > (uint32_t)g_current_read_offset_fixed) {\n        actual_bytes_to_rewind = (uint32_t)g_current_read_offset_fixed;\n    } else {\n        actual_bytes_to_rewind = desired_bytes_to_rewind;\n    }\n\n    int32_t new_read_offset = g_current_read_offset_fixed - actual_bytes_to_rewind;\n\n    int32_t start_clear_idx = new_read_offset;\n    int32_t end_clear_idx = g_current_read_offset_fixed;\n\n    for (int32_t i = start_clear_idx; i < end_clear_idx; ++i) {\n        g_diagnostic_data_buffer_fixed[i] = 0x00;\n    }\n\n    g_current_read_offset_fixed = new_read_offset;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_TRIP_SEGMENTS 20\n#define TRIP_DATA_SIZE_BYTES 8\n\ntypedef struct {\n    uint16_t segment_id;\n    uint32_t start_time_ms;\n    uint8_t  segment_data[TRIP_DATA_SIZE_BYTES];\n    bool     is_valid;\n} TripSegment;\n\nstatic TripSegment g_trip_segment_buffer[MAX_TRIP_SEGMENTS];\nstatic uint8_t g_current_segment_count = 0;\n\nvoid init_trip_logger() {\n    memset(g_trip_segment_buffer, 0, sizeof(g_trip_segment_buffer));\n    g_current_segment_count = 0;\n}\n\nbool add_trip_segment(uint16_t id, uint32_t time, const uint8_t* data, uint8_t data_len) {\n    if (g_current_segment_count >= MAX_TRIP_SEGMENTS) {\n        return false;\n    }\n    if (data_len > TRIP_DATA_SIZE_BYTES) {\n        data_len = TRIP_DATA_SIZE_BYTES;\n    }\n\n    TripSegment* current_segment = &g_trip_segment_buffer[g_current_segment_count];\n    current_segment->segment_id = id;\n    current_segment->start_time_ms = time;\n    if (data) {\n        memcpy(current_segment->segment_data, data, data_len);\n    }\n    current_segment->is_valid = true;\n    g_current_segment_count++;\n    return true;\n}\n\nvoid process_active_segment(uint8_t index) {\n    if (index < g_current_segment_count && g_trip_segment_buffer[index].is_valid) {\n        volatile uint16_t id = g_trip_segment_buffer[index].segment_id;\n        (void)id;\n    }\n}\n\nvoid clear_N_latest_segments_vulnerable(uint8_t n_to_clear) {\n    if (g_current_segment_count == 0 || n_to_clear == 0) {\n        return;\n    }\n\n    int32_t start_clear_idx = (int32_t)g_current_segment_count - n_to_clear;\n\n    for (int32_t i = 0; i < n_to_clear; ++i) {\n        g_trip_segment_buffer[start_clear_idx + i].is_valid = false;\n    }\n    \n    if (g_current_segment_count > n_to_clear) {\n        g_current_segment_count -= n_to_clear;\n    } else {\n        g_current_segment_count = 0;\n    }\n\n    if (g_current_segment_count > 0) {\n        process_active_segment(0);\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_CALIBRATION_RECORDS_FIXED 100\n#define CALIBRATION_DATA_BLOCK_SIZE_FIXED 16\n\ntypedef struct {\n    uint32_t record_id;\n    uint32_t timestamp_utc;\n    uint8_t  cal_data[CALIBRATION_DATA_BLOCK_SIZE_FIXED];\n    uint8_t  record_status;\n    uint8_t  padding[3];\n} CalibrationRecord_t_Fixed;\n\nstatic CalibrationRecord_t_Fixed g_calibration_history_fixed[MAX_CALIBRATION_RECORDS_FIXED];\nstatic int16_t g_current_record_count_fixed = 0;\n\nuint32_t get_current_timestamp_fixed() {\n    static uint32_t s_timestamp_fixed = 1000;\n    return s_timestamp_fixed++;\n}\n\nvoid CalHistory_Init_Fixed() {\n    memset(g_calibration_history_fixed, 0, sizeof(g_calibration_history_fixed));\n    g_current_record_count_fixed = 0;\n}\n\nbool CalHistory_AddRecord_Fixed(const uint8_t* data_block, uint32_t record_id) {\n    if (g_current_record_count_fixed >= MAX_CALIBRATION_RECORDS_FIXED) {\n        return false;\n    }\n    if (data_block == NULL) {\n        return false;\n    }\n\n    g_calibration_history_fixed[g_current_record_count_fixed].record_id = record_id;\n    g_calibration_history_fixed[g_current_record_count_fixed].timestamp_utc = get_current_timestamp_fixed();\n    memcpy(g_calibration_history_fixed[g_current_record_count_fixed].cal_data, data_block, CALIBRATION_DATA_BLOCK_SIZE_FIXED);\n    g_calibration_history_fixed[g_current_record_count_fixed].record_status = 1;\n\n    g_current_record_count_fixed++;\n    return true;\n}\n\nvoid CalHistory_MarkRecordInvalid_Fixed(uint16_t relative_offset) {\n    if (g_current_record_count_fixed == 0) {\n        return;\n    }\n\n    int16_t target_absolute_idx = g_current_record_count_fixed - 1 - relative_offset;\n\n    if (target_absolute_idx < 0 || target_absolute_idx >= g_current_record_count_fixed) {\n        return;\n    }\n    \n    g_calibration_history_fixed[target_absolute_idx].record_status = 0;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_HISTORICAL_PARAMS 5\n#define MAX_RECORDS_PER_PARAM 10\n\ntypedef struct {\n    uint16_t value;\n    uint32_t timestamp;\n} ParameterDataEntry;\n\n// Stored historical data for each parameter\nstatic ParameterDataEntry g_historicalData_fixed[MAX_HISTORICAL_PARAMS][MAX_RECORDS_PER_PARAM];\n// Current actual count of records for each parameter (can be less than MAX_RECORDS_PER_PARAM)\nstatic uint8_t g_currentRecordCount_fixed[MAX_HISTORICAL_PARAMS];\n\ntypedef struct {\n    uint8_t paramId;\n    uint8_t recordIndex;\n} DiagnosticQuery;\n\nvoid automotiveLog_fixed(const char* msg) {\n}\n\n// Simulates receiving a diagnostic query from an external source (e.g., CAN bus)\nDiagnosticQuery receiveDiagnosticQuery_fixed() {\n    DiagnosticQuery query;\n    query.paramId = 1;\n    query.recordIndex = 7;\n    return query;\n}\n\n// Initializes historical data and actual record counts\nvoid initializeHistoricalData_fixed() {\n    for (uint8_t i = 0; i < MAX_HISTORICAL_PARAMS; ++i) {\n        g_currentRecordCount_fixed[i] = 0;\n        for (uint8_t j = 0; j < MAX_RECORDS_PER_PARAM; ++j) {\n            g_historicalData_fixed[i][j] = (ParameterDataEntry){0, 0};\n        }\n    }\n\n    // Populate some data for paramId 1 with 5 actual records\n    g_currentRecordCount_fixed[1] = 5;\n    for (uint8_t j = 0; j < g_currentRecordCount_fixed[1]; ++j) {\n        g_historicalData_fixed[1][j] = (ParameterDataEntry){100 + j, 0x12345678 + j};\n    }\n\n    // Populate some data for paramId 0 with MAX_RECORDS_PER_PARAM records\n    g_currentRecordCount_fixed[0] = MAX_RECORDS_PER_PARAM;\n    for (uint8_t j = 0; j < g_currentRecordCount_fixed[0]; ++j) {\n        g_historicalData_fixed[0][j] = (ParameterDataEntry){200 + j, 0xAABBCCDD + j};\n    }\n}\n\n// Processes a diagnostic query to retrieve historical data\nvoid processDiagnosticQuery_fixed() {\n    DiagnosticQuery query = receiveDiagnosticQuery_fixed();\n\n    if (query.paramId < MAX_HISTORICAL_PARAMS) {\n        // Fix: Validate recordIndex against the actual number of records for this parameter.\n        if (query.recordIndex < g_currentRecordCount_fixed[query.paramId]) {\n            ParameterDataEntry requestedData = g_historicalData_fixed[query.paramId][query.recordIndex];\n            automotiveLog_fixed(\"Historical data retrieved (fixed).\");\n            // In a real system, requestedData would be sent back or processed.\n        } else {\n            automotiveLog_fixed(\"Requested record index out of bounds for this parameter (fixed).\");\n        }\n    } else {\n        automotiveLog_fixed(\"Invalid parameter ID received (fixed).\");\n    }\n}\n\nvoid automotiveMain_fixed() {\n    initializeHistoricalData_fixed();\n    processDiagnosticQuery_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n\n#pragma pack(push, 1)\nstruct DiagnosticChunkHeaderVulnerable {\n    uint16_t chunk_id;\n    uint16_t chunk_data_length;\n};\n\nstruct DiagnosticPacketHeaderVulnerable {\n    uint32_t packet_sequence_num;\n    uint16_t num_chunks;\n    uint32_t total_expected_chunk_data_bytes;\n};\n#pragma pack(pop)\n\nclass DiagnosticAggregatorVulnerable {\npublic:\n    DiagnosticAggregatorVulnerable() : m_aggregated_data(nullptr), m_allocated_size(0), m_current_write_offset(0) {}\n\n    ~DiagnosticAggregatorVulnerable() {\n        if (m_aggregated_data) {\n            free(m_aggregated_data);\n            m_aggregated_data = nullptr;\n        }\n    }\n\n    bool processDiagnosticPacketVulnerable(const uint8_t* raw_packet_data, size_t packet_len) {\n        if (!raw_packet_data || packet_len < sizeof(DiagnosticPacketHeaderVulnerable)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeaderVulnerable* packet_header = reinterpret_cast<const DiagnosticPacketHeaderVulnerable*>(raw_packet_data);\n\n        if (packet_len < (sizeof(DiagnosticPacketHeaderVulnerable) + packet_header->total_expected_chunk_data_bytes)) {\n            return false;\n        }\n\n        size_t proposed_allocation_size = packet_header->total_expected_chunk_data_bytes;\n        \n        if (m_aggregated_data) {\n            free(m_aggregated_data);\n            m_aggregated_data = nullptr;\n        }\n        m_allocated_size = 0;\n        m_current_write_offset = 0;\n\n        m_aggregated_data = (uint8_t*)malloc(proposed_allocation_size);\n        if (!m_aggregated_data && proposed_allocation_size > 0) {\n            return false;\n        }\n        m_allocated_size = proposed_allocation_size;\n\n        const uint8_t* current_read_ptr = raw_packet_data + sizeof(DiagnosticPacketHeaderVulnerable);\n        size_t remaining_packet_bytes = packet_len - sizeof(DiagnosticPacketHeaderVulnerable);\n\n        for (uint16_t i = 0; i < packet_header->num_chunks; ++i) {\n            if (remaining_packet_bytes < sizeof(DiagnosticChunkHeaderVulnerable)) {\n                if (m_aggregated_data) { free(m_aggregated_data); m_aggregated_data = nullptr; }\n                m_allocated_size = 0;\n                return false;\n            }\n\n            const DiagnosticChunkHeaderVulnerable* chunk_header = reinterpret_cast<const DiagnosticChunkHeaderVulnerable*>(current_read_ptr);\n            uint16_t current_chunk_data_len = chunk_header->chunk_data_length;\n\n            size_t total_chunk_len_in_packet = sizeof(DiagnosticChunkHeaderVulnerable) + current_chunk_data_len;\n\n            if (remaining_packet_bytes < total_chunk_len_in_packet) {\n                if (m_aggregated_data) { free(m_aggregated_data); m_aggregated_data = nullptr; }\n                m_allocated_size = 0;\n                return false;\n            }\n            \n            for (size_t j = 0; j < total_chunk_len_in_packet; ++j) {\n                m_aggregated_data[m_current_write_offset + j] = current_read_ptr[j];\n            }\n            m_current_write_offset += total_chunk_len_in_packet;\n\n            current_read_ptr += total_chunk_len_in_packet;\n            remaining_packet_bytes -= total_chunk_len_in_packet;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedData() const {\n        return m_aggregated_data;\n    }\n\n    size_t getAllocatedSize() const {\n        return m_allocated_size;\n    }\n    \n    size_t getCurrentWriteOffset() const {\n        return m_current_write_offset;\n    }\n\nprivate:\n    uint8_t* m_aggregated_data;\n    size_t m_allocated_size;\n    size_t m_current_write_offset;\n};\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VCU_PARAM_STAGE_BUFFER_SIZE 256\nstatic uint8_t g_vcuParamStageBuffer[VCU_PARAM_STAGE_BUFFER_SIZE];\nstatic uint16_t g_currentStagedParamOffset = 0;\n\ntypedef struct {\n    uint8_t paramId;\n    uint16_t valueOffset;\n    uint8_t valueLength;\n} VcuParameterEntry;\n\n#define MAX_VCU_PARAM_ENTRIES 10\nstatic VcuParameterEntry g_vcuParamTable[MAX_VCU_PARAM_ENTRIES];\nstatic uint8_t g_numVcuParamEntries = 0;\n\nvoid initVcuParamStaging() {\n    memset(g_vcuParamStageBuffer, 0, VCU_PARAM_STAGE_BUFFER_SIZE);\n    g_currentStagedParamOffset = 0;\n    g_numVcuParamEntries = 0;\n}\n\nint processVcuParameterUpdateStream(const uint8_t* update_stream, uint16_t stream_len) {\n    if (update_stream == NULL || stream_len < 2) {\n        return -1;\n    }\n\n    uint16_t current_stream_pos = 0;\n    g_currentStagedParamOffset = 0;\n\n    while (current_stream_pos < stream_len) {\n        if (current_stream_pos + 2 > stream_len) {\n            return -2;\n        }\n\n        uint8_t param_id = update_stream[current_stream_pos++];\n        uint8_t value_len = update_stream[current_stream_pos++];\n\n        if (current_stream_pos + value_len > stream_len) {\n            return -3;\n        }\n\n        if (g_numVcuParamEntries >= MAX_VCU_PARAM_ENTRIES) {\n            return -4;\n        }\n\n        if ((uint16_t)g_currentStagedParamOffset + value_len > VCU_PARAM_STAGE_BUFFER_SIZE) {\n            return -5;\n        }\n\n        g_vcuParamTable[g_numVcuParamEntries].paramId = param_id;\n        g_vcuParamTable[g_numVcuParamEntries].valueOffset = g_currentStagedParamOffset;\n        g_vcuParamTable[g_numVcuParamEntries].valueLength = value_len;\n\n        for (uint8_t i = 0; i < value_len; ++i) {\n            g_vcuParamStageBuffer[g_currentStagedParamOffset + i] = update_stream[current_stream_pos + i];\n        }\n\n        g_currentStagedParamOffset += value_len;\n        current_stream_pos += value_len;\n        g_numVcuParamEntries++;\n    }\n\n    return 0;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define FIRMWARE_SCRATCHPAD_SIZE 1024\n\nstatic uint8_t g_firmware_scratchpad[FIRMWARE_SCRATCHPAD_SIZE];\nstatic size_t g_active_data_size = 0;\n\nvoid init_firmware_scratchpad() {\n    memset(g_firmware_scratchpad, 0xFF, FIRMWARE_SCRATCHPAD_SIZE);\n    g_active_data_size = 0;\n}\n\nbool write_firmware_block(const uint8_t* data, size_t len) {\n    if (g_active_data_size + len > FIRMWARE_SCRATCHPAD_SIZE) {\n        return false;\n    }\n    memcpy(g_firmware_scratchpad + g_active_data_size, data, len);\n    g_active_data_size += len;\n    return true;\n}\n\nvoid apply_firmware_patch_Fixed(const uint8_t* patch_data, size_t patch_len, int rewind_bytes) {\n    if (patch_data == NULL || patch_len == 0) {\n        return;\n    }\n\n    int target_start_offset_calc = (int)g_active_data_size - rewind_bytes;\n\n    if (target_start_offset_calc < 0) {\n        target_start_offset_calc = 0;\n    }\n    \n    if ((size_t)target_start_offset_calc + patch_len > FIRMWARE_SCRATCHPAD_SIZE) {\n        return;\n    }\n\n    size_t actual_target_start_offset = (size_t)target_start_offset_calc;\n\n    memcpy(g_firmware_scratchpad + actual_target_start_offset, patch_data, patch_len);\n\n    if (actual_target_start_offset + patch_len > g_active_data_size) {\n        g_active_data_size = actual_target_start_offset + patch_len;\n    }\n    if (g_active_data_size > FIRMWARE_SCRATCHPAD_SIZE) {\n        g_active_data_size = FIRMWARE_SCRATCHPAD_SIZE;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define LOG_BUFFER_SIZE 32 \n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t speed_kph;\n    uint16_t rpm;\n    uint8_t gear;\n    uint8_t brake_status;\n} VehicleState;\n\nstatic VehicleState g_state_log_buffer[LOG_BUFFER_SIZE];\nstatic int16_t g_latest_entry_idx = -1; \nstatic uint16_t g_active_entry_count = 0; \n\nvoid init_vehicle_state_logger() {\n    memset(g_state_log_buffer, 0, sizeof(g_state_log_buffer));\n    g_latest_entry_idx = -1;\n    g_active_entry_count = 0;\n}\n\nvoid add_vehicle_state_entry(uint32_t ts, uint16_t speed, uint16_t rpm, uint8_t gear_val, uint8_t brake_stat) {\n    g_latest_entry_idx = (g_latest_entry_idx + 1) % LOG_BUFFER_SIZE;\n    if (g_active_entry_count < LOG_BUFFER_SIZE) {\n        g_active_entry_count++;\n    }\n\n    g_state_log_buffer[g_latest_entry_idx].timestamp_ms = ts;\n    g_state_log_buffer[g_latest_entry_idx].speed_kph = speed;\n    g_state_log_buffer[g_latest_entry_idx].rpm = rpm;\n    g_state_log_buffer[g_latest_entry_idx].gear = gear_val;\n    g_state_log_buffer[g_latest_entry_idx].brake_status = brake_stat;\n}\n\nvoid update_historic_brake_status_vulnerable(uint16_t relative_past_steps, uint8_t new_brake_status) {\n    if (g_active_entry_count == 0) {\n        return;\n    }\n\n    int16_t target_idx = g_latest_entry_idx - relative_past_steps;\n\n    g_state_log_buffer[target_idx].brake_status = new_brake_status;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_CALIBRATION_TABLE_SIZE 256\n\nstatic uint16_t g_vehicle_calibration_table[VEHICLE_CALIBRATION_TABLE_SIZE];\nstatic uint16_t g_current_base_cal_idx = 0;\n\nvoid init_vehicle_calibration_system() {\n    for (uint16_t i = 0; i < VEHICLE_CALIBRATION_TABLE_SIZE; ++i) {\n        g_vehicle_calibration_table[i] = i * 2;\n    }\n    g_current_base_cal_idx = 0;\n}\n\nbool set_base_calibration_index(uint16_t base_idx) {\n    if (base_idx < VEHICLE_CALIBRATION_TABLE_SIZE) {\n        g_current_base_cal_idx = base_idx;\n        return true;\n    }\n    return false;\n}\n\nvoid apply_relative_calibration_adjustment_vulnerable(int16_t fine_tune_offset, uint16_t adjustment_value) {\n    int32_t target_index = (int32_t)g_current_base_cal_idx + fine_tune_offset;\n\n    g_vehicle_calibration_table[target_index] = adjustment_value;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_LANE_SEGMENTS 5\n#define MAX_OBJECTS_PER_SEGMENT 10\n\ntypedef struct {\n    uint16_t object_id;\n    float position_x;\n    float position_y;\n    float velocity_x;\n    float velocity_y;\n    uint8_t confidence;\n} DetectedObject_Fixed;\n\ntypedef struct {\n    uint8_t active_objects_count;\n    DetectedObject_Fixed objects[MAX_OBJECTS_PER_SEGMENT];\n} LaneSegmentData_Fixed;\n\nstatic LaneSegmentData_Fixed g_laneData_fixed[MAX_LANE_SEGMENTS];\n\nvoid logPerceptionError_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t lane_idx;\n    uint8_t object_slot_idx;\n    DetectedObject_Fixed obj_data;\n} SensorFusionUpdatePacket_Fixed;\n\nSensorFusionUpdatePacket_Fixed receiveFusionUpdate_fixed() {\n    SensorFusionUpdatePacket_Fixed packet;\n    packet.lane_idx = MAX_LANE_SEGMENTS; \n    packet.object_slot_idx = 0;\n    packet.obj_data = (DetectedObject_Fixed){.object_id = 123, .position_x = 10.5f, .position_y = 5.2f, .velocity_x = 1.0f, .velocity_y = 0.5f, .confidence = 95};\n    return packet;\n}\n\nvoid initializeLaneData_fixed() {\n    for (uint8_t i = 0; i < MAX_LANE_SEGMENTS; ++i) {\n        g_laneData_fixed[i].active_objects_count = 0;\n        for (uint8_t j = 0; j < MAX_OBJECTS_PER_SEGMENT; ++j) {\n            g_laneData_fixed[i].objects[j] = (DetectedObject_Fixed){0};\n        }\n    }\n}\n\nvoid updateLaneObject_fixed() {\n    SensorFusionUpdatePacket_Fixed update = receiveFusionUpdate_fixed();\n\n    if (update.lane_idx < MAX_LANE_SEGMENTS) {\n        if (update.object_slot_idx < MAX_OBJECTS_PER_SEGMENT) {\n            g_laneData_fixed[update.lane_idx].objects[update.object_slot_idx] = update.obj_data;\n            if (update.object_slot_idx >= g_laneData_fixed[update.lane_idx].active_objects_count) {\n                g_laneData_fixed[update.lane_idx].active_objects_count = update.object_slot_idx + 1;\n            }\n        } else {\n            logPerceptionError_fixed(\"Received sensor fusion update with out-of-bounds object slot index.\");\n        }\n    } else {\n        logPerceptionError_fixed(\"Received sensor fusion update with out-of-bounds lane index.\");\n    }\n}\n\nvoid perceptionModuleMain_fixed() {\n    initializeLaneData_fixed();\n    updateLaneObject_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRIES 200\n#define LOG_ENTRY_SIZE 10\n#define TELEMETRY_BUFFER_TOTAL_SIZE (MAX_LOG_ENTRIES * LOG_ENTRY_SIZE)\n\nstatic uint8_t g_telemetryLogBuffer[TELEMETRY_BUFFER_TOTAL_SIZE];\nstatic uint16_t g_logWriteHead = 0;\nstatic uint16_t g_currentValidBytes = 0;\n\nvoid initTelemetryLogger() {\n    memset(g_telemetryLogBuffer, 0, TELEMETRY_BUFFER_TOTAL_SIZE);\n    g_logWriteHead = 0;\n    g_currentValidBytes = 0;\n}\n\nint addTelemetryEntry(const uint8_t* entry_data) {\n    if (entry_data == NULL) {\n        return -1;\n    }\n\n    for (uint8_t i = 0; i < LOG_ENTRY_SIZE; ++i) {\n        g_telemetryLogBuffer[g_logWriteHead] = entry_data[i];\n        g_logWriteHead = (g_logWriteHead + 1) % TELEMETRY_BUFFER_TOTAL_SIZE;\n    }\n\n    if (g_currentValidBytes < TELEMETRY_BUFFER_TOTAL_SIZE) {\n        g_currentValidBytes += LOG_ENTRY_SIZE;\n    }\n    return 0;\n}\n\nint getLatestTelemetryEntries(uint16_t num_requested_entries, uint8_t* response_buffer, uint16_t response_buffer_size) {\n    if (response_buffer == NULL) {\n        return -1;\n    }\n\n    if (num_requested_entries == 0) {\n        return 0;\n    }\n\n    uint16_t max_entries_for_dest_buffer = response_buffer_size / LOG_ENTRY_SIZE;\n    uint16_t max_entries_available_in_log = g_currentValidBytes / LOG_ENTRY_SIZE;\n\n    uint16_t actual_entries_to_copy = num_requested_entries;\n    if (actual_entries_to_copy > max_entries_for_dest_buffer) {\n        actual_entries_to_copy = max_entries_for_dest_buffer;\n    }\n    if (actual_entries_to_copy > max_entries_available_in_log) {\n        actual_entries_to_copy = max_entries_available_in_log;\n    }\n    \n    uint16_t actual_bytes_to_copy = actual_entries_to_copy * LOG_ENTRY_SIZE;\n\n    if (actual_entries_to_copy == 0) {\n        return 0;\n    }\n\n    uint16_t start_byte_offset;\n    if (g_currentValidBytes < TELEMETRY_BUFFER_TOTAL_SIZE) {\n        if (actual_bytes_to_copy > g_currentValidBytes) {\n            start_byte_offset = 0;\n        } else {\n            start_byte_offset = (g_logWriteHead + TELEMETRY_BUFFER_TOTAL_SIZE - g_currentValidBytes + (g_currentValidBytes - actual_bytes_to_copy)) % TELEMETRY_BUFFER_TOTAL_SIZE;\n        }\n    } else {\n        start_byte_offset = (g_logWriteHead + TELEMETRY_BUFFER_TOTAL_SIZE - actual_bytes_to_copy) % TELEMETRY_BUFFER_TOTAL_SIZE;\n    }\n    start_byte_offset %= TELEMETRY_BUFFER_TOTAL_SIZE;\n\n    for (uint16_t i = 0; i < actual_entries_to_copy; ++i) {\n        for (uint8_t j = 0; j < LOG_ENTRY_SIZE; ++j) {\n            uint16_t source_idx = (start_byte_offset + (i * LOG_ENTRY_SIZE) + j) % TELEMETRY_BUFFER_TOTAL_SIZE;\n            response_buffer[(i * LOG_ENTRY_SIZE) + j] = g_telemetryLogBuffer[source_idx];\n        }\n    }\n\n    return actual_bytes_to_copy;\n}\n\nvoid handleDiagnosticRequest(uint16_t command_id, uint16_t param1, uint8_t* diag_resp_buf, uint16_t diag_resp_buf_len) {\n    if (command_id == 0x1234) {\n        getLatestTelemetryEntries(param1, diag_resp_buf, diag_resp_buf_len);\n    }\n}\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define AGGREGATED_DATA_BUFFER_SIZE 256\n#define MAX_INCOMING_PACKET_SIZE 512\n\nstatic uint8_t g_aggregatedDataBuffer[AGGREGATED_DATA_BUFFER_SIZE];\nstatic uint16_t g_currentAggregatedLen = 0;\n\nvoid initDataAggregator() {\n    memset(g_aggregatedDataBuffer, 0, AGGREGATED_DATA_BUFFER_SIZE);\n    g_currentAggregatedLen = 0;\n}\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_length;\n} DataRecordHeader;\n\nint processDiagnosticDataPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len < 1) {\n        return -1;\n    }\n\n    uint16_t current_packet_offset = 0;\n    uint8_t record_count = packet[current_packet_offset++];\n\n    if (record_count == 0) {\n        g_currentAggregatedLen = 0;\n        return 0;\n    }\n    if (current_packet_offset >= packet_len) {\n        return -2;\n    }\n\n    g_currentAggregatedLen = 0;\n\n    for (int i = 0; i < record_count; ++i) {\n        if (current_packet_offset + sizeof(DataRecordHeader) > packet_len) {\n            return -3;\n        }\n\n        DataRecordHeader header;\n        header.record_type = packet[current_packet_offset];\n        current_packet_offset++;\n        header.record_length = packet[current_packet_offset];\n        current_packet_offset++;\n\n        if (current_packet_offset + header.record_length > packet_len) {\n            return -4;\n        }\n\n        for (uint8_t j = 0; j < header.record_length; ++j) {\n            g_aggregatedDataBuffer[g_currentAggregatedLen++] = packet[current_packet_offset++];\n        }\n    }\n\n    return 0;\n}\n\nvoid receiveDataPacket(const uint8_t* data, uint16_t len) {\n    processDiagnosticDataPacket(data, len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <new>\n#include <limits>\n#include <algorithm>\n\n// Represents the format of an incoming network/internal packet header for sensor data batches.\nstruct SensorBatchPacketHeader {\n    uint16_t packet_magic;\n    uint16_t num_readings;\n    uint32_t aggregate_data_payload_size; // Sum of all 'data_length' from individual readings in the packet\n};\n\n// Represents the format of an individual sensor reading entry as it appears in the raw packet\n// and how it's intended to be stored contiguously in the internal buffer.\nstruct RawSensorReadingEntry {\n    uint16_t sensor_id;\n    uint32_t timestamp;\n    uint16_t data_length; // The length of the actual data bytes for THIS reading (following this header)\n    // uint8_t data[]; // Variable length data conceptually follows this header\n};\n\nclass DynamicSensorDataLogger {\npublic:\n    DynamicSensorDataLogger() : m_storage_buffer(nullptr), m_allocated_capacity(0), m_current_size(0) {}\n\n    ~DynamicSensorDataLogger() {\n        if (m_storage_buffer) {\n            delete[] m_storage_buffer;\n        }\n    }\n\n    void clearBuffer() {\n        if (m_storage_buffer) {\n            delete[] m_storage_buffer;\n            m_storage_buffer = nullptr;\n        }\n        m_allocated_capacity = 0;\n        m_current_size = 0;\n    }\n\n    // Processes a raw packet containing a batch of sensor data readings (fixed version).\n    bool processSensorDataBatchFixed(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(SensorBatchPacketHeader)) {\n            return false;\n        }\n\n        const SensorBatchPacketHeader* batch_header = reinterpret_cast<const SensorBatchPacketHeader*>(raw_packet);\n\n        if (batch_header->packet_magic != 0xFEED) {\n            return false;\n        }\n\n        // Add reasonable limits to prevent excessive resource consumption (DoS).\n        static const uint16_t MAX_READINGS = 1000;\n        if (batch_header->num_readings > MAX_READINGS) {\n            return false;\n        }\n        static const uint16_t MAX_SINGLE_PAYLOAD_LEN = 1500; // E.g., based on MTU\n\n        // Check if the total payload size advertised in the header exceeds the provided packet length.\n        if (batch_header->aggregate_data_payload_size > (packet_length - sizeof(SensorBatchPacketHeader))) {\n            return false;\n        }\n\n        clearBuffer();\n\n        // FIX:\n        // Calculate the *correct* total required size for the internal buffer.\n        // This must include the size of each RawSensorReadingEntry header\n        // *plus* the aggregate data payload.\n        size_t headers_total_size;\n        // Prevent integer overflow for multiplication.\n        if (batch_header->num_readings > (std::numeric_limits<size_t>::max() / sizeof(RawSensorReadingEntry))) {\n            return false;\n        }\n        headers_total_size = batch_header->num_readings * sizeof(RawSensorReadingEntry);\n\n        size_t total_required_buffer_size;\n        // Prevent integer overflow for addition.\n        if (headers_total_size > (std::numeric_limits<size_t>::max() - batch_header->aggregate_data_payload_size)) {\n            return false;\n        }\n        total_required_buffer_size = headers_total_size + batch_header->aggregate_data_payload_size;\n\n        // Handle edge case of zero-sized allocation request for non-zero number of readings.\n        if (total_required_buffer_size == 0 && batch_header->num_readings > 0) {\n             return false;\n        }\n        // Handle graceful exit for empty batches.\n        if (total_required_buffer_size == 0 && batch_header->num_readings == 0) {\n            return true;\n        }\n\n        m_storage_buffer = new (std::nothrow) uint8_t[total_required_buffer_size];\n        if (!m_storage_buffer) {\n            return false;\n        }\n        m_allocated_capacity = total_required_buffer_size;\n        m_current_size = 0;\n\n        size_t current_packet_read_offset = sizeof(SensorBatchPacketHeader);\n        uint32_t accumulated_payload_length_from_entries = 0; // For final consistency check\n\n        for (uint16_t i = 0; i < batch_header->num_readings; ++i) {\n            // Ensure enough packet data for the current individual reading header.\n            if (current_packet_read_offset + sizeof(RawSensorReadingEntry) > packet_length) {\n                clearBuffer();\n                return false;\n            }\n\n            const RawSensorReadingEntry* reading_header = reinterpret_cast<const RawSensorReadingEntry*>(raw_packet + current_packet_read_offset);\n\n            size_t current_entry_payload_len = reading_header->data_length;\n            \n            // Enforce maximum individual payload length.\n            if (current_entry_payload_len > MAX_SINGLE_PAYLOAD_LEN) {\n                clearBuffer();\n                return false;\n            }\n\n            size_t current_entry_total_size = sizeof(RawSensorReadingEntry) + current_entry_payload_len;\n\n            // Check if the current entry's data extends beyond the remaining packet data.\n            if (current_packet_read_offset + current_entry_total_size > packet_length) {\n                clearBuffer();\n                return false;\n            }\n            \n            // FIX: Crucial check to prevent heap buffer overflow.\n            // Ensure there is enough space remaining in the allocated internal buffer\n            // before attempting to copy the current entry.\n            if (m_current_size > (m_allocated_capacity - current_entry_total_size)) {\n                clearBuffer();\n                return false; // Not enough space left in our allocated buffer\n            }\n\n            // Copy the entire RawSensorReadingEntry (its fixed header + its data payload).\n            for (size_t k = 0; k < current_entry_total_size; ++k) {\n                m_storage_buffer[m_current_size + k] = raw_packet[current_packet_read_offset + k];\n            }\n\n            // Advance offsets for the next reading.\n            m_current_size += current_entry_total_size;\n            current_packet_read_offset += current_entry_total_size;\n\n            // Accumulate payload length for final consistency check. Add overflow protection.\n            if (accumulated_payload_length_from_entries > (std::numeric_limits<uint32_t>::max() - current_entry_payload_len)) {\n                clearBuffer();\n                return false;\n            }\n            accumulated_payload_length_from_entries += current_entry_payload_len;\n        }\n\n        // Final consistency checks:\n        // 1. Ensure the sum of individual data_lengths matches the advertised aggregate_data_payload_size.\n        // 2. Ensure the total bytes written to the internal buffer matches the calculated total_required_buffer_size.\n        if (accumulated_payload_length_from_entries != batch_header->aggregate_data_payload_size ||\n            m_current_size != total_required_buffer_size) {\n            clearBuffer();\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getStoredData() const { return m_storage_buffer; }\n    size_t getStoredDataSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_storage_buffer;\n    size_t   m_allocated_capacity;\n    size_t   m_current_size;\n};", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMANDS_FIXED 32\n#define INITIAL_COMMAND_OFFSET_FIXED 5 \n\ntypedef enum {\n    CMD_TYPE_NONE_FIXED = 0,\n    CMD_TYPE_ACCEL_FIXED,\n    CMD_TYPE_BRAKE_FIXED,\n    CMD_TYPE_STEER_FIXED,\n    CMD_TYPE_PARK_FIXED\n} CommandType_Fixed;\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    CommandType_Fixed type;\n    int16_t value;\n    bool is_active;\n} VehicleCommand_Fixed;\n\nstatic VehicleCommand_Fixed g_command_log_fixed[MAX_COMMANDS_FIXED];\nstatic uint16_t g_next_write_idx_fixed = INITIAL_COMMAND_OFFSET_FIXED;\nstatic uint16_t g_active_command_count_fixed = 0;\n\nvoid init_command_log_fixed() {\n    memset(g_command_log_fixed, 0, sizeof(g_command_log_fixed));\n    g_next_write_idx_fixed = INITIAL_COMMAND_OFFSET_FIXED;\n    g_active_command_count_fixed = 0;\n}\n\nbool add_vehicle_command_fixed(CommandType_Fixed type, int16_t value) {\n    if (g_next_write_idx_fixed >= MAX_COMMANDS_FIXED) {\n        return false;\n    }\n    g_command_log_fixed[g_next_write_idx_fixed].timestamp_ms = 0xDEADBEEF;\n    g_command_log_fixed[g_next_write_idx_fixed].type = type;\n    g_command_log_fixed[g_next_write_idx_fixed].value = value;\n    g_command_log_fixed[g_next_write_idx_fixed].is_active = true;\n\n    g_next_write_idx_fixed++;\n    g_active_command_count_fixed++;\n    return true;\n}\n\nvoid cancel_command_by_logical_index_fixed(int16_t logical_cmd_idx) {\n    int32_t target_phys_idx = (int32_t)INITIAL_COMMAND_OFFSET_FIXED + logical_cmd_idx;\n\n    if (target_phys_idx < INITIAL_COMMAND_OFFSET_FIXED ||\n        target_phys_idx >= g_next_write_idx_fixed ||\n        target_phys_idx >= MAX_COMMANDS_FIXED) {\n        return;\n    }\n\n    g_command_log_fixed[target_phys_idx].is_active = false;\n    g_command_log_fixed[target_phys_idx].type = CMD_TYPE_NONE_FIXED;\n    g_command_log_fixed[target_phys_idx].value = 0;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <algorithm>\n\n#pragma pack(push, 1)\nstruct DiagnosticMessageHeader {\n    uint16_t message_id;\n    uint16_t data_length; \n    uint32_t timestamp_ms;\n};\n\nstruct DiagnosticPacketHeader {\n    uint32_t packet_sequence_num;\n    uint16_t num_messages;\n    uint16_t reserved;\n};\n#pragma pack(pop)\n\nclass DiagnosticMessageAggregatorFixed {\npublic:\n    DiagnosticMessageAggregatorFixed()\n        : m_aggregated_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {\n        m_allocated_capacity = 4096;\n        m_aggregated_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (m_aggregated_buffer == nullptr) {\n            m_allocated_capacity = 0;\n        }\n        m_current_size = 0;\n    }\n\n    ~DiagnosticMessageAggregatorFixed() {\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n        }\n    }\n\n    bool appendDiagnosticPacketFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeader* packet_header = reinterpret_cast<const DiagnosticPacketHeader*>(raw_packet);\n        size_t current_raw_read_offset = sizeof(DiagnosticPacketHeader);\n\n        for (uint16_t i = 0; i < packet_header->num_messages; ++i) {\n            if (current_raw_read_offset + sizeof(DiagnosticMessageHeader) > packet_len) {\n                return false;\n            }\n\n            const DiagnosticMessageHeader* msg_header = reinterpret_cast<const DiagnosticMessageHeader*>(raw_packet + current_raw_read_offset);\n            uint16_t message_data_len = msg_header->data_length;\n\n            if (current_raw_read_offset + sizeof(DiagnosticMessageHeader) + message_data_len > packet_len) {\n                return false;\n            }\n\n            size_t total_message_storage_size = sizeof(DiagnosticMessageHeader) + message_data_len;\n\n            if (m_current_size > (SIZE_MAX - total_message_storage_size) ||\n                m_current_size + total_message_storage_size > m_allocated_capacity) {\n\n                size_t new_capacity = m_allocated_capacity == 0 ? total_message_storage_size : m_allocated_capacity * 2;\n                if (new_capacity < m_current_size + total_message_storage_size) {\n                    new_capacity = m_current_size + total_message_storage_size;\n                }\n                \n                if (new_capacity > (16ULL * 1024 * 1024)) {\n                    if (total_message_storage_size > (16ULL * 1024 * 1024)) {\n                        return false; \n                    }\n                    new_capacity = (16ULL * 1024 * 1024);\n                }\n\n                uint8_t* new_buffer = (uint8_t*)realloc(m_aggregated_buffer, new_capacity);\n                if (!new_buffer) {\n                    if (m_aggregated_buffer) {\n                        free(m_aggregated_buffer);\n                        m_aggregated_buffer = nullptr;\n                    }\n                    m_current_size = 0;\n                    m_allocated_capacity = 0;\n                    return false;\n                }\n                m_aggregated_buffer = new_buffer;\n                m_allocated_capacity = new_capacity;\n            }\n\n            uint8_t* dest_ptr = m_aggregated_buffer + m_current_size;\n            const uint8_t* source_ptr = raw_packet + current_raw_read_offset;\n\n            for (size_t k = 0; k < sizeof(DiagnosticMessageHeader); ++k) {\n                dest_ptr[k] = source_ptr[k];\n            }\n\n            for (size_t k = 0; k < message_data_len; ++k) {\n                dest_ptr[sizeof(DiagnosticMessageHeader) + k] = source_ptr[sizeof(DiagnosticMessageHeader) + k];\n            }\n            \n            \n\n            m_current_size += total_message_storage_size;\n\n            current_raw_read_offset += sizeof(DiagnosticMessageHeader) + message_data_len;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedBuffer() const { return m_aggregated_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_aggregated_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CAN_PAYLOAD_SIZE 8 \n#define RESPONSE_HEADER_SIZE 3 \n\nint constructDiagnosticResponse(uint8_t* output_buffer, uint16_t output_buffer_max_len,\n                                uint8_t message_id, uint8_t sub_id,\n                                const uint8_t* data_to_send, uint8_t data_len) {\n    if (output_buffer == NULL || data_to_send == NULL) {\n        return -1;\n    }\n\n    uint16_t required_payload_size = (uint16_t)RESPONSE_HEADER_SIZE + data_len;\n\n    if (required_payload_size > output_buffer_max_len) {\n        return -2;\n    }\n\n    output_buffer[0] = message_id;\n    output_buffer[1] = sub_id;\n    output_buffer[2] = data_len;\n\n    uint16_t current_payload_offset = RESPONSE_HEADER_SIZE;\n\n    for (uint8_t i = 0; i <= data_len; ++i) {\n        output_buffer[current_payload_offset + i] = data_to_send[i];\n    }\n\n    return required_payload_size;\n}\n\nvoid simulateCanRxHandler() {\n    uint8_t can_data_buffer[MAX_CAN_PAYLOAD_SIZE];\n    uint8_t sensor_data_to_reply[5];\n    memset(sensor_data_to_reply, 0xAA, sizeof(sensor_data_to_reply));\n\n    /* \n     * Simulate a response construction where data_len matches remaining buffer space. \n     * MAX_CAN_PAYLOAD_SIZE = 8 bytes.\n     * RESPONSE_HEADER_SIZE = 3 bytes.\n     * Remaining space for data = 8 - 3 = 5 bytes.\n     * If data_len is set to 5, the `required_payload_size` becomes 3 + 5 = 8.\n     * The check `(8 > 8)` is false, so it passes. \n     * However, the loop `for (uint8_t i = 0; i <= data_len; ++i)` will iterate 6 times (i=0 to 5).\n     * This means it will attempt to write to `output_buffer[3+5]`, which is `output_buffer[8]`, an out-of-bounds access.\n     */\n    constructDiagnosticResponse(can_data_buffer, MAX_CAN_PAYLOAD_SIZE, 0x01, 0x10, sensor_data_to_reply, sizeof(sensor_data_to_reply));\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_BLOCK_SIZE 512\n\n#define MAX_VEHICLE_NAME_LEN 32\n#define MAX_LICENSE_PLATE_LEN 16\n\n#define CONFIG_ID_VEHICLE_NAME 0x01\n#define CONFIG_ID_LICENSE_PLATE 0x02\n#define CONFIG_ID_SPEED_LIMIT_ENABLED 0x03\n#define CONFIG_ID_MAX_SPEED_VALUE 0x04\n\nstatic char g_vehicleName[MAX_VEHICLE_NAME_LEN + 1];\nstatic char g_licensePlate[MAX_LICENSE_PLATE_LEN + 1];\nstatic uint8_t g_speedLimitEnabled = 0;\nstatic uint16_t g_maxSpeedValue = 0;\n\ntypedef struct {\n    uint8_t param_id;\n    uint8_t param_len;\n} ConfigParamHeader;\n\nvoid resetVehicleConfig() {\n    memset(g_vehicleName, 0, sizeof(g_vehicleName));\n    memset(g_licensePlate, 0, sizeof(g_licensePlate));\n    g_speedLimitEnabled = 0;\n    g_maxSpeedValue = 0;\n    strcpy(g_vehicleName, \"DEFAULT_VEHICLE\");\n    strcpy(g_licensePlate, \"DEFAULT_PLATE\");\n}\n\nint applyVehicleConfiguration(const uint8_t* config_data_block, uint16_t block_len) {\n    if (config_data_block == NULL || block_len == 0 || block_len > MAX_CONFIG_BLOCK_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    while (current_offset < block_len) {\n        if (current_offset + sizeof(ConfigParamHeader) > block_len) {\n            return -2;\n        }\n\n        const ConfigParamHeader* header = (const ConfigParamHeader*)(config_data_block + current_offset);\n        uint8_t param_id = header->param_id;\n        uint8_t param_len = header->param_len;\n\n        if (current_offset + sizeof(ConfigParamHeader) + param_len > block_len) {\n            return -3;\n        }\n\n        const uint8_t* param_value_ptr = config_data_block + current_offset + sizeof(ConfigParamHeader);\n\n        switch (param_id) {\n            case CONFIG_ID_VEHICLE_NAME:\n                memcpy(g_vehicleName, param_value_ptr, param_len);\n                if (param_len < MAX_VEHICLE_NAME_LEN + 1) {\n                    g_vehicleName[param_len] = '\\0';\n                } else {\n                    g_vehicleName[MAX_VEHICLE_NAME_LEN] = '\\0';\n                }\n                break;\n            case CONFIG_ID_LICENSE_PLATE:\n                memcpy(g_licensePlate, param_value_ptr, param_len);\n                if (param_len < MAX_LICENSE_PLATE_LEN + 1) {\n                    g_licensePlate[param_len] = '\\0';\n                } else {\n                    g_licensePlate[MAX_LICENSE_PLATE_LEN] = '\\0';\n                }\n                break;\n            case CONFIG_ID_SPEED_LIMIT_ENABLED:\n                if (param_len == 1) {\n                    g_speedLimitEnabled = param_value_ptr[0];\n                }\n                break;\n            case CONFIG_ID_MAX_SPEED_VALUE:\n                if (param_len == sizeof(uint16_t)) {\n                    g_maxSpeedValue = (param_value_ptr[0] << 8) | param_value_ptr[1];\n                }\n                break;\n            default:\n                break;\n        }\n\n        current_offset += sizeof(ConfigParamHeader) + param_len;\n    }\n\n    return 0;\n}\n\nvoid simulateConfigUpdate(const uint8_t* data, uint16_t len) {\n    resetVehicleConfig();\n    applyVehicleConfiguration(data, len);\n}\n\nconst char* getVehicleName() {\n    return g_vehicleName;\n}\n\nconst char* getLicensePlate() {\n    return g_licensePlate;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#define DIAG_EVENT_BUFFER_CAPACITY_FIXED 64\n\ntypedef struct {\n    uint32_t event_timestamp;\n    uint16_t event_type;\n    int16_t event_value;\n    uint8_t event_status;\n} DiagnosticEvent_Fixed;\n\nstatic DiagnosticEvent_Fixed g_diag_event_buffer_fixed[DIAG_EVENT_BUFFER_CAPACITY_FIXED];\nstatic uint16_t g_event_write_ptr_fixed = 0;\nstatic uint16_t g_num_stored_events_fixed = 0;\n\nvoid init_diag_event_buffer_fixed() {\n    memset(g_diag_event_buffer_fixed, 0, sizeof(g_diag_event_buffer_fixed));\n    g_event_write_ptr_fixed = 0;\n    g_num_stored_events_fixed = 0;\n}\n\nbool add_diagnostic_event_fixed(uint32_t timestamp, uint16_t type, int16_t value) {\n    if (g_num_stored_events_fixed >= DIAG_EVENT_BUFFER_CAPACITY_FIXED) {\n        return false;\n    }\n    g_diag_event_buffer_fixed[g_event_write_ptr_fixed].event_timestamp = timestamp;\n    g_diag_event_buffer_fixed[g_event_write_ptr_fixed].event_type = type;\n    g_diag_event_buffer_fixed[g_event_write_ptr_fixed].event_value = value;\n    g_diag_event_buffer_fixed[g_event_write_ptr_fixed].event_status = 0;\n    g_event_write_ptr_fixed = (g_event_write_ptr_fixed + 1) % DIAG_EVENT_BUFFER_CAPACITY_FIXED;\n    g_num_stored_events_fixed++;\n    return true;\n}\n\nDiagnosticEvent_Fixed* get_event_by_direct_index_fixed(uint16_t index) {\n    if (index >= DIAG_EVENT_BUFFER_CAPACITY_FIXED || index >= g_num_stored_events_fixed) {\n        return NULL;\n    }\n    return &g_diag_event_buffer_fixed[index];\n}\n\nvoid update_event_status_by_relative_pointer_fixed(DiagnosticEvent_Fixed* current_event_ptr, int16_t relative_steps_back, uint8_t new_status) {\n    if (current_event_ptr == NULL) {\n        return;\n    }\n\n    ptrdiff_t current_idx = current_event_ptr - g_diag_event_buffer_fixed;\n\n    ptrdiff_t target_idx = current_idx - relative_steps_back;\n\n    if (target_idx < 0 || target_idx >= DIAG_EVENT_BUFFER_CAPACITY_FIXED) {\n        return;\n    }\n\n    g_diag_event_buffer_fixed[target_idx].event_status = new_status;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_PROCESSED_SENSORS 128\n\ntypedef struct {\n    uint32_t sensor_id;\n    uint32_t processed_value;\n    bool valid;\n} ProcessedSensorEntry;\n\nstatic ProcessedSensorEntry g_processed_sensor_data_fixed[MAX_PROCESSED_SENSORS];\nstatic int16_t g_next_write_idx_fixed = 0;\n\nvoid init_sensor_data_buffer_fixed() {\n    memset(g_processed_sensor_data_fixed, 0, sizeof(g_processed_sensor_data_fixed));\n    g_next_write_idx_fixed = 0;\n}\n\nbool add_processed_sensor_data_fixed(uint32_t id, uint32_t value) {\n    if (g_next_write_idx_fixed >= MAX_PROCESSED_SENSORS) {\n        return false;\n    }\n    g_processed_sensor_data_fixed[g_next_write_idx_fixed].sensor_id = id;\n    g_processed_sensor_data_fixed[g_next_write_idx_fixed].processed_value = value;\n    g_processed_sensor_data_fixed[g_next_write_idx_fixed].valid = true;\n    g_next_write_idx_fixed++;\n    return true;\n}\n\nvoid mark_sensor_data_invalid_fixed(uint16_t historical_offset) {\n    if (g_next_write_idx_fixed == 0) {\n        return;\n    }\n\n    int16_t last_valid_idx = g_next_write_idx_fixed - 1;\n\n    int16_t target_idx = last_valid_idx - historical_offset;\n\n    if (target_idx < 0) {\n        return;\n    }\n\n    g_processed_sensor_data_fixed[target_idx].valid = false;\n    g_processed_sensor_data_fixed[target_idx].processed_value = 0xFFFFFFFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define EVENT_LOG_BUFFER_SIZE 32\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp_ms;\n    bool processed;\n    uint8_t severity;\n} VehicleEventLogEntry;\n\nstatic VehicleEventLogEntry g_event_log[EVENT_LOG_BUFFER_SIZE];\nstatic uint16_t g_log_write_ptr = 0;\nstatic uint16_t g_num_logged_events = 0;\n\nvoid init_event_log() {\n    for (int i = 0; i < EVENT_LOG_BUFFER_SIZE; ++i) {\n        memset(&g_event_log[i], 0, sizeof(VehicleEventLogEntry));\n        g_event_log[i].processed = false;\n    }\n    g_log_write_ptr = 0;\n    g_num_logged_events = 0;\n}\n\nvoid add_event_log_entry(uint16_t id, uint32_t timestamp, uint8_t severity) {\n    if (g_num_logged_events < EVENT_LOG_BUFFER_SIZE) {\n        g_num_logged_events++;\n    }\n    g_event_log[g_log_write_ptr].event_id = id;\n    g_event_log[g_log_write_ptr].timestamp_ms = timestamp;\n    g_event_log[g_log_write_ptr].processed = false;\n    g_event_log[g_log_write_ptr].severity = severity;\n    g_log_write_ptr = (g_log_write_ptr + 1) % EVENT_LOG_BUFFER_SIZE;\n}\n\nvoid mark_event_processed_vulnerable(uint16_t steps_back) {\n    if (g_num_logged_events == 0) {\n        return;\n    }\n\n    int last_event_idx = (g_log_write_ptr == 0) ? (EVENT_LOG_BUFFER_SIZE - 1) : (g_log_write_ptr - 1);\n\n    int target_raw_idx = last_event_idx - steps_back;\n\n    g_event_log[target_raw_idx].processed = true;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n\ntypedef struct {\n    uint16_t message_type;\n    uint16_t total_data_size;\n    uint16_t fragment_offset;\n    uint8_t  fragment_length;\n    uint8_t  payload[64];\n} TelemetryDataFragment;\n\nclass TelemetryDataAssembler {\nprivate:\n    uint8_t* assembled_data_buffer;\n    uint32_t current_assembled_length;\n    uint32_t expected_total_data_size;\n    bool     assembly_active;\n    uint16_t current_message_type;\n\npublic:\n    TelemetryDataAssembler() : assembled_data_buffer(nullptr), current_assembled_length(0),\n                               expected_total_data_size(0), assembly_active(false), current_message_type(0) {}\n\n    ~TelemetryDataAssembler() {\n        if (assembled_data_buffer) {\n            free(assembled_data_buffer);\n            assembled_data_buffer = nullptr;\n        }\n    }\n\n    void resetAssembly() {\n        if (assembled_data_buffer) {\n            free(assembled_data_buffer);\n        }\n        assembled_data_buffer = nullptr;\n        current_assembled_length = 0;\n        expected_total_data_size = 0;\n        assembly_active = false;\n        current_message_type = 0;\n    }\n\n    bool processFragmentVulnerable(const TelemetryDataFragment* fragment) {\n        if (!fragment || fragment->fragment_length > sizeof(fragment->payload)) {\n            return false;\n        }\n\n        if (!assembly_active) {\n            expected_total_data_size = fragment->total_data_size;\n            current_message_type = fragment->message_type;\n\n            if (expected_total_data_size == 0 || expected_total_data_size > 65535) {\n                return false;\n            }\n\n            assembled_data_buffer = (uint8_t*)malloc(expected_total_data_size);\n            if (!assembled_data_buffer) {\n                return false;\n            }\n            current_assembled_length = 0;\n            assembly_active = true;\n        } else {\n            if (fragment->message_type != current_message_type) {\n                return false;\n            }\n        }\n\n        for (uint8_t i = 0; i < fragment->fragment_length; ++i) {\n            assembled_data_buffer[fragment->fragment_offset + i] = fragment->payload[i];\n        }\n\n        uint32_t end_offset = fragment->fragment_offset + fragment->fragment_length;\n        if (end_offset > current_assembled_length) {\n            current_assembled_length = end_offset;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAssembledData() const {\n        if (current_assembled_length == expected_total_data_size) {\n            return assembled_data_buffer;\n        }\n        return nullptr;\n    }\n\n    uint32_t getAssembledLength() const {\n        return current_assembled_length;\n    }\n\n    uint32_t getExpectedTotalSize() const {\n        return expected_total_data_size;\n    }\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_SYSTEM_COMPONENTS 3\n#define TOTAL_CONFIG_SLOTS 20\n\ntypedef struct {\n    uint8_t start_index;\n    uint8_t size;\n} ComponentMapEntry;\n\nstatic const ComponentMapEntry g_componentMap_vulnerable[MAX_SYSTEM_COMPONENTS] = {\n    {0, 10},   \n    {10, 5},   \n    {15, 5}    \n};\n\nstatic uint16_t g_componentConfigData_vulnerable[TOTAL_CONFIG_SLOTS];\n\ntypedef struct {\n    uint8_t component_id;\n    uint8_t parameter_offset;\n    uint16_t new_value;\n} ConfigUpdateCommand_Vulnerable;\n\nvoid logConfigError_vulnerable(const char* msg) {\n}\n\nConfigUpdateCommand_Vulnerable receiveConfigUpdate_vulnerable() {\n    ConfigUpdateCommand_Vulnerable cmd;\n    cmd.component_id = 1; \n    cmd.parameter_offset = 5; \n    cmd.new_value = 0xAA55;\n    return cmd;\n}\n\nvoid initializeComponentConfig_vulnerable() {\n    for (int i = 0; i < TOTAL_CONFIG_SLOTS; ++i) {\n        g_componentConfigData_vulnerable[i] = 0;\n    }\n}\n\nvoid processConfigurationUpdate_vulnerable() {\n    ConfigUpdateCommand_Vulnerable cmd = receiveConfigUpdate_vulnerable();\n\n    if (cmd.component_id < MAX_SYSTEM_COMPONENTS) {\n        uint8_t base_index = g_componentMap_vulnerable[cmd.component_id].start_index;\n        uint8_t absolute_index = base_index + cmd.parameter_offset;\n\n        if (absolute_index < TOTAL_CONFIG_SLOTS) { \n            g_componentConfigData_vulnerable[absolute_index] = cmd.new_value;\n            logConfigError_vulnerable(\"Component configuration updated.\");\n        } else {\n            logConfigError_vulnerable(\"Configuration update failed: Absolute index out of global bounds.\");\n        }\n    } else {\n        logConfigError_vulnerable(\"Configuration update failed: Invalid component ID.\");\n    }\n}\n\nvoid configManagerMain_vulnerable() {\n    initializeComponentConfig_vulnerable();\n    processConfigurationUpdate_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_SCRATCHPAD_BUFFER_SIZE 512\n\nstatic uint8_t g_diag_scratchpad_buffer[DIAG_SCRATCHPAD_BUFFER_SIZE];\nstatic int16_t g_current_diag_data_start_offset = 0;\nstatic uint16_t g_current_diag_data_size = 0;\n\nvoid init_diag_scratchpad() {\n    memset(g_diag_scratchpad_buffer, 0x00, DIAG_SCRATCHPAD_BUFFER_SIZE);\n    g_current_diag_data_start_offset = 0;\n    g_current_diag_data_size = 0;\n}\n\nbool append_diag_data(const uint8_t* data, uint16_t len) {\n    if (data == NULL || len == 0) {\n        return false;\n    }\n    if ((g_current_diag_data_start_offset + g_current_diag_data_size + len) > DIAG_SCRATCHPAD_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_diag_scratchpad_buffer + g_current_diag_data_start_offset + g_current_diag_data_size, data, len);\n    g_current_diag_data_size += len;\n    return true;\n}\n\nvoid trim_diag_data_start_vulnerable(uint16_t data_units_to_trim, uint16_t unit_nominal_size) {\n    if (data_units_to_trim == 0 || unit_nominal_size == 0) {\n        return;\n    }\n\n    int16_t bytes_to_shift = (int16_t)((uint32_t)data_units_to_trim * unit_nominal_size);\n\n    g_current_diag_data_start_offset += bytes_to_shift;\n\n    if (bytes_to_shift < g_current_diag_data_size) {\n        g_current_diag_data_size -= bytes_to_shift;\n    } else {\n        g_current_diag_data_size = 0;\n    }\n\n    if (g_current_diag_data_start_offset >= DIAG_SCRATCHPAD_BUFFER_SIZE) {\n        g_current_diag_data_start_offset = 0;\n        g_current_diag_data_size = 0;\n    }\n}\n\nvoid set_first_unit_status_vulnerable(uint8_t new_status) {\n    if (g_current_diag_data_size == 0) {\n        return;\n    }\n\n    g_diag_scratchpad_buffer[g_current_diag_data_start_offset] = new_status;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n// Define maximum sizes for different types of recorded data\n#define VEHICLE_EVENTS_MAX_ENTRIES 50\n#define EVENT_ENTRY_SIZE_BYTES 12 // Each event entry is 12 bytes\n#define DIAG_SNAPSHOTS_MAX_ENTRIES 10\n#define SNAPSHOT_ENTRY_SIZE_BYTES 32 // Each snapshot entry is 32 bytes\n#define USER_LOGS_MAX_ENTRIES 20\n#define USER_LOG_ENTRY_SIZE_BYTES 8 // Each user log entry is 8 bytes\n\n// Total buffer size for all recorded data, ensuring contiguous allocation\n#define TOTAL_RECORDER_BUFFER_SIZE \\\n    (VEHICLE_EVENTS_MAX_ENTRIES * EVENT_ENTRY_SIZE_BYTES + \\\n     DIAG_SNAPSHOTS_MAX_ENTRIES * SNAPSHOT_ENTRY_SIZE_BYTES + \\\n     USER_LOGS_MAX_ENTRIES * USER_LOG_ENTRY_SIZE_BYTES)\n\n// Global buffer where all VDR data is stored contiguously\nstatic uint8_t g_vdrDataBuffer[TOTAL_RECORDER_BUFFER_SIZE];\n\n// Enums for different data types, mapping to specific segments within the global buffer\ntypedef enum {\n    VDR_DATA_TYPE_VEHICLE_EVENTS = 0,\n    VDR_DATA_TYPE_DIAG_SNAPSHOTS,\n    VDR_DATA_TYPE_USER_LOGS,\n    VDR_DATA_TYPE_COUNT // Total number of distinct VDR data types\n} VDRDataType;\n\n// Structure to define segments within the global VDR buffer\ntypedef struct {\n    uint16_t base_offset;      // Start offset of this data type's segment in g_vdrDataBuffer\n    uint16_t entry_size;       // Size of a single entry for this data type\n    uint16_t max_entries;      // Maximum number of entries for this data type in its segment\n    uint16_t current_entries;  // Current number of entries stored\n} VDRSegmentInfo;\n\n// Array of segment information, one for each VDRDataType\nstatic VDRSegmentInfo g_vdrSegments[VDR_DATA_TYPE_COUNT];\n\n// Initializes the VDR system and configures segment offsets and sizes\nvoid initVDRSystem() {\n    memset(g_vdrDataBuffer, 0, TOTAL_RECORDER_BUFFER_SIZE);\n\n    uint16_t current_offset = 0;\n\n    // Initialize VEHICLE_EVENTS segment\n    g_vdrSegments[VDR_DATA_TYPE_VEHICLE_EVENTS].base_offset = current_offset;\n    g_vdrSegments[VDR_DATA_TYPE_VEHICLE_EVENTS].entry_size = EVENT_ENTRY_SIZE_BYTES;\n    g_vdrSegments[VDR_DATA_TYPE_VEHICLE_EVENTS].max_entries = VEHICLE_EVENTS_MAX_ENTRIES;\n    g_vdrSegments[VDR_DATA_TYPE_VEHICLE_EVENTS].current_entries = 0;\n    current_offset += VEHICLE_EVENTS_MAX_ENTRIES * EVENT_ENTRY_SIZE_BYTES;\n\n    // Initialize DIAG_SNAPSHOTS segment\n    g_vdrSegments[VDR_DATA_TYPE_DIAG_SNAPSHOTS].base_offset = current_offset;\n    g_vdrSegments[VDR_DATA_TYPE_DIAG_SNAPSHOTS].entry_size = SNAPSHOT_ENTRY_SIZE_BYTES;\n    g_vdrSegments[VDR_DATA_TYPE_DIAG_SNAPSHOTS].max_entries = DIAG_SNAPSHOTS_MAX_ENTRIES;\n    g_vdrSegments[VDR_DATA_TYPE_DIAG_SNAPSHOTS].current_entries = 0;\n    current_offset += DIAG_SNAPSHOTS_MAX_ENTRIES * SNAPSHOT_ENTRY_SIZE_BYTES;\n\n    // Initialize USER_LOGS segment\n    g_vdrSegments[VDR_DATA_TYPE_USER_LOGS].base_offset = current_offset;\n    g_vdrSegments[VDR_DATA_TYPE_USER_LOGS].entry_size = USER_LOG_ENTRY_SIZE_BYTES;\n    g_vdrSegments[VDR_DATA_TYPE_USER_LOGS].max_entries = USER_LOGS_MAX_ENTRIES;\n    g_vdrSegments[VDR_DATA_TYPE_USER_LOGS].current_entries = 0;\n    // current_offset += USER_LOGS_MAX_ENTRIES * USER_LOG_ENTRY_SIZE_BYTES; // Final offset not needed\n}\n\n// Stores event data into the appropriate VDR segment based on type and index.\n// type: The VDRDataType indicating which segment to target.\n// entry_index: The specific entry slot within that data type's segment.\n// data: Pointer to the raw data payload to store.\n// data_len: The actual length of the raw data payload.\nint storeVDRDataEntry(VDRDataType type, uint16_t entry_index, const uint8_t* data, uint16_t data_len) {\n    if (type >= VDR_DATA_TYPE_COUNT || data == NULL) {\n        return -1; // Invalid type or data pointer\n    }\n\n    VDRSegmentInfo* segment = &g_vdrSegments[type];\n\n    // Check if the entry_index is valid for this segment's allocated entries\n    if (entry_index >= segment->max_entries) {\n        return -2; // Entry index out of bounds for this specific segment\n    }\n\n    // FIX:\n    // Ensure `bytes_to_copy` does not exceed the `segment->entry_size`.\n    // This prevents writing past the end of the allocated slot for the specific entry.\n    uint16_t bytes_to_copy = data_len;\n    if (bytes_to_copy > segment->entry_size) {\n        bytes_to_copy = segment->entry_size; // Truncate the data to fit the allocated slot\n    }\n\n    // Calculate the absolute start offset for the target entry within the global buffer\n    uint16_t target_global_offset = segment->base_offset + (entry_index * segment->entry_size);\n\n    // Defensive check to ensure the calculated offset and length don't exceed the total buffer size.\n    // This should ideally be covered by prior checks (entry_index < max_entries and bytes_to_copy <= entry_size),\n    // but it's good practice for defense-in-depth, especially against arithmetic overflows on `target_global_offset`\n    // if `entry_index * segment->entry_size` were to become very large (though unlikely with uint16_t max values here).\n    if (target_global_offset + bytes_to_copy > TOTAL_RECORDER_BUFFER_SIZE) {\n        return -4; // Calculated write would exceed overall VDR buffer boundary\n    }\n\n    // The loop now uses `bytes_to_copy`, which is guaranteed not to exceed `segment->entry_size`,\n    // preventing out-of-bounds writes into adjacent entries or segments.\n    for (uint16_t i = 0; i < bytes_to_copy; ++i) {\n        g_vdrDataBuffer[target_global_offset + i] = data[i];\n    }\n    \n    // Update current_entries\n    if (entry_index >= segment->current_entries) {\n        segment->current_entries = entry_index + 1;\n    }\n\n    return 0; // Success\n}\n\n// Example usage context (same as vulnerable, but now safe)\nvoid recordVehicleDiagnostics() {\n    initVDRSystem();\n\n    // Store a legitimate vehicle event (12 bytes)\n    uint8_t event_data[EVENT_ENTRY_SIZE_BYTES];\n    memset(event_data, 0x11, EVENT_ENTRY_SIZE_BYTES);\n    storeVDRDataEntry(VDR_DATA_TYPE_VEHICLE_EVENTS, 0, event_data, EVENT_ENTRY_SIZE_BYTES);\n\n    // Store a legitimate diagnostic snapshot (32 bytes)\n    uint8_t snapshot_data[SNAPSHOT_ENTRY_SIZE_BYTES];\n    memset(snapshot_data, 0x22, SNAPSHOT_ENTRY_SIZE_BYTES);\n    storeVDRDataEntry(VDR_DATA_TYPE_DIAG_SNAPSHOTS, 0, snapshot_data, SNAPSHOT_ENTRY_SIZE_BYTES);\n\n    // Simulate an attacker providing overly long data for a smaller slot.\n    // USER_LOG_ENTRY_SIZE_BYTES is 8 bytes.\n    // By providing 15 bytes, the fixed code will now truncate the copy to 8 bytes,\n    // preventing the overflow into the next user log entry slot.\n    uint8_t malicious_log_data[15]; \n    memset(malicious_log_data, 0xEE, 15);\n    // This call is now safe. `data_len` (15) will be truncated to `USER_LOG_ENTRY_SIZE_BYTES` (8).\n    storeVDRDataEntry(VDR_DATA_TYPE_USER_LOGS, 0, malicious_log_data, 15);\n\n    // The next legitimate log entry will now be written to its slot without prior corruption.\n    uint8_t legit_log_data[USER_LOG_ENTRY_SIZE_BYTES];\n    memset(legit_log_data, 0xAA, USER_LOG_ENTRY_SIZE_BYTES);\n    storeVDRDataEntry(VDR_DATA_TYPE_USER_LOGS, 1, legit_log_data, USER_LOG_ENTRY_SIZE_BYTES);\n}\n\n// Helper function to retrieve data for verification (not part of vulnerability)\nuint8_t retrieveVDRDataByte(VDRDataType type, uint16_t entry_index, uint16_t offset_in_entry) {\n    if (type >= VDR_DATA_TYPE_COUNT || entry_index >= g_vdrSegments[type].max_entries || offset_in_entry >= g_vdrSegments[type].entry_size) {\n        return 0x00; // Invalid access or out of bounds for the logical entry\n    }\n    uint16_t global_offset = g_vdrSegments[type].base_offset + (entry_index * g_vdrSegments[type].entry_size) + offset_in_entry;\n    if (global_offset < TOTAL_RECORDER_BUFFER_SIZE) {\n        return g_vdrDataBuffer[global_offset];\n    }\n    return 0x00; // Global buffer access out of bounds\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_SENSORS 8\n#define SENSOR_HISTORY_BUFFER_SIZE 10\n\ntypedef struct {\n    uint16_t sensor_id;\n    int32_t readings[SENSOR_HISTORY_BUFFER_SIZE];\n    uint8_t current_idx;\n    uint8_t count;\n} SensorHistory;\n\nstatic SensorHistory g_sensor_data_history[MAX_SENSORS];\n\nvoid init_sensor_history() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        g_sensor_data_history[i].sensor_id = (uint16_t)-1;\n        memset(g_sensor_data_history[i].readings, 0, sizeof(g_sensor_data_history[i].readings));\n        g_sensor_data_history[i].current_idx = 0;\n        g_sensor_data_history[i].count = 0;\n    }\n}\n\nbool add_sensor_reading_to_history(uint16_t sensor_id, int32_t reading) {\n    int sensor_idx = -1;\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        if (g_sensor_data_history[i].sensor_id == sensor_id || g_sensor_data_history[i].sensor_id == (uint16_t)-1) {\n            sensor_idx = i;\n            if (g_sensor_data_history[i].sensor_id == (uint16_t)-1) {\n                g_sensor_data_history[i].sensor_id = sensor_id;\n            }\n            break;\n        }\n    }\n\n    if (sensor_idx == -1) {\n        return false;\n    }\n\n    SensorHistory* history = &g_sensor_data_history[sensor_idx];\n    history->readings[history->current_idx] = reading;\n    history->current_idx = (history->current_idx + 1) % SENSOR_HISTORY_BUFFER_SIZE;\n    if (history->count < SENSOR_HISTORY_BUFFER_SIZE) {\n        history->count++;\n    }\n    return true;\n}\n\nvoid update_historical_reading_vulnerable(uint16_t sensor_id, int32_t offset_from_current, int32_t new_value) {\n    int sensor_idx = -1;\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        if (g_sensor_data_history[i].sensor_id == sensor_id) {\n            sensor_idx = i;\n            break;\n        }\n    }\n\n    if (sensor_idx == -1) {\n        return;\n    }\n\n    SensorHistory* history = &g_sensor_data_history[sensor_idx];\n\n    if (history->count == 0) {\n        return;\n    }\n\n    int32_t effective_last_idx = (history->current_idx == 0) ? (SENSOR_HISTORY_BUFFER_SIZE - 1) : (history->current_idx - 1);\n\n    int32_t target_raw_idx = effective_last_idx - offset_from_current;\n\n    history->readings[target_raw_idx] = new_value;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n#define SYSTEM_TYPE_ENGINE_VULNERABLE       0\n#define SYSTEM_TYPE_TRANSMISSION_VULNERABLE 1\n#define SYSTEM_TYPE_BRAKES_VULNERABLE       2\n#define MAX_SYSTEM_TYPES_VULNERABLE         3\n\n#define MAX_TESTS_ENGINE_SYS_VULNERABLE        5\n#define MAX_TESTS_TRANSMISSION_SYS_VULNERABLE  8\n#define MAX_TESTS_BRAKES_SYS_VULNERABLE        4\n\ntypedef void (*DiagnosticTestRoutine_Vulnerable)(uint32_t test_param);\n\nvoid diagnosticTestEngine1_vulnerable(uint32_t param) {}\nvoid diagnosticTestEngine2_vulnerable(uint32_t param) {}\nvoid diagnosticTestTrans1_vulnerable(uint32_t param) {}\nvoid diagnosticTestBrakes1_vulnerable(uint32_t param) {}\n\nstatic DiagnosticTestRoutine_Vulnerable g_engineTests_vulnerable[MAX_TESTS_ENGINE_SYS_VULNERABLE];\nstatic DiagnosticTestRoutine_Vulnerable g_transmissionTests_vulnerable[MAX_TESTS_TRANSMISSION_SYS_VULNERABLE];\nstatic DiagnosticTestRoutine_Vulnerable g_brakesTests_vulnerable[MAX_TESTS_BRAKES_SYS_VULNERABLE];\n\ntypedef struct {\n    DiagnosticTestRoutine_Vulnerable* tests_array;\n    uint8_t max_tests;\n} SystemTestInfo_Vulnerable;\n\nstatic SystemTestInfo_Vulnerable g_systemTestInfo_vulnerable[MAX_SYSTEM_TYPES_VULNERABLE];\n\nvoid logDiagnosticSystemError_vulnerable(const char* msg) {}\n\ntypedef struct {\n    uint8_t system_type;\n    uint8_t test_id;\n    uint32_t test_parameter;\n} DiagnosticCommand_Vulnerable;\n\nDiagnosticCommand_Vulnerable receiveDiagnosticCommand_vulnerable() {\n    DiagnosticCommand_Vulnerable cmd;\n    cmd.system_type = SYSTEM_TYPE_BRAKES_VULNERABLE;\n    cmd.test_id = MAX_TESTS_BRAKES_SYS_VULNERABLE;\n    cmd.test_parameter = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeDiagnosticSystem_vulnerable() {\n    g_engineTests_vulnerable[0] = diagnosticTestEngine1_vulnerable;\n    g_engineTests_vulnerable[1] = diagnosticTestEngine2_vulnerable;\n\n    g_transmissionTests_vulnerable[0] = diagnosticTestTrans1_vulnerable;\n\n    g_brakesTests_vulnerable[0] = diagnosticTestBrakes1_vulnerable;\n\n    g_systemTestInfo_vulnerable[SYSTEM_TYPE_ENGINE_VULNERABLE].tests_array = g_engineTests_vulnerable;\n    g_systemTestInfo_vulnerable[SYSTEM_TYPE_ENGINE_VULNERABLE].max_tests = MAX_TESTS_ENGINE_SYS_VULNERABLE;\n\n    g_systemTestInfo_vulnerable[SYSTEM_TYPE_TRANSMISSION_VULNERABLE].tests_array = g_transmissionTests_vulnerable;\n    g_systemTestInfo_vulnerable[SYSTEM_TYPE_TRANSMISSION_VULNERABLE].max_tests = MAX_TESTS_TRANSMISSION_SYS_VULNERABLE;\n\n    g_systemTestInfo_vulnerable[SYSTEM_TYPE_BRAKES_VULNERABLE].tests_array = g_brakesTests_vulnerable;\n    g_systemTestInfo_vulnerable[SYSTEM_TYPE_BRAKES_VULNERABLE].max_tests = MAX_TESTS_BRAKES_SYS_VULNERABLE;\n\n    logDiagnosticSystemError_vulnerable(\"Diagnostic system initialized.\");\n}\n\nvoid executeDiagnosticTest_vulnerable() {\n    DiagnosticCommand_Vulnerable cmd = receiveDiagnosticCommand_vulnerable();\n\n    if (cmd.system_type < MAX_SYSTEM_TYPES_VULNERABLE) {\n        SystemTestInfo_Vulnerable current_sys_info = g_systemTestInfo_vulnerable[cmd.system_type];\n\n        DiagnosticTestRoutine_Vulnerable routine = current_sys_info.tests_array[cmd.test_id];\n\n        if (routine != NULL) {\n            routine(cmd.test_parameter);\n            logDiagnosticSystemError_vulnerable(\"Diagnostic test executed (vulnerable).\");\n        } else {\n            logDiagnosticSystemError_vulnerable(\"Requested diagnostic test routine is NULL.\");\n        }\n    } else {\n        logDiagnosticSystemError_vulnerable(\"Invalid system type in diagnostic command.\");\n    }\n}\n\nvoid diagnosticModuleMain_vulnerable() {\n    initializeDiagnosticSystem_vulnerable();\n    executeDiagnosticTest_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMAND_DATA_PAYLOAD 64 \n#define PROCESSING_BUFFER_SIZE 32   \n\ntypedef struct {\n    uint16_t command_id;\n    uint8_t  payload_len;\n    uint8_t  payload[MAX_COMMAND_DATA_PAYLOAD];\n    uint16_t crc_checksum;\n} VehicleCommand;\n\nstatic uint8_t g_tempProcessingBuffer[PROCESSING_BUFFER_SIZE];\n\nvoid initCommandProcessor() {\n    memset(g_tempProcessingBuffer, 0, PROCESSING_BUFFER_SIZE);\n}\n\nuint16_t calculateCrc(const uint8_t* data, uint8_t len) {\n    uint16_t crc = 0xFFFF;\n    for (uint8_t i = 0; i < len; ++i) {\n        crc ^= data[i];\n        for (int j = 0; j < 8; ++j) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\nint processVehicleCommand(const VehicleCommand* cmd) {\n    if (cmd == NULL) {\n        return -1; \n    }\n\n    if (cmd->payload_len > MAX_COMMAND_DATA_PAYLOAD) {\n        return -2; \n    }\n\n    for (uint8_t i = 0; i < cmd->payload_len; ++i) {\n        g_tempProcessingBuffer[i] = cmd->payload[i];\n    }\n\n    uint16_t calculated_crc = calculateCrc(g_tempProcessingBuffer, cmd->payload_len);\n\n    if (calculated_crc != cmd->crc_checksum) {\n        return -3; \n    }\n\n    return 0; \n}\n\nvoid simulateCommandReception(const VehicleCommand* rx_cmd) {\n    processVehicleCommand(rx_cmd);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_LOG_CAPACITY 64\n\ntypedef struct {\n    uint32_t fault_code;\n    uint32_t timestamp;\n    uint8_t  level; \n    uint8_t  param_count;\n    uint16_t params[2];\n} DiagnosticLogEntry;\n\nstatic DiagnosticLogEntry g_diag_log_buffer[DIAG_LOG_CAPACITY];\nstatic uint16_t g_log_write_idx = 0;\nstatic uint16_t g_num_logged_entries = 0;\n\nvoid init_diag_logger_vulnerable() {\n    memset(g_diag_log_buffer, 0, sizeof(g_diag_log_buffer));\n    g_log_write_idx = 0;\n    g_num_logged_entries = 0;\n}\n\nvoid add_diag_entry_vulnerable(uint32_t code, uint32_t ts, uint8_t level, uint8_t p_count, uint16_t p1, uint16_t p2) {\n    if (g_num_logged_entries < DIAG_LOG_CAPACITY) {\n        g_diag_log_buffer[g_log_write_idx].fault_code = code;\n        g_diag_log_buffer[g_log_write_idx].timestamp = ts;\n        g_diag_log_buffer[g_log_write_idx].level = level;\n        g_diag_log_buffer[g_log_write_idx].param_count = p_count;\n        g_diag_log_buffer[g_log_write_idx].params[0] = p1;\n        g_diag_log_buffer[g_log_write_idx].params[1] = p2;\n        \n        g_log_write_idx = (g_log_write_idx + 1) % DIAG_LOG_CAPACITY;\n        g_num_logged_entries++;\n    } else {\n        g_diag_log_buffer[g_log_write_idx].fault_code = code;\n        g_diag_log_buffer[g_log_write_idx].timestamp = ts;\n        g_diag_log_buffer[g_log_write_idx].level = level;\n        g_diag_log_buffer[g_log_write_idx].param_count = p_count;\n        g_diag_log_buffer[g_log_write_idx].params[0] = p1;\n        g_diag_log_buffer[g_log_write_idx].params[1] = p2;\n        g_log_write_idx = (g_log_write_idx + 1) % DIAG_LOG_CAPACITY;\n    }\n}\n\nvoid clear_recent_diag_level_entries_vulnerable(uint8_t level_to_clear, uint16_t search_depth) {\n    if (g_num_logged_entries == 0 || search_depth == 0) {\n        return;\n    }\n\n    int32_t current_logical_tail_idx;\n    if (g_log_write_idx == 0) {\n        current_logical_tail_idx = DIAG_LOG_CAPACITY - 1;\n    } else {\n        current_logical_tail_idx = g_log_write_idx - 1;\n    }\n\n    for (uint16_t k = 0; k < search_depth; ++k) {\n        int32_t target_idx = current_logical_tail_idx - k;\n\n        if (g_diag_log_buffer[target_idx].level == level_to_clear) {\n            memset(&g_diag_log_buffer[target_idx], 0, sizeof(DiagnosticLogEntry));\n        }\n    }\n}\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n\n#pragma pack(push, 1)\n\nstruct SensorRecordHeader {\n    uint16_t record_id;\n    uint32_t timestamp_ms;\n    uint16_t metadata_len; \n};\n\nstruct SensorDataBatchHeader {\n    uint16_t num_records;\n    uint32_t total_payload_bytes; \n};\n\n#pragma pack(pop)\n\nclass SensorDataProcessor {\npublic:\n    SensorDataProcessor() : m_processed_data_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~SensorDataProcessor() {\n        if (m_processed_data_buffer) {\n            delete[] m_processed_data_buffer;\n            m_processed_data_buffer = nullptr;\n        }\n    }\n\n    bool processSensorBatchVulnerable(const uint8_t* raw_batch_packet, size_t packet_length) {\n        if (!raw_batch_packet || packet_length < sizeof(SensorDataBatchHeader)) {\n            return false;\n        }\n\n        const SensorDataBatchHeader* batch_header = reinterpret_cast<const SensorDataBatchHeader*>(raw_batch_packet);\n\n        if (batch_header->total_payload_bytes > (packet_length - sizeof(SensorDataBatchHeader))) {\n            return false;\n        }\n\n        if (m_processed_data_buffer) {\n            delete[] m_processed_data_buffer;\n            m_processed_data_buffer = nullptr;\n        }\n\n        m_buffer_capacity = batch_header->total_payload_bytes;\n        \n        if (m_buffer_capacity == 0 && batch_header->num_records > 0) {\n             return false;\n        }\n        \n        m_processed_data_buffer = new (std::nothrow) uint8_t[m_buffer_capacity];\n        if (!m_processed_data_buffer && m_buffer_capacity > 0) {\n            return false;\n        }\n\n        size_t current_read_offset_in_packet = sizeof(SensorDataBatchHeader);\n        size_t current_write_offset_in_buffer = 0;\n\n        for (uint16_t i = 0; i < batch_header->num_records; ++i) {\n            if (current_read_offset_in_packet + sizeof(SensorRecordHeader) > packet_length) {\n                return false;\n            }\n\n            const SensorRecordHeader* record_header = reinterpret_cast<const SensorRecordHeader*>(raw_batch_packet + current_read_offset_in_packet);\n            uint16_t current_metadata_len = record_header->metadata_len;\n\n            if (current_read_offset_in_packet + sizeof(SensorRecordHeader) + current_metadata_len > packet_length) {\n                return false;\n            }\n\n            size_t bytes_to_copy_this_record = sizeof(SensorRecordHeader) + current_metadata_len;\n            \n            memcpy(m_processed_data_buffer + current_write_offset_in_buffer, record_header, bytes_to_copy_this_record);\n\n            current_read_offset_in_packet += bytes_to_copy_this_record;\n            current_write_offset_in_buffer += bytes_to_copy_this_record;\n        }\n        \n        if (current_write_offset_in_buffer > m_buffer_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedDataBuffer() const {\n        return m_processed_data_buffer;\n    }\n\n    size_t getBufferCapacity() const {\n        return m_buffer_capacity;\n    }\n\nprivate:\n    uint8_t* m_processed_data_buffer;\n    size_t m_buffer_capacity;\n};\n", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n#define SYSTEM_TYPE_ENGINE_FIXED       0\n#define SYSTEM_TYPE_TRANSMISSION_FIXED 1\n#define SYSTEM_TYPE_BRAKES_FIXED       2\n#define MAX_SYSTEM_TYPES_FIXED         3\n\n#define MAX_TESTS_ENGINE_SYS_FIXED        5\n#define MAX_TESTS_TRANSMISSION_SYS_FIXED  8\n#define MAX_TESTS_BRAKES_SYS_FIXED        4\n\ntypedef void (*DiagnosticTestRoutine_Fixed)(uint32_t test_param);\n\nvoid diagnosticTestEngine1_fixed(uint32_t param) {}\nvoid diagnosticTestEngine2_fixed(uint32_t param) {}\nvoid diagnosticTestTrans1_fixed(uint32_t param) {}\nvoid diagnosticTestBrakes1_fixed(uint32_t param) {}\n\nstatic DiagnosticTestRoutine_Fixed g_engineTests_fixed[MAX_TESTS_ENGINE_SYS_FIXED];\nstatic DiagnosticTestRoutine_Fixed g_transmissionTests_fixed[MAX_TESTS_TRANSMISSION_SYS_FIXED];\nstatic DiagnosticTestRoutine_Fixed g_brakesTests_fixed[MAX_TESTS_BRAKES_SYS_FIXED];\n\ntypedef struct {\n    DiagnosticTestRoutine_Fixed* tests_array;\n    uint8_t max_tests;\n} SystemTestInfo_Fixed;\n\nstatic SystemTestInfo_Fixed g_systemTestInfo_fixed[MAX_SYSTEM_TYPES_FIXED];\n\nvoid logDiagnosticSystemError_fixed(const char* msg) {}\n\ntypedef struct {\n    uint8_t system_type;\n    uint8_t test_id;\n    uint32_t test_parameter;\n} DiagnosticCommand_Fixed;\n\nDiagnosticCommand_Fixed receiveDiagnosticCommand_fixed() {\n    DiagnosticCommand_Fixed cmd;\n    cmd.system_type = SYSTEM_TYPE_BRAKES_FIXED;\n    cmd.test_id = MAX_TESTS_BRAKES_SYS_FIXED;\n    cmd.test_parameter = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeDiagnosticSystem_fixed() {\n    g_engineTests_fixed[0] = diagnosticTestEngine1_fixed;\n    g_engineTests_fixed[1] = diagnosticTestEngine2_fixed;\n\n    g_transmissionTests_fixed[0] = diagnosticTestTrans1_fixed;\n\n    g_brakesTests_fixed[0] = diagnosticTestBrakes1_fixed;\n\n    g_systemTestInfo_fixed[SYSTEM_TYPE_ENGINE_FIXED].tests_array = g_engineTests_fixed;\n    g_systemTestInfo_fixed[SYSTEM_TYPE_ENGINE_FIXED].max_tests = MAX_TESTS_ENGINE_SYS_FIXED;\n\n    g_systemTestInfo_fixed[SYSTEM_TYPE_TRANSMISSION_FIXED].tests_array = g_transmissionTests_fixed;\n    g_systemTestInfo_fixed[SYSTEM_TYPE_TRANSMISSION_FIXED].max_tests = MAX_TESTS_TRANSMISSION_SYS_FIXED;\n\n    g_systemTestInfo_fixed[SYSTEM_TYPE_BRAKES_FIXED].tests_array = g_brakesTests_fixed;\n    g_systemTestInfo_fixed[SYSTEM_TYPE_BRAKES_FIXED].max_tests = MAX_TESTS_BRAKES_SYS_FIXED;\n\n    logDiagnosticSystemError_fixed(\"Diagnostic system initialized (fixed).\");\n}\n\nvoid executeDiagnosticTest_fixed() {\n    DiagnosticCommand_Fixed cmd = receiveDiagnosticCommand_fixed();\n\n    if (cmd.system_type < MAX_SYSTEM_TYPES_FIXED) {\n        SystemTestInfo_Fixed current_sys_info = g_systemTestInfo_fixed[cmd.system_type];\n\n        if (cmd.test_id < current_sys_info.max_tests) {\n            DiagnosticTestRoutine_Fixed routine = current_sys_info.tests_array[cmd.test_id];\n\n            if (routine != NULL) {\n                routine(cmd.test_parameter);\n                logDiagnosticSystemError_fixed(\"Diagnostic test executed (fixed).\");\n            } else {\n                logDiagnosticSystemError_fixed(\"Requested diagnostic test routine is NULL for valid index.\");\n            }\n        } else {\n            logDiagnosticSystemError_fixed(\"Requested test ID out of bounds for the selected system type (fixed).\");\n        }\n    } else {\n        logDiagnosticSystemError_fixed(\"Invalid system type in diagnostic command (fixed).\");\n    }\n}\n\nvoid diagnosticModuleMain_fixed() {\n    initializeDiagnosticSystem_fixed();\n    executeDiagnosticTest_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_COMPONENTS_FIXED 10\n#define MAX_ERROR_CODES_PER_COMPONENT_FIXED 20\n#define MAX_DTC_SEVERITY_LEVELS_FIXED 3\n\ntypedef struct {\n    uint32_t handler_id;\n    uint8_t  alert_level;\n    bool     triggers_limp_mode;\n} SeverityHandlerConfig_Fixed;\n\nstatic SeverityHandlerConfig_Fixed g_severityHandlers_Fixed[MAX_DTC_SEVERITY_LEVELS_FIXED];\n\ntypedef struct {\n    uint16_t code_value;\n    uint32_t timestamp;\n    uint8_t  severity_raw;\n    bool     active;\n} ComponentDTCLogEntry_Fixed;\n\nstatic ComponentDTCLogEntry_Fixed g_engineDTCLog_Fixed[MAX_ERROR_CODES_PER_COMPONENT_FIXED];\n\nvoid automotiveLogger_fixed(const char* message) {\n}\n\nComponentDTCLogEntry_Fixed getNewDTCReport_fixed() {\n    ComponentDTCLogEntry_Fixed report;\n    report.code_value = 0x01A2;\n    report.timestamp = 0xABCDEFFF;\n    report.severity_raw = 3;\n    report.active = true;\n    return report;\n}\n\nvoid initializeDiagnosticSystem_fixed() {\n    g_severityHandlers_Fixed[0] = (SeverityHandlerConfig_Fixed){0x1000, 1, false};\n    g_severityHandlers_Fixed[1] = (SeverityHandlerConfig_Fixed){0x2000, 5, false};\n    g_severityHandlers_Fixed[2] = (SeverityHandlerConfig_Fixed){0x3000, 10, true};\n\n    for (uint8_t i = 0; i < MAX_ERROR_CODES_PER_COMPONENT_FIXED; ++i) {\n        g_engineDTCLog_Fixed[i] = (ComponentDTCLogEntry_Fixed){0, 0, 0, false};\n    }\n    automotiveLogger_fixed(\"Diagnostic system initialized (fixed).\");\n}\n\nvoid processNewDTCReport_fixed(ComponentDTCLogEntry_Fixed new_dtc) {\n    uint8_t log_idx = new_dtc.code_value % MAX_ERROR_CODES_PER_COMPONENT_FIXED;\n\n    g_engineDTCLog_Fixed[log_idx] = new_dtc;\n\n    automotiveLogger_fixed(\"DTC processed. Attempting to apply handler config (fixed).\");\n\n    if (new_dtc.severity_raw < MAX_DTC_SEVERITY_LEVELS_FIXED) {\n        SeverityHandlerConfig_Fixed current_handler_config = g_severityHandlers_Fixed[new_dtc.severity_raw];\n        if (current_handler_config.triggers_limp_mode) {\n            automotiveLogger_fixed(\"Limp mode triggered by DTC (fixed).\");\n        } else {\n            automotiveLogger_fixed(\"DTC handler applied without limp mode (fixed).\");\n        }\n    } else {\n        automotiveLogger_fixed(\"Invalid severity level received for DTC. Ignoring handler application (fixed).\");\n    }\n}\n\nvoid diagnosticServiceMain_fixed() {\n    initializeDiagnosticSystem_fixed();\n    ComponentDTCLogEntry_Fixed report = getNewDTCReport_fixed();\n    processNewDTCReport_fixed(report);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CONFIG_AREA_SIZE 256\n#define ECU_MAX_PARAM_VALUE 0xFF\n\nstatic uint8_t g_ecu_config_area[CONFIG_AREA_SIZE];\n\ntypedef struct {\n    uint16_t param_id;\n    uint16_t base_offset;\n    uint8_t size;\n    int16_t lock_byte_offset;\n} ConfigParamMetadata;\n\nstatic const ConfigParamMetadata g_param_mapping[] = {\n    {0x0001, 0, 4, -1},\n    {0x0002, 4, 2, -3},\n    {0x0003, 6, 8, -7},\n    {0x0004, 14, 1, 0},\n    {0x0005, 15, 16, 17}\n};\n#define NUM_PARAM_MAPPINGS (sizeof(g_param_mapping) / sizeof(g_param_mapping[0]))\n\nvoid init_ecu_config_area() {\n    memset(g_ecu_config_area, ECU_MAX_PARAM_VALUE, CONFIG_AREA_SIZE);\n}\n\nbool get_config_parameter(uint16_t param_id, uint8_t* buffer, uint32_t buffer_len) {\n    for (int i = 0; i < NUM_PARAM_MAPPINGS; ++i) {\n        if (g_param_mapping[i].param_id == param_id) {\n            const ConfigParamMetadata* meta = &g_param_mapping[i];\n            if (buffer_len < meta->size || meta->base_offset + meta->size > CONFIG_AREA_SIZE) {\n                return false;\n            }\n            memcpy(buffer, g_ecu_config_area + meta->base_offset, meta->size);\n            return true;\n        }\n    }\n    return false;\n}\n\nbool update_config_parameter_vulnerable(uint16_t param_id, const uint8_t* new_data, uint32_t data_len) {\n    const ConfigParamMetadata* meta = NULL;\n    for (int i = 0; i < NUM_PARAM_MAPPINGS; ++i) {\n        if (g_param_mapping[i].param_id == param_id) {\n            meta = &g_param_mapping[i];\n            break;\n        }\n    }\n\n    if (meta == NULL) {\n        return false;\n    }\n\n    if (data_len != meta->size) {\n        return false;\n    }\n\n    if (meta->base_offset + meta->size > CONFIG_AREA_SIZE) {\n        return false;\n    }\n\n    int32_t lock_byte_absolute_offset = (int32_t)meta->base_offset + meta->lock_byte_offset;\n\n    g_ecu_config_area[lock_byte_absolute_offset] = 0xAA;\n\n    memcpy(g_ecu_config_area + meta->base_offset, new_data, data_len);\n\n    return true;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stbool.h>\n#include <string.h>\n\n#define MAX_FAULT_HISTORY_ENTRIES 32\n#define FAULT_DATA_SIZE 8\n\ntypedef struct {\n    uint32_t fault_code;\n    uint32_t timestamp;\n    uint8_t  data[FAULT_DATA_SIZE];\n    uint8_t  status_flags; \n} FaultHistoryEntry;\n\nstatic FaultHistoryEntry g_fault_history_fixed[MAX_FAULT_HISTORY_ENTRIES];\nstatic uint16_t g_current_history_idx_fixed = 0; \nstatic uint16_t g_num_active_faults_fixed = 0; \n\nvoid init_fault_history_fixed() {\n    memset(g_fault_history_fixed, 0, sizeof(g_fault_history_fixed));\n    g_current_history_idx_fixed = 0;\n    g_num_active_faults_fixed = 0;\n}\n\nvoid log_fault_event_fixed(uint32_t code, uint32_t timestamp, const uint8_t* data) {\n    if (g_num_active_faults_fixed < MAX_FAULT_HISTORY_ENTRIES) {\n        g_num_active_faults_fixed++;\n    }\n\n    FaultHistoryEntry* entry = &g_fault_history_fixed[g_current_history_idx_fixed];\n    entry->fault_code = code;\n    entry->timestamp = timestamp;\n    memcpy(entry->data, data, FAULT_DATA_SIZE);\n    entry->status_flags = 0x01; \n\n    g_current_history_idx_fixed = (g_current_history_idx_fixed + 1) % MAX_FAULT_HISTORY_ENTRIES;\n}\n\nvoid reactivate_cleared_faults_fixed(uint16_t num_to_reactivate) {\n    if (num_to_reactivate == 0 || g_num_active_faults_fixed == 0) {\n        return;\n    }\n\n    uint16_t effective_to_reactivate = (num_to_reactivate > g_num_active_faults_fixed) ? g_num_active_faults_fixed : num_to_reactivate;\n\n    int16_t start_reactivate_idx = (g_current_history_idx_fixed == 0) ? \n                                   (MAX_FAULT_HISTORY_ENTRIES - 1) : \n                                   (g_current_history_idx_fixed - 1);\n\n    for (uint16_t i = 0; i < effective_to_reactivate; ++i) {\n        int32_t conceptual_idx = start_reactivate_idx - i;\n        uint16_t target_idx = (uint16_t)(((conceptual_idx % MAX_FAULT_HISTORY_ENTRIES) + MAX_FAULT_HISTORY_ENTRIES) % MAX_FAULT_HISTORY_ENTRIES);\n        \n        g_fault_history_fixed[target_idx].status_flags = 0x01;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define FIRMWARE_STAGING_BUFFER_SIZE 2048 \n#define MAX_FW_PACKAGE_SIZE 4096 \n#define MAX_FW_BLOCKS 16 \n\ntypedef struct {\n    uint16_t block_id;\n    uint16_t block_offset; \n    uint16_t block_length;\n} FirmwareBlockDescriptor;\n\ntypedef struct {\n    uint16_t total_data_length; \n    uint8_t num_blocks;\n} FirmwarePackageHeader;\n\nstatic uint8_t g_firmwareStagingBuffer[FIRMWARE_STAGING_BUFFER_SIZE];\nstatic uint16_t g_stagingWritePointer = 0; \n\nvoid initFirmwareStagingSystem() {\n    memset(g_firmwareStagingBuffer, 0, FIRMWARE_STAGING_BUFFER_SIZE);\n    g_stagingWritePointer = 0;\n}\n\nint processFirmwareUpdatePackage(const uint8_t* package_payload, uint16_t payload_len) {\n    if (package_payload == NULL || payload_len < sizeof(FirmwarePackageHeader)) {\n        return -1; \n    }\n\n    FirmwarePackageHeader header;\n    header.total_data_length = (uint16_t)(package_payload[0] << 8 | package_payload[1]);\n    header.num_blocks = package_payload[2];\n\n    if (payload_len < sizeof(FirmwarePackageHeader) + (header.num_blocks * sizeof(FirmwareBlockDescriptor))) {\n        return -2; \n    }\n    if (header.num_blocks > MAX_FW_BLOCKS) {\n        return -3; \n    }\n\n    uint16_t descriptor_offset = sizeof(FirmwarePackageHeader);\n    uint16_t data_offset = descriptor_offset + (header.num_blocks * sizeof(FirmwareBlockDescriptor));\n\n    if (data_offset + header.total_data_length > payload_len) {\n        return -4; \n    }\n\n    g_stagingWritePointer = 0; \n\n    for (uint8_t i = 0; i < header.num_blocks; ++i) {\n        uint16_t current_descriptor_pos = descriptor_offset + (i * sizeof(FirmwareBlockDescriptor));\n        if (current_descriptor_pos + sizeof(FirmwareBlockDescriptor) > payload_len) {\n            return -5; \n        }\n\n        FirmwareBlockDescriptor block_desc;\n        block_desc.block_id = (uint16_t)(package_payload[current_descriptor_pos] << 8 | package_payload[current_descriptor_pos + 1]);\n        block_desc.block_offset = (uint16_t)(package_payload[current_descriptor_pos + 2] << 8 | package_payload[current_descriptor_pos + 3]);\n        block_desc.block_length = (uint16_t)(package_payload[current_descriptor_pos + 4] << 8 | package_payload[current_descriptor_pos + 5]);\n\n        if (block_desc.block_offset + block_desc.block_length > header.total_data_length) {\n            return -6; \n        }\n        if (data_offset + block_desc.block_offset + block_desc.block_length > payload_len) {\n            return -7; \n        }\n\n        for (uint16_t j = 0; j < block_desc.block_length; ++j) {\n            g_firmwareStagingBuffer[g_stagingWritePointer] = package_payload[data_offset + block_desc.block_offset + j];\n            g_stagingWritePointer++;\n        }\n    }\n\n    return 0; \n}\n\nvoid receiveFirmwarePackage(const uint8_t* data, uint16_t length) {\n    initFirmwareStagingSystem();\n    processFirmwareUpdatePackage(data, length);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_CHASSIS_PROFILES 5\n\ntypedef struct {\n    float damping_ratio;\n    float steering_response;\n    uint16_t throttle_map_id;\n    bool traction_control_active;\n} ChassisProfile_vulnerable;\n\ntypedef struct {\n    uint8_t slipperiness_index; \n    uint8_t roughness_index;    \n} SensorInput_vulnerable;\n\ntypedef struct {\n    int8_t profile_adjustment_offset;\n} DriverPreferenceInput_vulnerable;\n\nstatic ChassisProfile_vulnerable g_chassisProfiles_vulnerable[MAX_CHASSIS_PROFILES];\n\nvoid logChassisControlError_vulnerable(const char* msg) {\n}\n\nSensorInput_vulnerable getSimulatedSensorInput_vulnerable() {\n    SensorInput_vulnerable input;\n    input.slipperiness_index = 30;\n    input.roughness_index = 20;\n    return input;\n}\n\nDriverPreferenceInput_vulnerable getSimulatedDriverPreference_vulnerable() {\n    DriverPreferenceInput_vulnerable pref;\n    pref.profile_adjustment_offset = 5; \n    return pref;\n}\n\nvoid initializeChassisProfiles_vulnerable() {\n    for (int i = 0; i < MAX_CHASSIS_PROFILES; ++i) {\n        g_chassisProfiles_vulnerable[i].damping_ratio = 0.5f + (float)i * 0.1f;\n        g_chassisProfiles_vulnerable[i].steering_response = 0.3f + (float)i * 0.05f;\n        g_chassisProfiles_vulnerable[i].throttle_map_id = 100 + i;\n        g_chassisProfiles_vulnerable[i].traction_control_active = true;\n    }\n}\n\nvoid applyChassisSettings_vulnerable(const ChassisProfile_vulnerable* profile) {\n}\n\nvoid updateChassisControl_vulnerable() {\n    SensorInput_vulnerable sensor_data = getSimulatedSensorInput_vulnerable();\n    DriverPreferenceInput_vulnerable driver_data = getSimulatedDriverPreference_vulnerable();\n\n    int base_mode_index;\n    int averaged_sensor_value = (sensor_data.slipperiness_index + sensor_data.roughness_index) / 2;\n\n    if (averaged_sensor_value < 33) {\n        base_mode_index = 0;\n    } else if (averaged_sensor_value < 67) {\n        base_mode_index = 1;\n    } else {\n        base_mode_index = 2;\n    }\n\n    int final_profile_index = base_mode_index + driver_data.profile_adjustment_offset;\n\n    if (final_profile_index >= 0) {\n        applyChassisSettings_vulnerable(&g_chassisProfiles_vulnerable[final_profile_index]);\n    } else {\n        logChassisControlError_vulnerable(\"Calculated profile index is negative. Using default.\");\n        applyChassisSettings_vulnerable(&g_chassisProfiles_vulnerable[0]);\n    }\n}\n\nvoid chassisControlMain_vulnerable() {\n    initializeChassisProfiles_vulnerable();\n    updateChassisControl_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define REASSEMBLY_BUFFER_SIZE 256\n#define MAX_FRAGMENT_PAYLOAD_SIZE 64\n#define FRAGMENT_HEADER_SIZE 6\n\ntypedef struct {\n    uint16_t fragment_id;\n    uint16_t offset;\n    uint16_t length;\n} FragmentHeader;\n\nstatic uint8_t g_reassemblyBuffer[REASSEMBLY_BUFFER_SIZE];\nstatic uint16_t g_reassembledLength = 0;\n\nvoid initReassemblyBuffer() {\n    memset(g_reassemblyBuffer, 0, REASSEMBLY_BUFFER_SIZE);\n    g_reassembledLength = 0;\n}\n\nint processDataFragment(const uint8_t* raw_fragment_data, uint16_t raw_fragment_len) {\n    if (raw_fragment_data == NULL || raw_fragment_len < FRAGMENT_HEADER_SIZE) {\n        return -1;\n    }\n\n    FragmentHeader header;\n    header.fragment_id = (raw_fragment_data[0] << 8) | raw_fragment_data[1];\n    header.offset      = (raw_fragment_data[2] << 8) | raw_fragment_data[3];\n    header.length      = (raw_fragment_data[4] << 8) | raw_fragment_data[5];\n\n    if (FRAGMENT_HEADER_SIZE + header.length > raw_fragment_len) {\n        return -2;\n    }\n\n    if (header.length > MAX_FRAGMENT_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    if (header.offset >= REASSEMBLY_BUFFER_SIZE || (header.length > 0 && header.offset + header.length > REASSEMBLY_BUFFER_SIZE)) {\n        return -4;\n    }\n\n    for (uint16_t i = 0; i < header.length; ++i) {\n        g_reassemblyBuffer[header.offset + i] = raw_fragment_data[FRAGMENT_HEADER_SIZE + i];\n    }\n\n    if (header.offset + header.length > g_reassembledLength) {\n        g_reassembledLength = header.offset + header.length;\n    }\n\n    return 0;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_DTC_ENTRIES_PER_PRIORITY_LEVEL 10\n\ntypedef enum {\n    DIAG_SEVERITY_UNKNOWN = 0,\n    DIAG_SEVERITY_LOW = 1,\n    DIAG_SEVERITY_MEDIUM = 2,\n    DIAG_SEVERITY_HIGH = 3,\n    _DIAG_SEVERITY_COUNT_FIXED \n} DiagnosticSeverity_Fixed;\n\n#define NUM_PRIORITY_LEVELS_FIXED 4\n\ntypedef struct {\n    uint16_t dtc_code;\n    uint32_t timestamp;\n    uint8_t current_status;\n} DTC_Record_Fixed;\n\nstatic DTC_Record_Fixed g_dtcRecords_fixed[NUM_PRIORITY_LEVELS_FIXED][MAX_DTC_ENTRIES_PER_PRIORITY_LEVEL];\nstatic uint8_t g_dtcCounts_fixed[NUM_PRIORITY_LEVELS_FIXED];\n\nvoid logECU_fixed(const char* msg) {\n    fprintf(stderr, \"FIXED_LOG: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint16_t id;\n    DiagnosticSeverity_Fixed severity_raw;\n    uint32_t data;\n} IncomingDiagnosticMessage_Fixed;\n\nIncomingDiagnosticMessage_Fixed receiveDiagnosticMessage_fixed() {\n    IncomingDiagnosticMessage_Fixed msg;\n    msg.id = 0xDEAD;\n    msg.severity_raw = (DiagnosticSeverity_Fixed)_DIAG_SEVERITY_COUNT_FIXED;\n    msg.data = 0xCAFEBABE;\n    return msg;\n}\n\nvoid processDiagnosticMessage_fixed() {\n    IncomingDiagnosticMessage_Fixed msg = receiveDiagnosticMessage_fixed();\n\n    if (msg.severity_raw >= DIAG_SEVERITY_UNKNOWN && msg.severity_raw < NUM_PRIORITY_LEVELS_FIXED) {\n        DiagnosticSeverity_Fixed effective_severity_idx = msg.severity_raw;\n\n        if (g_dtcCounts_fixed[effective_severity_idx] < MAX_DTC_ENTRIES_PER_PRIORITY_LEVEL) {\n            DTC_Record_Fixed new_record;\n            new_record.dtc_code = msg.id;\n            new_record.timestamp = msg.data;\n            new_record.current_status = 1;\n\n            g_dtcRecords_fixed[effective_severity_idx][g_dtcCounts_fixed[effective_severity_idx]] = new_record;\n            g_dtcCounts_fixed[effective_severity_idx]++;\n            logECU_fixed(\"DTC record added based on severity.\");\n        } else {\n            logECU_fixed(\"DTC storage full for this severity level.\");\n        }\n    } else {\n        logECU_fixed(\"Invalid diagnostic severity value received. Ignoring message.\");\n    }\n}\n\nvoid diagnosticSubsystemInit_fixed() {\n    for (int i = 0; i < NUM_PRIORITY_LEVELS_FIXED; ++i) {\n        g_dtcCounts_fixed[i] = 0;\n        for (int j = 0; j < MAX_DTC_ENTRIES_PER_PRIORITY_LEVEL; ++j) {\n            g_dtcRecords_fixed[i][j] = (DTC_Record_Fixed){0, 0, 0};\n        }\n    }\n    logECU_fixed(\"Diagnostic subsystem initialized (fixed).\");\n}\n\nvoid runECUDiagnostics_fixed() {\n    diagnosticSubsystemInit_fixed();\n    processDiagnosticMessage_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define PARAM_NAME_MAX_LEN          16\n#define PARAM_VALUE_BUFFER_SIZE     32\n\n#define PROTOCOL_MAX_VALUE_LEN      60\n\ntypedef enum {\n    PARAM_TYPE_UINT8,\n    PARAM_TYPE_UINT16,\n    PARAM_TYPE_STRING,\n    PARAM_TYPE_BYTE_ARRAY\n} ParameterType;\n\ntypedef struct {\n    char name[PARAM_NAME_MAX_LEN];\n    ParameterType type;\n    uint8_t value_len;\n    union {\n        uint8_t  u8_val;\n        uint16_t u16_val;\n        char     str_val[PARAM_VALUE_BUFFER_SIZE];\n        uint8_t  byte_array_val[PARAM_VALUE_BUFFER_SIZE];\n    } value;\n} VehicleParameter;\n\nstatic uint8_t g_message_rx_buffer[256];\n\nstatic uint8_t get_byte_from_stream(const uint8_t* stream_data, uint32_t* offset, uint32_t total_length) {\n    if (stream_data == NULL || *offset >= total_length) {\n        return 0;\n    }\n    return stream_data[(*offset)++];\n}\n\nint parseVehicleParameter(const uint8_t* raw_message_stream, uint32_t stream_total_len, VehicleParameter* param_out) {\n    uint32_t current_stream_pos = 0;\n\n    if (raw_message_stream == NULL || param_out == NULL || stream_total_len < (1 + 1 + 1)) {\n        return -1;\n    }\n\n    memset(param_out, 0, sizeof(VehicleParameter));\n\n    if (current_stream_pos + 1 > stream_total_len) return -2;\n    uint8_t name_len = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n    \n    if (name_len == 0 || name_len >= PARAM_NAME_MAX_LEN) {\n        return -3;\n    }\n\n    if (current_stream_pos + name_len > stream_total_len) {\n        return -4;\n    }\n    for (int i = 0; i < name_len; ++i) {\n        param_out->name[i] = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n    }\n    param_out->name[name_len] = '\\0';\n\n    if (current_stream_pos + 1 > stream_total_len) return -5;\n    param_out->type = (ParameterType)get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n\n    switch (param_out->type) {\n        case PARAM_TYPE_UINT8:\n            if (current_stream_pos + sizeof(uint8_t) > stream_total_len) return -6;\n            param_out->value.u8_val = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n            param_out->value_len = sizeof(uint8_t);\n            break;\n        case PARAM_TYPE_UINT16:\n            if (current_stream_pos + sizeof(uint16_t) > stream_total_len) return -6;\n            param_out->value.u16_val = (uint16_t)((get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len) << 8) |\n                                                   get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len));\n            param_out->value_len = sizeof(uint16_t);\n            break;\n        case PARAM_TYPE_STRING:\n        case PARAM_TYPE_BYTE_ARRAY:\n            if (current_stream_pos + 1 > stream_total_len) return -6;\n            uint8_t declared_value_len = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n            \n            if (declared_value_len > PROTOCOL_MAX_VALUE_LEN) {\n                return -7;\n            }\n            \n            if (current_stream_pos + declared_value_len > stream_total_len) {\n                return -8;\n            }\n\n            uint8_t bytes_to_copy = declared_value_len;\n            if (bytes_to_copy > PARAM_VALUE_BUFFER_SIZE) {\n                bytes_to_copy = PARAM_VALUE_BUFFER_SIZE;\n            }\n            param_out->value_len = bytes_to_copy;\n\n            for (int i = 0; i < bytes_to_copy; ++i) {\n                if (param_out->type == PARAM_TYPE_STRING) {\n                    param_out->value.str_val[i] = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n                } else {\n                    param_out->value.byte_array_val[i] = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n                }\n            }\n            for (int i = bytes_to_copy; i < declared_value_len; ++i) {\n                get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n            }\n\n            if (param_out->type == PARAM_TYPE_STRING) {\n                if (bytes_to_copy < PARAM_VALUE_BUFFER_SIZE) {\n                    param_out->value.str_val[bytes_to_copy] = '\\0';\n                } else {\n                    param_out->value.str_val[PARAM_VALUE_BUFFER_SIZE - 1] = '\\0';\n                    param_out->value_len = PARAM_VALUE_BUFFER_SIZE - 1;\n                }\n            }\n            break;\n        default:\n            return -9;\n    }\n\n    return current_stream_pos;\n}\n\nvoid simulateConfigUpdate() {\n    uint8_t malicious_message_data[51];\n    memset(malicious_message_data, 0, sizeof(malicious_message_data));\n\n    uint32_t offset = 0;\n    malicious_message_data[offset++] = strlen(\"SensorSetting\");\n    memcpy(malicious_message_data + offset, \"SensorSetting\", strlen(\"SensorSetting\"));\n    offset += strlen(\"SensorSetting\");\n    malicious_message_data[offset++] = PARAM_TYPE_STRING;\n    malicious_message_data[offset++] = 35;\n    for (int i = 0; i < 35; ++i) {\n        malicious_message_data[offset++] = 'A';\n    }\n\n    VehicleParameter param;\n    (void)parseVehicleParameter(malicious_message_data, sizeof(malicious_message_data), &param);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define LOG_BUFFER_SIZE 512\n#define SENSOR_READING_SIZE 2\n\nstatic uint8_t g_sensorLogBuffer[LOG_BUFFER_SIZE];\nstatic uint16_t g_logWriteCursor = 0;\n\nvoid initSensorLogger() {\n    memset(g_sensorLogBuffer, 0, LOG_BUFFER_SIZE);\n    g_logWriteCursor = 0;\n}\n\nint processSensorDataPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len < 3) {\n        return -1;\n    }\n\n    uint16_t current_packet_read_offset = 0;\n    uint8_t sensor_id = packet[current_packet_read_offset++];\n    uint16_t num_readings = (packet[current_packet_read_offset] << 8) | packet[current_packet_read_offset+1];\n    current_packet_read_offset += 2;\n\n    if (num_readings == 0) {\n        return 0;\n    }\n\n    if (num_readings > (UINT16_MAX / SENSOR_READING_SIZE)) {\n        return -5;\n    }\n\n    uint16_t data_bytes_len = num_readings * SENSOR_READING_SIZE;\n\n    if (current_packet_read_offset + data_bytes_len > packet_len) {\n        return -3;\n    }\n\n    uint16_t header_size = 1 + 2;\n    uint16_t total_entry_size = header_size + data_bytes_len;\n\n    if (g_logWriteCursor + total_entry_size > LOG_BUFFER_SIZE) {\n        g_logWriteCursor = 0;\n        if (total_entry_size > LOG_BUFFER_SIZE) {\n            return -4;\n        }\n    }\n\n    g_sensorLogBuffer[g_logWriteCursor++] = sensor_id;\n    g_sensorLogBuffer[g_logWriteCursor++] = (uint8_t)(num_readings >> 8);\n    g_sensorLogBuffer[g_logWriteCursor++] = (uint8_t)(num_readings & 0xFF);\n\n    for (uint16_t i = 0; i < num_readings; ++i) {\n        uint16_t source_reading_offset = current_packet_read_offset + (i * SENSOR_READING_SIZE);\n        uint16_t dest_reading_offset = g_logWriteCursor + (i * SENSOR_READING_SIZE);\n\n        if (dest_reading_offset + SENSOR_READING_SIZE > LOG_BUFFER_SIZE) {\n            break;\n        }\n\n        g_sensorLogBuffer[dest_reading_offset] = packet[source_reading_offset];\n        g_sensorLogBuffer[dest_reading_offset + 1] = packet[source_reading_offset + 1];\n    }\n\n    g_logWriteCursor = (g_logWriteCursor + total_entry_size) % LOG_BUFFER_SIZE;\n\n    return 0;\n}\n\nvoid receiveSensorUpdate(const uint8_t* raw_data, uint16_t length) {\n    processSensorDataPacket(raw_data, length);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define NUM_ECU_TYPES 3\n#define MAX_ROUTINES_PER_ECU_TYPE 10\n\ntypedef void (*DiagnosticRoutine_t)(uint32_t);\n\nstatic const uint8_t g_numRoutinesPerEcuType_fixed[NUM_ECU_TYPES] = {\n    5, \n    8, \n    3  \n};\n\nstatic DiagnosticRoutine_t g_diagnosticRoutines_fixed[NUM_ECU_TYPES][MAX_ROUTINES_PER_ECU_TYPE];\n\ntypedef struct {\n    uint8_t ecu_type_id;\n    uint8_t routine_index;\n    uint32_t routine_param;\n} DiagnosticCommand_fixed;\n\nvoid logDiagnosticEvent_fixed(const char* msg) {\n}\n\nvoid simulatedDiagnosticRoutine_fixed(uint32_t param) {\n    (void)param;\n    logDiagnosticEvent_fixed(\"Simulated diagnostic routine executed.\");\n}\n\nDiagnosticCommand_fixed receiveDiagnosticCommand_fixed() {\n    DiagnosticCommand_fixed cmd;\n    cmd.ecu_type_id = 2; \n    cmd.routine_index = 4; \n    cmd.routine_param = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeDiagnosticSystem_fixed() {\n    for (uint8_t i = 0; i < NUM_ECU_TYPES; ++i) {\n        for (uint8_t j = 0; j < MAX_ROUTINES_PER_ECU_TYPE; ++j) {\n            g_diagnosticRoutines_fixed[i][j] = NULL;\n        }\n        for (uint8_t j = 0; j < g_numRoutinesPerEcuType_fixed[i]; ++j) {\n            g_diagnosticRoutines_fixed[i][j] = simulatedDiagnosticRoutine_fixed;\n        }\n    }\n    logDiagnosticEvent_fixed(\"Diagnostic system initialized (fixed).\");\n}\n\nvoid executeDiagnosticCommand_fixed() {\n    DiagnosticCommand_fixed cmd = receiveDiagnosticCommand_fixed();\n\n    if (cmd.ecu_type_id < NUM_ECU_TYPES) {\n        if (cmd.routine_index < g_numRoutinesPerEcuType_fixed[cmd.ecu_type_id]) { \n            if (g_diagnosticRoutines_fixed[cmd.ecu_type_id][cmd.routine_index] != NULL) {\n                g_diagnosticRoutines_fixed[cmd.ecu_type_id][cmd.routine_index](cmd.routine_param);\n            } else {\n                logDiagnosticEvent_fixed(\"Requested routine is NULL for this index. (Internal config error)\");\n            }\n        } else {\n            logDiagnosticEvent_fixed(\"Routine index out of bounds for specified ECU type.\");\n        }\n    } else {\n        logDiagnosticEvent_fixed(\"Invalid ECU type ID.\");\n    }\n}\n\nvoid diagnosticManagerMain_fixed() {\n    initializeDiagnosticSystem_fixed();\n    executeDiagnosticCommand_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_REPORT_PAYLOAD_SIZE 128\n#define DIAG_DATA_BUFFER_SIZE 64\n#define MAX_DIAG_DATA_ID_ENTRIES 5\n\ntypedef struct {\n    uint16_t id;\n    uint8_t  data[DIAG_DATA_BUFFER_SIZE];\n    uint8_t  current_len;\n} DiagnosticDataEntry;\n\nstatic DiagnosticDataEntry g_diagDataStore[MAX_DIAG_DATA_ID_ENTRIES];\nstatic uint8_t g_diagDataCount = 0;\n\nvoid initDiagnosticDataStore() {\n    memset(g_diagDataStore, 0, sizeof(g_diagDataStore));\n}\n\nint processDiagnosticReport(uint16_t report_id, const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len == 0 || payload_len > MAX_REPORT_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    if (report_id == 0x10) {\n        if (payload_len < (1 + 2 + 1)) {\n            return -2;\n        }\n\n        uint8_t entry_index = payload[0];\n        uint16_t data_id = (payload[1] << 8) | payload[2];\n        uint8_t data_len = payload[3];\n\n        if (entry_index >= MAX_DIAG_DATA_ID_ENTRIES) {\n            return -3;\n        }\n\n        if (data_len > (payload_len - (1 + 2 + 1))) {\n            return -4;\n        }\n\n        int found_idx = -1;\n        for (int i = 0; i < g_diagDataCount; ++i) {\n            if (g_diagDataStore[i].id == data_id) {\n                found_idx = i;\n                break;\n            }\n        }\n\n        if (found_idx == -1) {\n            if (g_diagDataCount < MAX_DIAG_DATA_ID_ENTRIES) {\n                found_idx = g_diagDataCount++;\n                g_diagDataStore[found_idx].id = data_id;\n            } else {\n                return -5;\n            }\n        }\n\n        memcpy(g_diagDataStore[found_idx].data, payload + (1 + 2 + 1), data_len);\n        g_diagDataStore[found_idx].current_len = data_len;\n\n        return 0;\n\n    } else if (report_id == 0x20) {\n        return 0;\n    }\n\n    return -99;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define TRANSACTION_LOG_CAPACITY 16\n\ntypedef struct {\n    uint32_t transaction_id;\n    uint32_t timestamp;\n    uint8_t status_flags;\n    uint8_t data[4];\n} TransactionRecord;\n\nstatic TransactionRecord g_transaction_log_fixed[TRANSACTION_LOG_CAPACITY];\nstatic uint16_t g_current_transaction_count_fixed = 0;\nstatic uint16_t g_next_write_idx_fixed = 0;\n\nvoid init_transaction_manager_fixed() {\n    memset(g_transaction_log_fixed, 0, sizeof(g_transaction_log_fixed));\n    g_current_transaction_count_fixed = 0;\n    g_next_write_idx_fixed = 0;\n}\n\nvoid record_transaction_fixed(uint32_t id, uint32_t ts, const uint8_t* data_in) {\n    if (g_current_transaction_count_fixed < TRANSACTION_LOG_CAPACITY) {\n        g_current_transaction_count_fixed++;\n    }\n\n    TransactionRecord* entry = &g_transaction_log_fixed[g_next_write_idx_fixed];\n    entry->transaction_id = id;\n    entry->timestamp = ts;\n    entry->status_flags = 0x01;\n    memcpy(entry->data, data_in, sizeof(entry->data));\n\n    g_next_write_idx_fixed = (g_next_write_idx_fixed + 1) % TRANSACTION_LOG_CAPACITY;\n}\n\nvoid update_transaction_status_by_offset_fixed(uint16_t offset_from_current, uint8_t new_status_flag) {\n    if (g_current_transaction_count_fixed == 0 || offset_from_current >= g_current_transaction_count_fixed) {\n        return;\n    }\n\n    int32_t last_written_idx;\n    if (g_next_write_idx_fixed == 0) {\n        last_written_idx = TRANSACTION_LOG_CAPACITY - 1;\n    } else {\n        last_written_idx = g_next_write_idx_fixed - 1;\n    }\n\n    int32_t conceptual_idx = last_written_idx - offset_from_current;\n\n    int16_t target_idx = (int16_t)(((conceptual_idx % TRANSACTION_LOG_CAPACITY) + TRANSACTION_LOG_CAPACITY) % TRANSACTION_LOG_CAPACITY);\n\n    g_transaction_log_fixed[target_idx].status_flags = new_status_flag;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_EVENT_BUFFER_SIZE 32\n#define DIAG_EVENT_DATA_LEN 8\n\ntypedef struct {\n    uint32_t event_timestamp;\n    uint16_t event_id;\n    uint8_t event_data[DIAG_EVENT_DATA_LEN];\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diag_event_buffer_fixed[DIAG_EVENT_BUFFER_SIZE];\nstatic int32_t g_diag_write_idx_fixed = -1; \nstatic uint32_t g_events_in_buffer_fixed = 0;\n\nvoid init_diag_event_recorder_fixed() {\n    memset(g_diag_event_buffer_fixed, 0, sizeof(g_diag_event_buffer_fixed));\n    g_diag_write_idx_fixed = -1;\n    g_events_in_buffer_fixed = 0;\n}\n\nvoid record_diagnostic_event_fixed(uint16_t id, const uint8_t* data) {\n    g_diag_write_idx_fixed = (g_diag_write_idx_fixed + 1) % DIAG_EVENT_BUFFER_SIZE;\n    g_diag_event_buffer_fixed[g_diag_write_idx_fixed].event_timestamp = 0xDEADBEEF; \n    g_diag_event_buffer_fixed[g_diag_write_idx_fixed].event_id = id;\n    memcpy(g_diag_event_buffer_fixed[g_diag_write_idx_fixed].event_data, data, DIAG_EVENT_DATA_LEN);\n    g_events_in_buffer_fixed++;\n}\n\nDiagnosticEvent* get_previous_diag_event_fixed(uint32_t steps_back) {\n    if (g_events_in_buffer_fixed == 0) {\n        return NULL;\n    }\n\n    uint32_t current_valid_elements = (g_events_in_buffer_fixed < DIAG_EVENT_BUFFER_SIZE) ? g_events_in_buffer_fixed : DIAG_EVENT_BUFFER_SIZE;\n\n    if (steps_back >= current_valid_elements) {\n        return NULL;\n    }\n\n    int32_t target_idx_raw = g_diag_write_idx_fixed - steps_back;\n\n    int32_t final_target_idx = (target_idx_raw % DIAG_EVENT_BUFFER_SIZE + DIAG_EVENT_BUFFER_SIZE) % DIAG_EVENT_BUFFER_SIZE;\n\n    return &g_diag_event_buffer_fixed[final_target_idx];\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdio.h>\n\n#define DIAG_REPORT_BUFFER_SIZE 64\n#define MAX_VIN_LENGTH 17\n\ntypedef struct {\n    uint16_t dtc_code;\n    uint32_t timestamp;\n    char component_id[5];\n    char vin[MAX_VIN_LENGTH + 1];\n} DiagnosticReportData;\n\nstatic char g_diagnosticReportBuffer[DIAG_REPORT_BUFFER_SIZE];\n\nstatic int append_to_report_buffer(const char* str, uint32_t len, uint32_t* current_offset, uint32_t buffer_size) {\n    if (str == NULL || *current_offset >= buffer_size) {\n        return -1;\n    }\n\n    uint32_t remaining_space = buffer_size - *current_offset;\n    uint32_t bytes_to_copy = len;\n\n    if (bytes_to_copy > remaining_space) {\n        bytes_to_copy = remaining_space;\n    }\n    \n    for (uint32_t i = 0; i < bytes_to_copy; ++i) {\n        g_diagnosticReportBuffer[*current_offset + i] = str[i];\n    }\n    *current_offset += bytes_to_copy;\n\n    return 0;\n}\n\nint generateDiagnosticReport(const DiagnosticReportData* data) {\n    if (data == NULL) {\n        return -1;\n    }\n\n    uint32_t current_pos = 0;\n    memset(g_diagnosticReportBuffer, 0, DIAG_REPORT_BUFFER_SIZE);\n\n    const char* prefix = ", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define LOG_BUFFER_SIZE 32\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t event_id;\n    uint8_t severity;\n    bool active;\n    uint8_t data[4];\n} VehicleLogEntry;\n\nstatic VehicleLogEntry g_vehicle_event_log[LOG_BUFFER_SIZE];\nstatic uint32_t g_write_head_idx = 0;\nstatic uint32_t g_num_active_entries = 0;\n\nvoid init_vehicle_log_fixed() {\n    for (uint32_t i = 0; i < LOG_BUFFER_SIZE; ++i) {\n        memset(&g_vehicle_event_log[i], 0, sizeof(VehicleLogEntry));\n        g_vehicle_event_log[i].active = false;\n    }\n    g_write_head_idx = 0;\n    g_num_active_entries = 0;\n}\n\nvoid add_log_entry_fixed(uint16_t event_id, uint8_t severity, const uint8_t* data, uint32_t timestamp) {\n    g_vehicle_event_log[g_write_head_idx].timestamp_ms = timestamp;\n    g_vehicle_event_log[g_write_head_idx].event_id = event_id;\n    g_vehicle_event_log[g_write_head_idx].severity = severity;\n    g_vehicle_event_log[g_write_head_idx].active = true;\n    if (data) {\n        memcpy(g_vehicle_event_log[g_write_head_idx].data, data, sizeof(g_vehicle_event_log[g_write_head_idx].data));\n    }\n\n    g_write_head_idx = (g_write_head_idx + 1) % LOG_BUFFER_SIZE;\n    if (g_num_active_entries < LOG_BUFFER_SIZE) {\n        g_num_active_entries++;\n    }\n}\n\nvoid update_historical_log_status_fixed(int relative_offset_from_newest, bool new_active_status) {\n    if (g_num_active_entries == 0) {\n        return;\n    }\n\n    if (relative_offset_from_newest < 0 || (uint32_t)relative_offset_from_newest >= g_num_active_entries) {\n        return;\n    }\n\n    int newest_entry_absolute_idx = (int)g_write_head_idx - 1;\n    if (newest_entry_absolute_idx < 0) {\n        newest_entry_absolute_idx = LOG_BUFFER_SIZE - 1;\n    }\n\n    int target_log_idx = (newest_entry_absolute_idx - relative_offset_from_newest + LOG_BUFFER_SIZE) % LOG_BUFFER_SIZE;\n\n    g_vehicle_event_log[target_log_idx].active = new_active_status;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define NUM_SUB_MODULES 3\n#define MAX_ENGINE_PARAMS 20\n#define MAX_TRANSMISSION_PARAMS 10\n#define MAX_INFOTAINMENT_PARAMS 5\n\ntypedef enum {\n    SUB_MODULE_ENGINE = 0,\n    SUB_MODULE_TRANSMISSION,\n    SUB_MODULE_INFOTAINMENT,\n    SUB_MODULE_INVALID\n} SubModuleID;\n\ntypedef struct {\n    SubModuleID module_id;\n    uint8_t     parameter_index;\n    uint32_t    new_value;\n    uint8_t     command_type;\n} DiagnosticCommand_Vulnerable;\n\nstatic uint32_t g_engineParameters[MAX_ENGINE_PARAMS];\nstatic uint32_t g_transmissionParameters[MAX_TRANSMISSION_PARAMS];\nstatic uint32_t g_infotainmentParameters[MAX_INFOTAINMENT_PARAMS];\n\nstatic uint32_t* g_moduleParameterArrays_vulnerable[NUM_SUB_MODULES] = {\n    g_engineParameters,\n    g_transmissionParameters,\n    g_infotainmentParameters\n};\n\nvoid logDiagnosticError_vulnerable(const char* msg) {\n}\n\nDiagnosticCommand_Vulnerable receiveDiagnosticCommand_vulnerable() {\n    DiagnosticCommand_Vulnerable cmd;\n    cmd.module_id = SUB_MODULE_TRANSMISSION; \n    cmd.parameter_index = 15; \n    cmd.new_value = 0xDEADBEEF;\n    cmd.command_type = 0x02;\n    return cmd;\n}\n\nvoid initializeSystemParameters_vulnerable() {\n    for (int i = 0; i < MAX_ENGINE_PARAMS; ++i) g_engineParameters[i] = i;\n    for (int i = 0; i < MAX_TRANSMISSION_PARAMS; ++i) g_transmissionParameters[i] = i + 100;\n    for (int i = 0; i < MAX_INFOTAINMENT_PARAMS; ++i) g_infotainmentParameters[i] = i + 200;\n}\n\nvoid processDiagnosticCommand_vulnerable() {\n    DiagnosticCommand_Vulnerable cmd = receiveDiagnosticCommand_vulnerable();\n\n    if (cmd.module_id < NUM_SUB_MODULES) {\n        uint32_t* target_array = g_moduleParameterArrays_vulnerable[cmd.module_id];\n\n        if (cmd.command_type == 0x02) {\n            target_array[cmd.parameter_index] = cmd.new_value;\n            logDiagnosticError_vulnerable(\"Parameter update processed.\");\n        } else if (cmd.command_type == 0x01) {\n            uint32_t value = target_array[cmd.parameter_index];\n            logDiagnosticError_vulnerable(\"Parameter read processed.\");\n        } else {\n            logDiagnosticError_vulnerable(\"Unknown command type.\");\n        }\n    } else {\n        logDiagnosticError_vulnerable(\"Invalid sub-module ID received.\");\n    }\n}\n\nvoid main_vulnerable() {\n    initializeSystemParameters_vulnerable();\n    processDiagnosticCommand_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_VEHICLE_PARAMS 256\n#define CAN_PAYLOAD_MAX_SIZE 8\n\nstatic uint8_t g_vehicleParameters[MAX_VEHICLE_PARAMS];\n\nvoid initVehicleParameters() {\n    memset(g_vehicleParameters, 0, MAX_VEHICLE_PARAMS);\n}\n\nint processParameterUpdate(const uint8_t* can_payload, uint8_t payload_len) {\n    if (can_payload == NULL || payload_len < 3) {\n        return -1;\n    }\n\n    uint16_t param_index = (can_payload[0] << 8) | can_payload[1];\n    uint8_t param_value = can_payload[2];\n\n    g_vehicleParameters[param_index] = param_value;\n\n    return 0;\n}\n\nvoid receiveCANMessage(const uint8_t* data, uint8_t len) {\n    processParameterUpdate(data, len);\n}\n\nuint8_t getVehicleParameter(uint8_t index) {\n    if (index < MAX_VEHICLE_PARAMS) {\n        return g_vehicleParameters[index];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define SYSTEM_CONFIG_SIZE 1024\n#define MAX_CONFIG_GROUPS 10\n\n// Base offsets for each configuration group within the g_systemConfig array.\n// Note: g_groupBaseOffsets[9] is set to a value (65500) that, when combined with a \n// large item_index, can cause an integer overflow if the sum is implicitly cast to uint16_t.\nstatic const uint16_t g_groupBaseOffsets[MAX_CONFIG_GROUPS] = {\n    0,     // Group 0\n    50,    // Group 1\n    120,   // Group 2\n    250,   // Group 3\n    400,   // Group 4\n    600,   // Group 5\n    850,   // Group 6\n    1150,  // Group 7\n    1400,  // Group 8\n    65500  // Group 9 - VULNERABILITY FOCUS: Base offset causing overflow with item_index\n};\n\n// Global array storing various system configuration values.\nstatic uint16_t g_systemConfig[SYSTEM_CONFIG_SIZE]; \n\nvoid initSystemConfig() {\n    memset(g_systemConfig, 0, sizeof(g_systemConfig));\n    for (int i = 0; i < SYSTEM_CONFIG_SIZE; ++i) {\n        g_systemConfig[i] = i * 2; \n    }\n}\n\n// Function to update a specific configuration value based on group and item index.\n// group_id: Identifies the configuration group (0 to MAX_CONFIG_GROUPS-1).\n// item_index: Offset within the identified group (0 to 255 due to uint8_t).\n// new_value: The 16-bit value to write.\nint updateConfigurationValue(uint8_t group_id, uint8_t item_index, uint16_t new_value) {\n    if (group_id >= MAX_CONFIG_GROUPS) {\n        return -1; // Invalid group_id\n    }\n\n    // VULNERABILITY: Integer overflow in index calculation (CWE-190 leading to CWE-119).\n    // The sum of g_groupBaseOffsets[group_id] (uint16_t) and item_index (uint8_t) \n    // is implicitly performed as a uint16_t operation if final_index is declared as uint16_t.\n    // For example, if group_id is 9 (g_groupBaseOffsets[9] = 65500) and item_index is 100,\n    // the mathematical sum is 65500 + 100 = 65600. \n    // When stored in a uint16_t, 65600 overflows and wraps around to 65600 % 65536 = 64.\n    // The subsequent bounds check 'final_index >= SYSTEM_CONFIG_SIZE' is performed on this \n    // wrapped-around value (64 < 1024), which passes, allowing an out-of-bounds write\n    // relative to the *intended* logical address (65600) but an in-bounds write to an\n    // *unintended* physical address (64).\n    uint16_t final_index = g_groupBaseOffsets[group_id] + item_index;\n\n    if (final_index >= SYSTEM_CONFIG_SIZE) {\n        return -2; // This check may be bypassed due to integer overflow, leading to an OOB write.\n    }\n\n    g_systemConfig[final_index] = new_value; \n\n    return 0; // Success\n}\n\n// Dummy function to simulate receiving a configuration update command from a vehicle's network.\nvoid receiveConfigUpdateCommand(uint8_t group, uint8_t item, uint16_t val) {\n    updateConfigurationValue(group, item, val);\n}\n\n// Function to retrieve a config value (for testing/demonstration).\nuint16_t getSystemConfigValue(uint16_t index) {\n    if (index < SYSTEM_CONFIG_SIZE) {\n        return g_systemConfig[index];\n    }\n    return 0xFFFF; // Error: Index out of bounds\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n#pragma pack(push, 1)\nstruct ModuleConfigHeader {\n    uint16_t module_id;\n    uint16_t payload_length; \n};\n#pragma pack(pop)\n\nconst size_t MAX_STORED_CONFIG_ENTRIES = 5; \nconst size_t ALLOC_SLOT_PAYLOAD_SIZE = 64; \n\nclass FirmwareConfigStorageFixed {\nprivate:\n    uint8_t* m_config_buffer;\n    size_t m_current_data_offset; \n    size_t m_total_allocated_capacity; \n    size_t m_num_stored_entries; \n\npublic:\n    FirmwareConfigStorageFixed() :\n        m_config_buffer(nullptr),\n        m_current_data_offset(0),\n        m_total_allocated_capacity(0),\n        m_num_stored_entries(0)\n    {\n        m_total_allocated_capacity = MAX_STORED_CONFIG_ENTRIES * (sizeof(ModuleConfigHeader) + ALLOC_SLOT_PAYLOAD_SIZE);\n        m_config_buffer = (uint8_t*)malloc(m_total_allocated_capacity);\n        if (!m_config_buffer) {\n            m_total_allocated_capacity = 0;\n        }\n    }\n\n    ~FirmwareConfigStorageFixed() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n        }\n    }\n\n    bool addModuleConfigEntryFixed(const uint8_t* raw_entry_data, size_t raw_entry_data_len) {\n        if (!m_config_buffer || !raw_entry_data || raw_entry_data_len < sizeof(ModuleConfigHeader)) {\n            return false;\n        }\n\n        const ModuleConfigHeader* header = reinterpret_cast<const ModuleConfigHeader*>(raw_entry_data);\n        uint16_t actual_payload_len = header->payload_length;\n\n        if (actual_payload_len > ALLOC_SLOT_PAYLOAD_SIZE) {\n            return false; \n        }\n\n        size_t incoming_entry_full_size = sizeof(ModuleConfigHeader) + actual_payload_len;\n\n        if (incoming_entry_full_size != raw_entry_data_len) {\n            return false;\n        }\n\n        if (m_num_stored_entries >= MAX_STORED_CONFIG_ENTRIES) {\n            return false;\n        }\n\n        size_t write_position_for_entry = m_num_stored_entries * (sizeof(ModuleConfigHeader) + ALLOC_SLOT_PAYLOAD_SIZE);\n\n        if (write_position_for_entry + incoming_entry_full_size > m_total_allocated_capacity) {\n            return false; \n        }\n\n        memcpy(m_config_buffer + write_position_for_entry, raw_entry_data, incoming_entry_full_size);\n\n        m_num_stored_entries++;\n\n        return true;\n    }\n\n    size_t getNumStoredEntries() const {\n        return m_num_stored_entries;\n    }\n\n    size_t getTotalAllocatedCapacity() const {\n        return m_total_allocated_capacity;\n    }\n\n    const uint8_t* getConfigBuffer() const {\n        return m_config_buffer;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define EVENT_LOG_BUFFER_SIZE 256\n#define MAX_SINGLE_EVENT_PAYLOAD_SIZE 64\n\ntypedef struct {\n    uint8_t event_id;\n    uint8_t payload_len;\n} EventLogHeader;\n\nstatic uint8_t g_eventLogBuffer[EVENT_LOG_BUFFER_SIZE];\nstatic uint16_t g_logWritePointer = 0;\n\nvoid initEventLogger() {\n    memset(g_eventLogBuffer, 0, EVENT_LOG_BUFFER_SIZE);\n    g_logWritePointer = 0;\n}\n\nint addEventToLog(uint8_t event_type, const uint8_t* event_data, uint8_t data_len) {\n    if (event_data == NULL) {\n        return -1;\n    }\n\n    if (data_len > MAX_SINGLE_EVENT_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    uint16_t entry_total_size = sizeof(EventLogHeader) + data_len;\n\n    // Vulnerability: The total size of the entry (header + data) is not checked against\n    // the remaining capacity of the global buffer before writing.\n    // An attacker can send a data_len that, while individually small (e.g., < MAX_SINGLE_EVENT_PAYLOAD_SIZE),\n    // causes an out-of-bounds write when combined with a specific g_logWritePointer value.\n    // For example, if g_logWritePointer is 250, and data_len is 8 (entry_total_size = 2+8=10),\n    // the copy will attempt to write up to index 250+2+7 = 259, overflowing the 256-byte buffer.\n\n    g_eventLogBuffer[g_logWritePointer] = event_type;\n    g_eventLogBuffer[g_logWritePointer + 1] = data_len;\n\n    // The loop iterates based on 'data_len' without an explicit bounds check for 'g_eventLogBuffer'\n    // on each iteration, relying only on previous checks that are insufficient.\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_eventLogBuffer[g_logWritePointer + 2 + i] = event_data[i];\n    }\n\n    g_logWritePointer += entry_total_size;\n\n    return 0;\n}\n\nvoid simulateDTCRecording(uint8_t dtc_code, const uint8_t* diagnostic_info, uint8_t info_len) {\n    if (g_logWritePointer == 0) {\n        initEventLogger();\n    }\n    addEventToLog(dtc_code, diagnostic_info, info_len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_ENGINE_MAPS 5\n\ntypedef struct {\n    uint16_t fuel_injection_timing;\n    uint16_t ignition_advance;\n    uint16_t throttle_response_curve_id;\n    uint8_t  turbo_boost_pressure_level;\n} EnginePerformanceMap;\n\nstatic EnginePerformanceMap g_engineMaps_vulnerable[MAX_ENGINE_MAPS];\nstatic uint8_t g_currentEngineMapIndex_vulnerable;\n\nvoid automotiveLog_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    uint32_t can_id;\n    uint8_t  data[8];\n    uint8_t  dlc;\n} CANMessage_vulnerable;\n\nCANMessage_vulnerable receiveCANMessage_vulnerable() {\n    CANMessage_vulnerable msg;\n    msg.can_id = 0x123;\n    msg.data[0] = MAX_ENGINE_MAPS; \n    msg.dlc = 1;\n    return msg;\n}\n\nvoid initializeEngineMaps_vulnerable() {\n    for (uint8_t i = 0; i < MAX_ENGINE_MAPS; ++i) {\n        g_engineMaps_vulnerable[i] = (EnginePerformanceMap){150 + i*10, 20 + i*2, i, (uint8_t)(i % 5)};\n    }\n    g_currentEngineMapIndex_vulnerable = 0;\n    automotiveLog_vulnerable(\"Engine maps initialized.\");\n}\n\nvoid setEngineMode_vulnerable(uint8_t mode_id) {\n    g_currentEngineMapIndex_vulnerable = mode_id;\n    EnginePerformanceMap selectedMap = g_engineMaps_vulnerable[g_currentEngineMapIndex_vulnerable];\n    automotiveLog_vulnerable(\"Engine mode attempted to be set (vulnerable).\");\n}\n\nvoid engineControlUnit_vulnerable_main() {\n    initializeEngineMaps_vulnerable();\n\n    CANMessage_vulnerable command_msg = receiveCANMessage_vulnerable();\n    uint8_t requested_mode_id = command_msg.data[0];\n\n    setEngineMode_vulnerable(requested_mode_id);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#define MAX_SUBSYSTEMS 5\n#define MAX_DATA_POINTS_PER_SUBSYSTEM 10\n\ntypedef enum {\n    SUBSYSTEM_ENGINE = 0,\n    SUBSYSTEM_TRANSMISSION,\n    SUBSYSTEM_BRAKES,\n    SUBSYSTEM_HVAC,\n    SUBSYSTEM_INFOTAINMENT,\n    SUBSYSTEM_COUNT\n} SubsystemType;\n\ntypedef struct {\n    SubsystemType type;\n    int data_index;\n    long value;\n} VehicleMetricPacket;\n\nstatic long g_subsystemMetrics[MAX_SUBSYSTEMS][MAX_DATA_POINTS_PER_SUBSYSTEM];\n\nVehicleMetricPacket receiveMetricPacket_fixed() {\n    VehicleMetricPacket packet;\n    packet.type = SUBSYSTEM_ENGINE;\n    packet.data_index = 10;\n    packet.value = 12345L;\n    return packet;\n}\n\nvoid logSystemError(const char* msg) {\n}\n\nvoid processVehicleMetric_fixed() {\n    VehicleMetricPacket packet = receiveMetricPacket_fixed();\n\n    if (packet.type < SUBSYSTEM_COUNT) {\n        if (packet.data_index >= 0 && packet.data_index < MAX_DATA_POINTS_PER_SUBSYSTEM) {\n            g_subsystemMetrics[packet.type][packet.data_index] = packet.value;\n        } else {\n            logSystemError(\"Received metric with out-of-bounds data index. Ignoring packet.\");\n        }\n    } else {\n        logSystemError(\"Received metric for unknown subsystem type.\");\n    }\n}\n\nvoid metricProcessorInit_fixed() {\n    for (int i = 0; i < MAX_SUBSYSTEMS; ++i) {\n        for (int j = 0; j < MAX_DATA_POINTS_PER_SUBSYSTEM; ++j) {\n            g_subsystemMetrics[i][j] = 0;\n        }\n    }\n}\n\nvoid simulateMetricProcessing_fixed() {\n    metricProcessorInit_fixed();\n    processVehicleMetric_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define VEHICLE_SENSOR_HISTORY_SIZE 10\n\ntypedef struct {\n    uint16_t sensor_id;\n    int32_t value;\n    uint32_t timestamp_ms;\n    bool valid;\n} VehicleSensorReading;\n\nstatic VehicleSensorReading g_sensor_history_buffer[VEHICLE_SENSOR_HISTORY_SIZE];\nstatic uint8_t g_history_head_idx = 0;\nstatic uint8_t g_history_count = 0;\n\nvoid init_sensor_history_buffer_fixed() {\n    for (uint8_t i = 0; i < VEHICLE_SENSOR_HISTORY_SIZE; ++i) {\n        memset(&g_sensor_history_buffer[i], 0, sizeof(VehicleSensorReading));\n        g_sensor_history_buffer[i].valid = false;\n    }\n    g_history_head_idx = 0;\n    g_history_count = 0;\n}\n\nbool add_sensor_reading_fixed(uint16_t sensor_id, int32_t value, uint32_t timestamp_ms) {\n    g_sensor_history_buffer[g_history_head_idx].sensor_id = sensor_id;\n    g_sensor_history_buffer[g_history_head_idx].value = value;\n    g_sensor_history_buffer[g_history_head_idx].timestamp_ms = timestamp_ms;\n    g_sensor_history_buffer[g_history_head_idx].valid = true;\n\n    g_history_head_idx = (g_history_head_idx + 1) % VEHICLE_SENSOR_HISTORY_SIZE;\n    if (g_history_count < VEHICLE_SENSOR_HISTORY_SIZE) {\n        g_history_count++;\n    }\n    return true;\n}\n\nvoid invalidate_n_last_readings_fixed(int8_t num_to_invalidate) {\n    if (g_history_count == 0 || num_to_invalidate <= 0) {\n        return;\n    }\n\n    int8_t actual_to_invalidate = (num_to_invalidate > g_history_count) ? g_history_count : num_to_invalidate;\n\n    for (int8_t i = 1; i <= actual_to_invalidate; ++i) {\n        uint8_t target_idx = (g_history_head_idx - i + VEHICLE_SENSOR_HISTORY_SIZE) % VEHICLE_SENSOR_HISTORY_SIZE;\n        g_sensor_history_buffer[target_idx].valid = false;\n        g_sensor_history_buffer[target_idx].value = 0;\n    }\n\n    g_history_count -= actual_to_invalidate;\n    g_history_head_idx = (g_history_head_idx - actual_to_invalidate + VEHICLE_SENSOR_HISTORY_SIZE) % VEHICLE_SENSOR_HISTORY_SIZE;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define EVENT_LOG_SIZE 256 \n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t event_type_id;\n    uint16_t metadata_flags;\n} VehicleEventEntry;\n\nstatic VehicleEventEntry g_event_log_fixed[EVENT_LOG_SIZE];\nstatic uint32_t g_current_log_head_fixed = 0; \nstatic bool g_log_wrapped_fixed = false; \n\nvoid init_event_logger_fixed() {\n    memset(g_event_log_fixed, 0, sizeof(g_event_log_fixed));\n    g_current_log_head_fixed = 0;\n    g_log_wrapped_fixed = false;\n}\n\nvoid log_vehicle_event_fixed(uint16_t type_id, uint32_t current_timestamp) {\n    g_event_log_fixed[g_current_log_head_fixed].timestamp_ms = current_timestamp;\n    g_event_log_fixed[g_current_log_head_fixed].event_type_id = type_id;\n    g_event_log_fixed[g_current_log_head_fixed].metadata_flags = 0; \n\n    g_current_log_head_fixed++;\n    if (g_current_log_head_fixed >= EVENT_LOG_SIZE) {\n        g_current_log_head_fixed = 0;\n        g_log_wrapped_fixed = true;\n    }\n}\n\nvoid mark_historical_event_fixed(uint32_t offset_from_head, uint16_t marker_flag) {\n    uint32_t last_written_idx;\n    if (g_current_log_head_fixed == 0) {\n        if (g_log_wrapped_fixed) {\n            last_written_idx = EVENT_LOG_SIZE - 1;\n        } else {\n            return; \n        }\n    } else {\n        last_written_idx = g_current_log_head_fixed - 1;\n    }\n\n    uint32_t available_history_count;\n    if (g_log_wrapped_fixed) {\n        available_history_count = EVENT_LOG_SIZE; \n    } else {\n        available_history_count = g_current_log_head_fixed; \n    }\n\n    if (offset_from_head >= available_history_count) {\n        return; \n    }\n\n    uint32_t safe_target_idx = (last_written_idx + EVENT_LOG_SIZE - offset_from_head) % EVENT_LOG_SIZE;\n\n    g_event_log_fixed[safe_target_idx].metadata_flags |= marker_flag;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAG_MESSAGE_MAX_SIZE 1024\n#define MAX_RECORD_PAYLOAD_SIZE 128\n#define TEMP_PROCESSING_BUFFER_SIZE 64\n\ntypedef struct {\n    uint16_t message_id;\n    uint16_t total_payload_len;\n} DiagnosticMessageHeader;\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_len;\n} DiagnosticRecordMinimalHeader;\n\nint processDiagnosticMessage(const uint8_t* msg_buffer, uint16_t msg_len) {\n    if (msg_buffer == NULL || msg_len < sizeof(DiagnosticMessageHeader)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n    \n    uint16_t message_id = (msg_buffer[0] << 8) | msg_buffer[1];\n    current_offset += sizeof(uint16_t);\n\n    uint16_t total_payload_len = (msg_buffer[current_offset] << 8) | msg_buffer[current_offset+1];\n    current_offset += sizeof(uint16_t);\n\n    if (current_offset + total_payload_len > msg_len) {\n        return -2;\n    }\n\n    uint16_t payload_bytes_processed = 0;\n    while (payload_bytes_processed < total_payload_len) {\n        if (payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader) > total_payload_len) {\n            return -3;\n        }\n\n        const DiagnosticRecordMinimalHeader* record_header = \n            (const DiagnosticRecordMinimalHeader*)(msg_buffer + current_offset + payload_bytes_processed);\n        \n        uint8_t record_type = record_header->record_type;\n        uint8_t record_data_len = record_header->record_len; \n\n        if (record_data_len > MAX_RECORD_PAYLOAD_SIZE ||\n            payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader) + record_data_len > total_payload_len) {\n            return -4;\n        }\n\n        const uint8_t* record_data_ptr = msg_buffer + current_offset + payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader);\n\n        if (record_type == 0x05) {\n            char temp_processing_buffer[TEMP_PROCESSING_BUFFER_SIZE];\n            uint8_t bytes_to_copy = record_data_len;\n\n            if (bytes_to_copy >= TEMP_PROCESSING_BUFFER_SIZE) {\n                bytes_to_copy = TEMP_PROCESSING_BUFFER_SIZE - 1;\n            }\n            \n            memcpy(temp_processing_buffer, record_data_ptr, bytes_to_copy);\n            temp_processing_buffer[bytes_to_copy] = '\\0';\n        }\n\n        payload_bytes_processed += sizeof(DiagnosticRecordMinimalHeader) + record_data_len;\n    }\n\n    return 0;\n}\n\nvoid simulateIncomingDiagnosticFrame(const uint8_t* data, uint16_t length) {\n    processDiagnosticMessage(data, length);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <algorithm>\n\ntypedef struct {\n    uint16_t record_id;\n    uint16_t data_size; \n} LogRecordHeader;\n\ntypedef struct {\n    uint32_t total_expected_payload_bytes; \n    uint16_t num_records;       \n} LogPacketHeader;\n\nclass VehicleLogProcessorFixed {\npublic:\n    VehicleLogProcessorFixed() :\n        internal_log_buffer(nullptr),\n        allocated_buffer_size(0) {}\n\n    ~VehicleLogProcessorFixed() {\n        if (internal_log_buffer) {\n            delete[] internal_log_buffer;\n            internal_log_buffer = nullptr;\n        }\n    }\n\n    bool processLogPacketFixed(const uint8_t* raw_packet, size_t raw_packet_len) {\n        if (!raw_packet || raw_packet_len < sizeof(LogPacketHeader)) {\n            return false;\n        }\n\n        const LogPacketHeader* packet_header = reinterpret_cast<const LogPacketHeader*>(raw_packet);\n\n        static const uint32_t MAX_EXPECTED_PAYLOAD_SIZE = 16 * 1024; \n        if (packet_header->total_expected_payload_bytes == 0 || packet_header->total_expected_payload_bytes > MAX_EXPECTED_PAYLOAD_SIZE) {\n            return false;\n        }\n\n        if (raw_packet_len < (sizeof(LogPacketHeader) + packet_header->total_expected_payload_bytes)) {\n            return false;\n        }\n\n        if (internal_log_buffer) {\n            delete[] internal_log_buffer;\n        }\n        internal_log_buffer = new (std::nothrow) uint8_t[packet_header->total_expected_payload_bytes];\n        if (!internal_log_buffer) {\n            return false;\n        }\n        allocated_buffer_size = packet_header->total_expected_payload_bytes;\n\n        size_t current_raw_read_offset = sizeof(LogPacketHeader);\n        size_t current_internal_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_header->num_records; ++i) {\n            if (current_raw_read_offset + sizeof(LogRecordHeader) > raw_packet_len) {\n                return false;\n            }\n            const LogRecordHeader* record_header = reinterpret_cast<const LogRecordHeader*>(raw_packet + current_raw_read_offset);\n\n            uint16_t record_data_len = record_header->data_size;\n\n            if (current_raw_read_offset + sizeof(LogRecordHeader) + record_data_len > raw_packet_len) {\n                return false;\n            }\n\n            if (current_internal_write_offset + record_data_len > allocated_buffer_size) {\n                return false;\n            }\n\n            for (uint16_t j = 0; j < record_data_len; ++j) {\n                internal_log_buffer[current_internal_write_offset + j] = raw_packet[current_raw_read_offset + sizeof(LogRecordHeader) + j];\n            }\n\n            current_raw_read_offset += sizeof(LogRecordHeader) + record_data_len;\n            current_internal_write_offset += record_data_len;\n        }\n\n        if (current_internal_write_offset != packet_header->total_expected_payload_bytes) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getLogBuffer() const {\n        return internal_log_buffer;\n    }\n\n    size_t getAllocatedSize() const {\n        return allocated_buffer_size;\n    }\n\nprivate:\n    uint8_t* internal_log_buffer;\n    size_t allocated_buffer_size;\n};\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 512\n#define CONFIG_BLOCK_HEADER_SIZE 8\n#define MAX_CONFIG_PAYLOAD (VEHICLE_CONFIG_BUFFER_SIZE - CONFIG_BLOCK_HEADER_SIZE)\n\n#define GLOBAL_METADATA_OFFSET 16\n\nstatic uint8_t g_vehicle_config_buffer[VEHICLE_CONFIG_BUFFER_SIZE];\nstatic uint8_t* g_config_data_start_ptr;\nstatic uint16_t g_current_config_data_len = 0;\n\nvoid init_vehicle_config_manager() {\n    memset(g_vehicle_config_buffer, 0, VEHICLE_CONFIG_BUFFER_SIZE);\n    g_config_data_start_ptr = g_vehicle_config_buffer + GLOBAL_METADATA_OFFSET;\n    g_current_config_data_len = 0;\n\n    g_vehicle_config_buffer[0] = 0x01;\n    g_vehicle_config_buffer[1] = 0xAF;\n}\n\nint16_t add_config_block(uint16_t block_id, uint16_t version, const uint8_t* payload, uint32_t payload_len) {\n    if (payload == NULL || payload_len == 0 || payload_len > MAX_CONFIG_PAYLOAD) {\n        return -1;\n    }\n\n    uint32_t block_total_size = CONFIG_BLOCK_HEADER_SIZE + payload_len;\n    if (g_current_config_data_len + block_total_size > (VEHICLE_CONFIG_BUFFER_SIZE - GLOBAL_METADATA_OFFSET)) {\n        return -1;\n    }\n\n    uint16_t block_start_relative_offset = g_current_config_data_len;\n    uint8_t* current_write_ptr = g_config_data_start_ptr + block_start_relative_offset;\n\n    *(uint16_t*)current_write_ptr = block_id;\n    *(uint16_t*)(current_write_ptr + 2) = version;\n    *(uint32_t*)(current_write_ptr + 4) = payload_len;\n\n    memcpy(current_write_ptr + CONFIG_BLOCK_HEADER_SIZE, payload, payload_len);\n\n    g_current_config_data_len += block_total_size;\n    return block_start_relative_offset;\n}\n\nvoid update_global_metadata_vulnerable(uint16_t config_block_offset, int32_t meta_target_offset, uint8_t value) {\n    uint8_t* target_address = g_config_data_start_ptr + meta_target_offset;\n\n    *target_address = value;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <string.h>\n\nstruct DiagnosticEvent {\n    uint32_t timestamp;\n    uint16_t event_code;\n    char*    details;\n};\n\nclass DiagnosticEventRecorderVulnerable {\nprivate:\n    DiagnosticEvent* m_events;\n    size_t m_event_count;\n    size_t m_capacity;\n\npublic:\n    DiagnosticEventRecorderVulnerable() : m_events(nullptr), m_event_count(0), m_capacity(0) {\n        m_capacity = 10; \n        m_events = (DiagnosticEvent*)malloc(m_capacity * sizeof(DiagnosticEvent));\n        if (!m_events) {\n            m_capacity = 0;\n        }\n    }\n\n    ~DiagnosticEventRecorderVulnerable() {\n        for (size_t i = 0; i < m_event_count; ++i) {\n            if (m_events[i].details) {\n                free(m_events[i].details);\n            }\n        }\n        if (m_events) {\n            free(m_events);\n        }\n    }\n\n    bool addEventVulnerable(uint32_t timestamp, uint16_t event_code, const char* details_str, uint16_t details_len_from_packet) {\n        if (!details_str || details_len_from_packet == 0) {\n            return false;\n        }\n        \n        if (details_len_from_packet > 255) { \n            return false;\n        }\n\n        if (m_event_count >= m_capacity) {\n            size_t new_capacity = m_capacity * 2;\n            if (new_capacity == 0) new_capacity = 1; \n            DiagnosticEvent* new_events = (DiagnosticEvent*)realloc(m_events, new_capacity * sizeof(DiagnosticEvent));\n            if (!new_events) {\n                return false;\n            }\n            m_events = new_events;\n            m_capacity = new_capacity;\n        }\n\n        DiagnosticEvent new_event;\n        new_event.timestamp = timestamp;\n        new_event.event_code = event_code;\n\n        new_event.details = (char*)malloc(details_len_from_packet);\n        if (!new_event.details) {\n            return false;\n        }\n\n        for (uint16_t i = 0; i < details_len_from_packet; ++i) {\n            new_event.details[i] = details_str[i];\n        }\n        new_event.details[details_len_from_packet] = '\\0';\n\n        m_events[m_event_count++] = new_event;\n        return true;\n    }\n\n    size_t getEventCount() const { return m_event_count; }\n    const DiagnosticEvent* getEvent(size_t index) const {\n        if (index < m_event_count) return &m_events[index];\n        return nullptr;\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>#include <stddef.h>typedef struct {uint32_t code;uint16_t timestamp;uint8_t severity;uint8_t _padding;} DtcEntry_Fixed;#define MAX_DTC_TYPES 5#define TOTAL_DTC_HISTORY_BUFFER_SIZE 256static uint8_t g_dtcHistoryBuffer_fixed[TOTAL_DTC_HISTORY_BUFFER_SIZE];typedef struct {uint16_t start_offset_bytes;uint16_t max_entries;} DtcHistorySegmentConfig_Fixed;static DtcHistorySegmentConfig_Fixed g_dtcSegmentConfigs_fixed[MAX_DTC_TYPES] = {{0, 7},{56, 8},{120, 8},{184, 8},{248, 1}};#ifndef DUMMY_LOG_ERROR_FIXED_DEFINED#define DUMMY_LOG_ERROR_FIXED_DEFINEDvoid logError_fixed(const char* msg) {}#endifstatic uint16_t g_currentDtcEntryCount_fixed[MAX_DTC_TYPES];typedef struct {uint8_t dtc_type_id;uint32_t dtc_code;uint16_t timestamp;uint8_t severity;} IncomingDtcLogRequest_Fixed;IncomingDtcLogRequest_Fixed receiveDtcLogRequest_fixed() {IncomingDtcLogRequest_Fixed req;req.dtc_type_id = 3;req.dtc_code = 0xDEADBEEF;req.timestamp = 12345;req.severity = 2;return req;}void initializeDtcHistory_fixed() {for (int i = 0; i < TOTAL_DTC_HISTORY_BUFFER_SIZE; ++i) {g_dtcHistoryBuffer_fixed[i] = 0;}for (int i = 0; i < MAX_DTC_TYPES; ++i) {g_currentDtcEntryCount_fixed[i] = 0;}}void logDtcEntry_fixed() {IncomingDtcLogRequest_Fixed request = receiveDtcLogRequest_fixed();if (request.dtc_type_id >= MAX_DTC_TYPES) {logError_fixed(", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\ntypedef struct {\n    uint16_t messageId;\n    uint16_t payloadType;\n    uint16_t payloadLength; \n    uint8_t payload[512]; \n} DiagnosticMessage;\n\nchar* processDiagnosticReport(const DiagnosticMessage* msg) {\n    if (!msg || msg->payloadLength == 0) {\n        char* empty_str = (char*)malloc(1);\n        if (empty_str) {\n            empty_str[0] = '\\0';\n        }\n        return empty_str;\n    }\n\n    size_t required_size = (size_t)msg->payloadLength * 2 + 1;\n\n    char* hex_payload_str = (char*)malloc(required_size);\n\n    if (hex_payload_str == NULL) {\n        return NULL;\n    }\n\n    for (uint16_t i = 0; i < msg->payloadLength; ++i) {\n        sprintf(&hex_payload_str[i * 2], \"%02X\", msg->payload[i]);\n    }\n    hex_payload_str[msg->payloadLength * 2] = '\\0';\n\n    return hex_payload_str;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_FEATURES 10\n\ntypedef enum {\n    FEATURE_CRUISE_CONTROL = 0,\n    FEATURE_LANE_KEEP_ASSIST,\n    FEATURE_AEB,\n    FEATURE_PARKING_ASSIST,\n    FEATURE_INFOTAINMENT_MODE,\n    FEATURE_DRIVING_MODE,\n    FEATURE_HEADLIGHT_SENSITIVITY,\n    FEATURE_RAIN_SENSOR_ACTIVE,\n    FEATURE_TIRE_PRESSURE_MONITOR,\n    FEATURE_VEHICLE_DIAG_MODE,\n    FEATURE_COUNT\n} VehicleFeatureID;\n\ntypedef struct {\n    VehicleFeatureID id;\n    int32_t config_value;\n    bool is_active;\n} FeatureConfig;\n\nstatic FeatureConfig g_featureConfigurations[MAX_FEATURES];\n\nvoid systemLog(const char* message) {\n}\n\nvoid initializeFeatureSystem() {\n    for (uint16_t i = 0; i < MAX_FEATURES; ++i) {\n        g_featureConfigurations[i].id = (VehicleFeatureID)i;\n        g_featureConfigurations[i].config_value = 0;\n        g_featureConfigurations[i].is_active = false;\n    }\n    g_featureConfigurations[FEATURE_CRUISE_CONTROL].config_value = 100;\n    g_featureConfigurations[FEATURE_CRUISE_CONTROL].is_active = true;\n    g_featureConfigurations[FEATURE_DRIVING_MODE].config_value = 0;\n}\n\ntypedef struct {\n    uint16_t feature_id_raw;\n    int32_t value;\n    bool active_state;\n} FeatureUpdateCommand;\n\nFeatureUpdateCommand getSimulatedFeatureUpdateCommand_vulnerable() {\n    FeatureUpdateCommand cmd;\n    cmd.feature_id_raw = 10;\n    cmd.value = 500;\n    cmd.active_state = true;\n    return cmd;\n}\n\nvoid applyFeatureUpdate_vulnerable() {\n    FeatureUpdateCommand command = getSimulatedFeatureUpdateCommand_vulnerable();\n\n    g_featureConfigurations[command.feature_id_raw].config_value = command.value;\n    g_featureConfigurations[command.feature_id_raw].is_active = command.active_state;\n\n    systemLog(\"Feature update applied (vulnerable).\");\n}\n\nvoid featureManagerMain_vulnerable() {\n    initializeFeatureSystem();\n    applyFeatureUpdate_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#define MAX_BATTERY_CELLS 96\n#define BMS_CMD_UPDATE_VOLTAGE 0x01\n#define BMS_CMD_UPDATE_TEMP    0x02\n\ntypedef struct {\n    unsigned short voltage_mV;\n    short temperature_C;\n    unsigned char state_of_charge_percent;\n} BatteryCellInfo;\n\nstatic BatteryCellInfo g_batteryCellInfo[MAX_BATTERY_CELLS];\n\ntypedef struct {\n    unsigned char commandType;\n    unsigned char cellId;\n    unsigned short dataValue;\n} BMS_Command;\n\nvoid logBMSWarning(const char* msg) {\n}\n\nBMS_Command receiveBMSCommand_simulated_vulnerable() {\n    BMS_Command cmd;\n    cmd.commandType = BMS_CMD_UPDATE_VOLTAGE;\n    cmd.cellId = 100;\n    cmd.dataValue = 3800;\n    return cmd;\n}\n\nvoid initializeBMSData() {\n    for (unsigned int i = 0; i < MAX_BATTERY_CELLS; ++i) {\n        g_batteryCellInfo[i].voltage_mV = 0;\n        g_batteryCellInfo[i].temperature_C = 0;\n        g_batteryCellInfo[i].state_of_charge_percent = 0;\n    }\n}\n\nvoid processBMSCommand_vulnerable() {\n    BMS_Command cmd = receiveBMSCommand_simulated_vulnerable();\n\n    if (cmd.commandType == BMS_CMD_UPDATE_VOLTAGE) {\n        g_batteryCellInfo[cmd.cellId].voltage_mV = cmd.dataValue;\n    } else if (cmd.commandType == BMS_CMD_UPDATE_TEMP) {\n        g_batteryCellInfo[cmd.cellId].temperature_C = (short)cmd.dataValue;\n    } else {\n        logBMSWarning(\"Unknown BMS command received.\");\n    }\n}\n\nvoid bmsModuleMain_vulnerable() {\n    initializeBMSData();\n    processBMSCommand_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRY_PAYLOAD_SIZE 62\n#define LOG_ACCUMULATOR_BUFFER_SIZE 256\n\ntypedef enum {\n    LOG_TYPE_GENERIC_INFO = 0x01,\n    LOG_TYPE_CRITICAL_FAULT = 0x02,\n    LOG_TYPE_SENSOR_DATA = 0x03,\n    LOG_TYPE_TELEMETRY_EVENT = 0x04\n} LogEntryType;\n\ntypedef struct {\n    uint8_t type;\n    uint8_t data_length;\n    uint8_t data[MAX_LOG_ENTRY_PAYLOAD_SIZE];\n} InternalLogEntry;\n\nstatic uint8_t g_logAccumulatorBuffer[LOG_ACCUMULATOR_BUFFER_SIZE];\nstatic uint16_t g_logAccumulatorCurrentPos = 0;\n\ntypedef struct {\n    const uint8_t* stream_ptr;\n    uint16_t stream_total_len;\n    uint16_t current_stream_offset;\n} DataStreamReaderContext;\n\nint processIncomingLogEntry(DataStreamReaderContext* reader_ctx) {\n    if (reader_ctx == NULL || reader_ctx->stream_ptr == NULL) {\n        return -1;\n    }\n\n    if (reader_ctx->current_stream_offset + 2 > reader_ctx->stream_total_len) {\n        return -1;\n    }\n\n    uint8_t log_type = reader_ctx->stream_ptr[reader_ctx->current_stream_offset];\n    uint8_t payload_len_from_stream = reader_ctx->stream_ptr[reader_ctx->current_stream_offset + 1];\n\n    if (reader_ctx->current_stream_offset + 2 + payload_len_from_stream > reader_ctx->stream_total_len) {\n        return -1;\n    }\n\n    InternalLogEntry temp_log_entry;\n    temp_log_entry.type = log_type;\n    temp_log_entry.data_length = payload_len_from_stream;\n\n    memcpy(temp_log_entry.data, reader_ctx->stream_ptr + reader_ctx->current_stream_offset + 2, payload_len_from_stream);\n\n    uint16_t total_entry_size_to_accumulate = 2 + payload_len_from_stream;\n\n    if (g_logAccumulatorCurrentPos + total_entry_size_to_accumulate > LOG_ACCUMULATOR_BUFFER_SIZE) {\n        return -1;\n    }\n\n    memcpy(g_logAccumulatorBuffer + g_logAccumulatorCurrentPos, &temp_log_entry, total_entry_size_to_accumulate);\n    g_logAccumulatorCurrentPos += total_entry_size_to_accumulate;\n\n    return total_entry_size_to_accumulate;\n}\n\nint processDiagnosticDataBlock(const uint8_t* diagnostic_data, uint16_t data_block_len) {\n    if (diagnostic_data == NULL || data_block_len < 2) {\n        return -1;\n    }\n\n    DataStreamReaderContext reader_ctx = {\n        .stream_ptr = diagnostic_data,\n        .stream_total_len = data_block_len,\n        .current_stream_offset = 0\n    };\n\n    g_logAccumulatorCurrentPos = 0;\n\n    while (reader_ctx.current_stream_offset < reader_ctx.stream_total_len) {\n        int bytes_consumed = processIncomingLogEntry(&reader_ctx);\n        if (bytes_consumed <= 0) {\n            return -1;\n        }\n        reader_ctx.current_stream_offset += bytes_consumed;\n    }\n\n    return g_logAccumulatorCurrentPos;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#define MAX_SENSORS 10#define CAN_MESSAGE_ID_CALIBRATION_UPDATE 0x18F00100#define CAN_MESSAGE_DLC_CALIBRATION 3typedef struct {unsigned int id; unsigned char data[8]; unsigned char dlc;} CanMessage;static int g_sensorCalibrationData[MAX_SENSORS];void logError(const char* msg) {}CanMessage receiveCANMessage_simulated() {CanMessage msg; msg.id = CAN_MESSAGE_ID_CALIBRATION_UPDATE; msg.dlc = CAN_MESSAGE_DLC_CALIBRATION; msg.data[0] = 15; msg.data[1] = 0x01; msg.data[2] = 0x23; for (int i = msg.dlc; i < 8; ++i) {msg.data[i] = 0;} return msg;}void systemInit() {for (int i = 0; i < MAX_SENSORS; ++i) {g_sensorCalibrationData[i] = 0;}}void processCanCommand_vulnerable(const CanMessage* msg) {if (msg->id == CAN_MESSAGE_ID_CALIBRATION_UPDATE && msg->dlc >= CAN_MESSAGE_DLC_CALIBRATION) {unsigned char sensorId = msg->data[0]; int calibrationValue = (msg->data[1] << 8) | msg->data[2]; g_sensorCalibrationData[sensorId] = calibrationValue;}}void vehicleECUMainLoop_vulnerable() {systemInit(); CanMessage receivedMsg = receiveCANMessage_simulated(); processCanCommand_vulnerable(&receivedMsg);}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define AGGREGATED_DATA_BUFFER_SIZE 256\n#define MAX_INCOMING_PACKET_SIZE 512\n\nstatic uint8_t g_aggregatedDataBuffer[AGGREGATED_DATA_BUFFER_SIZE];\nstatic uint16_t g_currentAggregatedLen = 0;\n\nvoid initDataAggregator() {\n    memset(g_aggregatedDataBuffer, 0, AGGREGATED_DATA_BUFFER_SIZE);\n    g_currentAggregatedLen = 0;\n}\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_length;\n} DataRecordHeader;\n\nint processDiagnosticDataPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len < 1) {\n        return -1;\n    }\n\n    uint16_t current_packet_offset = 0;\n    uint8_t record_count = packet[current_packet_offset++];\n\n    if (record_count == 0) {\n        g_currentAggregatedLen = 0;\n        return 0;\n    }\n    if (current_packet_offset >= packet_len) {\n        return -2;\n    }\n\n    g_currentAggregatedLen = 0;\n\n    for (int i = 0; i < record_count; ++i) {\n        if (current_packet_offset + sizeof(DataRecordHeader) > packet_len) {\n            return -3;\n        }\n\n        DataRecordHeader header;\n        header.record_type = packet[current_packet_offset];\n        current_packet_offset++;\n        header.record_length = packet[current_packet_offset];\n        current_packet_offset++;\n\n        if (current_packet_offset + header.record_length > packet_len) {\n            return -4;\n        }\n\n        uint16_t bytes_to_copy_into_agg_buffer = header.record_length;\n        if (g_currentAggregatedLen + bytes_to_copy_into_agg_buffer > AGGREGATED_DATA_BUFFER_SIZE) {\n            bytes_to_copy_into_agg_buffer = AGGREGATED_DATA_BUFFER_SIZE - g_currentAggregatedLen;\n            if (bytes_to_copy_into_agg_buffer == 0) {\n                current_packet_offset += header.record_length;\n                continue;\n            }\n        }\n        \n        for (uint8_t j = 0; j < bytes_to_copy_into_agg_buffer; ++j) {\n            g_aggregatedDataBuffer[g_currentAggregatedLen++] = packet[current_packet_offset++];\n        }\n\n        current_packet_offset += (header.record_length - bytes_to_copy_into_agg_buffer);\n\n        if (g_currentAggregatedLen == AGGREGATED_DATA_BUFFER_SIZE) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nvoid receiveDataPacket(const uint8_t* data, uint16_t len) {\n    processDiagnosticDataPacket(data, len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRIES_PER_PRIORITY 10\n\ntypedef enum {\n    PRIO_CRITICAL_VULNERABLE = 0,\n    PRIO_MAJOR_VULNERABLE,\n    PRIO_MINOR_VULNERABLE,\n    PRIO_INFO_VULNERABLE,\n    NUM_PRIORITY_LEVELS_VULNERABLE\n} EventPriority_Vulnerable;\n\ntypedef struct {\n    uint32_t event_id;\n    uint32_t timestamp;\n    uint8_t flags;\n} IncomingLogMessage_Vulnerable;\n\ntypedef struct {\n    uint32_t id;\n    uint32_t time;\n} LogEntry_Vulnerable;\n\nstatic LogEntry_Vulnerable g_logBuffer_vulnerable[NUM_PRIORITY_LEVELS_VULNERABLE][MAX_LOG_ENTRIES_PER_PRIORITY];\nstatic uint8_t g_logCounts_vulnerable[NUM_PRIORITY_LEVELS_VULNERABLE];\n\nvoid automotive_system_log_vulnerable(const char* msg) {\n    (void)msg;\n}\n\nIncomingLogMessage_Vulnerable receiveLogMessage_vulnerable() {\n    IncomingLogMessage_Vulnerable msg;\n    msg.event_id = 0xABCD1234;\n    msg.timestamp = 0x567890AB;\n    msg.flags = 0x40;\n    automotive_system_log_vulnerable(\"Simulated incoming log message with potentially malicious flags.\");\n    return msg;\n}\n\nvoid initializeLoggingSystem_vulnerable() {\n    for (uint8_t i = 0; i < NUM_PRIORITY_LEVELS_VULNERABLE; ++i) {\n        g_logCounts_vulnerable[i] = 0;\n        for (uint8_t j = 0; j < MAX_LOG_ENTRIES_PER_PRIORITY; ++j) {\n            g_logBuffer_vulnerable[i][j].id = 0;\n            g_logBuffer_vulnerable[i][j].time = 0;\n        }\n    }\n    automotive_system_log_vulnerable(\"Logging system initialized (vulnerable).\");\n}\n\nvoid processIncomingLog_vulnerable() {\n    IncomingLogMessage_Vulnerable msg = receiveLogMessage_vulnerable();\n\n    uint8_t raw_prio_val = (msg.flags >> 4) & 0x0F;\n\n    EventPriority_Vulnerable actual_priority = (EventPriority_VULNERABLE)raw_prio_val;\n\n    if (g_logCounts_vulnerable[actual_priority] < MAX_LOG_ENTRIES_PER_PRIORITY) {\n        g_logBuffer_vulnerable[actual_priority][g_logCounts_vulnerable[actual_priority]].id = msg.event_id;\n        g_logBuffer_vulnerable[actual_priority][g_logCounts_vulnerable[actual_priority]].time = msg.timestamp;\n        g_logCounts_vulnerable[actual_priority]++;\n        automotive_system_log_vulnerable(\"Log entry stored based on derived priority.\");\n    } else {\n        automotive_system_log_vulnerable(\"Log buffer full for this priority level.\");\n    }\n}\n\nvoid main_logging_vulnerable() {\n    initializeLoggingSystem_vulnerable();\n    processIncomingLog_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_PACKET_BUFFER_SIZE 512\n#define MIN_PACKET_HEADER_SIZE 8\n\nstatic uint8_t g_rx_packet_buffer[MAX_PACKET_BUFFER_SIZE];\nstatic uint32_t g_current_rx_data_len = 0;\n\ntypedef struct {\n    uint16_t packet_id;\n    uint8_t  packet_type;\n    uint8_t  flags;\n    uint16_t payload_length;\n    int16_t  checksum_offset;\n} PacketHeaderStruct;\n\nvoid receive_raw_packet_data(const uint8_t* data, uint32_t len) {\n    if (len > MAX_PACKET_BUFFER_SIZE) {\n        len = MAX_PACKET_BUFFER_SIZE;\n    }\n    memcpy(g_rx_packet_buffer, data, len);\n    g_current_rx_data_len = len;\n}\n\nvoid process_packet_payload(uint8_t* payload, uint16_t len) {\n    if (len > 0) {\n        volatile uint8_t first_byte = payload[0];\n        (void)first_byte;\n    }\n}\n\nvoid finalize_and_process_packet_vulnerable(void) {\n    if (g_current_rx_data_len < MIN_PACKET_HEADER_SIZE) {\n        return;\n    }\n\n    PacketHeaderStruct* header = (PacketHeaderStruct*)g_rx_packet_buffer;\n\n    uint16_t effective_payload_len = header->payload_length;\n    int16_t effective_checksum_offset = header->checksum_offset;\n\n    if (sizeof(PacketHeaderStruct) + effective_payload_len > g_current_rx_data_len ||\n        sizeof(PacketHeaderStruct) + effective_payload_len > MAX_PACKET_BUFFER_SIZE) {\n        return;\n    }\n    \n    uint8_t calculated_checksum = 0xAA;\n\n    int32_t target_byte_index = effective_checksum_offset;\n\n    g_rx_packet_buffer[target_byte_index] = calculated_checksum;\n\n    process_packet_payload(g_rx_packet_buffer + sizeof(PacketHeaderStruct), effective_payload_len);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define COMMAND_QUEUE_SIZE 10\n#define COMMAND_PAYLOAD_SIZE 16\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t payload[COMMAND_PAYLOAD_SIZE];\n} CommandPacket;\n\n#define META_BUFFER_SIZE 4\n#define CMD_QUEUE_START_OFFSET META_BUFFER_SIZE\n#define TOTAL_SYSTEM_MEMORY_SIZE (META_BUFFER_SIZE + sizeof(CommandPacket) * COMMAND_QUEUE_SIZE)\n\nstatic uint8_t g_system_memory_fixed[TOTAL_SYSTEM_MEMORY_SIZE];\nstatic uint16_t g_cmd_queue_head_fixed = 0;\nstatic uint16_t g_cmd_queue_count_fixed = 0;\n\nvoid init_command_system_fixed() {\n    memset(g_system_memory_fixed, 0, TOTAL_SYSTEM_MEMORY_SIZE);\n    g_cmd_queue_head_fixed = 0;\n    g_cmd_queue_count_fixed = 0;\n    g_system_memory_fixed[0] = 0xAA;\n    g_system_memory_fixed[1] = 0xBB;\n    g_system_memory_fixed[2] = 0xCC;\n    g_system_memory_fixed[3] = 0xDD;\n}\n\nbool enqueue_command_fixed(const CommandPacket* cmd) {\n    if (g_cmd_queue_count_fixed >= COMMAND_QUEUE_SIZE) {\n        return false;\n    }\n    uint16_t tail_idx = (g_cmd_queue_head_fixed + g_cmd_queue_count_fixed) % COMMAND_QUEUE_SIZE;\n    ((CommandPacket*)(g_system_memory_fixed + CMD_QUEUE_START_OFFSET))[tail_idx] = *cmd;\n    g_cmd_queue_count_fixed++;\n    return true;\n}\n\nvoid process_and_mark_command_fixed(uint8_t processed_status_val, int16_t status_offset_from_head) {\n    if (g_cmd_queue_count_fixed == 0) {\n        return;\n    }\n\n    uint16_t actual_cmd_idx = g_cmd_queue_head_fixed;\n\n    CommandPacket current_cmd = ((CommandPacket*)(g_system_memory_fixed + CMD_QUEUE_START_OFFSET))[actual_cmd_idx];\n    (void)current_cmd;\n\n    g_cmd_queue_head_fixed = (g_cmd_queue_head_fixed + 1) % COMMAND_QUEUE_SIZE;\n    g_cmd_queue_count_fixed--;\n\n    int32_t target_byte_offset_from_system_start = (int32_t)CMD_QUEUE_START_OFFSET + (int32_t)(actual_cmd_idx * sizeof(CommandPacket)) + status_offset_from_head;\n\n    if (target_byte_offset_from_system_start < 0 || target_byte_offset_from_system_start >= TOTAL_SYSTEM_MEMORY_SIZE) {\n        return;\n    }\n    \n    g_system_memory_fixed[target_byte_offset_from_system_start] = processed_status_val;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define LOG_CONTEXT_BUFFER_SIZE 64\n#define LOG_ENTRY_FOOTPRINT_SIZE 4\n\nstatic uint8_t g_log_context_buffer[LOG_CONTEXT_BUFFER_SIZE];\nstatic uint32_t g_current_log_end_ptr_offset = 0;\n\nvoid init_log_context() {\n    memset(g_log_context_buffer, 0, LOG_CONTEXT_BUFFER_SIZE);\n    g_current_log_end_ptr_offset = 0;\n}\n\nbool add_log_context_entry(uint32_t entry_value) {\n    if (g_current_log_end_ptr_offset + LOG_ENTRY_FOOTPRINT_SIZE > LOG_CONTEXT_BUFFER_SIZE) {\n        g_current_log_end_ptr_offset = 0;\n    }\n    g_log_context_buffer[g_current_log_end_ptr_offset + 0] = (uint8_t)(entry_value >> 24);\n    g_log_context_buffer[g_current_log_end_ptr_offset + 1] = (uint8_t)(entry_value >> 16);\n    g_log_context_buffer[g_current_log_end_ptr_offset + 2] = (uint8_t)(entry_value >> 8);\n    g_log_context_buffer[g_current_log_end_ptr_offset + 3] = (uint8_t)(entry_value);\n\n    g_current_log_end_ptr_offset += LOG_ENTRY_FOOTPRINT_SIZE;\n    return true;\n}\n\nvoid update_historical_log_context_vulnerable(int16_t offset_from_current, uint32_t new_context_value) {\n    if (g_current_log_end_ptr_offset == 0) {\n        return;\n    }\n    \n    int32_t target_byte_offset = (int32_t)g_current_log_end_ptr_offset - (offset_from_current * LOG_ENTRY_FOOTPRINT_SIZE);\n\n    g_log_context_buffer[target_byte_offset + 0] = (uint8_t)(new_context_value >> 24);\n    g_log_context_buffer[target_byte_offset + 1] = (uint8_t)(new_context_value >> 16);\n    g_log_context_buffer[target_byte_offset + 2] = (uint8_t)(new_context_value >> 8);\n    g_log_context_buffer[target_byte_offset + 3] = (uint8_t)(new_context_value);\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_ANOMALIES 64\n#define STATUS_BUFFER_START_OFFSET 10\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t sensor_id;\n    int32_t  value;\n    uint8_t  flags;\n} AnomalyEvent;\n\nstatic AnomalyEvent g_anomaly_events[MAX_ANOMALIES];\nstatic int g_num_anomalies = 0;\n\nstatic uint8_t g_event_processing_status[MAX_ANOMALIES + STATUS_BUFFER_START_OFFSET];\n\nvoid init_anomaly_system() {\n    memset(g_anomaly_events, 0, sizeof(g_anomaly_events));\n    memset(g_event_processing_status, 0, sizeof(g_event_processing_status));\n    g_num_anomalies = 0;\n}\n\nbool add_anomaly_event(uint32_t ts, uint16_t sid, int32_t val, uint8_t flgs) {\n    if (g_num_anomalies >= MAX_ANOMALIES) {\n        return false;\n    }\n    g_anomaly_events[g_num_anomalies].timestamp = ts;\n    g_anomaly_events[g_num_anomalies].sensor_id = sid;\n    g_anomaly_events[g_num_anomalies].value = val;\n    g_anomaly_events[g_num_anomalies].flags = flgs;\n    g_event_processing_status[STATUS_BUFFER_START_OFFSET + g_num_anomalies] = 0x01;\n    g_num_anomalies++;\n    return true;\n}\n\nstatic int find_anomaly_event_index(uint32_t ts, uint16_t sid) {\n    for (int i = 0; i < g_num_anomalies; ++i) {\n        if (g_anomaly_events[i].timestamp == ts && g_anomaly_events[i].sensor_id == sid) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid update_anomaly_status_property_fixed(uint32_t ts, uint16_t sid, int16_t offset_from_base_status, uint8_t new_value) {\n    int event_idx = find_anomaly_event_index(ts, sid);\n    if (event_idx == -1) {\n        return;\n    }\n\n    int base_status_idx = STATUS_BUFFER_START_OFFSET + event_idx;\n\n    int potential_target_status_idx = base_status_idx + offset_from_base_status;\n\n    if (potential_target_status_idx < 0 || potential_target_status_idx >= (MAX_ANOMALIES + STATUS_BUFFER_START_OFFSET)) {\n        return;\n    }\n\n    uint16_t target_status_idx = (uint16_t)potential_target_status_idx;\n\n    g_event_processing_status[target_status_idx] = new_value;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_PID_CONTROLLERS 5\n#define PID_PARAM_SET_SIZE sizeof(PID_Parameters)\n\ntypedef struct {\n    float Kp;\n    float Ki;\n    float Kd;\n    int32_t min_output;\n    int32_t max_output;\n    uint8_t loop_status;\n    uint8_t reserved[3];\n} PID_Parameters;\n\nstatic PID_Parameters g_pidConfigs[MAX_PID_CONTROLLERS];\n\nvoid initPIDControllers() {\n    for (int i = 0; i < MAX_PID_CONTROLLERS; ++i) {\n        g_pidConfigs[i].Kp = 0.0f;\n        g_pidConfigs[i].Ki = 0.0f;\n        g_pidConfigs[i].Kd = 0.0f;\n        g_pidConfigs[i].min_output = 0;\n        g_pidConfigs[i].max_output = 0;\n        g_pidConfigs[i].loop_status = 0;\n        memset(g_pidConfigs[i].reserved, 0, sizeof(g_pidConfigs[i].reserved));\n    }\n}\n\nint updatePIDParameter(const uint8_t* msg_data, uint16_t msg_len) {\n    if (msg_data == NULL || msg_len < 3) {\n        return -1;\n    }\n\n    uint8_t controller_id = msg_data[0];\n    uint8_t parameter_offset_bytes = msg_data[1];\n    uint16_t data_value_len = msg_len - 2;\n\n    if (controller_id >= MAX_PID_CONTROLLERS) {\n        return -2;\n    }\n\n    if ((uint16_t)parameter_offset_bytes + data_value_len > PID_PARAM_SET_SIZE) {\n        return -3;\n    }\n\n    memcpy((uint8_t*)&g_pidConfigs[controller_id] + parameter_offset_bytes, msg_data + 2, data_value_len);\n\n    return 0;\n}\n\nvoid handleVehicleConfigMessage(const uint8_t* network_data, uint16_t network_len) {\n    if (network_len < 3) {\n        return;\n    }\n    updatePIDParameter(network_data, network_len);\n}\n\nfloat getPIDKp(uint8_t id) {\n    if (id < MAX_PID_CONTROLLERS) {\n        return g_pidConfigs[id].Kp;\n    }\n    return 0.0f;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_DRIVING_PROFILES 10\n#define NUM_PROFILE_PARAMS 4\n\ntypedef struct {\n    uint16_t speed_limit;\n    uint8_t  throttle_response;\n    uint8_t  suspension_mode;\n    bool     traction_control_active;\n} DrivingProfile;\n\nstatic DrivingProfile g_drivingProfiles_fixed[MAX_DRIVING_PROFILES];\n\nstatic uint8_t g_currentActiveProfiles_fixed = 5;\n\ntypedef struct {\n    uint8_t command_type;\n    uint8_t profile_id;\n    DrivingProfile new_config;\n} DrivingModeCommand;\n\nvoid logVehicleError_fixed(const char* msg) {\n}\n\nDrivingModeCommand receiveDrivingModeCommand_fixed() {\n    DrivingModeCommand cmd;\n    cmd.command_type = 0x01;\n    cmd.profile_id = 7;\n    cmd.new_config.speed_limit = 180;\n    cmd.new_config.throttle_response = 0xFF;\n    cmd.new_config.suspension_mode = 0x02;\n    cmd.new_config.traction_control_active = false;\n    return cmd;\n}\n\nvoid initializeDrivingProfiles_fixed() {\n    for (uint8_t i = 0; i < MAX_DRIVING_PROFILES; ++i) {\n        g_drivingProfiles_fixed[i] = (DrivingProfile){0, 0, 0, false};\n    }\n    for (uint8_t i = 0; i < g_currentActiveProfiles_fixed; ++i) {\n        g_drivingProfiles_fixed[i].speed_limit = 120 + (i * 10);\n        g_drivingProfiles_fixed[i].throttle_response = 0x50 + (i * 0x10);\n        g_drivingProfiles_fixed[i].suspension_mode = i % 3;\n        g_drivingProfiles_fixed[i].traction_control_active = true;\n    }\n}\n\nvoid processDrivingModeCommand_fixed() {\n    DrivingModeCommand cmd = receiveDrivingModeCommand_fixed();\n\n    if (cmd.command_type == 0x01) {\n        if (cmd.profile_id < g_currentActiveProfiles_fixed) {\n            g_drivingProfiles_fixed[cmd.profile_id] = cmd.new_config;\n            logVehicleError_fixed(\"Driving profile updated successfully.\");\n        } else {\n            logVehicleError_fixed(\"Profile ID out of active profile bounds.\");\n        }\n    } else if (cmd.command_type == 0x02) {\n        if (cmd.profile_id < g_currentActiveProfiles_fixed) {\n            DrivingProfile queriedProfile = g_drivingProfiles_fixed[cmd.profile_id];\n            logVehicleError_fixed(\"Driving profile queried.\");\n        } else {\n            logVehicleError_fixed(\"Profile ID out of active profile bounds for query.\");\n        }\n    } else {\n        logVehicleError_fixed(\"Unknown driving mode command type.\");\n    }\n}\n\nvoid vehicleControlMain_fixed() {\n    initializeDrivingProfiles_fixed();\n    processDrivingModeCommand_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_MODES 4\n\ntypedef enum {\n    MODE_ECO = 0,\n    MODE_SPORT,\n    MODE_COMFORT,\n    MODE_OFFROAD,\n    MODE_COUNT\n} VehicleOperatingMode;\n\ntypedef struct {\n    uint16_t engine_power_limit_kW;\n    uint16_t battery_discharge_rate_A;\n    uint8_t throttle_response_curve_idx;\n    bool enable_regenerative_braking;\n} PowerManagementProfile;\n\nstatic PowerManagementProfile g_powerProfiles[MAX_VEHICLE_MODES];\n\nvoid logSystemStatus(const char* message) {\n}\n\ntypedef struct {\n    uint8_t command_type;\n    uint8_t requested_mode_id;\n    uint8_t reserved[6];\n} VehicleModeCommand;\n\nVehicleModeCommand receiveVehicleModeCommand_vulnerable() {\n    VehicleModeCommand cmd;\n    cmd.command_type = 0x01;\n    cmd.requested_mode_id = 5;\n    return cmd;\n}\n\nvoid initializePowerProfiles_vulnerable() {\n    g_powerProfiles[MODE_ECO] = (PowerManagementProfile){80, 50, 1, true};\n    g_powerProfiles[MODE_SPORT] = (PowerManagementProfile){150, 100, 3, true};\n    g_powerProfiles[MODE_COMFORT] = (PowerManagementProfile){100, 70, 2, true};\n    g_powerProfiles[MODE_OFFROAD] = (PowerManagementProfile){120, 80, 2, false};\n    logSystemStatus(\"Power profiles initialized (vulnerable).\");\n}\n\nvoid activateVehicleMode_vulnerable() {\n    VehicleModeCommand cmd = receiveVehicleModeCommand_vulnerable();\n\n    if (cmd.command_type == 0x01) {\n        PowerManagementProfile selectedProfile = g_powerProfiles[cmd.requested_mode_id];\n\n        logSystemStatus(\"Applying selected power profile (vulnerable).\");\n        if (selectedProfile.enable_regenerative_braking) {\n        } else {\n        }\n    } else {\n        logSystemStatus(\"Invalid command type received (vulnerable).\");\n    }\n}\n\nvoid vehicleEMU_vulnerable_main() {\n    initializePowerProfiles_vulnerable();\n    activateVehicleMode_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n// Define CAN message IDs for specific diagnostic services\n#define CAN_ID_CONFIG_UPDATE_SERVICE 0x18F00100\n#define CAN_ID_STATUS_REQUEST_SERVICE 0x18F00200\n\n// Maximum number of configurable parameters\n#define MAX_CONFIG_PARAMETERS 64\n\n// Structure for a single configurable parameter entry\ntypedef struct {\n    uint8_t id;\n    uint8_t value;\n    uint8_t type; \n} ConfigParameterEntry;\n\n// Main ECU configuration storage\nstatic ConfigParameterEntry ecu_config_store[MAX_CONFIG_PARAMETERS];\n\n// Initializes the ECU configuration store with default values\nvoid init_ecu_config_store() {\n    for (int i = 0; i < MAX_CONFIG_PARAMETERS; ++i) {\n        ecu_config_store[i].id = (uint8_t)i;\n        ecu_config_store[i].value = 0x00;\n        ecu_config_store[i].type = 0x00; \n    }\n}\n\n// Function to process a CAN diagnostic message payload\n// This function assumes the msg_id has already been validated to be a config update service.\n// The payload format for config update: [param_index_byte][param_value_byte]\n// This service allows setting a single parameter at a time.\nint process_config_update_payload(const uint8_t* payload, uint8_t payload_len) {\n    if (payload == NULL || payload_len < 2) {\n        return -1; \n    }\n\n    uint8_t param_idx_received = payload[0]; \n    uint8_t new_param_value = payload[1];\n\n    // The vulnerability: No bounds check on param_idx_received.\n    // An attacker can send param_idx_received >= MAX_CONFIG_PARAMETERS\n    // to write to memory outside ecu_config_store.\n    ecu_config_store[param_idx_received].value = new_param_value;\n\n    return 0; \n}\n\n// Main entry point for processing incoming CAN messages\n// This function would typically be called by a CAN driver interrupt or polling loop.\nint handle_can_diagnostic_message(uint32_t can_id, const uint8_t* data_bytes, uint8_t data_len) {\n    if (data_bytes == NULL || data_len == 0) {\n        return -1; \n    }\n\n    switch (can_id) {\n        case CAN_ID_CONFIG_UPDATE_SERVICE:\n            return process_config_update_payload(data_bytes, data_len);\n        case CAN_ID_STATUS_REQUEST_SERVICE:\n            // Placeholder for status request handling logic\n            return 0;\n        default:\n            return -99; \n    }\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define EVENT_LOG_SIZE 256 \n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t event_type_id;\n    uint16_t metadata_flags;\n} VehicleEventEntry;\n\nstatic VehicleEventEntry g_event_log[EVENT_LOG_SIZE];\nstatic uint32_t g_current_log_head = 0; \nstatic bool g_log_wrapped = false; \n\nvoid init_event_logger_vulnerable() {\n    memset(g_event_log, 0, sizeof(g_event_log));\n    g_current_log_head = 0;\n    g_log_wrapped = false;\n}\n\nvoid log_vehicle_event_vulnerable(uint16_t type_id, uint32_t current_timestamp) {\n    g_event_log[g_current_log_head].timestamp_ms = current_timestamp;\n    g_event_log[g_current_log_head].event_type_id = type_id;\n    g_event_log[g_current_log_head].metadata_flags = 0; \n\n    g_current_log_head++;\n    if (g_current_log_head >= EVENT_LOG_SIZE) {\n        g_current_log_head = 0;\n        g_log_wrapped = true;\n    }\n}\n\nvoid mark_historical_event_vulnerable(uint32_t offset_from_head, uint16_t marker_flag) {\n    if (offset_from_head >= EVENT_LOG_SIZE && !g_log_wrapped) {\n        return; \n    }\n\n    int32_t target_logical_idx = (int32_t)g_current_log_head - 1 - (int32_t)offset_from_head;\n\n    g_event_log[target_logical_idx].metadata_flags |= marker_flag;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_EVENT_RECORDS 10\n#define MAX_EVENT_DATA_LEN 60 \n#define EVENT_LOG_BUFFER_SIZE (MAX_EVENT_RECORDS * (sizeof(EventRecordHeader) + MAX_EVENT_DATA_LEN))\n\ntypedef struct {\n    uint8_t event_type;\n    uint8_t data_len;\n} EventRecordHeader;\n\nstatic uint8_t g_eventLogBuffer[EVENT_LOG_BUFFER_SIZE];\nstatic uint16_t g_currentLogWriteOffset = 0;\n\nvoid initEventLog(void) {\n    memset(g_eventLogBuffer, 0, EVENT_LOG_BUFFER_SIZE);\n    g_currentLogWriteOffset = 0;\n}\n\nint addEventToLog(const uint8_t* raw_event_data, uint16_t event_total_len) {\n    if (raw_event_data == NULL || event_total_len < sizeof(EventRecordHeader)) {\n        return -1;\n    }\n\n    uint8_t received_event_type = raw_event_data[0];\n    uint8_t received_data_len = raw_event_data[1];\n\n    if (received_data_len > MAX_EVENT_DATA_LEN) {\n        return -2;\n    }\n\n    if (sizeof(EventRecordHeader) + received_data_len > event_total_len) {\n        return -3;\n    }\n\n    uint16_t record_packed_size = sizeof(EventRecordHeader) + received_data_len;\n\n    if (g_currentLogWriteOffset + record_packed_size > EVENT_LOG_BUFFER_SIZE) {\n        return -4;\n    }\n\n    g_eventLogBuffer[g_currentLogWriteOffset] = received_event_type;\n    g_currentLogWriteOffset++;\n    g_eventLogBuffer[g_currentLogWriteOffset] = received_data_len;\n    g_currentLogWriteOffset++;\n\n    for (uint8_t i = 0; i < received_data_len; ++i) {\n        g_eventLogBuffer[g_currentLogWriteOffset + i] = raw_event_data[sizeof(EventRecordHeader) + i];\n    }\n    g_currentLogWriteOffset += received_data_len;\n\n    return 0;\n}\n\nvoid processIncomingEventStream(const uint8_t* data, uint16_t len) {\n    addEventToLog(data, len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CALIBRATION_SIZE 512\n#define MAX_PROTOCOL_DATA_LENGTH 128\n#define MAX_PACKET_PROCESS_SIZE 64\n\nstatic uint8_t g_calibrationTable[MAX_CALIBRATION_SIZE];\nstatic uint8_t g_packetProcessingBuffer[MAX_PACKET_PROCESS_SIZE];\n\nvoid initCalibrationSystem() {\n    memset(g_calibrationTable, 0xFF, MAX_CALIBRATION_SIZE);\n    memset(g_packetProcessingBuffer, 0x00, MAX_PACKET_PROCESS_SIZE);\n}\n\ntypedef struct {\n    uint16_t table_id;\n    uint16_t start_offset;\n    uint8_t  data_len;\n    const uint8_t* payload;\n} CalibrationUpdateCommand;\n\nint processCalibrationUpdate(const CalibrationUpdateCommand* cmd) {\n    if (cmd == NULL || cmd->payload == NULL) {\n        return -1;\n    }\n\n    if (cmd->table_id != 0) {\n        return -2;\n    }\n\n    if (cmd->data_len > MAX_PROTOCOL_DATA_LENGTH || cmd->data_len == 0) {\n        return -3;\n    }\n\n    if (cmd->data_len > MAX_PACKET_PROCESS_SIZE) {\n        return -5;\n    }\n\n    if (cmd->start_offset + cmd->data_len > MAX_CALIBRATION_SIZE) {\n        return -4;\n    }\n    \n    for (uint8_t i = 0; i < cmd->data_len; ++i) {\n        g_packetProcessingBuffer[i] = cmd->payload[i];\n    }\n\n    for (uint8_t i = 0; i < cmd->data_len; ++i) {\n        g_calibrationTable[cmd->start_offset + i] = g_packetProcessingBuffer[i];\n    }\n\n    return 0;\n}\n\nint receiveAndProcessCalibrationMessage(uint16_t table_id, uint16_t offset, uint8_t len, const uint8_t* data) {\n    CalibrationUpdateCommand cmd;\n    cmd.table_id = table_id;\n    cmd.start_offset = offset;\n    cmd.data_len = len;\n    cmd.payload = data;\n    return processCalibrationUpdate(&cmd);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAG_HISTORY_CAPACITY 50\n#define DIAG_REQ_DATA_MAX_SIZE 24\n\ntypedef struct {\n    uint32_t request_id;\n    uint32_t timestamp_ms;\n    uint8_t  request_data[DIAG_REQ_DATA_MAX_SIZE];\n    uint8_t  data_len;\n    bool     processed;\n} DiagRequestEntry;\n\nstatic DiagRequestEntry g_diag_history[DIAG_HISTORY_CAPACITY];\nstatic size_t g_current_history_size = 0;\n\nvoid init_diag_history() {\n    memset(g_diag_history, 0, sizeof(g_diag_history));\n    g_current_history_size = 0;\n}\n\nvoid add_diag_request(uint32_t id, uint32_t timestamp, const uint8_t* data, uint8_t len) {\n    if (g_current_history_size < DIAG_HISTORY_CAPACITY) {\n        DiagRequestEntry* target_entry = &g_diag_history[g_current_history_size];\n        target_entry->request_id = id;\n        target_entry->timestamp_ms = timestamp;\n        uint8_t actual_len = (len > DIAG_REQ_DATA_MAX_SIZE) ? DIAG_REQ_DATA_MAX_SIZE : len;\n        memcpy(target_entry->request_data, data, actual_len);\n        target_entry->data_len = actual_len;\n        target_entry->processed = false;\n        g_current_history_size++;\n    }\n}\n\nvoid archive_recent_diag_requests_fixed(uint16_t steps_to_archive) {\n    if (g_current_history_size == 0 || steps_to_archive == 0) {\n        return;\n    }\n\n    uint16_t actual_steps_to_archive = (steps_to_archive > g_current_history_size) ? (uint16_t)g_current_history_size : steps_to_archive;\n\n    DiagRequestEntry* current_entry_ptr = &g_diag_history[g_current_history_size - 1];\n\n    for (uint16_t i = 0; i < actual_steps_to_archive; ++i) {\n        current_entry_ptr->processed = true;\n        memset(current_entry_ptr->request_data, 0, DIAG_REQ_DATA_MAX_SIZE);\n        current_entry_ptr--;\n    }\n\n    g_current_history_size -= actual_steps_to_archive;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <algorithm>\n\n// Define types for clarity\ntypedef uint8_t TelemetryBlockType;\n\n// Telemetry Block Types\nconst TelemetryBlockType TYPE_RAW_SENSOR_DATA = 0x01;\nconst TelemetryBlockType TYPE_TEXT_MESSAGE = 0x02;\nconst TelemetryBlockType TYPE_EVENT_CODE = 0x03;\n\nstruct TelemetryBlockHeader {\n    TelemetryBlockType block_type;\n    uint16_t block_id;\n    uint16_t data_length; // Length of the data payload following this header\n};\n\nclass TelemetryDataBufferVulnerable {\npublic:\n    TelemetryDataBufferVulnerable(size_t initial_capacity = 256)\n        : m_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {\n        if (initial_capacity > 0) {\n            m_buffer = (uint8_t*)malloc(initial_capacity);\n            if (m_buffer) {\n                m_allocated_capacity = initial_capacity;\n            }\n        }\n    }\n\n    ~TelemetryDataBufferVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    // Appends a telemetry block to the internal buffer.\n    // The vulnerability lies here: When TYPE_RAW_SENSOR_DATA is processed,\n    // data_length bytes are received, but they are converted to 2*data_length hex characters.\n    // The buffer resizing logic only accounts for data_length *in bytes* for the\n    // space needed for the raw sensor data, leading to an overflow when the hex characters are written.\n    bool appendTelemetryBlockVulnerable(const TelemetryBlockHeader* header, const uint8_t* payload) {\n        if (!header || !payload || header->data_length == 0) {\n            return false;\n        }\n\n        size_t block_header_size = sizeof(TelemetryBlockHeader);\n        size_t effective_payload_size = 0; // The actual size needed in the buffer for the payload\n\n        switch (header->block_type) {\n            case TYPE_RAW_SENSOR_DATA:\n                // Raw sensor data will be converted to hex string (2 chars per byte)\n                // VULNERABILITY: The realloc calculation below does NOT account for this expansion.\n                // It treats `header->data_length` as the size needed, not `2 * header->data_length`.\n                effective_payload_size = header->data_length; \n                break;\n            case TYPE_TEXT_MESSAGE:\n            case TYPE_EVENT_CODE:\n                // For text or event codes, it's a direct byte copy, plus null terminator\n                effective_payload_size = header->data_length + 1; // +1 for null terminator\n                break;\n            default:\n                return false; // Unknown type\n        }\n\n        size_t total_space_needed_for_this_block = block_header_size + effective_payload_size;\n\n        // Basic check for potential integer overflow in size calculation before addition\n        if (m_current_size > (~(size_t)0) - total_space_needed_for_this_block) {\n            return false;\n        }\n\n        // Check if current buffer has enough space. If not, reallocate.\n        if (m_current_size + total_space_needed_for_this_block > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity == 0 ? total_space_needed_for_this_block : m_allocated_capacity * 2;\n            // Ensure new_capacity is at least what's needed and doesn't overflow during doubling\n            if (m_allocated_capacity > (~(size_t)0) / 2 && m_allocated_capacity != 0) {\n                new_capacity = (~(size_t)0);\n            }\n            if (new_capacity < m_current_size + total_space_needed_for_this_block) {\n                new_capacity = m_current_size + total_space_needed_for_this_block;\n            }\n            \n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_capacity);\n            if (!new_buffer) {\n                if (m_buffer) {\n                    free(m_buffer);\n                    m_buffer = nullptr;\n                }\n                m_current_size = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        if (!m_buffer) {\n            return false;\n        }\n\n        // Copy header\n        memcpy(m_buffer + m_current_size, header, block_header_size);\n        m_current_size += block_header_size;\n\n        // Copy payload based on type\n        switch (header->block_type) {\n            case TYPE_RAW_SENSOR_DATA: {\n                // Convert each byte to two hex characters\n                // This is where the overflow happens: `m_current_size` has only been incremented\n                // by `header->data_length` in the effective_payload_size calculation, \n                // but we write `header->data_length * 2` characters.\n                for (uint16_t i = 0; i < header->data_length; ++i) {\n                    uint8_t byte_val = payload[i];\n                    // VULNERABLE WRITE: No bounds check here for the conversion output\n                    // The allocated space was only for `header->data_length` for this payload,\n                    // but we are writing 2 characters per byte.\n                    m_buffer[m_current_size++] = (byte_val >> 4) < 10 ? ('0' + (byte_val >> 4)) : ('A' + (byte_val >> 4) - 10);\n                    m_buffer[m_current_size++] = (byte_val & 0x0F) < 10 ? ('0' + (byte_val & 0x0F)) : ('A' + (byte_val & 0x0F) - 10);\n                }\n                break;\n            }\n            case TYPE_TEXT_MESSAGE:\n            case TYPE_EVENT_CODE: {\n                memcpy(m_buffer + m_current_size, payload, header->data_length);\n                m_current_size += header->data_length;\n                m_buffer[m_current_size++] = '\\0'; // Null terminate\n                break;\n            }\n            default:\n                return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getBuffer() const { return m_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n\n    // Helper to convert nibble to hex char (0-9, A-F)\n    char nibbleToHex(uint8_t nibble) {\n        if (nibble < 10) {\n            return '0' + nibble;\n        } else {\n            return 'A' + (nibble - 10);\n        }\n    }\n};", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_SENSOR_PROFILES 4\n#define SENSOR_PROFILE_BUFFER_SIZE 64\n#define MAX_CALIBRATION_PAYLOAD_SIZE 32\n\nstatic uint8_t g_sensorCalibrationProfiles[NUM_SENSOR_PROFILES][SENSOR_PROFILE_BUFFER_SIZE];\n\nvoid initSensorCalibrationProfiles() {\n    for (int i = 0; i < NUM_SENSOR_PROFILES; ++i) {\n        memset(g_sensorCalibrationProfiles[i], 0x00, SENSOR_PROFILE_BUFFER_SIZE);\n        g_sensorCalibrationProfiles[i][0] = i;\n    }\n}\n\ntypedef struct {\n    uint8_t  profile_index;\n    uint8_t  data_offset;\n    uint8_t  data_length;\n    uint8_t  payload[MAX_CALIBRATION_PAYLOAD_SIZE];\n} SensorCalibrationUpdateMsg;\n\nint applyCalibrationUpdate(const SensorCalibrationUpdateMsg* msg) {\n    if (msg == NULL) {\n        return -1;\n    }\n\n    uint8_t profile_idx = msg->profile_index;\n    uint8_t offset = msg->data_offset;\n    uint8_t length = msg->data_length;\n    const uint8_t* data = msg->payload;\n\n    if (profile_idx >= NUM_SENSOR_PROFILES) {\n        return -2;\n    }\n\n    if (length == 0 || length > MAX_CALIBRATION_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    if (offset >= SENSOR_PROFILE_BUFFER_SIZE) {\n        return -4;\n    }\n\n    if ((uint16_t)offset + length > SENSOR_PROFILE_BUFFER_SIZE) {\n        return -5;\n    }\n\n    for (uint8_t i = 0; i < length; ++i) {\n        g_sensorCalibrationProfiles[profile_idx][offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid simulateCalibrationMessage(uint8_t p_idx, uint8_t off, uint8_t len, const uint8_t* payload_data) {\n    SensorCalibrationUpdateMsg msg;\n    msg.profile_index = p_idx;\n    msg.data_offset = off;\n    msg.data_length = len;\n    if (len > MAX_CALIBRATION_PAYLOAD_SIZE) {\n        len = MAX_CALIBRATION_PAYLOAD_SIZE; \n    }\n    for (uint8_t i = 0; i < len; ++i) {\n        msg.payload[i] = payload_data[i];\n    }\n    applyCalibrationUpdate(&msg);\n}\n\nuint8_t getCalibrationByte(uint8_t profile_idx, uint8_t offset) {\n    if (profile_idx < NUM_SENSOR_PROFILES && offset < SENSOR_PROFILE_BUFFER_SIZE) {\n        return g_sensorCalibrationProfiles[profile_idx][offset];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_SUBSYSTEMS 5\n#define MAX_COMMANDS_PER_SUBSYSTEM 10\n#define MAX_PAYLOAD_SIZE 8\n\nvoid logSystemEvent(const char* event_msg) {\n}\n\nvoid logSecurityAlert(const char* alert_msg) {\n}\n\nvoid handleEngineCommand1(const uint8_t* data, uint32_t len) {\n    logSystemEvent(\"EngineCmd1: Processing engine status request.\");\n}\n\nvoid handleEngineCommand2(const uint8_t* data, uint32_t len) {\n    logSystemEvent(\"EngineCmd2: Adjusting ignition timing.\");\n}\n\nvoid handleBrakeCommand1(const uint8_t* data, uint32_t len) {\n    logSystemEvent(\"BrakeCmd1: Calibrating ABS sensors.\");\n}\n\nvoid handleBrakeCommand2(const uint8_t* data, uint32_t len) {\n    logSystemEvent(\"BrakeCmd2: Activating emergency braking.\");\n}\n\nvoid handleInvalidCommand(const uint8_t* data, uint32_t len) {\n    logSecurityAlert(\"Invalid/Unsupported command handler invoked.\");\n}\n\ntypedef void (*CommandHandler)(const uint8_t*, uint32_t);\n\nstatic CommandHandler g_subsystemCommandHandlers_vulnerable[MAX_SUBSYSTEMS][MAX_COMMANDS_PER_SUBSYSTEM];\nstatic uint8_t g_actualCommandsPerSubsystem_vulnerable[MAX_SUBSYSTEMS];\n\ntypedef struct {\n    uint8_t subsystem_id;\n    uint8_t command_id;\n    uint32_t data_len;\n    uint8_t payload[MAX_PAYLOAD_SIZE];\n} IncomingVehicleCommand;\n\nIncomingVehicleCommand receiveIncomingCommand_Vulnerable() {\n    IncomingVehicleCommand cmd;\n    cmd.subsystem_id = 0; \n    cmd.command_id = 5;  \n    cmd.data_len = 2;\n    cmd.payload[0] = 0xAA;\n    cmd.payload[1] = 0xBB;\n    return cmd;\n}\n\nvoid initializeCommandHandlers_Vulnerable() {\n    for (uint8_t i = 0; i < MAX_SUBSYSTEMS; ++i) {\n        g_actualCommandsPerSubsystem_vulnerable[i] = 0;\n        for (uint8_t j = 0; j < MAX_COMMANDS_PER_SUBSYSTEM; ++j) {\n            g_subsystemCommandHandlers_vulnerable[i][j] = handleInvalidCommand;\n        }\n    }\n\n    g_subsystemCommandHandlers_vulnerable[0][0] = handleEngineCommand1;\n    g_subsystemCommandHandlers_vulnerable[0][1] = handleEngineCommand2;\n    g_actualCommandsPerSubsystem_vulnerable[0] = 2;\n\n    g_subsystemCommandHandlers_vulnerable[1][0] = handleBrakeCommand1;\n    g_subsystemCommandHandlers_vulnerable[1][1] = handleBrakeCommand2;\n    g_actualCommandsPerSubsystem_vulnerable[1] = 2;\n}\n\nvoid processVehicleCommand_Vulnerable() {\n    IncomingVehicleCommand cmd = receiveIncomingCommand_Vulnerable();\n\n    if (cmd.subsystem_id < MAX_SUBSYSTEMS) {\n        if (cmd.command_id < MAX_COMMANDS_PER_SUBSYSTEM) {\n            CommandHandler handler = g_subsystemCommandHandlers_vulnerable[cmd.subsystem_id][cmd.command_id];\n            handler(cmd.payload, cmd.data_len);\n        } else {\n            logSystemEvent(\"Command ID exceeds global max for any subsystem.\");\n            handleInvalidCommand(cmd.payload, cmd.data_len);\n        }\n    } else {\n        logSystemEvent(\"Subsystem ID out of bounds.\");\n        handleInvalidCommand(cmd.payload, cmd.data_len);\n    }\n}\n\nvoid automotiveECULoop_Vulnerable() {\n    initializeCommandHandlers_Vulnerable();\n    logSystemEvent(\"Vulnerable ECU started.\");\n    processVehicleCommand_Vulnerable();\n    logSystemEvent(\"Vulnerable ECU finished processing command.\");\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define MAX_SENSOR_DATA_POINTS 128\n#define EVENT_DATA_SIZE 8\n\ntypedef struct {\n    uint16_t value;\n    uint16_t checksum;\n    uint8_t  event_data[EVENT_DATA_SIZE];\n} SensorDataPoint;\n\nstatic SensorDataPoint g_sensor_history[MAX_SENSOR_DATA_POINTS];\nstatic uint32_t g_num_history_points = 0;\nstatic int16_t g_current_engine_calibration = 100;\n\nvoid init_sensor_history_fixed() {\n    memset(g_sensor_history, 0, sizeof(g_sensor_history));\n    g_num_history_points = 0;\n    g_current_engine_calibration = 100;\n}\n\nvoid add_sensor_reading_fixed(uint16_t value, uint16_t checksum, const uint8_t* event_data) {\n    if (g_num_history_points < MAX_SENSOR_DATA_POINTS) {\n        g_sensor_history[g_num_history_points].value = value;\n        g_sensor_history[g_num_history_points].checksum = checksum;\n        memcpy(g_sensor_history[g_num_history_points].event_data, event_data, EVENT_DATA_SIZE);\n        g_num_history_points++;\n    } else {\n        for (uint32_t i = 0; i < MAX_SENSOR_DATA_POINTS - 1; ++i) {\n            g_sensor_history[i] = g_sensor_history[i+1];\n        }\n        g_sensor_history[MAX_SENSOR_DATA_POINTS - 1].value = value;\n        g_sensor_history[MAX_SENSOR_DATA_POINTS - 1].checksum = checksum;\n        memcpy(g_sensor_history[MAX_SENSOR_DATA_POINTS - 1].event_data, event_data, EVENT_DATA_SIZE);\n    }\n}\n\nvoid perform_data_analysis_fixed(SensorDataPoint* data_point) {\n    if (data_point != NULL) {\n        if (data_point->value > 500 && data_point->checksum == (uint16_t)(data_point->value ^ 0xFFFF)) {\n            g_current_engine_calibration += 5;\n        } else {\n            g_current_engine_calibration -= 1;\n        }\n    }\n}\n\nvoid calibrate_historical_readings_fixed(int32_t offset_from_current, uint32_t num_to_adjust, uint16_t new_value) {\n    if (g_num_history_points == 0 || num_to_adjust == 0) {\n        return;\n    }\n\n    int32_t calculated_start_idx = (int32_t)g_num_history_points - 1 - offset_from_current;\n\n    uint32_t actual_start_idx;\n    if (calculated_start_idx < 0) {\n        actual_start_idx = 0;\n    } else {\n        actual_start_idx = (uint32_t)calculated_start_idx;\n    }\n\n    uint32_t available_from_start_to_end = g_num_history_points - actual_start_idx;\n    uint32_t actual_num_to_adjust = (num_to_adjust > available_from_start_to_end) ? available_from_start_to_end : num_to_adjust;\n\n    for (uint32_t i = 0; i < actual_num_to_adjust; ++i) {\n        g_sensor_history[actual_start_idx + i].value = new_value;\n        g_sensor_history[actual_start_idx + i].checksum = (uint16_t)(new_value ^ 0xFFFF);\n    }\n\n    if (g_num_history_points > 0) {\n        perform_data_analysis_fixed(&g_sensor_history[g_num_history_points - 1]);\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define FIRMWARE_STAGING_BUFFER_SIZE 2048 \n#define MAX_FW_PACKAGE_SIZE 4096 \n#define MAX_FW_BLOCKS 16 \n\ntypedef struct {\n    uint16_t block_id;\n    uint16_t block_offset; \n    uint16_t block_length;\n} FirmwareBlockDescriptor;\n\ntypedef struct {\n    uint16_t total_data_length; \n    uint8_t num_blocks;\n} FirmwarePackageHeader;\n\nstatic uint8_t g_firmwareStagingBuffer[FIRMWARE_STAGING_BUFFER_SIZE];\nstatic uint16_t g_stagingWritePointer = 0; \n\nvoid initFirmwareStagingSystem() {\n    memset(g_firmwareStagingBuffer, 0, FIRMWARE_STAGING_BUFFER_SIZE);\n    g_stagingWritePointer = 0;\n}\n\nint processFirmwareUpdatePackage(const uint8_t* package_payload, uint16_t payload_len) {\n    if (package_payload == NULL || payload_len < sizeof(FirmwarePackageHeader)) {\n        return -1; \n    }\n\n    FirmwarePackageHeader header;\n    header.total_data_length = (uint16_t)(package_payload[0] << 8 | package_payload[1]);\n    header.num_blocks = package_payload[2];\n\n    if (payload_len < sizeof(FirmwarePackageHeader) + (header.num_blocks * sizeof(FirmwareBlockDescriptor))) {\n        return -2; \n    }\n    if (header.num_blocks > MAX_FW_BLOCKS) {\n        return -3; \n    }\n\n    uint16_t descriptor_offset = sizeof(FirmwarePackageHeader);\n    uint16_t data_offset = descriptor_offset + (header.num_blocks * sizeof(FirmwareBlockDescriptor));\n\n    if (data_offset + header.total_data_length > payload_len) {\n        return -4; \n    }\n\n    g_stagingWritePointer = 0; \n\n    for (uint8_t i = 0; i < header.num_blocks; ++i) {\n        uint16_t current_descriptor_pos = descriptor_offset + (i * sizeof(FirmwareBlockDescriptor));\n        if (current_descriptor_pos + sizeof(FirmwareBlockDescriptor) > payload_len) {\n            return -5; \n        }\n\n        FirmwareBlockDescriptor block_desc;\n        block_desc.block_id = (uint16_t)(package_payload[current_descriptor_pos] << 8 | package_payload[current_descriptor_pos + 1]);\n        block_desc.block_offset = (uint16_t)(package_payload[current_descriptor_pos + 2] << 8 | package_payload[current_descriptor_pos + 3]);\n        block_desc.block_length = (uint16_t)(package_payload[current_descriptor_pos + 4] << 8 | package_payload[current_descriptor_pos + 5]);\n\n        if (block_desc.block_offset + block_desc.block_length > header.total_data_length) {\n            return -6; \n        }\n        if (data_offset + block_desc.block_offset + block_desc.block_length > payload_len) {\n            return -7; \n        }\n\n        if (g_stagingWritePointer + block_desc.block_length > FIRMWARE_STAGING_BUFFER_SIZE) {\n            return -8;\n        }\n\n        for (uint16_t j = 0; j < block_desc.block_length; ++j) {\n            g_firmwareStagingBuffer[g_stagingWritePointer] = package_payload[data_offset + block_desc.block_offset + j];\n            g_stagingWritePointer++;\n        }\n    }\n\n    return 0; \n}\n\nvoid receiveFirmwarePackage(const uint8_t* data, uint16_t length) {\n    initFirmwareStagingSystem();\n    processFirmwareUpdatePackage(data, length);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdlib.h>\n#include <stdint.h>\n\n#define MAX_ERROR_DESC_LEN 64\n\ntypedef struct {\n    uint32_t errorCode;\n    uint8_t severity;\n    char description[MAX_ERROR_DESC_LEN];\n} DiagnosticErrorEntry;\n\nclass ErrorLogManager {\npublic:\n    ErrorLogManager() : current_capacity(0), num_errors(0), error_entries(NULL) {\n        current_capacity = 4;\n        error_entries = (DiagnosticErrorEntry*)malloc(current_capacity * sizeof(DiagnosticErrorEntry));\n        if (!error_entries) {\n            // Handle allocation failure\n        }\n    }\n\n    ~ErrorLogManager() {\n        if (error_entries) {\n            free(error_entries);\n            error_entries = NULL;\n        }\n    }\n\n    bool addErrorEntryFixed(uint32_t code, uint8_t sev, const char* desc) {\n        if (!desc) {\n            return false;\n        }\n\n        if (num_errors >= current_capacity) {\n            size_t new_capacity = current_capacity * 2;\n            // Defensive check for potential integer overflow in 'new_capacity' calculation\n            if (new_capacity <= current_capacity) { \n                return false; \n            }\n            DiagnosticErrorEntry* new_entries = (DiagnosticErrorEntry*)realloc(error_entries, new_capacity * sizeof(DiagnosticErrorEntry));\n            if (!new_entries) {\n                return false;\n            }\n            error_entries = new_entries;\n            current_capacity = new_capacity;\n        }\n\n        error_entries[num_errors].errorCode = code;\n        error_entries[num_errors].severity = sev;\n\n        size_t desc_idx = 0;\n        // Fixed: Added bounds check for 'desc_idx' to ensure it doesn't exceed 'MAX_ERROR_DESC_LEN - 1'\n        // This ensures space for the null terminator and prevents heap overflow.\n        while (desc[desc_idx] != '\\0' && desc_idx < MAX_ERROR_DESC_LEN - 1) {\n            error_entries[num_errors].description[desc_idx] = desc[desc_idx];\n            desc_idx++;\n        }\n        // Always null-terminate within bounds, potentially truncating the string\n        error_entries[num_errors].description[desc_idx] = '\\0';\n\n        num_errors++;\n        return true;\n    }\n\nprivate:\n    size_t current_capacity;\n    size_t num_errors;\n    DiagnosticErrorEntry* error_entries;\n};\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_SENSORS 5\n\ntypedef enum {\n    SENSOR_TYPE_PRESSURE = 0,\n    SENSOR_TYPE_TEMPERATURE,\n    SENSOR_TYPE_ACCELEROMETER,\n    SENSOR_TYPE_GYROSCOPE,\n    SENSOR_TYPE_VOLTAGE\n} SensorType;\n\ntypedef struct {\n    float offset;\n    float gain;\n} SensorCalibrationParams;\n\nstatic SensorCalibrationParams g_sensorCalibrationData[MAX_SENSORS];\n\nvoid logError(const char* msg) {\n}\n\nvoid initializeSensorCalibrations_fixed() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        g_sensorCalibrationData[i].offset = 0.0f;\n        g_sensorCalibrationData[i].gain = 1.0f;\n    }\n}\n\ntypedef struct {\n    uint8_t sensor_type_id;\n    float new_offset;\n    float new_gain;\n} SensorCalibrationCommand;\n\nSensorCalibrationCommand receiveCalibrationCommand_fixed() {\n    SensorCalibrationCommand cmd;\n    cmd.sensor_type_id = MAX_SENSORS;\n    cmd.new_offset = 12.34f;\n    cmd.new_gain = 5.67f;\n    return cmd;\n}\n\nvoid processSensorCalibrationCommand_fixed() {\n    SensorCalibrationCommand cmd = receiveCalibrationCommand_fixed();\n\n    if (cmd.sensor_type_id < MAX_SENSORS) {\n        g_sensorCalibrationData[cmd.sensor_type_id].offset = cmd.new_offset;\n        g_sensorCalibrationData[cmd.sensor_type_id].gain = cmd.new_gain;\n        logError(\"Sensor calibration updated (fixed).\");\n    } else {\n        logError(\"Invalid sensor type ID received for calibration. Ignoring command.\");\n    }\n}\n\nvoid automotiveCalibrationService_fixed() {\n    initializeSensorCalibrations_fixed();\n    processSensorCalibrationCommand_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define TELEMETRY_BUFFER_CAPACITY 32\n#define TELEMETRY_PACKET_SIZE 16\n\ntypedef struct {\n    uint32_t timestamp;\n    uint8_t  packet_data[TELEMETRY_PACKET_SIZE - sizeof(uint32_t)];\n} TelemetryPacket;\n\nstatic TelemetryPacket g_telemetry_buffer[TELEMETRY_BUFFER_CAPACITY];\nstatic uint16_t g_telemetry_write_idx = 0;\nstatic uint16_t g_telemetry_count = 0;\n\nvoid init_telemetry_buffer() {\n    memset(g_telemetry_buffer, 0, sizeof(g_telemetry_buffer));\n    g_telemetry_write_idx = 0;\n    g_telemetry_count = 0;\n}\n\nvoid store_telemetry_packet(uint32_t timestamp, const uint8_t* data) {\n    if (data == NULL) return;\n\n    g_telemetry_buffer[g_telemetry_write_idx].timestamp = timestamp;\n    memcpy(g_telemetry_buffer[g_telemetry_write_idx].packet_data, data, TELEMETRY_PACKET_SIZE - sizeof(uint32_t));\n\n    g_telemetry_write_idx = (g_telemetry_write_idx + 1) % TELEMETRY_BUFFER_CAPACITY;\n    if (g_telemetry_count < TELEMETRY_BUFFER_CAPACITY) {\n        g_telemetry_count++;\n    }\n}\n\nvoid set_review_index_from_oldest_vulnerable(uint16_t num_steps_back) {\n    if (g_telemetry_count == 0) {\n        return;\n    }\n\n    uint16_t oldest_packet_logical_idx;\n    if (g_telemetry_count < TELEMETRY_BUFFER_CAPACITY) {\n        oldest_packet_logical_idx = 0;\n    } else {\n        oldest_packet_logical_idx = g_telemetry_write_idx;\n    }\n\n    int32_t target_idx_raw = (int32_t)oldest_packet_logical_idx - num_steps_back;\n\n    g_telemetry_buffer[target_idx_raw].timestamp = 0xFFFFFFFF;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\n\nstruct TelemetryEntryHeader {\n    uint8_t  entry_type;\n    uint16_t entry_data_len;\n};\n\n#define CAN_MESSAGE_PAYLOAD_SIZE 8\n#define MAX_TELEMETRY_BUFFER_SIZE (1 * 1024 * 1024)\n\nclass TelemetryRecorderFixed {\nprivate:\n    uint8_t* m_buffer;\n    size_t m_current_offset;\n    size_t m_allocated_capacity;\n\npublic:\n    TelemetryRecorderFixed() : m_buffer(nullptr), m_current_offset(0), m_allocated_capacity(0) {\n        m_allocated_capacity = 4096;\n        m_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~TelemetryRecorderFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool recordTelemetryEntryFixed(const uint8_t* raw_entry, size_t raw_entry_len) {\n        if (!raw_entry || raw_entry_len < sizeof(TelemetryEntryHeader)) {\n            return false;\n        }\n\n        const TelemetryEntryHeader* header = reinterpret_cast<const TelemetryEntryHeader*>(raw_entry);\n        uint8_t entry_type = header->entry_type;\n        uint16_t advertised_data_len_or_count = header->entry_data_len;\n\n        size_t actual_payload_size;\n        if (entry_type == 0x03) {\n            if (advertised_data_len_or_count > (std::numeric_limits<size_t>::max() / CAN_MESSAGE_PAYLOAD_SIZE)) {\n                 return false;\n            }\n            actual_payload_size = (size_t)advertised_data_len_or_count * CAN_MESSAGE_PAYLOAD_SIZE;\n        } else {\n            actual_payload_size = advertised_data_len_or_count;\n        }\n\n        if (actual_payload_size > (std::numeric_limits<size_t>::max() - sizeof(TelemetryEntryHeader))) {\n            return false;\n        }\n        size_t required_space_for_this_entry = sizeof(TelemetryEntryHeader) + actual_payload_size;\n\n        if (m_current_offset > (MAX_TELEMETRY_BUFFER_SIZE - required_space_for_this_entry)) {\n            return false;\n        }\n\n        if (m_current_offset + required_space_for_this_entry > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity;\n            if (new_capacity == 0) {\n                new_capacity = 4096;\n            }\n\n            while (new_capacity < m_current_offset + required_space_for_this_entry) {\n                if (new_capacity > (std::numeric_limits<size_t>::max() / 2)) {\n                    new_capacity = std::numeric_limits<size_t>::max();\n                    break;\n                }\n                new_capacity *= 2;\n            }\n            if (new_capacity > MAX_TELEMETRY_BUFFER_SIZE) {\n                new_capacity = MAX_TELEMETRY_BUFFER_SIZE;\n            }\n            if (new_capacity < m_current_offset + required_space_for_this_entry) {\n                return false;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_capacity);\n            if (!new_buffer && new_capacity > 0) {\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        if (raw_entry_len < sizeof(TelemetryEntryHeader) + actual_payload_size) {\n            return false;\n        }\n        \n        for (size_t i = 0; i < sizeof(TelemetryEntryHeader); ++i) {\n            m_buffer[m_current_offset + i] = raw_entry[i];\n        }\n\n        const uint8_t* payload_src = raw_entry + sizeof(TelemetryEntryHeader);\n        \n        for (size_t i = 0; i < actual_payload_size; ++i) {\n            m_buffer[m_current_offset + sizeof(TelemetryEntryHeader) + i] = payload_src[i];\n        }\n\n        m_current_offset += required_space_for_this_entry;\n\n        return true;\n    }\n\n    const uint8_t* getTelemetryBuffer() const {\n        return m_buffer;\n    }\n\n    size_t getContainedDataSize() const {\n        return m_current_offset;\n    }\n};\n", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define SENSOR_EVENT_DATA_SIZE 8\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_type;\n    uint8_t  details[SENSOR_EVENT_DATA_SIZE];\n} SensorEvent;\n\n#define MAX_EVENT_LOG_ENTRIES 20\n\nstatic SensorEvent g_event_log[MAX_EVENT_LOG_ENTRIES];\nstatic int32_t g_current_event_count = 0;\n\nvoid init_event_log() {\n    memset(g_event_log, 0, sizeof(g_event_log));\n    g_current_event_count = 0;\n}\n\nbool add_sensor_event(uint16_t type, const uint8_t* details) {\n    if (g_current_event_count >= MAX_EVENT_LOG_ENTRIES) {\n        return false;\n    }\n    g_event_log[g_current_event_count].timestamp = 0x12345678;\n    g_event_log[g_current_event_count].event_type = type;\n    memcpy(g_event_log[g_current_event_count].details, details, SENSOR_EVENT_DATA_SIZE);\n    g_current_event_count++;\n    return true;\n}\n\nvoid rewind_event_log_and_update_marker_vulnerable(uint32_t steps_to_rewind, uint8_t marker_value) {\n    if (g_current_event_count == 0) {\n        return;\n    }\n\n    int32_t new_logical_end_idx = g_current_event_count - (int32_t)steps_to_rewind;\n\n    if (new_logical_end_idx < 0) {\n        new_logical_end_idx = 0;\n    }\n\n    g_current_event_count = new_logical_end_idx;\n\n    ((uint8_t*)g_event_log)[new_logical_end_idx * sizeof(SensorEvent) - 1] = marker_value;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#define MAX_DRIVING_MODES 4\ntypedef struct {\n    float throttle_response_factor;\n    unsigned char transmission_shift_aggressiveness;\n    unsigned char suspension_damping_level;\n    unsigned short steering_assist_level;\n} DrivingProfile;\nstatic DrivingProfile g_drivingProfiles[MAX_DRIVING_MODES] = {\n    {0.5f, 20, 0, 800},\n    {0.7f, 50, 1, 500},\n    {0.9f, 80, 2, 200},\n    {0.6f, 40, 3, 900}\n};\ntypedef struct {\n    unsigned char command_id;\n    unsigned char mode_index;\n    unsigned short reserved;\n} VehicleControlCommand;\nvoid log_vehicle_event(const char* event_msg) {}\nVehicleControlCommand receive_vehicle_command_vulnerable() {\n    VehicleControlCommand cmd;\n    cmd.command_id = 0x01;\n    cmd.mode_index = 5;\n    cmd.reserved = 0;\n    return cmd;\n}\nvoid apply_driving_mode_vulnerable(unsigned char mode_id) {\n    DrivingProfile selected_profile = g_drivingProfiles[mode_id];\n    log_vehicle_event(\"Applied driving mode profile.\");\n}\nvoid vehicle_control_loop_vulnerable() {\n    VehicleControlCommand command = receive_vehicle_command_vulnerable();\n    if (command.command_id == 0x01) {\n        apply_driving_mode_vulnerable(command.mode_index);\n    } else {\n        log_vehicle_event(\"Unknown vehicle control command received.\");\n    }\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_MSG_TYPES 3\n#define MAX_SUB_TYPES_PER_MSG 5\n#define PAYLOAD_MAX_SIZE 16\n\nvoid handleMsgType0Sub0_vulnerable(const uint8_t* payload) {}\nvoid handleMsgType0Sub1_vulnerable(const uint8_t* payload) {}\nvoid handleMsgType1Sub0_vulnerable(const uint8_t* payload) {}\nvoid handleMsgType1Sub1_vulnerable(const uint8_t* payload) {}\nvoid handleMsgType2Sub0_vulnerable(const uint8_t* payload) {}\n\ntypedef struct {\n    uint8_t msg_id;\n    uint8_t sub_id;\n    uint8_t payload[PAYLOAD_MAX_SIZE];\n    uint8_t payload_len;\n} DiagnosticMessage;\n\nstatic void (*g_diagMsgHandlers_vulnerable[MAX_MSG_TYPES][MAX_SUB_TYPES_PER_MSG])(const uint8_t* payload);\n\nvoid logECUError_vulnerable(const char* msg) {}\n\nvoid initializeDiagHandlers_vulnerable() {\n    for (int i = 0; i < MAX_MSG_TYPES; ++i) {\n        for (int j = 0; j < MAX_SUB_TYPES_PER_MSG; ++j) {\n            g_diagMsgHandlers_vulnerable[i][j] = NULL;\n        }\n    }\n    g_diagMsgHandlers_vulnerable[0][0] = handleMsgType0Sub0_vulnerable;\n    g_diagMsgHandlers_vulnerable[0][1] = handleMsgType0Sub1_vulnerable;\n    g_diagMsgHandlers_vulnerable[1][0] = handleMsgType1Sub0_vulnerable;\n    g_diagMsgHandlers_vulnerable[1][1] = handleMsgType1Sub1_vulnerable;\n    g_diagMsgHandlers_vulnerable[2][0] = handleMsgType2Sub0_vulnerable;\n}\n\nDiagnosticMessage receiveDiagnosticMessage_vulnerable() {\n    DiagnosticMessage msg;\n    msg.msg_id = 1;\n    msg.sub_id = MAX_SUB_TYPES_PER_MSG;\n    msg.payload[0] = 0xAA;\n    msg.payload_len = 1;\n    return msg;\n}\n\nvoid processDiagnosticMessage_vulnerable() {\n    DiagnosticMessage received_msg = receiveDiagnosticMessage_vulnerable();\n\n    if (received_msg.msg_id < MAX_MSG_TYPES) {\n        if (g_diagMsgHandlers_vulnerable[received_msg.msg_id][received_msg.sub_id] != NULL) {\n            g_diagMsgHandlers_vulnerable[received_msg.msg_id][received_msg.sub_id](received_msg.payload);\n        } else {\n            logECUError_vulnerable(\"Handler not registered for the given sub_id.\");\n        }\n    } else {\n        logECUError_vulnerable(\"Invalid message ID received.\");\n    }\n}\n\nvoid main_ecu_loop_vulnerable() {\n    initializeDiagHandlers_vulnerable();\n    processDiagnosticMessage_vulnerable();\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_STORED_DTCS 50\n\ntypedef enum {\n    DTC_STATUS_INACTIVE = 0,\n    DTC_STATUS_ACTIVE,\n    DTC_STATUS_CONFIRMED,\n    DTC_STATUS_PENDING,\n    DTC_STATUS_COUNT\n} DtcStatus;\n\ntypedef struct {\n    uint16_t  dtc_code;\n    DtcStatus status;\n    uint8_t   occurrence_count;\n    uint32_t  first_occurrence_timestamp;\n} DtcEntry;\n\nstatic DtcEntry g_dtcStatusTable_fixed[MAX_STORED_DTCS];\n\nvoid logDTCSystemError_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t dtc_logical_index;\n    uint8_t new_status_value;\n    uint16_t reserved;\n} DiagnosticRequestFrame;\n\nDiagnosticRequestFrame receiveDiagnosticRequest_fixed() {\n    DiagnosticRequestFrame req;\n    req.command_id = 0x01;\n    req.dtc_logical_index = MAX_STORED_DTCS;\n    req.new_status_value = DTC_STATUS_CONFIRMED;\n    req.reserved = 0;\n    return req;\n}\n\nvoid initializeDTCSystem_fixed() {\n    for (int i = 0; i < MAX_STORED_DTCS; ++i) {\n        g_dtcStatusTable_fixed[i].dtc_code = 0x0000;\n        g_dtcStatusTable_fixed[i].status = DTC_STATUS_INACTIVE;\n        g_dtcStatusTable_fixed[i].occurrence_count = 0;\n        g_dtcStatusTable_fixed[i].first_occurrence_timestamp = 0;\n    }\n    g_dtcStatusTable_fixed[0].dtc_code = 0x1234;\n    g_dtcStatusTable_fixed[1].dtc_code = 0x5678;\n    g_dtcStatusTable_fixed[2].dtc_code = 0x9ABC;\n}\n\nvoid processDiagnosticRequest_fixed() {\n    DiagnosticRequestFrame request = receiveDiagnosticRequest_fixed();\n\n    if (request.command_id == 0x01) {\n        if (request.dtc_logical_index < MAX_STORED_DTCS) {\n            if (request.new_status_value < DTC_STATUS_COUNT) {\n                g_dtcStatusTable_fixed[request.dtc_logical_index].status = (DtcStatus)request.new_status_value;\n                g_dtcStatusTable_fixed[request.dtc_logical_index].occurrence_count++;\n                logDTCSystemError_fixed(\"DTC status update processed successfully.\");\n            } else {\n                logDTCSystemError_fixed(\"Invalid new DTC status value received (fixed).\");\n            }\n        } else {\n            logDTCSystemError_fixed(\"DTC logical index out of bounds. Command ignored (fixed).\");\n        }\n    } else {\n        logDTCSystemError_fixed(\"Unknown diagnostic command received (fixed).\");\n    }\n}\n\nvoid dtcManagerMain_fixed() {\n    initializeDTCSystem_fixed();\n    processDiagnosticRequest_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define FIRMWARE_DATA_BUFFER_SIZE 512\n#define MAX_FIRMWARE_CHUNK_SIZE 128\n\nstatic uint8_t g_firmware_data_buffer[FIRMWARE_DATA_BUFFER_SIZE];\nstatic uint8_t* g_firmware_write_ptr;\nstatic uint32_t g_firmware_data_current_len;\n\nstatic volatile uint8_t g_ecu_operational_mode = 0x01;\n\nvoid init_firmware_data_handler() {\n    memset(g_firmware_data_buffer, 0, FIRMWARE_DATA_BUFFER_SIZE);\n    g_firmware_write_ptr = g_firmware_data_buffer;\n    g_firmware_data_current_len = 0;\n    g_ecu_operational_mode = 0x01;\n}\n\nbool append_firmware_chunk(const uint8_t* chunk, uint16_t chunk_len) {\n    if (chunk == NULL || chunk_len == 0 || chunk_len > MAX_FIRMWARE_CHUNK_SIZE) {\n        return false;\n    }\n\n    if (g_firmware_data_current_len + chunk_len > FIRMWARE_DATA_BUFFER_SIZE) {\n        return false;\n    }\n\n    memcpy(g_firmware_write_ptr, chunk, chunk_len);\n    g_firmware_write_ptr += chunk_len;\n    g_firmware_data_current_len += chunk_len;\n    return true;\n}\n\nvoid rewind_firmware_data_fixed(uint16_t bytes_to_rewind) {\n    if (bytes_to_rewind > g_firmware_data_current_len) {\n        bytes_to_rewind = g_firmware_data_current_len;\n    }\n\n    uint8_t* proposed_write_ptr = g_firmware_write_ptr - bytes_to_rewind;\n    uint32_t proposed_data_len = g_firmware_data_current_len - bytes_to_rewind;\n\n    if (proposed_write_ptr < g_firmware_data_buffer) {\n        g_firmware_write_ptr = g_firmware_data_buffer;\n        g_firmware_data_current_len = 0;\n    } else {\n        g_firmware_write_ptr = proposed_write_ptr;\n        g_firmware_data_current_len = proposed_data_len;\n    }\n\n    if (g_firmware_write_ptr >= g_firmware_data_buffer && g_firmware_write_ptr < g_firmware_data_buffer + FIRMWARE_DATA_BUFFER_SIZE) {\n        *g_firmware_write_ptr = 0x00;\n    }\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define OTA_FIRMWARE_STAGING_BUFFER_SIZE 4096\n#define MAX_FRAGMENT_PAYLOAD_SIZE 64\n\nstatic uint8_t g_firmwareStagingBuffer[OTA_FIRMWARE_STAGING_BUFFER_SIZE];\nstatic uint32_t g_totalFirmwareSize = 0;\nstatic uint32_t g_bytesReceived = 0;\n\ntypedef struct {\n    uint16_t fragment_offset;\n    uint8_t  fragment_length;\n    uint8_t  data[MAX_FRAGMENT_PAYLOAD_SIZE];\n} OtaFragmentPacket;\n\nvoid initOtaStaging() {\n    memset(g_firmwareStagingBuffer, 0, OTA_FIRMWARE_STAGING_BUFFER_SIZE);\n    g_totalFirmwareSize = 0;\n    g_bytesReceived = 0;\n}\n\nvoid setExpectedFirmwareSize(uint32_t total_size) {\n    if (total_size > OTA_FIRMWARE_STAGING_BUFFER_SIZE) {\n        g_totalFirmwareSize = OTA_FIRMWARE_STAGING_BUFFER_SIZE; \n    } else {\n        g_totalFirmwareSize = total_size;\n    }\n}\n\nint processFirmwareFragment(const OtaFragmentPacket* fragment_packet) {\n    if (fragment_packet == NULL) {\n        return -1;\n    }\n\n    uint16_t offset = fragment_packet->fragment_offset;\n    uint8_t length = fragment_packet->fragment_length;\n\n    if (length > MAX_FRAGMENT_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    // Vulnerability: The check 'offset >= g_totalFirmwareSize' only verifies the starting\n    // offset against the logical firmware size, which itself is capped at the buffer size.\n    // However, it does not check if 'offset + length' exceeds the actual physical buffer size.\n    // An attacker can craft a packet where 'offset' is just below 'g_totalFirmwareSize'\n    // and 'length' causes the write to go past the end of g_firmwareStagingBuffer.\n    if (offset >= g_totalFirmwareSize) {\n        return -3;\n    }\n\n    memcpy(g_firmwareStagingBuffer + offset, fragment_packet->data, length);\n\n    if (offset + length > g_bytesReceived) {\n        g_bytesReceived = offset + length;\n    }\n\n    return 0;\n}\n\nvoid simulateOtaFragmentReception(const OtaFragmentPacket* packet) {\n    processFirmwareFragment(packet);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define OTA_FIRMWARE_STAGING_BUFFER_SIZE 4096\n#define MAX_FRAGMENT_PAYLOAD_SIZE 64\n\nstatic uint8_t g_firmwareStagingBuffer[OTA_FIRMWARE_STAGING_BUFFER_SIZE];\nstatic uint32_t g_totalFirmwareSize = 0;\nstatic uint32_t g_bytesReceived = 0;\n\ntypedef struct {\n    uint16_t fragment_offset;\n    uint8_t  fragment_length;\n    uint8_t  data[MAX_FRAGMENT_PAYLOAD_SIZE];\n} OtaFragmentPacket;\n\nvoid initOtaStaging() {\n    memset(g_firmwareStagingBuffer, 0, OTA_FIRMWARE_STAGING_BUFFER_SIZE);\n    g_totalFirmwareSize = 0;\n    g_bytesReceived = 0;\n}\n\nvoid setExpectedFirmwareSize(uint32_t total_size) {\n    if (total_size > OTA_FIRMWARE_STAGING_BUFFER_SIZE) {\n        g_totalFirmwareSize = OTA_FIRMWARE_STAGING_BUFFER_SIZE; \n    } else {\n        g_totalFirmwareSize = total_size;\n    }\n}\n\nint processFirmwareFragment(const OtaFragmentPacket* fragment_packet) {\n    if (fragment_packet == NULL) {\n        return -1;\n    }\n\n    uint16_t offset = fragment_packet->fragment_offset;\n    uint8_t length = fragment_packet->fragment_length;\n\n    if (length > MAX_FRAGMENT_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    // Fixed: Added explicit checks to ensure that the entire write operation\n    // (offset + length) remains within the bounds of the physical staging buffer\n    // and also within the expected logical firmware size.\n    if (offset >= OTA_FIRMWARE_STAGING_BUFFER_SIZE || \n        (uint32_t)offset + length > OTA_FIRMWARE_STAGING_BUFFER_SIZE || \n        (uint32_t)offset + length > g_totalFirmwareSize) {\n        return -3;\n    }\n\n    memcpy(g_firmwareStagingBuffer + offset, fragment_packet->data, length);\n\n    if (offset + length > g_bytesReceived) {\n        g_bytesReceived = offset + length;\n    }\n\n    return 0;\n}\n\nvoid simulateOtaFragmentReception(const OtaFragmentPacket* packet) {\n    processFirmwareFragment(packet);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define TOTAL_FIRMWARE_MEMORY_BYTES_FIXED 2048\n#define PAGE_SIZE_BYTES_FIXED 64\n#define MAX_COMPONENTS_FIXED 3\n\nstatic uint8_t g_firmwareMemory_fixed[TOTAL_FIRMWARE_MEMORY_BYTES_FIXED];\n\ntypedef enum {\n    COMPONENT_ENGINE_CONTROL_FIXED = 0,\n    COMPONENT_TRANSMISSION_CONTROL_FIXED,\n    COMPONENT_BRAKE_SYSTEM_FIXED,\n    COMPONENT_INVALID_FIXED\n} ComponentID_Fixed;\n\ntypedef struct {\n    size_t start_offset_bytes;\n    size_t bank_size_pages;\n} ComponentFirmwareBankConfig_Fixed;\n\nstatic ComponentFirmwareBankConfig_Fixed g_componentBankConfigs_fixed[MAX_COMPONENTS_FIXED];\n\nvoid logFirmwareUpdateEvent_fixed(const char* msg) {\n}\n\nvoid logFirmwareUpdateError_fixed(const char* msg) {\n}\n\ntypedef struct {\n    ComponentID_Fixed component_id;\n    uint16_t page_index;\n    uint8_t data[PAGE_SIZE_BYTES_FIXED];\n} FirmwareUpdatePacket_Fixed;\n\nFirmwareUpdatePacket_Fixed receiveFirmwareUpdatePacket_fixed() {\n    FirmwareUpdatePacket_Fixed packet;\n    packet.component_id = COMPONENT_ENGINE_CONTROL_FIXED;\n    packet.page_index = 20;\n    for (int i = 0; i < PAGE_SIZE_BYTES_FIXED; ++i) {\n        packet.data[i] = (uint8_t)i;\n    }\n    return packet;\n}\n\nvoid initializeFirmwareBanks_fixed() {\n    g_componentBankConfigs_fixed[COMPONENT_ENGINE_CONTROL_FIXED] = (ComponentFirmwareBankConfig_Fixed){\n        .start_offset_bytes = 0,\n        .bank_size_pages = 10\n    };\n    g_componentBankConfigs_fixed[COMPONENT_TRANSMISSION_CONTROL_FIXED] = (ComponentFirmwareBankConfig_Fixed){\n        .start_offset_bytes = g_componentBankConfigs_fixed[COMPONENT_ENGINE_CONTROL_FIXED].start_offset_bytes +\n                              g_componentBankConfigs_fixed[COMPONENT_ENGINE_CONTROL_FIXED].bank_size_pages * PAGE_SIZE_BYTES_FIXED,\n        .bank_size_pages = 15\n    };\n    g_componentBankConfigs_fixed[COMPONENT_BRAKE_SYSTEM_FIXED] = (ComponentFirmwareBankConfig_Fixed){\n        .start_offset_bytes = g_componentBankConfigs_fixed[COMPONENT_TRANSMISSION_CONTROL_FIXED].start_offset_bytes +\n                              g_componentBankConfigs_fixed[COMPONENT_TRANSMISSION_CONTROL_FIXED].bank_size_pages * PAGE_SIZE_BYTES_FIXED,\n        .bank_size_pages = 8\n    };\n\n    for (size_t i = 0; i < TOTAL_FIRMWARE_MEMORY_BYTES_FIXED; ++i) {\n        g_firmwareMemory_fixed[i] = 0;\n    }\n\n    logFirmwareUpdateEvent_fixed(\"Firmware banks initialized (fixed).\");\n}\n\nvoid applyFirmwareUpdate_fixed(FirmwareUpdatePacket_Fixed update_packet) {\n    if (update_packet.component_id >= COMPONENT_INVALID_FIXED) {\n        logFirmwareUpdateError_fixed(\"Invalid component ID in firmware update (fixed).\");\n        return;\n    }\n\n    ComponentFirmwareBankConfig_Fixed config = g_componentBankConfigs_fixed[update_packet.component_id];\n\n    if (update_packet.page_index >= config.bank_size_pages) {\n        logFirmwareUpdateError_fixed(\"Page index out of bounds for selected component bank (fixed).\");\n        return;\n    }\n\n    size_t target_byte_offset = config.start_offset_bytes + (size_t)update_packet.page_index * PAGE_SIZE_BYTES_FIXED;\n\n    if (target_byte_offset + PAGE_SIZE_BYTES_FIXED <= TOTAL_FIRMWARE_MEMORY_BYTES_FIXED) {\n        for (size_t i = 0; i < PAGE_SIZE_BYTES_FIXED; ++i) {\n            g_firmwareMemory_fixed[target_byte_offset + i] = update_packet.data[i];\n        }\n        logFirmwareUpdateEvent_fixed(\"Firmware page updated successfully (fixed).\");\n    } else {\n        logFirmwareUpdateError_fixed(\"Firmware update would write out of total memory bounds (fixed). This should not happen with proper page index validation.\");\n    }\n}\n\nvoid firmwareUpdateManager_fixed_main() {\n    initializeFirmwareBanks_fixed();\n    FirmwareUpdatePacket_Fixed cmd = receiveFirmwareUpdatePacket_fixed();\n    applyFirmwareUpdate_fixed(cmd);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOGGED_FAULTS 10\n#define CMD_LOG_FAULTS 0x01\n\nstatic uint16_t g_faultLogBuffer[MAX_LOGGED_FAULTS];\nstatic uint8_t g_currentFaultCount = 0;\n\nvoid initFaultLogger() {\n    memset(g_faultLogBuffer, 0, sizeof(g_faultLogBuffer));\n    g_currentFaultCount = 0;\n}\n\nint logDiagnosticFaults(const uint8_t* diag_packet, uint16_t packet_len) {\n    if (diag_packet == NULL || packet_len < 2) {\n        return -1;\n    }\n\n    uint8_t command_id = diag_packet[0];\n    if (command_id != CMD_LOG_FAULTS) {\n        return -2;\n    }\n\n    uint8_t num_faults_requested = diag_packet[1];\n    uint16_t current_offset = 2;\n\n    g_currentFaultCount = 0;\n\n    uint8_t num_faults_to_log = num_faults_requested;\n    if (num_faults_to_log > MAX_LOGGED_FAULTS) {\n        num_faults_to_log = MAX_LOGGED_FAULTS;\n    }\n\n    uint16_t max_faults_in_packet_payload = (packet_len > 2) ? ((packet_len - 2) / sizeof(uint16_t)) : 0;\n    if (num_faults_to_log > max_faults_in_packet_payload) {\n        num_faults_to_log = (uint8_t)max_faults_in_packet_payload;\n    }\n\n    for (uint8_t i = 0; i < num_faults_to_log; ++i) {\n        if (current_offset + sizeof(uint16_t) > packet_len) {\n            break;\n        }\n\n        uint16_t fault_code = (diag_packet[current_offset] << 8) | diag_packet[current_offset + 1];\n        current_offset += sizeof(uint16_t);\n\n        g_faultLogBuffer[g_currentFaultCount] = fault_code;\n        g_currentFaultCount++;\n    }\n\n    return 0;\n}\n\nvoid simulateDiagnosticRequest(const uint8_t* data, uint16_t len) {\n    logDiagnosticFaults(data, len);\n}\n\nuint8_t getLoggedFaultCount() {\n    return g_currentFaultCount;\n}\n\nuint16_t getLoggedFault(uint8_t index) {\n    if (index < g_currentFaultCount) {\n        return g_faultLogBuffer[index];\n    }\n    return 0xFFFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <new>\n#include <cstring>\n#include <cstdlib>\n#include <limits>\n\nstruct ConfigEntryMetadata {\n    uint32_t key_offset;\n    uint16_t key_len;\n    uint32_t value_offset;\n    uint16_t value_len;\n};\n\nclass VehicleConfigManagerFixed {\npublic:\n    VehicleConfigManagerFixed() : m_dataBuffer(nullptr), m_currentDataSize(0), m_allocatedCapacity(0) {\n        m_allocatedCapacity = 256;\n        m_dataBuffer = (uint8_t*)malloc(m_allocatedCapacity);\n        if (!m_dataBuffer) {\n            m_allocatedCapacity = 0;\n        }\n    }\n\n    ~VehicleConfigManagerFixed() {\n        if (m_dataBuffer) {\n            free(m_dataBuffer);\n            m_dataBuffer = nullptr;\n        }\n    }\n\n    bool addConfigEntryFixed(const char* key, uint16_t key_len, const char* value, uint16_t value_len) {\n        if (!key || !value) {\n            return false;\n        }\n\n        static const uint16_t MAX_KEY_LEN = 2048; \n        static const uint16_t MAX_VALUE_LEN = 2048; \n\n        if (key_len > MAX_KEY_LEN || value_len > MAX_VALUE_LEN) {\n            return false;\n        }\n\n        if (key_len > (std::numeric_limits<size_t>::max() - 1 - value_len - 1)) {\n            return false;\n        }\n        size_t required_data_for_new_entry = (size_t)key_len + 1 + (size_t)value_len + 1;\n\n        if (m_currentDataSize > (std::numeric_limits<size_t>::max() - required_data_for_new_entry)) {\n            return false;\n        }\n        size_t required_total_size = m_currentDataSize + required_data_for_new_entry;\n\n        static const size_t MAX_TOTAL_CONFIG_SIZE = 64 * 1024; \n        if (required_total_size > MAX_TOTAL_CONFIG_SIZE) {\n            return false;\n        }\n\n        if (required_total_size > m_allocatedCapacity) {\n            uint8_t* new_buffer = (uint8_t*)realloc(m_dataBuffer, required_total_size);\n            if (!new_buffer) {\n                return false;\n            }\n            m_dataBuffer = new_buffer;\n            m_allocatedCapacity = required_total_size;\n        }\n\n        ConfigEntryMetadata new_metadata;\n        new_metadata.key_offset = static_cast<uint32_t>(m_currentDataSize);\n        new_metadata.key_len = key_len;\n        new_metadata.value_offset = static_cast<uint32_t>(m_currentDataSize + key_len + 1);\n        new_metadata.value_len = value_len;\n        m_configEntries.push_back(new_metadata);\n\n        memcpy(m_dataBuffer + m_currentDataSize, key, key_len);\n        m_dataBuffer[m_currentDataSize + key_len] = '\\0';\n\n        memcpy(m_dataBuffer + new_metadata.value_offset, value, value_len);\n        m_dataBuffer[new_metadata.value_offset + value_len] = '\\0';\n\n        m_currentDataSize += required_data_for_new_entry;\n\n        return true;\n    }\n\n    const uint8_t* getDataBuffer() const { return m_dataBuffer; }\n    size_t getCurrentDataSize() const { return m_currentDataSize; }\n    size_t getAllocatedCapacity() const { return m_allocatedCapacity; }\n    const std::vector<ConfigEntryMetadata>& getConfigEntries() const { return m_configEntries; }\n\nprivate:\n    uint8_t* m_dataBuffer;\n    size_t m_currentDataSize;\n    size_t m_allocatedCapacity;\n    std::vector<ConfigEntryMetadata> m_configEntries;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define CRITICAL_CALIBRATION_VALUES_COUNT 10 \n#define CALIBRATION_BUFFER_SIZE (CRITICAL_CALIBRATION_VALUES_COUNT * sizeof(uint16_t))\n\nstatic uint16_t g_criticalCalibrationValues[CRITICAL_CALIBRATION_VALUES_COUNT];\n\nvoid initCalibrationValues() {\n    memset(g_criticalCalibrationValues, 0, CALIBRATION_BUFFER_SIZE);\n    for (uint8_t i = 0; i < CRITICAL_CALIBRATION_VALUES_COUNT; ++i) {\n        g_criticalCalibrationValues[i] = (i + 1) * 100;\n    }\n}\n\ntypedef struct {\n    uint8_t  group_id;\n    uint8_t  item_offset;\n    uint16_t new_value;\n} CalibrationUpdateCommand;\n\nint applyCalibrationUpdate(const CalibrationUpdateCommand* command) {\n    if (command == NULL) {\n        return -1;\n    }\n\n    uint8_t group_id = command->group_id;\n    uint8_t item_offset = command->item_offset;\n    uint16_t new_value = command->new_value;\n\n    uint8_t effective_index_base_8bit;\n\n    switch (group_id) {\n        case 0:\n            effective_index_base_8bit = 0;\n            break;\n        case 1:\n            effective_index_base_8bit = 5;\n            break;\n        case 2:\n            effective_index_base_8bit = 250;\n            break;\n        default:\n            return -2;\n    }\n\n    uint8_t final_index_8bit = effective_index_base_8bit + item_offset;\n\n    if (final_index_8bit >= CRITICAL_CALIBRATION_VALUES_COUNT) {\n        return -3;\n    }\n\n    g_criticalCalibrationValues[final_index_8bit] = new_value;\n\n    return 0;\n}\n\nvoid simulateExternalCalibrationUpdate(uint8_t group, uint8_t offset, uint16_t value) {\n    CalibrationUpdateCommand cmd = { .group_id = group, .item_offset = offset, .new_value = value };\n    applyCalibrationUpdate(&cmd);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <stdio.h>\n\ntypedef enum {\n    EVENT_TYPE_IGNITION = 0,\n    EVENT_TYPE_GEARBOX,\n    EVENT_TYPE_WHEEL_SPEED,\n    EVENT_TYPE_BATTERY,\n    EVENT_TYPE_DIAGNOSTIC,\n    EVENT_TYPE_COUNT\n} EventType;\n\ntypedef struct {\n    EventType type;\n    uint8_t   subtype_idx;\n    uint16_t  data_payload;\n} VehicleEvent_Fixed;\n\nvoid handleIgnitionEvent_fixed(uint8_t subtype_idx, uint16_t data) { }\nvoid handleGearboxEvent_fixed(uint8_t subtype_idx, uint16_t data) { }\nvoid handleWheelSpeedEvent_fixed(uint8_t subtype_idx, uint16_t data) { }\nvoid handleBatteryEvent_fixed(uint8_t subtype_idx, uint16_t data) { }\nvoid handleDiagnosticEvent_fixed(uint8_t subtype_idx, uint16_t data) { }\n\nstatic const char* ignition_subtypes_fixed[] = {\n    \"Ignition On\", \"Ignition Off\", \"Engine Start Attempt\"\n};\n#define IGNITION_SUBTYPE_COUNT_FIXED (sizeof(ignition_subtypes_fixed) / sizeof(ignition_subtypes_fixed[0]))\n\nstatic const char* gearbox_subtypes_fixed[] = {\n    \"Gear Shift Up\", \"Gear Shift Down\", \"Neutral Engaged\", \"Gearbox Fault\"\n};\n#define GEARBOX_SUBTYPE_COUNT_FIXED (sizeof(gearbox_subtypes_fixed) / sizeof(gearbox_subtypes_fixed[0]))\n\nstatic const char* wheel_speed_subtypes_fixed[] = {\n    \"Wheel Speed FL\", \"Wheel Speed FR\", \"Wheel Speed RL\", \"Wheel Speed RR\", \"All Sensors Valid\"\n};\n#define WHEEL_SPEED_SUBTYPE_COUNT_FIXED (sizeof(wheel_speed_subtypes_fixed) / sizeof(wheel_speed_subtypes_fixed[0]))\n\nstatic const char* battery_subtypes_fixed[] = {\n    \"Low Battery Voltage\", \"High Battery Voltage\", \"Overcharge Detected\"\n};\n#define BATTERY_SUBTYPE_COUNT_FIXED (sizeof(battery_subtypes_fixed) / sizeof(battery_subtypes_fixed[0]))\n\nstatic const char* diagnostic_subtypes_fixed[] = {\n    \"Read DTCs\", \"Clear DTCs\", \"Perform Self-Test\", \"Diagnostic Reset\"\n};\n#define DIAGNOSTIC_SUBTYPE_COUNT_FIXED (sizeof(diagnostic_subtypes_fixed) / sizeof(diagnostic_subtypes_fixed[0]))\n\nstatic const char** g_fixed_subTypeDescriptions[EVENT_TYPE_COUNT] = {\n    ignition_subtypes_fixed,\n    gearbox_subtypes_fixed,\n    wheel_speed_subtypes_fixed,\n    battery_subtypes_fixed,\n    diagnostic_subtypes_fixed\n};\n\nstatic const uint8_t g_fixed_subTypeCounts[EVENT_TYPE_COUNT] = {\n    IGNITION_SUBTYPE_COUNT_FIXED,\n    GEARBOX_SUBTYPE_COUNT_FIXED,\n    WHEEL_SPEED_SUBTYPE_COUNT_FIXED,\n    BATTERY_SUBTYPE_COUNT_FIXED,\n    DIAGNOSTIC_SUBTYPE_COUNT_FIXED\n};\n\nvoid systemLog_fixed(const char* msg) {\n    printf(\"SYS_LOG: %s\\n\", msg);\n}\n\nVehicleEvent_Fixed receiveVehicleEvent_fixed() {\n    VehicleEvent_Fixed event;\n    event.type = EVENT_TYPE_GEARBOX;\n    event.subtype_idx = GEARBOX_SUBTYPE_COUNT_FIXED;\n    event.data_payload = 0xABCD;\n    return event;\n}\n\nvoid processVehicleEvent_fixed() {\n    VehicleEvent_Fixed event = receiveVehicleEvent_fixed();\n\n    if (event.type < EVENT_TYPE_COUNT) {\n        if (event.subtype_idx < g_fixed_subTypeCounts[event.type]) {\n            const char* subtype_desc = g_fixed_subTypeDescriptions[event.type][event.subtype_idx];\n            systemLog_fixed(subtype_desc);\n        } else {\n            systemLog_fixed(\"Received event with out-of-bounds subtype index for specific type.\");\n        }\n    } else {\n        systemLog_fixed(\"Received event with invalid main type.\");\n    }\n}\n\nvoid automotiveApplicationMain_fixed() {\n    processVehicleEvent_fixed();\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define COM_LOG_SIZE 16\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_code;\n    uint8_t  severity;\n} ComEvent;\n\nstatic ComEvent g_com_event_log[COM_LOG_SIZE];\nstatic uint16_t g_next_event_idx = 0;\nstatic uint16_t g_current_event_count = 0;\n\nvoid init_com_log() {\n    memset(g_com_event_log, 0, sizeof(g_com_event_log));\n    g_next_event_idx = 0;\n    g_current_event_count = 0;\n}\n\nvoid log_com_event(uint32_t ts, uint16_t code, uint8_t sev) {\n    g_com_event_log[g_next_event_idx].timestamp = ts;\n    g_com_event_log[g_next_event_idx].event_code = code;\n    g_com_event_log[g_next_event_idx].severity = sev;\n\n    g_next_event_idx = (g_next_event_idx + 1) % COM_LOG_SIZE;\n    if (g_current_event_count < COM_LOG_SIZE) {\n        g_current_event_count++;\n    }\n}\n\nvoid adjust_com_event_severity_vulnerable(uint8_t relative_offset_from_latest, uint8_t new_severity) {\n    if (g_current_event_count == 0) {\n        return;\n    }\n\n    int16_t latest_event_index;\n    if (g_next_event_idx == 0) {\n        latest_event_index = COM_LOG_SIZE - 1;\n    } else {\n        latest_event_index = g_next_event_idx - 1;\n    }\n\n    int16_t target_index = latest_event_index - (int16_t)relative_offset_from_latest;\n\n    g_com_event_log[target_index].severity = new_severity;\n}", "is_vuln": 1, "cvss": 5.0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE 256\n#define MAX_INCOMING_PACKET_SIZE 512\n\nstatic uint8_t g_telemetryStorageBuffer[MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE];\nstatic uint16_t g_currentStorageWriteOffset = 0;\n\nvoid initTelemetryStorage() {\n    memset(g_telemetryStorageBuffer, 0, MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE);\n    g_currentStorageWriteOffset = 0;\n}\n\nint processTelemetryDataPacket(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len == 0 || packet_len > MAX_INCOMING_PACKET_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_packet_read_offset = 0;\n\n    while (current_packet_read_offset < packet_len) {\n        if (current_packet_read_offset + 2 > packet_len) {\n            return -1;\n        }\n\n        uint8_t record_id = packet_data[current_packet_read_offset];\n        uint8_t data_len = packet_data[current_packet_read_offset + 1];\n\n        if (current_packet_read_offset + 2 + data_len > packet_len) {\n            return -1;\n        }\n\n        const uint8_t* record_data_ptr = packet_data + current_packet_read_offset + 2;\n\n        g_telemetryStorageBuffer[g_currentStorageWriteOffset] = record_id;\n        g_currentStorageWriteOffset++;\n\n        g_telemetryStorageBuffer[g_currentStorageWriteOffset] = data_len;\n        g_currentStorageWriteOffset++;\n\n        for (int i = 0; i < data_len; ++i) {\n            g_telemetryStorageBuffer[g_currentStorageWriteOffset + i] = record_data_ptr[i];\n        }\n        g_currentStorageWriteOffset += data_len;\n\n        current_packet_read_offset += 2 + data_len;\n    }\n\n    return 0;\n}\n\nvoid systemReceiveTelemetry(const uint8_t* raw_telemetry_packet, uint16_t packet_size) {\n    if (g_currentStorageWriteOffset == 0) {\n        initTelemetryStorage();\n    }\n    processTelemetryDataPacket(raw_telemetry_packet, packet_size);\n}", "is_vuln": 1, "cvss": 7.5}
