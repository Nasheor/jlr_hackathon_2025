{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <string.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n#define CAN_PAYLOAD_MAX_SUPPORTED 256\n#define DIAG_PROCESSING_BUFFER_SIZE 128\n\ntypedef struct {\n    uint32_t arbitrationId;\n    uint8_t  dlc;\n    uint8_t  data[CAN_PAYLOAD_MAX_SUPPORTED];\n} CanRxFrame;\n\ntypedef struct {\n    uint8_t currentServiceId;\n    uint8_t diagnosticDataBuffer[DIAG_PROCESSING_BUFFER_SIZE];\n    uint16_t dataReceivedLength;\n    bool processingActive;\n} DiagnosticHandlerContext;\n\nstatic DiagnosticHandlerContext g_diagContext = {0};\n\nvoid initDiagnosticHandler(void) {\n    memset(&g_diagContext, 0, sizeof(DiagnosticHandlerContext));\n    g_diagContext.processingActive = false;\n}\n\nint handleIncomingDiagnosticMessage(const CanRxFrame* frame) {\n    if (frame == NULL || frame->dlc == 0) {\n        return -1;\n    }\n\n    memcpy(g_diagContext.diagnosticDataBuffer, frame->data, frame->dlc);\n\n    g_diagContext.dataReceivedLength = frame->dlc;\n    g_diagContext.processingActive = true;\n    g_diagContext.currentServiceId = g_diagContext.diagnosticDataBuffer[0];\n\n    if (g_diagContext.currentServiceId == 0x22) {\n        // Process data identifier request\n    } else if (g_diagContext.currentServiceId == 0x2E) {\n        // Process write request\n    }\n\n    return 0;\n}", "fixed_code": "#include <string.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n#define CAN_PAYLOAD_MAX_SUPPORTED 256\n#define DIAG_PROCESSING_BUFFER_SIZE 128\n\ntypedef struct {\n    uint32_t arbitrationId;\n    uint8_t  dlc;\n    uint8_t  data[CAN_PAYLOAD_MAX_SUPPORTED];\n} CanRxFrame;\n\ntypedef struct {\n    uint8_t currentServiceId;\n    uint8_t diagnosticDataBuffer[DIAG_PROCESSING_BUFFER_SIZE];\n    uint16_t dataReceivedLength;\n    bool processingActive;\n} DiagnosticHandlerContext;\n\nstatic DiagnosticHandlerContext g_diagContext = {0};\n\nvoid initDiagnosticHandler(void) {\n    memset(&g_diagContext, 0, sizeof(DiagnosticHandlerContext));\n    g_diagContext.processingActive = false;\n}\n\nint handleIncomingDiagnosticMessage(const CanRxFrame* frame) {\n    if (frame == NULL || frame->dlc == 0) {\n        return -1;\n    }\n\n    uint16_t bytesToCopy = frame->dlc;\n    if (bytesToCopy > DIAG_PROCESSING_BUFFER_SIZE) {\n        bytesToCopy = DIAG_PROCESSING_BUFFER_SIZE;\n    }\n\n    memcpy(g_diagContext.diagnosticDataBuffer, frame->data, bytesToCopy);\n\n    g_diagContext.dataReceivedLength = bytesToCopy;\n    g_diagContext.processingActive = true;\n    g_diagContext.currentServiceId = g_diagContext.diagnosticDataBuffer[0];\n\n    if (g_diagContext.currentServiceId == 0x22) {\n        // Process data identifier request\n    } else if (g_diagContext.currentServiceId == 0x2E) {\n        // Process write request\n    }\n\n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <string.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n// Vehicle parameter IDs\n#define VEHICLE_PARAM_SENSOR_CALIBRATION_A 0x10\n#define VEHICLE_PARAM_VEHICLE_IDENTIFIER   0x11\n#define VEHICLE_PARAM_DIAG_LIFETIME_COUNTER 0x12\n\n// Maximum length for vehicle identifier string\n#define VEHICLE_IDENTIFIER_MAX_LEN 16\n\n// Structure to hold vehicle configuration parameters\ntypedef struct {\n    uint16_t sensorCalibrationValueA;       // 2 bytes\n    char     vehicleIdentifier[VEHICLE_IDENTIFIER_MAX_LEN]; // 16 bytes buffer for C string\n    uint32_t diagnosticLifetimeCounter;     // 4 bytes\n    uint8_t  featureFlags[4];               // 4 bytes of feature flags\n} VehicleSystemConfiguration;\n\n// Global instance of the vehicle configuration\nstatic VehicleSystemConfiguration g_systemConfig;\n\n// Function to initialize the configuration\nvoid systemConfigInit() {\n    g_systemConfig.sensorCalibrationValueA = 512;\n    strncpy(g_systemConfig.vehicleIdentifier, \"DEFAULT_VIN_XYZ\", VEHICLE_IDENTIFIER_MAX_LEN - 1);\n    g_systemConfig.vehicleIdentifier[VEHICLE_IDENTIFIER_MAX_LEN - 1] = '\\0';\n    g_systemConfig.diagnosticLifetimeCounter = 0;\n    memset(g_systemConfig.featureFlags, 0, sizeof(g_systemConfig.featureFlags));\n}\n\n// Function to process an incoming update request for a specific vehicle parameter\n// This function could be called by a diagnostic service handler or a CAN message handler.\n// paramId: The ID of the parameter to update.\n// data: Pointer to the new data for the parameter.\n// dataLen: The length of the new data in bytes.\nint updateVehicleParameter(uint8_t paramId, const uint8_t* data, uint16_t dataLen) {\n    if (data == NULL || dataLen == 0) {\n        return -1; // Invalid input\n    }\n\n    switch (paramId) {\n        case VEHICLE_PARAM_SENSOR_CALIBRATION_A:\n            if (dataLen == sizeof(uint16_t)) {\n                // Assuming little-endian or byte-order handled by caller/system\n                g_systemConfig.sensorCalibrationValueA = *(uint16_t*)data;\n            } else {\n                return -2; // Incorrect data length for calibration value\n            }\n            break;\n\n        case VEHICLE_PARAM_VEHICLE_IDENTIFIER:\n            // Vulnerability: No explicit length check against VEHICLE_IDENTIFIER_MAX_LEN\n            // The memcpy copies 'dataLen' bytes. If dataLen > VEHICLE_IDENTIFIER_MAX_LEN,\n            // it will write past the end of 'vehicleIdentifier', overflowing into\n            // 'diagnosticLifetimeCounter' and 'featureFlags'.\n            memcpy(g_systemConfig.vehicleIdentifier, data, dataLen);\n            // This line attempts to null-terminate, but only if dataLen < buffer size,\n            // which doesn't protect against overflow if dataLen is too large.\n            if (dataLen < VEHICLE_IDENTIFIER_MAX_LEN) {\n                g_systemConfig.vehicleIdentifier[dataLen] = '\\0';\n            } else {\n                g_systemConfig.vehicleIdentifier[VEHICLE_IDENTIFIER_MAX_LEN - 1] = '\\0';\n            }\n            break;\n\n        case VEHICLE_PARAM_DIAG_LIFETIME_COUNTER:\n            if (dataLen == sizeof(uint32_t)) {\n                g_systemConfig.diagnosticLifetimeCounter = *(uint32_t*)data;\n            } else {\n                return -2; // Incorrect data length for lifetime counter\n            }\n            break;\n\n        default:\n            return -3; // Unknown parameter ID\n    }\n\n    return 0; // Parameter updated successfully\n}\n\n// Example usage context (not part of the vulnerability, just for completeness)\nvoid simulateIncomingMessage(uint8_t id, const uint8_t* payload, uint16_t len) {\n    updateVehicleParameter(id, payload, len);\n}", "fixed_code": "#include <string.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n// Vehicle parameter IDs\n#define VEHICLE_PARAM_SENSOR_CALIBRATION_A 0x10\n#define VEHICLE_PARAM_VEHICLE_IDENTIFIER   0x11\n#define VEHICLE_PARAM_DIAG_LIFETIME_COUNTER 0x12\n\n// Maximum length for vehicle identifier string\n#define VEHICLE_IDENTIFIER_MAX_LEN 16\n\n// Structure to hold vehicle configuration parameters\ntypedef struct {\n    uint16_t sensorCalibrationValueA;       // 2 bytes\n    char     vehicleIdentifier[VEHICLE_IDENTIFIER_MAX_LEN]; // 16 bytes buffer for C string\n    uint32_t diagnosticLifetimeCounter;     // 4 bytes\n    uint8_t  featureFlags[4];               // 4 bytes of feature flags\n} VehicleSystemConfiguration;\n\n// Global instance of the vehicle configuration\nstatic VehicleSystemConfiguration g_systemConfig;\n\n// Function to initialize the configuration\nvoid systemConfigInit() {\n    g_systemConfig.sensorCalibrationValueA = 512;\n    strncpy(g_systemConfig.vehicleIdentifier, \"DEFAULT_VIN_XYZ\", VEHICLE_IDENTIFIER_MAX_LEN - 1);\n    g_systemConfig.vehicleIdentifier[VEHICLE_IDENTIFIER_MAX_LEN - 1] = '\\0';\n    g_systemConfig.diagnosticLifetimeCounter = 0;\n    memset(g_systemConfig.featureFlags, 0, sizeof(g_systemConfig.featureFlags));\n}\n\n// Function to process an incoming update request for a specific vehicle parameter\n// This function could be called by a diagnostic service handler or a CAN message handler.\n// paramId: The ID of the parameter to update.\n// data: Pointer to the new data for the parameter.\n// dataLen: The length of the new data in bytes.\nint updateVehicleParameter(uint8_t paramId, const uint8_t* data, uint16_t dataLen) {\n    if (data == NULL || dataLen == 0) {\n        return -1; // Invalid input\n    }\n\n    switch (paramId) {\n        case VEHICLE_PARAM_SENSOR_CALIBRATION_A:\n            if (dataLen == sizeof(uint16_t)) {\n                // Assuming little-endian or byte-order handled by caller/system\n                g_systemConfig.sensorCalibrationValueA = *(uint16_t*)data;\n            } else {\n                return -2; // Incorrect data length for calibration value\n            }\n            break;\n\n        case VEHICLE_PARAM_VEHICLE_IDENTIFIER:\n            // Fix: Add explicit length check against the buffer's capacity\n            uint16_t bytesToCopy = dataLen;\n            if (bytesToCopy >= VEHICLE_IDENTIFIER_MAX_LEN) { // Use >= to account for null terminator space if applicable\n                bytesToCopy = VEHICLE_IDENTIFIER_MAX_LEN - 1; // Truncate to fit, leaving space for null terminator\n            }\n            memcpy(g_systemConfig.vehicleIdentifier, data, bytesToCopy);\n            g_systemConfig.vehicleIdentifier[bytesToCopy] = '\\0'; // Ensure null termination\n            break;\n\n        case VEHICLE_PARAM_DIAG_LIFETIME_COUNTER:\n            if (dataLen == sizeof(uint32_t)) {\n                g_systemConfig.diagnosticLifetimeCounter = *(uint32_t*)data;\n            } else {\n                return -2; // Incorrect data length for lifetime counter\n            }\n            break;\n\n        default:\n            return -3; // Unknown parameter ID\n    }\n\n    return 0; // Parameter updated successfully\n}\n\n// Example usage context (not part of the vulnerability, just for completeness)\nvoid simulateIncomingMessage(uint8_t id, const uint8_t* payload, uint16_t len) {\n    updateVehicleParameter(id, payload, len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CONFIG_NAME_MAX_LEN 32\n#define CONFIG_VALUE_MAX_LEN 64\n#define MAX_CONFIG_PARAMS 10\n\ntypedef enum {\n    PARAM_TYPE_UINT8,\n    PARAM_TYPE_UINT16,\n    PARAM_TYPE_UINT32,\n    PARAM_TYPE_STRING,\n    PARAM_TYPE_BOOL\n} ConfigParamType;\n\ntypedef struct {\n    char name[CONFIG_NAME_MAX_LEN];\n    ConfigParamType type;\n    uint8_t value_len;\n    union {\n        uint8_t  u8_val;\n        uint16_t u16_val;\n        uint32_t u32_val;\n        char     str_val[CONFIG_VALUE_MAX_LEN];\n        bool     bool_val;\n    } value;\n} ConfigurationParameter;\n\nstatic ConfigurationParameter g_vehicleConfig[MAX_CONFIG_PARAMS];\nstatic uint8_t g_numConfigParams = 0;\n\nint parseConfigurationParameter(const uint8_t* stream, uint16_t stream_len, ConfigurationParameter* param_out) {\n    if (stream == NULL || param_out == NULL || stream_len < 2) {\n        return -1;\n    }\n\n    uint16_t bytes_consumed = 0;\n\n    uint8_t name_len = stream[bytes_consumed++];\n    if (name_len >= CONFIG_NAME_MAX_LEN || bytes_consumed + name_len > stream_len) {\n        return -1;\n    }\n    memcpy(param_out->name, stream + bytes_consumed, name_len);\n    param_out->name[name_len] = '\\0';\n    bytes_consumed += name_len;\n\n    param_out->type = (ConfigParamType)stream[bytes_consumed++];\n    if (bytes_consumed > stream_len) {\n        return -1;\n    }\n\n    switch (param_out->type) {\n        case PARAM_TYPE_UINT8:\n            if (bytes_consumed + sizeof(uint8_t) > stream_len) return -1;\n            param_out->value.u8_val = stream[bytes_consumed];\n            param_out->value_len = sizeof(uint8_t);\n            bytes_consumed += sizeof(uint8_t);\n            break;\n        case PARAM_TYPE_UINT16:\n            if (bytes_consumed + sizeof(uint16_t) > stream_len) return -1;\n            param_out->value.u16_val = (uint16_t)((stream[bytes_consumed] << 8) | stream[bytes_consumed+1]);\n            param_out->value_len = sizeof(uint16_t);\n            bytes_consumed += sizeof(uint16_t);\n            break;\n        case PARAM_TYPE_UINT32:\n            if (bytes_consumed + sizeof(uint32_t) > stream_len) return -1;\n            param_out->value.u32_val = (uint32_t)((stream[bytes_consumed] << 24) | (stream[bytes_consumed+1] << 16) |\n                                                   (stream[bytes_consumed+2] << 8) | stream[bytes_consumed+3]);\n            param_out->value_len = sizeof(uint32_t);\n            bytes_consumed += sizeof(uint32_t);\n            break;\n        case PARAM_TYPE_BOOL:\n            if (bytes_consumed + sizeof(bool) > stream_len) return -1;\n            param_out->value.bool_val = (bool)stream[bytes_consumed];\n            param_out->value_len = sizeof(bool);\n            bytes_consumed += sizeof(bool);\n            break;\n        case PARAM_TYPE_STRING:\n            if (bytes_consumed >= stream_len) return -1;\n            uint8_t str_actual_len = stream[bytes_consumed++];\n            if (str_actual_len > CONFIG_VALUE_MAX_LEN || bytes_consumed + str_actual_len > stream_len) {\n                return -1;\n            }\n            memcpy(param_out->value.str_val, stream + bytes_consumed, str_actual_len);\n            param_out->value.str_val[str_actual_len] = '\\0';\n            param_out->value_len = str_actual_len;\n            bytes_consumed += str_actual_len;\n            break;\n        default:\n            return -1;\n    }\n\n    return bytes_consumed;\n}\n\nint loadVehicleConfiguration(const uint8_t* config_stream, uint16_t stream_total_len) {\n    if (config_stream == NULL || stream_total_len == 0) {\n        return -1;\n    }\n\n    uint16_t current_stream_pos = 0;\n    g_numConfigParams = 0;\n\n    while (current_stream_pos < stream_total_len && g_numConfigParams < MAX_CONFIG_PARAMS) {\n        int bytes_parsed = parseConfigurationParameter(\n                                config_stream + current_stream_pos,\n                                stream_total_len - current_stream_pos,\n                                &g_vehicleConfig[g_numConfigParams]\n                           );\n\n        if (bytes_parsed <= 0) {\n            return -1;\n        }\n        current_stream_pos += bytes_parsed;\n        g_numConfigParams++;\n    }\n\n    return 0;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CONFIG_NAME_MAX_LEN 32\n#define CONFIG_VALUE_MAX_LEN 64\n#define MAX_CONFIG_PARAMS 10\n\ntypedef enum {\n    PARAM_TYPE_UINT8,\n    PARAM_TYPE_UINT16,\n    PARAM_TYPE_UINT32,\n    PARAM_TYPE_STRING,\n    PARAM_TYPE_BOOL\n} ConfigParamType;\n\ntypedef struct {\n    char name[CONFIG_NAME_MAX_LEN];\n    ConfigParamType type;\n    uint8_t value_len;\n    union {\n        uint8_t  u8_val;\n        uint16_t u16_val;\n        uint32_t u32_val;\n        char     str_val[CONFIG_VALUE_MAX_LEN];\n        bool     bool_val;\n    } value;\n} ConfigurationParameter;\n\nstatic ConfigurationParameter g_vehicleConfig[MAX_CONFIG_PARAMS];\nstatic uint8_t g_numConfigParams = 0;\n\nint parseConfigurationParameter(const uint8_t* stream, uint16_t stream_len, ConfigurationParameter* param_out) {\n    if (stream == NULL || param_out == NULL || stream_len < 2) {\n        return -1;\n    }\n\n    uint16_t bytes_consumed = 0;\n\n    uint8_t name_len = stream[bytes_consumed++];\n    if (name_len >= CONFIG_NAME_MAX_LEN || bytes_consumed + name_len > stream_len) {\n        return -1;\n    }\n    memcpy(param_out->name, stream + bytes_consumed, name_len);\n    param_out->name[name_len] = '\\0';\n    bytes_consumed += name_len;\n\n    param_out->type = (ConfigParamType)stream[bytes_consumed++];\n    if (bytes_consumed > stream_len) {\n        return -1;\n    }\n\n    switch (param_out->type) {\n        case PARAM_TYPE_UINT8:\n            if (bytes_consumed + sizeof(uint8_t) > stream_len) return -1;\n            param_out->value.u8_val = stream[bytes_consumed];\n            param_out->value_len = sizeof(uint8_t);\n            bytes_consumed += sizeof(uint8_t);\n            break;\n        case PARAM_TYPE_UINT16:\n            if (bytes_consumed + sizeof(uint16_t) > stream_len) return -1;\n            param_out->value.u16_val = (uint16_t)((stream[bytes_consumed] << 8) | stream[bytes_consumed+1]);\n            param_out->value_len = sizeof(uint16_t);\n            bytes_consumed += sizeof(uint16_t);\n            break;\n        case PARAM_TYPE_UINT32:\n            if (bytes_consumed + sizeof(uint32_t) > stream_len) return -1;\n            param_out->value.u32_val = (uint32_t)((stream[bytes_consumed] << 24) | (stream[bytes_consumed+1] << 16) |\n                                                   (stream[bytes_consumed+2] << 8) | stream[bytes_consumed+3]);\n            param_out->value_len = sizeof(uint32_t);\n            bytes_consumed += sizeof(uint32_t);\n            break;\n        case PARAM_TYPE_BOOL:\n            if (bytes_consumed + sizeof(bool) > stream_len) return -1;\n            param_out->value.bool_val = (bool)stream[bytes_consumed];\n            param_out->value_len = sizeof(bool);\n            bytes_consumed += sizeof(bool);\n            break;\n        case PARAM_TYPE_STRING:\n            if (bytes_consumed >= stream_len) return -1;\n            uint8_t str_actual_len = stream[bytes_consumed++];\n            if (str_actual_len >= CONFIG_VALUE_MAX_LEN || bytes_consumed + str_actual_len > stream_len) {\n                return -1;\n            }\n            memcpy(param_out->value.str_val, stream + bytes_consumed, str_actual_len);\n            param_out->value.str_val[str_actual_len] = '\\0';\n            param_out->value_len = str_actual_len;\n            bytes_consumed += str_actual_len;\n            break;\n        default:\n            return -1;\n    }\n\n    return bytes_consumed;\n}\n\nint loadVehicleConfiguration(const uint8_t* config_stream, uint16_t stream_total_len) {\n    if (config_stream == NULL || stream_total_len == 0) {\n        return -1;\n    }\n\n    uint16_t current_stream_pos = 0;\n    g_numConfigParams = 0;\n\n    while (current_stream_pos < stream_total_len && g_numConfigParams < MAX_CONFIG_PARAMS) {\n        int bytes_parsed = parseConfigurationParameter(\n                                config_stream + current_stream_pos,\n                                stream_total_len - current_stream_pos,\n                                &g_vehicleConfig[g_numConfigParams]\n                           );\n\n        if (bytes_parsed <= 0) {\n            return -1;\n        }\n        current_stream_pos += bytes_parsed;\n        g_numConfigParams++;\n    }\n\n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRY_PAYLOAD_SIZE 62\n#define LOG_ACCUMULATOR_BUFFER_SIZE 256\n\ntypedef enum {\n    LOG_TYPE_GENERIC_INFO = 0x01,\n    LOG_TYPE_CRITICAL_FAULT = 0x02,\n    LOG_TYPE_SENSOR_DATA = 0x03,\n    LOG_TYPE_TELEMETRY_EVENT = 0x04\n} LogEntryType;\n\ntypedef struct {\n    uint8_t type;\n    uint8_t data_length;\n    uint8_t data[MAX_LOG_ENTRY_PAYLOAD_SIZE];\n} InternalLogEntry;\n\nstatic uint8_t g_logAccumulatorBuffer[LOG_ACCUMULATOR_BUFFER_SIZE];\nstatic uint16_t g_logAccumulatorCurrentPos = 0;\n\ntypedef struct {\n    const uint8_t* stream_ptr;\n    uint16_t stream_total_len;\n    uint16_t current_stream_offset;\n} DataStreamReaderContext;\n\nint processIncomingLogEntry(DataStreamReaderContext* reader_ctx) {\n    if (reader_ctx == NULL || reader_ctx->stream_ptr == NULL) {\n        return -1;\n    }\n\n    if (reader_ctx->current_stream_offset + 2 > reader_ctx->stream_total_len) {\n        return -1;\n    }\n\n    uint8_t log_type = reader_ctx->stream_ptr[reader_ctx->current_stream_offset];\n    uint8_t payload_len_from_stream = reader_ctx->stream_ptr[reader_ctx->current_stream_offset + 1];\n\n    if (reader_ctx->current_stream_offset + 2 + payload_len_from_stream > reader_ctx->stream_total_len) {\n        return -1;\n    }\n\n    InternalLogEntry temp_log_entry;\n    temp_log_entry.type = log_type;\n    temp_log_entry.data_length = payload_len_from_stream;\n\n    memcpy(temp_log_entry.data, reader_ctx->stream_ptr + reader_ctx->current_stream_offset + 2, payload_len_from_stream);\n\n    uint16_t total_entry_size_to_accumulate = 2 + payload_len_from_stream;\n\n    if (g_logAccumulatorCurrentPos + total_entry_size_to_accumulate > LOG_ACCUMULATOR_BUFFER_SIZE) {\n        return -1;\n    }\n\n    memcpy(g_logAccumulatorBuffer + g_logAccumulatorCurrentPos, &temp_log_entry, total_entry_size_to_accumulate);\n    g_logAccumulatorCurrentPos += total_entry_size_to_accumulate;\n\n    return total_entry_size_to_accumulate;\n}\n\nint processDiagnosticDataBlock(const uint8_t* diagnostic_data, uint16_t data_block_len) {\n    if (diagnostic_data == NULL || data_block_len < 2) {\n        return -1;\n    }\n\n    DataStreamReaderContext reader_ctx = {\n        .stream_ptr = diagnostic_data,\n        .stream_total_len = data_block_len,\n        .current_stream_offset = 0\n    };\n\n    g_logAccumulatorCurrentPos = 0;\n\n    while (reader_ctx.current_stream_offset < reader_ctx.stream_total_len) {\n        int bytes_consumed = processIncomingLogEntry(&reader_ctx);\n        if (bytes_consumed <= 0) {\n            return -1;\n        }\n        reader_ctx.current_stream_offset += bytes_consumed;\n    }\n\n    return g_logAccumulatorCurrentPos;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRY_PAYLOAD_SIZE 62\n#define LOG_ACCUMULATOR_BUFFER_SIZE 256\n\ntypedef enum {\n    LOG_TYPE_GENERIC_INFO = 0x01,\n    LOG_TYPE_CRITICAL_FAULT = 0x02,\n    LOG_TYPE_SENSOR_DATA = 0x03,\n    LOG_TYPE_TELEMETRY_EVENT = 0x04\n} LogEntryType;\n\ntypedef struct {\n    uint8_t type;\n    uint8_t data_length;\n    uint8_t data[MAX_LOG_ENTRY_PAYLOAD_SIZE];\n} InternalLogEntry;\n\nstatic uint8_t g_logAccumulatorBuffer[LOG_ACCUMULATOR_BUFFER_SIZE];\nstatic uint16_t g_logAccumulatorCurrentPos = 0;\n\ntypedef struct {\n    const uint8_t* stream_ptr;\n    uint16_t stream_total_len;\n    uint16_t current_stream_offset;\n} DataStreamReaderContext;\n\nint processIncomingLogEntry(DataStreamReaderContext* reader_ctx) {\n    if (reader_ctx == NULL || reader_ctx->stream_ptr == NULL) {\n        return -1;\n    }\n\n    if (reader_ctx->current_stream_offset + 2 > reader_ctx->stream_total_len) {\n        return -1;\n    }\n\n    uint8_t log_type = reader_ctx->stream_ptr[reader_ctx->current_stream_offset];\n    uint8_t payload_len_from_stream = reader_ctx->stream_ptr[reader_ctx->current_stream_offset + 1];\n\n    if (reader_ctx->current_stream_offset + 2 + payload_len_from_stream > reader_ctx->stream_total_len) {\n        return -1;\n    }\n\n    InternalLogEntry temp_log_entry;\n    temp_log_entry.type = log_type;\n\n    uint8_t bytes_to_copy = payload_len_from_stream;\n    if (bytes_to_copy > MAX_LOG_ENTRY_PAYLOAD_SIZE) {\n        bytes_to_copy = MAX_LOG_ENTRY_PAYLOAD_SIZE;\n    }\n    \n    temp_log_entry.data_length = bytes_to_copy;\n\n    memcpy(temp_log_entry.data, reader_ctx->stream_ptr + reader_ctx->current_stream_offset + 2, bytes_to_copy);\n\n    uint16_t total_entry_size_consumed_from_stream = 2 + payload_len_from_stream;\n\n    uint16_t total_entry_size_to_store_in_accumulator = 2 + bytes_to_copy;\n\n    if (g_logAccumulatorCurrentPos + total_entry_size_to_store_in_accumulator > LOG_ACCUMULATOR_BUFFER_SIZE) {\n        return -1;\n    }\n\n    memcpy(g_logAccumulatorBuffer + g_logAccumulatorCurrentPos, &temp_log_entry, total_entry_size_to_store_in_accumulator);\n    g_logAccumulatorCurrentPos += total_entry_size_to_store_in_accumulator;\n\n    return total_entry_size_consumed_from_stream;\n}\n\nint processDiagnosticDataBlock(const uint8_t* diagnostic_data, uint16_t data_block_len) {\n    if (diagnostic_data == NULL || data_block_len < 2) {\n        return -1;\n    }\n\n    DataStreamReaderContext reader_ctx = {\n        .stream_ptr = diagnostic_data,\n        .stream_total_len = data_block_len,\n        .current_stream_offset = 0\n    };\n\n    g_logAccumulatorCurrentPos = 0;\n\n    while (reader_ctx.current_stream_offset < reader_ctx.stream_total_len) {\n        int bytes_consumed = processIncomingLogEntry(&reader_ctx);\n        if (bytes_consumed <= 0) {\n            return -1;\n        }\n        reader_ctx.current_stream_offset += bytes_consumed;\n    }\n\n    return g_logAccumulatorCurrentPos;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_PACKET_PAYLOAD_SIZE 500\n#define TELEMETRY_HEADER_SIZE 5\n\n#define TEMP_DISPLAY_BUFFER_CAPACITY 80\n\ntypedef enum {\n    TELEMETRY_TYPE_INVALID = 0x00,\n    TELEMETRY_TYPE_SENSOR_READING = 0x01,\n    TELEMETRY_TYPE_EVENT_LOG = 0x02,\n    TELEMETRY_TYPE_DIAGNOSTIC_FAULT = 0x03\n} TelemetryPacketType;\n\nvoid displayEventDescription(const uint8_t* description_data, uint8_t description_len) {\n    char temp_display_buffer[TEMP_DISPLAY_BUFFER_CAPACITY];\n\n    if (description_data == NULL) {\n        return;\n    }\n\n    memcpy(temp_display_buffer, description_data, description_len);\n\n    if (description_len < TEMP_DISPLAY_BUFFER_CAPACITY) {\n        temp_display_buffer[description_len] = '\\0';\n    } else {\n        temp_display_buffer[TEMP_DISPLAY_BUFFER_CAPACITY - 1] = '\\0';\n    }\n}\n\nint handleIncomingTelemetryFrame(const uint8_t* frame_data, uint16_t frame_len) {\n    if (frame_data == NULL || frame_len < TELEMETRY_HEADER_SIZE) {\n        return -1;\n    }\n\n    uint16_t packet_id = (frame_data[0] << 8) | frame_data[1];\n    uint8_t packet_type = frame_data[2];\n    uint16_t payload_len = (frame_data[3] << 8) | frame_data[4];\n\n    if (TELEMETRY_HEADER_SIZE + payload_len > frame_len) {\n        return -1;\n    }\n\n    if (payload_len > MAX_PACKET_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    const uint8_t* payload_ptr = frame_data + TELEMETRY_HEADER_SIZE;\n\n    switch (packet_type) {\n        case TELEMETRY_TYPE_EVENT_LOG: {\n            uint16_t min_event_payload_size = sizeof(uint32_t) + sizeof(uint16_t) + sizeof(uint8_t);\n            if (payload_len < min_event_payload_size) {\n                return -1;\n            }\n\n            uint32_t timestamp = (payload_ptr[0] << 24) | (payload_ptr[1] << 16) |\n                                 (payload_ptr[2] << 8) | payload_ptr[3];\n            uint16_t event_code = (payload_ptr[4] << 8) | payload_ptr[5];\n            uint8_t description_len = payload_ptr[6];\n\n            if (description_len > (payload_len - min_event_payload_size)) {\n                return -1;\n            }\n\n            const uint8_t* description_ptr = payload_ptr + min_event_payload_size;\n\n            displayEventDescription(description_ptr, description_len);\n            break;\n        }\n        case TELEMETRY_TYPE_SENSOR_READING:\n            break;\n        case TELEMETRY_TYPE_DIAGNOSTIC_FAULT:\n            break;\n        default:\n            return -1;\n    }\n\n    return 0;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_PACKET_PAYLOAD_SIZE 500\n#define TELEMETRY_HEADER_SIZE 5\n\n#define TEMP_DISPLAY_BUFFER_CAPACITY 80\n\ntypedef enum {\n    TELEMETRY_TYPE_INVALID = 0x00,\n    TELEMETRY_TYPE_SENSOR_READING = 0x01,\n    TELEMETRY_TYPE_EVENT_LOG = 0x02,\n    TELEMETRY_TYPE_DIAGNOSTIC_FAULT = 0x03\n} TelemetryPacketType;\n\nvoid displayEventDescription(const uint8_t* description_data, uint8_t description_len) {\n    char temp_display_buffer[TEMP_DISPLAY_BUFFER_CAPACITY];\n\n    if (description_data == NULL) {\n        return;\n    }\n\n    uint8_t bytes_to_copy = description_len;\n    if (bytes_to_copy >= TEMP_DISPLAY_BUFFER_CAPACITY) {\n        bytes_to_copy = TEMP_DISPLAY_BUFFER_CAPACITY - 1;\n    }\n    \n    memcpy(temp_display_buffer, description_data, bytes_to_copy);\n    temp_display_buffer[bytes_to_copy] = '\\0';\n}\n\nint handleIncomingTelemetryFrame(const uint8_t* frame_data, uint16_t frame_len) {\n    if (frame_data == NULL || frame_len < TELEMETRY_HEADER_SIZE) {\n        return -1;\n    }\n\n    uint16_t packet_id = (frame_data[0] << 8) | frame_data[1];\n    uint8_t packet_type = frame_data[2];\n    uint16_t payload_len = (frame_data[3] << 8) | frame_data[4];\n\n    if (TELEMETRY_HEADER_SIZE + payload_len > frame_len) {\n        return -1;\n    }\n\n    if (payload_len > MAX_PACKET_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    const uint8_t* payload_ptr = frame_data + TELEMETRY_HEADER_SIZE;\n\n    switch (packet_type) {\n        case TELEMETRY_TYPE_EVENT_LOG: {\n            uint16_t min_event_payload_size = sizeof(uint32_t) + sizeof(uint16_t) + sizeof(uint8_t);\n            if (payload_len < min_event_payload_size) {\n                return -1;\n            }\n\n            uint32_t timestamp = (payload_ptr[0] << 24) | (payload_ptr[1] << 16) |\n                                 (payload_ptr[2] << 8) | payload_ptr[3];\n            uint16_t event_code = (payload_ptr[4] << 8) | payload_ptr[5];\n            uint8_t description_len = payload_ptr[6];\n\n            if (description_len > (payload_len - min_event_payload_size)) {\n                return -1;\n            }\n\n            const uint8_t* description_ptr = payload_ptr + min_event_payload_size;\n\n            displayEventDescription(description_ptr, description_len);\n            break;\n        }\n        case TELEMETRY_TYPE_SENSOR_READING:\n            break;\n        case TELEMETRY_TYPE_DIAGNOSTIC_FAULT:\n            break;\n        default:\n            return -1;\n    }\n\n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_MSG_SIZE 1024\n#define DIAG_DATA_RECORD_BUF_SIZE 100\n\n#define DIAG_CMD_READ_DATA_BY_ID 0x22\n#define DIAG_CMD_WRITE_DATA_BY_ID 0x2E\n#define DIAG_CMD_ROUTINE_CONTROL 0x31\n\ntypedef struct {\n    uint8_t service_id;\n    uint16_t data_identifier;\n    uint16_t data_offset_in_pdu;\n    uint16_t data_length;\n} DiagServiceRecordHeader;\n\nstatic uint8_t g_currentDiagPDU[MAX_DIAG_MSG_SIZE];\nstatic uint16_t g_currentPDULength = 0;\n\nstatic uint8_t g_dataRecordProcessingBuffer[DIAG_DATA_RECORD_BUF_SIZE];\n\nvoid resetDiagnosticPDU() {\n    memset(g_currentDiagPDU, 0, sizeof(g_currentDiagPDU));\n    g_currentPDULength = 0;\n}\n\nint receiveDiagnosticPDU(const uint8_t* pdu_data, uint16_t pdu_len) {\n    if (pdu_data == NULL || pdu_len == 0 || pdu_len > MAX_DIAG_MSG_SIZE) {\n        return -1;\n    }\n    memcpy(g_currentDiagPDU, pdu_data, pdu_len);\n    g_currentPDULength = pdu_len;\n    return 0;\n}\n\nint processDiagDataRecordPayload(const DiagServiceRecordHeader* record_header) {\n    if (record_header == NULL) {\n        return -1;\n    }\n\n    uint16_t payload_offset = record_header->data_offset_in_pdu;\n    uint16_t payload_len = record_header->data_length;\n\n    if (payload_offset + payload_len > g_currentPDULength) {\n        return -1;\n    }\n\n    const uint8_t* source_ptr = g_currentDiagPDU + payload_offset;\n\n    memcpy(g_dataRecordProcessingBuffer, source_ptr, payload_len);\n\n    if (record_header->service_id == DIAG_CMD_READ_DATA_BY_ID) {\n\n    } else if (record_header->service_id == DIAG_CMD_WRITE_DATA_BY_ID) {\n\n    }\n    \n    return 0;\n}\n\nint handleIncomingDiagnosticMessage(const uint8_t* raw_pdu, uint16_t raw_pdu_len) {\n    if (receiveDiagnosticPDU(raw_pdu, raw_pdu_len) != 0) {\n        return -1;\n    }\n\n    if (raw_pdu_len < sizeof(DiagServiceRecordHeader)) {\n        return -1;\n    }\n\n    DiagServiceRecordHeader parsed_header;\n    memcpy(&parsed_header, g_currentDiagPDU, sizeof(DiagServiceRecordHeader));\n\n    return processDiagDataRecordPayload(&parsed_header);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_MSG_SIZE 1024\n#define DIAG_DATA_RECORD_BUF_SIZE 100\n\n#define DIAG_CMD_READ_DATA_BY_ID 0x22\n#define DIAG_CMD_WRITE_DATA_BY_ID 0x2E\n#define DIAG_CMD_ROUTINE_CONTROL 0x31\n\ntypedef struct {\n    uint8_t service_id;\n    uint16_t data_identifier;\n    uint16_t data_offset_in_pdu;\n    uint16_t data_length;\n} DiagServiceRecordHeader;\n\nstatic uint8_t g_currentDiagPDU[MAX_DIAG_MSG_SIZE];\nstatic uint16_t g_currentPDULength = 0;\n\nstatic uint8_t g_dataRecordProcessingBuffer[DIAG_DATA_RECORD_BUF_SIZE];\n\nvoid resetDiagnosticPDU() {\n    memset(g_currentDiagPDU, 0, sizeof(g_currentDiagPDU));\n    g_currentPDULength = 0;\n}\n\nint receiveDiagnosticPDU(const uint8_t* pdu_data, uint16_t pdu_len) {\n    if (pdu_data == NULL || pdu_len == 0 || pdu_len > MAX_DIAG_MSG_SIZE) {\n        return -1;\n    }\n    memcpy(g_currentDiagPDU, pdu_data, pdu_len);\n    g_currentPDULength = pdu_len;\n    return 0;\n}\n\nint processDiagDataRecordPayload(const DiagServiceRecordHeader* record_header) {\n    if (record_header == NULL) {\n        return -1;\n    }\n\n    uint16_t payload_offset = record_header->data_offset_in_pdu;\n    uint16_t payload_len = record_header->data_length;\n\n    if (payload_offset + payload_len > g_currentPDULength) {\n        return -1;\n    }\n\n    const uint8_t* source_ptr = g_currentDiagPDU + payload_offset;\n\n    uint16_t bytes_to_copy = payload_len;\n    if (bytes_to_copy > DIAG_DATA_RECORD_BUF_SIZE) {\n        bytes_to_copy = DIAG_DATA_RECORD_BUF_SIZE;\n    }\n    \n    memcpy(g_dataRecordProcessingBuffer, source_ptr, bytes_to_copy);\n\n    if (record_header->service_id == DIAG_CMD_READ_DATA_BY_ID) {\n\n    } else if (record_header->service_id == DIAG_CMD_WRITE_DATA_BY_ID) {\n\n    }\n    \n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_FIRMWARE_CHUNK_SIZE 256\n#define FIRMWARE_BLOCK_BUFFER_SIZE 4096\n#define TOTAL_FIRMWARE_IMAGE_SIZE 1048576\n\ntypedef struct {\n    uint32_t address_offset;\n    uint16_t data_length;\n    uint8_t  data[MAX_FIRMWARE_CHUNK_SIZE];\n} FirmwarePacket;\n\ntypedef struct {\n    uint32_t current_block_address;\n    uint8_t  firmware_block_buffer[FIRMWARE_BLOCK_BUFFER_SIZE];\n    uint32_t bytes_in_current_block;\n    bool     update_in_progress;\n} FirmwareUpdateContext;\n\nstatic FirmwareUpdateContext g_fwUpdateContext = {0};\n\nvoid initFirmwareUpdater() {\n    memset(&g_fwUpdateContext, 0, sizeof(FirmwareUpdateContext));\n    g_fwUpdateContext.update_in_progress = false;\n}\n\nint handleFirmwarePacket(const FirmwarePacket* packet) {\n    if (packet == NULL || packet->data_length == 0 || packet->data_length > MAX_FIRMWARE_CHUNK_SIZE) {\n        return -1;\n    }\n\n    if (!g_fwUpdateContext.update_in_progress) {\n        return -1;\n    }\n\n    uint32_t global_target_offset = packet->address_offset;\n    uint16_t chunk_len = packet->data_length;\n\n    if (global_target_offset + chunk_len > TOTAL_FIRMWARE_IMAGE_SIZE) {\n        return -2;\n    }\n\n    uint32_t packet_block_base_address = global_target_offset / FIRMWARE_BLOCK_BUFFER_SIZE * FIRMWARE_BLOCK_BUFFER_SIZE;\n    uint32_t offset_within_block = global_target_offset % FIRMWARE_BLOCK_BUFFER_SIZE;\n\n    if (g_fwUpdateContext.current_block_address != packet_block_base_address) {\n        memset(g_fwUpdateContext.firmware_block_buffer, 0, FIRMWARE_BLOCK_BUFFER_SIZE);\n        g_fwUpdateContext.bytes_in_current_block = 0;\n        g_fwUpdateContext.current_block_address = packet_block_base_address;\n    }\n\n    memcpy(g_fwUpdateContext.firmware_block_buffer + offset_within_block, packet->data, chunk_len);\n\n    if (offset_within_block + chunk_len > g_fwUpdateContext.bytes_in_current_block) {\n        g_fwUpdateContext.bytes_in_current_block = offset_within_block + chunk_len;\n    }\n\n    return 0;\n}\n\nvoid startFirmwareUpdate() {\n    g_fwUpdateContext.update_in_progress = true;\n    g_fwUpdateContext.current_block_address = 0;\n    g_fwUpdateContext.bytes_in_current_block = 0;\n    memset(g_fwUpdateContext.firmware_block_buffer, 0, FIRMWARE_BLOCK_BUFFER_SIZE);\n}\n\nvoid endFirmwareUpdate() {\n    g_fwUpdateContext.update_in_progress = false;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_FIRMWARE_CHUNK_SIZE 256\n#define FIRMWARE_BLOCK_BUFFER_SIZE 4096\n#define TOTAL_FIRMWARE_IMAGE_SIZE 1048576\n\ntypedef struct {\n    uint32_t address_offset;\n    uint16_t data_length;\n    uint8_t  data[MAX_FIRMWARE_CHUNK_SIZE];\n} FirmwarePacket;\n\ntypedef struct {\n    uint32_t current_block_address;\n    uint8_t  firmware_block_buffer[FIRMWARE_BLOCK_BUFFER_SIZE];\n    uint32_t bytes_in_current_block;\n    bool     update_in_progress;\n} FirmwareUpdateContext;\n\nstatic FirmwareUpdateContext g_fwUpdateContext = {0};\n\nvoid initFirmwareUpdater() {\n    memset(&g_fwUpdateContext, 0, sizeof(FirmwareUpdateContext));\n    g_fwUpdateContext.update_in_progress = false;\n}\n\nint handleFirmwarePacket(const FirmwarePacket* packet) {\n    if (packet == NULL || packet->data_length == 0 || packet->data_length > MAX_FIRMWARE_CHUNK_SIZE) {\n        return -1;\n    }\n\n    if (!g_fwUpdateContext.update_in_progress) {\n        return -1;\n    }\n\n    uint32_t global_target_offset = packet->address_offset;\n    uint16_t chunk_len = packet->data_length;\n\n    if (global_target_offset + chunk_len > TOTAL_FIRMWARE_IMAGE_SIZE) {\n        return -2;\n    }\n\n    uint32_t packet_block_base_address = global_target_offset / FIRMWARE_BLOCK_BUFFER_SIZE * FIRMWARE_BLOCK_BUFFER_SIZE;\n    uint32_t offset_within_block = global_target_offset % FIRMWARE_BLOCK_BUFFER_SIZE;\n\n    if (g_fwUpdateContext.current_block_address != packet_block_base_address) {\n        memset(g_fwUpdateContext.firmware_block_buffer, 0, FIRMWARE_BLOCK_BUFFER_SIZE);\n        g_fwUpdateContext.bytes_in_current_block = 0;\n        g_fwUpdateContext.current_block_address = packet_block_base_address;\n    }\n\n    if (offset_within_block + chunk_len > FIRMWARE_BLOCK_BUFFER_SIZE) {\n        return -3;\n    }\n\n    memcpy(g_fwUpdateContext.firmware_block_buffer + offset_within_block, packet->data, chunk_len);\n\n    if (offset_within_block + chunk_len > g_fwUpdateContext.bytes_in_current_block) {\n        g_fwUpdateContext.bytes_in_current_block = offset_within_block + chunk_len;\n    }\n\n    return 0;\n}\n\nvoid startFirmwareUpdate() {\n    g_fwUpdateContext.update_in_progress = true;\n    g_fwUpdateContext.current_block_address = 0;\n    g_fwUpdateContext.bytes_in_current_block = 0;\n    memset(g_fwUpdateContext.firmware_block_buffer, 0, FIRMWARE_BLOCK_BUFFER_SIZE);\n}\n\nvoid endFirmwareUpdate() {\n    g_fwUpdateContext.update_in_progress = false;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAG_MESSAGE_MAX_SIZE 1024\n#define MAX_RECORD_PAYLOAD_SIZE 128\n#define TEMP_PROCESSING_BUFFER_SIZE 64\n\ntypedef struct {\n    uint16_t message_id;\n    uint16_t total_payload_len;\n} DiagnosticMessageHeader;\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_len;\n} DiagnosticRecordMinimalHeader;\n\nint processDiagnosticMessage(const uint8_t* msg_buffer, uint16_t msg_len) {\n    if (msg_buffer == NULL || msg_len < sizeof(DiagnosticMessageHeader)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n    \n    uint16_t message_id = (msg_buffer[0] << 8) | msg_buffer[1];\n    current_offset += sizeof(uint16_t);\n\n    uint16_t total_payload_len = (msg_buffer[current_offset] << 8) | msg_buffer[current_offset+1];\n    current_offset += sizeof(uint16_t);\n\n    if (current_offset + total_payload_len > msg_len) {\n        return -2;\n    }\n\n    uint16_t payload_bytes_processed = 0;\n    while (payload_bytes_processed < total_payload_len) {\n        if (payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader) > total_payload_len) {\n            return -3;\n        }\n\n        const DiagnosticRecordMinimalHeader* record_header = \n            (const DiagnosticRecordMinimalHeader*)(msg_buffer + current_offset + payload_bytes_processed);\n        \n        uint8_t record_type = record_header->record_type;\n        uint8_t record_data_len = record_header->record_len; \n\n        if (record_data_len > MAX_RECORD_PAYLOAD_SIZE ||\n            payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader) + record_data_len > total_payload_len) {\n            return -4;\n        }\n\n        const uint8_t* record_data_ptr = msg_buffer + current_offset + payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader);\n\n        if (record_type == 0x05) {\n            char temp_processing_buffer[TEMP_PROCESSING_BUFFER_SIZE];\n\n            memcpy(temp_processing_buffer, record_data_ptr, record_data_len);\n\n            if (record_data_len < TEMP_PROCESSING_BUFFER_SIZE) {\n                temp_processing_buffer[record_data_len] = '\\0';\n            } else {\n                temp_processing_buffer[TEMP_PROCESSING_BUFFER_SIZE - 1] = '\\0';\n            }\n        }\n\n        payload_bytes_processed += sizeof(DiagnosticRecordMinimalHeader) + record_data_len;\n    }\n\n    return 0;\n}\n\nvoid simulateIncomingDiagnosticFrame(const uint8_t* data, uint16_t length) {\n    processDiagnosticMessage(data, length);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAG_MESSAGE_MAX_SIZE 1024\n#define MAX_RECORD_PAYLOAD_SIZE 128\n#define TEMP_PROCESSING_BUFFER_SIZE 64\n\ntypedef struct {\n    uint16_t message_id;\n    uint16_t total_payload_len;\n} DiagnosticMessageHeader;\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_len;\n} DiagnosticRecordMinimalHeader;\n\nint processDiagnosticMessage(const uint8_t* msg_buffer, uint16_t msg_len) {\n    if (msg_buffer == NULL || msg_len < sizeof(DiagnosticMessageHeader)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n    \n    uint16_t message_id = (msg_buffer[0] << 8) | msg_buffer[1];\n    current_offset += sizeof(uint16_t);\n\n    uint16_t total_payload_len = (msg_buffer[current_offset] << 8) | msg_buffer[current_offset+1];\n    current_offset += sizeof(uint16_t);\n\n    if (current_offset + total_payload_len > msg_len) {\n        return -2;\n    }\n\n    uint16_t payload_bytes_processed = 0;\n    while (payload_bytes_processed < total_payload_len) {\n        if (payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader) > total_payload_len) {\n            return -3;\n        }\n\n        const DiagnosticRecordMinimalHeader* record_header = \n            (const DiagnosticRecordMinimalHeader*)(msg_buffer + current_offset + payload_bytes_processed);\n        \n        uint8_t record_type = record_header->record_type;\n        uint8_t record_data_len = record_header->record_len; \n\n        if (record_data_len > MAX_RECORD_PAYLOAD_SIZE ||\n            payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader) + record_data_len > total_payload_len) {\n            return -4;\n        }\n\n        const uint8_t* record_data_ptr = msg_buffer + current_offset + payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader);\n\n        if (record_type == 0x05) {\n            char temp_processing_buffer[TEMP_PROCESSING_BUFFER_SIZE];\n            uint8_t bytes_to_copy = record_data_len;\n\n            if (bytes_to_copy >= TEMP_PROCESSING_BUFFER_SIZE) {\n                bytes_to_copy = TEMP_PROCESSING_BUFFER_SIZE - 1;\n            }\n            \n            memcpy(temp_processing_buffer, record_data_ptr, bytes_to_copy);\n            temp_processing_buffer[bytes_to_copy] = '\\0';\n        }\n\n        payload_bytes_processed += sizeof(DiagnosticRecordMinimalHeader) + record_data_len;\n    }\n\n    return 0;\n}\n\nvoid simulateIncomingDiagnosticFrame(const uint8_t* data, uint16_t length) {\n    processDiagnosticMessage(data, length);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_PAYLOAD_SIZE 256\n#define MAX_VEHICLE_FEATURES 32\n\ntypedef struct {\n    uint8_t feature_index; \n    uint8_t new_state;     \n} FeatureUpdateRequest;\n\nstatic uint8_t g_vehicleFeatureStates[MAX_VEHICLE_FEATURES]; \n\nvoid initVehicleFeatures() {\n    memset(g_vehicleFeatureStates, 0, sizeof(g_vehicleFeatureStates));\n}\n\nint processFeatureUpdateCommand(const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len < 1) {\n        return -1; \n    }\n\n    uint8_t num_updates = payload[0];\n    uint16_t expected_len = 1 + (num_updates * sizeof(FeatureUpdateRequest));\n\n    if (expected_len > payload_len) {\n        return -1; \n    }\n\n    for (uint8_t i = 0; i < num_updates; ++i) {\n        uint16_t current_offset = 1 + (i * sizeof(FeatureUpdateRequest));\n        \n        if (current_offset + sizeof(FeatureUpdateRequest) > payload_len) {\n            return -1; \n        }\n\n        FeatureUpdateRequest current_request;\n        current_request.feature_index = payload[current_offset];\n        current_request.new_state = payload[current_offset + 1];\n\n        g_vehicleFeatureStates[current_request.feature_index] = current_request.new_state;\n    }\n\n    return 0; \n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_PAYLOAD_SIZE 256\n#define MAX_VEHICLE_FEATURES 32\n\ntypedef struct {\n    uint8_t feature_index; \n    uint8_t new_state;     \n} FeatureUpdateRequest;\n\nstatic uint8_t g_vehicleFeatureStates[MAX_VEHICLE_FEATURES]; \n\nvoid initVehicleFeatures() {\n    memset(g_vehicleFeatureStates, 0, sizeof(g_vehicleFeatureStates));\n}\n\nint processFeatureUpdateCommand(const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len < 1) {\n        return -1; \n    }\n\n    uint8_t num_updates = payload[0];\n    uint16_t expected_len = 1 + (num_updates * sizeof(FeatureUpdateRequest));\n\n    if (expected_len > payload_len || expected_len > MAX_DIAG_PAYLOAD_SIZE) {\n        return -1; \n    }\n\n    for (uint8_t i = 0; i < num_updates; ++i) {\n        uint16_t current_offset = 1 + (i * sizeof(FeatureUpdateRequest));\n        \n        if (current_offset + sizeof(FeatureUpdateRequest) > payload_len) {\n            return -1; \n        }\n\n        FeatureUpdateRequest current_request;\n        current_request.feature_index = payload[current_offset];\n        current_request.new_state = payload[current_offset + 1];\n\n        if (current_request.feature_index >= MAX_VEHICLE_FEATURES) {\n            return -2; \n        }\n        \n        g_vehicleFeatureStates[current_request.feature_index] = current_request.new_state;\n    }\n\n    return 0; \n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_LOG_BUFFER_SIZE 4096\n#define MAX_DTC_SNAPSHOT_DATA 1024\n\ntypedef struct {\n    uint16_t dtcCode;\n    uint32_t timestamp;\n    uint16_t snapshotDataLen;\n} DiagLogEntryHeader;\n\nstatic uint8_t g_diagLogBuffer[DIAG_LOG_BUFFER_SIZE];\nstatic uint32_t g_logWritePointer = 0;\n\nvoid initDiagnosticLog() {\n    memset(g_diagLogBuffer, 0, DIAG_LOG_BUFFER_SIZE);\n    g_logWritePointer = 0;\n}\n\nint addDiagnosticEventToLog(uint16_t dtc, uint32_t timestamp, const uint8_t* snapshot_data, uint16_t snapshot_data_len) {\n    if (snapshot_data == NULL && snapshot_data_len > 0) {\n        return -1;\n    }\n\n    uint32_t entry_header_size = sizeof(DiagLogEntryHeader);\n    uint32_t entry_total_size = entry_header_size + snapshot_data_len;\n\n    if (g_logWritePointer + entry_total_size > DIAG_LOG_BUFFER_SIZE) {\n        g_logWritePointer = 0;\n    }\n\n    DiagLogEntryHeader header;\n    header.dtcCode = dtc;\n    header.timestamp = timestamp;\n    header.snapshotDataLen = snapshot_data_len;\n\n    memcpy(g_diagLogBuffer + g_logWritePointer, &header, entry_header_size);\n    g_logWritePointer += entry_header_size;\n\n    memcpy(g_diagLogBuffer + g_logWritePointer, snapshot_data, snapshot_data_len);\n    g_logWritePointer += snapshot_data_len;\n\n    return 0;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_LOG_BUFFER_SIZE 4096\n#define MAX_DTC_SNAPSHOT_DATA 1024\n\ntypedef struct {\n    uint16_t dtcCode;\n    uint32_t timestamp;\n    uint16_t snapshotDataLen;\n} DiagLogEntryHeader;\n\nstatic uint8_t g_diagLogBuffer[DIAG_LOG_BUFFER_SIZE];\nstatic uint32_t g_logWritePointer = 0;\n\nvoid initDiagnosticLog() {\n    memset(g_diagLogBuffer, 0, DIAG_LOG_BUFFER_SIZE);\n    g_logWritePointer = 0;\n}\n\nint addDiagnosticEventToLog(uint16_t dtc, uint32_t timestamp, const uint8_t* snapshot_data, uint16_t snapshot_data_len) {\n    if (snapshot_data == NULL && snapshot_data_len > 0) {\n        return -1;\n    }\n\n    if (snapshot_data_len > MAX_DTC_SNAPSHOT_DATA) {\n        return -2;\n    }\n\n    uint32_t entry_header_size = sizeof(DiagLogEntryHeader);\n    uint32_t entry_total_size = entry_header_size + snapshot_data_len;\n\n    if (entry_total_size > DIAG_LOG_BUFFER_SIZE) {\n        return -3;\n    }\n\n    if (g_logWritePointer + entry_total_size > DIAG_LOG_BUFFER_SIZE) {\n        g_logWritePointer = 0;\n    }\n\n    DiagLogEntryHeader header;\n    header.dtcCode = dtc;\n    header.timestamp = timestamp;\n    header.snapshotDataLen = snapshot_data_len;\n\n    memcpy(g_diagLogBuffer + g_logWritePointer, &header, entry_header_size);\n    g_logWritePointer += entry_header_size;\n\n    memcpy(g_diagLogBuffer + g_logWritePointer, snapshot_data, snapshot_data_len);\n    g_logWritePointer += snapshot_data_len;\n\n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 64\n#define MAX_COMMAND_PAYLOAD_SIZE 128\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t parameter_idx;\n    uint8_t data_length;\n    uint8_t data[MAX_COMMAND_PAYLOAD_SIZE - 3];\n} VehicleCommand;\n\nstatic uint8_t g_vehicleConfigArea[VEHICLE_CONFIG_BUFFER_SIZE];\n\nvoid initVehicleConfigArea() {\n    memset(g_vehicleConfigArea, 0x00, VEHICLE_CONFIG_BUFFER_SIZE);\n}\n\n#define CMD_UPDATE_CONFIG_DATA 0x05\n#define CMD_READ_CONFIG_DATA   0x06\n\nint processVehicleCommand(const VehicleCommand* cmd) {\n    if (cmd == NULL) {\n        return -1;\n    }\n\n    if (cmd->command_id == CMD_UPDATE_CONFIG_DATA) {\n        uint8_t start_offset = cmd->parameter_idx;\n        uint8_t data_to_copy = cmd->data_length;\n\n        if (start_offset >= VEHICLE_CONFIG_BUFFER_SIZE) {\n            return -2;\n        }\n\n        if (data_to_copy > (MAX_COMMAND_PAYLOAD_SIZE - (sizeof(cmd->command_id) + sizeof(cmd->parameter_idx) + sizeof(cmd->data_length)))) {\n             return -3;\n        }\n\n        memcpy(g_vehicleConfigArea + start_offset, cmd->data, data_to_copy);\n\n        return 0;\n    } else if (cmd->command_id == CMD_READ_CONFIG_DATA) {\n        return 0;\n    }\n    \n    return -4;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 64\n#define MAX_COMMAND_PAYLOAD_SIZE 128\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t parameter_idx;\n    uint8_t data_length;\n    uint8_t data[MAX_COMMAND_PAYLOAD_SIZE - 3];\n} VehicleCommand;\n\nstatic uint8_t g_vehicleConfigArea[VEHICLE_CONFIG_BUFFER_SIZE];\n\nvoid initVehicleConfigArea() {\n    memset(g_vehicleConfigArea, 0x00, VEHICLE_CONFIG_BUFFER_SIZE);\n}\n\n#define CMD_UPDATE_CONFIG_DATA 0x05\n#define CMD_READ_CONFIG_DATA   0x06\n\nint processVehicleCommand(const VehicleCommand* cmd) {\n    if (cmd == NULL) {\n        return -1;\n    }\n\n    if (cmd->command_id == CMD_UPDATE_CONFIG_DATA) {\n        uint8_t start_offset = cmd->parameter_idx;\n        uint8_t data_to_copy = cmd->data_length;\n\n        if (start_offset >= VEHICLE_CONFIG_BUFFER_SIZE) {\n            return -2;\n        }\n\n        if (data_to_copy > (MAX_COMMAND_PAYLOAD_SIZE - (sizeof(cmd->command_id) + sizeof(cmd->parameter_idx) + sizeof(cmd->data_length)))) {\n             return -3;\n        }\n\n        uint8_t available_space = VEHICLE_CONFIG_BUFFER_SIZE - start_offset;\n        uint8_t actual_bytes_to_copy = data_to_copy;\n\n        if (actual_bytes_to_copy > available_space) {\n            actual_bytes_to_copy = available_space;\n        }\n\n        memcpy(g_vehicleConfigArea + start_offset, cmd->data, actual_bytes_to_copy);\n\n        if (data_to_copy > actual_bytes_to_copy) {\n            return -5;\n        }\n\n        return 0;\n    } else if (cmd->command_id == CMD_READ_CONFIG_DATA) {\n        return 0;\n    }\n    \n    return -4;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define DATA_LOG_BUFFER_SIZE 256\n#define MAX_LOG_ENTRY_PAYLOAD_SIZE 60\n\ntypedef struct {\n    uint8_t  type;\n    uint8_t  payload_len;\n} LogEntryHeader;\n\nstatic uint8_t g_logBuffer[DATA_LOG_BUFFER_SIZE];\nstatic uint16_t g_logBufferWriteHead = 0;\n\nvoid initDataLogger() {\n    memset(g_logBuffer, 0, DATA_LOG_BUFFER_SIZE);\n    g_logBufferWriteHead = 0;\n}\n\nint addLogEntry(uint8_t type, const uint8_t* payload_data, uint8_t payload_len) {\n    if (payload_data == NULL) {\n        return -1;\n    }\n\n    if (payload_len > MAX_LOG_ENTRY_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    uint16_t required_total_entry_size = sizeof(LogEntryHeader) + payload_len;\n\n    if (required_total_entry_size > DATA_LOG_BUFFER_SIZE) {\n        return -3;\n    }\n\n    // Construct the header\n    LogEntryHeader header = { .type = type, .payload_len = payload_len };\n\n    // Write header to current position\n    memcpy(g_logBuffer + g_logBufferWriteHead, &header, sizeof(LogEntryHeader));\n    uint16_t current_entry_payload_offset = g_logBufferWriteHead + sizeof(LogEntryHeader);\n\n    // Write payload data following the header\n    // VULNERABILITY: If current_entry_payload_offset + payload_len extends beyond DATA_LOG_BUFFER_SIZE,\n    // this memcpy will write out-of-bounds, even though the total required_total_entry_size fits\n    // into the conceptual circular buffer space. The single memcpy doesn't handle wrapping.\n    memcpy(g_logBuffer + current_entry_payload_offset, payload_data, payload_len);\n\n    // Update write head for the next entry, correctly handling circular buffer logic\n    g_logBufferWriteHead = (g_logBufferWriteHead + required_total_entry_size) % DATA_LOG_BUFFER_SIZE;\n\n    return 0;\n}\n\n// Dummy function to simulate usage in a larger context (e.g., error handling)\nvoid simulateSensorDTCLog(uint8_t dtc_code, const uint8_t* dtc_data, uint8_t data_len) {\n    // In a real scenario, dtc_data might contain additional diagnostic info\n    // The dtc_code itself could be part of the payload or processed separately.\n    // Here, we just pass the raw data.\n    addLogEntry(dtc_code, dtc_data, data_len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define DATA_LOG_BUFFER_SIZE 256\n#define MAX_LOG_ENTRY_PAYLOAD_SIZE 60\n\ntypedef struct {\n    uint8_t  type;\n    uint8_t  payload_len;\n} LogEntryHeader;\n\nstatic uint8_t g_logBuffer[DATA_LOG_BUFFER_SIZE];\nstatic uint16_t g_logBufferWriteHead = 0;\n\nvoid initDataLogger() {\n    memset(g_logBuffer, 0, DATA_LOG_BUFFER_SIZE);\n    g_logBufferWriteHead = 0;\n}\n\nint addLogEntry(uint8_t type, const uint8_t* payload_data, uint8_t payload_len) {\n    if (payload_data == NULL) {\n        return -1;\n    }\n\n    if (payload_len > MAX_LOG_ENTRY_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    uint16_t required_total_entry_size = sizeof(LogEntryHeader) + payload_len;\n\n    if (required_total_entry_size > DATA_LOG_BUFFER_SIZE) {\n        return -3;\n    }\n    \n    LogEntryHeader header = { .type = type, .payload_len = payload_len };\n\n    uint16_t current_write_pos = g_logBufferWriteHead;\n    uint16_t bytes_to_copy_this_segment;\n\n    // Write Header - handle potential wrap-around\n    bytes_to_copy_this_segment = sizeof(LogEntryHeader);\n    if (current_write_pos + bytes_to_copy_this_segment > DATA_LOG_BUFFER_SIZE) {\n        uint16_t first_part_len = DATA_LOG_BUFFER_SIZE - current_write_pos;\n        memcpy(g_logBuffer + current_write_pos, &header, first_part_len);\n        memcpy(g_logBuffer, (uint8_t*)&header + first_part_len, bytes_to_copy_this_segment - first_part_len);\n    } else {\n        memcpy(g_logBuffer + current_write_pos, &header, bytes_to_copy_this_segment);\n    }\n    current_write_pos = (current_write_pos + bytes_to_copy_this_segment) % DATA_LOG_BUFFER_SIZE;\n\n    // Write Payload - handle potential wrap-around\n    bytes_to_copy_this_segment = payload_len;\n    if (current_write_pos + bytes_to_copy_this_segment > DATA_LOG_BUFFER_SIZE) {\n        uint16_t first_part_len = DATA_LOG_BUFFER_SIZE - current_write_pos;\n        memcpy(g_logBuffer + current_write_pos, payload_data, first_part_len);\n        memcpy(g_logBuffer, payload_data + first_part_len, bytes_to_copy_this_segment - first_part_len);\n    } else {\n        memcpy(g_logBuffer + current_write_pos, payload_data, bytes_to_copy_this_segment);\n    }\n\n    // Update global write head for the next entry\n    g_logBufferWriteHead = (g_logBufferWriteHead + required_total_entry_size) % DATA_LOG_BUFFER_SIZE;\n\n    return 0;\n}\n\n// Dummy function to simulate usage in a larger context (e.g., error handling)\nvoid simulateSensorDTCLog(uint8_t dtc_code, const uint8_t* dtc_data, uint8_t data_len) {\n    addLogEntry(dtc_code, dtc_data, data_len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define CALIBRATION_DATA_SIZE 256\n#define MAX_CAN_DLC 8\n\ntypedef struct {\n    uint8_t  command_id;\n    uint8_t  segment_offset_high;\n    uint8_t  segment_offset_low;\n    uint8_t  segment_length;\n    uint8_t  data[MAX_CAN_DLC - 4];\n} CanCalibrationUpdatePacket;\n\nstatic uint8_t g_calibrationData[CALIBRATION_DATA_SIZE];\n\nvoid initCalibrationSystem() {\n    memset(g_calibrationData, 0xFF, CALIBRATION_DATA_SIZE);\n}\n\nint processCalibrationUpdate(const CanCalibrationUpdatePacket* packet_data, uint8_t actual_can_dlc) {\n    if (packet_data == NULL || actual_can_dlc < 4) {\n        return -1;\n    }\n\n    if (packet_data->command_id != 0x01) {\n        return -2;\n    }\n\n    uint16_t segment_offset = ((uint16_t)packet_data->segment_offset_high << 8) | packet_data->segment_offset_low;\n    uint8_t segment_length = packet_data->segment_length;\n\n    if (segment_length > (actual_can_dlc - 4)) {\n        return -3;\n    }\n\n    if (segment_offset >= CALIBRATION_DATA_SIZE) {\n        return -4;\n    }\n\n    memcpy(g_calibrationData + segment_offset, packet_data->data, segment_length);\n\n    return 0;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define CALIBRATION_DATA_SIZE 256\n#define MAX_CAN_DLC 8\n\ntypedef struct {\n    uint8_t  command_id;\n    uint8_t  segment_offset_high;\n    uint8_t  segment_offset_low;\n    uint8_t  segment_length;\n    uint8_t  data[MAX_CAN_DLC - 4];\n} CanCalibrationUpdatePacket;\n\nstatic uint8_t g_calibrationData[CALIBRATION_DATA_SIZE];\n\nvoid initCalibrationSystem() {\n    memset(g_calibrationData, 0xFF, CALIBRATION_DATA_SIZE);\n}\n\nint processCalibrationUpdate(const CanCalibrationUpdatePacket* packet_data, uint8_t actual_can_dlc) {\n    if (packet_data == NULL || actual_can_dlc < 4) {\n        return -1;\n    }\n\n    if (packet_data->command_id != 0x01) {\n        return -2;\n    }\n\n    uint16_t segment_offset = ((uint16_t)packet_data->segment_offset_high << 8) | packet_data->segment_offset_low;\n    uint8_t segment_length = packet_data->segment_length;\n\n    if (segment_length > (actual_can_dlc - 4)) {\n        return -3;\n    }\n\n    if (segment_offset >= CALIBRATION_DATA_SIZE) {\n        return -4;\n    }\n\n    if (segment_length > (CALIBRATION_DATA_SIZE - segment_offset)) {\n        return -5;\n    }\n\n    memcpy(g_calibrationData + segment_offset, packet_data->data, segment_length);\n\n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_BLOCK_SIZE 512\n\n#define MAX_VEHICLE_NAME_LEN 32\n#define MAX_LICENSE_PLATE_LEN 16\n\n#define CONFIG_ID_VEHICLE_NAME 0x01\n#define CONFIG_ID_LICENSE_PLATE 0x02\n#define CONFIG_ID_SPEED_LIMIT_ENABLED 0x03\n#define CONFIG_ID_MAX_SPEED_VALUE 0x04\n\nstatic char g_vehicleName[MAX_VEHICLE_NAME_LEN + 1];\nstatic char g_licensePlate[MAX_LICENSE_PLATE_LEN + 1];\nstatic uint8_t g_speedLimitEnabled = 0;\nstatic uint16_t g_maxSpeedValue = 0;\n\ntypedef struct {\n    uint8_t param_id;\n    uint8_t param_len;\n} ConfigParamHeader;\n\nvoid resetVehicleConfig() {\n    memset(g_vehicleName, 0, sizeof(g_vehicleName));\n    memset(g_licensePlate, 0, sizeof(g_licensePlate));\n    g_speedLimitEnabled = 0;\n    g_maxSpeedValue = 0;\n    strcpy(g_vehicleName, \"DEFAULT_VEHICLE\");\n    strcpy(g_licensePlate, \"DEFAULT_PLATE\");\n}\n\nint applyVehicleConfiguration(const uint8_t* config_data_block, uint16_t block_len) {\n    if (config_data_block == NULL || block_len == 0 || block_len > MAX_CONFIG_BLOCK_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    while (current_offset < block_len) {\n        if (current_offset + sizeof(ConfigParamHeader) > block_len) {\n            return -2;\n        }\n\n        const ConfigParamHeader* header = (const ConfigParamHeader*)(config_data_block + current_offset);\n        uint8_t param_id = header->param_id;\n        uint8_t param_len = header->param_len;\n\n        if (current_offset + sizeof(ConfigParamHeader) + param_len > block_len) {\n            return -3;\n        }\n\n        const uint8_t* param_value_ptr = config_data_block + current_offset + sizeof(ConfigParamHeader);\n\n        switch (param_id) {\n            case CONFIG_ID_VEHICLE_NAME:\n                memcpy(g_vehicleName, param_value_ptr, param_len);\n                if (param_len < MAX_VEHICLE_NAME_LEN + 1) {\n                    g_vehicleName[param_len] = '\\0';\n                } else {\n                    g_vehicleName[MAX_VEHICLE_NAME_LEN] = '\\0';\n                }\n                break;\n            case CONFIG_ID_LICENSE_PLATE:\n                memcpy(g_licensePlate, param_value_ptr, param_len);\n                if (param_len < MAX_LICENSE_PLATE_LEN + 1) {\n                    g_licensePlate[param_len] = '\\0';\n                } else {\n                    g_licensePlate[MAX_LICENSE_PLATE_LEN] = '\\0';\n                }\n                break;\n            case CONFIG_ID_SPEED_LIMIT_ENABLED:\n                if (param_len == 1) {\n                    g_speedLimitEnabled = param_value_ptr[0];\n                }\n                break;\n            case CONFIG_ID_MAX_SPEED_VALUE:\n                if (param_len == sizeof(uint16_t)) {\n                    g_maxSpeedValue = (param_value_ptr[0] << 8) | param_value_ptr[1];\n                }\n                break;\n            default:\n                break;\n        }\n\n        current_offset += sizeof(ConfigParamHeader) + param_len;\n    }\n\n    return 0;\n}\n\nvoid simulateConfigUpdate(const uint8_t* data, uint16_t len) {\n    resetVehicleConfig();\n    applyVehicleConfiguration(data, len);\n}\n\nconst char* getVehicleName() {\n    return g_vehicleName;\n}\n\nconst char* getLicensePlate() {\n    return g_licensePlate;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_BLOCK_SIZE 512\n\n#define MAX_VEHICLE_NAME_LEN 32\n#define MAX_LICENSE_PLATE_LEN 16\n\n#define CONFIG_ID_VEHICLE_NAME 0x01\n#define CONFIG_ID_LICENSE_PLATE 0x02\n#define CONFIG_ID_SPEED_LIMIT_ENABLED 0x03\n#define CONFIG_ID_MAX_SPEED_VALUE 0x04\n\nstatic char g_vehicleName[MAX_VEHICLE_NAME_LEN + 1];\nstatic char g_licensePlate[MAX_LICENSE_PLATE_LEN + 1];\nstatic uint8_t g_speedLimitEnabled = 0;\nstatic uint16_t g_maxSpeedValue = 0;\n\ntypedef struct {\n    uint8_t param_id;\n    uint8_t param_len;\n} ConfigParamHeader;\n\nvoid resetVehicleConfig() {\n    memset(g_vehicleName, 0, sizeof(g_vehicleName));\n    memset(g_licensePlate, 0, sizeof(g_licensePlate));\n    g_speedLimitEnabled = 0;\n    g_maxSpeedValue = 0;\n    strcpy(g_vehicleName, \"DEFAULT_VEHICLE\");\n    strcpy(g_licensePlate, \"DEFAULT_PLATE\");\n}\n\nint applyVehicleConfiguration(const uint8_t* config_data_block, uint16_t block_len) {\n    if (config_data_block == NULL || block_len == 0 || block_len > MAX_CONFIG_BLOCK_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    while (current_offset < block_len) {\n        if (current_offset + sizeof(ConfigParamHeader) > block_len) {\n            return -2;\n        }\n\n        const ConfigParamHeader* header = (const ConfigParamHeader*)(config_data_block + current_offset);\n        uint8_t param_id = header->param_id;\n        uint8_t param_len = header->param_len;\n\n        if (current_offset + sizeof(ConfigParamHeader) + param_len > block_len) {\n            return -3;\n        }\n\n        const uint8_t* param_value_ptr = config_data_block + current_offset + sizeof(ConfigParamHeader);\n\n        switch (param_id) {\n            case CONFIG_ID_VEHICLE_NAME: {\n                uint8_t bytes_to_copy = param_len;\n                if (bytes_to_copy > MAX_VEHICLE_NAME_LEN) {\n                    bytes_to_copy = MAX_VEHICLE_NAME_LEN;\n                }\n                memcpy(g_vehicleName, param_value_ptr, bytes_to_copy);\n                g_vehicleName[bytes_to_copy] = '\\0';\n                break;\n            }\n            case CONFIG_ID_LICENSE_PLATE: {\n                uint8_t bytes_to_copy = param_len;\n                if (bytes_to_copy > MAX_LICENSE_PLATE_LEN) {\n                    bytes_to_copy = MAX_LICENSE_PLATE_LEN;\n                }\n                memcpy(g_licensePlate, param_value_ptr, bytes_to_copy);\n                g_licensePlate[bytes_to_copy] = '\\0';\n                break;\n            }\n            case CONFIG_ID_SPEED_LIMIT_ENABLED:\n                if (param_len == 1) {\n                    g_speedLimitEnabled = param_value_ptr[0];\n                }\n                break;\n            case CONFIG_ID_MAX_SPEED_VALUE:\n                if (param_len == sizeof(uint16_t)) {\n                    g_maxSpeedValue = (param_value_ptr[0] << 8) | param_value_ptr[1];\n                }\n                break;\n            default:\n                break;\n        }\n\n        current_offset += sizeof(ConfigParamHeader) + param_len;\n    }\n\n    return 0;\n}\n\nvoid simulateConfigUpdate(const uint8_t* data, uint16_t len) {\n    resetVehicleConfig();\n    applyVehicleConfiguration(data, len);\n}\n\nconst char* getVehicleName() {\n    return g_vehicleName;\n}\n\nconst char* getLicensePlate() {\n    return g_licensePlate;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_INCOMING_FAULT_MSG_SIZE 256\n#define MAX_FAULT_DESCRIPTION_LEN 64\n\ntypedef enum {\n    SEVERITY_INFO = 0,\n    SEVERITY_WARNING,\n    SEVERITY_CRITICAL\n} FaultSeverity;\n\ntypedef struct {\n    uint16_t      fault_id;\n    FaultSeverity severity;\n    char          description[MAX_FAULT_DESCRIPTION_LEN];\n} ParsedFaultEntry;\n\nstatic ParsedFaultEntry g_lastFaultEntry;\n\nvoid initFaultEntry() {\n    memset(&g_lastFaultEntry, 0, sizeof(ParsedFaultEntry));\n}\n\nint processFaultMessage(const uint8_t* raw_msg, uint16_t msg_len) {\n    if (raw_msg == NULL || msg_len < (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    if (msg_len > MAX_INCOMING_FAULT_MSG_SIZE) {\n        return -2;\n    }\n\n    uint16_t current_offset = 0;\n\n    g_lastFaultEntry.fault_id = (raw_msg[current_offset] << 8) | raw_msg[current_offset + 1];\n    current_offset += sizeof(uint16_t);\n\n    g_lastFaultEntry.severity = (FaultSeverity)raw_msg[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    uint8_t incoming_description_len = raw_msg[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    if (current_offset + incoming_description_len > msg_len) {\n        return -3;\n    }\n\n    memcpy(g_lastFaultEntry.description, raw_msg + current_offset, incoming_description_len);\n\n    if (incoming_description_len < MAX_FAULT_DESCRIPTION_LEN) {\n        g_lastFaultEntry.description[incoming_description_len] = '\\0';\n    } else {\n        g_lastFaultEntry.description[MAX_FAULT_DESCRIPTION_LEN - 1] = '\\0';\n    }\n\n    return 0;\n}\n\nconst ParsedFaultEntry* getLastFaultEntry() {\n    return &g_lastFaultEntry;\n}\n\nvoid receiveSimulatedFaultData(const uint8_t* data, uint16_t len) {\n    processFaultMessage(data, len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_INCOMING_FAULT_MSG_SIZE 256\n#define MAX_FAULT_DESCRIPTION_LEN 64\n\ntypedef enum {\n    SEVERITY_INFO = 0,\n    SEVERITY_WARNING,\n    SEVERITY_CRITICAL\n} FaultSeverity;\n\ntypedef struct {\n    uint16_t      fault_id;\n    FaultSeverity severity;\n    char          description[MAX_FAULT_DESCRIPTION_LEN];\n} ParsedFaultEntry;\n\nstatic ParsedFaultEntry g_lastFaultEntry;\n\nvoid initFaultEntry() {\n    memset(&g_lastFaultEntry, 0, sizeof(ParsedFaultEntry));\n}\n\nint processFaultMessage(const uint8_t* raw_msg, uint16_t msg_len) {\n    if (raw_msg == NULL || msg_len < (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    if (msg_len > MAX_INCOMING_FAULT_MSG_SIZE) {\n        return -2;\n    }\n\n    uint16_t current_offset = 0;\n\n    g_lastFaultEntry.fault_id = (raw_msg[current_offset] << 8) | raw_msg[current_offset + 1];\n    current_offset += sizeof(uint16_t);\n\n    g_lastFaultEntry.severity = (FaultSeverity)raw_msg[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    uint8_t incoming_description_len = raw_msg[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    if (current_offset + incoming_description_len > msg_len) {\n        return -3;\n    }\n\n    uint8_t bytes_to_copy = incoming_description_len;\n    if (bytes_to_copy >= MAX_FAULT_DESCRIPTION_LEN) {\n        bytes_to_copy = MAX_FAULT_DESCRIPTION_LEN - 1;\n    }\n    \n    memcpy(g_lastFaultEntry.description, raw_msg + current_offset, bytes_to_copy);\n    g_lastFaultEntry.description[bytes_to_copy] = '\\0';\n\n    return 0;\n}\n\nconst ParsedFaultEntry* getLastFaultEntry() {\n    return &g_lastFaultEntry;\n}\n\nvoid receiveSimulatedFaultData(const uint8_t* data, uint16_t len) {\n    processFaultMessage(data, len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_EVENT_BUFFER_SIZE 512\n#define MAX_EVENT_DESCRIPTION_LEN 100\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp;\n    uint8_t  severity;\n    uint8_t  description_len; \n} DiagnosticEventHeader;\n\nstatic uint8_t g_eventRecordBuffer[DIAG_EVENT_BUFFER_SIZE];\nstatic uint16_t g_bufferWritePointer = 0;\n\nvoid initDiagnosticRecorder() {\n    memset(g_eventRecordBuffer, 0, DIAG_EVENT_BUFFER_SIZE);\n    g_bufferWritePointer = 0;\n}\n\nint recordDiagnosticEvent(uint16_t id, uint32_t ts, uint8_t sev, const char* desc, uint8_t desc_len) {\n    uint16_t fixed_header_size = sizeof(DiagnosticEventHeader);\n    uint16_t total_event_size_to_write = fixed_header_size + desc_len;\n\n    if (total_event_size_to_write > DIAG_EVENT_BUFFER_SIZE) {\n        return -1;\n    }\n\n    uint16_t write_start_pos = g_bufferWritePointer;\n    if (write_start_pos + total_event_size_to_write > DIAG_EVENT_BUFFER_SIZE) {\n        write_start_pos = 0;\n    }\n\n    uint8_t* current_write_ptr = g_eventRecordBuffer + write_start_pos;\n\n    *(uint16_t*)current_write_ptr = id;\n    current_write_ptr += sizeof(uint16_t);\n    *(uint32_t*)current_write_ptr = ts;\n    current_write_ptr += sizeof(uint32_t);\n    *current_write_ptr = sev;\n    current_write_ptr += sizeof(uint8_t);\n    *current_write_ptr = desc_len; \n    current_write_ptr += sizeof(uint8_t);\n\n    memcpy(current_write_ptr, desc, desc_len);\n\n    g_bufferWritePointer = (write_start_pos + total_event_size_to_write) % DIAG_EVENT_BUFFER_SIZE;\n\n    return 0;\n}\n\nvoid simulateIncomingEvent(uint16_t id, uint32_t ts, uint8_t sev, const char* desc, uint8_t desc_len) {\n    recordDiagnosticEvent(id, ts, sev, desc, desc_len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_EVENT_BUFFER_SIZE 512\n#define MAX_EVENT_DESCRIPTION_LEN 100\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp;\n    uint8_t  severity;\n    uint8_t  description_len; \n} DiagnosticEventHeader;\n\nstatic uint8_t g_eventRecordBuffer[DIAG_EVENT_BUFFER_SIZE];\nstatic uint16_t g_bufferWritePointer = 0;\n\nvoid initDiagnosticRecorder() {\n    memset(g_eventRecordBuffer, 0, DIAG_EVENT_BUFFER_SIZE);\n    g_bufferWritePointer = 0;\n}\n\nint recordDiagnosticEvent(uint16_t id, uint32_t ts, uint8_t sev, const char* desc, uint8_t desc_len) {\n    uint16_t fixed_header_size = sizeof(DiagnosticEventHeader);\n    \n    uint8_t actual_desc_bytes_to_copy = desc_len;\n    if (actual_desc_bytes_to_copy > MAX_EVENT_DESCRIPTION_LEN) {\n        actual_desc_bytes_to_copy = MAX_EVENT_DESCRIPTION_LEN;\n    }\n\n    uint16_t total_event_size_to_write = fixed_header_size + actual_desc_bytes_to_copy;\n\n    if (total_event_size_to_write > DIAG_EVENT_BUFFER_SIZE) {\n        return -1;\n    }\n\n    uint16_t write_start_pos = g_bufferWritePointer;\n    if (write_start_pos + total_event_size_to_write > DIAG_EVENT_BUFFER_SIZE) {\n        write_start_pos = 0;\n    }\n\n    uint8_t* current_write_ptr = g_eventRecordBuffer + write_start_pos;\n\n    *(uint16_t*)current_write_ptr = id;\n    current_write_ptr += sizeof(uint16_t);\n    *(uint32_t*)current_write_ptr = ts;\n    current_write_ptr += sizeof(uint32_t);\n    *current_write_ptr = sev;\n    current_write_ptr += sizeof(uint8_t);\n    *current_write_ptr = actual_desc_bytes_to_copy; \n    current_write_ptr += sizeof(uint8_t);\n\n    memcpy(current_write_ptr, desc, actual_desc_bytes_to_copy);\n\n    g_bufferWritePointer = (write_start_pos + total_event_size_to_write) % DIAG_EVENT_BUFFER_SIZE;\n\n    return 0;\n}\n\nvoid simulateIncomingEvent(uint16_t id, uint32_t ts, uint8_t sev, const char* desc, uint8_t desc_len) {\n    recordDiagnosticEvent(id, ts, sev, desc, desc_len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define OTA_FIRMWARE_STAGING_BUFFER_SIZE 4096\n#define MAX_FRAGMENT_PAYLOAD_SIZE 64\n\nstatic uint8_t g_firmwareStagingBuffer[OTA_FIRMWARE_STAGING_BUFFER_SIZE];\nstatic uint32_t g_totalFirmwareSize = 0;\nstatic uint32_t g_bytesReceived = 0;\n\ntypedef struct {\n    uint16_t fragment_offset;\n    uint8_t  fragment_length;\n    uint8_t  data[MAX_FRAGMENT_PAYLOAD_SIZE];\n} OtaFragmentPacket;\n\nvoid initOtaStaging() {\n    memset(g_firmwareStagingBuffer, 0, OTA_FIRMWARE_STAGING_BUFFER_SIZE);\n    g_totalFirmwareSize = 0;\n    g_bytesReceived = 0;\n}\n\nvoid setExpectedFirmwareSize(uint32_t total_size) {\n    if (total_size > OTA_FIRMWARE_STAGING_BUFFER_SIZE) {\n        g_totalFirmwareSize = OTA_FIRMWARE_STAGING_BUFFER_SIZE; \n    } else {\n        g_totalFirmwareSize = total_size;\n    }\n}\n\nint processFirmwareFragment(const OtaFragmentPacket* fragment_packet) {\n    if (fragment_packet == NULL) {\n        return -1;\n    }\n\n    uint16_t offset = fragment_packet->fragment_offset;\n    uint8_t length = fragment_packet->fragment_length;\n\n    if (length > MAX_FRAGMENT_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    // Vulnerability: The check 'offset >= g_totalFirmwareSize' only verifies the starting\n    // offset against the logical firmware size, which itself is capped at the buffer size.\n    // However, it does not check if 'offset + length' exceeds the actual physical buffer size.\n    // An attacker can craft a packet where 'offset' is just below 'g_totalFirmwareSize'\n    // and 'length' causes the write to go past the end of g_firmwareStagingBuffer.\n    if (offset >= g_totalFirmwareSize) {\n        return -3;\n    }\n\n    memcpy(g_firmwareStagingBuffer + offset, fragment_packet->data, length);\n\n    if (offset + length > g_bytesReceived) {\n        g_bytesReceived = offset + length;\n    }\n\n    return 0;\n}\n\nvoid simulateOtaFragmentReception(const OtaFragmentPacket* packet) {\n    processFirmwareFragment(packet);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define OTA_FIRMWARE_STAGING_BUFFER_SIZE 4096\n#define MAX_FRAGMENT_PAYLOAD_SIZE 64\n\nstatic uint8_t g_firmwareStagingBuffer[OTA_FIRMWARE_STAGING_BUFFER_SIZE];\nstatic uint32_t g_totalFirmwareSize = 0;\nstatic uint32_t g_bytesReceived = 0;\n\ntypedef struct {\n    uint16_t fragment_offset;\n    uint8_t  fragment_length;\n    uint8_t  data[MAX_FRAGMENT_PAYLOAD_SIZE];\n} OtaFragmentPacket;\n\nvoid initOtaStaging() {\n    memset(g_firmwareStagingBuffer, 0, OTA_FIRMWARE_STAGING_BUFFER_SIZE);\n    g_totalFirmwareSize = 0;\n    g_bytesReceived = 0;\n}\n\nvoid setExpectedFirmwareSize(uint32_t total_size) {\n    if (total_size > OTA_FIRMWARE_STAGING_BUFFER_SIZE) {\n        g_totalFirmwareSize = OTA_FIRMWARE_STAGING_BUFFER_SIZE; \n    } else {\n        g_totalFirmwareSize = total_size;\n    }\n}\n\nint processFirmwareFragment(const OtaFragmentPacket* fragment_packet) {\n    if (fragment_packet == NULL) {\n        return -1;\n    }\n\n    uint16_t offset = fragment_packet->fragment_offset;\n    uint8_t length = fragment_packet->fragment_length;\n\n    if (length > MAX_FRAGMENT_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    // Fixed: Added explicit checks to ensure that the entire write operation\n    // (offset + length) remains within the bounds of the physical staging buffer\n    // and also within the expected logical firmware size.\n    if (offset >= OTA_FIRMWARE_STAGING_BUFFER_SIZE || \n        (uint32_t)offset + length > OTA_FIRMWARE_STAGING_BUFFER_SIZE || \n        (uint32_t)offset + length > g_totalFirmwareSize) {\n        return -3;\n    }\n\n    memcpy(g_firmwareStagingBuffer + offset, fragment_packet->data, length);\n\n    if (offset + length > g_bytesReceived) {\n        g_bytesReceived = offset + length;\n    }\n\n    return 0;\n}\n\nvoid simulateOtaFragmentReception(const OtaFragmentPacket* packet) {\n    processFirmwareFragment(packet);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_STORAGE_SIZE 1024\n#define DIAG_RESPONSE_BUFFER_SIZE 256\n\nstatic uint8_t g_vehicleConfig[VEHICLE_CONFIG_STORAGE_SIZE];\n\nvoid initVehicleConfig() {\n    for (int i = 0; i < VEHICLE_CONFIG_STORAGE_SIZE; ++i) {\n        g_vehicleConfig[i] = (uint8_t)(i % 0xFF);\n    }\n}\n\ntypedef struct {\n    uint16_t serviceId;\n    uint16_t configAreaOffset;\n    uint16_t bytesToRead;\n} DiagReadConfigRequest;\n\ntypedef struct {\n    uint16_t serviceIdResponse;\n    uint8_t data[DIAG_RESPONSE_BUFFER_SIZE];\n    uint16_t dataLength;\n} DiagReadConfigResponse;\n\nint handleDiagReadConfigRequest(const DiagReadConfigRequest* request, DiagReadConfigResponse* response) {\n    if (request == NULL || response == NULL) {\n        return -1;\n    }\n\n    if (request->serviceId != 0x22) {\n        return -1;\n    }\n\n    uint16_t offset = request->configAreaOffset;\n    uint16_t length = request->bytesToRead;\n\n    uint16_t total_read_end_idx = offset + length;\n\n    if (total_read_end_idx > VEHICLE_CONFIG_STORAGE_SIZE) {\n        return -2;\n    }\n\n    if (offset >= VEHICLE_CONFIG_STORAGE_SIZE) {\n        return -2;\n    }\n\n    uint16_t bytes_to_copy = length;\n    if (bytes_to_copy > DIAG_RESPONSE_BUFFER_SIZE) {\n        bytes_to_copy = DIAG_RESPONSE_BUFFER_SIZE;\n    }\n\n    memcpy(response->data, g_vehicleConfig + offset, bytes_to_copy);\n\n    response->serviceIdResponse = 0x62;\n    response->dataLength = bytes_to_copy;\n\n    return 0;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_STORAGE_SIZE 1024\n#define DIAG_RESPONSE_BUFFER_SIZE 256\n\nstatic uint8_t g_vehicleConfig[VEHICLE_CONFIG_STORAGE_SIZE];\n\nvoid initVehicleConfig() {\n    for (int i = 0; i < VEHICLE_CONFIG_STORAGE_SIZE; ++i) {\n        g_vehicleConfig[i] = (uint8_t)(i % 0xFF);\n    }\n}\n\ntypedef struct {\n    uint16_t serviceId;\n    uint16_t configAreaOffset;\n    uint16_t bytesToRead;\n} DiagReadConfigRequest;\n\ntypedef struct {\n    uint16_t serviceIdResponse;\n    uint8_t data[DIAG_RESPONSE_BUFFER_SIZE];\n    uint16_t dataLength;\n} DiagReadConfigResponse;\n\nint handleDiagReadConfigRequest(const DiagReadConfigRequest* request, DiagReadConfigResponse* response) {\n    if (request == NULL || response == NULL) {\n        return -1;\n    }\n\n    if (request->serviceId != 0x22) {\n        return -1;\n    }\n\n    uint16_t offset = request->configAreaOffset;\n    uint16_t length = request->bytesToRead;\n\n    if (offset >= VEHICLE_CONFIG_STORAGE_SIZE || (uint32_t)offset + length > VEHICLE_CONFIG_STORAGE_SIZE) {\n        return -2;\n    }\n\n    uint16_t bytes_to_copy = length;\n    if (bytes_to_copy > DIAG_RESPONSE_BUFFER_SIZE) {\n        bytes_to_copy = DIAG_RESPONSE_BUFFER_SIZE;\n    }\n    if (bytes_to_copy > (VEHICLE_CONFIG_STORAGE_SIZE - offset)) {\n        bytes_to_copy = VEHICLE_CONFIG_STORAGE_SIZE - offset;\n    }\n\n    memcpy(response->data, g_vehicleConfig + offset, bytes_to_copy);\n\n    response->serviceIdResponse = 0x62;\n    response->dataLength = bytes_to_copy;\n\n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_REPORT_PAYLOAD_SIZE 128\n#define DIAG_DATA_BUFFER_SIZE 64\n#define MAX_DIAG_DATA_ID_ENTRIES 5\n\ntypedef struct {\n    uint16_t id;\n    uint8_t  data[DIAG_DATA_BUFFER_SIZE];\n    uint8_t  current_len;\n} DiagnosticDataEntry;\n\nstatic DiagnosticDataEntry g_diagDataStore[MAX_DIAG_DATA_ID_ENTRIES];\nstatic uint8_t g_diagDataCount = 0;\n\nvoid initDiagnosticDataStore() {\n    memset(g_diagDataStore, 0, sizeof(g_diagDataStore));\n}\n\nint processDiagnosticReport(uint16_t report_id, const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len == 0 || payload_len > MAX_REPORT_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    if (report_id == 0x10) {\n        if (payload_len < (1 + 2 + 1)) {\n            return -2;\n        }\n\n        uint8_t entry_index = payload[0];\n        uint16_t data_id = (payload[1] << 8) | payload[2];\n        uint8_t data_len = payload[3];\n\n        if (entry_index >= MAX_DIAG_DATA_ID_ENTRIES) {\n            return -3;\n        }\n\n        if (data_len > (payload_len - (1 + 2 + 1))) {\n            return -4;\n        }\n\n        int found_idx = -1;\n        for (int i = 0; i < g_diagDataCount; ++i) {\n            if (g_diagDataStore[i].id == data_id) {\n                found_idx = i;\n                break;\n            }\n        }\n\n        if (found_idx == -1) {\n            if (g_diagDataCount < MAX_DIAG_DATA_ID_ENTRIES) {\n                found_idx = g_diagDataCount++;\n                g_diagDataStore[found_idx].id = data_id;\n            } else {\n                return -5;\n            }\n        }\n\n        memcpy(g_diagDataStore[found_idx].data, payload + (1 + 2 + 1), data_len);\n        g_diagDataStore[found_idx].current_len = data_len;\n\n        return 0;\n\n    } else if (report_id == 0x20) {\n        return 0;\n    }\n\n    return -99;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_REPORT_PAYLOAD_SIZE 128\n#define DIAG_DATA_BUFFER_SIZE 64\n#define MAX_DIAG_DATA_ID_ENTRIES 5\n\ntypedef struct {\n    uint16_t id;\n    uint8_t  data[DIAG_DATA_BUFFER_SIZE];\n    uint8_t  current_len;\n} DiagnosticDataEntry;\n\nstatic DiagnosticDataEntry g_diagDataStore[MAX_DIAG_DATA_ID_ENTRIES];\nstatic uint8_t g_diagDataCount = 0;\n\nvoid initDiagnosticDataStore() {\n    memset(g_diagDataStore, 0, sizeof(g_diagDataStore));\n}\n\nint processDiagnosticReport(uint16_t report_id, const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len == 0 || payload_len > MAX_REPORT_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    if (report_id == 0x10) {\n        if (payload_len < (1 + 2 + 1)) {\n            return -2;\n        }\n\n        uint8_t entry_index = payload[0];\n        uint16_t data_id = (payload[1] << 8) | payload[2];\n        uint8_t data_len = payload[3];\n\n        if (entry_index >= MAX_DIAG_DATA_ID_ENTRIES) {\n            return -3;\n        }\n\n        if (data_len > (payload_len - (1 + 2 + 1))) {\n            return -4;\n        }\n        \n        int found_idx = -1;\n        for (int i = 0; i < g_diagDataCount; ++i) {\n            if (g_diagDataStore[i].id == data_id) {\n                found_idx = i;\n                break;\n            }\n        }\n\n        if (found_idx == -1) {\n            if (g_diagDataCount < MAX_DIAG_DATA_ID_ENTRIES) {\n                found_idx = g_diagDataCount++;\n                g_diagDataStore[found_idx].id = data_id;\n            } else {\n                return -5;\n            }\n        }\n\n        uint8_t bytes_to_copy = data_len;\n        if (bytes_to_copy > DIAG_DATA_BUFFER_SIZE) {\n            bytes_to_copy = DIAG_DATA_BUFFER_SIZE;\n        }\n\n        memcpy(g_diagDataStore[found_idx].data, payload + (1 + 2 + 1), bytes_to_copy);\n        g_diagDataStore[found_idx].current_len = bytes_to_copy;\n\n        if (data_len > DIAG_DATA_BUFFER_SIZE) {\n            return -6;\n        }\n\n        return 0;\n\n    } else if (report_id == 0x20) {\n        return 0;\n    }\n\n    return -99;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define DRIVER_MESSAGE_BUFFER_SIZE 32\n#define PROTOCOL_MAX_MESSAGE_LEN 64\n\nstatic char g_driverWelcomeMessage[DRIVER_MESSAGE_BUFFER_SIZE];\nstatic uint8_t g_messageLength = 0;\n\nvoid initDriverProfile() {\n    memset(g_driverWelcomeMessage, 0, sizeof(g_driverWelcomeMessage));\n    const char* default_msg = \"Hello Driver!\";\n    uint8_t default_len = strlen(default_msg);\n    if (default_len < DRIVER_MESSAGE_BUFFER_SIZE) {\n        strncpy(g_driverWelcomeMessage, default_msg, default_len);\n        g_driverWelcomeMessage[default_len] = '\\0';\n        g_messageLength = default_len;\n    } else {\n        strncpy(g_driverWelcomeMessage, default_msg, DRIVER_MESSAGE_BUFFER_SIZE - 1);\n        g_driverWelcomeMessage[DRIVER_MESSAGE_BUFFER_SIZE - 1] = '\\0';\n        g_messageLength = DRIVER_MESSAGE_BUFFER_SIZE - 1;\n    }\n}\n\nint updateDriverWelcomeMessage(const char* new_message, uint8_t message_len) {\n    if (new_message == NULL) {\n        return -1;\n    }\n\n    if (message_len > PROTOCOL_MAX_MESSAGE_LEN) {\n        return -2;\n    }\n\n    memcpy(g_driverWelcomeMessage, new_message, message_len);\n\n    if (message_len < DRIVER_MESSAGE_BUFFER_SIZE) {\n        g_driverWelcomeMessage[message_len] = '\\0';\n        g_messageLength = message_len;\n    } else {\n        g_driverWelcomeMessage[DRIVER_MESSAGE_BUFFER_SIZE - 1] = '\\0';\n        g_messageLength = DRIVER_MESSAGE_BUFFER_SIZE - 1;\n    }\n\n    return 0;\n}\n\nconst char* getDriverWelcomeMessage() {\n    return g_driverWelcomeMessage;\n}\n\nuint8_t getDriverWelcomeMessageLength() {\n    return g_messageLength;\n}\n\nvoid simulateCanMessage(const char* data, uint8_t len) {\n    updateDriverWelcomeMessage(data, len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define DRIVER_MESSAGE_BUFFER_SIZE 32\n#define PROTOCOL_MAX_MESSAGE_LEN 64\n\nstatic char g_driverWelcomeMessage[DRIVER_MESSAGE_BUFFER_SIZE];\nstatic uint8_t g_messageLength = 0;\n\nvoid initDriverProfile() {\n    memset(g_driverWelcomeMessage, 0, sizeof(g_driverWelcomeMessage));\n    const char* default_msg = \"Hello Driver!\";\n    uint8_t default_len = strlen(default_msg);\n    uint8_t actual_copy_len = default_len;\n    if (actual_copy_len >= DRIVER_MESSAGE_BUFFER_SIZE) {\n        actual_copy_len = DRIVER_MESSAGE_BUFFER_SIZE - 1;\n    }\n    strncpy(g_driverWelcomeMessage, default_msg, actual_copy_len);\n    g_driverWelcomeMessage[actual_copy_len] = '\\0';\n    g_messageLength = actual_copy_len;\n}\n\nint updateDriverWelcomeMessage(const char* new_message, uint8_t message_len) {\n    if (new_message == NULL) {\n        return -1;\n    }\n\n    if (message_len > PROTOCOL_MAX_MESSAGE_LEN) {\n        return -2;\n    }\n\n    uint8_t bytes_to_copy = message_len;\n    if (bytes_to_copy >= DRIVER_MESSAGE_BUFFER_SIZE) {\n        bytes_to_copy = DRIVER_MESSAGE_BUFFER_SIZE - 1;\n    }\n\n    memcpy(g_driverWelcomeMessage, new_message, bytes_to_copy);\n\n    g_driverWelcomeMessage[bytes_to_copy] = '\\0';\n    g_messageLength = bytes_to_copy;\n\n    return 0;\n}\n\nconst char* getDriverWelcomeMessage() {\n    return g_driverWelcomeMessage;\n}\n\nuint8_t getDriverWelcomeMessageLength() {\n    return g_messageLength;\n}\n\nvoid simulateCanMessage(const char* data, uint8_t len) {\n    updateDriverWelcomeMessage(data, len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE 256\n#define MAX_INCOMING_PACKET_SIZE 512\n\nstatic uint8_t g_telemetryStorageBuffer[MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE];\nstatic uint16_t g_currentStorageWriteOffset = 0;\n\nvoid initTelemetryStorage() {\n    memset(g_telemetryStorageBuffer, 0, MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE);\n    g_currentStorageWriteOffset = 0;\n}\n\nint processTelemetryDataPacket(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len == 0 || packet_len > MAX_INCOMING_PACKET_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_packet_read_offset = 0;\n\n    while (current_packet_read_offset < packet_len) {\n        if (current_packet_read_offset + 2 > packet_len) {\n            return -1;\n        }\n\n        uint8_t record_id = packet_data[current_packet_read_offset];\n        uint8_t data_len = packet_data[current_packet_read_offset + 1];\n\n        if (current_packet_read_offset + 2 + data_len > packet_len) {\n            return -1;\n        }\n\n        const uint8_t* record_data_ptr = packet_data + current_packet_read_offset + 2;\n\n        g_telemetryStorageBuffer[g_currentStorageWriteOffset] = record_id;\n        g_currentStorageWriteOffset++;\n\n        g_telemetryStorageBuffer[g_currentStorageWriteOffset] = data_len;\n        g_currentStorageWriteOffset++;\n\n        for (int i = 0; i < data_len; ++i) {\n            g_telemetryStorageBuffer[g_currentStorageWriteOffset + i] = record_data_ptr[i];\n        }\n        g_currentStorageWriteOffset += data_len;\n\n        current_packet_read_offset += 2 + data_len;\n    }\n\n    return 0;\n}\n\nvoid systemReceiveTelemetry(const uint8_t* raw_telemetry_packet, uint16_t packet_size) {\n    if (g_currentStorageWriteOffset == 0) {\n        initTelemetryStorage();\n    }\n    processTelemetryDataPacket(raw_telemetry_packet, packet_size);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE 256\n#define MAX_INCOMING_PACKET_SIZE 512\n\nstatic uint8_t g_telemetryStorageBuffer[MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE];\nstatic uint16_t g_currentStorageWriteOffset = 0;\n\nvoid initTelemetryStorage() {\n    memset(g_telemetryStorageBuffer, 0, MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE);\n    g_currentStorageWriteOffset = 0;\n}\n\nint processTelemetryDataPacket(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len == 0 || packet_len > MAX_INCOMING_PACKET_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_packet_read_offset = 0;\n\n    while (current_packet_read_offset < packet_len) {\n        if (current_packet_read_offset + 2 > packet_len) {\n            return -1;\n        }\n\n        uint8_t record_id = packet_data[current_packet_read_offset];\n        uint8_t data_len = packet_data[current_packet_read_offset + 1];\n\n        if (current_packet_read_offset + 2 + data_len > packet_len) {\n            return -1;\n        }\n\n        uint16_t record_storage_size = 2 + data_len;\n\n        if (g_currentStorageWriteOffset + record_storage_size > MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE) {\n            return -2;\n        }\n\n        const uint8_t* record_data_ptr = packet_data + current_packet_read_offset + 2;\n\n        g_telemetryStorageBuffer[g_currentStorageWriteOffset] = record_id;\n        g_currentStorageWriteOffset++;\n\n        g_telemetryStorageBuffer[g_currentStorageWriteOffset] = data_len;\n        g_currentStorageWriteOffset++;\n\n        for (int i = 0; i < data_len; ++i) {\n            g_telemetryStorageBuffer[g_currentStorageWriteOffset + i] = record_data_ptr[i];\n        }\n        g_currentStorageWriteOffset += data_len;\n\n        current_packet_read_offset += 2 + data_len;\n    }\n\n    return 0;\n}\n\nvoid systemReceiveTelemetry(const uint8_t* raw_telemetry_packet, uint16_t packet_size) {\n    if (g_currentStorageWriteOffset == 0) {\n        initTelemetryStorage();\n    }\n    processTelemetryDataPacket(raw_telemetry_packet, packet_size);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DTC_METADATA_PROTO_MAX 60\n#define MAX_INTERNAL_DTC_METADATA_SIZE 30\n\n#define MAX_LOGGED_DTC_RECORDS 20\n#define DTC_RECORD_FIXED_SIZE (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t))\n#define SINGLE_DTC_RECORD_STORAGE_SIZE (DTC_RECORD_FIXED_SIZE + MAX_INTERNAL_DTC_METADATA_SIZE)\n#define DTC_LOG_BUFFER_TOTAL_SIZE (MAX_LOGGED_DTC_RECORDS * SINGLE_DTC_RECORD_STORAGE_SIZE)\n\ntypedef struct {\n    uint16_t dtc_id;\n    uint8_t status_byte;\n    uint8_t metadata_len;\n    uint8_t metadata[MAX_INTERNAL_DTC_METADATA_SIZE];\n} DTCRecord;\n\nstatic uint8_t g_dtc_log_buffer[DTC_LOG_BUFFER_TOTAL_SIZE];\nstatic uint16_t g_current_log_pos = 0;\n\nvoid initDTCLoggingSystem() {\n    memset(g_dtc_log_buffer, 0, DTC_LOG_BUFFER_TOTAL_SIZE);\n    g_current_log_pos = 0;\n}\n\nint addDTCRecord(uint16_t dtc_code, uint8_t status_byte, const uint8_t* metadata, uint8_t metadata_len) {\n    if (metadata == NULL && metadata_len > 0) {\n        return -1;\n    }\n\n    if (metadata_len > MAX_DTC_METADATA_PROTO_MAX) {\n        return -2;\n    }\n\n    DTCRecord temp_record;\n    temp_record.dtc_id = dtc_code;\n    temp_record.status_byte = status_byte;\n    temp_record.metadata_len = metadata_len;\n\n    memcpy(temp_record.metadata, metadata, metadata_len);\n\n    uint16_t record_effective_size = DTC_RECORD_FIXED_SIZE + metadata_len;\n\n    if (g_current_log_pos + record_effective_size > DTC_LOG_BUFFER_TOTAL_SIZE) {\n        return -3;\n    }\n\n    memcpy(g_dtc_log_buffer + g_current_log_pos, &temp_record, record_effective_size);\n    g_current_log_pos += record_effective_size;\n\n    return 0;\n}\n\nuint16_t getDTCLogCount() {\n    if (SINGLE_DTC_RECORD_STORAGE_SIZE == 0) return 0;\n    return g_current_log_pos / SINGLE_DTC_RECORD_STORAGE_SIZE;\n}\n\nvoid simulateExternalDTCReport(uint16_t dtc, uint8_t status, const uint8_t* data, uint8_t data_len) {\n    addDTCRecord(dtc, status, data, data_len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DTC_METADATA_PROTO_MAX 60\n#define MAX_INTERNAL_DTC_METADATA_SIZE 30\n\n#define MAX_LOGGED_DTC_RECORDS 20\n#define DTC_RECORD_FIXED_SIZE (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t))\n#define SINGLE_DTC_RECORD_STORAGE_SIZE (DTC_RECORD_FIXED_SIZE + MAX_INTERNAL_DTC_METADATA_SIZE)\n#define DTC_LOG_BUFFER_TOTAL_SIZE (MAX_LOGGED_DTC_RECORDS * SINGLE_DTC_RECORD_STORAGE_SIZE)\n\ntypedef struct {\n    uint16_t dtc_id;\n    uint8_t status_byte;\n    uint8_t metadata_len;\n    uint8_t metadata[MAX_INTERNAL_DTC_METADATA_SIZE];\n} DTCRecord;\n\nstatic uint8_t g_dtc_log_buffer[DTC_LOG_BUFFER_TOTAL_SIZE];\nstatic uint16_t g_current_log_pos = 0;\n\nvoid initDTCLoggingSystem() {\n    memset(g_dtc_log_buffer, 0, DTC_LOG_BUFFER_TOTAL_SIZE);\n    g_current_log_pos = 0;\n}\n\nint addDTCRecord(uint16_t dtc_code, uint8_t status_byte, const uint8_t* metadata, uint8_t metadata_len) {\n    if (metadata == NULL && metadata_len > 0) {\n        return -1;\n    }\n\n    if (metadata_len > MAX_DTC_METADATA_PROTO_MAX) {\n        return -2;\n    }\n\n    DTCRecord temp_record;\n    temp_record.dtc_id = dtc_code;\n    temp_record.status_byte = status_byte;\n\n    uint8_t actual_copy_len = metadata_len;\n    if (actual_copy_len > MAX_INTERNAL_DTC_METADATA_SIZE) {\n        actual_copy_len = MAX_INTERNAL_DTC_METADATA_SIZE;\n    }\n    temp_record.metadata_len = actual_copy_len;\n    \n    memcpy(temp_record.metadata, metadata, actual_copy_len);\n\n    uint16_t record_effective_size = DTC_RECORD_FIXED_SIZE + temp_record.metadata_len;\n\n    if (g_current_log_pos + record_effective_size > DTC_LOG_BUFFER_TOTAL_SIZE) {\n        return -3;\n    }\n\n    memcpy(g_dtc_log_buffer + g_current_log_pos, &temp_record, record_effective_size);\n    g_current_log_pos += record_effective_size;\n\n    return 0;\n}\n\nuint16_t getDTCLogCount() {\n    if (SINGLE_DTC_RECORD_STORAGE_SIZE == 0) return 0;\n    return g_current_log_pos / SINGLE_DTC_RECORD_STORAGE_SIZE;\n}\n\nvoid simulateExternalDTCReport(uint16_t dtc, uint8_t status, const uint8_t* data, uint8_t data_len) {\n    addDTCRecord(dtc, status, data, data_len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_PACKET_SIZE 1500\n#define PARAMETER_RECORD_FIXED_HEADER_SIZE (sizeof(uint16_t) + sizeof(uint8_t)) \n\nstatic uint8_t g_vehicleConfigMemory[512];\n\nint processVehicleConfigUpdate(const uint8_t* message_data, uint16_t message_len) {\n    if (message_data == NULL || message_len < sizeof(uint16_t)) {\n        return -1;\n    }\n\n    uint16_t num_params = (message_data[0] << 8) | message_data[1];\n    uint16_t current_read_offset = sizeof(uint16_t);\n\n    uint16_t total_payload_bytes_expected = 0;\n\n    for (uint16_t i = 0; i < num_params; ++i) {\n        if (current_read_offset + PARAMETER_RECORD_FIXED_HEADER_SIZE > message_len) {\n            return -2;\n        }\n\n        uint8_t data_len = message_data[current_read_offset + sizeof(uint16_t)];\n\n        if (current_read_offset + PARAMETER_RECORD_FIXED_HEADER_SIZE + data_len > message_len) {\n            return -3;\n        }\n\n        uint16_t param_record_size = PARAMETER_RECORD_FIXED_HEADER_SIZE + data_len;\n        total_payload_bytes_expected += param_record_size;\n\n        current_read_offset += param_record_size;\n    }\n\n    if (current_read_offset != message_len) {\n        return -4;\n    }\n\n    uint8_t* temp_stage_buffer = (uint8_t*)malloc(total_payload_bytes_expected);\n    if (temp_stage_buffer == NULL) {\n        return -5;\n    }\n\n    memcpy(temp_stage_buffer, message_data + sizeof(uint16_t), message_len - sizeof(uint16_t));\n\n    free(temp_stage_buffer);\n\n    return 0;\n}", "fixed_code": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_PACKET_SIZE 1500\n#define PARAMETER_RECORD_FIXED_HEADER_SIZE (sizeof(uint16_t) + sizeof(uint8_t)) \n#define MAX_TOTAL_CONFIG_PAYLOAD_SIZE (MAX_PACKET_SIZE - sizeof(uint16_t))\n\nstatic uint8_t g_vehicleConfigMemory[512];\n\nint processVehicleConfigUpdate(const uint8_t* message_data, uint16_t message_len) {\n    if (message_data == NULL || message_len < sizeof(uint16_t)) {\n        return -1;\n    }\n\n    uint16_t num_params = (message_data[0] << 8) | message_data[1];\n    uint16_t current_read_offset = sizeof(uint16_t);\n\n    uint32_t total_payload_bytes_expected = 0;\n\n    for (uint16_t i = 0; i < num_params; ++i) {\n        if (current_read_offset + PARAMETER_RECORD_FIXED_HEADER_SIZE > message_len) {\n            return -2;\n        }\n\n        uint8_t data_len = message_data[current_read_offset + sizeof(uint16_t)];\n\n        if (current_read_offset + PARAMETER_RECORD_FIXED_HEADER_SIZE + data_len > message_len) {\n            return -3;\n        }\n\n        uint32_t param_record_size = (uint32_t)PARAMETER_RECORD_FIXED_HEADER_SIZE + data_len;\n        \n        if (total_payload_bytes_expected > (MAX_TOTAL_CONFIG_PAYLOAD_SIZE - param_record_size)) {\n            return -6;\n        }\n        total_payload_bytes_expected += param_record_size;\n\n        current_read_offset += param_record_size;\n    }\n\n    if (current_read_offset != message_len) {\n        return -4;\n    }\n\n    if (total_payload_bytes_expected > MAX_TOTAL_CONFIG_PAYLOAD_SIZE) {\n        return -8;\n    }\n    \n    uint8_t* temp_stage_buffer = (uint8_t*)malloc(total_payload_bytes_expected);\n    if (temp_stage_buffer == NULL) {\n        return -5;\n    }\n\n    memcpy(temp_stage_buffer, message_data + sizeof(uint16_t), total_payload_bytes_expected);\n\n    free(temp_stage_buffer);\n\n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define FIRMWARE_CONFIG_BUFFER_SIZE 256\n#define MAX_INCOMING_PARAM_DATA_SIZE 64\n\nstatic uint8_t g_firmwareConfigData[FIRMWARE_CONFIG_BUFFER_SIZE];\n\nvoid initFirmwareConfig() {\n    memset(g_firmwareConfigData, 0x00, FIRMWARE_CONFIG_BUFFER_SIZE);\n    g_firmwareConfigData[0] = 0xAA;\n    g_firmwareConfigData[1] = 0xBB;\n}\n\nint updateFirmwareConfigSegment(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len < 2) {\n        return -1;\n    }\n\n    uint8_t config_area_offset = packet_data[0];\n    uint8_t data_segment_length = packet_data[1];\n\n    if (2 + data_segment_length > packet_len) {\n        return -2;\n    }\n\n    if (data_segment_length > MAX_INCOMING_PARAM_DATA_SIZE) {\n        return -3;\n    }\n\n    if (config_area_offset >= FIRMWARE_CONFIG_BUFFER_SIZE) {\n        return -4;\n    }\n\n    const uint8_t* actual_data_ptr = packet_data + 2;\n\n    for (uint8_t i = 0; i < data_segment_length; ++i) {\n        g_firmwareConfigData[config_area_offset + i] = actual_data_ptr[i];\n    }\n\n    return 0;\n}\n\nvoid handleFirmwareUpdateMessage(const uint8_t* msg_payload, uint16_t payload_size) {\n    updateFirmwareConfigSegment(msg_payload, payload_size);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define FIRMWARE_CONFIG_BUFFER_SIZE 256\n#define MAX_INCOMING_PARAM_DATA_SIZE 64\n\nstatic uint8_t g_firmwareConfigData[FIRMWARE_CONFIG_BUFFER_SIZE];\n\nvoid initFirmwareConfig() {\n    memset(g_firmwareConfigData, 0x00, FIRMWARE_CONFIG_BUFFER_SIZE);\n    g_firmwareConfigData[0] = 0xAA;\n    g_firmwareConfigData[1] = 0xBB;\n}\n\nint updateFirmwareConfigSegment(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len < 2) {\n        return -1;\n    }\n\n    uint8_t config_area_offset = packet_data[0];\n    uint8_t data_segment_length = packet_data[1];\n\n    if (2 + data_segment_length > packet_len) {\n        return -2;\n    }\n\n    if (data_segment_length > MAX_INCOMING_PARAM_DATA_SIZE) {\n        return -3;\n    }\n\n    if (config_area_offset >= FIRMWARE_CONFIG_BUFFER_SIZE) {\n        return -4;\n    }\n\n    if (config_area_offset + data_segment_length > FIRMWARE_CONFIG_BUFFER_SIZE) {\n        return -5;\n    }\n\n    const uint8_t* actual_data_ptr = packet_data + 2;\n\n    for (uint8_t i = 0; i < data_segment_length; ++i) {\n        g_firmwareConfigData[config_area_offset + i] = actual_data_ptr[i];\n    }\n\n    return 0;\n}\n\nvoid handleFirmwareUpdateMessage(const uint8_t* msg_payload, uint16_t payload_size) {\n    updateFirmwareConfigSegment(msg_payload, payload_size);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define AGGREGATED_DATA_BUFFER_SIZE 256\n#define MAX_INCOMING_PACKET_SIZE 512\n\nstatic uint8_t g_aggregatedDataBuffer[AGGREGATED_DATA_BUFFER_SIZE];\nstatic uint16_t g_currentAggregatedLen = 0;\n\nvoid initDataAggregator() {\n    memset(g_aggregatedDataBuffer, 0, AGGREGATED_DATA_BUFFER_SIZE);\n    g_currentAggregatedLen = 0;\n}\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_length;\n} DataRecordHeader;\n\nint processDiagnosticDataPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len < 1) {\n        return -1;\n    }\n\n    uint16_t current_packet_offset = 0;\n    uint8_t record_count = packet[current_packet_offset++];\n\n    if (record_count == 0) {\n        g_currentAggregatedLen = 0;\n        return 0;\n    }\n    if (current_packet_offset >= packet_len) {\n        return -2;\n    }\n\n    g_currentAggregatedLen = 0;\n\n    for (int i = 0; i < record_count; ++i) {\n        if (current_packet_offset + sizeof(DataRecordHeader) > packet_len) {\n            return -3;\n        }\n\n        DataRecordHeader header;\n        header.record_type = packet[current_packet_offset];\n        current_packet_offset++;\n        header.record_length = packet[current_packet_offset];\n        current_packet_offset++;\n\n        if (current_packet_offset + header.record_length > packet_len) {\n            return -4;\n        }\n\n        for (uint8_t j = 0; j < header.record_length; ++j) {\n            g_aggregatedDataBuffer[g_currentAggregatedLen++] = packet[current_packet_offset++];\n        }\n    }\n\n    return 0;\n}\n\nvoid receiveDataPacket(const uint8_t* data, uint16_t len) {\n    processDiagnosticDataPacket(data, len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define AGGREGATED_DATA_BUFFER_SIZE 256\n#define MAX_INCOMING_PACKET_SIZE 512\n\nstatic uint8_t g_aggregatedDataBuffer[AGGREGATED_DATA_BUFFER_SIZE];\nstatic uint16_t g_currentAggregatedLen = 0;\n\nvoid initDataAggregator() {\n    memset(g_aggregatedDataBuffer, 0, AGGREGATED_DATA_BUFFER_SIZE);\n    g_currentAggregatedLen = 0;\n}\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_length;\n} DataRecordHeader;\n\nint processDiagnosticDataPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len < 1) {\n        return -1;\n    }\n\n    uint16_t current_packet_offset = 0;\n    uint8_t record_count = packet[current_packet_offset++];\n\n    if (record_count == 0) {\n        g_currentAggregatedLen = 0;\n        return 0;\n    }\n    if (current_packet_offset >= packet_len) {\n        return -2;\n    }\n\n    g_currentAggregatedLen = 0;\n\n    for (int i = 0; i < record_count; ++i) {\n        if (current_packet_offset + sizeof(DataRecordHeader) > packet_len) {\n            return -3;\n        }\n\n        DataRecordHeader header;\n        header.record_type = packet[current_packet_offset];\n        current_packet_offset++;\n        header.record_length = packet[current_packet_offset];\n        current_packet_offset++;\n\n        if (current_packet_offset + header.record_length > packet_len) {\n            return -4;\n        }\n\n        uint16_t bytes_to_copy_into_agg_buffer = header.record_length;\n        if (g_currentAggregatedLen + bytes_to_copy_into_agg_buffer > AGGREGATED_DATA_BUFFER_SIZE) {\n            bytes_to_copy_into_agg_buffer = AGGREGATED_DATA_BUFFER_SIZE - g_currentAggregatedLen;\n            if (bytes_to_copy_into_agg_buffer == 0) {\n                current_packet_offset += header.record_length;\n                continue;\n            }\n        }\n        \n        for (uint8_t j = 0; j < bytes_to_copy_into_agg_buffer; ++j) {\n            g_aggregatedDataBuffer[g_currentAggregatedLen++] = packet[current_packet_offset++];\n        }\n\n        current_packet_offset += (header.record_length - bytes_to_copy_into_agg_buffer);\n\n        if (g_currentAggregatedLen == AGGREGATED_DATA_BUFFER_SIZE) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nvoid receiveDataPacket(const uint8_t* data, uint16_t len) {\n    processDiagnosticDataPacket(data, len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define EVENT_LOG_BUFFER_SIZE 256\n#define MAX_SINGLE_EVENT_PAYLOAD_SIZE 64\n\ntypedef struct {\n    uint8_t event_id;\n    uint8_t payload_len;\n} EventLogHeader;\n\nstatic uint8_t g_eventLogBuffer[EVENT_LOG_BUFFER_SIZE];\nstatic uint16_t g_logWritePointer = 0;\n\nvoid initEventLogger() {\n    memset(g_eventLogBuffer, 0, EVENT_LOG_BUFFER_SIZE);\n    g_logWritePointer = 0;\n}\n\nint addEventToLog(uint8_t event_type, const uint8_t* event_data, uint8_t data_len) {\n    if (event_data == NULL) {\n        return -1;\n    }\n\n    if (data_len > MAX_SINGLE_EVENT_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    uint16_t entry_total_size = sizeof(EventLogHeader) + data_len;\n\n    // Vulnerability: The total size of the entry (header + data) is not checked against\n    // the remaining capacity of the global buffer before writing.\n    // An attacker can send a data_len that, while individually small (e.g., < MAX_SINGLE_EVENT_PAYLOAD_SIZE),\n    // causes an out-of-bounds write when combined with a specific g_logWritePointer value.\n    // For example, if g_logWritePointer is 250, and data_len is 8 (entry_total_size = 2+8=10),\n    // the copy will attempt to write up to index 250+2+7 = 259, overflowing the 256-byte buffer.\n\n    g_eventLogBuffer[g_logWritePointer] = event_type;\n    g_eventLogBuffer[g_logWritePointer + 1] = data_len;\n\n    // The loop iterates based on 'data_len' without an explicit bounds check for 'g_eventLogBuffer'\n    // on each iteration, relying only on previous checks that are insufficient.\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_eventLogBuffer[g_logWritePointer + 2 + i] = event_data[i];\n    }\n\n    g_logWritePointer += entry_total_size;\n\n    return 0;\n}\n\nvoid simulateDTCRecording(uint8_t dtc_code, const uint8_t* diagnostic_info, uint8_t info_len) {\n    if (g_logWritePointer == 0) {\n        initEventLogger();\n    }\n    addEventToLog(dtc_code, diagnostic_info, info_len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define EVENT_LOG_BUFFER_SIZE 256\n#define MAX_SINGLE_EVENT_PAYLOAD_SIZE 64\n\ntypedef struct {\n    uint8_t event_id;\n    uint8_t payload_len;\n} EventLogHeader;\n\nstatic uint8_t g_eventLogBuffer[EVENT_LOG_BUFFER_SIZE];\nstatic uint16_t g_logWritePointer = 0;\n\nvoid initEventLogger() {\n    memset(g_eventLogBuffer, 0, EVENT_LOG_BUFFER_SIZE);\n    g_logWritePointer = 0;\n}\n\nint addEventToLog(uint8_t event_type, const uint8_t* event_data, uint8_t data_len) {\n    if (event_data == NULL) {\n        return -1;\n    }\n\n    if (data_len > MAX_SINGLE_EVENT_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    uint16_t entry_total_size = sizeof(EventLogHeader) + data_len;\n\n    // FIX: Ensure the entire new entry (header + data) fits within the buffer.\n    if (g_logWritePointer + entry_total_size > EVENT_LOG_BUFFER_SIZE) {\n        return -3; // Not enough space, prevent overflow\n    }\n\n    g_eventLogBuffer[g_logWritePointer] = event_type;\n    g_eventLogBuffer[g_logWritePointer + 1] = data_len;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        // No further bounds check needed within the loop as the aggregate check above guarantees space.\n        g_eventLogBuffer[g_logWritePointer + 2 + i] = event_data[i];\n    }\n\n    g_logWritePointer += entry_total_size;\n\n    return 0;\n}\n\nvoid simulateDTCRecording(uint8_t dtc_code, const uint8_t* diagnostic_info, uint8_t info_len) {\n    if (g_logWritePointer == 0) {\n        initEventLogger();\n    }\n    addEventToLog(dtc_code, diagnostic_info, info_len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define REASSEMBLY_BUFFER_SIZE 256\n#define MAX_FRAGMENT_PAYLOAD_SIZE 64\n#define FRAGMENT_HEADER_SIZE 6\n\ntypedef struct {\n    uint16_t fragment_id;\n    uint16_t offset;\n    uint16_t length;\n} FragmentHeader;\n\nstatic uint8_t g_reassemblyBuffer[REASSEMBLY_BUFFER_SIZE];\nstatic uint16_t g_reassembledLength = 0;\n\nvoid initReassemblyBuffer() {\n    memset(g_reassemblyBuffer, 0, REASSEMBLY_BUFFER_SIZE);\n    g_reassembledLength = 0;\n}\n\nint processDataFragment(const uint8_t* raw_fragment_data, uint16_t raw_fragment_len) {\n    if (raw_fragment_data == NULL || raw_fragment_len < FRAGMENT_HEADER_SIZE) {\n        return -1;\n    }\n\n    FragmentHeader header;\n    header.fragment_id = (raw_fragment_data[0] << 8) | raw_fragment_data[1];\n    header.offset      = (raw_fragment_data[2] << 8) | raw_fragment_data[3];\n    header.length      = (raw_fragment_data[4] << 8) | raw_fragment_data[5];\n\n    if (FRAGMENT_HEADER_SIZE + header.length > raw_fragment_len) {\n        return -2;\n    }\n\n    if (header.length > MAX_FRAGMENT_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    for (uint16_t i = 0; i < header.length; ++i) {\n        g_reassemblyBuffer[header.offset + i] = raw_fragment_data[FRAGMENT_HEADER_SIZE + i];\n    }\n\n    if (header.offset + header.length > g_reassembledLength) {\n        g_reassembledLength = header.offset + header.length;\n    }\n\n    return 0;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define REASSEMBLY_BUFFER_SIZE 256\n#define MAX_FRAGMENT_PAYLOAD_SIZE 64\n#define FRAGMENT_HEADER_SIZE 6\n\ntypedef struct {\n    uint16_t fragment_id;\n    uint16_t offset;\n    uint16_t length;\n} FragmentHeader;\n\nstatic uint8_t g_reassemblyBuffer[REASSEMBLY_BUFFER_SIZE];\nstatic uint16_t g_reassembledLength = 0;\n\nvoid initReassemblyBuffer() {\n    memset(g_reassemblyBuffer, 0, REASSEMBLY_BUFFER_SIZE);\n    g_reassembledLength = 0;\n}\n\nint processDataFragment(const uint8_t* raw_fragment_data, uint16_t raw_fragment_len) {\n    if (raw_fragment_data == NULL || raw_fragment_len < FRAGMENT_HEADER_SIZE) {\n        return -1;\n    }\n\n    FragmentHeader header;\n    header.fragment_id = (raw_fragment_data[0] << 8) | raw_fragment_data[1];\n    header.offset      = (raw_fragment_data[2] << 8) | raw_fragment_data[3];\n    header.length      = (raw_fragment_data[4] << 8) | raw_fragment_data[5];\n\n    if (FRAGMENT_HEADER_SIZE + header.length > raw_fragment_len) {\n        return -2;\n    }\n\n    if (header.length > MAX_FRAGMENT_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    if (header.offset >= REASSEMBLY_BUFFER_SIZE || (header.length > 0 && header.offset + header.length > REASSEMBLY_BUFFER_SIZE)) {\n        return -4;\n    }\n\n    for (uint16_t i = 0; i < header.length; ++i) {\n        g_reassemblyBuffer[header.offset + i] = raw_fragment_data[FRAGMENT_HEADER_SIZE + i];\n    }\n\n    if (header.offset + header.length > g_reassembledLength) {\n        g_reassembledLength = header.offset + header.length;\n    }\n\n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CALIBRATION_BLOCK_SIZE 64\n#define NUM_CALIBRATION_BLOCKS 8\n#define TOTAL_CALIBRATION_SIZE (CALIBRATION_BLOCK_SIZE * NUM_CALIBRATION_BLOCKS)\n\nstatic uint8_t g_calibrationData[TOTAL_CALIBRATION_SIZE];\nstatic bool g_calibrationInitialized = false;\n\nvoid initCalibrationSystem() {\n    memset(g_calibrationData, 0, TOTAL_CALIBRATION_SIZE);\n    g_calibrationInitialized = true;\n}\n\nint processCalibrationFragment(const uint8_t* msg_payload, uint16_t payload_len) {\n    if (!g_calibrationInitialized || msg_payload == NULL || payload_len < 5) {\n        return -1;\n    }\n\n    uint8_t block_idx = msg_payload[0];\n    uint16_t block_offset = (msg_payload[1] << 8) | msg_payload[2];\n    uint16_t data_len = (msg_payload[3] << 8) | msg_payload[4];\n\n    if (payload_len < (5 + data_len)) {\n        return -2;\n    }\n\n    if (block_idx >= NUM_CALIBRATION_BLOCKS) {\n        return -3;\n    }\n    \n    if (block_offset >= CALIBRATION_BLOCK_SIZE) {\n        return -4;\n    }\n\n    const uint8_t* data_payload = msg_payload + 5;\n\n    uint16_t global_start_offset = (uint16_t)block_idx * CALIBRATION_BLOCK_SIZE + block_offset;\n\n    for (uint16_t i = 0; i < data_len; ++i) {\n        g_calibrationData[global_start_offset + i] = data_payload[i];\n    }\n    \n    return 0;\n}\n\nvoid handleCANCalibrationMessage(const uint8_t* can_data, uint16_t can_dlc) {\n    processCalibrationFragment(can_data, can_dlc);\n}\n\nuint8_t getCalibrationByte(uint16_t index) {\n    if (index < TOTAL_CALIBRATION_SIZE) {\n        return g_calibrationData[index];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CALIBRATION_BLOCK_SIZE 64\n#define NUM_CALIBRATION_BLOCKS 8\n#define TOTAL_CALIBRATION_SIZE (CALIBRATION_BLOCK_SIZE * NUM_CALIBRATION_BLOCKS)\n\nstatic uint8_t g_calibrationData[TOTAL_CALIBRATION_SIZE];\nstatic bool g_calibrationInitialized = false;\n\nvoid initCalibrationSystem() {\n    memset(g_calibrationData, 0, TOTAL_CALIBRATION_SIZE);\n    g_calibrationInitialized = true;\n}\n\nint processCalibrationFragment(const uint8_t* msg_payload, uint16_t payload_len) {\n    if (!g_calibrationInitialized || msg_payload == NULL || payload_len < 5) {\n        return -1;\n    }\n\n    uint8_t block_idx = msg_payload[0];\n    uint16_t block_offset = (msg_payload[1] << 8) | msg_payload[2];\n    uint16_t data_len = (msg_payload[3] << 8) | msg_payload[4];\n\n    if (payload_len < (5 + data_len)) {\n        return -2;\n    }\n\n    if (block_idx >= NUM_CALIBRATION_BLOCKS) {\n        return -3;\n    }\n\n    const uint8_t* data_payload = msg_payload + 5;\n\n    uint16_t global_start_offset = (uint16_t)block_idx * CALIBRATION_BLOCK_SIZE + block_offset;\n\n    if (global_start_offset >= TOTAL_CALIBRATION_SIZE || \n        global_start_offset + data_len > TOTAL_CALIBRATION_SIZE) {\n        return -5;\n    }\n\n    for (uint16_t i = 0; i < data_len; ++i) {\n        g_calibrationData[global_start_offset + i] = data_payload[i];\n    }\n    \n    return 0;\n}\n\nvoid handleCANCalibrationMessage(const uint8_t* can_data, uint16_t can_dlc) {\n    processCalibrationFragment(can_data, can_dlc);\n}\n\nuint8_t getCalibrationByte(uint16_t index) {\n    if (index < TOTAL_CALIBRATION_SIZE) {\n        return g_calibrationData[index];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_CAN_FRAME_DATA_LENGTH 8\n#define VEHICLE_STATE_SENSOR_ID 0x01\n#define TIRE_PRESSURE_SENSOR_ID 0x02\n#define FUEL_LEVEL_SENSOR_ID 0x03\n#define VEHICLE_DIAGNOSTIC_DATA_ID 0x04\n\n#define MAX_SENSOR_DATA_PAYLOAD 60 \n\n#define DIAGNOSTIC_STRING_BUFFER_SIZE 30\n\ntypedef struct {\n    uint8_t sensor_id;\n    uint8_t data_length; \n    uint8_t data[MAX_SENSOR_DATA_PAYLOAD]; \n} SensorPacketSegment;\n\nint processSensorTelemetryStream(const uint8_t* msg_buffer, uint16_t msg_len) {\n    if (msg_buffer == NULL || msg_len < (sizeof(uint8_t) * 2)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    while (current_offset < msg_len) {\n        if (current_offset + sizeof(uint8_t) * 2 > msg_len) {\n            return -2;\n        }\n\n        uint8_t sensor_id = msg_buffer[current_offset];\n        uint8_t data_len = msg_buffer[current_offset + 1];\n\n        if (current_offset + sizeof(uint8_t) * 2 + data_len > msg_len) {\n            return -3;\n        }\n        \n        const uint8_t* sensor_data_ptr = msg_buffer + current_offset + sizeof(uint8_t) * 2;\n\n        if (sensor_id == VEHICLE_DIAGNOSTIC_DATA_ID) {\n            char diagnostic_buffer[DIAGNOSTIC_STRING_BUFFER_SIZE];\n            memset(diagnostic_buffer, 0, DIAGNOSTIC_STRING_BUFFER_SIZE); \n\n            for (int i = 0; i < data_len; ++i) {\n                diagnostic_buffer[i] = (char)sensor_data_ptr[i];\n            }\n            diagnostic_buffer[data_len] = '\\0'; \n\n        }\n\n        current_offset += (sizeof(uint8_t) * 2 + data_len);\n    }\n\n    return 0;\n}\n\nvoid handleTelemetryStream(const uint8_t* stream, uint16_t len) {\n    processSensorTelemetryStream(stream, len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_CAN_FRAME_DATA_LENGTH 8\n#define VEHICLE_STATE_SENSOR_ID 0x01\n#define TIRE_PRESSURE_SENSOR_ID 0x02\n#define FUEL_LEVEL_SENSOR_ID 0x03\n#define VEHICLE_DIAGNOSTIC_DATA_ID 0x04\n\n#define MAX_SENSOR_DATA_PAYLOAD 60 \n\n#define DIAGNOSTIC_STRING_BUFFER_SIZE 30\n\ntypedef struct {\n    uint8_t sensor_id;\n    uint8_t data_length; \n    uint8_t data[MAX_SENSOR_DATA_PAYLOAD]; \n} SensorPacketSegment;\n\nint processSensorTelemetryStream(const uint8_t* msg_buffer, uint16_t msg_len) {\n    if (msg_buffer == NULL || msg_len < (sizeof(uint8_t) * 2)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    while (current_offset < msg_len) {\n        if (current_offset + sizeof(uint8_t) * 2 > msg_len) {\n            return -2;\n        }\n\n        uint8_t sensor_id = msg_buffer[current_offset];\n        uint8_t data_len = msg_buffer[current_offset + 1];\n\n        if (current_offset + sizeof(uint8_t) * 2 + data_len > msg_len) {\n            return -3;\n        }\n        \n        const uint8_t* sensor_data_ptr = msg_buffer + current_offset + sizeof(uint8_t) * 2;\n\n        if (sensor_id == VEHICLE_DIAGNOSTIC_DATA_ID) {\n            char diagnostic_buffer[DIAGNOSTIC_STRING_BUFFER_SIZE];\n            memset(diagnostic_buffer, 0, DIAGNOSTIC_STRING_BUFFER_SIZE); \n\n            uint8_t bytes_to_copy = data_len;\n            if (bytes_to_copy >= DIAGNOSTIC_STRING_BUFFER_SIZE) {\n                bytes_to_copy = DIAGNOSTIC_STRING_BUFFER_SIZE - 1; \n            }\n\n            for (int i = 0; i < bytes_to_copy; ++i) {\n                diagnostic_buffer[i] = (char)sensor_data_ptr[i];\n            }\n            diagnostic_buffer[bytes_to_copy] = '\\0'; \n\n        }\n\n        current_offset += (sizeof(uint8_t) * 2 + data_len);\n    }\n\n    return 0;\n}\n\nvoid handleTelemetryStream(const uint8_t* stream, uint16_t len) {\n    processSensorTelemetryStream(stream, len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define CRITICAL_CALIBRATION_VALUES_COUNT 10 \n#define CALIBRATION_BUFFER_SIZE (CRITICAL_CALIBRATION_VALUES_COUNT * sizeof(uint16_t))\n\nstatic uint16_t g_criticalCalibrationValues[CRITICAL_CALIBRATION_VALUES_COUNT];\n\nvoid initCalibrationValues() {\n    memset(g_criticalCalibrationValues, 0, CALIBRATION_BUFFER_SIZE);\n    for (uint8_t i = 0; i < CRITICAL_CALIBRATION_VALUES_COUNT; ++i) {\n        g_criticalCalibrationValues[i] = (i + 1) * 100;\n    }\n}\n\ntypedef struct {\n    uint8_t  group_id;\n    uint8_t  item_offset;\n    uint16_t new_value;\n} CalibrationUpdateCommand;\n\nint applyCalibrationUpdate(const CalibrationUpdateCommand* command) {\n    if (command == NULL) {\n        return -1;\n    }\n\n    uint8_t group_id = command->group_id;\n    uint8_t item_offset = command->item_offset;\n    uint16_t new_value = command->new_value;\n\n    uint8_t effective_index_base_8bit;\n\n    switch (group_id) {\n        case 0:\n            effective_index_base_8bit = 0;\n            break;\n        case 1:\n            effective_index_base_8bit = 5;\n            break;\n        case 2:\n            effective_index_base_8bit = 250;\n            break;\n        default:\n            return -2;\n    }\n\n    uint8_t final_index_8bit = effective_index_base_8bit + item_offset;\n\n    if (final_index_8bit >= CRITICAL_CALIBRATION_VALUES_COUNT) {\n        return -3;\n    }\n\n    g_criticalCalibrationValues[final_index_8bit] = new_value;\n\n    return 0;\n}\n\nvoid simulateExternalCalibrationUpdate(uint8_t group, uint8_t offset, uint16_t value) {\n    CalibrationUpdateCommand cmd = { .group_id = group, .item_offset = offset, .new_value = value };\n    applyCalibrationUpdate(&cmd);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define CRITICAL_CALIBRATION_VALUES_COUNT 10 \n#define CALIBRATION_BUFFER_SIZE (CRITICAL_CALIBRATION_VALUES_COUNT * sizeof(uint16_t))\n\nstatic uint16_t g_criticalCalibrationValues[CRITICAL_CALIBRATION_VALUES_COUNT];\n\nvoid initCalibrationValues() {\n    memset(g_criticalCalibrationValues, 0, CALIBRATION_BUFFER_SIZE);\n    for (uint8_t i = 0; i < CRITICAL_CALIBRATION_VALUES_COUNT; ++i) {\n        g_criticalCalibrationValues[i] = (i + 1) * 100;\n    }\n}\n\ntypedef struct {\n    uint8_t  group_id;\n    uint8_t  item_offset;\n    uint16_t new_value;\n} CalibrationUpdateCommand;\n\nint applyCalibrationUpdate(const CalibrationUpdateCommand* command) {\n    if (command == NULL) {\n        return -1;\n    }\n\n    uint8_t group_id = command->group_id;\n    uint8_t item_offset = command->item_offset;\n    uint16_t new_value = command->new_value;\n\n    uint16_t effective_index_base; \n\n    switch (group_id) {\n        case 0:\n            effective_index_base = 0;\n            break;\n        case 1:\n            effective_index_base = 5;\n            break;\n        case 2:\n            effective_index_base = 250;\n            break;\n        default:\n            return -2;\n    }\n\n    uint16_t final_index = effective_index_base + item_offset;\n\n    if (final_index >= CRITICAL_CALIBRATION_VALUES_COUNT) {\n        return -3;\n    }\n\n    g_criticalCalibrationValues[final_index] = new_value;\n\n    return 0;\n}\n\nvoid simulateExternalCalibrationUpdate(uint8_t group, uint8_t offset, uint16_t value) {\n    CalibrationUpdateCommand cmd = { .group_id = group, .item_offset = offset, .new_value = value };\n    applyCalibrationUpdate(&cmd);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n// Define CAN message IDs for specific diagnostic services\n#define CAN_ID_CONFIG_UPDATE_SERVICE 0x18F00100\n#define CAN_ID_STATUS_REQUEST_SERVICE 0x18F00200\n\n// Maximum number of configurable parameters\n#define MAX_CONFIG_PARAMETERS 64\n\n// Structure for a single configurable parameter entry\ntypedef struct {\n    uint8_t id;\n    uint8_t value;\n    uint8_t type; \n} ConfigParameterEntry;\n\n// Main ECU configuration storage\nstatic ConfigParameterEntry ecu_config_store[MAX_CONFIG_PARAMETERS];\n\n// Initializes the ECU configuration store with default values\nvoid init_ecu_config_store() {\n    for (int i = 0; i < MAX_CONFIG_PARAMETERS; ++i) {\n        ecu_config_store[i].id = (uint8_t)i;\n        ecu_config_store[i].value = 0x00;\n        ecu_config_store[i].type = 0x00; \n    }\n}\n\n// Function to process a CAN diagnostic message payload\n// This function assumes the msg_id has already been validated to be a config update service.\n// The payload format for config update: [param_index_byte][param_value_byte]\n// This service allows setting a single parameter at a time.\nint process_config_update_payload(const uint8_t* payload, uint8_t payload_len) {\n    if (payload == NULL || payload_len < 2) {\n        return -1; \n    }\n\n    uint8_t param_idx_received = payload[0]; \n    uint8_t new_param_value = payload[1];\n\n    // The vulnerability: No bounds check on param_idx_received.\n    // An attacker can send param_idx_received >= MAX_CONFIG_PARAMETERS\n    // to write to memory outside ecu_config_store.\n    ecu_config_store[param_idx_received].value = new_param_value;\n\n    return 0; \n}\n\n// Main entry point for processing incoming CAN messages\n// This function would typically be called by a CAN driver interrupt or polling loop.\nint handle_can_diagnostic_message(uint32_t can_id, const uint8_t* data_bytes, uint8_t data_len) {\n    if (data_bytes == NULL || data_len == 0) {\n        return -1; \n    }\n\n    switch (can_id) {\n        case CAN_ID_CONFIG_UPDATE_SERVICE:\n            return process_config_update_payload(data_bytes, data_len);\n        case CAN_ID_STATUS_REQUEST_SERVICE:\n            // Placeholder for status request handling logic\n            return 0;\n        default:\n            return -99; \n    }\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n// Define CAN message IDs for specific diagnostic services\n#define CAN_ID_CONFIG_UPDATE_SERVICE 0x18F00100\n#define CAN_ID_STATUS_REQUEST_SERVICE 0x18F00200\n\n// Maximum number of configurable parameters\n#define MAX_CONFIG_PARAMETERS 64\n\n// Structure for a single configurable parameter entry\ntypedef struct {\n    uint8_t id;\n    uint8_t value;\n    uint8_t type; \n} ConfigParameterEntry;\n\n// Main ECU configuration storage\nstatic ConfigParameterEntry ecu_config_store[MAX_CONFIG_PARAMETERS];\n\n// Initializes the ECU configuration store with default values\nvoid init_ecu_config_store() {\n    for (int i = 0; i < MAX_CONFIG_PARAMETERS; ++i) {\n        ecu_config_store[i].id = (uint8_t)i;\n        ecu_config_store[i].value = 0x00;\n        ecu_config_store[i].type = 0x00; \n    }\n}\n\n// Function to process a CAN diagnostic message payload\n// This function assumes the msg_id has already been validated to be a config update service.\n// The payload format for config update: [param_index_byte][param_value_byte]\n// This service allows setting a single parameter at a time.\nint process_config_update_payload(const uint8_t* payload, uint8_t payload_len) {\n    if (payload == NULL || payload_len < 2) {\n        return -1; \n    }\n\n    uint8_t param_idx_received = payload[0];\n    uint8_t new_param_value = payload[1];\n\n    // The fix: Add a bounds check for param_idx_received\n    if (param_idx_received >= MAX_CONFIG_PARAMETERS) {\n        return -2; \n    }\n\n    ecu_config_store[param_idx_received].value = new_param_value;\n\n    return 0; \n}\n\n// Main entry point for processing incoming CAN messages\n// This function would typically be called by a CAN driver interrupt or polling loop.\nint handle_can_diagnostic_message(uint32_t can_id, const uint8_t* data_bytes, uint8_t data_len) {\n    if (data_bytes == NULL || data_len == 0) {\n        return -1; \n    }\n\n    switch (can_id) {\n        case CAN_ID_CONFIG_UPDATE_SERVICE:\n            return process_config_update_payload(data_bytes, data_len);\n        case CAN_ID_STATUS_REQUEST_SERVICE:\n            // Placeholder for status request handling logic\n            return 0;\n        default:\n            return -99; \n    }\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_SENSOR_PROFILES 4\n#define SENSOR_PROFILE_BUFFER_SIZE 64\n#define MAX_CALIBRATION_PAYLOAD_SIZE 32\n\nstatic uint8_t g_sensorCalibrationProfiles[NUM_SENSOR_PROFILES][SENSOR_PROFILE_BUFFER_SIZE];\n\nvoid initSensorCalibrationProfiles() {\n    for (int i = 0; i < NUM_SENSOR_PROFILES; ++i) {\n        memset(g_sensorCalibrationProfiles[i], 0x00, SENSOR_PROFILE_BUFFER_SIZE);\n        g_sensorCalibrationProfiles[i][0] = i;\n    }\n}\n\ntypedef struct {\n    uint8_t  profile_index;\n    uint8_t  data_offset;\n    uint8_t  data_length;\n    uint8_t  payload[MAX_CALIBRATION_PAYLOAD_SIZE];\n} SensorCalibrationUpdateMsg;\n\nint applyCalibrationUpdate(const SensorCalibrationUpdateMsg* msg) {\n    if (msg == NULL) {\n        return -1;\n    }\n\n    uint8_t profile_idx = msg->profile_index;\n    uint8_t offset = msg->data_offset;\n    uint8_t length = msg->data_length;\n    const uint8_t* data = msg->payload;\n\n    if (profile_idx >= NUM_SENSOR_PROFILES) {\n        return -2;\n    }\n\n    if (length == 0 || length > MAX_CALIBRATION_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    if (offset >= SENSOR_PROFILE_BUFFER_SIZE) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < length; ++i) {\n        g_sensorCalibrationProfiles[profile_idx][offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid simulateCalibrationMessage(uint8_t p_idx, uint8_t off, uint8_t len, const uint8_t* payload_data) {\n    SensorCalibrationUpdateMsg msg;\n    msg.profile_index = p_idx;\n    msg.data_offset = off;\n    msg.data_length = len;\n    if (len > MAX_CALIBRATION_PAYLOAD_SIZE) {\n        len = MAX_CALIBRATION_PAYLOAD_SIZE; \n    }\n    for (uint8_t i = 0; i < len; ++i) {\n        msg.payload[i] = payload_data[i];\n    }\n    applyCalibrationUpdate(&msg);\n}\n\nuint8_t getCalibrationByte(uint8_t profile_idx, uint8_t offset) {\n    if (profile_idx < NUM_SENSOR_PROFILES && offset < SENSOR_PROFILE_BUFFER_SIZE) {\n        return g_sensorCalibrationProfiles[profile_idx][offset];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_SENSOR_PROFILES 4\n#define SENSOR_PROFILE_BUFFER_SIZE 64\n#define MAX_CALIBRATION_PAYLOAD_SIZE 32\n\nstatic uint8_t g_sensorCalibrationProfiles[NUM_SENSOR_PROFILES][SENSOR_PROFILE_BUFFER_SIZE];\n\nvoid initSensorCalibrationProfiles() {\n    for (int i = 0; i < NUM_SENSOR_PROFILES; ++i) {\n        memset(g_sensorCalibrationProfiles[i], 0x00, SENSOR_PROFILE_BUFFER_SIZE);\n        g_sensorCalibrationProfiles[i][0] = i;\n    }\n}\n\ntypedef struct {\n    uint8_t  profile_index;\n    uint8_t  data_offset;\n    uint8_t  data_length;\n    uint8_t  payload[MAX_CALIBRATION_PAYLOAD_SIZE];\n} SensorCalibrationUpdateMsg;\n\nint applyCalibrationUpdate(const SensorCalibrationUpdateMsg* msg) {\n    if (msg == NULL) {\n        return -1;\n    }\n\n    uint8_t profile_idx = msg->profile_index;\n    uint8_t offset = msg->data_offset;\n    uint8_t length = msg->data_length;\n    const uint8_t* data = msg->payload;\n\n    if (profile_idx >= NUM_SENSOR_PROFILES) {\n        return -2;\n    }\n\n    if (length == 0 || length > MAX_CALIBRATION_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    if (offset >= SENSOR_PROFILE_BUFFER_SIZE) {\n        return -4;\n    }\n\n    if ((uint16_t)offset + length > SENSOR_PROFILE_BUFFER_SIZE) {\n        return -5;\n    }\n\n    for (uint8_t i = 0; i < length; ++i) {\n        g_sensorCalibrationProfiles[profile_idx][offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid simulateCalibrationMessage(uint8_t p_idx, uint8_t off, uint8_t len, const uint8_t* payload_data) {\n    SensorCalibrationUpdateMsg msg;\n    msg.profile_index = p_idx;\n    msg.data_offset = off;\n    msg.data_length = len;\n    if (len > MAX_CALIBRATION_PAYLOAD_SIZE) {\n        len = MAX_CALIBRATION_PAYLOAD_SIZE; \n    }\n    for (uint8_t i = 0; i < len; ++i) {\n        msg.payload[i] = payload_data[i];\n    }\n    applyCalibrationUpdate(&msg);\n}\n\nuint8_t getCalibrationByte(uint8_t profile_idx, uint8_t offset) {\n    if (profile_idx < NUM_SENSOR_PROFILES && offset < SENSOR_PROFILE_BUFFER_SIZE) {\n        return g_sensorCalibrationProfiles[profile_idx][offset];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_VEHICLE_COMPONENTS 10\n#define BASE_INTERVAL_ARRAY_SIZE NUM_VEHICLE_COMPONENTS\n#define PROFILE_MODIFIER_ARRAY_SIZE (NUM_VEHICLE_COMPONENTS * 2) \n\nstatic uint16_t g_componentBaseIntervals[BASE_INTERVAL_ARRAY_SIZE];\nstatic int16_t g_componentProfileModifiers[PROFILE_MODIFIER_ARRAY_SIZE];\n\ntypedef struct {\n    uint8_t component_idx;\n    uint8_t profile_offset;\n    int8_t adjustment_value;\n} MaintenanceUpdateReq;\n\nvoid initMaintenanceSystem() {\n    memset(g_componentBaseIntervals, 0, sizeof(g_componentBaseIntervals));\n    memset(g_componentProfileModifiers, 0, sizeof(g_componentProfileModifiers));\n    for (uint8_t i = 0; i < NUM_VEHICLE_COMPONENTS; ++i) {\n        g_componentBaseIntervals[i] = 1000 + (i * 10);\n        g_componentProfileModifiers[i * 2] = 0;\n        g_componentProfileModifiers[i * 2 + 1] = -50;\n    }\n}\n\nint applyMaintenanceScheduleUpdate(const MaintenanceUpdateReq* req) {\n    if (req == NULL) {\n        return -1;\n    }\n\n    if (req->component_idx >= NUM_VEHICLE_COMPONENTS) {\n        return -2;\n    }\n\n    uint16_t effective_modifier_index = (uint16_t)(req->component_idx * 2) + req->profile_offset;\n\n    g_componentProfileModifiers[effective_modifier_index] += req->adjustment_value;\n\n    g_componentBaseIntervals[req->component_idx] += (req->adjustment_value / 2);\n\n    return 0;\n}\n\nvoid simulateMaintenanceRequest(uint8_t comp_id, uint8_t profile_off, int8_t adj_val) {\n    MaintenanceUpdateReq request = { .component_idx = comp_id, .profile_offset = profile_off, .adjustment_value = adj_val };\n    applyMaintenanceScheduleUpdate(&request);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_VEHICLE_COMPONENTS 10\n#define BASE_INTERVAL_ARRAY_SIZE NUM_VEHICLE_COMPONENTS\n#define PROFILE_MODIFIER_ARRAY_SIZE (NUM_VEHICLE_COMPONENTS * 2) \n\nstatic uint16_t g_componentBaseIntervals[BASE_INTERVAL_ARRAY_SIZE];\nstatic int16_t g_componentProfileModifiers[PROFILE_MODIFIER_ARRAY_SIZE];\n\ntypedef struct {\n    uint8_t component_idx;\n    uint8_t profile_offset;\n    int8_t adjustment_value;\n} MaintenanceUpdateReq;\n\nvoid initMaintenanceSystem() {\n    memset(g_componentBaseIntervals, 0, sizeof(g_componentBaseIntervals));\n    memset(g_componentProfileModifiers, 0, sizeof(g_componentProfileModifiers));\n    for (uint8_t i = 0; i < NUM_VEHICLE_COMPONENTS; ++i) {\n        g_componentBaseIntervals[i] = 1000 + (i * 10);\n        g_componentProfileModifiers[i * 2] = 0;\n        g_componentProfileModifiers[i * 2 + 1] = -50;\n    }\n}\n\nint applyMaintenanceScheduleUpdate(const MaintenanceUpdateReq* req) {\n    if (req == NULL) {\n        return -1;\n    }\n\n    if (req->component_idx >= NUM_VEHICLE_COMPONENTS) {\n        return -2;\n    }\n\n    uint16_t effective_modifier_index = (uint16_t)(req->component_idx * 2) + req->profile_offset;\n\n    if (effective_modifier_index >= PROFILE_MODIFIER_ARRAY_SIZE) {\n        return -3;\n    }\n\n    g_componentProfileModifiers[effective_modifier_index] += req->adjustment_value;\n\n    g_componentBaseIntervals[req->component_idx] += (req->adjustment_value / 2);\n\n    return 0;\n}\n\nvoid simulateMaintenanceRequest(uint8_t comp_id, uint8_t profile_off, int8_t adj_val) {\n    MaintenanceUpdateReq request = { .component_idx = comp_id, .profile_offset = profile_off, .adjustment_value = adj_val };\n    applyMaintenanceScheduleUpdate(&request);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_ENGINE_CALIBRATION_POINTS 100\n#define MAX_PAYLOAD_FOR_CALIBRATION 512\n\ntypedef struct {\n    uint16_t rpm_target;\n    uint16_t fuel_injection_pulse;\n} EngineCalibrationPoint;\n\nstatic EngineCalibrationPoint g_engineCalibrationTable[MAX_ENGINE_CALIBRATION_POINTS];\n\nvoid initEngineCalibration() {\n    memset(g_engineCalibrationTable, 0, sizeof(g_engineCalibrationTable));\n    for (int i = 0; i < MAX_ENGINE_CALIBRATION_POINTS; ++i) {\n        g_engineCalibrationTable[i].rpm_target = 800 + i * 10;\n        g_engineCalibrationTable[i].fuel_injection_pulse = 100 + i * 2;\n    }\n}\n\nint updateEngineCalibration(const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len < 4) {\n        return -1;\n    }\n\n    uint16_t start_index = (payload[0] << 8) | payload[1];\n    uint16_t num_points = (payload[2] << 8) | payload[3];\n\n    uint16_t data_offset = 4;\n    uint16_t expected_data_len = num_points * sizeof(EngineCalibrationPoint);\n\n    if (data_offset + expected_data_len > payload_len) {\n        return -2;\n    }\n    \n    if (start_index >= MAX_ENGINE_CALIBRATION_POINTS) {\n        return -3;\n    }\n\n    for (uint16_t i = 0; i < num_points; ++i) {\n        uint16_t current_data_ptr_offset = data_offset + (i * sizeof(EngineCalibrationPoint));\n        \n        g_engineCalibrationTable[start_index + i].rpm_target = \n            (payload[current_data_ptr_offset] << 8) | payload[current_data_ptr_offset + 1];\n        g_engineCalibrationTable[start_index + i].fuel_injection_pulse = \n            (payload[current_data_ptr_offset + 2] << 8) | payload[current_data_ptr_offset + 3];\n    }\n\n    return 0;\n}\n\nvoid simulateCanMessage(const uint8_t* data, uint16_t len) {\n    updateEngineCalibration(data, len);\n}\n\nEngineCalibrationPoint getCalibrationPoint(uint16_t index) {\n    if (index < MAX_ENGINE_CALIBRATION_POINTS) {\n        return g_engineCalibrationTable[index];\n    }\n    EngineCalibrationPoint invalid = {0,0};\n    return invalid;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_ENGINE_CALIBRATION_POINTS 100\n#define MAX_PAYLOAD_FOR_CALIBRATION 512\n\ntypedef struct {\n    uint16_t rpm_target;\n    uint16_t fuel_injection_pulse;\n} EngineCalibrationPoint;\n\nstatic EngineCalibrationPoint g_engineCalibrationTable[MAX_ENGINE_CALIBRATION_POINTS];\n\nvoid initEngineCalibration() {\n    memset(g_engineCalibrationTable, 0, sizeof(g_engineCalibrationTable));\n    for (int i = 0; i < MAX_ENGINE_CALIBRATION_POINTS; ++i) {\n        g_engineCalibrationTable[i].rpm_target = 800 + i * 10;\n        g_engineCalibrationTable[i].fuel_injection_pulse = 100 + i * 2;\n    }\n}\n\nint updateEngineCalibration(const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len < 4) {\n        return -1;\n    }\n\n    uint16_t start_index = (payload[0] << 8) | payload[1];\n    uint16_t num_points = (payload[2] << 8) | payload[3];\n\n    uint16_t data_offset = 4;\n    uint16_t expected_data_len = num_points * sizeof(EngineCalibrationPoint);\n\n    if (data_offset + expected_data_len > payload_len) {\n        return -2;\n    }\n    \n    if (start_index >= MAX_ENGINE_CALIBRATION_POINTS || (num_points > 0 && (uint32_t)start_index + num_points > MAX_ENGINE_CALIBRATION_POINTS)) {\n        return -3;\n    }\n\n    for (uint16_t i = 0; i < num_points; ++i) {\n        uint16_t current_data_ptr_offset = data_offset + (i * sizeof(EngineCalibrationPoint));\n        \n        g_engineCalibrationTable[start_index + i].rpm_target = \n            (payload[current_data_ptr_offset] << 8) | payload[current_data_ptr_offset + 1];\n        g_engineCalibrationTable[start_index + i].fuel_injection_pulse = \n            (payload[current_data_ptr_offset + 2] << 8) | payload[current_data_ptr_offset + 3];\n    }\n\n    return 0;\n}\n\nvoid simulateCanMessage(const uint8_t* data, uint16_t len) {\n    updateEngineCalibration(data, len);\n}\n\nEngineCalibrationPoint getCalibrationPoint(uint16_t index) {\n    if (index < MAX_ENGINE_CALIBRATION_POINTS) {\n        return g_engineCalibrationTable[index];\n    }\n    EngineCalibrationPoint invalid = {0,0};\n    return invalid;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_FIRMWARE_SIZE 0x10000 \n#define FRAGMENT_MAX_PAYLOAD_SIZE 256 \n\nstatic uint8_t g_firmwareBuffer[VEHICLE_FIRMWARE_SIZE];\n\nvoid initFirmwareBuffer() {\n    memset(g_firmwareBuffer, 0, VEHICLE_FIRMWARE_SIZE);\n}\n\nstatic int processFirmwareFragment(uint16_t fragment_offset, uint8_t fragment_len, const uint8_t* fragment_data) {\n    if (fragment_data == NULL || fragment_len == 0) {\n        return -1;\n    }\n\n    if ((uint32_t)fragment_offset + fragment_len > VEHICLE_FIRMWARE_SIZE) {\n        return -2;\n    }\n\n    for (uint8_t i = 0; i < fragment_len; ++i) {\n        g_firmwareBuffer[fragment_offset + i] = fragment_data[i];\n    }\n\n    return 0;\n}\n\nint handleFirmwareUpdateMessage(const uint8_t* message, uint16_t message_len) {\n    if (message == NULL || message_len < (1 + sizeof(uint16_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    uint8_t service_id = message[0];\n    if (service_id != 0x34) {\n        return -2;\n    }\n\n    uint16_t offset_idx = 1;\n    uint16_t fragment_offset = (message[offset_idx] << 8) | message[offset_idx+1];\n    \n    uint16_t len_idx = offset_idx + sizeof(uint16_t);\n    uint8_t fragment_len = message[len_idx];\n\n    const uint8_t* fragment_data = message + len_idx + sizeof(uint8_t);\n    uint16_t actual_data_in_msg_len = message_len - (len_idx + sizeof(uint8_t));\n\n    if (fragment_len > FRAGMENT_MAX_PAYLOAD_SIZE) {\n        return -3;\n    }\n    \n    return processFirmwareFragment(fragment_offset, fragment_len, fragment_data);\n}\n\nuint8_t getFirmwareByte(uint32_t index) {\n    if (index < VEHICLE_FIRMWARE_SIZE) {\n        return g_firmwareBuffer[index];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_FIRMWARE_SIZE 0x10000 \n#define FRAGMENT_MAX_PAYLOAD_SIZE 256 \n\nstatic uint8_t g_firmwareBuffer[VEHICLE_FIRMWARE_SIZE];\n\nvoid initFirmwareBuffer() {\n    memset(g_firmwareBuffer, 0, VEHICLE_FIRMWARE_SIZE);\n}\n\nstatic int processFirmwareFragment(uint16_t fragment_offset, uint8_t fragment_len, const uint8_t* fragment_data) {\n    if (fragment_data == NULL || fragment_len == 0) {\n        return -1;\n    }\n\n    if ((uint32_t)fragment_offset + fragment_len > VEHICLE_FIRMWARE_SIZE) {\n        return -2;\n    }\n\n    for (uint8_t i = 0; i < fragment_len; ++i) {\n        g_firmwareBuffer[fragment_offset + i] = fragment_data[i];\n    }\n\n    return 0;\n}\n\nint handleFirmwareUpdateMessage(const uint8_t* message, uint16_t message_len) {\n    if (message == NULL || message_len < (1 + sizeof(uint16_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    uint8_t service_id = message[0];\n    if (service_id != 0x34) {\n        return -2;\n    }\n\n    uint16_t offset_idx = 1;\n    uint16_t fragment_offset = (message[offset_idx] << 8) | message[offset_idx+1];\n    \n    uint16_t len_idx = offset_idx + sizeof(uint16_t);\n    uint8_t fragment_len = message[len_idx];\n\n    const uint8_t* fragment_data = message + len_idx + sizeof(uint8_t);\n    uint16_t actual_data_in_msg_len = message_len - (len_idx + sizeof(uint8_t));\n\n    if (fragment_len > FRAGMENT_MAX_PAYLOAD_SIZE) {\n        return -3;\n    }\n    \n    if (fragment_len > actual_data_in_msg_len) { \n        return -4; \n    }\n\n    return processFirmwareFragment(fragment_offset, fragment_len, fragment_data);\n}\n\nuint8_t getFirmwareByte(uint32_t index) {\n    if (index < VEHICLE_FIRMWARE_SIZE) {\n        return g_firmwareBuffer[index];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n// Max number of distinct sensor data types\n#define MAX_SENSORS 4\n\n// Fixed size buffer for each sensor's aggregated data\n// This is intentionally smaller than MAX_TELEMETRY_PACKET_PAYLOAD\n#define SENSOR_DATA_BUFFER_SIZE 32\n\n// Maximum payload size for an incoming telemetry packet\n// This represents the maximum data that can be carried by the communication protocol.\n#define MAX_TELEMETRY_PACKET_PAYLOAD 64\n\n// Storage for sensor data. Each sensor has its own fixed-size buffer.\nstatic uint8_t g_sensorDataBuffers[MAX_SENSORS][SENSOR_DATA_BUFFER_SIZE];\n// Current valid length for each sensor's buffer\nstatic uint8_t g_sensorDataLengths[MAX_SENSORS];\n\n// Structure representing an incoming telemetry packet\ntypedef struct {\n    uint8_t  sensor_id;  // Identifier for the sensor (0 to MAX_SENSORS-1)\n    uint16_t data_len;   // Length of the data payload in this packet\n    uint8_t  data[MAX_TELEMETRY_PACKET_PAYLOAD]; // Raw data payload\n} TelemetryPacket;\n\n// Initialize sensor data buffers to zeros and lengths to zero\nvoid initSensorDataStorage() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        memset(g_sensorDataBuffers[i], 0, SENSOR_DATA_BUFFER_SIZE);\n        g_sensorDataLengths[i] = 0;\n    }\n}\n\n// Process an incoming telemetry packet\n// This function stores the sensor data into the respective buffer based on sensor_id.\nint processTelemetryPacket(const TelemetryPacket* packet) {\n    if (packet == NULL) {\n        return -1; // Invalid packet pointer\n    }\n\n    // 1. Validate sensor ID against the maximum number of sensors\n    if (packet->sensor_id >= MAX_SENSORS) {\n        return -2; // Invalid sensor ID, out of bounds for the array of buffers\n    }\n\n    // 2. Validate incoming data length against the packet's maximum allowed payload size.\n    // This check ensures the data doesn't exceed what the packet structure can hold.\n    if (packet->data_len > MAX_TELEMETRY_PACKET_PAYLOAD) {\n        return -3; // Data length exceeds the maximum payload defined for the packet format\n    }\n\n    // VULNERABILITY: Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-119)\n    // The 'packet->data_len' is checked against 'MAX_TELEMETRY_PACKET_PAYLOAD' (64 bytes), which is\n    // the maximum size the incoming packet *can* carry. However, the destination buffer\n    // 'g_sensorDataBuffers[packet->sensor_id]' is only 'SENSOR_DATA_BUFFER_SIZE' (32 bytes).\n    // If an attacker sends a 'data_len' value that is valid for the packet (e.g., 40 bytes),\n    // but larger than 'SENSOR_DATA_BUFFER_SIZE', the 'memcpy' will write beyond the bounds of\n    // the targeted sensor's buffer, potentially overwriting data in adjacent buffers\n    // or other critical memory regions.\n    memcpy(g_sensorDataBuffers[packet->sensor_id], packet->data, packet->data_len);\n    \n    // Update the stored length, note that it will be truncated if packet->data_len > 255,\n    // but the overflow happens during memcpy if packet->data_len > SENSOR_DATA_BUFFER_SIZE\n    g_sensorDataLengths[packet->sensor_id] = (uint8_t)packet->data_len;\n\n    return 0; // Success\n}\n\n// Dummy function to simulate receiving a raw data buffer from a communication interface.\n// In a real system, 'raw_data_buffer' would be parsed into a 'TelemetryPacket' structure.\nvoid receiveSensorData(const uint8_t* raw_data_buffer) {\n    processTelemetryPacket((const TelemetryPacket*)raw_data_buffer);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n// Max number of distinct sensor data types\n#define MAX_SENSORS 4\n\n// Fixed size buffer for each sensor's aggregated data\n// This is intentionally smaller than MAX_TELEMETRY_PACKET_PAYLOAD\n#define SENSOR_DATA_BUFFER_SIZE 32\n\n// Maximum payload size for an incoming telemetry packet\n// This represents the maximum data that can be carried by the communication protocol.\n#define MAX_TELEMETRY_PACKET_PAYLOAD 64\n\n// Storage for sensor data. Each sensor has its own fixed-size buffer.\nstatic uint8_t g_sensorDataBuffers[MAX_SENSORS][SENSOR_DATA_BUFFER_SIZE];\n// Current valid length for each sensor's buffer\nstatic uint8_t g_sensorDataLengths[MAX_SENSORS];\n\n// Structure representing an incoming telemetry packet\ntypedef struct {\n    uint8_t  sensor_id;  // Identifier for the sensor (0 to MAX_SENSORS-1)\n    uint16_t data_len;   // Length of the data payload in this packet\n    uint8_t  data[MAX_TELEMETRY_PACKET_PAYLOAD]; // Raw data payload\n} TelemetryPacket;\n\n// Initialize sensor data buffers to zeros and lengths to zero\nvoid initSensorDataStorage() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        memset(g_sensorDataBuffers[i], 0, SENSOR_DATA_BUFFER_SIZE);\n        g_sensorDataLengths[i] = 0;\n    }\n}\n\n// Process an incoming telemetry packet\n// This function stores the sensor data into the respective buffer based on sensor_id.\nint processTelemetryPacket(const TelemetryPacket* packet) {\n    if (packet == NULL) {\n        return -1; // Invalid packet pointer\n    }\n\n    // 1. Validate sensor ID against the maximum number of sensors\n    if (packet->sensor_id >= MAX_SENSORS) {\n        return -2; // Invalid sensor ID, out of bounds for the array of buffers\n    }\n\n    // 2. Validate incoming data length against the packet's maximum allowed payload size.\n    // This check ensures the data doesn't exceed what the packet structure can hold.\n    if (packet->data_len > MAX_TELEMETRY_PACKET_PAYLOAD) {\n        return -3; // Data length exceeds the maximum payload defined for the packet format\n    }\n\n    // FIX: Add a bounds check to ensure the incoming data length does not exceed\n    // the actual capacity of the destination buffer for the specific sensor.\n    if (packet->data_len > SENSOR_DATA_BUFFER_SIZE) {\n        // Option: Return an error indicating that the data is too large for this sensor's buffer.\n        // Alternatively, one could truncate the data, but returning an error is often safer.\n        return -4; // Data length too large for the specific sensor's buffer\n    }\n\n    memcpy(g_sensorDataBuffers[packet->sensor_id], packet->data, packet->data_len);\n    \n    // Update the stored length after successful copy.\n    g_sensorDataLengths[packet->sensor_id] = (uint8_t)packet->data_len;\n\n    return 0; // Success\n}\n\n// Dummy function to simulate receiving a raw data buffer from a communication interface.\n// In a real system, 'raw_data_buffer' would be parsed into a 'TelemetryPacket' structure.\nvoid receiveSensorData(const uint8_t* raw_data_buffer) {\n    processTelemetryPacket((const TelemetryPacket*)raw_data_buffer);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_BUFFER_SIZE 256\n#define MAX_TELEMETRY_PAYLOAD_LEN 8 \n\nstatic uint8_t g_telemetryDataBuffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_currentBufferWriteOffset = 0;\n\ntypedef enum {\n    TELEMETRY_TYPE_ENGINE_STATUS = 0,\n    TELEMETRY_TYPE_BATTERY_INFO,\n    TELEMETRY_TYPE_TIRE_PRESSURE,\n    TELEMETRY_TYPE_COUNT\n} TelemetryBlockType;\n\ntypedef struct {\n    uint8_t item_size;\n    uint8_t num_items;\n} TelemetryBlockMetadata;\n\nstatic const TelemetryBlockMetadata g_telemetryMetadata[TELEMETRY_TYPE_COUNT] = {\n    {10, 10}, \n    {5, 5},   \n    {8, 10}   \n};\n\nstatic uint16_t g_telemetryTypeBaseOffsets[TELEMETRY_TYPE_COUNT];\n\nvoid initTelemetrySystem() {\n    memset(g_telemetryDataBuffer, 0, TELEMETRY_BUFFER_SIZE);\n    g_currentBufferWriteOffset = 0;\n\n    uint16_t current_offset = 0;\n    for (int i = 0; i < TELEMETRY_TYPE_COUNT; ++i) {\n        g_telemetryTypeBaseOffsets[i] = current_offset;\n        current_offset += (uint16_t)g_telemetryMetadata[i].item_size * g_telemetryMetadata[i].num_items;\n    }\n    g_currentBufferWriteOffset = current_offset; \n}\n\nint updateTelemetryDataItem(TelemetryBlockType telemetry_type, uint8_t item_index, \n                            uint8_t update_offset, uint8_t data_len, const uint8_t* data_payload) {\n    \n    if (telemetry_type >= TELEMETRY_TYPE_COUNT || data_payload == NULL || data_len == 0) {\n        return -1;\n    }\n\n    if (item_index >= g_telemetryMetadata[telemetry_type].num_items) {\n        return -2;\n    }\n\n    if (data_len > MAX_TELEMETRY_PAYLOAD_LEN) {\n        return -3;\n    }\n\n    uint16_t item_base_addr = g_telemetryTypeBaseOffsets[telemetry_type] + \n                              (uint16_t)item_index * g_telemetryMetadata[telemetry_type].item_size;\n\n    uint16_t dest_offset = item_base_addr + update_offset;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_telemetryDataBuffer[dest_offset + i] = data_payload[i];\n    }\n\n    return 0;\n}\n\nvoid simulateCanTelemetryUpdate(TelemetryBlockType type, uint8_t index, uint8_t offset, uint8_t len, const uint8_t* data) {\n    updateTelemetryDataItem(type, index, offset, len, data);\n}\n\nuint8_t getTelemetryDataByte(uint16_t global_offset) {\n    if (global_offset < TELEMETRY_BUFFER_SIZE) {\n        return g_telemetryDataBuffer[global_offset];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_BUFFER_SIZE 256\n#define MAX_TELEMETRY_PAYLOAD_LEN 8 \n\nstatic uint8_t g_telemetryDataBuffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_currentBufferWriteOffset = 0;\n\ntypedef enum {\n    TELEMETRY_TYPE_ENGINE_STATUS = 0,\n    TELEMETRY_TYPE_BATTERY_INFO,\n    TELEMETRY_TYPE_TIRE_PRESSURE,\n    TELEMETRY_TYPE_COUNT\n} TelemetryBlockType;\n\ntypedef struct {\n    uint8_t item_size;\n    uint8_t num_items;\n} TelemetryBlockMetadata;\n\nstatic const TelemetryBlockMetadata g_telemetryMetadata[TELEMETRY_TYPE_COUNT] = {\n    {10, 10}, \n    {5, 5},   \n    {8, 10}   \n};\n\nstatic uint16_t g_telemetryTypeBaseOffsets[TELEMETRY_TYPE_COUNT];\n\nvoid initTelemetrySystem() {\n    memset(g_telemetryDataBuffer, 0, TELEMETRY_BUFFER_SIZE);\n    g_currentBufferWriteOffset = 0;\n\n    uint16_t current_offset = 0;\n    for (int i = 0; i < TELEMETRY_TYPE_COUNT; ++i) {\n        g_telemetryTypeBaseOffsets[i] = current_offset;\n        current_offset += (uint16_t)g_telemetryMetadata[i].item_size * g_telemetryMetadata[i].num_items;\n    }\n    g_currentBufferWriteOffset = current_offset;\n}\n\nint updateTelemetryDataItem(TelemetryBlockType telemetry_type, uint8_t item_index, \n                            uint8_t update_offset, uint8_t data_len, const uint8_t* data_payload) {\n    \n    if (telemetry_type >= TELEMETRY_TYPE_COUNT || data_payload == NULL || data_len == 0) {\n        return -1;\n    }\n\n    if (item_index >= g_telemetryMetadata[telemetry_type].num_items) {\n        return -2;\n    }\n\n    if (data_len > MAX_TELEMETRY_PAYLOAD_LEN) {\n        return -3;\n    }\n\n    uint16_t item_base_addr = g_telemetryTypeBaseOffsets[telemetry_type] + \n                              (uint16_t)item_index * g_telemetryMetadata[telemetry_type].item_size;\n\n    uint16_t dest_offset = item_base_addr + update_offset;\n    \n    if (update_offset >= g_telemetryMetadata[telemetry_type].item_size) {\n        return -4;\n    }\n\n    if ((uint16_t)update_offset + data_len > g_telemetryMetadata[telemetry_type].item_size ||\n        dest_offset + data_len > TELEMETRY_BUFFER_SIZE) {\n        return -5;\n    }\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_telemetryDataBuffer[dest_offset + i] = data_payload[i];\n    }\n\n    return 0;\n}\n\nvoid simulateCanTelemetryUpdate(TelemetryBlockType type, uint8_t index, uint8_t offset, uint8_t len, const uint8_t* data) {\n    updateTelemetryDataItem(type, index, offset, len, data);\n}\n\nuint8_t getTelemetryDataByte(uint16_t global_offset) {\n    if (global_offset < TELEMETRY_BUFFER_SIZE) {\n        return g_telemetryDataBuffer[global_offset];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define FIRMWARE_STAGING_BUFFER_SIZE 2048 \n#define MAX_FW_PACKAGE_SIZE 4096 \n#define MAX_FW_BLOCKS 16 \n\ntypedef struct {\n    uint16_t block_id;\n    uint16_t block_offset; \n    uint16_t block_length;\n} FirmwareBlockDescriptor;\n\ntypedef struct {\n    uint16_t total_data_length; \n    uint8_t num_blocks;\n} FirmwarePackageHeader;\n\nstatic uint8_t g_firmwareStagingBuffer[FIRMWARE_STAGING_BUFFER_SIZE];\nstatic uint16_t g_stagingWritePointer = 0; \n\nvoid initFirmwareStagingSystem() {\n    memset(g_firmwareStagingBuffer, 0, FIRMWARE_STAGING_BUFFER_SIZE);\n    g_stagingWritePointer = 0;\n}\n\nint processFirmwareUpdatePackage(const uint8_t* package_payload, uint16_t payload_len) {\n    if (package_payload == NULL || payload_len < sizeof(FirmwarePackageHeader)) {\n        return -1; \n    }\n\n    FirmwarePackageHeader header;\n    header.total_data_length = (uint16_t)(package_payload[0] << 8 | package_payload[1]);\n    header.num_blocks = package_payload[2];\n\n    if (payload_len < sizeof(FirmwarePackageHeader) + (header.num_blocks * sizeof(FirmwareBlockDescriptor))) {\n        return -2; \n    }\n    if (header.num_blocks > MAX_FW_BLOCKS) {\n        return -3; \n    }\n\n    uint16_t descriptor_offset = sizeof(FirmwarePackageHeader);\n    uint16_t data_offset = descriptor_offset + (header.num_blocks * sizeof(FirmwareBlockDescriptor));\n\n    if (data_offset + header.total_data_length > payload_len) {\n        return -4; \n    }\n\n    g_stagingWritePointer = 0; \n\n    for (uint8_t i = 0; i < header.num_blocks; ++i) {\n        uint16_t current_descriptor_pos = descriptor_offset + (i * sizeof(FirmwareBlockDescriptor));\n        if (current_descriptor_pos + sizeof(FirmwareBlockDescriptor) > payload_len) {\n            return -5; \n        }\n\n        FirmwareBlockDescriptor block_desc;\n        block_desc.block_id = (uint16_t)(package_payload[current_descriptor_pos] << 8 | package_payload[current_descriptor_pos + 1]);\n        block_desc.block_offset = (uint16_t)(package_payload[current_descriptor_pos + 2] << 8 | package_payload[current_descriptor_pos + 3]);\n        block_desc.block_length = (uint16_t)(package_payload[current_descriptor_pos + 4] << 8 | package_payload[current_descriptor_pos + 5]);\n\n        if (block_desc.block_offset + block_desc.block_length > header.total_data_length) {\n            return -6; \n        }\n        if (data_offset + block_desc.block_offset + block_desc.block_length > payload_len) {\n            return -7; \n        }\n\n        for (uint16_t j = 0; j < block_desc.block_length; ++j) {\n            g_firmwareStagingBuffer[g_stagingWritePointer] = package_payload[data_offset + block_desc.block_offset + j];\n            g_stagingWritePointer++;\n        }\n    }\n\n    return 0; \n}\n\nvoid receiveFirmwarePackage(const uint8_t* data, uint16_t length) {\n    initFirmwareStagingSystem();\n    processFirmwareUpdatePackage(data, length);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define FIRMWARE_STAGING_BUFFER_SIZE 2048 \n#define MAX_FW_PACKAGE_SIZE 4096 \n#define MAX_FW_BLOCKS 16 \n\ntypedef struct {\n    uint16_t block_id;\n    uint16_t block_offset; \n    uint16_t block_length;\n} FirmwareBlockDescriptor;\n\ntypedef struct {\n    uint16_t total_data_length; \n    uint8_t num_blocks;\n} FirmwarePackageHeader;\n\nstatic uint8_t g_firmwareStagingBuffer[FIRMWARE_STAGING_BUFFER_SIZE];\nstatic uint16_t g_stagingWritePointer = 0; \n\nvoid initFirmwareStagingSystem() {\n    memset(g_firmwareStagingBuffer, 0, FIRMWARE_STAGING_BUFFER_SIZE);\n    g_stagingWritePointer = 0;\n}\n\nint processFirmwareUpdatePackage(const uint8_t* package_payload, uint16_t payload_len) {\n    if (package_payload == NULL || payload_len < sizeof(FirmwarePackageHeader)) {\n        return -1; \n    }\n\n    FirmwarePackageHeader header;\n    header.total_data_length = (uint16_t)(package_payload[0] << 8 | package_payload[1]);\n    header.num_blocks = package_payload[2];\n\n    if (payload_len < sizeof(FirmwarePackageHeader) + (header.num_blocks * sizeof(FirmwareBlockDescriptor))) {\n        return -2; \n    }\n    if (header.num_blocks > MAX_FW_BLOCKS) {\n        return -3; \n    }\n\n    uint16_t descriptor_offset = sizeof(FirmwarePackageHeader);\n    uint16_t data_offset = descriptor_offset + (header.num_blocks * sizeof(FirmwareBlockDescriptor));\n\n    if (data_offset + header.total_data_length > payload_len) {\n        return -4; \n    }\n\n    g_stagingWritePointer = 0; \n\n    for (uint8_t i = 0; i < header.num_blocks; ++i) {\n        uint16_t current_descriptor_pos = descriptor_offset + (i * sizeof(FirmwareBlockDescriptor));\n        if (current_descriptor_pos + sizeof(FirmwareBlockDescriptor) > payload_len) {\n            return -5; \n        }\n\n        FirmwareBlockDescriptor block_desc;\n        block_desc.block_id = (uint16_t)(package_payload[current_descriptor_pos] << 8 | package_payload[current_descriptor_pos + 1]);\n        block_desc.block_offset = (uint16_t)(package_payload[current_descriptor_pos + 2] << 8 | package_payload[current_descriptor_pos + 3]);\n        block_desc.block_length = (uint16_t)(package_payload[current_descriptor_pos + 4] << 8 | package_payload[current_descriptor_pos + 5]);\n\n        if (block_desc.block_offset + block_desc.block_length > header.total_data_length) {\n            return -6; \n        }\n        if (data_offset + block_desc.block_offset + block_desc.block_length > payload_len) {\n            return -7; \n        }\n\n        if (g_stagingWritePointer + block_desc.block_length > FIRMWARE_STAGING_BUFFER_SIZE) {\n            return -8;\n        }\n\n        for (uint16_t j = 0; j < block_desc.block_length; ++j) {\n            g_firmwareStagingBuffer[g_stagingWritePointer] = package_payload[data_offset + block_desc.block_offset + j];\n            g_stagingWritePointer++;\n        }\n    }\n\n    return 0; \n}\n\nvoid receiveFirmwarePackage(const uint8_t* data, uint16_t length) {\n    initFirmwareStagingSystem();\n    processFirmwareUpdatePackage(data, length);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define ENGINE_PARAM_MAP_SIZE 256\n#define MAX_PARAM_UPDATE_LENGTH 64\n\nstatic uint8_t g_engineParamMap[ENGINE_PARAM_MAP_SIZE];\n\nvoid initializeEngineParameters() {\n    memset(g_engineParamMap, 0x00, ENGINE_PARAM_MAP_SIZE);\n    for (uint16_t i = 0; i < ENGINE_PARAM_MAP_SIZE; ++i) {\n        g_engineParamMap[i] = (uint8_t)(i % 0xFF);\n    }\n}\n\nint updateEngineParameterSegment(uint8_t param_offset, const uint8_t* update_data, uint8_t update_len) {\n    if (update_data == NULL || update_len == 0) {\n        return -1;\n    }\n\n    if (param_offset >= ENGINE_PARAM_MAP_SIZE) {\n        return -2;\n    }\n\n    if (update_len > MAX_PARAM_UPDATE_LENGTH) {\n        return -3;\n    }\n\n    for (uint8_t i = 0; i < update_len; ++i) {\n        g_engineParamMap[param_offset + i] = update_data[i];\n    }\n\n    return 0;\n}\n\nvoid handleParamUpdateMessage(uint8_t offset, const uint8_t* data, uint8_t len) {\n    updateEngineParameterSegment(offset, data, len);\n}\n\nuint8_t getEngineParameter(uint8_t index) {\n    if (index < ENGINE_PARAM_MAP_SIZE) {\n        return g_engineParamMap[index];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define ENGINE_PARAM_MAP_SIZE 256\n#define MAX_PARAM_UPDATE_LENGTH 64\n\nstatic uint8_t g_engineParamMap[ENGINE_PARAM_MAP_SIZE];\n\nvoid initializeEngineParameters() {\n    memset(g_engineParamMap, 0x00, ENGINE_PARAM_MAP_SIZE);\n    for (uint16_t i = 0; i < ENGINE_PARAM_MAP_SIZE; ++i) {\n        g_engineParamMap[i] = (uint8_t)(i % 0xFF);\n    }\n}\n\nint updateEngineParameterSegment(uint8_t param_offset, const uint8_t* update_data, uint8_t update_len) {\n    if (update_data == NULL || update_len == 0) {\n        return -1;\n    }\n\n    if (param_offset >= ENGINE_PARAM_MAP_SIZE) {\n        return -2;\n    }\n\n    if (update_len > MAX_PARAM_UPDATE_LENGTH) {\n        return -3;\n    }\n\n    if ((uint16_t)param_offset + update_len > ENGINE_PARAM_MAP_SIZE) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < update_len; ++i) {\n        g_engineParamMap[param_offset + i] = update_data[i];\n    }\n\n    return 0;\n}\n\nvoid handleParamUpdateMessage(uint8_t offset, const uint8_t* data, uint8_t len) {\n    updateEngineParameterSegment(offset, data, len);\n}\n\nuint8_t getEngineParameter(uint8_t index) {\n    if (index < ENGINE_PARAM_MAP_SIZE) {\n        return g_engineParamMap[index];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n// Configuration for the telemetry system\n#define TELEMETRY_BUFFER_SIZE 128 // Small buffer to easily demonstrate overflow\n#define MAX_DIAG_DATA_LENGTH 15   // Max length for custom diagnostic data payload\n\n// Sensor Type Definitions\n#define SENSOR_TYPE_TEMPERATURE     0x01 // 1 byte value\n#define SENSOR_TYPE_PRESSURE        0x02 // 2 bytes value\n#define SENSOR_TYPE_RPM             0x03 // 4 bytes value\n#define SENSOR_TYPE_CUSTOM_DIAG     0x04 // Variable length (1 byte length + up to MAX_DIAG_DATA_LENGTH bytes data)\n#define SENSOR_TYPE_IGNITION_STATUS 0x05 // 1 byte value for simplicity of packing\n\n// Global telemetry buffer and current write offset\nstatic uint8_t g_telemetry_data_buffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_current_telemetry_write_offset;\n\n// Function to initialize the telemetry buffer\nvoid initializeTelemetryBuffer() {\n    memset(g_telemetry_data_buffer, 0, TELEMETRY_BUFFER_SIZE);\n    g_current_telemetry_write_offset = 0;\n}\n\n// Function to pack sensor data into the global telemetry buffer.\n// Returns 0 on success, or a negative value on error.\n// Vulnerability: Lack of comprehensive bounds checking before and during data writes,\n// especially for SENSOR_TYPE_CUSTOM_DIAG, can lead to out-of-bounds writes.\nint packSensorDataToBuffer(uint8_t sensor_type, uint32_t sensor_value) {\n    uint16_t current_pos = g_current_telemetry_write_offset;\n    uint8_t actual_diag_len = 0;\n\n    // First byte is always sensor type ID\n    if (current_pos >= TELEMETRY_BUFFER_SIZE) {\n        return -1; // Buffer already full before writing type ID\n    }\n    g_telemetry_data_buffer[current_pos++] = sensor_type; // Write type ID (1 byte)\n\n    switch (sensor_type) {\n        case SENSOR_TYPE_TEMPERATURE: // 1 byte value\n            // Vulnerability: If current_pos is now TELEMETRY_BUFFER_SIZE - 1, this writes OOB\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value & 0xFF);\n            break;\n        case SENSOR_TYPE_PRESSURE: // 2 byte value\n            // Vulnerability: If current_pos is now TELEMETRY_BUFFER_SIZE - 1 or -2, this writes OOB\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)((sensor_value >> 8) & 0xFF);\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value & 0xFF);\n            break;\n        case SENSOR_TYPE_RPM: // 4 byte value\n            // Vulnerability: If current_pos is now TELEMETRY_BUFFER_SIZE - 1, -2, -3 or -4, this writes OOB\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)((sensor_value >> 24) & 0xFF);\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)((sensor_value >> 16) & 0xFF);\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)((sensor_value >> 8) & 0xFF);\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value & 0xFF);\n            break;\n        case SENSOR_TYPE_CUSTOM_DIAG: // Variable length: 1 byte for length + data bytes\n            actual_diag_len = (uint8_t)(sensor_value & 0x0F); // Extract length from lower 4 bits\n            if (actual_diag_len > MAX_DIAG_DATA_LENGTH) {\n                actual_diag_len = MAX_DIAG_DATA_LENGTH;\n            }\n\n            // Vulnerability: If current_pos is TELEMETRY_BUFFER_SIZE - 1, this writes OOB\n            g_telemetry_data_buffer[current_pos++] = actual_diag_len; // Write length byte (1 byte)\n\n            // Vulnerability: No bounds check within this loop.\n            // (current_pos + i) can easily exceed TELEMETRY_BUFFER_SIZE if current_pos\n            // was already near the boundary before this loop began, and actual_diag_len is large.\n            for (int i = 0; i < actual_diag_len; ++i) {\n                g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value >> (8 * (actual_diag_len - 1 - i)));\n            }\n            break;\n        case SENSOR_TYPE_IGNITION_STATUS: // 1 byte value\n            // Vulnerability: If current_pos is now TELEMETRY_BUFFER_SIZE - 1, this writes OOB\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value & 0x01);\n            break;\n        default:\n            // Revert the written type ID as this sensor type is unknown\n            g_current_telemetry_write_offset = current_pos - 1;\n            return -2; // Unknown sensor type\n    }\n    \n    g_current_telemetry_write_offset = current_pos;\n    return 0; // Success (return 0 or actual bytes written if needed)\n}\n\n// Main function to simulate telemetry data collection and transmission cycle\nvoid prepareAndTransmitSensorData() {\n    initializeTelemetryBuffer();\n\n    // Populate with some initial data (10 bytes total)\n    packSensorDataToBuffer(SENSOR_TYPE_TEMPERATURE, 75); // 1 type + 1 value = 2 bytes. Offset=2\n    packSensorDataToBuffer(SENSOR_TYPE_PRESSURE, 2560);  // 1 type + 2 value = 3 bytes. Offset=5\n    packSensorDataToBuffer(SENSOR_TYPE_RPM, 3500);       // 1 type + 4 value = 5 bytes. Offset=10\n\n    // Fill the buffer until there are exactly 10 bytes remaining.\n    // A CUSTOM_DIAG item with MAX_DIAG_DATA_LENGTH (15) requires 1+1+15=17 bytes.\n    // If only 10 bytes are remaining, it will write 7 bytes OOB.\n    while (g_current_telemetry_write_offset < TELEMETRY_BUFFER_SIZE - 10) {\n        packSensorDataToBuffer(SENSOR_TYPE_TEMPERATURE, 20); // Each adds 2 bytes (1 type + 1 value)\n    }\n    // At this point, g_current_telemetry_write_offset should be TELEMETRY_BUFFER_SIZE - 10 (i.e., 118)\n\n    // This call attempts to write 17 bytes (1 type + 1 length + 15 data) when only 10 bytes remain.\n    // The 'for' loop inside SENSOR_TYPE_CUSTOM_DIAG in packSensorDataToBuffer will cause an OOB write.\n    packSensorDataToBuffer(SENSOR_TYPE_CUSTOM_DIAG, MAX_DIAG_DATA_LENGTH); // Attempt to pack 15 bytes of diagnostic data\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n// Configuration for the telemetry system\n#define TELEMETRY_BUFFER_SIZE 128 // Small buffer to easily demonstrate overflow\n#define MAX_DIAG_DATA_LENGTH 15   // Max length for custom diagnostic data payload\n\n// Sensor Type Definitions\n#define SENSOR_TYPE_TEMPERATURE     0x01 // 1 byte value\n#define SENSOR_TYPE_PRESSURE        0x02 // 2 bytes value\n#define SENSOR_TYPE_RPM             0x03 // 4 bytes value\n#define SENSOR_TYPE_CUSTOM_DIAG     0x04 // Variable length (1 byte length + up to MAX_DIAG_DATA_LENGTH bytes data)\n#define SENSOR_TYPE_IGNITION_STATUS 0x05 // 1 byte value for simplicity of packing\n\n// Global telemetry buffer and current write offset\nstatic uint8_t g_telemetry_data_buffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_current_telemetry_write_offset;\n\n// Function to initialize the telemetry buffer\nvoid initializeTelemetryBuffer() {\n    memset(g_telemetry_data_buffer, 0, TELEMETRY_BUFFER_SIZE);\n    g_current_telemetry_write_offset = 0;\n}\n\n// Function to pack sensor data into the global telemetry buffer.\n// Returns 0 on success, or a negative value on error.\n// Fix: Comprehensive bounds checking is performed before any data is written for an item,\n// ensuring that the entire item (type ID + payload) fits within the buffer.\nint packSensorDataToBuffer(uint8_t sensor_type, uint32_t sensor_value) {\n    uint16_t current_pos = g_current_telemetry_write_offset;\n    uint8_t bytes_needed_for_payload = 0; // Bytes for the value data, not including type byte\n    uint8_t actual_diag_len = 0;\n\n    // Calculate bytes needed for the payload data based on sensor type\n    switch (sensor_type) {\n        case SENSOR_TYPE_TEMPERATURE:\n            bytes_needed_for_payload = 1;\n            break;\n        case SENSOR_TYPE_PRESSURE:\n            bytes_needed_for_payload = 2;\n            break;\n        case SENSOR_TYPE_RPM:\n            bytes_needed_for_payload = 4;\n            break;\n        case SENSOR_TYPE_CUSTOM_DIAG:\n            actual_diag_len = (uint8_t)(sensor_value & 0x0F);\n            if (actual_diag_len > MAX_DIAG_DATA_LENGTH) {\n                actual_diag_len = MAX_DIAG_DATA_LENGTH;\n            }\n            bytes_needed_for_payload = 1 + actual_diag_len; // 1 for length byte + data bytes\n            break;\n        case SENSOR_TYPE_IGNITION_STATUS:\n            bytes_needed_for_payload = 1;\n            break;\n        default:\n            return -2; // Unknown sensor type\n    }\n\n    // Comprehensive bounds check: Ensure there is enough space for the type ID AND the entire payload\n    if (current_pos + 1 + bytes_needed_for_payload > TELEMETRY_BUFFER_SIZE) {\n        return -1; // Not enough space for this telemetry item\n    }\n\n    // Now it's safe to write the type ID and payload\n    g_telemetry_data_buffer[current_pos++] = sensor_type; // Write type ID\n\n    switch (sensor_type) {\n        case SENSOR_TYPE_TEMPERATURE:\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value & 0xFF);\n            break;\n        case SENSOR_TYPE_PRESSURE:\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)((sensor_value >> 8) & 0xFF);\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value & 0xFF);\n            break;\n        case SENSOR_TYPE_RPM:\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)((sensor_value >> 24) & 0xFF);\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)((sensor_value >> 16) & 0xFF);\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)((sensor_value >> 8) & 0xFF);\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value & 0xFF);\n            break;\n        case SENSOR_TYPE_CUSTOM_DIAG:\n            // actual_diag_len was already calculated\n            g_telemetry_data_buffer[current_pos++] = actual_diag_len; // Write length byte\n            for (int i = 0; i < actual_diag_len; ++i) {\n                // All writes in this loop are now guaranteed to be in bounds due to the earlier check\n                g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value >> (8 * (actual_diag_len - 1 - i)));\n            }\n            break;\n        case SENSOR_TYPE_IGNITION_STATUS:\n            g_telemetry_data_buffer[current_pos++] = (uint8_t)(sensor_value & 0x01);\n            break;\n        default:\n            // This case should ideally not be reached due to the initial check for unknown type.\n            // If it is, something else is wrong, or the type changed between checks.\n            // Defensive coding: revert the type ID write.\n            g_current_telemetry_write_offset = current_pos - 1;\n            return -3; // Internal error or race condition\n    }\n    \n    g_current_telemetry_write_offset = current_pos;\n    return 0; // Success\n}\n\n// Main function to simulate telemetry data collection and transmission cycle\nvoid prepareAndTransmitSensorData() {\n    initializeTelemetryBuffer();\n\n    // Populate with some initial data\n    packSensorDataToBuffer(SENSOR_TYPE_TEMPERATURE, 75);\n    packSensorDataToBuffer(SENSOR_TYPE_PRESSURE, 2560);\n    packSensorDataToBuffer(SENSOR_TYPE_RPM, 3500);\n\n    // Fill the buffer until there are exactly 10 bytes remaining.\n    // A CUSTOM_DIAG item with MAX_DIAG_DATA_LENGTH (15) requires 1+1+15=17 bytes.\n    // If only 10 bytes are remaining, the fix will prevent the write.\n    while (g_current_telemetry_write_offset < TELEMETRY_BUFFER_SIZE - 10) {\n        packSensorDataToBuffer(SENSOR_TYPE_TEMPERATURE, 20);\n    }\n\n    // This call attempts to write 17 bytes when only 10 bytes remain.\n    // The fixed packSensorDataToBuffer will now return an error (-1) and not write out of bounds.\n    int result = packSensorDataToBuffer(SENSOR_TYPE_CUSTOM_DIAG, MAX_DIAG_DATA_LENGTH);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_DIAG_LOG_BUFFER_SIZE 256\n#define DIAG_RECORD_MAX_DATA_LEN 100 \n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t flags;\n    uint8_t data_len; \n} DiagLogRecordHeader;\n\nstatic uint8_t g_diagLogBuffer[VEHICLE_DIAG_LOG_BUFFER_SIZE];\nstatic uint16_t g_logWriteCursor = 0; \n\nvoid initDiagLogger() {\n    memset(g_diagLogBuffer, 0, VEHICLE_DIAG_LOG_BUFFER_SIZE);\n    g_logWriteCursor = 0;\n}\n\nint storeDiagEvent(const uint8_t* record_payload, uint16_t payload_total_len) {\n    if (record_payload == NULL || payload_total_len < sizeof(DiagLogRecordHeader)) {\n        return -1;\n    }\n\n    uint8_t record_type = record_payload[0];\n    uint8_t flags = record_payload[1];\n    uint8_t data_len = record_payload[2];\n\n    if (data_len > DIAG_RECORD_MAX_DATA_LEN) {\n        return -2;\n    }\n    \n    uint16_t current_record_size = sizeof(DiagLogRecordHeader) + data_len;\n\n    if (payload_total_len < current_record_size) {\n        return -3;\n    }\n\n    uint16_t effective_write_pos = g_logWriteCursor;\n\n    if (effective_write_pos + current_record_size > VEHICLE_DIAG_LOG_BUFFER_SIZE) { \n        effective_write_pos = 0;\n        if (current_record_size > VEHICLE_DIAG_LOG_BUFFER_SIZE) {\n            return -4;\n        }\n    }\n\n    g_diagLogBuffer[effective_write_pos++] = record_type;\n    g_diagLogBuffer[effective_write_pos++] = flags;\n    g_diagLogBuffer[effective_write_pos++] = data_len;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_diagLogBuffer[effective_write_pos + i] = record_payload[sizeof(DiagLogRecordHeader) + i];\n    }\n\n    g_logWriteCursor = (effective_write_pos + data_len) % VEHICLE_DIAG_LOG_BUFFER_SIZE;\n\n    return 0;\n}\n\nvoid receiveNewDiagEventMessage(const uint8_t* msg, uint16_t len) {\n    if (g_logWriteCursor == 0) {\n        initDiagLogger();\n    }\n    storeDiagEvent(msg, len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_DIAG_LOG_BUFFER_SIZE 256\n#define DIAG_RECORD_MAX_DATA_LEN 100 \n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t flags;\n    uint8_t data_len; \n} DiagLogRecordHeader;\n\nstatic uint8_t g_diagLogBuffer[VEHICLE_DIAG_LOG_BUFFER_SIZE];\nstatic uint16_t g_logWriteCursor = 0; \n\nvoid initDiagLogger() {\n    memset(g_diagLogBuffer, 0, VEHICLE_DIAG_LOG_BUFFER_SIZE);\n    g_logWriteCursor = 0;\n}\n\nint storeDiagEvent(const uint8_t* record_payload, uint16_t payload_total_len) {\n    if (record_payload == NULL || payload_total_len < sizeof(DiagLogRecordHeader)) {\n        return -1;\n    }\n\n    uint8_t record_type = record_payload[0];\n    uint8_t flags = record_payload[1];\n    uint8_t data_len = record_payload[2];\n\n    if (data_len > DIAG_RECORD_MAX_DATA_LEN) {\n        return -2;\n    }\n    \n    uint16_t current_record_size = sizeof(DiagLogRecordHeader) + data_len;\n\n    if (payload_total_len < current_record_size) {\n        return -3;\n    }\n\n    uint16_t effective_write_pos = g_logWriteCursor;\n\n    if (effective_write_pos + current_record_size >= VEHICLE_DIAG_LOG_BUFFER_SIZE) { \n        effective_write_pos = 0;\n        if (current_record_size > VEHICLE_DIAG_LOG_BUFFER_SIZE) {\n            return -4;\n        }\n    }\n\n    g_diagLogBuffer[effective_write_pos++] = record_type;\n    g_diagLogBuffer[effective_write_pos++] = flags;\n    g_diagLogBuffer[effective_write_pos++] = data_len;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_diagLogBuffer[effective_write_pos + i] = record_payload[sizeof(DiagLogRecordHeader) + i];\n    }\n\n    g_logWriteCursor = (effective_write_pos + data_len) % VEHICLE_DIAG_LOG_BUFFER_SIZE;\n\n    return 0;\n}\n\nvoid receiveNewDiagEventMessage(const uint8_t* msg, uint16_t len) {\n    if (g_logWriteCursor == 0) {\n        initDiagLogger();\n    }\n    storeDiagEvent(msg, len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define PARAM_NAME_MAX_LEN          16\n#define PARAM_VALUE_BUFFER_SIZE     32\n\n#define PROTOCOL_MAX_VALUE_LEN      60\n\ntypedef enum {\n    PARAM_TYPE_UINT8,\n    PARAM_TYPE_UINT16,\n    PARAM_TYPE_STRING,\n    PARAM_TYPE_BYTE_ARRAY\n} ParameterType;\n\ntypedef struct {\n    char name[PARAM_NAME_MAX_LEN];\n    ParameterType type;\n    uint8_t value_len;\n    union {\n        uint8_t  u8_val;\n        uint16_t u16_val;\n        char     str_val[PARAM_VALUE_BUFFER_SIZE];\n        uint8_t  byte_array_val[PARAM_VALUE_BUFFER_SIZE];\n    } value;\n} VehicleParameter;\n\nstatic uint8_t g_message_rx_buffer[256];\n\nstatic uint8_t get_byte_from_stream(const uint8_t* stream_data, uint32_t* offset, uint32_t total_length) {\n    if (stream_data == NULL || *offset >= total_length) {\n        return 0;\n    }\n    return stream_data[(*offset)++];\n}\n\nint parseVehicleParameter(const uint8_t* raw_message_stream, uint32_t stream_total_len, VehicleParameter* param_out) {\n    uint32_t current_stream_pos = 0;\n\n    if (raw_message_stream == NULL || param_out == NULL || stream_total_len < (1 + 1 + 1)) {\n        return -1;\n    }\n\n    memset(param_out, 0, sizeof(VehicleParameter));\n\n    if (current_stream_pos + 1 > stream_total_len) return -2;\n    uint8_t name_len = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n    \n    if (name_len == 0 || name_len >= PARAM_NAME_MAX_LEN) {\n        return -3;\n    }\n\n    if (current_stream_pos + name_len > stream_total_len) {\n        return -4;\n    }\n    for (int i = 0; i < name_len; ++i) {\n        param_out->name[i] = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n    }\n    param_out->name[name_len] = '\\0';\n\n    if (current_stream_pos + 1 > stream_total_len) return -5;\n    param_out->type = (ParameterType)get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n\n    switch (param_out->type) {\n        case PARAM_TYPE_UINT8:\n            if (current_stream_pos + sizeof(uint8_t) > stream_total_len) return -6;\n            param_out->value.u8_val = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n            param_out->value_len = sizeof(uint8_t);\n            break;\n        case PARAM_TYPE_UINT16:\n            if (current_stream_pos + sizeof(uint16_t) > stream_total_len) return -6;\n            param_out->value.u16_val = (uint16_t)((get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len) << 8) |\n                                                   get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len));\n            param_out->value_len = sizeof(uint16_t);\n            break;\n        case PARAM_TYPE_STRING:\n        case PARAM_TYPE_BYTE_ARRAY:\n            if (current_stream_pos + 1 > stream_total_len) return -6;\n            uint8_t declared_value_len = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n            \n            param_out->value_len = declared_value_len;\n\n            if (declared_value_len > PROTOCOL_MAX_VALUE_LEN) {\n                return -7;\n            }\n            \n            if (current_stream_pos + declared_value_len > stream_total_len) {\n                return -8;\n            }\n\n            for (int i = 0; i < declared_value_len; ++i) {\n                if (param_out->type == PARAM_TYPE_STRING) {\n                    param_out->value.str_val[i] = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n                } else {\n                    param_out->value.byte_array_val[i] = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n                }\n            }\n            if (param_out->type == PARAM_TYPE_STRING) {\n                param_out->value.str_val[declared_value_len] = '\\0';\n            }\n            break;\n        default:\n            return -9;\n    }\n\n    return current_stream_pos;\n}\n\nvoid simulateConfigUpdate() {\n    uint8_t malicious_message_data[51];\n    memset(malicious_message_data, 0, sizeof(malicious_message_data));\n\n    uint32_t offset = 0;\n    malicious_message_data[offset++] = strlen(\"SensorSetting\");\n    memcpy(malicious_message_data + offset, \"SensorSetting\", strlen(\"SensorSetting\"));\n    offset += strlen(\"SensorSetting\");\n    malicious_message_data[offset++] = PARAM_TYPE_STRING;\n    malicious_message_data[offset++] = 35;\n    for (int i = 0; i < 35; ++i) {\n        malicious_message_data[offset++] = 'A';\n    }\n\n    VehicleParameter param;\n    (void)parseVehicleParameter(malicious_message_data, sizeof(malicious_message_data), &param);\n}", "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define PARAM_NAME_MAX_LEN          16\n#define PARAM_VALUE_BUFFER_SIZE     32\n\n#define PROTOCOL_MAX_VALUE_LEN      60\n\ntypedef enum {\n    PARAM_TYPE_UINT8,\n    PARAM_TYPE_UINT16,\n    PARAM_TYPE_STRING,\n    PARAM_TYPE_BYTE_ARRAY\n} ParameterType;\n\ntypedef struct {\n    char name[PARAM_NAME_MAX_LEN];\n    ParameterType type;\n    uint8_t value_len;\n    union {\n        uint8_t  u8_val;\n        uint16_t u16_val;\n        char     str_val[PARAM_VALUE_BUFFER_SIZE];\n        uint8_t  byte_array_val[PARAM_VALUE_BUFFER_SIZE];\n    } value;\n} VehicleParameter;\n\nstatic uint8_t g_message_rx_buffer[256];\n\nstatic uint8_t get_byte_from_stream(const uint8_t* stream_data, uint32_t* offset, uint32_t total_length) {\n    if (stream_data == NULL || *offset >= total_length) {\n        return 0;\n    }\n    return stream_data[(*offset)++];\n}\n\nint parseVehicleParameter(const uint8_t* raw_message_stream, uint32_t stream_total_len, VehicleParameter* param_out) {\n    uint32_t current_stream_pos = 0;\n\n    if (raw_message_stream == NULL || param_out == NULL || stream_total_len < (1 + 1 + 1)) {\n        return -1;\n    }\n\n    memset(param_out, 0, sizeof(VehicleParameter));\n\n    if (current_stream_pos + 1 > stream_total_len) return -2;\n    uint8_t name_len = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n    \n    if (name_len == 0 || name_len >= PARAM_NAME_MAX_LEN) {\n        return -3;\n    }\n\n    if (current_stream_pos + name_len > stream_total_len) {\n        return -4;\n    }\n    for (int i = 0; i < name_len; ++i) {\n        param_out->name[i] = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n    }\n    param_out->name[name_len] = '\\0';\n\n    if (current_stream_pos + 1 > stream_total_len) return -5;\n    param_out->type = (ParameterType)get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n\n    switch (param_out->type) {\n        case PARAM_TYPE_UINT8:\n            if (current_stream_pos + sizeof(uint8_t) > stream_total_len) return -6;\n            param_out->value.u8_val = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n            param_out->value_len = sizeof(uint8_t);\n            break;\n        case PARAM_TYPE_UINT16:\n            if (current_stream_pos + sizeof(uint16_t) > stream_total_len) return -6;\n            param_out->value.u16_val = (uint16_t)((get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len) << 8) |\n                                                   get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len));\n            param_out->value_len = sizeof(uint16_t);\n            break;\n        case PARAM_TYPE_STRING:\n        case PARAM_TYPE_BYTE_ARRAY:\n            if (current_stream_pos + 1 > stream_total_len) return -6;\n            uint8_t declared_value_len = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n            \n            if (declared_value_len > PROTOCOL_MAX_VALUE_LEN) {\n                return -7;\n            }\n            \n            if (current_stream_pos + declared_value_len > stream_total_len) {\n                return -8;\n            }\n\n            uint8_t bytes_to_copy = declared_value_len;\n            if (bytes_to_copy > PARAM_VALUE_BUFFER_SIZE) {\n                bytes_to_copy = PARAM_VALUE_BUFFER_SIZE;\n            }\n            param_out->value_len = bytes_to_copy;\n\n            for (int i = 0; i < bytes_to_copy; ++i) {\n                if (param_out->type == PARAM_TYPE_STRING) {\n                    param_out->value.str_val[i] = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n                } else {\n                    param_out->value.byte_array_val[i] = get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n                }\n            }\n            for (int i = bytes_to_copy; i < declared_value_len; ++i) {\n                get_byte_from_stream(raw_message_stream, &current_stream_pos, stream_total_len);\n            }\n\n            if (param_out->type == PARAM_TYPE_STRING) {\n                if (bytes_to_copy < PARAM_VALUE_BUFFER_SIZE) {\n                    param_out->value.str_val[bytes_to_copy] = '\\0';\n                } else {\n                    param_out->value.str_val[PARAM_VALUE_BUFFER_SIZE - 1] = '\\0';\n                    param_out->value_len = PARAM_VALUE_BUFFER_SIZE - 1;\n                }\n            }\n            break;\n        default:\n            return -9;\n    }\n\n    return current_stream_pos;\n}\n\nvoid simulateConfigUpdate() {\n    uint8_t malicious_message_data[51];\n    memset(malicious_message_data, 0, sizeof(malicious_message_data));\n\n    uint32_t offset = 0;\n    malicious_message_data[offset++] = strlen(\"SensorSetting\");\n    memcpy(malicious_message_data + offset, \"SensorSetting\", strlen(\"SensorSetting\"));\n    offset += strlen(\"SensorSetting\");\n    malicious_message_data[offset++] = PARAM_TYPE_STRING;\n    malicious_message_data[offset++] = 35;\n    for (int i = 0; i < 35; ++i) {\n        malicious_message_data[offset++] = 'A';\n    }\n\n    VehicleParameter param;\n    (void)parseVehicleParameter(malicious_message_data, sizeof(malicious_message_data), &param);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 256\n#define MAX_COMMAND_DATA_SIZE 128\n#define MAX_COMMANDS_PER_PACKET 8\n\nstatic uint8_t g_vehicleConfiguration[VEHICLE_CONFIG_BUFFER_SIZE];\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t target_offset;\n    uint8_t data_length;\n} ConfigCommandHeader;\n\nvoid initVehicleConfiguration() {\n    memset(g_vehicleConfiguration, 0, VEHICLE_CONFIG_BUFFER_SIZE);\n}\n\nint processConfigCommands(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len < sizeof(uint8_t)) {\n        return -1;\n    }\n\n    uint8_t num_commands = packet_data[0];\n    uint16_t current_read_offset = sizeof(uint8_t);\n\n    if (num_commands > MAX_COMMANDS_PER_PACKET) {\n        return -2;\n    }\n\n    for (uint8_t i = 0; i < num_commands; ++i) {\n        if (current_read_offset + sizeof(ConfigCommandHeader) > packet_len) {\n            return -3;\n        }\n\n        uint8_t command_id = packet_data[current_read_offset];\n        uint8_t target_offset = packet_data[current_read_offset + 1];\n        uint8_t data_length = packet_data[current_read_offset + 2];\n        current_read_offset += sizeof(ConfigCommandHeader);\n\n        if (data_length > MAX_COMMAND_DATA_SIZE) {\n            return -4;\n        }\n\n        if (current_read_offset + data_length > packet_len) {\n            return -5;\n        }\n\n        for (uint8_t j = 0; j < data_length; ++j) {\n            g_vehicleConfiguration[target_offset + j] = packet_data[current_read_offset + j];\n        }\n        current_read_offset += data_length;\n    }\n    return 0;\n}\n\nvoid receiveConfigCommandPacket(const uint8_t* msg_data, uint16_t msg_len) {\n    processConfigCommands(msg_data, msg_len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 256\n#define MAX_COMMAND_DATA_SIZE 128\n#define MAX_COMMANDS_PER_PACKET 8\n\nstatic uint8_t g_vehicleConfiguration[VEHICLE_CONFIG_BUFFER_SIZE];\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t target_offset;\n    uint8_t data_length;\n} ConfigCommandHeader;\n\nvoid initVehicleConfiguration() {\n    memset(g_vehicleConfiguration, 0, VEHICLE_CONFIG_BUFFER_SIZE);\n}\n\nint processConfigCommands(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len < sizeof(uint8_t)) {\n        return -1;\n    }\n\n    uint8_t num_commands = packet_data[0];\n    uint16_t current_read_offset = sizeof(uint8_t);\n\n    if (num_commands > MAX_COMMANDS_PER_PACKET) {\n        return -2;\n    }\n\n    for (uint8_t i = 0; i < num_commands; ++i) {\n        if (current_read_offset + sizeof(ConfigCommandHeader) > packet_len) {\n            return -3;\n        }\n\n        uint8_t command_id = packet_data[current_read_offset];\n        uint8_t target_offset = packet_data[current_read_offset + 1];\n        uint8_t data_length = packet_data[current_read_offset + 2];\n        current_read_offset += sizeof(ConfigCommandHeader);\n\n        if (data_length > MAX_COMMAND_DATA_SIZE) {\n            return -4;\n        }\n\n        if (current_read_offset + data_length > packet_len) {\n            return -5;\n        }\n\n        if (target_offset >= VEHICLE_CONFIG_BUFFER_SIZE || (uint16_t)target_offset + data_length > VEHICLE_CONFIG_BUFFER_SIZE) {\n            return -6;\n        }\n\n        for (uint8_t j = 0; j < data_length; ++j) {\n            g_vehicleConfiguration[target_offset + j] = packet_data[current_read_offset + j];\n        }\n        current_read_offset += data_length;\n    }\n    return 0;\n}\n\nvoid receiveConfigCommandPacket(const uint8_t* msg_data, uint16_t msg_len) {\n    processConfigCommands(msg_data, msg_len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", ",cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_PAYLOAD 64\n#define DIAG_EVENT_LOG_CAPACITY 10\n\ntypedef struct {\n    uint8_t  event_type;\n    uint8_t  log_level;\n    uint8_t  payload_actual_len;\n    uint8_t  payload[MAX_DIAG_PAYLOAD];\n    uint32_t timestamp;\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diagEventLog[DIAG_EVENT_LOG_CAPACITY];\nstatic uint8_t g_currentLogIndex = 0;\n\nvoid initDiagEventLog() {\n    memset(g_diagEventLog, 0, sizeof(g_diagEventLog));\n    g_currentLogIndex = 0;\n}\n\nstatic int addEventToLog(const DiagnosticEvent* event) {\n    if (g_currentLogIndex >= DIAG_EVENT_LOG_CAPACITY) {\n        return -1;\n    }\n    memcpy(&g_diagEventLog[g_currentLogIndex], event, sizeof(DiagnosticEvent));\n    g_currentLogIndex++;\n    return 0;\n}\n\nint processIncomingDiagData(const uint8_t* raw_data, uint16_t raw_data_len) {\n    if (raw_data == NULL || raw_data_len < 3) {\n        return -1;\n    }\n\n    uint8_t event_type = raw_data[0];\n    uint8_t log_level = raw_data[1];\n    uint8_t incoming_payload_len = raw_data[2];\n\n    if (raw_data_len < (3 + incoming_payload_len)) {\n        return -2;\n    }\n\n    DiagnosticEvent temp_event;\n    temp_event.event_type = event_type;\n    temp_event.log_level = log_level;\n    temp_event.payload_actual_len = incoming_payload_len;\n    temp_event.timestamp = 0xDEADBEEF;\n\n    memcpy(temp_event.payload, raw_data + 3, incoming_payload_len);\n\n    return addEventToLog(&temp_event);\n}\n\nvoid receiveNetworkDiagMessage(const uint8_t* message_buffer, uint16_t buffer_len) {\n    processIncomingDiagData(message_buffer, buffer_len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_PAYLOAD 64\n#define DIAG_EVENT_LOG_CAPACITY 10\n\ntypedef struct {\n    uint8_t  event_type;\n    uint8_t  log_level;\n    uint8_t  payload_actual_len;\n    uint8_t  payload[MAX_DIAG_PAYLOAD];\n    uint32_t timestamp;\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diagEventLog[DIAG_EVENT_LOG_CAPACITY];\nstatic uint8_t g_currentLogIndex = 0;\n\nvoid initDiagEventLog() {\n    memset(g_diagEventLog, 0, sizeof(g_diagEventLog));\n    g_currentLogIndex = 0;\n}\n\nstatic int addEventToLog(const DiagnosticEvent* event) {\n    if (g_currentLogIndex >= DIAG_EVENT_LOG_CAPACITY) {\n        return -1;\n    }\n    memcpy(&g_diagEventLog[g_currentLogIndex], event, sizeof(DiagnosticEvent));\n    g_currentLogIndex++;\n    return 0;\n}\n\nint processIncomingDiagData(const uint8_t* raw_data, uint16_t raw_data_len) {\n    if (raw_data == NULL || raw_data_len < 3) {\n        return -1;\n    }\n\n    uint8_t event_type = raw_data[0];\n    uint8_t log_level = raw_data[1];\n    uint8_t incoming_payload_len = raw_data[2];\n\n    if (raw_data_len < (3 + incoming_payload_len)) {\n        return -2;\n    }\n\n    DiagnosticEvent temp_event;\n    temp_event.event_type = event_type;\n    temp_event.log_level = log_level;\n    temp_event.timestamp = 0xDEADBEEF;\n\n    uint8_t bytes_to_copy = incoming_payload_len;\n    if (bytes_to_copy > MAX_DIAG_PAYLOAD) {\n        bytes_to_copy = MAX_DIAG_PAYLOAD;\n    }\n    temp_event.payload_actual_len = bytes_to_copy;\n\n    memcpy(temp_event.payload, raw_data + 3, bytes_to_copy);\n\n    return addEventToLog(&temp_event);\n}\n\nvoid receiveNetworkDiagMessage(const uint8_t* message_buffer, uint16_t buffer_len) {\n    processIncomingDiagData(message_buffer, buffer_len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_SETTINGS_BUFFER_SIZE 128\n#define MAX_SETTINGS_COMMAND_PAYLOAD_SIZE 64\n#define SETTINGS_COMMAND_ID_UPDATE 0x01\n\nstatic uint8_t g_vehicleSettings[VEHICLE_SETTINGS_BUFFER_SIZE];\n\nvoid initVehicleSettings() {\n    memset(g_vehicleSettings, 0, VEHICLE_SETTINGS_BUFFER_SIZE);\n    for (uint8_t i = 0; i < VEHICLE_SETTINGS_BUFFER_SIZE; ++i) {\n        g_vehicleSettings[i] = (uint8_t)(i % 0xFF);\n    }\n}\n\nint applyVehicleSettingsCommand(const uint8_t* raw_command_packet, uint16_t packet_length) {\n    if (raw_command_packet == NULL || packet_length < 4) {\n        return -1;\n    }\n\n    uint8_t command_id = raw_command_packet[0];\n    if (command_id != SETTINGS_COMMAND_ID_UPDATE) {\n        return -2;\n    }\n\n    uint8_t target_start_address = raw_command_packet[1];\n    uint8_t data_block_length = raw_command_packet[2];\n\n    if (data_block_length > MAX_SETTINGS_COMMAND_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    if (packet_length < (3 + data_block_length)) {\n        return -4;\n    }\n    \n    for (uint8_t i = 0; i < data_block_length; ++i) {\n        g_vehicleSettings[target_start_address + i] = raw_command_packet[3 + i];\n    }\n\n    return 0;\n}\n\nvoid receiveSettingsUpdateMessage(const uint8_t* message, uint16_t length) {\n    initVehicleSettings();\n    applyVehicleSettingsCommand(message, length);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_SETTINGS_BUFFER_SIZE 128\n#define MAX_SETTINGS_COMMAND_PAYLOAD_SIZE 64\n#define SETTINGS_COMMAND_ID_UPDATE 0x01\n\nstatic uint8_t g_vehicleSettings[VEHICLE_SETTINGS_BUFFER_SIZE];\n\nvoid initVehicleSettings() {\n    memset(g_vehicleSettings, 0, VEHICLE_SETTINGS_BUFFER_SIZE);\n    for (uint8_t i = 0; i < VEHICLE_SETTINGS_BUFFER_SIZE; ++i) {\n        g_vehicleSettings[i] = (uint8_t)(i % 0xFF);\n    }\n}\n\nint applyVehicleSettingsCommand(const uint8_t* raw_command_packet, uint16_t packet_length) {\n    if (raw_command_packet == NULL || packet_length < 4) {\n        return -1;\n    }\n\n    uint8_t command_id = raw_command_packet[0];\n    if (command_id != SETTINGS_COMMAND_ID_UPDATE) {\n        return -2;\n    }\n\n    uint8_t target_start_address = raw_command_packet[1];\n    uint8_t data_block_length = raw_command_packet[2];\n\n    if (data_block_length > MAX_SETTINGS_COMMAND_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    if (packet_length < (3 + data_block_length)) {\n        return -4;\n    }\n    \n    if (target_start_address >= VEHICLE_SETTINGS_BUFFER_SIZE || \n        (uint16_t)target_start_address + data_block_length > VEHICLE_SETTINGS_BUFFER_SIZE) {\n        return -5;\n    }\n\n    for (uint8_t i = 0; i < data_block_length; ++i) {\n        g_vehicleSettings[target_start_address + i] = raw_command_packet[3 + i];\n    }\n\n    return 0;\n}\n\nvoid receiveSettingsUpdateMessage(const uint8_t* message, uint16_t length) {\n    initVehicleSettings();\n    applyVehicleSettingsCommand(message, length);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMAND_DATA_PAYLOAD 64 \n#define PROCESSING_BUFFER_SIZE 32   \n\ntypedef struct {\n    uint16_t command_id;\n    uint8_t  payload_len;\n    uint8_t  payload[MAX_COMMAND_DATA_PAYLOAD];\n    uint16_t crc_checksum;\n} VehicleCommand;\n\nstatic uint8_t g_tempProcessingBuffer[PROCESSING_BUFFER_SIZE];\n\nvoid initCommandProcessor() {\n    memset(g_tempProcessingBuffer, 0, PROCESSING_BUFFER_SIZE);\n}\n\nuint16_t calculateCrc(const uint8_t* data, uint8_t len) {\n    uint16_t crc = 0xFFFF;\n    for (uint8_t i = 0; i < len; ++i) {\n        crc ^= data[i];\n        for (int j = 0; j < 8; ++j) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\nint processVehicleCommand(const VehicleCommand* cmd) {\n    if (cmd == NULL) {\n        return -1; \n    }\n\n    if (cmd->payload_len > MAX_COMMAND_DATA_PAYLOAD) {\n        return -2; \n    }\n\n    for (uint8_t i = 0; i < cmd->payload_len; ++i) {\n        g_tempProcessingBuffer[i] = cmd->payload[i];\n    }\n\n    uint16_t calculated_crc = calculateCrc(g_tempProcessingBuffer, cmd->payload_len);\n\n    if (calculated_crc != cmd->crc_checksum) {\n        return -3; \n    }\n\n    return 0; \n}\n\nvoid simulateCommandReception(const VehicleCommand* rx_cmd) {\n    processVehicleCommand(rx_cmd);\n}", "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMAND_DATA_PAYLOAD 64 \n#define PROCESSING_BUFFER_SIZE 32   \n\ntypedef struct {\n    uint16_t command_id;\n    uint8_t  payload_len;\n    uint8_t  payload[MAX_COMMAND_DATA_PAYLOAD];\n    uint16_t crc_checksum;\n} VehicleCommand;\n\nstatic uint8_t g_tempProcessingBuffer[PROCESSING_BUFFER_SIZE];\n\nvoid initCommandProcessor() {\n    memset(g_tempProcessingBuffer, 0, PROCESSING_BUFFER_SIZE);\n}\n\nuint16_t calculateCrc(const uint8_t* data, uint8_t len) {\n    uint16_t crc = 0xFFFF;\n    for (uint8_t i = 0; i < len; ++i) {\n        crc ^= data[i];\n        for (int j = 0; j < 8; ++j) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ 0xA001;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\nint processVehicleCommand(const VehicleCommand* cmd) {\n    if (cmd == NULL) {\n        return -1; \n    }\n\n    if (cmd->payload_len > MAX_COMMAND_DATA_PAYLOAD) {\n        return -2; \n    }\n\n    memset(g_tempProcessingBuffer, 0, PROCESSING_BUFFER_SIZE); \n\n    uint8_t bytes_to_copy = cmd->payload_len;\n    if (bytes_to_copy > PROCESSING_BUFFER_SIZE) {\n        bytes_to_copy = PROCESSING_BUFFER_SIZE; \n    }\n\n    for (uint8_t i = 0; i < bytes_to_copy; ++i) {\n        g_tempProcessingBuffer[i] = cmd->payload[i];\n    }\n\n    uint16_t calculated_crc = calculateCrc(g_tempProcessingBuffer, bytes_to_copy);\n\n    if (calculated_crc != cmd->crc_checksum) {\n        return -3; \n    }\n\n    return 0; \n}\n\nvoid simulateCommandReception(const VehicleCommand* rx_cmd) {\n    processVehicleCommand(rx_cmd);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_LOG_ENTRIES 50\n#define DIAG_LOG_ENTRY_SIZE 8\n\ntypedef struct {\n    uint16_t eventId;\n    uint16_t subId;\n    uint32_t timestamp;\n} DiagnosticLogEntry;\n\nstatic DiagnosticLogEntry g_diagnosticLogBuffer[MAX_DIAG_LOG_ENTRIES];\nstatic uint16_t g_currentStoredLogCount = 0;\n\nvoid initDiagnosticLogger() {\n    memset(g_diagnosticLogBuffer, 0, sizeof(g_diagnosticLogBuffer));\n    g_currentStoredLogCount = 0;\n}\n\nint processAndStoreLogBlock(const uint8_t* raw_log_block, uint16_t block_byte_len) {\n    if (raw_log_block == NULL || block_byte_len == 0) {\n        return -1;\n    }\n\n    if (block_byte_len % DIAG_LOG_ENTRY_SIZE != 0) {\n        return -2;\n    }\n\n    uint16_t num_entries_to_process = block_byte_len / DIAG_LOG_ENTRY_SIZE;\n\n    for (uint16_t i = 0; i < num_entries_to_process; ++i) {\n        uint16_t target_log_idx = g_currentStoredLogCount + i;\n\n        g_diagnosticLogBuffer[target_log_idx].eventId = (raw_log_block[i * DIAG_LOG_ENTRY_SIZE] << 8) |\n                                                            raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 1];\n        g_diagnosticLogBuffer[target_log_idx].subId = (raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 2] << 8) |\n                                                          raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 3];\n        g_diagnosticLogBuffer[target_log_idx].timestamp = (raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 4] << 24) |\n                                                              (raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 5] << 16) |\n                                                              (raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 6] << 8) |\n                                                              raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 7];\n    }\n\n    g_currentStoredLogCount += num_entries_to_process;\n\n    return 0;\n}\n\nDiagnosticLogEntry getLogEntry(uint16_t index) {\n    if (index < MAX_DIAG_LOG_ENTRIES) {\n        return g_diagnosticLogBuffer[index];\n    }\n    DiagnosticLogEntry empty = {0,0,0};\n    return empty;\n}\n\nvoid simulateCanLogMessage(const uint8_t* data, uint16_t len) {\n    processAndStoreLogBlock(data, len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_LOG_ENTRIES 50\n#define DIAG_LOG_ENTRY_SIZE 8\n\ntypedef struct {\n    uint16_t eventId;\n    uint16_t subId;\n    uint32_t timestamp;\n} DiagnosticLogEntry;\n\nstatic DiagnosticLogEntry g_diagnosticLogBuffer[MAX_DIAG_LOG_ENTRIES];\nstatic uint16_t g_currentStoredLogCount = 0;\n\nvoid initDiagnosticLogger() {\n    memset(g_diagnosticLogBuffer, 0, sizeof(g_diagnosticLogBuffer));\n    g_currentStoredLogCount = 0;\n}\n\nint processAndStoreLogBlock(const uint8_t* raw_log_block, uint16_t block_byte_len) {\n    if (raw_log_block == NULL || block_byte_len == 0) {\n        return -1;\n    }\n\n    if (block_byte_len % DIAG_LOG_ENTRY_SIZE != 0) {\n        return -2;\n    }\n\n    uint16_t num_entries_in_block = block_byte_len / DIAG_LOG_ENTRY_SIZE;\n\n    uint16_t entries_to_write;\n    if (g_currentStoredLogCount >= MAX_DIAG_LOG_ENTRIES) {\n        entries_to_write = 0;\n    } else {\n        uint16_t remaining_space = MAX_DIAG_LOG_ENTRIES - g_currentStoredLogCount;\n        if (num_entries_in_block > remaining_space) {\n            entries_to_write = remaining_space;\n        } else {\n            entries_to_write = num_entries_in_block;\n        }\n    }\n    \n    if (entries_to_write == 0) {\n        return -3;\n    }\n\n    for (uint16_t i = 0; i < entries_to_write; ++i) {\n        uint16_t target_log_idx = g_currentStoredLogCount + i;\n\n        g_diagnosticLogBuffer[target_log_idx].eventId = (raw_log_block[i * DIAG_LOG_ENTRY_SIZE] << 8) |\n                                                            raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 1];\n        g_diagnosticLogBuffer[target_log_idx].subId = (raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 2] << 8) |\n                                                          raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 3];\n        g_diagnosticLogBuffer[target_log_idx].timestamp = (raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 4] << 24) |\n                                                              (raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 5] << 16) |\n                                                              (raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 6] << 8) |\n                                                              raw_log_block[i * DIAG_LOG_ENTRY_SIZE + 7];\n    }\n\n    g_currentStoredLogCount += entries_to_write;\n\n    return 0;\n}\n\nDiagnosticLogEntry getLogEntry(uint16_t index) {\n    if (index < MAX_DIAG_LOG_ENTRIES) {\n        return g_diagnosticLogBuffer[index];\n    }\n    DiagnosticLogEntry empty = {0,0,0};\n    return empty;\n}\n\nvoid simulateCanLogMessage(const uint8_t* data, uint16_t len) {\n    processAndStoreLogBlock(data, len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define ENGINE_CONFIG_BUFFER_SIZE 64\n#define TRANSMISSION_CONFIG_BUFFER_SIZE 32\n#define BRAKE_CONFIG_BUFFER_SIZE 48\n#define INFOTAINMENT_CONFIG_BUFFER_SIZE 128\n\nstatic uint8_t g_engineConfig[ENGINE_CONFIG_BUFFER_SIZE];\nstatic uint8_t g_transmissionConfig[TRANSMISSION_CONFIG_BUFFER_SIZE];\nstatic uint8_t g_brakeConfig[BRAKE_CONFIG_BUFFER_SIZE];\nstatic uint8_t g_infotainmentConfig[INFOTAINMENT_CONFIG_BUFFER_SIZE];\n\ntypedef enum {\n    PARAM_ENGINE = 0,\n    PARAM_TRANSMISSION = 1,\n    PARAM_BRAKE = 2,\n    PARAM_INFOTAINMENT = 3,\n    PARAM_MAX_ID = 4\n} VehicleParamID;\n\nvoid initVehicleConfigBuffers() {\n    memset(g_engineConfig, 0, ENGINE_CONFIG_BUFFER_SIZE);\n    memset(g_transmissionConfig, 0, TRANSMISSION_CONFIG_BUFFER_SIZE);\n    memset(g_brakeConfig, 0, BRAKE_CONFIG_BUFFER_SIZE);\n    memset(g_infotainmentConfig, 0, INFOTAINMENT_CONFIG_BUFFER_SIZE);\n}\n\nint updateVehicleParameter(uint8_t param_id, uint8_t offset, uint8_t length, const uint8_t* data) {\n    if (data == NULL || length == 0) {\n        return -1;\n    }\n    if (param_id >= PARAM_MAX_ID) {\n        return -2;\n    }\n\n    uint8_t* target_buffer = NULL;\n    uint16_t buffer_size = 0;\n    \n    switch (param_id) {\n        case PARAM_ENGINE:\n            target_buffer = g_engineConfig;\n            buffer_size = ENGINE_CONFIG_BUFFER_SIZE;\n            break;\n        case PARAM_TRANSMISSION:\n            target_buffer = g_transmissionConfig;\n            buffer_size = TRANSMISSION_CONFIG_BUFFER_SIZE;\n            break;\n        case PARAM_BRAKE:\n            target_buffer = g_brakeConfig;\n            buffer_size = BRAKE_CONFIG_BUFFER_SIZE;\n            break;\n        case PARAM_INFOTAINMENT:\n            target_buffer = g_infotainmentConfig;\n            buffer_size = INFOTAINMENT_CONFIG_BUFFER_SIZE;\n            break;\n        default:\n            return -3;\n    }\n\n    if (offset >= buffer_size) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < length; ++i) {\n        target_buffer[offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticCommand(const uint8_t* command_packet, uint16_t packet_len) {\n    if (command_packet == NULL || packet_len < 3) {\n        return;\n    }\n\n    uint8_t param_id = command_packet[0];\n    uint8_t offset = command_packet[1];\n    uint8_t length = command_packet[2];\n    const uint8_t* data = command_packet + 3;\n\n    if (3 + length > packet_len) {\n        return;\n    }\n\n    updateVehicleParameter(param_id, offset, length, data);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define ENGINE_CONFIG_BUFFER_SIZE 64\n#define TRANSMISSION_CONFIG_BUFFER_SIZE 32\n#define BRAKE_CONFIG_BUFFER_SIZE 48\n#define INFOTAINMENT_CONFIG_BUFFER_SIZE 128\n\nstatic uint8_t g_engineConfig[ENGINE_CONFIG_BUFFER_SIZE];\nstatic uint8_t g_transmissionConfig[TRANSMISSION_CONFIG_BUFFER_SIZE];\nstatic uint8_t g_brakeConfig[BRAKE_CONFIG_BUFFER_SIZE];\nstatic uint8_t g_infotainmentConfig[INFOTAINMENT_CONFIG_BUFFER_SIZE];\n\ntypedef enum {\n    PARAM_ENGINE = 0,\n    PARAM_TRANSMISSION = 1,\n    PARAM_BRAKE = 2,\n    PARAM_INFOTAINMENT = 3,\n    PARAM_MAX_ID = 4\n} VehicleParamID;\n\nvoid initVehicleConfigBuffers() {\n    memset(g_engineConfig, 0, ENGINE_CONFIG_BUFFER_SIZE);\n    memset(g_transmissionConfig, 0, TRANSMISSION_CONFIG_BUFFER_SIZE);\n    memset(g_brakeConfig, 0, BRAKE_CONFIG_BUFFER_SIZE);\n    memset(g_infotainmentConfig, 0, INFOTAINMENT_CONFIG_BUFFER_SIZE);\n}\n\nint updateVehicleParameter(uint8_t param_id, uint8_t offset, uint8_t length, const uint8_t* data) {\n    if (data == NULL || length == 0) {\n        return -1;\n    }\n    if (param_id >= PARAM_MAX_ID) {\n        return -2;\n    }\n\n    uint8_t* target_buffer = NULL;\n    uint16_t buffer_size = 0;\n    \n    switch (param_id) {\n        case PARAM_ENGINE:\n            target_buffer = g_engineConfig;\n            buffer_size = ENGINE_CONFIG_BUFFER_SIZE;\n            break;\n        case PARAM_TRANSMISSION:\n            target_buffer = g_transmissionConfig;\n            buffer_size = TRANSMISSION_CONFIG_BUFFER_SIZE;\n            break;\n        case PARAM_BRAKE:\n            target_buffer = g_brakeConfig;\n            buffer_size = BRAKE_CONFIG_BUFFER_SIZE;\n            break;\n        case PARAM_INFOTAINMENT:\n            target_buffer = g_infotainmentConfig;\n            buffer_size = INFOTAINMENT_CONFIG_BUFFER_SIZE;\n            break;\n        default:\n            return -3;\n    }\n\n    if (offset >= buffer_size) {\n        return -4;\n    }\n\n    if ((uint16_t)offset + length > buffer_size) {\n        return -5;\n    }\n\n    for (uint8_t i = 0; i < length; ++i) {\n        target_buffer[offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticCommand(const uint8_t* command_packet, uint16_t packet_len) {\n    if (command_packet == NULL || packet_len < 3) {\n        return;\n    }\n\n    uint8_t param_id = command_packet[0];\n    uint8_t offset = command_packet[1];\n    uint8_t length = command_packet[2];\n    const uint8_t* data = command_packet + 3;\n\n    if (3 + length > packet_len) {\n        return;\n    }\n\n    updateVehicleParameter(param_id, offset, length, data);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define CONFIG_STORAGE_BUFFER_SIZE 256\n#define MAX_CONFIG_PACKET_SIZE 128\n#define MAX_SUPPORTED_VALUE_LENGTH 64\n\ntypedef struct {\n    uint8_t key_id;\n    uint8_t value_type;\n    uint8_t value_length;\n} ConfigEntryHeader;\n\nstatic uint8_t g_configStorageBuffer[CONFIG_STORAGE_BUFFER_SIZE];\nstatic uint16_t g_currentStorageOffset = 0;\n\nvoid initConfigManager() {\n    memset(g_configStorageBuffer, 0, CONFIG_STORAGE_BUFFER_SIZE);\n    g_currentStorageOffset = 0;\n}\n\nint applyConfigUpdate(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len == 0 || packet_len > MAX_CONFIG_PACKET_SIZE) {\n        return -1;\n    }\n\n    uint16_t packet_parse_offset = 0;\n\n    while (packet_parse_offset < packet_len) {\n        if (packet_parse_offset + sizeof(ConfigEntryHeader) > packet_len) {\n            return -2;\n        }\n\n        const ConfigEntryHeader* current_header = (const ConfigEntryHeader*)(packet + packet_parse_offset);\n        uint8_t entry_value_len = current_header->value_length;\n\n        if (entry_value_len > MAX_SUPPORTED_VALUE_LENGTH) {\n            return -3;\n        }\n\n        if (packet_parse_offset + sizeof(ConfigEntryHeader) + entry_value_len > packet_len) {\n            return -4;\n        }\n\n        for (uint8_t i = 0; i < entry_value_len; ++i) {\n            g_configStorageBuffer[g_currentStorageOffset + i] = packet[packet_parse_offset + sizeof(ConfigEntryHeader) + i];\n        }\n\n        g_currentStorageOffset += entry_value_len;\n        packet_parse_offset += sizeof(ConfigEntryHeader) + entry_value_len;\n    }\n\n    return 0;\n}\n\nuint8_t getConfigByte(uint16_t offset) {\n    if (offset < CONFIG_STORAGE_BUFFER_SIZE) {\n        return g_configStorageBuffer[offset];\n    }\n    return 0xFF;\n}\n\nvoid simulateIncomingConfigPacket(const uint8_t* data, uint16_t len) {\n    applyConfigUpdate(data, len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define CONFIG_STORAGE_BUFFER_SIZE 256\n#define MAX_CONFIG_PACKET_SIZE 128\n#define MAX_SUPPORTED_VALUE_LENGTH 64\n\ntypedef struct {\n    uint8_t key_id;\n    uint8_t value_type;\n    uint8_t value_length;\n} ConfigEntryHeader;\n\nstatic uint8_t g_configStorageBuffer[CONFIG_STORAGE_BUFFER_SIZE];\nstatic uint16_t g_currentStorageOffset = 0;\n\nvoid initConfigManager() {\n    memset(g_configStorageBuffer, 0, CONFIG_STORAGE_BUFFER_SIZE);\n    g_currentStorageOffset = 0;\n}\n\nint applyConfigUpdate(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len == 0 || packet_len > MAX_CONFIG_PACKET_SIZE) {\n        return -1;\n    }\n\n    uint16_t packet_parse_offset = 0;\n\n    while (packet_parse_offset < packet_len) {\n        if (packet_parse_offset + sizeof(ConfigEntryHeader) > packet_len) {\n            return -2;\n        }\n\n        const ConfigEntryHeader* current_header = (const ConfigEntryHeader*)(packet + packet_parse_offset);\n        uint8_t entry_value_len = current_header->value_length;\n\n        if (entry_value_len > MAX_SUPPORTED_VALUE_LENGTH) {\n            return -3;\n        }\n\n        if (packet_parse_offset + sizeof(ConfigEntryHeader) + entry_value_len > packet_len) {\n            return -4;\n        }\n\n        if (g_currentStorageOffset + entry_value_len > CONFIG_STORAGE_BUFFER_SIZE) {\n            return -5;\n        }\n\n        for (uint8_t i = 0; i < entry_value_len; ++i) {\n            g_configStorageBuffer[g_currentStorageOffset + i] = packet[packet_parse_offset + sizeof(ConfigEntryHeader) + i];\n        }\n\n        g_currentStorageOffset += entry_value_len;\n        packet_parse_offset += sizeof(ConfigEntryHeader) + entry_value_len;\n    }\n\n    return 0;\n}\n\nuint8_t getConfigByte(uint16_t offset) {\n    if (offset < CONFIG_STORAGE_BUFFER_SIZE) {\n        return g_configStorageBuffer[offset];\n    }\n    return 0xFF;\n}\n\nvoid simulateIncomingConfigPacket(const uint8_t* data, uint16_t len) {\n    applyConfigUpdate(data, len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_RECORDER_BUFFER_SIZE 250 \n#define MAX_PAYLOAD_CHUNK_SIZE 60   \n\nstatic uint8_t g_diagRecordBuffer[DIAG_RECORDER_BUFFER_SIZE];\nstatic uint8_t g_currentRecordOffset = 0; \n\nvoid initDiagRecorder() {\n    memset(g_diagRecordBuffer, 0, DIAG_RECORDER_BUFFER_SIZE);\n    g_currentRecordOffset = 0;\n}\n\nint appendDiagDataChunk(const uint8_t* data_chunk, uint8_t chunk_len) {\n    if (data_chunk == NULL || chunk_len == 0 || chunk_len > MAX_PAYLOAD_CHUNK_SIZE) {\n        return -1; \n    }\n\n    uint8_t next_offset = g_currentRecordOffset + chunk_len;\n\n    if (next_offset > DIAG_RECORDER_BUFFER_SIZE) { \n        return -2; \n    }\n\n    for (uint8_t i = 0; i < chunk_len; ++i) {\n        g_diagRecordBuffer[g_currentRecordOffset + i] = data_chunk[i];\n    }\n\n    g_currentRecordOffset = next_offset; \n\n    return 0; \n}\n\nvoid processDiagnosticDataStream(const uint8_t* stream_data, uint16_t stream_len) {\n    initDiagRecorder(); \n\n    uint8_t fill_data[10];\n    memset(fill_data, 0x01, sizeof(fill_data));\n    \n    for (int k = 0; k < 20; ++k) {\n        appendDiagDataChunk(fill_data, 10); \n    }\n    \n    uint8_t evil_chunk_data[60];\n    memset(evil_chunk_data, 0xAA, sizeof(evil_chunk_data));\n\n    appendDiagDataChunk(evil_chunk_data, 60);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_RECORDER_BUFFER_SIZE 250 \n#define MAX_PAYLOAD_CHUNK_SIZE 60   \n\nstatic uint8_t g_diagRecordBuffer[DIAG_RECORDER_BUFFER_SIZE];\nstatic uint16_t g_currentRecordOffset = 0; \n\nvoid initDiagRecorder() {\n    memset(g_diagRecordBuffer, 0, DIAG_RECORDER_BUFFER_SIZE);\n    g_currentRecordOffset = 0;\n}\n\nint appendDiagDataChunk(const uint8_t* data_chunk, uint8_t chunk_len) {\n    if (data_chunk == NULL || chunk_len == 0 || chunk_len > MAX_PAYLOAD_CHUNK_SIZE) {\n        return -1; \n    }\n\n    uint16_t next_offset = g_currentRecordOffset + chunk_len;\n\n    if (next_offset > DIAG_RECORDER_BUFFER_SIZE) { \n        return -2; \n    }\n\n    for (uint8_t i = 0; i < chunk_len; ++i) {\n        g_diagRecordBuffer[g_currentRecordOffset + i] = data_chunk[i];\n    }\n\n    g_currentRecordOffset = next_offset; \n\n    return 0; \n}\n\nvoid processDiagnosticDataStream(const uint8_t* stream_data, uint16_t stream_len) {\n    initDiagRecorder(); \n\n    uint8_t fill_data[10];\n    memset(fill_data, 0x01, sizeof(fill_data));\n    \n    for (int k = 0; k < 20; ++k) {\n        appendDiagDataChunk(fill_data, 10); \n    }\n    \n    uint8_t evil_chunk_data[60];\n    memset(evil_chunk_data, 0xAA, sizeof(evil_chunk_data));\n\n    appendDiagDataChunk(evil_chunk_data, 60);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define LOG_BUFFER_MAX_SIZE 512\n#define EVENT_HEADER_BASE_SIZE 2\n\nstatic uint8_t g_eventLogBuffer[LOG_BUFFER_MAX_SIZE];\nstatic uint16_t g_logCurrentWriteOffset = 0;\n\nvoid initEventLogger() {\n    memset(g_eventLogBuffer, 0, LOG_BUFFER_MAX_SIZE);\n    g_logCurrentWriteOffset = 0;\n}\n\nint processIncomingEvent(const uint8_t* message_payload, uint16_t payload_len) {\n    if (message_payload == NULL || payload_len < EVENT_HEADER_BASE_SIZE) {\n        return -1;\n    }\n\n    uint8_t event_type = message_payload[0];\n    uint8_t data_len = message_payload[1];\n\n    if (EVENT_HEADER_BASE_SIZE + data_len > payload_len) {\n        return -2;\n    }\n\n    uint8_t total_entry_size_check = (uint8_t)(EVENT_HEADER_BASE_SIZE + data_len);\n\n    if (g_logCurrentWriteOffset + total_entry_size_check > LOG_BUFFER_MAX_SIZE) {\n        return -3;\n    }\n\n    g_eventLogBuffer[g_logCurrentWriteOffset] = event_type;\n    g_logCurrentWriteOffset++;\n\n    g_eventLogBuffer[g_logCurrentWriteOffset] = data_len;\n    g_logCurrentWriteOffset++;\n\n    const uint8_t* event_data_ptr = message_payload + EVENT_HEADER_BASE_SIZE;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_eventLogBuffer[g_logCurrentWriteOffset + i] = event_data_ptr[i];\n    }\n    g_logCurrentWriteOffset += data_len;\n\n    return 0;\n}\n\nuint8_t getLogByte(uint16_t offset) {\n    if (offset < LOG_BUFFER_MAX_SIZE) {\n        return g_eventLogBuffer[offset];\n    }\n    return 0xFF;\n}\n\nvoid simulateEventReception(const uint8_t* msg, uint16_t len) {\n    processIncomingEvent(msg, len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define LOG_BUFFER_MAX_SIZE 512\n#define EVENT_HEADER_BASE_SIZE 2\n\nstatic uint8_t g_eventLogBuffer[LOG_BUFFER_MAX_SIZE];\nstatic uint16_t g_logCurrentWriteOffset = 0;\n\nvoid initEventLogger() {\n    memset(g_eventLogBuffer, 0, LOG_BUFFER_MAX_SIZE);\n    g_logCurrentWriteOffset = 0;\n}\n\nint processIncomingEvent(const uint8_t* message_payload, uint16_t payload_len) {\n    if (message_payload == NULL || payload_len < EVENT_HEADER_BASE_SIZE) {\n        return -1;\n    }\n\n    uint8_t event_type = message_payload[0];\n    uint8_t data_len = message_payload[1];\n\n    if (EVENT_HEADER_BASE_SIZE + data_len > payload_len) {\n        return -2;\n    }\n\n    uint16_t total_entry_size = (uint16_t)EVENT_HEADER_BASE_SIZE + data_len;\n\n    if (g_logCurrentWriteOffset + total_entry_size > LOG_BUFFER_MAX_SIZE) {\n        return -3;\n    }\n\n    g_eventLogBuffer[g_logCurrentWriteOffset] = event_type;\n    g_logCurrentWriteOffset++;\n\n    g_eventLogBuffer[g_logCurrentWriteOffset] = data_len;\n    g_logCurrentWriteOffset++;\n\n    const uint8_t* event_data_ptr = message_payload + EVENT_HEADER_BASE_SIZE;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_eventLogBuffer[g_logCurrentWriteOffset + i] = event_data_ptr[i];\n    }\n    g_logCurrentWriteOffset += data_len;\n\n    return 0;\n}\n\nuint8_t getLogByte(uint16_t offset) {\n    if (offset < LOG_BUFFER_MAX_SIZE) {\n        return g_eventLogBuffer[offset];\n    }\n    return 0xFF;\n}\n\nvoid simulateEventReception(const uint8_t* msg, uint16_t len) {\n    processIncomingEvent(msg, len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", ",cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_PID_CONTROLLERS 5\n\ntypedef struct {\n    float Kp;\n    float Ki;\n    float Kd;\n    int32_t min_output;\n    int32_t max_output;\n    uint8_t loop_status;\n    uint8_t reserved[3];\n} PID_Parameters;\n\nstatic PID_Parameters g_pidConfigs[MAX_PID_CONTROLLERS];\n\nvoid initPIDControllers() {\n    for (int i = 0; i < MAX_PID_CONTROLLERS; ++i) {\n        g_pidConfigs[i].Kp = 0.0f;\n        g_pidConfigs[i].Ki = 0.0f;\n        g_pidConfigs[i].Kd = 0.0f;\n        g_pidConfigs[i].min_output = 0;\n        g_pidConfigs[i].max_output = 0;\n        g_pidConfigs[i].loop_status = 0;\n        memset(g_pidConfigs[i].reserved, 0, sizeof(g_pidConfigs[i].reserved));\n    }\n}\n\nint updatePIDParameter(const uint8_t* msg_data, uint16_t msg_len) {\n    if (msg_data == NULL || msg_len < 3) {\n        return -1;\n    }\n\n    uint8_t controller_id = msg_data[0];\n    uint8_t parameter_offset_bytes = msg_data[1];\n    uint16_t data_value_len = msg_len - 2;\n\n    if (controller_id >= MAX_PID_CONTROLLERS) {\n        return -2;\n    }\n\n    memcpy((uint8_t*)&g_pidConfigs[controller_id] + parameter_offset_bytes, msg_data + 2, data_value_len);\n\n    return 0;\n}\n\nvoid handleVehicleConfigMessage(const uint8_t* network_data, uint16_t network_len) {\n    if (network_len < 3) {\n        return;\n    }\n    updatePIDParameter(network_data, network_len);\n}\n\nfloat getPIDKp(uint8_t id) {\n    if (id < MAX_PID_CONTROLLERS) {\n        return g_pidConfigs[id].Kp;\n    }\n    return 0.0f;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_PID_CONTROLLERS 5\n#define PID_PARAM_SET_SIZE sizeof(PID_Parameters)\n\ntypedef struct {\n    float Kp;\n    float Ki;\n    float Kd;\n    int32_t min_output;\n    int32_t max_output;\n    uint8_t loop_status;\n    uint8_t reserved[3];\n} PID_Parameters;\n\nstatic PID_Parameters g_pidConfigs[MAX_PID_CONTROLLERS];\n\nvoid initPIDControllers() {\n    for (int i = 0; i < MAX_PID_CONTROLLERS; ++i) {\n        g_pidConfigs[i].Kp = 0.0f;\n        g_pidConfigs[i].Ki = 0.0f;\n        g_pidConfigs[i].Kd = 0.0f;\n        g_pidConfigs[i].min_output = 0;\n        g_pidConfigs[i].max_output = 0;\n        g_pidConfigs[i].loop_status = 0;\n        memset(g_pidConfigs[i].reserved, 0, sizeof(g_pidConfigs[i].reserved));\n    }\n}\n\nint updatePIDParameter(const uint8_t* msg_data, uint16_t msg_len) {\n    if (msg_data == NULL || msg_len < 3) {\n        return -1;\n    }\n\n    uint8_t controller_id = msg_data[0];\n    uint8_t parameter_offset_bytes = msg_data[1];\n    uint16_t data_value_len = msg_len - 2;\n\n    if (controller_id >= MAX_PID_CONTROLLERS) {\n        return -2;\n    }\n\n    if ((uint16_t)parameter_offset_bytes + data_value_len > PID_PARAM_SET_SIZE) {\n        return -3;\n    }\n\n    memcpy((uint8_t*)&g_pidConfigs[controller_id] + parameter_offset_bytes, msg_data + 2, data_value_len);\n\n    return 0;\n}\n\nvoid handleVehicleConfigMessage(const uint8_t* network_data, uint16_t network_len) {\n    if (network_len < 3) {\n        return;\n    }\n    updatePIDParameter(network_data, network_len);\n}\n\nfloat getPIDKp(uint8_t id) {\n    if (id < MAX_PID_CONTROLLERS) {\n        return g_pidConfigs[id].Kp;\n    }\n    return 0.0f;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_FEATURES 10\n#define CONFIG_STORAGE_BUFFER_SIZE (MAX_CONFIG_FEATURES * sizeof(FeatureConfig))\n\n// Structure for a single feature configuration, representing a calibration or setting.\ntypedef struct {\n    uint16_t feature_id;\n    uint8_t  config_value;\n} FeatureConfig;\n\n// Global buffer to store parsed feature configurations for an ECU module.\nstatic FeatureConfig g_featureConfigStorage[MAX_CONFIG_FEATURES];\nstatic uint8_t g_currentFeatureCount = 0;\n\n// Initializes the feature configuration storage.\nvoid initFeatureConfigStorage() {\n    memset(g_featureConfigStorage, 0, CONFIG_STORAGE_BUFFER_SIZE);\n    g_currentFeatureCount = 0;\n}\n\n// Parses a received configuration data block from an external source (e.g., diagnostic tool or bootloader).\n// The format of 'raw_data_block' is expected to be:\n// [uint8_t magic_byte] [uint8_t num_entries] [entry1_id_high] [entry1_id_low] [entry1_value] ...\n// Each entry is 3 bytes (2 for ID, 1 for value).\nint parseConfigDataBlock(const uint8_t* raw_data_block, uint16_t block_len) {\n    if (raw_data_block == NULL || block_len < 2) {\n        return -1; // Invalid input: NULL block or too short for header\n    }\n\n    if (raw_data_block[0] != 0xAC) {\n        return -2; // Invalid magic byte: Not a recognized config block\n    }\n\n    uint8_t num_entries_from_stream = raw_data_block[1];\n    \n    // Calculate the total expected length based on the number of entries declared in the stream.\n    uint16_t expected_data_len = 2 + (num_entries_from_stream * (sizeof(uint16_t) + sizeof(uint8_t)));\n\n    // Check if the provided 'block_len' is sufficient for the declared number of entries.\n    // VULNERABILITY: This check ensures the input buffer is large enough, but does NOT\n    // ensure that 'num_entries_from_stream' itself does not exceed 'MAX_CONFIG_FEATURES'.\n    // If num_entries_from_stream is > MAX_CONFIG_FEATURES, the loop below will write out of bounds.\n    if (expected_data_len > block_len) {\n        return -3; // Data block too short for declared entries\n    }\n\n    uint16_t current_read_offset = 2; // Start reading data after magic byte and num_entries\n\n    // Reset current feature count for new block processing\n    g_currentFeatureCount = 0;\n\n    // Iterate through each declared entry in the data block.\n    for (uint8_t i = 0; i < num_entries_from_stream; ++i) {\n        // Ensure there's enough remaining data in the block for the current entry.\n        if (current_read_offset + sizeof(FeatureConfig) > block_len) {\n            return -4; // Malformed data: insufficient bytes for an entry\n        }\n\n        // Read feature_id (uint16_t, assumed big-endian for simplicity).\n        // VULNERABILITY HERE: If 'i' exceeds MAX_CONFIG_FEATURES, this access is out-of-bounds.\n        g_featureConfigStorage[i].feature_id = ((uint16_t)raw_data_block[current_read_offset] << 8) | raw_data_block[current_read_offset + 1];\n        current_read_offset += 2;\n\n        // Read config_value (uint8_t).\n        g_featureConfigStorage[i].config_value = raw_data_block[current_read_offset];\n        current_read_offset += 1;\n\n        g_currentFeatureCount++; // Increment count of processed features\n    }\n\n    return 0; // Successfully processed the configuration block\n}\n\n// Example usage in an automotive context\nvoid loadVehicleSpecificConfigs(const uint8_t* config_stream, uint16_t stream_size) {\n    initFeatureConfigStorage();\n    parseConfigDataBlock(config_stream, stream_size);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_FEATURES 10\n#define CONFIG_STORAGE_BUFFER_SIZE (MAX_CONFIG_FEATURES * sizeof(FeatureConfig))\n\n// Structure for a single feature configuration, representing a calibration or setting.\ntypedef struct {\n    uint16_t feature_id;\n    uint8_t  config_value;\n} FeatureConfig;\n\n// Global buffer to store parsed feature configurations for an ECU module.\nstatic FeatureConfig g_featureConfigStorage[MAX_CONFIG_FEATURES];\nstatic uint8_t g_currentFeatureCount = 0;\n\n// Initializes the feature configuration storage.\nvoid initFeatureConfigStorage() {\n    memset(g_featureConfigStorage, 0, CONFIG_STORAGE_BUFFER_SIZE);\n    g_currentFeatureCount = 0;\n}\n\n// Parses a received configuration data block from an external source (e.g., diagnostic tool or bootloader).\n// The format of 'raw_data_block' is expected to be:\n// [uint8_t magic_byte] [uint8_t num_entries] [entry1_id_high] [entry1_id_low] [entry1_value] ...\n// Each entry is 3 bytes (2 for ID, 1 for value).\nint parseConfigDataBlock(const uint8_t* raw_data_block, uint16_t block_len) {\n    if (raw_data_block == NULL || block_len < 2) {\n        return -1; // Invalid input: NULL block or too short for header\n    }\n\n    if (raw_data_block[0] != 0xAC) {\n        return -2; // Invalid magic byte: Not a recognized config block\n    }\n\n    uint8_t num_entries_from_stream = raw_data_block[1];\n\n    // FIX: Add bounds check for the number of entries against the internal buffer capacity.\n    // This prevents an attacker from causing an out-of-bounds write by specifying too many entries.\n    if (num_entries_from_stream > MAX_CONFIG_FEATURES) {\n        return -5; // Too many entries for internal storage capacity\n    }\n    \n    // Calculate the total expected length based on the number of entries declared in the stream.\n    uint16_t expected_data_len = 2 + (num_entries_from_stream * (sizeof(uint16_t) + sizeof(uint8_t)));\n\n    // Check if the provided 'block_len' is sufficient for the declared number of entries.\n    if (expected_data_len > block_len) {\n        return -3; // Data block too short for declared entries\n    }\n\n    uint16_t current_read_offset = 2; // Start reading data after magic byte and num_entries\n\n    // Reset current feature count for new block processing\n    g_currentFeatureCount = 0;\n\n    // Iterate through each declared entry in the data block.\n    // The loop bound 'num_entries_from_stream' is now guaranteed not to exceed MAX_CONFIG_FEATURES.\n    for (uint8_t i = 0; i < num_entries_from_stream; ++i) {\n        // Ensure there's enough remaining data in the block for the current entry.\n        if (current_read_offset + sizeof(FeatureConfig) > block_len) {\n            return -4; // Malformed data: insufficient bytes for an entry\n        }\n\n        // Read feature_id (uint16_t, assumed big-endian for simplicity).\n        g_featureConfigStorage[i].feature_id = ((uint16_t)raw_data_block[current_read_offset] << 8) | raw_data_block[current_read_offset + 1];\n        current_read_offset += 2;\n\n        // Read config_value (uint8_t).\n        g_featureConfigStorage[i].config_value = raw_data_block[current_read_offset];\n        current_read_offset += 1;\n\n        g_currentFeatureCount++; // Increment count of processed features\n    }\n\n    return 0; // Successfully processed the configuration block\n}\n\n// Example usage in an automotive context\nvoid loadVehicleSpecificConfigs(const uint8_t* config_stream, uint16_t stream_size) {\n    initFeatureConfigStorage();\n    parseConfigDataBlock(config_stream, stream_size);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define CONFIG_TABLE_SIZE 256 \n\nstatic uint8_t g_configTable[CONFIG_TABLE_SIZE];\n\ntypedef enum {\n    CFG_TYPE_UINT8 = 0,\n    CFG_TYPE_UINT16,\n    CFG_TYPE_UINT32,\n    CFG_TYPE_MAX\n} ConfigDataType;\n\nstatic uint8_t getConfigTypeSize(ConfigDataType type) {\n    switch (type) {\n        case CFG_TYPE_UINT8:  return 1;\n        case CFG_TYPE_UINT16: return 2;\n        case CFG_TYPE_UINT32: return 4;\n        default: return 0;\n    }\n}\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t offset;\n    ConfigDataType data_type;\n} ConfigEntryDescriptor;\n\nstatic const ConfigEntryDescriptor g_cfgDescriptors[] = {\n    {0x1001, 0, CFG_TYPE_UINT16},\n    {0x1002, 2, CFG_TYPE_UINT8},\n    {0x1003, 3, CFG_TYPE_UINT32},\n    {0x1004, 7, CFG_TYPE_UINT16},\n    {0x2001, 200, CFG_TYPE_UINT8},\n    {0x2002, 250, CFG_TYPE_UINT16}\n};\n#define NUM_CFG_ENTRIES (sizeof(g_cfgDescriptors) / sizeof(ConfigEntryDescriptor))\n\nvoid initConfigTable() {\n    memset(g_configTable, 0, CONFIG_TABLE_SIZE);\n}\n\nint updateConfigEntryValue(uint16_t entry_id, const uint8_t* new_value_bytes, uint8_t max_value_len) {\n    if (new_value_bytes == NULL || max_value_len == 0) {\n        return -1;\n    }\n\n    const ConfigEntryDescriptor* target_entry = NULL;\n    for (int i = 0; i < NUM_CFG_ENTRIES; ++i) {\n        if (g_cfgDescriptors[i].entry_id == entry_id) {\n            target_entry = &g_cfgDescriptors[i];\n            break;\n        }\n    }\n\n    if (target_entry == NULL) {\n        return -2;\n    }\n\n    uint8_t required_size = getConfigTypeSize(target_entry->data_type);\n\n    if (required_size == 0 || required_size > max_value_len) {\n        return -3;\n    }\n\n    switch (target_entry->data_type) {\n        case CFG_TYPE_UINT8:\n            g_configTable[target_entry->offset] = new_value_bytes[0];\n            break;\n        case CFG_TYPE_UINT16:\n            // Vulnerability: If target_entry->offset + required_size (2) exceeds CONFIG_TABLE_SIZE,\n            // this direct pointer cast will write out of bounds. For example, if target_entry->offset is 255,\n            // and data_type is CFG_TYPE_UINT16, it attempts to write to g_configTable[255] and g_configTable[256],\n            // causing an overflow. The static definition g_cfgDescriptors includes such a case (0x2002).\n            *(uint16_t*)(g_configTable + target_entry->offset) = *(uint16_t*)new_value_bytes;\n            break;\n        case CFG_TYPE_UINT32:\n            *(uint32_t*)(g_configTable + target_entry->offset) = *(uint32_t*)new_value_bytes;\n            break;\n        default:\n            return -4;\n    }\n\n    return 0;\n}\n\nvoid simulateConfigUpdate(uint16_t id, const uint8_t* data, uint8_t len) {\n    updateConfigEntryValue(id, data, len);\n}\n\nuint8_t getConfigByte(uint16_t offset) {\n    if (offset < CONFIG_TABLE_SIZE) {\n        return g_configTable[offset];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define CONFIG_TABLE_SIZE 256 \n\nstatic uint8_t g_configTable[CONFIG_TABLE_SIZE];\n\ntypedef enum {\n    CFG_TYPE_UINT8 = 0,\n    CFG_TYPE_UINT16,\n    CFG_TYPE_UINT32,\n    CFG_TYPE_MAX\n} ConfigDataType;\n\nstatic uint8_t getConfigTypeSize(ConfigDataType type) {\n    switch (type) {\n        case CFG_TYPE_UINT8:  return 1;\n        case CFG_TYPE_UINT16: return 2;\n        case CFG_TYPE_UINT32: return 4;\n        default: return 0;\n    }\n}\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t offset;\n    ConfigDataType data_type;\n} ConfigEntryDescriptor;\n\nstatic const ConfigEntryDescriptor g_cfgDescriptors[] = {\n    {0x1001, 0, CFG_TYPE_UINT16},\n    {0x1002, 2, CFG_TYPE_UINT8},\n    {0x1003, 3, CFG_TYPE_UINT32},\n    {0x1004, 7, CFG_TYPE_UINT16},\n    {0x2001, 200, CFG_TYPE_UINT8},\n    {0x2002, 250, CFG_TYPE_UINT16}\n};\n#define NUM_CFG_ENTRIES (sizeof(g_cfgDescriptors) / sizeof(ConfigEntryDescriptor))\n\nvoid initConfigTable() {\n    memset(g_configTable, 0, CONFIG_TABLE_SIZE);\n}\n\nint updateConfigEntryValue(uint16_t entry_id, const uint8_t* new_value_bytes, uint8_t max_value_len) {\n    if (new_value_bytes == NULL || max_value_len == 0) {\n        return -1;\n    }\n\n    const ConfigEntryDescriptor* target_entry = NULL;\n    for (int i = 0; i < NUM_CFG_ENTRIES; ++i) {\n        if (g_cfgDescriptors[i].entry_id == entry_id) {\n            target_entry = &g_cfgDescriptors[i];\n            break;\n        }\n    }\n\n    if (target_entry == NULL) {\n        return -2;\n    }\n\n    uint8_t required_size = getConfigTypeSize(target_entry->data_type);\n\n    if (required_size == 0 || required_size > max_value_len) {\n        return -3;\n    }\n\n    // FIX: Add a bounds check to ensure the entire write operation stays within CONFIG_TABLE_SIZE.\n    // This prevents an out-of-bounds write if target_entry->offset + required_size exceeds the buffer's capacity.\n    if ((uint32_t)target_entry->offset + required_size > CONFIG_TABLE_SIZE) {\n        return -5; // Data would write out of bounds\n    }\n\n    switch (target_entry->data_type) {\n        case CFG_TYPE_UINT8:\n            g_configTable[target_entry->offset] = new_value_bytes[0];\n            break;\n        case CFG_TYPE_UINT16:\n            *(uint16_t*)(g_configTable + target_entry->offset) = *(uint16_t*)new_value_bytes;\n            break;\n        case CFG_TYPE_UINT32:\n            *(uint32_t*)(g_configTable + target_entry->offset) = *(uint32_t*)new_value_bytes;\n            break;\n        default:\n            return -4;\n    }\n\n    return 0;\n}\n\nvoid simulateConfigUpdate(uint16_t id, const uint8_t* data, uint8_t len) {\n    updateConfigEntryValue(id, data, len);\n}\n\nuint8_t getConfigByte(uint16_t offset) {\n    if (offset < CONFIG_TABLE_SIZE) {\n        return g_configTable[offset];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_MESSAGE_SIZE 256\n#define VEHICLE_ID_BUFFER_SIZE 32\n#define CALIBRATION_VERSION_BUFFER_SIZE 16\n\nstatic char g_vehicleIdentifier[VEHICLE_ID_BUFFER_SIZE];\nstatic char g_calibrationVersion[CALIBRATION_VERSION_BUFFER_SIZE];\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_length;\n} DiagnosticRecordHeader;\n\ntypedef enum {\n    RECORD_TYPE_INVALID = 0,\n    RECORD_TYPE_VEHICLE_ID = 1,\n    RECORD_TYPE_CALIBRATION_VERSION = 2,\n    RECORD_TYPE_STATUS_CODE = 3\n} DiagnosticRecordType;\n\nvoid initVehicleInfoStore() {\n    memset(g_vehicleIdentifier, 0, VEHICLE_ID_BUFFER_SIZE);\n    memset(g_calibrationVersion, 0, CALIBRATION_VERSION_BUFFER_SIZE);\n}\n\nint processDiagnosticInfoMessage(const uint8_t* message, uint16_t message_len) {\n    if (message == NULL || message_len < sizeof(DiagnosticRecordHeader)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    while (current_offset + sizeof(DiagnosticRecordHeader) <= message_len) {\n        const DiagnosticRecordHeader* header = (const DiagnosticRecordHeader*)(message + current_offset);\n        \n        uint8_t type = header->record_type;\n        uint8_t length = header->record_length;\n\n        if (current_offset + sizeof(DiagnosticRecordHeader) + length > message_len) {\n            return -2;\n        }\n\n        const uint8_t* data_ptr = message + current_offset + sizeof(DiagnosticRecordHeader);\n\n        switch (type) {\n            case RECORD_TYPE_VEHICLE_ID: {\n                for (uint8_t i = 0; i < length; ++i) {\n                    g_vehicleIdentifier[i] = data_ptr[i];\n                }\n                if (length < VEHICLE_ID_BUFFER_SIZE) {\n                    g_vehicleIdentifier[length] = '\\0';\n                }\n                break;\n            }\n            case RECORD_TYPE_CALIBRATION_VERSION: {\n                for (uint8_t i = 0; i < length; ++i) {\n                    g_calibrationVersion[i] = data_ptr[i];\n                }\n                if (length < CALIBRATION_VERSION_BUFFER_SIZE) {\n                    g_calibrationVersion[length] = '\\0';\n                }\n                break;\n            }\n            case RECORD_TYPE_STATUS_CODE: {\n                if (length != sizeof(uint16_t)) return -3;\n                break;\n            }\n            default:\n                break;\n        }\n\n        current_offset += sizeof(DiagnosticRecordHeader) + length;\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticMessage(const uint8_t* msg_data, uint16_t msg_len) {\n    initVehicleInfoStore();\n    processDiagnosticInfoMessage(msg_data, msg_len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_MESSAGE_SIZE 256\n#define VEHICLE_ID_BUFFER_SIZE 32\n#define CALIBRATION_VERSION_BUFFER_SIZE 16\n\nstatic char g_vehicleIdentifier[VEHICLE_ID_BUFFER_SIZE];\nstatic char g_calibrationVersion[CALIBRATION_VERSION_BUFFER_SIZE];\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_length;\n} DiagnosticRecordHeader;\n\ntypedef enum {\n    RECORD_TYPE_INVALID = 0,\n    RECORD_TYPE_VEHICLE_ID = 1,\n    RECORD_TYPE_CALIBRATION_VERSION = 2,\n    RECORD_TYPE_STATUS_CODE = 3\n} DiagnosticRecordType;\n\nvoid initVehicleInfoStore() {\n    memset(g_vehicleIdentifier, 0, VEHICLE_ID_BUFFER_SIZE);\n    memset(g_calibrationVersion, 0, CALIBRATION_VERSION_BUFFER_SIZE);\n}\n\nint processDiagnosticInfoMessage(const uint8_t* message, uint16_t message_len) {\n    if (message == NULL || message_len < sizeof(DiagnosticRecordHeader)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    while (current_offset + sizeof(DiagnosticRecordHeader) <= message_len) {\n        const DiagnosticRecordHeader* header = (const DiagnosticRecordHeader*)(message + current_offset);\n        \n        uint8_t type = header->record_type;\n        uint8_t length = header->record_length;\n\n        if (current_offset + sizeof(DiagnosticRecordHeader) + length > message_len) {\n            return -2;\n        }\n\n        const uint8_t* data_ptr = message + current_offset + sizeof(DiagnosticRecordHeader);\n\n        switch (type) {\n            case RECORD_TYPE_VEHICLE_ID: {\n                uint8_t bytes_to_copy = length;\n                if (bytes_to_copy >= VEHICLE_ID_BUFFER_SIZE) {\n                    bytes_to_copy = VEHICLE_ID_BUFFER_SIZE - 1;\n                }\n                for (uint8_t i = 0; i < bytes_to_copy; ++i) {\n                    g_vehicleIdentifier[i] = data_ptr[i];\n                }\n                g_vehicleIdentifier[bytes_to_copy] = '\\0';\n                break;\n            }\n            case RECORD_TYPE_CALIBRATION_VERSION: {\n                uint8_t bytes_to_copy = length;\n                if (bytes_to_copy >= CALIBRATION_VERSION_BUFFER_SIZE) {\n                    bytes_to_copy = CALIBRATION_VERSION_BUFFER_SIZE - 1;\n                }\n                for (uint8_t i = 0; i < bytes_to_copy; ++i) {\n                    g_calibrationVersion[i] = data_ptr[i];\n                }\n                g_calibrationVersion[bytes_to_copy] = '\\0';\n                break;\n            }\n            case RECORD_TYPE_STATUS_CODE: {\n                if (length != sizeof(uint16_t)) return -3;\n                break;\n            }\n            default:\n                break;\n        }\n\n        current_offset += sizeof(DiagnosticRecordHeader) + length;\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticMessage(const uint8_t* msg_data, uint16_t msg_len) {\n    initVehicleInfoStore();\n    processDiagnosticInfoMessage(msg_data, msg_len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_TELEMETRY_PACKET_SIZE   2000 \n#define SENSOR_DATA_ENTRY_SIZE      12   \n#define MAX_INTERNAL_SENSOR_ENTRIES 40   \n#define TELEMETRY_DATA_BUFFER_SIZE  (MAX_INTERNAL_SENSOR_ENTRIES * SENSOR_DATA_ENTRY_SIZE) \n\nstatic uint8_t g_aggregatedSensorData[TELEMETRY_DATA_BUFFER_SIZE]; \n\ntypedef struct {\n    uint16_t packet_id;\n    uint8_t  num_sensor_entries; \n    uint8_t  _reserved; \n} TelemetryPacketHeader;\n\ntypedef struct {\n    uint8_t sensor_type;\n    uint16_t sensor_value;\n    uint32_t timestamp;\n    uint32_t sensor_flags;\n    uint8_t  checksum;\n} SensorDataEntry; \n\nvoid initTelemetryUnit() {\n    memset(g_aggregatedSensorData, 0, TELEMETRY_DATA_BUFFER_SIZE);\n}\n\nint processTelemetryPacket(const uint8_t* raw_packet, uint16_t packet_len) {\n    if (raw_packet == NULL || packet_len < sizeof(TelemetryPacketHeader)) {\n        return -1; \n    }\n\n    const TelemetryPacketHeader* header = (const TelemetryPacketHeader*)raw_packet;\n\n    if (header->num_sensor_entries > 60) { \n        return -2; \n    }\n\n    uint16_t expected_data_len = header->num_sensor_entries * SENSOR_DATA_ENTRY_SIZE;\n    uint16_t minimum_packet_len = sizeof(TelemetryPacketHeader) + expected_data_len;\n\n    if (packet_len < minimum_packet_len) {\n        return -3; \n    }\n\n    for (uint16_t i = 0; i < expected_data_len; ++i) {\n        g_aggregatedSensorData[i] = raw_packet[sizeof(TelemetryPacketHeader) + i];\n    }\n\n    return 0; \n}\n\nvoid receiveTelemetryUpdate(const uint8_t* data, uint16_t length) {\n    processTelemetryPacket(data, length);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_TELEMETRY_PACKET_SIZE   2000 \n#define SENSOR_DATA_ENTRY_SIZE      12   \n#define MAX_INTERNAL_SENSOR_ENTRIES 40   \n#define TELEMETRY_DATA_BUFFER_SIZE  (MAX_INTERNAL_SENSOR_ENTRIES * SENSOR_DATA_ENTRY_SIZE) \n\nstatic uint8_t g_aggregatedSensorData[TELEMETRY_DATA_BUFFER_SIZE]; \n\ntypedef struct {\n    uint16_t packet_id;\n    uint8_t  num_sensor_entries; \n    uint8_t  _reserved; \n} TelemetryPacketHeader;\n\ntypedef struct {\n    uint8_t sensor_type;\n    uint16_t sensor_value;\n    uint32_t timestamp;\n    uint32_t sensor_flags;\n    uint8_t  checksum;\n} SensorDataEntry; \n\nvoid initTelemetryUnit() {\n    memset(g_aggregatedSensorData, 0, TELEMETRY_DATA_BUFFER_SIZE);\n}\n\nint processTelemetryPacket(const uint8_t* raw_packet, uint16_t packet_len) {\n    if (raw_packet == NULL || packet_len < sizeof(TelemetryPacketHeader)) {\n        return -1; \n    }\n\n    const TelemetryPacketHeader* header = (const TelemetryPacketHeader*)raw_packet;\n\n    if (header->num_sensor_entries > MAX_INTERNAL_SENSOR_ENTRIES) { \n        return -2; \n    }\n\n    uint16_t expected_data_len = header->num_sensor_entries * SENSOR_DATA_ENTRY_SIZE;\n\n    if (expected_data_len > TELEMETRY_DATA_BUFFER_SIZE) { \n        return -3; \n    }\n\n    uint16_t minimum_packet_len = sizeof(TelemetryPacketHeader) + expected_data_len;\n\n    if (packet_len < minimum_packet_len) {\n        return -4; \n    }\n\n    for (uint16_t i = 0; i < expected_data_len; ++i) {\n        g_aggregatedSensorData[i] = raw_packet[sizeof(TelemetryPacketHeader) + i];\n    }\n\n    return 0; \n}\n\nvoid receiveTelemetryUpdate(const uint8_t* data, uint16_t length) {\n    processTelemetryPacket(data, length);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define VCU_PARAM_STAGE_BUFFER_SIZE 256\nstatic uint8_t g_vcuParamStageBuffer[VCU_PARAM_STAGE_BUFFER_SIZE];\nstatic uint16_t g_currentStagedParamOffset = 0;\n\ntypedef struct {\n    uint8_t paramId;\n    uint16_t valueOffset;\n    uint8_t valueLength;\n} VcuParameterEntry;\n\n#define MAX_VCU_PARAM_ENTRIES 10\nstatic VcuParameterEntry g_vcuParamTable[MAX_VCU_PARAM_ENTRIES];\nstatic uint8_t g_numVcuParamEntries = 0;\n\nvoid initVcuParamStaging() {\n    memset(g_vcuParamStageBuffer, 0, VCU_PARAM_STAGE_BUFFER_SIZE);\n    g_currentStagedParamOffset = 0;\n    g_numVcuParamEntries = 0;\n}\n\nint processVcuParameterUpdateStream(const uint8_t* update_stream, uint16_t stream_len) {\n    if (update_stream == NULL || stream_len < 2) {\n        return -1;\n    }\n\n    uint16_t current_stream_pos = 0;\n    g_currentStagedParamOffset = 0;\n\n    while (current_stream_pos < stream_len) {\n        if (current_stream_pos + 2 > stream_len) {\n            return -2;\n        }\n\n        uint8_t param_id = update_stream[current_stream_pos++];\n        uint8_t value_len = update_stream[current_stream_pos++];\n\n        if (current_stream_pos + value_len > stream_len) {\n            return -3;\n        }\n\n        if (g_numVcuParamEntries >= MAX_VCU_PARAM_ENTRIES) {\n            return -4;\n        }\n\n        g_vcuParamTable[g_numVcuParamEntries].paramId = param_id;\n        g_vcuParamTable[g_numVcuParamEntries].valueOffset = g_currentStagedParamOffset;\n        g_vcuParamTable[g_numVcuParamEntries].valueLength = value_len;\n\n        for (uint8_t i = 0; i < value_len; ++i) {\n            g_vcuParamStageBuffer[g_currentStagedParamOffset + i] = update_stream[current_stream_pos + i];\n        }\n\n        g_currentStagedParamOffset += value_len;\n        current_stream_pos += value_len;\n        g_numVcuParamEntries++;\n    }\n\n    return 0;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define VCU_PARAM_STAGE_BUFFER_SIZE 256\nstatic uint8_t g_vcuParamStageBuffer[VCU_PARAM_STAGE_BUFFER_SIZE];\nstatic uint16_t g_currentStagedParamOffset = 0;\n\ntypedef struct {\n    uint8_t paramId;\n    uint16_t valueOffset;\n    uint8_t valueLength;\n} VcuParameterEntry;\n\n#define MAX_VCU_PARAM_ENTRIES 10\nstatic VcuParameterEntry g_vcuParamTable[MAX_VCU_PARAM_ENTRIES];\nstatic uint8_t g_numVcuParamEntries = 0;\n\nvoid initVcuParamStaging() {\n    memset(g_vcuParamStageBuffer, 0, VCU_PARAM_STAGE_BUFFER_SIZE);\n    g_currentStagedParamOffset = 0;\n    g_numVcuParamEntries = 0;\n}\n\nint processVcuParameterUpdateStream(const uint8_t* update_stream, uint16_t stream_len) {\n    if (update_stream == NULL || stream_len < 2) {\n        return -1;\n    }\n\n    uint16_t current_stream_pos = 0;\n    g_currentStagedParamOffset = 0;\n\n    while (current_stream_pos < stream_len) {\n        if (current_stream_pos + 2 > stream_len) {\n            return -2;\n        }\n\n        uint8_t param_id = update_stream[current_stream_pos++];\n        uint8_t value_len = update_stream[current_stream_pos++];\n\n        if (current_stream_pos + value_len > stream_len) {\n            return -3;\n        }\n\n        if (g_numVcuParamEntries >= MAX_VCU_PARAM_ENTRIES) {\n            return -4;\n        }\n\n        if ((uint16_t)g_currentStagedParamOffset + value_len > VCU_PARAM_STAGE_BUFFER_SIZE) {\n            return -5;\n        }\n\n        g_vcuParamTable[g_numVcuParamEntries].paramId = param_id;\n        g_vcuParamTable[g_numVcuParamEntries].valueOffset = g_currentStagedParamOffset;\n        g_vcuParamTable[g_numVcuParamEntries].valueLength = value_len;\n\n        for (uint8_t i = 0; i < value_len; ++i) {\n            g_vcuParamStageBuffer[g_currentStagedParamOffset + i] = update_stream[current_stream_pos + i];\n        }\n\n        g_currentStagedParamOffset += value_len;\n        current_stream_pos += value_len;\n        g_numVcuParamEntries++;\n    }\n\n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n// Define maximum sizes for different types of recorded data\n#define VEHICLE_EVENTS_MAX_ENTRIES 50\n#define EVENT_ENTRY_SIZE_BYTES 12 // Each event entry is 12 bytes\n#define DIAG_SNAPSHOTS_MAX_ENTRIES 10\n#define SNAPSHOT_ENTRY_SIZE_BYTES 32 // Each snapshot entry is 32 bytes\n#define USER_LOGS_MAX_ENTRIES 20\n#define USER_LOG_ENTRY_SIZE_BYTES 8 // Each user log entry is 8 bytes\n\n// Total buffer size for all recorded data, ensuring contiguous allocation\n#define TOTAL_RECORDER_BUFFER_SIZE \\\n    (VEHICLE_EVENTS_MAX_ENTRIES * EVENT_ENTRY_SIZE_BYTES + \\\n     DIAG_SNAPSHOTS_MAX_ENTRIES * SNAPSHOT_ENTRY_SIZE_BYTES + \\\n     USER_LOGS_MAX_ENTRIES * USER_LOG_ENTRY_SIZE_BYTES)\n\n// Global buffer where all VDR data is stored contiguously\nstatic uint8_t g_vdrDataBuffer[TOTAL_RECORDER_BUFFER_SIZE];\n\n// Enums for different data types, mapping to specific segments within the global buffer\ntypedef enum {\n    VDR_DATA_TYPE_VEHICLE_EVENTS = 0,\n    VDR_DATA_TYPE_DIAG_SNAPSHOTS,\n    VDR_DATA_TYPE_USER_LOGS,\n    VDR_DATA_TYPE_COUNT // Total number of distinct VDR data types\n} VDRDataType;\n\n// Structure to define segments within the global VDR buffer\ntypedef struct {\n    uint16_t base_offset;      // Start offset of this data type's segment in g_vdrDataBuffer\n    uint16_t entry_size;       // Size of a single entry for this data type\n    uint16_t max_entries;      // Maximum number of entries for this data type in its segment\n    uint16_t current_entries;  // Current number of entries stored for this data type\n} VDRSegmentInfo;\n\n// Array of segment information, one for each VDRDataType\nstatic VDRSegmentInfo g_vdrSegments[VDR_DATA_TYPE_COUNT];\n\n// Initializes the VDR system and configures segment offsets and sizes\nvoid initVDRSystem() {\n    memset(g_vdrDataBuffer, 0, TOTAL_RECORDER_BUFFER_SIZE);\n\n    uint16_t current_offset = 0;\n\n    // Initialize VEHICLE_EVENTS segment\n    g_vdrSegments[VDR_DATA_TYPE_VEHICLE_EVENTS].base_offset = current_offset;\n    g_vdrSegments[VDR_DATA_TYPE_VEHICLE_EVENTS].entry_size = EVENT_ENTRY_SIZE_BYTES;\n    g_vdrSegments[VDR_DATA_TYPE_VEHICLE_EVENTS].max_entries = VEHICLE_EVENTS_MAX_ENTRIES;\n    g_vdrSegments[VDR_DATA_TYPE_VEHICLE_EVENTS].current_entries = 0;\n    current_offset += VEHICLE_EVENTS_MAX_ENTRIES * EVENT_ENTRY_SIZE_BYTES;\n\n    // Initialize DIAG_SNAPSHOTS segment\n    g_vdrSegments[VDR_DATA_TYPE_DIAG_SNAPSHOTS].base_offset = current_offset;\n    g_vdrSegments[VDR_DATA_TYPE_DIAG_SNAPSHOTS].entry_size = SNAPSHOT_ENTRY_SIZE_BYTES;\n    g_vdrSegments[VDR_DATA_TYPE_DIAG_SNAPSHOTS].max_entries = DIAG_SNAPSHOTS_MAX_ENTRIES;\n    g_vdrSegments[VDR_DATA_TYPE_DIAG_SNAPSHOTS].current_entries = 0;\n    current_offset += DIAG_SNAPSHOTS_MAX_ENTRIES * SNAPSHOT_ENTRY_SIZE_BYTES;\n\n    // Initialize USER_LOGS segment\n    g_vdrSegments[VDR_DATA_TYPE_USER_LOGS].base_offset = current_offset;\n    g_vdrSegments[VDR_DATA_TYPE_USER_LOGS].entry_size = USER_LOG_ENTRY_SIZE_BYTES;\n    g_vdrSegments[VDR_DATA_TYPE_USER_LOGS].max_entries = USER_LOGS_MAX_ENTRIES;\n    g_vdrSegments[VDR_DATA_TYPE_USER_LOGS].current_entries = 0;\n    // current_offset += USER_LOGS_MAX_ENTRIES * USER_LOG_ENTRY_SIZE_BYTES; // Final offset not needed\n}\n\n// Stores event data into the appropriate VDR segment based on type and index.\n// type: The VDRDataType indicating which segment to target.\n// entry_index: The specific entry slot within that data type's segment.\n// data: Pointer to the raw data payload to store.\n// data_len: The actual length of the raw data payload.\nint storeVDRDataEntry(VDRDataType type, uint16_t entry_index, const uint8_t* data, uint16_t data_len) {\n    if (type >= VDR_DATA_TYPE_COUNT || data == NULL) {\n        return -1; // Invalid type or data pointer\n    }\n\n    VDRSegmentInfo* segment = &g_vdrSegments[type];\n\n    // Check if the entry_index is valid for this segment's allocated entries\n    if (entry_index >= segment->max_entries) {\n        return -2; // Entry index out of bounds for this specific segment\n    }\n\n    // Calculate the absolute start offset for the target entry within the global buffer\n    uint16_t target_global_offset = segment->base_offset + (entry_index * segment->entry_size);\n\n    // VULNERABILITY:\n    // This check validates `data_len` against the `TOTAL_RECORDER_BUFFER_SIZE`,\n    // which is a common but insufficient check. It does NOT ensure that `data_len`\n    // fits within the specific `segment->entry_size` of the target slot.\n    // An attacker can provide a `data_len` greater than `segment->entry_size` (e.g., 15 bytes for an 8-byte log entry)\n    // but still less than `TOTAL_RECORDER_BUFFER_SIZE`, leading to an out-of-bounds write\n    // into the subsequent entry's memory, or even into a different segment.\n    if (data_len > TOTAL_RECORDER_BUFFER_SIZE) { \n        return -3; // Data length too large for the entire recorder buffer (overall check)\n    }\n\n    // The loop iterates `data_len` times. If `data_len` is greater than `segment->entry_size`,\n    // it will write past the end of the intended entry slot.\n    for (uint16_t i = 0; i < data_len; ++i) {\n        g_vdrDataBuffer[target_global_offset + i] = data[i];\n    }\n    \n    // Update current_entries. This is a simplistic update; an overflow could still\n    // cause data corruption in a way that this count doesn't directly reflect.\n    if (entry_index >= segment->current_entries) {\n        segment->current_entries = entry_index + 1;\n    }\n\n    return 0; // Success\n}\n\n// Example usage context to demonstrate the vulnerability\nvoid recordVehicleDiagnostics() {\n    initVDRSystem();\n\n    // Store a legitimate vehicle event (12 bytes)\n    uint8_t event_data[EVENT_ENTRY_SIZE_BYTES];\n    memset(event_data, 0x11, EVENT_ENTRY_SIZE_BYTES);\n    storeVDRDataEntry(VDR_DATA_TYPE_VEHICLE_EVENTS, 0, event_data, EVENT_ENTRY_SIZE_BYTES);\n\n    // Store a legitimate diagnostic snapshot (32 bytes)\n    uint8_t snapshot_data[SNAPSHOT_ENTRY_SIZE_BYTES];\n    memset(snapshot_data, 0x22, SNAPSHOT_ENTRY_SIZE_BYTES);\n    storeVDRDataEntry(VDR_DATA_TYPE_DIAG_SNAPSHOTS, 0, snapshot_data, SNAPSHOT_ENTRY_SIZE_BYTES);\n\n    // Simulate an attacker providing overly long data for a smaller slot.\n    // USER_LOG_ENTRY_SIZE_BYTES is 8 bytes.\n    // By providing 15 bytes, the extra 7 bytes will overflow into the next user log entry slot.\n    uint8_t malicious_log_data[15]; \n    memset(malicious_log_data, 0xEE, 15); // Fill with attacker-controlled data\n    // This call is vulnerable: `data_len` (15) > `USER_LOG_ENTRY_SIZE_BYTES` (8)\n    // The check `data_len > TOTAL_RECORDER_BUFFER_SIZE` passes, but it overflows the specific 8-byte slot.\n    storeVDRDataEntry(VDR_DATA_TYPE_USER_LOGS, 0, malicious_log_data, 15);\n\n    // Even if we try to write a legitimate log entry next, its data might be partially corrupted\n    // by the previous overflow from the 'malicious_log_data'.\n    uint8_t legit_log_data[USER_LOG_ENTRY_SIZE_BYTES];\n    memset(legit_log_data, 0xAA, USER_LOG_ENTRY_SIZE_BYTES);\n    storeVDRDataEntry(VDR_DATA_TYPE_USER_LOGS, 1, legit_log_data, USER_LOG_ENTRY_SIZE_BYTES);\n}\n\n// Helper function to retrieve data for verification (not part of vulnerability)\nuint8_t retrieveVDRDataByte(VDRDataType type, uint16_t entry_index, uint16_t offset_in_entry) {\n    if (type >= VDR_DATA_TYPE_COUNT || entry_index >= g_vdrSegments[type].max_entries || offset_in_entry >= g_vdrSegments[type].entry_size) {\n        return 0x00; // Invalid access or out of bounds for the logical entry\n    }\n    uint16_t global_offset = g_vdrSegments[type].base_offset + (entry_index * g_vdrSegments[type].entry_size) + offset_in_entry;\n    if (global_offset < TOTAL_RECORDER_BUFFER_SIZE) {\n        return g_vdrDataBuffer[global_offset];\n    }\n    return 0x00; // Global buffer access out of bounds\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n// Define maximum sizes for different types of recorded data\n#define VEHICLE_EVENTS_MAX_ENTRIES 50\n#define EVENT_ENTRY_SIZE_BYTES 12 // Each event entry is 12 bytes\n#define DIAG_SNAPSHOTS_MAX_ENTRIES 10\n#define SNAPSHOT_ENTRY_SIZE_BYTES 32 // Each snapshot entry is 32 bytes\n#define USER_LOGS_MAX_ENTRIES 20\n#define USER_LOG_ENTRY_SIZE_BYTES 8 // Each user log entry is 8 bytes\n\n// Total buffer size for all recorded data, ensuring contiguous allocation\n#define TOTAL_RECORDER_BUFFER_SIZE \\\n    (VEHICLE_EVENTS_MAX_ENTRIES * EVENT_ENTRY_SIZE_BYTES + \\\n     DIAG_SNAPSHOTS_MAX_ENTRIES * SNAPSHOT_ENTRY_SIZE_BYTES + \\\n     USER_LOGS_MAX_ENTRIES * USER_LOG_ENTRY_SIZE_BYTES)\n\n// Global buffer where all VDR data is stored contiguously\nstatic uint8_t g_vdrDataBuffer[TOTAL_RECORDER_BUFFER_SIZE];\n\n// Enums for different data types, mapping to specific segments within the global buffer\ntypedef enum {\n    VDR_DATA_TYPE_VEHICLE_EVENTS = 0,\n    VDR_DATA_TYPE_DIAG_SNAPSHOTS,\n    VDR_DATA_TYPE_USER_LOGS,\n    VDR_DATA_TYPE_COUNT // Total number of distinct VDR data types\n} VDRDataType;\n\n// Structure to define segments within the global VDR buffer\ntypedef struct {\n    uint16_t base_offset;      // Start offset of this data type's segment in g_vdrDataBuffer\n    uint16_t entry_size;       // Size of a single entry for this data type\n    uint16_t max_entries;      // Maximum number of entries for this data type in its segment\n    uint16_t current_entries;  // Current number of entries stored\n} VDRSegmentInfo;\n\n// Array of segment information, one for each VDRDataType\nstatic VDRSegmentInfo g_vdrSegments[VDR_DATA_TYPE_COUNT];\n\n// Initializes the VDR system and configures segment offsets and sizes\nvoid initVDRSystem() {\n    memset(g_vdrDataBuffer, 0, TOTAL_RECORDER_BUFFER_SIZE);\n\n    uint16_t current_offset = 0;\n\n    // Initialize VEHICLE_EVENTS segment\n    g_vdrSegments[VDR_DATA_TYPE_VEHICLE_EVENTS].base_offset = current_offset;\n    g_vdrSegments[VDR_DATA_TYPE_VEHICLE_EVENTS].entry_size = EVENT_ENTRY_SIZE_BYTES;\n    g_vdrSegments[VDR_DATA_TYPE_VEHICLE_EVENTS].max_entries = VEHICLE_EVENTS_MAX_ENTRIES;\n    g_vdrSegments[VDR_DATA_TYPE_VEHICLE_EVENTS].current_entries = 0;\n    current_offset += VEHICLE_EVENTS_MAX_ENTRIES * EVENT_ENTRY_SIZE_BYTES;\n\n    // Initialize DIAG_SNAPSHOTS segment\n    g_vdrSegments[VDR_DATA_TYPE_DIAG_SNAPSHOTS].base_offset = current_offset;\n    g_vdrSegments[VDR_DATA_TYPE_DIAG_SNAPSHOTS].entry_size = SNAPSHOT_ENTRY_SIZE_BYTES;\n    g_vdrSegments[VDR_DATA_TYPE_DIAG_SNAPSHOTS].max_entries = DIAG_SNAPSHOTS_MAX_ENTRIES;\n    g_vdrSegments[VDR_DATA_TYPE_DIAG_SNAPSHOTS].current_entries = 0;\n    current_offset += DIAG_SNAPSHOTS_MAX_ENTRIES * SNAPSHOT_ENTRY_SIZE_BYTES;\n\n    // Initialize USER_LOGS segment\n    g_vdrSegments[VDR_DATA_TYPE_USER_LOGS].base_offset = current_offset;\n    g_vdrSegments[VDR_DATA_TYPE_USER_LOGS].entry_size = USER_LOG_ENTRY_SIZE_BYTES;\n    g_vdrSegments[VDR_DATA_TYPE_USER_LOGS].max_entries = USER_LOGS_MAX_ENTRIES;\n    g_vdrSegments[VDR_DATA_TYPE_USER_LOGS].current_entries = 0;\n    // current_offset += USER_LOGS_MAX_ENTRIES * USER_LOG_ENTRY_SIZE_BYTES; // Final offset not needed\n}\n\n// Stores event data into the appropriate VDR segment based on type and index.\n// type: The VDRDataType indicating which segment to target.\n// entry_index: The specific entry slot within that data type's segment.\n// data: Pointer to the raw data payload to store.\n// data_len: The actual length of the raw data payload.\nint storeVDRDataEntry(VDRDataType type, uint16_t entry_index, const uint8_t* data, uint16_t data_len) {\n    if (type >= VDR_DATA_TYPE_COUNT || data == NULL) {\n        return -1; // Invalid type or data pointer\n    }\n\n    VDRSegmentInfo* segment = &g_vdrSegments[type];\n\n    // Check if the entry_index is valid for this segment's allocated entries\n    if (entry_index >= segment->max_entries) {\n        return -2; // Entry index out of bounds for this specific segment\n    }\n\n    // FIX:\n    // Ensure `bytes_to_copy` does not exceed the `segment->entry_size`.\n    // This prevents writing past the end of the allocated slot for the specific entry.\n    uint16_t bytes_to_copy = data_len;\n    if (bytes_to_copy > segment->entry_size) {\n        bytes_to_copy = segment->entry_size; // Truncate the data to fit the allocated slot\n    }\n\n    // Calculate the absolute start offset for the target entry within the global buffer\n    uint16_t target_global_offset = segment->base_offset + (entry_index * segment->entry_size);\n\n    // Defensive check to ensure the calculated offset and length don't exceed the total buffer size.\n    // This should ideally be covered by prior checks (entry_index < max_entries and bytes_to_copy <= entry_size),\n    // but it's good practice for defense-in-depth, especially against arithmetic overflows on `target_global_offset`\n    // if `entry_index * segment->entry_size` were to become very large (though unlikely with uint16_t max values here).\n    if (target_global_offset + bytes_to_copy > TOTAL_RECORDER_BUFFER_SIZE) {\n        return -4; // Calculated write would exceed overall VDR buffer boundary\n    }\n\n    // The loop now uses `bytes_to_copy`, which is guaranteed not to exceed `segment->entry_size`,\n    // preventing out-of-bounds writes into adjacent entries or segments.\n    for (uint16_t i = 0; i < bytes_to_copy; ++i) {\n        g_vdrDataBuffer[target_global_offset + i] = data[i];\n    }\n    \n    // Update current_entries\n    if (entry_index >= segment->current_entries) {\n        segment->current_entries = entry_index + 1;\n    }\n\n    return 0; // Success\n}\n\n// Example usage context (same as vulnerable, but now safe)\nvoid recordVehicleDiagnostics() {\n    initVDRSystem();\n\n    // Store a legitimate vehicle event (12 bytes)\n    uint8_t event_data[EVENT_ENTRY_SIZE_BYTES];\n    memset(event_data, 0x11, EVENT_ENTRY_SIZE_BYTES);\n    storeVDRDataEntry(VDR_DATA_TYPE_VEHICLE_EVENTS, 0, event_data, EVENT_ENTRY_SIZE_BYTES);\n\n    // Store a legitimate diagnostic snapshot (32 bytes)\n    uint8_t snapshot_data[SNAPSHOT_ENTRY_SIZE_BYTES];\n    memset(snapshot_data, 0x22, SNAPSHOT_ENTRY_SIZE_BYTES);\n    storeVDRDataEntry(VDR_DATA_TYPE_DIAG_SNAPSHOTS, 0, snapshot_data, SNAPSHOT_ENTRY_SIZE_BYTES);\n\n    // Simulate an attacker providing overly long data for a smaller slot.\n    // USER_LOG_ENTRY_SIZE_BYTES is 8 bytes.\n    // By providing 15 bytes, the fixed code will now truncate the copy to 8 bytes,\n    // preventing the overflow into the next user log entry slot.\n    uint8_t malicious_log_data[15]; \n    memset(malicious_log_data, 0xEE, 15);\n    // This call is now safe. `data_len` (15) will be truncated to `USER_LOG_ENTRY_SIZE_BYTES` (8).\n    storeVDRDataEntry(VDR_DATA_TYPE_USER_LOGS, 0, malicious_log_data, 15);\n\n    // The next legitimate log entry will now be written to its slot without prior corruption.\n    uint8_t legit_log_data[USER_LOG_ENTRY_SIZE_BYTES];\n    memset(legit_log_data, 0xAA, USER_LOG_ENTRY_SIZE_BYTES);\n    storeVDRDataEntry(VDR_DATA_TYPE_USER_LOGS, 1, legit_log_data, USER_LOG_ENTRY_SIZE_BYTES);\n}\n\n// Helper function to retrieve data for verification (not part of vulnerability)\nuint8_t retrieveVDRDataByte(VDRDataType type, uint16_t entry_index, uint16_t offset_in_entry) {\n    if (type >= VDR_DATA_TYPE_COUNT || entry_index >= g_vdrSegments[type].max_entries || offset_in_entry >= g_vdrSegments[type].entry_size) {\n        return 0x00; // Invalid access or out of bounds for the logical entry\n    }\n    uint16_t global_offset = g_vdrSegments[type].base_offset + (entry_index * g_vdrSegments[type].entry_size) + offset_in_entry;\n    if (global_offset < TOTAL_RECORDER_BUFFER_SIZE) {\n        return g_vdrDataBuffer[global_offset];\n    }\n    return 0x00; // Global buffer access out of bounds\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define CALIBRATION_DATA_SIZE 1024\n#define MAX_CALIBRATION_PATCH_LEN 64\n\nstatic uint8_t g_vehicleCalibrationData[CALIBRATION_DATA_SIZE];\n\nvoid initCalibrationData() {\n    memset(g_vehicleCalibrationData, 0xAA, CALIBRATION_DATA_SIZE);\n}\n\nint applyCalibrationPatch(uint16_t offset, uint8_t length, const uint8_t* patch_data) {\n    if (patch_data == NULL || length == 0) {\n        return -1;\n    }\n\n    if (length > MAX_CALIBRATION_PATCH_LEN) {\n        return -2;\n    }\n\n    for (uint8_t i = 0; i < length; ++i) {\n        g_vehicleCalibrationData[offset + i] = patch_data[i];\n    }\n\n    return 0;\n}\n\nvoid receiveCalibrationCommand(uint16_t offset, uint8_t length, const uint8_t* data) {\n    applyCalibrationPatch(offset, length, data);\n}\n\nuint8_t getCalibrationByte(uint16_t index) {\n    if (index < CALIBRATION_DATA_SIZE) {\n        return g_vehicleCalibrationData[index];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define CALIBRATION_DATA_SIZE 1024\n#define MAX_CALIBRATION_PATCH_LEN 64\n\nstatic uint8_t g_vehicleCalibrationData[CALIBRATION_DATA_SIZE];\n\nvoid initCalibrationData() {\n    memset(g_vehicleCalibrationData, 0xAA, CALIBRATION_DATA_SIZE);\n}\n\nint applyCalibrationPatch(uint16_t offset, uint8_t length, const uint8_t* patch_data) {\n    if (patch_data == NULL || length == 0) {\n        return -1;\n    }\n\n    if (length > MAX_CALIBRATION_PATCH_LEN) {\n        return -2;\n    }\n\n    if (offset >= CALIBRATION_DATA_SIZE || (uint32_t)offset + length > CALIBRATION_DATA_SIZE) {\n        return -3;\n    }\n\n    for (uint8_t i = 0; i < length; ++i) {\n        g_vehicleCalibrationData[offset + i] = patch_data[i];\n    }\n\n    return 0;\n}\n\nvoid receiveCalibrationCommand(uint16_t offset, uint8_t length, const uint8_t* data) {\n    applyCalibrationPatch(offset, length, data);\n}\n\nuint8_t getCalibrationByte(uint16_t index) {\n    if (index < CALIBRATION_DATA_SIZE) {\n        return g_vehicleCalibrationData[index];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define LOG_BUFFER_SIZE 512\n#define SENSOR_READING_SIZE 2\n\nstatic uint8_t g_sensorLogBuffer[LOG_BUFFER_SIZE];\nstatic uint16_t g_logWriteCursor = 0;\n\nvoid initSensorLogger() {\n    memset(g_sensorLogBuffer, 0, LOG_BUFFER_SIZE);\n    g_logWriteCursor = 0;\n}\n\nint processSensorDataPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len < 3) {\n        return -1;\n    }\n\n    uint16_t current_packet_read_offset = 0;\n    uint8_t sensor_id = packet[current_packet_read_offset++];\n    uint16_t num_readings = (packet[current_packet_read_offset] << 8) | packet[current_packet_read_offset+1];\n    current_packet_read_offset += 2;\n\n    if (num_readings == 0) {\n        return 0;\n    }\n\n    uint16_t data_bytes_len = num_readings * SENSOR_READING_SIZE;\n\n    if (current_packet_read_offset + data_bytes_len > packet_len) {\n        return -3;\n    }\n\n    uint16_t header_size = 1 + 2;\n    uint16_t total_entry_size = header_size + data_bytes_len;\n\n    if (g_logWriteCursor + total_entry_size > LOG_BUFFER_SIZE) {\n        g_logWriteCursor = 0;\n        if (total_entry_size > LOG_BUFFER_SIZE) {\n            return -4;\n        }\n    }\n\n    g_sensorLogBuffer[g_logWriteCursor++] = sensor_id;\n    g_sensorLogBuffer[g_logWriteCursor++] = (uint8_t)(num_readings >> 8);\n    g_sensorLogBuffer[g_logWriteCursor++] = (uint8_t)(num_readings & 0xFF);\n\n    for (uint16_t i = 0; i < num_readings; ++i) {\n        uint16_t source_reading_offset = current_packet_read_offset + (i * SENSOR_READING_SIZE);\n        uint16_t dest_reading_offset = g_logWriteCursor + (i * SENSOR_READING_SIZE);\n\n        g_sensorLogBuffer[dest_reading_offset] = packet[source_reading_offset];\n        g_sensorLogBuffer[dest_reading_offset + 1] = packet[source_reading_offset + 1];\n    }\n\n    g_logWriteCursor = (g_logWriteCursor + data_bytes_len) % LOG_BUFFER_SIZE;\n\n    return 0;\n}\n\nvoid receiveSensorUpdate(const uint8_t* raw_data, uint16_t length) {\n    processSensorDataPacket(raw_data, length);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define LOG_BUFFER_SIZE 512\n#define SENSOR_READING_SIZE 2\n\nstatic uint8_t g_sensorLogBuffer[LOG_BUFFER_SIZE];\nstatic uint16_t g_logWriteCursor = 0;\n\nvoid initSensorLogger() {\n    memset(g_sensorLogBuffer, 0, LOG_BUFFER_SIZE);\n    g_logWriteCursor = 0;\n}\n\nint processSensorDataPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len < 3) {\n        return -1;\n    }\n\n    uint16_t current_packet_read_offset = 0;\n    uint8_t sensor_id = packet[current_packet_read_offset++];\n    uint16_t num_readings = (packet[current_packet_read_offset] << 8) | packet[current_packet_read_offset+1];\n    current_packet_read_offset += 2;\n\n    if (num_readings == 0) {\n        return 0;\n    }\n\n    if (num_readings > (UINT16_MAX / SENSOR_READING_SIZE)) {\n        return -5;\n    }\n\n    uint16_t data_bytes_len = num_readings * SENSOR_READING_SIZE;\n\n    if (current_packet_read_offset + data_bytes_len > packet_len) {\n        return -3;\n    }\n\n    uint16_t header_size = 1 + 2;\n    uint16_t total_entry_size = header_size + data_bytes_len;\n\n    if (g_logWriteCursor + total_entry_size > LOG_BUFFER_SIZE) {\n        g_logWriteCursor = 0;\n        if (total_entry_size > LOG_BUFFER_SIZE) {\n            return -4;\n        }\n    }\n\n    g_sensorLogBuffer[g_logWriteCursor++] = sensor_id;\n    g_sensorLogBuffer[g_logWriteCursor++] = (uint8_t)(num_readings >> 8);\n    g_sensorLogBuffer[g_logWriteCursor++] = (uint8_t)(num_readings & 0xFF);\n\n    for (uint16_t i = 0; i < num_readings; ++i) {\n        uint16_t source_reading_offset = current_packet_read_offset + (i * SENSOR_READING_SIZE);\n        uint16_t dest_reading_offset = g_logWriteCursor + (i * SENSOR_READING_SIZE);\n\n        if (dest_reading_offset + SENSOR_READING_SIZE > LOG_BUFFER_SIZE) {\n            break;\n        }\n\n        g_sensorLogBuffer[dest_reading_offset] = packet[source_reading_offset];\n        g_sensorLogBuffer[dest_reading_offset + 1] = packet[source_reading_offset + 1];\n    }\n\n    g_logWriteCursor = (g_logWriteCursor + total_entry_size) % LOG_BUFFER_SIZE;\n\n    return 0;\n}\n\nvoid receiveSensorUpdate(const uint8_t* raw_data, uint16_t length) {\n    processSensorDataPacket(raw_data, length);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define GLOBAL_CONFIG_BUFFER_SIZE 512\n\nstatic uint8_t g_vehicleConfiguration[GLOBAL_CONFIG_BUFFER_SIZE];\n\ntypedef struct {\n    uint16_t param_did;\n    uint16_t offset_in_buffer;\n    uint16_t param_size;\n} ConfigurationParameterInfo;\n\nstatic const ConfigurationParameterInfo g_configParams[] = {\n    {0x1001, 0,    128},\n    {0x1002, 128,  64},\n    {0x1003, 192,  32},\n    {0x1004, 224,  256}\n};\n#define NUM_CONFIG_PARAMS (sizeof(g_configParams) / sizeof(g_configParams[0]))\n\nvoid initVehicleConfiguration() {\n    memset(g_vehicleConfiguration, 0, GLOBAL_CONFIG_BUFFER_SIZE);\n    for (uint16_t i = 0; i < GLOBAL_CONFIG_BUFFER_SIZE; ++i) {\n        g_vehicleConfiguration[i] = (uint8_t)(i % 256);\n    }\n}\n\nint updateConfigurationSegment(uint16_t did, uint16_t segment_offset, uint16_t segment_length, const uint8_t* data) {\n    if (data == NULL || segment_length == 0) {\n        return -1;\n    }\n\n    uint16_t param_idx = (uint16_t)-1;\n    for (uint16_t i = 0; i < NUM_CONFIG_PARAMS; ++i) {\n        if (g_configParams[i].param_did == did) {\n            param_idx = i;\n            break;\n        }\n    }\n\n    if (param_idx == (uint16_t)-1) {\n        return -2;\n    }\n\n    const ConfigurationParameterInfo* param_info = &g_configParams[param_idx];\n\n    if (segment_offset >= param_info->param_size) {\n        return -3;\n    }\n\n    uint16_t dest_abs_offset = param_info->offset_in_buffer + segment_offset;\n\n    for (uint16_t i = 0; i < segment_length; ++i) {\n        g_vehicleConfiguration[dest_abs_offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid handleDiagnosticRequest(uint16_t did, uint16_t offset, uint16_t len, const uint8_t* payload) {\n    updateConfigurationSegment(did, offset, len, payload);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define GLOBAL_CONFIG_BUFFER_SIZE 512\n\nstatic uint8_t g_vehicleConfiguration[GLOBAL_CONFIG_BUFFER_SIZE];\n\ntypedef struct {\n    uint16_t param_did;\n    uint16_t offset_in_buffer;\n    uint16_t param_size;\n} ConfigurationParameterInfo;\n\nstatic const ConfigurationParameterInfo g_configParams[] = {\n    {0x1001, 0,    128},\n    {0x1002, 128,  64},\n    {0x1003, 192,  32},\n    {0x1004, 224,  256}\n};\n#define NUM_CONFIG_PARAMS (sizeof(g_configParams) / sizeof(g_configParams[0]))\n\nvoid initVehicleConfiguration() {\n    memset(g_vehicleConfiguration, 0, GLOBAL_CONFIG_BUFFER_SIZE);\n    for (uint16_t i = 0; i < GLOBAL_CONFIG_BUFFER_SIZE; ++i) {\n        g_vehicleConfiguration[i] = (uint8_t)(i % 256);\n    }\n}\n\nint updateConfigurationSegment(uint16_t did, uint16_t segment_offset, uint16_t segment_length, const uint8_t* data) {\n    if (data == NULL || segment_length == 0) {\n        return -1;\n    }\n\n    uint16_t param_idx = (uint16_t)-1;\n    for (uint16_t i = 0; i < NUM_CONFIG_PARAMS; ++i) {\n        if (g_configParams[i].param_did == did) {\n            param_idx = i;\n            break;\n        }\n    }\n\n    if (param_idx == (uint16_t)-1) {\n        return -2;\n    }\n\n    const ConfigurationParameterInfo* param_info = &g_configParams[param_idx];\n\n    if ((uint32_t)segment_offset + segment_length > param_info->param_size) {\n        return -3;\n    }\n\n    uint16_t dest_abs_offset = param_info->offset_in_buffer + segment_offset;\n\n    if ((uint32_t)dest_abs_offset + segment_length > GLOBAL_CONFIG_BUFFER_SIZE) {\n        return -4;\n    }\n\n    for (uint16_t i = 0; i < segment_length; ++i) {\n        g_vehicleConfiguration[dest_abs_offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid handleDiagnosticRequest(uint16_t did, uint16_t offset, uint16_16t len, const uint8_t* payload) {\n    updateConfigurationSegment(did, offset, len, payload);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_BUFFER_SIZE 256\n#define MAX_PAYLOAD_PER_EVENT 64 \n\nstatic uint8_t g_telemetryCircularBuffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_writeIndex = 0; \nstatic uint16_t g_dataLength = 0; \n\ntypedef struct {\n    uint16_t timestamp;   \n    uint8_t event_id;     \n    uint8_t payload_len;  \n} TelemetryEventHeader;\n\nvoid initTelemetryBuffer() {\n    memset(g_telemetryCircularBuffer, 0, TELEMETRY_BUFFER_SIZE);\n    g_writeIndex = 0;\n    g_dataLength = 0;\n}\n\nint addTelemetryEvent(const uint8_t* event_data, uint16_t data_len) {\n    if (event_data == NULL || data_len < sizeof(TelemetryEventHeader)) {\n        return -1; \n    }\n\n    uint16_t received_timestamp = (event_data[0] << 8) | event_data[1];\n    uint8_t received_event_id = event_data[2];\n    uint8_t received_payload_len = event_data[3];\n\n    uint16_t total_event_size = sizeof(TelemetryEventHeader) + received_payload_len;\n\n    if (received_payload_len > MAX_PAYLOAD_PER_EVENT) {\n        return -2; \n    }\n\n    if (total_event_size != data_len) {\n        return -3; \n    }\n\n    for (uint16_t i = 0; i < total_event_size; ++i) {\n        g_telemetryCircularBuffer[g_writeIndex + i] = event_data[i]; \n    }\n\n    g_writeIndex = (g_writeIndex + total_event_size) % TELEMETRY_BUFFER_SIZE;\n\n    g_dataLength += total_event_size;\n    if (g_dataLength > TELEMETRY_BUFFER_SIZE) {\n        g_dataLength = TELEMETRY_BUFFER_SIZE; \n    }\n\n    return 0; \n}\n\nvoid receiveTelemetryData(const uint8_t* data, uint16_t len) {\n    addTelemetryEvent(data, len);\n}\n\nuint8_t getTelemetryByte(uint16_t index) {\n    if (index < TELEMETRY_BUFFER_SIZE) {\n        return g_telemetryCircularBuffer[index];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_BUFFER_SIZE 256\n#define MAX_PAYLOAD_PER_EVENT 64 \n\nstatic uint8_t g_telemetryCircularBuffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_writeIndex = 0; \nstatic uint16_t g_dataLength = 0; \n\ntypedef struct {\n    uint16_t timestamp;   \n    uint8_t event_id;     \n    uint8_t payload_len;  \n} TelemetryEventHeader;\n\nvoid initTelemetryBuffer() {\n    memset(g_telemetryCircularBuffer, 0, TELEMETRY_BUFFER_SIZE);\n    g_writeIndex = 0;\n    g_dataLength = 0;\n}\n\nint addTelemetryEvent(const uint8_t* event_data, uint16_t data_len) {\n    if (event_data == NULL || data_len < sizeof(TelemetryEventHeader)) {\n        return -1; \n    }\n\n    uint16_t received_timestamp = (event_data[0] << 8) | event_data[1];\n    uint8_t received_event_id = event_data[2];\n    uint8_t received_payload_len = event_data[3];\n\n    uint16_t total_event_size = sizeof(TelemetryEventHeader) + received_payload_len;\n\n    if (received_payload_len > MAX_PAYLOAD_PER_EVENT) {\n        return -2; \n    }\n\n    if (total_event_size != data_len) {\n        return -3; \n    }\n\n    uint16_t space_to_end = TELEMETRY_BUFFER_SIZE - g_writeIndex;\n\n    if (total_event_size <= space_to_end) {\n        memcpy(&g_telemetryCircularBuffer[g_writeIndex], event_data, total_event_size);\n    } else {\n        memcpy(&g_telemetryCircularBuffer[g_writeIndex], event_data, space_to_end);\n        memcpy(&g_telemetryCircularBuffer[0], event_data + space_to_end, total_event_size - space_to_end);\n    }\n\n    g_writeIndex = (g_writeIndex + total_event_size) % TELEMETRY_BUFFER_SIZE;\n\n    if (g_dataLength < TELEMETRY_BUFFER_SIZE) {\n        g_dataLength += total_event_size;\n        if (g_dataLength > TELEMETRY_BUFFER_SIZE) {\n            g_dataLength = TELEMETRY_BUFFER_SIZE;\n        }\n    }\n\n    return 0; \n}\n\nvoid receiveTelemetryData(const uint8_t* data, uint16_t len) {\n    addTelemetryEvent(data, len);\n}\n\nuint8_t getTelemetryByte(uint16_t index) {\n    if (index < TELEMETRY_BUFFER_SIZE) {\n        return g_telemetryCircularBuffer[index];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define MAX_SENSOR_DETECTIONS 100 \n\n#pragma pack(push, 1)\ntypedef struct {\n    int16_t x;\n    int16_t y;\n    int16_t z;\n    uint8_t confidence;\n} DetectionPoint;\n#pragma pack(pop)\n\ntypedef struct {\n    uint16_t frame_id;\n    uint8_t  sensor_id;\n    uint8_t  num_detection_points; \n    uint32_t timestamp;\n} SensorDataFrameHeader;\n\nstatic DetectionPoint g_processedDetections[MAX_SENSOR_DETECTIONS];\nstatic uint8_t g_currentDetectionCount = 0;\n\nvoid initDetectionBuffer() {\n    memset(g_processedDetections, 0, sizeof(g_processedDetections));\n    g_currentDetectionCount = 0;\n}\n\nint processSensorDataFrame(const uint8_t* raw_frame, uint16_t frame_len) {\n    if (raw_frame == NULL || frame_len < sizeof(SensorDataFrameHeader)) {\n        return -1;\n    }\n\n    const SensorDataFrameHeader* header = (const SensorDataFrameHeader*)raw_frame;\n\n    uint8_t num_points = header->num_detection_points;\n    \n    const uint8_t* data_ptr = raw_frame + sizeof(SensorDataFrameHeader);\n    uint16_t current_data_offset = 0;\n\n    uint16_t expected_points_data_len = num_points * sizeof(DetectionPoint);\n    if (frame_len < (sizeof(SensorDataFrameHeader) + expected_points_data_len)) {\n        return -2; \n    }\n\n    for (uint8_t i = 0; i < num_points; ++i) {\n        g_processedDetections[i].x = (int16_t)((data_ptr[current_data_offset + 0] << 8) | data_ptr[current_data_offset + 1]);\n        g_processedDetections[i].y = (int16_t)((data_ptr[current_data_offset + 2] << 8) | data_ptr[current_data_offset + 3]);\n        g_processedDetections[i].z = (int16_t)((data_ptr[current_data_offset + 4] << 8) | data_ptr[current_data_offset + 5]);\n        g_processedDetections[i].confidence = data_ptr[current_data_offset + 6];\n        current_data_offset += sizeof(DetectionPoint);\n    }\n\n    g_currentDetectionCount = num_points;\n    return 0;\n}\n\nvoid simulateReceiveSensorFrame(const uint8_t* frame, uint16_t len) {\n    processSensorDataFrame(frame, len);\n}\n\nDetectionPoint* getProcessedDetection(uint8_t index) {\n    if (index < g_currentDetectionCount) {\n        return &g_processedDetections[index];\n    }\n    return NULL;\n}", "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define MAX_SENSOR_DETECTIONS 100 \n\n#pragma pack(push, 1)\ntypedef struct {\n    int16_t x;\n    int16_t y;\n    int16_t z;\n    uint8_t confidence;\n} DetectionPoint;\n#pragma pack(pop)\n\ntypedef struct {\n    uint16_t frame_id;\n    uint8_t  sensor_id;\n    uint8_t  num_detection_points; \n    uint32_t timestamp;\n} SensorDataFrameHeader;\n\nstatic DetectionPoint g_processedDetections[MAX_SENSOR_DETECTIONS];\nstatic uint8_t g_currentDetectionCount = 0;\n\nvoid initDetectionBuffer() {\n    memset(g_processedDetections, 0, sizeof(g_processedDetections));\n    g_currentDetectionCount = 0;\n}\n\nint processSensorDataFrame(const uint8_t* raw_frame, uint16_t frame_len) {\n    if (raw_frame == NULL || frame_len < sizeof(SensorDataFrameHeader)) {\n        return -1;\n    }\n\n    const SensorDataFrameHeader* header = (const SensorDataFrameHeader*)raw_frame;\n\n    uint8_t num_points = header->num_detection_points;\n\n    if (num_points > MAX_SENSOR_DETECTIONS) {\n        return -3; \n    }\n    \n    const uint8_t* data_ptr = raw_frame + sizeof(SensorDataFrameHeader);\n    uint16_t current_data_offset = 0;\n\n    uint16_t expected_points_data_len = num_points * sizeof(DetectionPoint);\n    if (frame_len < (sizeof(SensorDataFrameHeader) + expected_points_data_len)) {\n        return -2; \n    }\n\n    for (uint8_t i = 0; i < num_points; ++i) {\n        g_processedDetections[i].x = (int16_t)((data_ptr[current_data_offset + 0] << 8) | data_ptr[current_data_offset + 1]);\n        g_processedDetections[i].y = (int16_t)((data_ptr[current_data_offset + 2] << 8) | data_ptr[current_data_offset + 3]);\n        g_processedDetections[i].z = (int16_t)((data_ptr[current_data_offset + 4] << 8) | data_ptr[current_data_offset + 5]);\n        g_processedDetections[i].confidence = data_ptr[current_data_offset + 6];\n        current_data_offset += sizeof(DetectionPoint);\n    }\n\n    g_currentDetectionCount = num_points;\n    return 0;\n}\n\nvoid simulateReceiveSensorFrame(const uint8_t* frame, uint16_t len) {\n    processSensorDataFrame(frame, len);\n}\n\nDetectionPoint* getProcessedDetection(uint8_t index) {\n    if (index < g_currentDetectionCount) {\n        return &g_processedDetections[index];\n    }\n    return NULL;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRIES 200\n#define LOG_ENTRY_SIZE 10\n#define TELEMETRY_BUFFER_TOTAL_SIZE (MAX_LOG_ENTRIES * LOG_ENTRY_SIZE)\n\nstatic uint8_t g_telemetryLogBuffer[TELEMETRY_BUFFER_TOTAL_SIZE];\nstatic uint16_t g_logWriteHead = 0;\nstatic uint16_t g_currentValidBytes = 0;\n\nvoid initTelemetryLogger() {\n    memset(g_telemetryLogBuffer, 0, TELEMETRY_BUFFER_TOTAL_SIZE);\n    g_logWriteHead = 0;\n    g_currentValidBytes = 0;\n}\n\nint addTelemetryEntry(const uint8_t* entry_data) {\n    if (entry_data == NULL) {\n        return -1;\n    }\n\n    for (uint8_t i = 0; i < LOG_ENTRY_SIZE; ++i) {\n        g_telemetryLogBuffer[g_logWriteHead] = entry_data[i];\n        g_logWriteHead = (g_logWriteHead + 1) % TELEMETRY_BUFFER_TOTAL_SIZE;\n    }\n\n    if (g_currentValidBytes < TELEMETRY_BUFFER_TOTAL_SIZE) {\n        g_currentValidBytes += LOG_ENTRY_SIZE;\n    }\n    return 0;\n}\n\nint getLatestTelemetryEntries(uint16_t num_requested_entries, uint8_t* response_buffer, uint16_t response_buffer_size) {\n    if (response_buffer == NULL) {\n        return -1;\n    }\n\n    if (num_requested_entries == 0) {\n        return 0;\n    }\n\n    uint16_t total_bytes_expected = num_requested_entries * LOG_ENTRY_SIZE;\n\n    if (total_bytes_expected > response_buffer_size) {\n        return -2;\n    }\n    \n    uint16_t start_byte_offset;\n    if (g_currentValidBytes < TELEMETRY_BUFFER_TOTAL_SIZE || (uint32_t)num_requested_entries * LOG_ENTRY_SIZE <= g_currentValidBytes) {\n        uint32_t effective_offset_calc = (uint32_t)g_currentValidBytes - ((uint32_t)num_requested_entries * LOG_ENTRY_SIZE);\n        if (effective_offset_calc > TELEMETRY_BUFFER_TOTAL_SIZE) {\n             start_byte_offset = 0;\n        } else {\n             start_byte_offset = (g_logWriteHead + TELEMETRY_BUFFER_TOTAL_SIZE - g_currentValidBytes + (uint16_t)effective_offset_calc) % TELEMETRY_BUFFER_TOTAL_SIZE;\n        }\n    } else {\n        start_byte_offset = (g_logWriteHead + TELEMETRY_BUFFER_TOTAL_SIZE - ((uint32_t)num_requested_entries * LOG_ENTRY_SIZE)) % TELEMETRY_BUFFER_TOTAL_SIZE;\n    }\n    start_byte_offset %= TELEMETRY_BUFFER_TOTAL_SIZE;\n\n    for (uint16_t i = 0; i < num_requested_entries; ++i) {\n        for (uint8_t j = 0; j < LOG_ENTRY_SIZE; ++j) {\n            uint16_t source_idx = (start_byte_offset + (i * LOG_ENTRY_SIZE) + j) % TELEMETRY_BUFFER_TOTAL_SIZE;\n            response_buffer[(i * LOG_ENTRY_SIZE) + j] = g_telemetryLogBuffer[source_idx];\n        }\n    }\n\n    return num_requested_entries;\n}\n\nvoid handleDiagnosticRequest(uint16_t command_id, uint16_t param1, uint8_t* diag_resp_buf, uint16_t diag_resp_buf_len) {\n    if (command_id == 0x1234) {\n        getLatestTelemetryEntries(param1, diag_resp_buf, diag_resp_buf_len);\n    }\n}\n", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRIES 200\n#define LOG_ENTRY_SIZE 10\n#define TELEMETRY_BUFFER_TOTAL_SIZE (MAX_LOG_ENTRIES * LOG_ENTRY_SIZE)\n\nstatic uint8_t g_telemetryLogBuffer[TELEMETRY_BUFFER_TOTAL_SIZE];\nstatic uint16_t g_logWriteHead = 0;\nstatic uint16_t g_currentValidBytes = 0;\n\nvoid initTelemetryLogger() {\n    memset(g_telemetryLogBuffer, 0, TELEMETRY_BUFFER_TOTAL_SIZE);\n    g_logWriteHead = 0;\n    g_currentValidBytes = 0;\n}\n\nint addTelemetryEntry(const uint8_t* entry_data) {\n    if (entry_data == NULL) {\n        return -1;\n    }\n\n    for (uint8_t i = 0; i < LOG_ENTRY_SIZE; ++i) {\n        g_telemetryLogBuffer[g_logWriteHead] = entry_data[i];\n        g_logWriteHead = (g_logWriteHead + 1) % TELEMETRY_BUFFER_TOTAL_SIZE;\n    }\n\n    if (g_currentValidBytes < TELEMETRY_BUFFER_TOTAL_SIZE) {\n        g_currentValidBytes += LOG_ENTRY_SIZE;\n    }\n    return 0;\n}\n\nint getLatestTelemetryEntries(uint16_t num_requested_entries, uint8_t* response_buffer, uint16_t response_buffer_size) {\n    if (response_buffer == NULL) {\n        return -1;\n    }\n\n    if (num_requested_entries == 0) {\n        return 0;\n    }\n\n    uint16_t max_entries_for_dest_buffer = response_buffer_size / LOG_ENTRY_SIZE;\n    uint16_t max_entries_available_in_log = g_currentValidBytes / LOG_ENTRY_SIZE;\n\n    uint16_t actual_entries_to_copy = num_requested_entries;\n    if (actual_entries_to_copy > max_entries_for_dest_buffer) {\n        actual_entries_to_copy = max_entries_for_dest_buffer;\n    }\n    if (actual_entries_to_copy > max_entries_available_in_log) {\n        actual_entries_to_copy = max_entries_available_in_log;\n    }\n    \n    uint16_t actual_bytes_to_copy = actual_entries_to_copy * LOG_ENTRY_SIZE;\n\n    if (actual_entries_to_copy == 0) {\n        return 0;\n    }\n\n    uint16_t start_byte_offset;\n    if (g_currentValidBytes < TELEMETRY_BUFFER_TOTAL_SIZE) {\n        if (actual_bytes_to_copy > g_currentValidBytes) {\n            start_byte_offset = 0;\n        } else {\n            start_byte_offset = (g_logWriteHead + TELEMETRY_BUFFER_TOTAL_SIZE - g_currentValidBytes + (g_currentValidBytes - actual_bytes_to_copy)) % TELEMETRY_BUFFER_TOTAL_SIZE;\n        }\n    } else {\n        start_byte_offset = (g_logWriteHead + TELEMETRY_BUFFER_TOTAL_SIZE - actual_bytes_to_copy) % TELEMETRY_BUFFER_TOTAL_SIZE;\n    }\n    start_byte_offset %= TELEMETRY_BUFFER_TOTAL_SIZE;\n\n    for (uint16_t i = 0; i < actual_entries_to_copy; ++i) {\n        for (uint8_t j = 0; j < LOG_ENTRY_SIZE; ++j) {\n            uint16_t source_idx = (start_byte_offset + (i * LOG_ENTRY_SIZE) + j) % TELEMETRY_BUFFER_TOTAL_SIZE;\n            response_buffer[(i * LOG_ENTRY_SIZE) + j] = g_telemetryLogBuffer[source_idx];\n        }\n    }\n\n    return actual_bytes_to_copy;\n}\n\nvoid handleDiagnosticRequest(uint16_t command_id, uint16_t param1, uint8_t* diag_resp_buf, uint16_t diag_resp_buf_len) {\n    if (command_id == 0x1234) {\n        getLatestTelemetryEntries(param1, diag_resp_buf, diag_resp_buf_len);\n    }\n}\n", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\nstatic uint16_t engine_params[5] = {1000, 85, 50, 1200, 0};\nstatic uint16_t chassis_params[10] = {300, 305, 302, 301, 100, 101, 102, 103, 0, 0};\nstatic uint16_t infotainment_params[3] = {1, 0, 15};\n\n#define MAX_RESPONSE_DATA_SIZE 64\n#define NUM_PARAM_GROUPS 3\n\ntypedef struct {\n    uint16_t* data_ptr;\n    uint16_t count;\n} ParameterGroup;\n\nstatic ParameterGroup g_paramGroups[NUM_PARAM_GROUPS];\n\nvoid initDiagnosticSystem() {\n    g_paramGroups[0].data_ptr = engine_params;\n    g_paramGroups[0].count = sizeof(engine_params) / sizeof(uint16_t);\n\n    g_paramGroups[1].data_ptr = chassis_params;\n    g_paramGroups[1].count = sizeof(chassis_params) / sizeof(uint16_t);\n\n    g_paramGroups[2].data_ptr = infotainment_params;\n    g_paramGroups[2].count = sizeof(infotainment_params) / sizeof(uint16_t);\n}\n\nint handleDiagnosticParamRequest(const uint8_t* request_packet, uint16_t packet_len, uint8_t* response_buffer, uint16_t response_buffer_size) {\n    if (request_packet == NULL || packet_len < 5 || response_buffer == NULL || response_buffer_size < 3) {\n        return -1;\n    }\n\n    uint8_t group_id = request_packet[0];\n    uint16_t start_index = (request_packet[1] << 8) | request_packet[2];\n    uint16_t count = (request_packet[3] << 8) | request_packet[4];\n\n    if (group_id >= NUM_PARAM_GROUPS) {\n        return -2;\n    }\n\n    ParameterGroup* target_group = &g_paramGroups[group_id];\n    \n    uint16_t required_response_payload_bytes = count * sizeof(uint16_t);\n    if (3 + required_response_payload_bytes > response_buffer_size) {\n        return -3;\n    }\n\n    response_buffer[0] = group_id;\n    response_buffer[1] = (uint8_t)(count >> 8);\n    response_buffer[2] = (uint8_t)(count & 0xFF);\n\n    uint16_t current_response_offset = 3;\n\n    for (uint16_t i = 0; i < count; ++i) {\n        uint16_t param_value = target_group->data_ptr[start_index + i]; \n        response_buffer[current_response_offset++] = (uint8_t)(param_value >> 8);\n        response_buffer[current_response_offset++] = (uint8_t)(param_value & 0xFF);\n    }\n\n    return current_response_offset;\n}\n\nvoid simulateDiagnosticQuery(const uint8_t* req_data, uint16_t req_len) {\n    uint8_t response_data[MAX_RESPONSE_DATA_SIZE + 3];\n    memset(response_data, 0, sizeof(response_data));\n    handleDiagnosticParamRequest(req_data, req_len, response_data, sizeof(response_data));\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\nstatic uint16_t engine_params[5] = {1000, 85, 50, 1200, 0};\nstatic uint16_t chassis_params[10] = {300, 305, 302, 301, 100, 101, 102, 103, 0, 0};\nstatic uint16_t infotainment_params[3] = {1, 0, 15};\n\n#define MAX_RESPONSE_DATA_SIZE 64\n#define NUM_PARAM_GROUPS 3\n\ntypedef struct {\n    uint16_t* data_ptr;\n    uint16_t count;\n} ParameterGroup;\n\nstatic ParameterGroup g_paramGroups[NUM_PARAM_GROUPS];\n\nvoid initDiagnosticSystem() {\n    g_paramGroups[0].data_ptr = engine_params;\n    g_paramGroups[0].count = sizeof(engine_params) / sizeof(uint16_t);\n\n    g_paramGroups[1].data_ptr = chassis_params;\n    g_paramGroups[1].count = sizeof(chassis_params) / sizeof(uint16_t);\n\n    g_paramGroups[2].data_ptr = infotainment_params;\n    g_paramGroups[2].count = sizeof(infotainment_params) / sizeof(uint16_t);\n}\n\nint handleDiagnosticParamRequest(const uint8_t* request_packet, uint16_t packet_len, uint8_t* response_buffer, uint16_t response_buffer_size) {\n    if (request_packet == NULL || packet_len < 5 || response_buffer == NULL || response_buffer_size < 3) {\n        return -1;\n    }\n\n    uint8_t group_id = request_packet[0];\n    uint16_t start_index = (request_packet[1] << 8) | request_packet[2];\n    uint16_t count = (request_packet[3] << 8) | request_packet[4];\n\n    if (group_id >= NUM_PARAM_GROUPS) {\n        return -2;\n    }\n\n    ParameterGroup* target_group = &g_paramGroups[group_id];\n    \n    if (start_index >= target_group->count) {\n        return -4;\n    }\n    \n    uint16_t actual_count_to_retrieve = count;\n    if (start_index + actual_count_to_retrieve > target_group->count) {\n        actual_count_to_retrieve = target_group->count - start_index;\n    }\n    \n    uint16_t required_response_payload_bytes = actual_count_to_retrieve * sizeof(uint16_t);\n    if (3 + required_response_payload_bytes > response_buffer_size) {\n        return -3;\n    }\n\n    response_buffer[0] = group_id;\n    response_buffer[1] = (uint8_t)(actual_count_to_retrieve >> 8);\n    response_buffer[2] = (uint8_t)(actual_count_to_retrieve & 0xFF);\n\n    uint16_t current_response_offset = 3;\n\n    for (uint16_t i = 0; i < actual_count_to_retrieve; ++i) {\n        uint16_t param_value = target_group->data_ptr[start_index + i]; \n        response_buffer[current_response_offset++] = (uint8_t)(param_value >> 8);\n        response_buffer[current_response_offset++] = (uint8_t)(param_value & 0xFF);\n    }\n\n    return current_response_offset;\n}\n\nvoid simulateDiagnosticQuery(const uint8_t* req_data, uint16_t req_len) {\n    uint8_t response_data[MAX_RESPONSE_DATA_SIZE + 3];\n    memset(response_data, 0, sizeof(response_data));\n    handleDiagnosticParamRequest(req_data, req_len, response_data, sizeof(response_data));\n}", "analysis": ""}
{"cwe_id": "CWE-119", ",cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define REASSEMBLY_BUFFER_SIZE 512\n#define MAX_RECORDS            4\n#define MAX_RECORD_LEN_BYTES   100 \n\n// Structure for a record's metadata within the reassembly manager\ntypedef struct {\n    uint16_t record_id;\n    uint16_t total_expected_len; \n    uint16_t current_len;        \n    uint16_t buffer_offset;      \n    bool     is_active;          \n} RecordMetadata;\n\n// Global buffer for reassembling record data\nstatic uint8_t g_reassemblyBuffer[REASSEMBLY_BUFFER_SIZE];\n// Metadata for active records being reassembled\nstatic RecordMetadata g_recordMetadata[MAX_RECORDS];\n// Pointer to the next free byte in g_reassemblyBuffer for new record allocation\nstatic uint16_t g_nextFreeBufferOffset = 0;\n\n// Initializes the reassembly manager system.\nvoid initReassemblyManager() {\n    memset(g_reassemblyBuffer, 0, REASSEMBLY_BUFFER_SIZE);\n    memset(g_recordMetadata, 0, sizeof(g_recordMetadata));\n    g_nextFreeBufferOffset = 0;\n}\n\n// Activates a new record reassembly slot or finds an existing one.\n// Returns the index into g_recordMetadata or a negative error code.\nint activateRecord(uint16_t id, uint16_t expected_total_len) {\n    if (expected_total_len == 0 || expected_total_len > MAX_RECORD_LEN_BYTES) {\n        return -1; \n    }\n\n    for (int i = 0; i < MAX_RECORDS; ++i) {\n        if (g_recordMetadata[i].is_active && g_recordMetadata[i].record_id == id) {\n            return i;\n        }\n    }\n\n    for (int i = 0; i < MAX_RECORDS; ++i) {\n        if (!g_recordMetadata[i].is_active) {\n            if (g_nextFreeBufferOffset + expected_total_len > REASSEMBLY_BUFFER_SIZE) {\n                return -2; \n            }\n\n            g_recordMetadata[i].record_id = id;\n            g_recordMetadata[i].total_expected_len = expected_total_len;\n            g_recordMetadata[i].current_len = 0;\n            g_recordMetadata[i].buffer_offset = g_nextFreeBufferOffset;\n            g_recordMetadata[i].is_active = true;\n\n            g_nextFreeBufferOffset += expected_total_len; \n\n            return i;\n        }\n    }\n    return -3; \n}\n\n// Processes a received data fragment for a specific record.\n// record_meta_idx: Index of the target record in g_recordMetadata.\n// fragment_offset: Offset of this fragment within the logical record's data.\n// fragment_data: Pointer to the raw fragment data.\n// fragment_len: Length of the raw fragment data.\nint processRecordFragment(int record_meta_idx, uint16_t fragment_offset, const uint8_t* fragment_data, uint16_t fragment_len) {\n    if (record_meta_idx < 0 || record_meta_idx >= MAX_RECORDS || !g_recordMetadata[record_meta_idx].is_active) {\n        return -1; \n    }\n    if (fragment_data == NULL || fragment_len == 0) {\n        return -2; \n    }\n\n    RecordMetadata* record = &g_recordMetadata[record_meta_idx];\n\n    // Calculate the absolute destination offset in the global reassembly buffer.\n    uint16_t dest_offset = record->buffer_offset + fragment_offset;\n\n    // VULNERABILITY:\n    // This check only ensures the *start* of the write is within the record's logical bounds.\n    // It does NOT ensure that the *entire* fragment data (dest_offset + fragment_len) fits within\n    // the record's allocated space (`record->total_expected_len`).\n    // If `fragment_offset + fragment_len` exceeds `record->total_expected_len`,\n    // an out-of-bounds write will occur into the subsequent record's buffer or beyond.\n    if (dest_offset < (record->buffer_offset + record->total_expected_len)) {\n        for (uint16_t i = 0; i < fragment_len; ++i) {\n            g_reassemblyBuffer[dest_offset + i] = fragment_data[i];\n        }\n\n        uint16_t new_current_len = fragment_offset + fragment_len;\n        if (new_current_len > record->current_len) {\n            record->current_len = new_current_len;\n        }\n        return 0;\n    }\n\n    return -3; \n}\n\n// Simulates receiving a vehicle data frame fragmented over a network.\nvoid receiveVehicleDataFrame(uint16_t record_id, uint16_t fragment_offset, const uint8_t* data, uint16_t len) {\n    // In a real system, expected_total_len would come from a header or prior message.\n    // For this simulation, assume a fixed expected length of 50 bytes for any record.\n    int record_idx = activateRecord(record_id, 50);\n    if (record_idx >= 0) {\n        processRecordFragment(record_idx, fragment_offset, data, len);\n    }\n}\n\n// This function would be used for testing/demonstration purposes\nuint8_t getReassembledByte(uint16_t absolute_offset) {\n    if (absolute_offset < REASSEMBLY_BUFFER_SIZE) {\n        return g_reassemblyBuffer[absolute_offset];\n    }\n    return 0;\n}\n\n// Example usage to demonstrate the vulnerability\nvoid runReassemblySimulation() {\n    initReassemblyManager();\n\n    // Activate two records. Each is allocated 50 bytes within g_reassemblyBuffer.\n    // Record 1 (ID 101): buffer_offset = 0, range [0, 49]\n    int record_idx1 = activateRecord(101, 50);\n    // Record 2 (ID 102): buffer_offset = 50, range [50, 99]\n    int record_idx2 = activateRecord(102, 50);\n\n    // Legitimate fragment for Record 2, populating its start\n    uint8_t legit_fragment_r2[] = {0xA1, 0xA2, 0xA3, 0xA4, 0xA5}; \n    processRecordFragment(record_idx2, 0, legit_fragment_r2, sizeof(legit_fragment_r2));\n    // g_reassemblyBuffer[50..54] should contain {0xA1, 0xA2, 0xA3, 0xA4, 0xA5}\n\n    // ATTACK SCENARIO: Send an oversized fragment for Record 1.\n    // Record 1 is allocated 50 bytes (indices 0-49). \n    // Fragment offset is 40, which is within bounds for Record 1 (0-49).\n    // Fragment length is 20. This means the write will cover indices [40, 40+20-1] = [40, 59].\n    // This will overwrite bytes [50-59], which belong to Record 2.\n    uint8_t malicious_fragment_r1[20];\n    memset(malicious_fragment_r1, 0xFF, sizeof(malicious_fragment_r1)); \n    processRecordFragment(record_idx1, 40, malicious_fragment_r1, sizeof(malicious_fragment_r1));\n\n    // After the attack, g_reassemblyBuffer[50] (first byte of record 2) should now be 0xFF,\n    // demonstrating the out-of-bounds write.\n}\n", "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define REASSEMBLY_BUFFER_SIZE 512\n#define MAX_RECORDS            4\n#define MAX_RECORD_LEN_BYTES   100 \n\ntypedef struct {\n    uint16_t record_id;\n    uint16_t total_expected_len; \n    uint16_t current_len;        \n    uint16_t buffer_offset;      \n    bool     is_active;          \n} RecordMetadata;\n\nstatic uint8_t g_reassemblyBuffer[REASSEMBLY_BUFFER_SIZE];\nstatic RecordMetadata g_recordMetadata[MAX_RECORDS];\nstatic uint16_t g_nextFreeBufferOffset = 0;\n\nvoid initReassemblyManager() {\n    memset(g_reassemblyBuffer, 0, REASSEMBLY_BUFFER_SIZE);\n    memset(g_recordMetadata, 0, sizeof(g_recordMetadata));\n    g_nextFreeBufferOffset = 0;\n}\n\nint activateRecord(uint16_t id, uint16_t expected_total_len) {\n    if (expected_total_len == 0 || expected_total_len > MAX_RECORD_LEN_BYTES) {\n        return -1; \n    }\n\n    for (int i = 0; i < MAX_RECORDS; ++i) {\n        if (g_recordMetadata[i].is_active && g_recordMetadata[i].record_id == id) {\n            return i;\n        }\n    }\n\n    for (int i = 0; i < MAX_RECORDS; ++i) {\n        if (!g_recordMetadata[i].is_active) {\n            if (g_nextFreeBufferOffset + expected_total_len > REASSEMBLY_BUFFER_SIZE) {\n                return -2; \n            }\n\n            g_recordMetadata[i].record_id = id;\n            g_recordMetadata[i].total_expected_len = expected_total_len;\n            g_recordMetadata[i].current_len = 0;\n            g_recordMetadata[i].buffer_offset = g_nextFreeBufferOffset;\n            g_recordMetadata[i].is_active = true;\n\n            g_nextFreeBufferOffset += expected_total_len; \n\n            return i;\n        }\n    }\n    return -3; \n}\n\nint processRecordFragment(int record_meta_idx, uint16_t fragment_offset, const uint8_t* fragment_data, uint16_t fragment_len) {\n    if (record_meta_idx < 0 || record_meta_idx >= MAX_RECORDS || !g_recordMetadata[record_meta_idx].is_active) {\n        return -1; \n    }\n    if (fragment_data == NULL || fragment_len == 0) {\n        return -2; \n    }\n\n    RecordMetadata* record = &g_recordMetadata[record_meta_idx];\n\n    uint16_t dest_offset = record->buffer_offset + fragment_offset;\n\n    // FIX:\n    // The check now correctly verifies that the entire fragment (start + length)\n    // does not exceed the logical end of the record's allocated space.\n    // Using uint32_t for the sum avoids potential integer overflow if uint16_t values were near max, \n    // although with REASSEMBLY_BUFFER_SIZE of 512, uint16_t for sum is generally safe.\n    if ((uint32_t)dest_offset + fragment_len <= (uint32_t)record->buffer_offset + record->total_expected_len) {\n        for (uint16_t i = 0; i < fragment_len; ++i) {\n            g_reassemblyBuffer[dest_offset + i] = fragment_data[i];\n        }\n\n        uint16_t new_current_len = fragment_offset + fragment_len;\n        if (new_current_len > record->current_len) {\n            record->current_len = new_current_len;\n        }\n        return 0;\n    }\n\n    // If the check fails, return an error indicating out-of-bounds access attempt.\n    return -3; \n}\n\nvoid receiveVehicleDataFrame(uint16_t record_id, uint16_t fragment_offset, const uint8_t* data, uint16_t len) {\n    int record_idx = activateRecord(record_id, 50);\n    if (record_idx >= 0) {\n        processRecordFragment(record_idx, fragment_offset, data, len);\n    }\n}\n\nuint8_t getReassembledByte(uint16_t absolute_offset) {\n    if (absolute_offset < REASSEMBLY_BUFFER_SIZE) {\n        return g_reassemblyBuffer[absolute_offset];\n    }\n    return 0;\n}\n\nvoid runReassemblySimulation() {\n    initReassemblyManager();\n\n    int record_idx1 = activateRecord(101, 50);\n    int record_idx2 = activateRecord(102, 50);\n\n    uint8_t legit_fragment_r2[] = {0xA1, 0xA2, 0xA3, 0xA4, 0xA5}; \n    processRecordFragment(record_idx2, 0, legit_fragment_r2, sizeof(legit_fragment_r2));\n\n    // ATTACK SCENARIO (now prevented):\n    // The call below would have caused an out-of-bounds write in the vulnerable code.\n    // In the fixed code, this call will now correctly return -3 (Fragment offset out of bounds)\n    // because (dest_offset + fragment_len) would exceed record->total_expected_len.\n    uint8_t malicious_fragment_r1[20];\n    memset(malicious_fragment_r1, 0xFF, sizeof(malicious_fragment_r1)); \n    processRecordFragment(record_idx1, 40, malicious_fragment_r1, sizeof(malicious_fragment_r1));\n\n    // g_reassemblyBuffer[50] will retain its legitimate value (0xA1) as the overflow is prevented.\n}\n", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define SYSTEM_CONFIG_SIZE 1024\n#define MAX_CONFIG_GROUPS 10\n\n// Base offsets for each configuration group within the g_systemConfig array.\n// Note: g_groupBaseOffsets[9] is set to a value (65500) that, when combined with a \n// large item_index, can cause an integer overflow if the sum is implicitly cast to uint16_t.\nstatic const uint16_t g_groupBaseOffsets[MAX_CONFIG_GROUPS] = {\n    0,     // Group 0\n    50,    // Group 1\n    120,   // Group 2\n    250,   // Group 3\n    400,   // Group 4\n    600,   // Group 5\n    850,   // Group 6\n    1150,  // Group 7\n    1400,  // Group 8\n    65500  // Group 9 - VULNERABILITY FOCUS: Base offset causing overflow with item_index\n};\n\n// Global array storing various system configuration values.\nstatic uint16_t g_systemConfig[SYSTEM_CONFIG_SIZE]; \n\nvoid initSystemConfig() {\n    memset(g_systemConfig, 0, sizeof(g_systemConfig));\n    for (int i = 0; i < SYSTEM_CONFIG_SIZE; ++i) {\n        g_systemConfig[i] = i * 2; \n    }\n}\n\n// Function to update a specific configuration value based on group and item index.\n// group_id: Identifies the configuration group (0 to MAX_CONFIG_GROUPS-1).\n// item_index: Offset within the identified group (0 to 255 due to uint8_t).\n// new_value: The 16-bit value to write.\nint updateConfigurationValue(uint8_t group_id, uint8_t item_index, uint16_t new_value) {\n    if (group_id >= MAX_CONFIG_GROUPS) {\n        return -1; // Invalid group_id\n    }\n\n    // VULNERABILITY: Integer overflow in index calculation (CWE-190 leading to CWE-119).\n    // The sum of g_groupBaseOffsets[group_id] (uint16_t) and item_index (uint8_t) \n    // is implicitly performed as a uint16_t operation if final_index is declared as uint16_t.\n    // For example, if group_id is 9 (g_groupBaseOffsets[9] = 65500) and item_index is 100,\n    // the mathematical sum is 65500 + 100 = 65600. \n    // When stored in a uint16_t, 65600 overflows and wraps around to 65600 % 65536 = 64.\n    // The subsequent bounds check 'final_index >= SYSTEM_CONFIG_SIZE' is performed on this \n    // wrapped-around value (64 < 1024), which passes, allowing an out-of-bounds write\n    // relative to the *intended* logical address (65600) but an in-bounds write to an\n    // *unintended* physical address (64).\n    uint16_t final_index = g_groupBaseOffsets[group_id] + item_index;\n\n    if (final_index >= SYSTEM_CONFIG_SIZE) {\n        return -2; // This check may be bypassed due to integer overflow, leading to an OOB write.\n    }\n\n    g_systemConfig[final_index] = new_value; \n\n    return 0; // Success\n}\n\n// Dummy function to simulate receiving a configuration update command from a vehicle's network.\nvoid receiveConfigUpdateCommand(uint8_t group, uint8_t item, uint16_t val) {\n    updateConfigurationValue(group, item, val);\n}\n\n// Function to retrieve a config value (for testing/demonstration).\nuint16_t getSystemConfigValue(uint16_t index) {\n    if (index < SYSTEM_CONFIG_SIZE) {\n        return g_systemConfig[index];\n    }\n    return 0xFFFF; // Error: Index out of bounds\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define SYSTEM_CONFIG_SIZE 1024\n#define MAX_CONFIG_GROUPS 10\n\n// Base offsets for each configuration group within the g_systemConfig array.\nstatic const uint16_t g_groupBaseOffsets[MAX_CONFIG_GROUPS] = {\n    0,     // Group 0\n    50,    // Group 1\n    120,   // Group 2\n    250,   // Group 3\n    400,   // Group 4\n    600,   // Group 5\n    850,   // Group 6\n    1150,  // Group 7\n    1400,  // Group 8\n    65500  // Group 9\n};\n\n// Global array storing various system configuration values.\nstatic uint16_t g_systemConfig[SYSTEM_CONFIG_SIZE]; \n\nvoid initSystemConfig() {\n    memset(g_systemConfig, 0, sizeof(g_systemConfig));\n    for (int i = 0; i < SYSTEM_CONFIG_SIZE; ++i) {\n        g_systemConfig[i] = i * 2; \n    }\n}\n\n// Function to update a specific configuration value based on group and item index.\n// group_id: Identifies the configuration group (0 to MAX_CONFIG_GROUPS-1).\n// item_index: Offset within the identified group (0 to 255 due to uint8_t).\n// new_value: The 16-bit value to write.\nint updateConfigurationValue(uint8_t group_id, uint8_t item_index, uint16_t new_value) {\n    if (group_id >= MAX_CONFIG_GROUPS) {\n        return -1; // Invalid group_id\n    }\n\n    // FIX: Use a wider type (uint32_t) for the intermediate index calculation.\n    // This prevents integer overflow when adding g_groupBaseOffsets[group_id] and item_index.\n    // The full, correct logical index is maintained before comparison to array bounds.\n    uint32_t potential_final_index = (uint32_t)g_groupBaseOffsets[group_id] + item_index;\n\n    // Now, compare the correctly calculated index against the actual buffer size.\n    // This check will properly catch cases where the intended logical index exceeds \n    // the physical buffer size, even if a uint16_t overflow would have made it appear in-bounds.\n    if (potential_final_index >= SYSTEM_CONFIG_SIZE) {\n        return -2; // Calculated index (even before wrap-around) is out of array bounds\n    }\n    \n    // Cast the validated index back to uint16_t for array access, as it is now guaranteed to be safe.\n    uint16_t final_index = (uint16_t)potential_final_index;\n\n    g_systemConfig[final_index] = new_value; \n\n    return 0; // Success\n}\n\n// Dummy function to simulate receiving a configuration update command from a vehicle's network.\nvoid receiveConfigUpdateCommand(uint8_t group, uint8_t item, uint16_t val) {\n    updateConfigurationValue(group, item, val);\n}\n\n// Function to retrieve a config value (for testing/demonstration).\nuint16_t getSystemConfigValue(uint16_t index) {\n    if (index < SYSTEM_CONFIG_SIZE) {\n        return g_systemConfig[index];\n    }\n    return 0xFFFF; // Error: Index out of bounds\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_FRAME_BUFFER_SIZE 256\n#define MAX_ERROR_MESSAGE_LEN 60\n\n// Fixed offsets and sizes for telemetry frame components\n#define FRAME_HEADER_SIZE 4\n#define SENSOR_DATA_BLOCK_OFFSET FRAME_HEADER_SIZE\n#define SENSOR_DATA_BLOCK_SIZE 200 // This size makes the buffer vulnerable\n#define ERROR_MESSAGE_OFFSET (SENSOR_DATA_BLOCK_OFFSET + SENSOR_DATA_BLOCK_SIZE)\n\n// Global buffer for assembling the telemetry frame\nstatic uint8_t g_telemetryFrameBuffer[TELEMETRY_FRAME_BUFFER_SIZE];\n\nvoid initTelemetryFrameAssembler() {\n    memset(g_telemetryFrameBuffer, 0, TELEMETRY_FRAME_BUFFER_SIZE);\n}\n\n// Function to assemble a telemetry frame containing header, sensor data, and an error message.\n// sensor_data: Pointer to a fixed-size block of sensor readings.\n// error_msg: Pointer to a null-terminated error message string.\n// msg_len: The actual length of the error message (excluding null terminator).\n//\n// The frame structure is [Header (4 bytes)] [Sensor Data (200 bytes)] [Error Message (variable, up to MAX_ERROR_MESSAGE_LEN)]\n//\n// VULNERABILITY: Improper buffer bounds check for the error message segment.\n// The sum of fixed block sizes (Header + Sensor Data) and the maximum error message length\n// exceeds the total allocated buffer size. Specifically, ERROR_MESSAGE_OFFSET is 204,\n// and MAX_ERROR_MESSAGE_LEN is 60. A message of 60 bytes will attempt to write up to index\n// 204 + 60 - 1 = 263. However, TELEMETRY_FRAME_BUFFER_SIZE is 256, meaning valid indices\n// are 0-255. This results in an out-of-bounds write to g_telemetryFrameBuffer.\nint assembleTelemetryFrame(const uint8_t* sensor_data, const char* error_msg, uint8_t msg_len) {\n    if (sensor_data == NULL || error_msg == NULL) {\n        return -1; // Invalid input\n    }\n\n    // Populate fixed header fields\n    g_telemetryFrameBuffer[0] = 0xAA;\n    g_telemetryFrameBuffer[1] = 0x55;\n    g_telemetryFrameBuffer[2] = 0x01;\n    // Note: Total length field calculation here does not impact the vulnerability directly\n    // as the overflow is in the copy loop, not in this length field's value.\n    g_telemetryFrameBuffer[3] = (uint8_t)(FRAME_HEADER_SIZE + SENSOR_DATA_BLOCK_SIZE + msg_len);\n\n    // Copy sensor data block\n    // Assumes sensor_data is at least SENSOR_DATA_BLOCK_SIZE bytes\n    for (uint8_t i = 0; i < SENSOR_DATA_BLOCK_SIZE; ++i) {\n        g_telemetryFrameBuffer[SENSOR_DATA_BLOCK_OFFSET + i] = sensor_data[i];\n    }\n\n    // Check if error message length is within its individual defined maximum\n    if (msg_len > MAX_ERROR_MESSAGE_LEN) {\n        msg_len = MAX_ERROR_MESSAGE_LEN;\n    }\n\n    // Copy error message data into the telemetry frame.\n    // The loop iterates based on msg_len, without a sufficient check that\n    // ERROR_MESSAGE_OFFSET + i remains within TELEMETRY_FRAME_BUFFER_SIZE.\n    for (uint8_t i = 0; i < msg_len; ++i) {\n        g_telemetryFrameBuffer[ERROR_MESSAGE_OFFSET + i] = (uint8_t)error_msg[i];\n    }\n\n    return 0; // Success (even if overflow occurred)\n}\n\n// Dummy function to simulate receiving data from an internal module\nvoid simulateDataReception(const uint8_t* s_data, const char* e_msg, uint8_t e_len) {\n    assembleTelemetryFrame(s_data, e_msg, e_len);\n}\n\n// Dummy function to retrieve a byte from the assembled frame\nuint8_t getFrameByte(uint16_t index) {\n    if (index < TELEMETRY_FRAME_BUFFER_SIZE) {\n        return g_telemetryFrameBuffer[index];\n    }\n    return 0xFF; // Out of bounds read indication\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_FRAME_BUFFER_SIZE 256\n#define MAX_ERROR_MESSAGE_LEN 60\n\n// Fixed offsets and sizes for telemetry frame components\n#define FRAME_HEADER_SIZE 4\n#define SENSOR_DATA_BLOCK_OFFSET FRAME_HEADER_SIZE\n#define SENSOR_DATA_BLOCK_SIZE 200\n#define ERROR_MESSAGE_OFFSET (SENSOR_DATA_BLOCK_OFFSET + SENSOR_DATA_BLOCK_SIZE)\n\n// Global buffer for assembling the telemetry frame\nstatic uint8_t g_telemetryFrameBuffer[TELEMETRY_FRAME_BUFFER_SIZE];\n\nvoid initTelemetryFrameAssembler() {\n    memset(g_telemetryFrameBuffer, 0, TELEMETRY_FRAME_BUFFER_SIZE);\n}\n\n// Function to assemble a telemetry frame containing header, sensor data, and an error message.\n// sensor_data: Pointer to a fixed-size block of sensor readings.\n// error_msg: Pointer to a null-terminated error message string.\n// msg_len: The actual length of the error message (excluding null terminator).\n//\n// The frame structure is [Header (4 bytes)] [Sensor Data (200 bytes)] [Error Message (variable, up to MAX_ERROR_MESSAGE_LEN)]\n//\n// FIX: Introduce a comprehensive bounds check for the error message segment\n// to ensure it does not overflow the global telemetry buffer.\nint assembleTelemetryFrame(const uint8_t* sensor_data, const char* error_msg, uint8_t msg_len) {\n    if (sensor_data == NULL || error_msg == NULL) {\n        return -1; // Invalid input\n    }\n\n    // Populate fixed header fields\n    g_telemetryFrameBuffer[0] = 0xAA;\n    g_telemetryFrameBuffer[1] = 0x55;\n    g_telemetryFrameBuffer[2] = 0x01;\n    // Update total frame length field based on the 'actual_msg_len_to_copy'\n    g_telemetryFrameBuffer[3] = (uint8_t)(FRAME_HEADER_SIZE + SENSOR_DATA_BLOCK_SIZE + msg_len);\n\n    // Copy sensor data block\n    // Assumes sensor_data is at least SENSOR_DATA_BLOCK_SIZE bytes\n    for (uint8_t i = 0; i < SENSOR_DATA_BLOCK_SIZE; ++i) {\n        g_telemetryFrameBuffer[SENSOR_DATA_BLOCK_OFFSET + i] = sensor_data[i];\n    }\n\n    // Determine the actual number of bytes to copy for the error message.\n    // It must not exceed MAX_ERROR_MESSAGE_LEN AND must fit within the remaining buffer space.\n    uint8_t actual_msg_len_to_copy = msg_len;\n\n    if (actual_msg_len_to_copy > MAX_ERROR_MESSAGE_LEN) {\n        actual_msg_len_to_copy = MAX_ERROR_MESSAGE_LEN;\n    }\n\n    // Calculate the maximum number of bytes that can actually fit from ERROR_MESSAGE_OFFSET\n    // to the end of the telemetry buffer.\n    uint16_t available_space_for_error_msg = 0;\n    if (TELEMETRY_FRAME_BUFFER_SIZE > ERROR_MESSAGE_OFFSET) {\n        available_space_for_error_msg = TELEMETRY_FRAME_BUFFER_SIZE - ERROR_MESSAGE_OFFSET;\n    }\n\n    if (actual_msg_len_to_copy > available_space_for_error_msg) {\n        actual_msg_len_to_copy = (uint8_t)available_space_for_error_msg;\n    }\n\n    // Copy error message data into the telemetry frame using the safe length.\n    for (uint8_t i = 0; i < actual_msg_len_to_copy; ++i) {\n        g_telemetryFrameBuffer[ERROR_MESSAGE_OFFSET + i] = (uint8_t)error_msg[i];\n    }\n\n    // Update the total frame length in the header with the actual copied length\n    g_telemetryFrameBuffer[3] = (uint8_t)(FRAME_HEADER_SIZE + SENSOR_DATA_BLOCK_SIZE + actual_msg_len_to_copy);\n\n    return 0; // Success\n}\n\n// Dummy function to simulate receiving data from an internal module\nvoid simulateDataReception(const uint8_t* s_data, const char* e_msg, uint8_t e_len) {\n    assembleTelemetryFrame(s_data, e_msg, e_len);\n}\n\n// Dummy function to retrieve a byte from the assembled frame\nuint8_t getFrameByte(uint16_t index) {\n    if (index < TELEMETRY_FRAME_BUFFER_SIZE) {\n        return g_telemetryFrameBuffer[index];\n    }\n    return 0xFF; // Out of bounds read indication\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_FILE_SIZE 2048\n#define ECU_CONFIG_BUFFER_SIZE 256\n#define PARAMETER_BLOCK_SIZE 64 // Fixed size for processing parameters within a section\n\n// Global buffer holding the raw configuration data for an ECU\nstatic uint8_t g_ecuConfigData[ECU_CONFIG_BUFFER_SIZE];\n\n// Simulates a header for a configuration section within the main config file\ntypedef struct {\n    uint16_t section_id;\n    uint16_t section_length; // Total length of this section including this header\n    uint16_t num_parameters;\n} ConfigSectionHeader;\n\n// Function to process a specific configuration section from a larger config stream\n// raw_config_stream: Pointer to the start of the configuration section\n// stream_available_len: Total bytes available from raw_config_stream until end of message/file\nint processEcuConfigSection(const uint8_t* raw_config_stream, uint16_t stream_available_len) {\n    if (raw_config_stream == NULL || stream_available_len < sizeof(ConfigSectionHeader)) {\n        return -1; // Invalid input\n    }\n\n    const ConfigSectionHeader* header = (const ConfigSectionHeader*)raw_config_stream;\n\n    // Validate overall section length from the header against the available stream length.\n    if (header->section_length > stream_available_len || header->section_length < sizeof(ConfigSectionHeader)) {\n        return -2; // Section length inconsistent with available stream or too small\n    }\n\n    uint16_t data_offset = sizeof(ConfigSectionHeader); // Offset to the actual data within the section\n\n    // Calculate the length of the raw parameter data block within this section.\n    // This length is determined by the total section length declared in the header.\n    uint16_t raw_parameter_data_len = header->section_length - data_offset;\n\n    // VULNERABILITY: Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-119)\n    // A temporary buffer 'temp_param_block' is declared with a fixed size (PARAMETER_BLOCK_SIZE).\n    // 'raw_parameter_data_len' is derived from the 'section_length' which is controllable via input.\n    // There is no check to ensure that 'raw_parameter_data_len' does not exceed the size of 'temp_param_block'.\n    // If 'raw_parameter_data_len' is larger than PARAMETER_BLOCK_SIZE (e.g., 100 > 64),\n    // the memcpy will write beyond the bounds of 'temp_param_block' on the stack, leading to an OOB write.\n    // The subsequent check against ECU_CONFIG_BUFFER_SIZE is for the global buffer, not for 'temp_param_block'.\n    uint8_t temp_param_block[PARAMETER_BLOCK_SIZE]; // Fixed-size buffer for processing a parameter block\n\n    if (raw_parameter_data_len > 0) {\n        memcpy(temp_param_block, raw_config_stream + data_offset, raw_parameter_data_len);\n\n        // Simulate further processing on temp_param_block, then copy to global ECU config.\n        // Note: The overflow of temp_param_block may already have occurred here.\n        if (raw_parameter_data_len <= ECU_CONFIG_BUFFER_SIZE) {\n             memcpy(g_ecuConfigData, temp_param_block, raw_parameter_data_len);\n        } else {\n            return -3; // Parameter data too large for global ECU_CONFIG_BUFFER_SIZE\n        }\n    }\n\n    // Simulate further processing based on parameters if needed\n    // e.g., iterating header->num_parameters to parse elements from temp_param_block\n\n    return 0; // Success\n}\n\n// Dummy function to simulate receiving a configuration update from a vehicle network.\n// In a real system, full_config_msg might contain multiple sections,\n// but for this example, it points directly to the section being processed.\nvoid receiveConfigUpdate(const uint8_t* full_config_msg, uint16_t msg_len) {\n    processEcuConfigSection(full_config_msg, msg_len);\n}\n\n// Function to retrieve a config value for testing/demonstration.\nuint8_t getEcuConfigByte(uint16_t index) {\n    if (index < ECU_CONFIG_BUFFER_SIZE) {\n        return g_ecuConfigData[index];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_FILE_SIZE 2048\n#define ECU_CONFIG_BUFFER_SIZE 256\n#define PARAMETER_BLOCK_SIZE 64 // Fixed size for processing parameters within a section\n\n// Global buffer holding the raw configuration data for an ECU\nstatic uint8_t g_ecuConfigData[ECU_CONFIG_BUFFER_SIZE];\n\n// Simulates a header for a configuration section within the main config file\ntypedef struct {\n    uint16_t section_id;\n    uint16_t section_length; // Total length of this section including this header\n    uint16_t num_parameters;\n} ConfigSectionHeader;\n\n// Function to process a specific configuration section from a larger config stream\n// raw_config_stream: Pointer to the start of the configuration section\n// stream_available_len: Total bytes available from raw_config_stream until end of message/file\nint processEcuConfigSection(const uint8_t* raw_config_stream, uint16_t stream_available_len) {\n    if (raw_config_stream == NULL || stream_available_len < sizeof(ConfigSectionHeader)) {\n        return -1; // Invalid input\n    }\n\n    const ConfigSectionHeader* header = (const ConfigSectionHeader*)raw_config_stream;\n\n    // Validate overall section length from the header against the available stream length.\n    if (header->section_length > stream_available_len || header->section_length < sizeof(ConfigSectionHeader)) {\n        return -2; // Section length inconsistent with available stream or too small\n    }\n\n    uint16_t data_offset = sizeof(ConfigSectionHeader); // Offset to the actual data within the section\n\n    // Calculate the length of the raw parameter data block within this section.\n    // This length is determined by the total section length declared in the header.\n    uint16_t raw_parameter_data_len = header->section_length - data_offset;\n\n    uint8_t temp_param_block[PARAMETER_BLOCK_SIZE]; // Fixed-size buffer for processing a parameter block\n\n    if (raw_parameter_data_len > 0) {\n        // FIX: Add a bounds check to ensure the data to be copied fits within 'temp_param_block'.\n        // If 'raw_parameter_data_len' exceeds PARAMETER_BLOCK_SIZE, truncate it to prevent overflow.\n        uint16_t bytes_to_copy_to_temp = raw_parameter_data_len;\n        if (bytes_to_copy_to_temp > PARAMETER_BLOCK_SIZE) {\n            bytes_to_copy_to_temp = PARAMETER_BLOCK_SIZE; // Truncate to fit the temporary buffer\n            // Optionally, return an error or log a warning if data is truncated, depending on requirements.\n        }\n\n        memcpy(temp_param_block, raw_config_stream + data_offset, bytes_to_copy_to_temp);\n\n        // Simulate further processing on temp_param_block, then copy to global ECU config.\n        // Ensure the data copied from temp_param_block to g_ecuConfigData also respects its bounds.\n        if (bytes_to_copy_to_temp <= ECU_CONFIG_BUFFER_SIZE) {\n             memcpy(g_ecuConfigData, temp_param_block, bytes_to_copy_to_temp);\n        } else {\n            // This case should ideally not be reached if PARAMETER_BLOCK_SIZE <= ECU_CONFIG_BUFFER_SIZE\n            // and the logic is consistent, but kept for robustness.\n            return -3; // Parameter data too large for global ECU_CONFIG_BUFFER_SIZE (after truncation)\n        }\n    }\n\n    // Simulate further processing based on parameters if needed\n\n    return 0; // Success\n}\n\n// Dummy function to simulate receiving a configuration update from a vehicle network.\nvoid receiveConfigUpdate(const uint8_t* full_config_msg, uint16_t msg_len) {\n    processEcuConfigSection(full_config_msg, msg_len);\n}\n\n// Function to retrieve a config value for testing/demonstration.\nuint8_t getEcuConfigByte(uint16_t index) {\n    if (index < ECU_CONFIG_BUFFER_SIZE) {\n        return g_ecuConfigData[index];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOGGED_FAULTS 10\n#define CMD_LOG_FAULTS 0x01\n\nstatic uint16_t g_faultLogBuffer[MAX_LOGGED_FAULTS];\nstatic uint8_t g_currentFaultCount = 0;\n\nvoid initFaultLogger() {\n    memset(g_faultLogBuffer, 0, sizeof(g_faultLogBuffer));\n    g_currentFaultCount = 0;\n}\n\nint logDiagnosticFaults(const uint8_t* diag_packet, uint16_t packet_len) {\n    if (diag_packet == NULL || packet_len < 2) {\n        return -1;\n    }\n\n    uint8_t command_id = diag_packet[0];\n    if (command_id != CMD_LOG_FAULTS) {\n        return -2;\n    }\n\n    uint8_t num_faults = diag_packet[1];\n    uint16_t current_offset = 2;\n\n    g_currentFaultCount = 0;\n\n    for (uint8_t i = 0; i < num_faults; ++i) {\n        if (current_offset + sizeof(uint16_t) > packet_len) {\n            return -3;\n        }\n\n        uint16_t fault_code = (diag_packet[current_offset] << 8) | diag_packet[current_offset + 1];\n        current_offset += sizeof(uint16_t);\n\n        g_faultLogBuffer[i] = fault_code;\n        g_currentFaultCount++;\n    }\n\n    return 0;\n}\n\nvoid simulateDiagnosticRequest(const uint8_t* data, uint16_t len) {\n    logDiagnosticFaults(data, len);\n}\n\nuint8_t getLoggedFaultCount() {\n    return g_currentFaultCount;\n}\n\nuint16_t getLoggedFault(uint8_t index) {\n    if (index < g_currentFaultCount) {\n        return g_faultLogBuffer[index];\n    }\n    return 0xFFFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOGGED_FAULTS 10\n#define CMD_LOG_FAULTS 0x01\n\nstatic uint16_t g_faultLogBuffer[MAX_LOGGED_FAULTS];\nstatic uint8_t g_currentFaultCount = 0;\n\nvoid initFaultLogger() {\n    memset(g_faultLogBuffer, 0, sizeof(g_faultLogBuffer));\n    g_currentFaultCount = 0;\n}\n\nint logDiagnosticFaults(const uint8_t* diag_packet, uint16_t packet_len) {\n    if (diag_packet == NULL || packet_len < 2) {\n        return -1;\n    }\n\n    uint8_t command_id = diag_packet[0];\n    if (command_id != CMD_LOG_FAULTS) {\n        return -2;\n    }\n\n    uint8_t num_faults_requested = diag_packet[1];\n    uint16_t current_offset = 2;\n\n    g_currentFaultCount = 0;\n\n    uint8_t num_faults_to_log = num_faults_requested;\n    if (num_faults_to_log > MAX_LOGGED_FAULTS) {\n        num_faults_to_log = MAX_LOGGED_FAULTS;\n    }\n\n    uint16_t max_faults_in_packet_payload = (packet_len > 2) ? ((packet_len - 2) / sizeof(uint16_t)) : 0;\n    if (num_faults_to_log > max_faults_in_packet_payload) {\n        num_faults_to_log = (uint8_t)max_faults_in_packet_payload;\n    }\n\n    for (uint8_t i = 0; i < num_faults_to_log; ++i) {\n        if (current_offset + sizeof(uint16_t) > packet_len) {\n            break;\n        }\n\n        uint16_t fault_code = (diag_packet[current_offset] << 8) | diag_packet[current_offset + 1];\n        current_offset += sizeof(uint16_t);\n\n        g_faultLogBuffer[g_currentFaultCount] = fault_code;\n        g_currentFaultCount++;\n    }\n\n    return 0;\n}\n\nvoid simulateDiagnosticRequest(const uint8_t* data, uint16_t len) {\n    logDiagnosticFaults(data, len);\n}\n\nuint8_t getLoggedFaultCount() {\n    return g_currentFaultCount;\n}\n\nuint16_t getLoggedFault(uint8_t index) {\n    if (index < g_currentFaultCount) {\n        return g_faultLogBuffer[index];\n    }\n    return 0xFFFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define FLASH_CONFIG_TOTAL_SIZE 256 // Total bytes in the simulated flash configuration area\n#define MAX_CONFIG_DATA_ITEMS 10    // Maximum number of configurable data items\n\n// Simulated flash memory area containing various configuration items.\n// This is treated as a read-only area for normal operations, but its contents\n// are accessed based on metadata that can be manipulated.\nstatic const uint8_t g_simulatedFlashMemory[FLASH_CONFIG_TOTAL_SIZE] = {\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,\n    0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,\n    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,\n    0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,\n    0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,\n    0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n    0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF\n};\n\n// Static array defining the starting byte offset of each configuration item within g_simulatedFlashMemory.\n// This array is assumed to be immutable and correctly configured at build time.\nstatic const uint16_t g_configItemOffsets[MAX_CONFIG_DATA_ITEMS] = {\n    0,    // Item 0 starts at offset 0\n    10,   // Item 1 starts at offset 10\n    30,   // Item 2 starts at offset 30\n    35,   // Item 3 starts at offset 35\n    50,   // Item 4 starts at offset 50\n    80,   // Item 5 starts at offset 80\n    120,  // Item 6 starts at offset 120\n    170,  // Item 7 starts at offset 170\n    230,  // Item 8 starts at offset 230\n    250   // Item 9 starts at offset 250\n};\n\n// Mutable array storing the *configured size* of each data item.\n// This array can be updated via diagnostic commands or configuration updates.\n// VULNERABILITY SOURCE: This array is NOT validated against the total flash bounds during updates.\nstatic uint16_t g_configItemSizes[MAX_CONFIG_DATA_ITEMS] = {\n    10,  // Item 0: default size 10 bytes\n    20,  // Item 1: default size 20 bytes\n    5,   // Item 2: default size 5 bytes\n    15,  // Item 3: default size 15 bytes\n    30,  // Item 4: default size 30 bytes\n    40,  // Item 5: default size 40 bytes\n    50,  // Item 6: default size 50 bytes\n    60,  // Item 7: default size 60 bytes\n    20,  // Item 8: default size 20 bytes (offset 230 + size 20 = 250, fits in 256)\n    10   // Item 9: default size 10 bytes (offset 250 + size 10 = 260, would overflow if used)\n};\n\n// Function to initialize system configuration (e.g., at boot).\nvoid initConfigSystem() {\n    // In a real system, flash might be initialized with specific patterns or loaded from NVM.\n    // Here, g_simulatedFlashMemory is 'const' so we don't memset it directly.\n    // g_configItemSizes holds its default values.\n}\n\n// Function to update the size of a specific configuration item.\n// This simulates a diagnostic service command or an authorized configuration tool.\n// param item_id: The identifier for the configuration item to update.\n// param new_size: The new desired size for the item in bytes.\n// Returns 0 on success, or a negative error code on failure.\nint setConfigItemSize(uint8_t item_id, uint16_t new_size) {\n    if (item_id >= MAX_CONFIG_DATA_ITEMS) {\n        return -1; // Invalid item ID\n    }\n\n    // VULNERABILITY: Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-119)\n    // No check is performed here to ensure that the 'new_size', when added to the item's\n    // fixed 'g_configItemOffsets[item_id]', will not cause a subsequent read operation\n    // (e.g., by 'readConfigItem') to exceed the bounds of 'FLASH_CONFIG_TOTAL_SIZE'.\n    // An attacker can set a 'new_size' that leads to an out-of-bounds read in 'readConfigItem'.\n    // For instance, for item_id 8 (offset 230), setting new_size to 30 will lead to a read\n    // attempt at offset 230 for 30 bytes, accessing up to byte 259, which is beyond\n    // FLASH_CONFIG_TOTAL_SIZE (256).\n    g_configItemSizes[item_id] = new_size;\n    return 0; // Success\n}\n\n// Function to read a specific configuration item from the simulated flash memory.\n// This function relies on the sizes stored in g_configItemSizes, which can be vulnerable.\n// param item_id: The identifier for the configuration item to read.\n// param dest_buffer: Pointer to the caller-provided buffer where data will be copied.\n// param dest_buffer_size: The size of the caller-provided destination buffer.\n// Returns the actual bytes read on success, or a negative error code on failure.\nint readConfigItem(uint8_t item_id, uint8_t* dest_buffer, uint16_t dest_buffer_size) {\n    if (item_id >= MAX_CONFIG_DATA_ITEMS || dest_buffer == NULL) {\n        return -1; // Invalid item ID or destination buffer\n    }\n\n    uint16_t item_offset = g_configItemOffsets[item_id];\n    uint16_t item_size = g_configItemSizes[item_id]; // This size can be maliciously inflated\n\n    // Check if the destination buffer is large enough to hold the item.\n    // This check protects the 'dest_buffer' from overflow, but not the source 'g_simulatedFlashMemory'.\n    if (item_size > dest_buffer_size) {\n        return -2; // Destination buffer too small for the item\n    }\n\n    // VULNERABILITY TRIGGER: Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-119)\n    // If 'item_size' was previously set to a malicious value via 'setConfigItemSize',\n    // this memcpy operation will attempt to read 'item_size' bytes starting from 'item_offset'\n    // in 'g_simulatedFlashMemory'. If (item_offset + item_size) exceeds 'FLASH_CONFIG_TOTAL_SIZE',\n    // it results in an out-of-bounds read (CWE-125), potentially leaking sensitive information\n    // from adjacent memory or causing a system crash.\n    memcpy(dest_buffer, &g_simulatedFlashMemory[item_offset], item_size);\n\n    return item_size; // Return actual bytes read\n}\n\n// Dummy function to simulate a diagnostic tool's interaction pattern:\n// 1. Potentially manipulate a config item's size via a diagnostic command.\n// 2. Request to read the config item, triggering the out-of-bounds read.\nvoid simulateDiagnosticConfigAccess(uint8_t item_id_to_read, uint16_t malicious_size_to_set) {\n    // Initialize the system (in a real system, this would be part of bootup)\n    initConfigSystem();\n\n    // Step 1: An attacker or faulty system component sets a malicious size for a config item.\n    // This is where the root vulnerability lies if not properly validated.\n    setConfigItemSize(item_id_to_read, malicious_size_to_set);\n\n    // Prepare a buffer to receive the data.\n    uint8_t read_buffer[100]; // Max buffer size that the client can provide.\n    memset(read_buffer, 0, sizeof(read_buffer));\n\n    // Step 2: Another function (or the same attacker) requests to read the item.\n    // This read will now be vulnerable if the size was maliciously inflated.\n    readConfigItem(item_id_to_read, read_buffer, sizeof(read_buffer));\n}\n", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define FLASH_CONFIG_TOTAL_SIZE 256 // Total bytes in the simulated flash configuration area\n#define MAX_CONFIG_DATA_ITEMS 10    // Maximum number of configurable data items\n\n// Simulated flash memory area containing various configuration items.\n// This is treated as a read-only area for normal operations, but its contents\n// are accessed based on metadata that can be manipulated.\nstatic const uint8_t g_simulatedFlashMemory[FLASH_CONFIG_TOTAL_SIZE] = {\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,\n    0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,\n    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,\n    0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,\n    0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,\n    0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n    0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF\n};\n\n// Static array defining the starting byte offset of each configuration item within g_simulatedFlashMemory.\nstatic const uint16_t g_configItemOffsets[MAX_CONFIG_DATA_ITEMS] = {\n    0,\n    10,\n    30,\n    35,\n    50,\n    80,\n    120,\n    170,\n    230,\n    250\n};\n\n// Mutable array storing the *configured size* of each data item.\nstatic uint16_t g_configItemSizes[MAX_CONFIG_DATA_ITEMS] = {\n    10,\n    20,\n    5,\n    15,\n    30,\n    40,\n    50,\n    60,\n    20,\n    10\n};\n\nvoid initConfigSystem() {\n    // Initialization logic if needed.\n}\n\n// Function to update the size of a specific configuration item.\n// This simulates a diagnostic service command or an authorized configuration tool.\n// param item_id: The identifier for the configuration item to update.\n// param new_size: The new desired size for the item in bytes.\n// Returns 0 on success, or a negative error code on failure.\nint setConfigItemSize(uint8_t item_id, uint16_t new_size) {\n    if (item_id >= MAX_CONFIG_DATA_ITEMS) {\n        return -1; // Invalid item ID\n    }\n\n    // FIX: Add a bounds check here to prevent setting a size that would lead to an\n    // out-of-bounds read from 'g_simulatedFlashMemory' when later retrieved.\n    // Use uint32_t for intermediate calculation to prevent integer overflow in the check itself.\n    uint32_t potential_end_address = (uint32_t)g_configItemOffsets[item_id] + new_size;\n\n    if (potential_end_address > FLASH_CONFIG_TOTAL_SIZE) {\n        return -2; // New size would cause a read beyond flash memory bounds\n    }\n\n    g_configItemSizes[item_id] = new_size;\n    return 0; // Success\n}\n\n// Function to read a specific configuration item from the simulated flash memory.\n// It uses the sizes stored in g_configItemSizes.\n// param item_id: The identifier for the configuration item to read.\n// param dest_buffer: Pointer to the caller-provided buffer where data will be copied.\n// param dest_buffer_size: The size of the caller-provided destination buffer.\n// Returns the actual bytes read on success, or a negative error code on failure.\nint readConfigItem(uint8_t item_id, uint8_t* dest_buffer, uint16_t dest_buffer_size) {\n    if (item_id >= MAX_CONFIG_DATA_ITEMS || dest_buffer == NULL) {\n        return -1; // Invalid item ID or destination buffer\n    }\n\n    uint16_t item_offset = g_configItemOffsets[item_id];\n    uint16_t item_size = g_configItemSizes[item_id];\n\n    // Defense-in-depth: A redundant check to ensure the read operation stays within\n    // the source buffer's bounds. This handles scenarios where g_configItemSizes\n    // might have been corrupted through other means, or if setConfigItemSize had a flaw.\n    // Using uint32_t for calculation to prevent integer overflow for the bounds check.\n    if ((uint32_t)item_offset + item_size > FLASH_CONFIG_TOTAL_SIZE) {\n        return -3; // Detected corrupted item size/offset leading to out-of-bounds source read\n    }\n\n    // Check if the destination buffer is large enough to hold the item.\n    if (item_size > dest_buffer_size) {\n        return -4; // Destination buffer too small for the item\n    }\n\n    // The memcpy is now safe as both source and destination bounds are validated.\n    memcpy(dest_buffer, &g_simulatedFlashMemory[item_offset], item_size);\n\n    return item_size; // Return actual bytes read\n}\n\n// Dummy function to simulate a diagnostic tool's interaction pattern.\nvoid simulateDiagnosticConfigAccess(uint8_t item_id_to_read, uint16_t malicious_size_to_set) {\n    initConfigSystem();\n\n    // Step 1: An attacker or faulty system component attempts to set a malicious size.\n    // The fix in setConfigItemSize will now prevent this.\n    setConfigItemSize(item_id_to_read, malicious_size_to_set);\n\n    uint8_t read_buffer[100];\n    memset(read_buffer, 0, sizeof(read_buffer));\n\n    // Step 2: Request to read the item. This call is now protected.\n    readConfigItem(item_id_to_read, read_buffer, sizeof(read_buffer));\n}\n", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_RESPONSE_BUFFER_SIZE 256\n#define MAX_DIAG_ITEMS 10\n#define DIAG_ITEM_DATA_MAX_LEN 30 \n\nstatic uint8_t g_unpackedDiagData[DIAG_RESPONSE_BUFFER_SIZE];\nstatic uint16_t g_currentUnpackedOffset = 0;\n\ntypedef struct {\n    uint16_t item_id;\n    uint8_t  item_len; \n} DiagnosticItemHeader;\n\nvoid initDiagnosticSystem() {\n    memset(g_unpackedDiagData, 0, DIAG_RESPONSE_BUFFER_SIZE);\n    g_currentUnpackedOffset = 0;\n}\n\nint processDiagResponse(const uint8_t* response_msg, uint16_t msg_len) {\n    if (response_msg == NULL || msg_len < (sizeof(uint8_t) + sizeof(uint8_t))) {\n        return -1; \n    }\n\n    uint16_t current_msg_offset = 0;\n\n    uint8_t num_items = response_msg[current_msg_offset++];\n\n    uint8_t status_flag = response_msg[current_msg_offset++];\n\n    if (num_items == 0) {\n        g_currentUnpackedOffset = 0; \n        return 0;\n    }\n\n    if (num_items > MAX_DIAG_ITEMS) {\n        return -2; \n    }\n\n    g_currentUnpackedOffset = 0;\n\n    for (uint8_t i = 0; i < num_items; ++i) {\n        if (current_msg_offset + sizeof(DiagnosticItemHeader) > msg_len) {\n            return -3; \n        }\n\n        DiagnosticItemHeader header;\n        header.item_id = (response_msg[current_msg_offset] << 8) | response_msg[current_msg_offset + 1];\n        current_msg_offset += 2; \n\n        header.item_len = response_msg[current_msg_offset++]; \n        \n        if (header.item_len > DIAG_ITEM_DATA_MAX_LEN) {\n            return -6; \n        }\n\n        if (current_msg_offset + header.item_len > msg_len) {\n            return -4; \n        }\n\n        for (uint8_t j = 0; j < header.item_len; ++j) {\n            g_unpackedDiagData[g_currentUnpackedOffset + j] = response_msg[current_msg_offset + j];\n        }\n        g_currentUnpackedOffset += header.item_len; \n        current_msg_offset += header.item_len;      \n    }\n\n    return 0;\n}\n\nvoid simulateDiagMessageReceive(const uint8_t* data, uint16_t len) {\n    initDiagnosticSystem();\n    processDiagResponse(data, len);\n}\n\nvoid triggerVulnerability() {\n    uint8_t malicious_msg[332]; \n    uint16_t offset = 0;\n\n    malicious_msg[offset++] = MAX_DIAG_ITEMS; \n    malicious_msg[offset++] = 0; \n\n    for (uint8_t i = 0; i < MAX_DIAG_ITEMS; ++i) {\n        malicious_msg[offset++] = (uint8_t)(0x0001 >> 8); \n        malicious_msg[offset++] = (uint8_t)(0x0001 & 0xFF); \n        malicious_msg[offset++] = DIAG_ITEM_DATA_MAX_LEN; \n\n        for (uint8_t j = 0; j < DIAG_ITEM_DATA_MAX_LEN; ++j) {\n            malicious_msg[offset++] = 'A'; \n        }\n    }\n\n    simulateDiagMessageReceive(malicious_msg, offset);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_RESPONSE_BUFFER_SIZE 256\n#define MAX_DIAG_ITEMS 10\n#define DIAG_ITEM_DATA_MAX_LEN 30 \n\nstatic uint8_t g_unpackedDiagData[DIAG_RESPONSE_BUFFER_SIZE];\nstatic uint16_t g_currentUnpackedOffset = 0;\n\ntypedef struct {\n    uint16_t item_id;\n    uint8_t  item_len; \n} DiagnosticItemHeader;\n\nvoid initDiagnosticSystem() {\n    memset(g_unpackedDiagData, 0, DIAG_RESPONSE_BUFFER_SIZE);\n    g_currentUnpackedOffset = 0;\n}\n\nint processDiagResponse(const uint8_t* response_msg, uint16_t msg_len) {\n    if (response_msg == NULL || msg_len < (sizeof(uint8_t) + sizeof(uint8_t))) {\n        return -1; \n    }\n\n    uint16_t current_msg_offset = 0;\n\n    uint8_t num_items = response_msg[current_msg_offset++];\n\n    uint8_t status_flag = response_msg[current_msg_offset++];\n\n    if (num_items == 0) {\n        g_currentUnpackedOffset = 0; \n        return 0;\n    }\n\n    if (num_items > MAX_DIAG_ITEMS) {\n        return -2; \n    }\n\n    g_currentUnpackedOffset = 0;\n\n    for (uint8_t i = 0; i < num_items; ++i) {\n        if (current_msg_offset + sizeof(DiagnosticItemHeader) > msg_len) {\n            return -3; \n        }\n\n        DiagnosticItemHeader header;\n        header.item_id = (response_msg[current_msg_offset] << 8) | response_msg[current_msg_offset + 1];\n        current_msg_offset += 2; \n\n        header.item_len = response_msg[current_msg_offset++]; \n        \n        if (header.item_len > DIAG_ITEM_DATA_MAX_LEN) {\n            return -6; \n        }\n\n        if (current_msg_offset + header.item_len > msg_len) {\n            return -4; \n        }\n\n        if ((uint32_t)g_currentUnpackedOffset + header.item_len > DIAG_RESPONSE_BUFFER_SIZE) {\n            current_msg_offset += header.item_len; \n            return -5; \n        }\n\n        for (uint8_t j = 0; j < header.item_len; ++j) {\n            g_unpackedDiagData[g_currentUnpackedOffset + j] = response_msg[current_msg_offset + j];\n        }\n        g_currentUnpackedOffset += header.item_len; \n        current_msg_offset += header.item_len;      \n    }\n\n    return 0;\n}\n\nvoid simulateDiagMessageReceive(const uint8_t* data, uint16_t len) {\n    initDiagnosticSystem();\n    processDiagResponse(data, len);\n}\n\nvoid triggerVulnerability() {\n    uint8_t malicious_msg[332]; \n    uint16_t offset = 0;\n\n    malicious_msg[offset++] = MAX_DIAG_ITEMS; \n    malicious_msg[offset++] = 0; \n\n    for (uint8_t i = 0; i < MAX_DIAG_ITEMS; ++i) {\n        malicious_msg[offset++] = (uint8_t)(0x0001 >> 8); \n        malicious_msg[offset++] = (uint8_t)(0x0001 & 0xFF); \n        malicious_msg[offset++] = DIAG_ITEM_DATA_MAX_LEN; \n\n        for (uint8_t j = 0; j < DIAG_ITEM_DATA_MAX_LEN; ++j) {\n            malicious_msg[offset++] = 'A'; \n        }\n    }\n\n    simulateDiagMessageReceive(malicious_msg, offset);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_COMMAND_PACKET_SIZE 512\n#define VEHICLE_STATUS_BUFFER_SIZE 128\n#define COMMAND_HEADER_SIZE (sizeof(uint16_t) * 2)\n\nstatic uint8_t g_vehicleStatusData[VEHICLE_STATUS_BUFFER_SIZE];\n\nvoid initializeVehicleStatus() {\n    memset(g_vehicleStatusData, 0, VEHICLE_STATUS_BUFFER_SIZE);\n}\n\nint processStatusUpdatePayload(uint8_t target_offset, const uint8_t* source_data_ptr, uint16_t data_to_copy_len) {\n    if (source_data_ptr == NULL || data_to_copy_len == 0) {\n        return -1;\n    }\n\n    if (target_offset >= VEHICLE_STATUS_BUFFER_SIZE) {\n        return -3;\n    }\n\n    for (uint16_t i = 0; i < data_to_copy_len; ++i) {\n        g_vehicleStatusData[target_offset + i] = source_data_ptr[i];\n    }\n\n    return 0;\n}\n\nint handleVehicleCommandPacket(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len < COMMAND_HEADER_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_read_offset = 0;\n\n    while (current_read_offset + COMMAND_HEADER_SIZE <= packet_len) {\n        uint16_t cmd_id = (packet_data[current_read_offset] << 8) | packet_data[current_read_offset + 1];\n        uint16_t cmd_payload_len = (packet_data[current_read_offset + 2] << 8) | packet_data[current_read_offset + 3];\n        current_read_offset += COMMAND_HEADER_SIZE;\n\n        if (cmd_payload_len > (packet_len - current_read_offset)) {\n            return -2;\n        }\n\n        const uint8_t* command_payload_data_ptr = packet_data + current_read_offset;\n\n        if (cmd_id == 0x0101) {\n            if (cmd_payload_len >= 1) {\n                uint8_t target_offset = command_payload_data_ptr[0];\n                const uint8_t* data_to_copy_ptr = command_payload_data_ptr + 1;\n                uint16_t actual_data_len = cmd_payload_len - 1;\n\n                int res = processStatusUpdatePayload(target_offset, data_to_copy_ptr, actual_data_len);\n                if (res != 0) {\n                    return res;\n                }\n            }\n        }\n        \n        current_read_offset += cmd_payload_len;\n    }\n    return 0;\n}\n\nuint8_t getVehicleStatusByte(uint8_t index) {\n    if (index < VEHICLE_STATUS_BUFFER_SIZE) {\n        return g_vehicleStatusData[index];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_COMMAND_PACKET_SIZE 512\n#define VEHICLE_STATUS_BUFFER_SIZE 128\n#define COMMAND_HEADER_SIZE (sizeof(uint16_t) * 2)\n\nstatic uint8_t g_vehicleStatusData[VEHICLE_STATUS_BUFFER_SIZE];\n\nvoid initializeVehicleStatus() {\n    memset(g_vehicleStatusData, 0, VEHICLE_STATUS_BUFFER_SIZE);\n}\n\nint processStatusUpdatePayload(uint8_t target_offset, const uint8_t* source_data_ptr, uint16_t data_to_copy_len) {\n    if (source_data_ptr == NULL || data_to_copy_len == 0) {\n        return -1;\n    }\n\n    if ((uint32_t)target_offset + data_to_copy_len > VEHICLE_STATUS_BUFFER_SIZE) {\n        return -3;\n    }\n\n    for (uint16_t i = 0; i < data_to_copy_len; ++i) {\n        g_vehicleStatusData[target_offset + i] = source_data_ptr[i];\n    }\n\n    return 0;\n}\n\nint handleVehicleCommandPacket(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len < COMMAND_HEADER_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_read_offset = 0;\n\n    while (current_read_offset + COMMAND_HEADER_SIZE <= packet_len) {\n        uint16_t cmd_id = (packet_data[current_read_offset] << 8) | packet_data[current_read_offset + 1];\n        uint16_t cmd_payload_len = (packet_data[current_read_offset + 2] << 8) | packet_data[current_read_offset + 3];\n        current_read_offset += COMMAND_HEADER_SIZE;\n\n        if (cmd_payload_len > (packet_len - current_read_offset)) {\n            return -2;\n        }\n\n        const uint8_t* command_payload_data_ptr = packet_data + current_read_offset;\n\n        if (cmd_id == 0x0101) {\n            if (cmd_payload_len >= 1) {\n                uint8_t target_offset = command_payload_data_ptr[0];\n                const uint8_t* data_to_copy_ptr = command_payload_data_ptr + 1;\n                uint16_t actual_data_len = cmd_payload_len - 1;\n\n                int res = processStatusUpdatePayload(target_offset, data_to_copy_ptr, actual_data_len);\n                if (res != 0) {\n                    return res;\n                }\n            }\n        }\n        \n        current_read_offset += cmd_payload_len;\n    }\n    return 0;\n}\n\nuint8_t getVehicleStatusByte(uint8_t index) {\n    if (index < VEHICLE_STATUS_BUFFER_SIZE) {\n        return g_vehicleStatusData[index];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_SUBSYSTEM_PARAMS 10\n#define MAX_PARAM_DATA_SIZE 64 \n\ntypedef struct {\n    uint8_t* param_data_ptr;\n    uint16_t param_data_size;\n    bool is_initialized;\n} SubsystemParameter;\n\nstatic uint8_t engineParamBuffer1[20];\nstatic uint8_t engineParamBuffer2[10];\nstatic uint8_t engineParamBuffer3[30];\n\nstatic SubsystemParameter g_engineParameters[MAX_SUBSYSTEM_PARAMS];\n\nvoid initializeEngineParameters() {\n    memset(g_engineParameters, 0, sizeof(g_engineParameters));\n    \n    g_engineParameters[0] = (SubsystemParameter){.param_data_ptr = engineParamBuffer1, .param_data_size = sizeof(engineParamBuffer1), .is_initialized = true};\n    g_engineParameters[1] = (SubsystemParameter){.param_data_ptr = engineParamBuffer2, .param_data_size = sizeof(engineParamBuffer2), .is_initialized = true};\n    g_engineParameters[2] = (SubsystemParameter){.param_data_ptr = engineParamBuffer3, .param_data_size = sizeof(engineParamBuffer3), .is_initialized = true};\n}\n\n#define DIAG_SERVICE_READ_PARAM 0x22\n#define DIAG_RESPONSE_HEADER_SIZE 3 \n#define DIAG_MAX_RESPONSE_DATA_SIZE 128 \n\nint handleReadParameterRequest(const uint8_t* request_msg, uint16_t request_len, uint8_t* response_buffer, uint16_t* response_len) {\n    if (request_msg == NULL || response_buffer == NULL || response_len == NULL || request_len < 6) {\n        return -1; \n    }\n\n    if (request_msg[0] != DIAG_SERVICE_READ_PARAM) {\n        return -2; \n    }\n\n    uint8_t param_idx = request_msg[1];\n    uint16_t fragment_offset = (request_msg[2] << 8) | request_msg[3];\n    uint16_t fragment_length = (request_msg[4] << 8) | request_msg[5];\n\n    if (param_idx >= MAX_SUBSYSTEM_PARAMS) {\n        return -3; \n    }\n\n    SubsystemParameter* param = &g_engineParameters[param_idx];\n\n    if (!param->is_initialized || param->param_data_ptr == NULL) {\n        return -4; \n    }\n    \n    uint16_t actual_read_length = fragment_length;\n    if (actual_read_length > (DIAG_MAX_RESPONSE_DATA_SIZE - DIAG_RESPONSE_HEADER_SIZE)) {\n        actual_read_length = DIAG_MAX_RESPONSE_DATA_SIZE - DIAG_RESPONSE_HEADER_SIZE;\n    }\n\n    response_buffer[0] = DIAG_SERVICE_READ_PARAM | 0x40; \n    response_buffer[1] = 0x00; \n    response_buffer[2] = (uint8_t)actual_read_length; \n\n    for (uint16_t i = 0; i < actual_read_length; ++i) {\n        response_buffer[DIAG_RESPONSE_HEADER_SIZE + i] = param->param_data_ptr[fragment_offset + i];\n    }\n    *response_len = DIAG_RESPONSE_HEADER_SIZE + actual_read_length;\n\n    return 0;\n}\n\nvoid processDiagnosticRequest(const uint8_t* msg, uint16_t len, uint8_t* resp_buf, uint16_t* resp_len) {\n    if (!g_engineParameters[0].is_initialized) {\n        initializeEngineParameters();\n    }\n    handleReadParameterRequest(msg, len, resp_buf, resp_len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_SUBSYSTEM_PARAMS 10\n#define MAX_PARAM_DATA_SIZE 64 \n\ntypedef struct {\n    uint8_t* param_data_ptr;\n    uint16_t param_data_size;\n    bool is_initialized;\n} SubsystemParameter;\n\nstatic uint8_t engineParamBuffer1[20];\nstatic uint8_t engineParamBuffer2[10];\nstatic uint8_t engineParamBuffer3[30];\n\nstatic SubsystemParameter g_engineParameters[MAX_SUBSYSTEM_PARAMS];\n\nvoid initializeEngineParameters() {\n    memset(g_engineParameters, 0, sizeof(g_engineParameters));\n    \n    g_engineParameters[0] = (SubsystemParameter){.param_data_ptr = engineParamBuffer1, .param_data_size = sizeof(engineParamBuffer1), .is_initialized = true};\n    g_engineParameters[1] = (SubsystemParameter){.param_data_ptr = engineParamBuffer2, .param_data_size = sizeof(engineParamBuffer2), .is_initialized = true};\n    g_engineParameters[2] = (SubsystemParameter){.param_data_ptr = engineParamBuffer3, .param_data_size = sizeof(engineParamBuffer3), .is_initialized = true};\n}\n\n#define DIAG_SERVICE_READ_PARAM 0x22\n#define DIAG_RESPONSE_HEADER_SIZE 3 \n#define DIAG_MAX_RESPONSE_DATA_SIZE 128 \n\nint handleReadParameterRequest(const uint8_t* request_msg, uint16_t request_len, uint8_t* response_buffer, uint16_t* response_len) {\n    if (request_msg == NULL || response_buffer == NULL || response_len == NULL || request_len < 6) {\n        return -1; \n    }\n\n    if (request_msg[0] != DIAG_SERVICE_READ_PARAM) {\n        return -2; \n    }\n\n    uint8_t param_idx = request_msg[1];\n    uint16_t fragment_offset = (request_msg[2] << 8) | request_msg[3];\n    uint16_t fragment_length = (request_msg[4] << 8) | request_msg[5];\n\n    if (param_idx >= MAX_SUBSYSTEM_PARAMS) {\n        return -3; \n    }\n\n    SubsystemParameter* param = &g_engineParameters[param_idx];\n\n    if (!param->is_initialized || param->param_data_ptr == NULL) {\n        return -4; \n    }\n    \n    if (fragment_offset >= param->param_data_size || (uint32_t)fragment_offset + fragment_length > param->param_data_size) {\n        return -5; \n    }\n\n    uint16_t actual_read_length = fragment_length;\n    if (actual_read_length > (DIAG_MAX_RESPONSE_DATA_SIZE - DIAG_RESPONSE_HEADER_SIZE)) {\n        actual_read_length = DIAG_MAX_RESPONSE_DATA_SIZE - DIAG_RESPONSE_HEADER_SIZE;\n    }\n    if (actual_read_length > (param->param_data_size - fragment_offset)) {\n        actual_read_length = param->param_data_size - fragment_offset;\n    }\n\n    response_buffer[0] = DIAG_SERVICE_READ_PARAM | 0x40; \n    response_buffer[1] = 0x00; \n    response_buffer[2] = (uint8_t)actual_read_length; \n\n    for (uint16_t i = 0; i < actual_read_length; ++i) {\n        response_buffer[DIAG_RESPONSE_HEADER_SIZE + i] = param->param_data_ptr[fragment_offset + i];\n    }\n    *response_len = DIAG_RESPONSE_HEADER_SIZE + actual_read_length;\n\n    return 0;\n}\n\nvoid processDiagnosticRequest(const uint8_t* msg, uint16_t len, uint8_t* resp_buf, uint16_t* resp_len) {\n    if (!g_engineParameters[0].is_initialized) {\n        initializeEngineParameters();\n    }\n    handleReadParameterRequest(msg, len, resp_buf, resp_len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CAN_PAYLOAD_SIZE 8 \n#define RESPONSE_HEADER_SIZE 3 \n\nint constructDiagnosticResponse(uint8_t* output_buffer, uint16_t output_buffer_max_len,\n                                uint8_t message_id, uint8_t sub_id,\n                                const uint8_t* data_to_send, uint8_t data_len) {\n    if (output_buffer == NULL || data_to_send == NULL) {\n        return -1;\n    }\n\n    uint16_t required_payload_size = (uint16_t)RESPONSE_HEADER_SIZE + data_len;\n\n    if (required_payload_size > output_buffer_max_len) {\n        return -2;\n    }\n\n    output_buffer[0] = message_id;\n    output_buffer[1] = sub_id;\n    output_buffer[2] = data_len;\n\n    uint16_t current_payload_offset = RESPONSE_HEADER_SIZE;\n\n    for (uint8_t i = 0; i <= data_len; ++i) {\n        output_buffer[current_payload_offset + i] = data_to_send[i];\n    }\n\n    return required_payload_size;\n}\n\nvoid simulateCanRxHandler() {\n    uint8_t can_data_buffer[MAX_CAN_PAYLOAD_SIZE];\n    uint8_t sensor_data_to_reply[5];\n    memset(sensor_data_to_reply, 0xAA, sizeof(sensor_data_to_reply));\n\n    /* \n     * Simulate a response construction where data_len matches remaining buffer space. \n     * MAX_CAN_PAYLOAD_SIZE = 8 bytes.\n     * RESPONSE_HEADER_SIZE = 3 bytes.\n     * Remaining space for data = 8 - 3 = 5 bytes.\n     * If data_len is set to 5, the `required_payload_size` becomes 3 + 5 = 8.\n     * The check `(8 > 8)` is false, so it passes. \n     * However, the loop `for (uint8_t i = 0; i <= data_len; ++i)` will iterate 6 times (i=0 to 5).\n     * This means it will attempt to write to `output_buffer[3+5]`, which is `output_buffer[8]`, an out-of-bounds access.\n     */\n    constructDiagnosticResponse(can_data_buffer, MAX_CAN_PAYLOAD_SIZE, 0x01, 0x10, sensor_data_to_reply, sizeof(sensor_data_to_reply));\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CAN_PAYLOAD_SIZE 8 \n#define RESPONSE_HEADER_SIZE 3 \n\nint constructDiagnosticResponse(uint8_t* output_buffer, uint16_t output_buffer_max_len,\n                                uint8_t message_id, uint8_t sub_id,\n                                const uint8_t* data_to_send, uint8_t data_len) {\n    if (output_buffer == NULL || data_to_send == NULL) {\n        return -1;\n    }\n\n    uint16_t required_payload_size = (uint16_t)RESPONSE_HEADER_SIZE + data_len;\n\n    if (required_payload_size > output_buffer_max_len) {\n        return -2;\n    }\n\n    output_buffer[0] = message_id;\n    output_buffer[1] = sub_id;\n    output_buffer[2] = data_len;\n\n    uint16_t current_payload_offset = RESPONSE_HEADER_SIZE;\n\n    for (uint8_t i = 0; i < data_len; ++i) { /* FIX: Changed <= to < to correctly limit iterations */\n        output_buffer[current_payload_offset + i] = data_to_send[i];\n    }\n\n    return required_payload_size;\n}\n\nvoid simulateCanRxHandler() {\n    uint8_t can_data_buffer[MAX_CAN_PAYLOAD_SIZE];\n    uint8_t sensor_data_to_reply[5];\n    memset(sensor_data_to_reply, 0xAA, sizeof(sensor_data_to_reply));\n\n    constructDiagnosticResponse(can_data_buffer, MAX_CAN_PAYLOAD_SIZE, 0x01, 0x10, sensor_data_to_reply, sizeof(sensor_data_to_reply));\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_PARAMETERS 10\n#define PARAM_VALUE_BUFFER_SIZE 32\n#define MAX_INCOMING_DATA_LEN 256\n\ntypedef struct {\n    uint16_t param_id;\n    uint8_t  param_type;\n    uint8_t  value[PARAM_VALUE_BUFFER_SIZE];\n    uint8_t  current_len;\n} ParameterEntry;\n\nstatic ParameterEntry g_parameterStore[MAX_PARAMETERS];\nstatic uint8_t g_activeParameters = 0;\n\nvoid initParameterStore() {\n    memset(g_parameterStore, 0, sizeof(g_parameterStore));\n    g_activeParameters = 0;\n}\n\nint addParameterDefinition(uint16_t id, uint8_t type) {\n    if (g_activeParameters < MAX_PARAMETERS) {\n        g_parameterStore[g_activeParameters].param_id = id;\n        g_parameterStore[g_activeParameters].param_type = type;\n        g_parameterStore[g_activeParameters].current_len = 0;\n        g_activeParameters++;\n        return 0;\n    }\n    return -1;\n}\n\nint updateParameterValue(uint16_t target_param_id, const uint8_t* data, uint8_t data_len) {\n    if (data == NULL) {\n        return -1;\n    }\n\n    if (data_len > MAX_INCOMING_DATA_LEN) {\n        return -2;\n    }\n\n    int found_idx = -1;\n    for (uint8_t i = 0; i < g_activeParameters; ++i) {\n        if (g_parameterStore[i].param_id == target_param_id) {\n            found_idx = i;\n            break;\n        }\n    }\n\n    if (found_idx == -1) {\n        return -3;\n    }\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_parameterStore[found_idx].value[i] = data[i];\n    }\n\n    g_parameterStore[found_idx].current_len = data_len;\n\n    return 0;\n}\n\nint handleCANMessage(uint16_t msg_id, const uint8_t* msg_payload, uint8_t payload_len) {\n    if (msg_id == 0x123) {\n        if (payload_len < (sizeof(uint16_t) + sizeof(uint8_t) + 1)) {\n            return -1;\n        }\n        uint16_t param_id = (msg_payload[0] << 8) | msg_payload[1];\n        uint8_t data_len = msg_payload[2];\n        const uint8_t* data_ptr = &msg_payload[3];\n\n        if ((3 + data_len) > payload_len) {\n            return -5;\n        }\n\n        return updateParameterValue(param_id, data_ptr, data_len);\n    }\n    return 0;\n}\n\nuint8_t getParameterValueByte(uint16_t param_id, uint8_t index) {\n    int found_idx = -1;\n    for (uint8_t i = 0; i < g_activeParameters; ++i) {\n        if (g_parameterStore[i].param_id == param_id) {\n            found_idx = i;\n            break;\n        }\n    }\n    if (found_idx != -1 && index < g_parameterStore[found_idx].current_len) {\n        return g_parameterStore[found_idx].value[index];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_PARAMETERS 10\n#define PARAM_VALUE_BUFFER_SIZE 32\n#define MAX_INCOMING_DATA_LEN 256\n\ntypedef struct {\n    uint16_t param_id;\n    uint8_t  param_type;\n    uint8_t  value[PARAM_VALUE_BUFFER_SIZE];\n    uint8_t  current_len;\n} ParameterEntry;\n\nstatic ParameterEntry g_parameterStore[MAX_PARAMETERS];\nstatic uint8_t g_activeParameters = 0;\n\nvoid initParameterStore() {\n    memset(g_parameterStore, 0, sizeof(g_parameterStore));\n    g_activeParameters = 0;\n}\n\nint addParameterDefinition(uint16_t id, uint8_t type) {\n    if (g_activeParameters < MAX_PARAMETERS) {\n        g_parameterStore[g_activeParameters].param_id = id;\n        g_parameterStore[g_activeParameters].param_type = type;\n        g_parameterStore[g_activeParameters].current_len = 0;\n        g_activeParameters++;\n        return 0;\n    }\n    return -1;\n}\n\nint updateParameterValue(uint16_t target_param_id, const uint8_t* data, uint8_t data_len) {\n    if (data == NULL) {\n        return -1;\n    }\n\n    if (data_len > MAX_INCOMING_DATA_LEN) {\n        return -2;\n    }\n\n    int found_idx = -1;\n    for (uint8_t i = 0; i < g_activeParameters; ++i) {\n        if (g_parameterStore[i].param_id == target_param_id) {\n            found_idx = i;\n            break;\n        }\n    }\n\n    if (found_idx == -1) {\n        return -3;\n    }\n\n    uint8_t bytes_to_copy = data_len;\n    if (bytes_to_copy > PARAM_VALUE_BUFFER_SIZE) {\n        bytes_to_copy = PARAM_VALUE_BUFFER_SIZE;\n    }\n\n    for (uint8_t i = 0; i < bytes_to_copy; ++i) {\n        g_parameterStore[found_idx].value[i] = data[i];\n    }\n\n    g_parameterStore[found_idx].current_len = bytes_to_copy;\n\n    return 0;\n}\n\nint handleCANMessage(uint16_t msg_id, const uint8_t* msg_payload, uint8_t payload_len) {\n    if (msg_id == 0x123) {\n        if (payload_len < (sizeof(uint16_t) + sizeof(uint8_t) + 1)) {\n            return -1;\n        }\n        uint16_t param_id = (msg_payload[0] << 8) | msg_payload[1];\n        uint8_t data_len = msg_payload[2];\n        const uint8_t* data_ptr = &msg_payload[3];\n\n        if ((3 + data_len) > payload_len) {\n            return -5;\n        }\n\n        return updateParameterValue(param_id, data_ptr, data_len);\n    }\n    return 0;\n}\n\nuint8_t getParameterValueByte(uint16_t param_id, uint8_t index) {\n    int found_idx = -1;\n    for (uint8_t i = 0; i < g_activeParameters; ++i) {\n        if (g_parameterStore[i].param_id == param_id) {\n            found_idx = i;\n            break;\n        }\n    }\n    if (found_idx != -1 && index < g_parameterStore[found_idx].current_len) {\n        return g_parameterStore[found_idx].value[index];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define COMPONENT_STATE_BUFFER_SIZE 512\n#define MAX_STATE_DATA_SEGMENTS 10\n\nstatic uint8_t g_componentStateBuffer[COMPONENT_STATE_BUFFER_SIZE];\n\ntypedef struct {\n    uint8_t segment_id;\n    uint16_t segment_offset;\n    uint8_t segment_length;\n} StateSegmentDescriptor;\n\nstatic const StateSegmentDescriptor g_stateDescriptors[MAX_STATE_DATA_SEGMENTS] = {\n    {0x01, 0,   10},\n    {0x02, 10,  20},\n    {0x03, 30,  15},\n    {0x04, 45,  5},\n    {0x05, 50,  100},\n    {0x06, 150, 10},\n    {0x07, 160, 200},\n    {0x08, 360, 50},\n    {0x09, 410, 100},\n    {0x0A, 510, 3}\n};\n#define NUM_STATE_DESCRIPTORS (sizeof(g_stateDescriptors) / sizeof(StateSegmentDescriptor))\n\nvoid initializeComponentStates() {\n    memset(g_componentStateBuffer, 0, COMPONENT_STATE_BUFFER_SIZE);\n}\n\nint updateComponentStateSegment(uint8_t segment_id, const uint8_t* new_data, uint8_t new_data_len) {\n    if (new_data == NULL) {\n        return -1;\n    }\n\n    const StateSegmentDescriptor* target_desc = NULL;\n    for (int i = 0; i < NUM_STATE_DESCRIPTORS; ++i) {\n        if (g_stateDescriptors[i].segment_id == segment_id) {\n            target_desc = &g_stateDescriptors[i];\n            break;\n        }\n    }\n\n    if (target_desc == NULL) {\n        return -2;\n    }\n\n    if (new_data_len > target_desc->segment_length) {\n        return -3;\n    }\n\n    memcpy(g_componentStateBuffer + target_desc->segment_offset, new_data, new_data_len);\n\n    return 0;\n}\n\nvoid receiveComponentStateUpdate(uint8_t id, const uint8_t* data, uint8_t len) {\n    updateComponentStateSegment(id, data, len);\n}\n\nuint8_t getComponentStateByte(uint16_t index) {\n    if (index < COMPONENT_STATE_BUFFER_SIZE) {\n        return g_componentStateBuffer[index];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define COMPONENT_STATE_BUFFER_SIZE 512\n#define MAX_STATE_DATA_SEGMENTS 10\n\nstatic uint8_t g_componentStateBuffer[COMPONENT_STATE_BUFFER_SIZE];\n\ntypedef struct {\n    uint8_t segment_id;\n    uint16_t segment_offset;\n    uint8_t segment_length;\n} StateSegmentDescriptor;\n\nstatic const StateSegmentDescriptor g_stateDescriptors[MAX_STATE_DATA_SEGMENTS] = {\n    {0x01, 0,   10},\n    {0x02, 10,  20},\n    {0x03, 30,  15},\n    {0x04, 45,  5},\n    {0x05, 50,  100},\n    {0x06, 150, 10},\n    {0x07, 160, 200},\n    {0x08, 360, 50},\n    {0x09, 410, 100},\n    {0x0A, 510, 3}\n};\n#define NUM_STATE_DESCRIPTORS (sizeof(g_stateDescriptors) / sizeof(StateSegmentDescriptor))\n\nvoid initializeComponentStates() {\n    memset(g_componentStateBuffer, 0, COMPONENT_STATE_BUFFER_SIZE);\n}\n\nint updateComponentStateSegment(uint8_t segment_id, const uint8_t* new_data, uint8_t new_data_len) {\n    if (new_data == NULL) {\n        return -1;\n    }\n\n    const StateSegmentDescriptor* target_desc = NULL;\n    for (int i = 0; i < NUM_STATE_DESCRIPTORS; ++i) {\n        if (g_stateDescriptors[i].segment_id == segment_id) {\n            target_desc = &g_stateDescriptors[i];\n            break;\n        }\n    }\n\n    if (target_desc == NULL) {\n        return -2;\n    }\n\n    if (new_data_len > target_desc->segment_length) {\n        return -3;\n    }\n\n    if ((uint32_t)target_desc->segment_offset + new_data_len > COMPONENT_STATE_BUFFER_SIZE) {\n        return -4;\n    }\n\n    memcpy(g_componentStateBuffer + target_desc->segment_offset, new_data, new_data_len);\n\n    return 0;\n}\n\nvoid receiveComponentStateUpdate(uint8_t id, const uint8_t* data, uint8_t len) {\n    updateComponentStateSegment(id, data, len);\n}\n\nuint8_t getComponentStateByte(uint16_t index) {\n    if (index < COMPONENT_STATE_BUFFER_SIZE) {\n        return g_componentStateBuffer[index];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CALIBRATION_SIZE 512\n#define MAX_PROTOCOL_DATA_LENGTH 128\n#define MAX_PACKET_PROCESS_SIZE 64\n\nstatic uint8_t g_calibrationTable[MAX_CALIBRATION_SIZE];\nstatic uint8_t g_packetProcessingBuffer[MAX_PACKET_PROCESS_SIZE];\n\nvoid initCalibrationSystem() {\n    memset(g_calibrationTable, 0xFF, MAX_CALIBRATION_SIZE);\n    memset(g_packetProcessingBuffer, 0x00, MAX_PACKET_PROCESS_SIZE);\n}\n\ntypedef struct {\n    uint16_t table_id;\n    uint16_t start_offset;\n    uint8_t  data_len;\n    const uint8_t* payload;\n} CalibrationUpdateCommand;\n\nint processCalibrationUpdate(const CalibrationUpdateCommand* cmd) {\n    if (cmd == NULL || cmd->payload == NULL) {\n        return -1;\n    }\n\n    if (cmd->table_id != 0) {\n        return -2;\n    }\n\n    if (cmd->data_len > MAX_PROTOCOL_DATA_LENGTH || cmd->data_len == 0) {\n        return -3;\n    }\n\n    if (cmd->start_offset + cmd->data_len > MAX_CALIBRATION_SIZE) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < cmd->data_len; ++i) {\n        g_packetProcessingBuffer[i] = cmd->payload[i];\n    }\n\n    for (uint8_t i = 0; i < cmd->data_len; ++i) {\n        g_calibrationTable[cmd->start_offset + i] = g_packetProcessingBuffer[i];\n    }\n\n    return 0;\n}\n\nint receiveAndProcessCalibrationMessage(uint16_t table_id, uint16_t offset, uint8_t len, const uint8_t* data) {\n    CalibrationUpdateCommand cmd;\n    cmd.table_id = table_id;\n    cmd.start_offset = offset;\n    cmd.data_len = len;\n    cmd.payload = data;\n    return processCalibrationUpdate(&cmd);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CALIBRATION_SIZE 512\n#define MAX_PROTOCOL_DATA_LENGTH 128\n#define MAX_PACKET_PROCESS_SIZE 64\n\nstatic uint8_t g_calibrationTable[MAX_CALIBRATION_SIZE];\nstatic uint8_t g_packetProcessingBuffer[MAX_PACKET_PROCESS_SIZE];\n\nvoid initCalibrationSystem() {\n    memset(g_calibrationTable, 0xFF, MAX_CALIBRATION_SIZE);\n    memset(g_packetProcessingBuffer, 0x00, MAX_PACKET_PROCESS_SIZE);\n}\n\ntypedef struct {\n    uint16_t table_id;\n    uint16_t start_offset;\n    uint8_t  data_len;\n    const uint8_t* payload;\n} CalibrationUpdateCommand;\n\nint processCalibrationUpdate(const CalibrationUpdateCommand* cmd) {\n    if (cmd == NULL || cmd->payload == NULL) {\n        return -1;\n    }\n\n    if (cmd->table_id != 0) {\n        return -2;\n    }\n\n    if (cmd->data_len > MAX_PROTOCOL_DATA_LENGTH || cmd->data_len == 0) {\n        return -3;\n    }\n\n    if (cmd->data_len > MAX_PACKET_PROCESS_SIZE) {\n        return -5;\n    }\n\n    if (cmd->start_offset + cmd->data_len > MAX_CALIBRATION_SIZE) {\n        return -4;\n    }\n    \n    for (uint8_t i = 0; i < cmd->data_len; ++i) {\n        g_packetProcessingBuffer[i] = cmd->payload[i];\n    }\n\n    for (uint8_t i = 0; i < cmd->data_len; ++i) {\n        g_calibrationTable[cmd->start_offset + i] = g_packetProcessingBuffer[i];\n    }\n\n    return 0;\n}\n\nint receiveAndProcessCalibrationMessage(uint16_t table_id, uint16_t offset, uint8_t len, const uint8_t* data) {\n    CalibrationUpdateCommand cmd;\n    cmd.table_id = table_id;\n    cmd.start_offset = offset;\n    cmd.data_len = len;\n    cmd.payload = data;\n    return processCalibrationUpdate(&cmd);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_TELEMETRY_PACKET_SIZE 100\n#define FIXED_LOG_BUFFER_SIZE 32\n#define MAX_LOG_ENTRIES 5\n\ntypedef struct {\n    uint16_t packet_id;\n    uint8_t  dynamic_payload_len;\n    uint8_t  payload_data[MAX_TELEMETRY_PACKET_SIZE - 3];\n} TelemetryDataPacket;\n\ntypedef struct {\n    uint16_t log_id;\n    uint8_t  actual_payload_len;\n    uint8_t  fixed_log_buffer[FIXED_LOG_BUFFER_SIZE];\n    uint32_t timestamp;\n} TelemetryLogEntry;\n\nstatic TelemetryLogEntry g_telemetryLog[MAX_LOG_ENTRIES];\nstatic uint8_t g_currentLogEntryIndex = 0;\n\nvoid initTelemetryLog() {\n    for (int i = 0; i < MAX_LOG_ENTRIES; ++i) {\n        g_telemetryLog[i].log_id = 0;\n        g_telemetryLog[i].actual_payload_len = 0;\n        for (int j = 0; j < FIXED_LOG_BUFFER_SIZE; ++j) {\n            g_telemetryLog[i].fixed_log_buffer[j] = 0;\n        }\n        g_telemetryLog[i].timestamp = 0;\n    }\n    g_currentLogEntryIndex = 0;\n}\n\nint processTelemetryPacket(const TelemetryDataPacket* packet, uint32_t current_timestamp) {\n    if (packet == NULL) {\n        return -1;\n    }\n\n    if (g_currentLogEntryIndex >= MAX_LOG_ENTRIES) {\n        return -2;\n    }\n\n    TelemetryLogEntry* current_entry = &g_telemetryLog[g_currentLogEntryIndex];\n\n    current_entry->log_id = packet->packet_id;\n    current_entry->timestamp = current_timestamp;\n\n    for (uint8_t i = 0; i < packet->dynamic_payload_len; ++i) {\n        current_entry->fixed_log_buffer[i] = packet->payload_data[i];\n    }\n\n    current_entry->actual_payload_len = packet->dynamic_payload_len;\n\n    g_currentLogEntryIndex++;\n\n    return 0;\n}\n\nvoid simulateTelemetryReception() {\n    initTelemetryLog();\n\n    TelemetryDataPacket packet1 = {0};\n    packet1.packet_id = 0x101;\n    packet1.dynamic_payload_len = 20;\n    for (int i = 0; i < 20; ++i) {\n        packet1.payload_data[i] = (uint8_t)i;\n    }\n    processTelemetryPacket(&packet1, 1000);\n\n    TelemetryDataPacket packet2 = {0};\n    packet2.packet_id = 0x102;\n    packet2.dynamic_payload_len = 40;\n    for (int i = 0; i < 40; ++i) {\n        packet2.payload_data[i] = 0xAA;\n    }\n    processTelemetryPacket(&packet2, 1001);\n}", "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_TELEMETRY_PACKET_SIZE 100\n#define FIXED_LOG_BUFFER_SIZE 32\n#define MAX_LOG_ENTRIES 5\n\ntypedef struct {\n    uint16_t packet_id;\n    uint8_t  dynamic_payload_len;\n    uint8_t  payload_data[MAX_TELEMETRY_PACKET_SIZE - 3];\n} TelemetryDataPacket;\n\ntypedef struct {\n    uint16_t log_id;\n    uint8_t  actual_payload_len;\n    uint8_t  fixed_log_buffer[FIXED_LOG_BUFFER_SIZE];\n    uint32_t timestamp;\n} TelemetryLogEntry;\n\nstatic TelemetryLogEntry g_telemetryLog[MAX_LOG_ENTRIES];\nstatic uint8_t g_currentLogEntryIndex = 0;\n\nvoid initTelemetryLog() {\n    for (int i = 0; i < MAX_LOG_ENTRIES; ++i) {\n        g_telemetryLog[i].log_id = 0;\n        g_telemetryLog[i].actual_payload_len = 0;\n        for (int j = 0; j < FIXED_LOG_BUFFER_SIZE; ++j) {\n            g_telemetryLog[i].fixed_log_buffer[j] = 0;\n        }\n        g_telemetryLog[i].timestamp = 0;\n    }\n    g_currentLogEntryIndex = 0;\n}\n\nint processTelemetryPacket(const TelemetryDataPacket* packet, uint32_t current_timestamp) {\n    if (packet == NULL) {\n        return -1;\n    }\n\n    if (g_currentLogEntryIndex >= MAX_LOG_ENTRIES) {\n        return -2;\n    }\n\n    TelemetryLogEntry* current_entry = &g_telemetryLog[g_currentLogEntryIndex];\n\n    current_entry->log_id = packet->packet_id;\n    current_entry->timestamp = current_timestamp;\n\n    uint8_t bytes_to_copy = packet->dynamic_payload_len;\n\n    if (bytes_to_copy > FIXED_LOG_BUFFER_SIZE) {\n        bytes_to_copy = FIXED_LOG_BUFFER_SIZE;\n    }\n\n    for (uint8_t i = 0; i < bytes_to_copy; ++i) {\n        current_entry->fixed_log_buffer[i] = packet->payload_data[i];\n    }\n    \n    current_entry->actual_payload_len = bytes_to_copy;\n\n    g_currentLogEntryIndex++;\n\n    return 0;\n}\n\nvoid simulateTelemetryReception() {\n    initTelemetryLog();\n\n    TelemetryDataPacket packet1 = {0};\n    packet1.packet_id = 0x101;\n    packet1.dynamic_payload_len = 20;\n    for (int i = 0; i < 20; ++i) {\n        packet1.payload_data[i] = (uint8_t)i;\n    }\n    processTelemetryPacket(&packet1, 1000);\n\n    TelemetryDataPacket packet2 = {0};\n    packet2.packet_id = 0x102;\n    packet2.dynamic_payload_len = 40;\n    for (int i = 0; i < 40; ++i) {\n        packet2.payload_data[i] = 0xAA;\n    }\n    processTelemetryPacket(&packet2, 1001);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_RESPONSE_BUFFER_SIZE 256\n#define MAX_RAW_DIAG_DATA_LEN 100\n\nstatic uint8_t g_diagResponseBuffer[DIAG_RESPONSE_BUFFER_SIZE];\nstatic uint16_t g_responseWritePos = 0;\n\nvoid initDiagResponseSystem() {\n    memset(g_diagResponseBuffer, 0, DIAG_RESPONSE_BUFFER_SIZE);\n    g_responseWritePos = 0;\n}\n\nint buildDiagnosticResponse(const uint8_t* raw_data, uint16_t raw_data_len) {\n    if (raw_data == NULL || raw_data_len == 0 || raw_data_len > MAX_RAW_DIAG_DATA_LEN) {\n        return -1;\n    }\n\n    g_responseWritePos = 0;\n\n    for (uint16_t i = 0; i < raw_data_len; ++i) {\n        uint8_t current_byte = raw_data[i];\n\n        if (current_byte == 0xCC || current_byte == 0xEE) {\n            if (g_responseWritePos + 1 > DIAG_RESPONSE_BUFFER_SIZE) {\n                return -2;\n            }\n            g_diagResponseBuffer[g_responseWritePos++] = 0x1B;\n            g_diagResponseBuffer[g_responseWritePos++] = 0x01;\n            g_diagResponseBuffer[g_responseWritePos++] = current_byte;\n        } else {\n            if (g_responseWritePos + 1 > DIAG_RESPONSE_BUFFER_SIZE) {\n                return -2;\n            }\n            g_diagResponseBuffer[g_responseWritePos++] = current_byte;\n        }\n    }\n\n    return g_responseWritePos;\n}\n\nvoid sendDiagResponse(const uint8_t* data, uint16_t len) {\n    buildDiagnosticResponse(data, len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_RESPONSE_BUFFER_SIZE 256\n#define MAX_RAW_DIAG_DATA_LEN 100\n\nstatic uint8_t g_diagResponseBuffer[DIAG_RESPONSE_BUFFER_SIZE];\nstatic uint16_t g_responseWritePos = 0;\n\nvoid initDiagResponseSystem() {\n    memset(g_diagResponseBuffer, 0, DIAG_RESPONSE_BUFFER_SIZE);\n    g_responseWritePos = 0;\n}\n\nint buildDiagnosticResponse(const uint8_t* raw_data, uint16_t raw_data_len) {\n    if (raw_data == NULL || raw_data_len == 0 || raw_data_len > MAX_RAW_DIAG_DATA_LEN) {\n        return -1;\n    }\n\n    g_responseWritePos = 0;\n\n    for (uint16_t i = 0; i < raw_data_len; ++i) {\n        uint8_t current_byte = raw_data[i];\n\n        if (current_byte == 0xCC || current_byte == 0xEE) {\n            if (g_responseWritePos + 3 > DIAG_RESPONSE_BUFFER_SIZE) {\n                return -2;\n            }\n            g_diagResponseBuffer[g_responseWritePos++] = 0x1B;\n            g_diagResponseBuffer[g_responseWritePos++] = 0x01;\n            g_diagResponseBuffer[g_responseWritePos++] = current_byte;\n        } else {\n            if (g_responseWritePos + 1 > DIAG_RESPONSE_BUFFER_SIZE) {\n                return -2;\n            }\n            g_diagResponseBuffer[g_responseWritePos++] = current_byte;\n        }\n    }\n\n    return g_responseWritePos;\n}\n\nvoid sendDiagResponse(const uint8_t* data, uint16_t len) {\n    buildDiagnosticResponse(data, len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define SENSOR_CALIBRATION_MAX_POINTS 128\n#define DIAG_PACKET_MAX_PAYLOAD_SIZE 256\n\nstatic uint16_t g_sensorCalibration[SENSOR_CALIBRATION_MAX_POINTS];\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t sub_command;\n    uint16_t start_index;\n    uint16_t num_points;\n    uint8_t  payload[DIAG_PACKET_MAX_PAYLOAD_SIZE];\n} DiagnosticCommandPacket;\n\nvoid initSensorCalibration() {\n    for (int i = 0; i < SENSOR_CALIBRATION_MAX_POINTS; ++i) {\n        g_sensorCalibration[i] = 0xAAAA;\n    }\n}\n\nint processCalibrationUpdateCommand(const DiagnosticCommandPacket* packet, uint16_t packet_size) {\n    if (packet == NULL || packet_size < sizeof(DiagnosticCommandPacket) - DIAG_PACKET_MAX_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    if (packet->command_id != 0x01 || packet->sub_command != 0x01) {\n        return -2;\n    }\n\n    uint16_t requested_start_index = packet->start_index;\n    uint16_t requested_num_points = packet->num_points;\n\n    if (requested_num_points > (DIAG_PACKET_MAX_PAYLOAD_SIZE / sizeof(uint16_t))) {\n        return -3;\n    }\n\n    if (requested_start_index >= SENSOR_CALIBRATION_MAX_POINTS) {\n        return -4;\n    }\n\n    const uint16_t* new_values = (const uint16_t*)packet->payload;\n\n    for (uint16_t i = 0; i < requested_num_points; ++i) {\n        g_sensorCalibration[requested_start_index + i] = new_values[i];\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticMessage(const uint8_t* raw_message, uint16_t raw_message_len) {\n    initSensorCalibration();\n    processCalibrationUpdateCommand((const DiagnosticCommandPacket*)raw_message, raw_message_len);\n}\n\nuint16_t getSensorCalibrationValue(uint16_t index) {\n    if (index < SENSOR_CALIBRATION_MAX_POINTS) {\n        return g_sensorCalibration[index];\n    }\n    return 0xFFFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define SENSOR_CALIBRATION_MAX_POINTS 128\n#define DIAG_PACKET_MAX_PAYLOAD_SIZE 256\n\nstatic uint16_t g_sensorCalibration[SENSOR_CALIBRATION_MAX_POINTS];\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t sub_command;\n    uint16_t start_index;\n    uint16_t num_points;\n    uint8_t  payload[DIAG_PACKET_MAX_PAYLOAD_SIZE];\n} DiagnosticCommandPacket;\n\nvoid initSensorCalibration() {\n    for (int i = 0; i < SENSOR_CALIBRATION_MAX_POINTS; ++i) {\n        g_sensorCalibration[i] = 0xAAAA;\n    }\n}\n\nint processCalibrationUpdateCommand(const DiagnosticCommandPacket* packet, uint16_t packet_size) {\n    if (packet == NULL || packet_size < sizeof(DiagnosticCommandPacket) - DIAG_PACKET_MAX_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    if (packet->command_id != 0x01 || packet->sub_command != 0x01) {\n        return -2;\n    }\n\n    uint16_t requested_start_index = packet->start_index;\n    uint16_t requested_num_points = packet->num_points;\n\n    if (requested_num_points > (DIAG_PACKET_MAX_PAYLOAD_SIZE / sizeof(uint16_t))) {\n        return -3;\n    }\n\n    if (requested_start_index >= SENSOR_CALIBRATION_MAX_POINTS ||\n        (uint32_t)requested_start_index + requested_num_points > SENSOR_CALIBRATION_MAX_POINTS) {\n        return -4;\n    }\n\n    const uint16_t* new_values = (const uint16_t*)packet->payload;\n\n    for (uint16_t i = 0; i < requested_num_points; ++i) {\n        g_sensorCalibration[requested_start_index + i] = new_values[i];\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticMessage(const uint8_t* raw_message, uint16_t raw_message_len) {\n    initSensorCalibration();\n    processCalibrationUpdateCommand((const DiagnosticCommandPacket*)raw_message, raw_message_len);\n}\n\nuint16_t getSensorCalibrationValue(uint16_t index) {\n    if (index < SENSOR_CALIBRATION_MAX_POINTS) {\n        return g_sensorCalibration[index];\n    }\n    return 0xFFFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_TRANSPORT_BUFFER_SIZE 128\n#define FIRMWARE_SEGMENT_PAYLOAD_BUFFER_SIZE 10\n\ntypedef struct {\n    uint16_t address;\n    uint8_t  data_length; \n    uint8_t  payload[FIRMWARE_SEGMENT_PAYLOAD_BUFFER_SIZE];\n    uint16_t checksum;\n} FirmwareSegment;\n\nvoid initFirmwareStorage() {\n    \n}\n\nint deserializeFirmwareSegment_Vulnerable(const uint8_t* raw_buffer, uint16_t buffer_len, FirmwareSegment* out_segment) {\n    if (raw_buffer == NULL || out_segment == NULL || buffer_len < (sizeof(uint16_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    out_segment->address = (raw_buffer[current_offset] << 8) | raw_buffer[current_offset + 1];\n    current_offset += sizeof(uint16_t);\n\n    out_segment->data_length = raw_buffer[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    if (current_offset + out_segment->data_length > buffer_len) {\n        return -2;\n    }\n\n    for (uint8_t i = 0; i < out_segment->data_length; ++i) {\n        out_segment->payload[i] = raw_buffer[current_offset + i];\n    }\n\n    out_segment->checksum = 0;\n\n    return 0;\n}\n\nvoid handleIncomingFirmwarePacket_Vulnerable(const uint8_t* packet_data, uint16_t packet_len) {\n    FirmwareSegment segment;\n    deserializeFirmwareSegment_Vulnerable(packet_data, packet_len, &segment);\n}\n", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_TRANSPORT_BUFFER_SIZE 128\n#define FIRMWARE_SEGMENT_PAYLOAD_BUFFER_SIZE 10\n\ntypedef struct {\n    uint16_t address;\n    uint8_t  data_length;\n    uint8_t  payload[FIRMWARE_SEGMENT_PAYLOAD_BUFFER_SIZE];\n    uint16_t checksum;\n} FirmwareSegment;\n\nvoid initFirmwareStorage() {\n    \n}\n\nint deserializeFirmwareSegment_Fixed(const uint8_t* raw_buffer, uint16_t buffer_len, FirmwareSegment* out_segment) {\n    if (raw_buffer == NULL || out_segment == NULL || buffer_len < (sizeof(uint16_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    out_segment->address = (raw_buffer[current_offset] << 8) | raw_buffer[current_offset + 1];\n    current_offset += sizeof(uint16_t);\n\n    out_segment->data_length = raw_buffer[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    if (current_offset + out_segment->data_length > buffer_len) {\n        return -2;\n    }\n\n    uint8_t bytes_to_copy = out_segment->data_length;\n    if (bytes_to_copy > FIRMWARE_SEGMENT_PAYLOAD_BUFFER_SIZE) {\n        bytes_to_copy = FIRMWARE_SEGMENT_PAYLOAD_BUFFER_SIZE;\n    }\n\n    for (uint8_t i = 0; i < bytes_to_copy; ++i) {\n        out_segment->payload[i] = raw_buffer[current_offset + i];\n    }\n\n    if (bytes_to_copy < FIRMWARE_SEGMENT_PAYLOAD_BUFFER_SIZE) {\n        memset(out_segment->payload + bytes_to_copy, 0, FIRMWARE_SEGMENT_PAYLOAD_BUFFER_SIZE - bytes_to_copy);\n    }\n\n    out_segment->checksum = 0;\n\n    return 0;\n}\n\nvoid handleIncomingFirmwarePacket_Fixed(const uint8_t* packet_data, uint16_t packet_len) {\n    FirmwareSegment segment;\n    deserializeFirmwareSegment_Fixed(packet_data, packet_len, &segment);\n}\n", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define ECU_CONFIG_DATA_MAX_SIZE 128\n#define PARAM_ID_CUSTOM_SETTING 0x1A\n#define PARAM_ID_DIAG_MODE 0x05\n\nstatic uint8_t g_ecuConfigData[ECU_CONFIG_DATA_MAX_SIZE];\n\nvoid initEcuConfig() {\n    for (size_t i = 0; i < ECU_CONFIG_DATA_MAX_SIZE; ++i) {\n        g_ecuConfigData[i] = 0x00;\n    }\n    g_ecuConfigData[0] = 0xAA;\n    g_ecuConfigData[1] = 0xBB;\n    g_ecuConfigData[2] = 0xCC;\n}\n\nint processConfigParameter(const uint8_t* param_stream, uint16_t stream_len) {\n    if (param_stream == NULL || stream_len < 4) {\n        return -1;\n    }\n\n    uint16_t param_id = (param_stream[0] << 8) | param_stream[1];\n    uint16_t data_len = (param_stream[2] << 8) | param_stream[3];\n    const uint8_t* data_src_ptr = param_stream + 4;\n\n    if (4 + data_len > stream_len) {\n        return -2;\n    }\n\n    if (param_id == PARAM_ID_CUSTOM_SETTING) {\n        const uint8_t CUSTOM_SETTING_OFFSET = 10; \n\n        if (CUSTOM_SETTING_OFFSET >= ECU_CONFIG_DATA_MAX_SIZE) {\n            return -3;\n        }\n        \n        uint8_t* dest_ptr = &g_ecuConfigData[CUSTOM_SETTING_OFFSET];\n        for (uint16_t i = 0; i < data_len; ++i) {\n            *dest_ptr = data_src_ptr[i];\n            dest_ptr++;\n        }\n    } else if (param_id == PARAM_ID_DIAG_MODE) {\n        if (data_len != 1) return -4;\n        g_ecuConfigData[0] = data_src_ptr[0];\n    } else {\n        return -99;\n    }\n\n    return 0;\n}\n\nuint8_t getEcuConfigByte(uint8_t index) {\n    if (index < ECU_CONFIG_DATA_MAX_SIZE) {\n        return g_ecuConfigData[index];\n    }\n    return 0xFF;\n}\n\nvoid receiveConfigUpdate(const uint8_t* msg_data, uint16_t msg_len) {\n    processConfigParameter(msg_data, msg_len);\n}", "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define ECU_CONFIG_DATA_MAX_SIZE 128\n#define PARAM_ID_CUSTOM_SETTING 0x1A\n#define PARAM_ID_DIAG_MODE 0x05\n\nstatic uint8_t g_ecuConfigData[ECU_CONFIG_DATA_MAX_SIZE];\n\nvoid initEcuConfig() {\n    for (size_t i = 0; i < ECU_CONFIG_DATA_MAX_SIZE; ++i) {\n        g_ecuConfigData[i] = 0x00;\n    }\n    g_ecuConfigData[0] = 0xAA;\n    g_ecuConfigData[1] = 0xBB;\n    g_ecuConfigData[2] = 0xCC;\n}\n\nint processConfigParameter(const uint8_t* param_stream, uint16_t stream_len) {\n    if (param_stream == NULL || stream_len < 4) {\n        return -1;\n    }\n\n    uint16_t param_id = (param_stream[0] << 8) | param_stream[1];\n    uint16_t data_len = (param_stream[2] << 8) | param_stream[3];\n    const uint8_t* data_src_ptr = param_stream + 4;\n\n    if (4 + data_len > stream_len) {\n        return -2;\n    }\n\n    if (param_id == PARAM_ID_CUSTOM_SETTING) {\n        const uint8_t CUSTOM_SETTING_OFFSET = 10; \n\n        if (CUSTOM_SETTING_OFFSET >= ECU_CONFIG_DATA_MAX_SIZE) {\n            return -3;\n        }\n\n        if ((uint16_t)CUSTOM_SETTING_OFFSET + data_len > ECU_CONFIG_DATA_MAX_SIZE) {\n            return -5; \n        }\n        \n        uint8_t* dest_ptr = &g_ecuConfigData[CUSTOM_SETTING_OFFSET];\n        for (uint16_t i = 0; i < data_len; ++i) {\n            *dest_ptr = data_src_ptr[i];\n            dest_ptr++;\n        }\n    } else if (param_id == PARAM_ID_DIAG_MODE) {\n        if (data_len != 1) return -4;\n        g_ecuConfigData[0] = data_src_ptr[0];\n    } else {\n        return -99;\n    }\n\n    return 0;\n}\n\nuint8_t getEcuConfigByte(uint8_t index) {\n    if (index < ECU_CONFIG_DATA_MAX_SIZE) {\n        return g_ecuConfigData[index];\n    }\n    return 0xFF;\n}\n\nvoid receiveConfigUpdate(const uint8_t* msg_data, uint16_t msg_len) {\n    processConfigParameter(msg_data, msg_len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_DATA_BUFFER_SIZE 256\n#define COMPRESSED_PACKET_MAX_SIZE 128\n\ntypedef struct {\n    uint8_t  chunk_type;\n    uint8_t  compressed_len;\n} CompressedChunkHeader;\n\nstatic uint8_t g_decompressedConfigData[MAX_CONFIG_DATA_BUFFER_SIZE];\nstatic uint16_t g_decompressedDataOffset = 0;\n\nvoid initDecompressor() {\n    memset(g_decompressedConfigData, 0, MAX_CONFIG_DATA_BUFFER_SIZE);\n    g_decompressedDataOffset = 0;\n}\n\nint decompress_rle_chunk(const uint8_t* input_ptr, uint8_t compressed_len,\n                         uint8_t* output_ptr, uint16_t output_buffer_max_len,\n                         uint16_t current_output_offset) {\n    if (input_ptr == NULL || output_ptr == NULL || compressed_len % 2 != 0) {\n        return -1;\n    }\n\n    uint16_t bytes_written_in_chunk = 0;\n    uint8_t input_bytes_processed = 0;\n\n    while (input_bytes_processed < compressed_len) {\n        if (input_bytes_processed + 2 > compressed_len) {\n            return -2;\n        }\n\n        uint8_t byte_value = input_ptr[input_bytes_processed];\n        uint8_t repeat_count = input_ptr[input_bytes_processed + 1];\n\n        for (uint8_t i = 0; i < repeat_count; ++i) {\n            output_ptr[current_output_offset + bytes_written_in_chunk] = byte_value;\n            bytes_written_in_chunk++;\n        }\n        input_bytes_processed += 2;\n    }\n    return bytes_written_in_chunk;\n}\n\nint processCompressedConfigPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len == 0 || packet_len > COMPRESSED_PACKET_MAX_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_packet_offset = 0;\n    \n    while (current_packet_offset < packet_len) {\n        if (current_packet_offset + sizeof(CompressedChunkHeader) > packet_len) {\n            return -2;\n        }\n\n        const CompressedChunkHeader* header = (const CompressedChunkHeader*)(packet + current_packet_offset);\n        uint8_t chunk_type = header->chunk_type;\n        uint8_t compressed_chunk_len = header->compressed_len;\n\n        if (current_packet_offset + sizeof(CompressedChunkHeader) + compressed_chunk_len > packet_len) {\n            return -3;\n        }\n\n        const uint8_t* chunk_data_ptr = packet + current_packet_offset + sizeof(CompressedChunkHeader);\n\n        int decompress_result;\n        if (chunk_type == 0x01) {\n            decompress_result = decompress_rle_chunk(chunk_data_ptr, compressed_chunk_len,\n                                                    g_decompressedConfigData,\n                                                    MAX_CONFIG_DATA_BUFFER_SIZE,\n                                                    g_decompressedDataOffset);\n            if (decompress_result < 0) {\n                return -4;\n            }\n            g_decompressedDataOffset += decompress_result;\n        } else {\n\n        }\n\n        current_packet_offset += sizeof(CompressedChunkHeader) + compressed_chunk_len;\n    }\n\n    return 0;\n}\n\nvoid receiveCompressedUpdate(const uint8_t* data, uint16_t len) {\n    initDecompressor();\n    processCompressedConfigPacket(data, len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_DATA_BUFFER_SIZE 256\n#define COMPRESSED_PACKET_MAX_SIZE 128\n\ntypedef struct {\n    uint8_t  chunk_type;\n    uint8_t  compressed_len;\n} CompressedChunkHeader;\n\nstatic uint8_t g_decompressedConfigData[MAX_CONFIG_DATA_BUFFER_SIZE];\nstatic uint16_t g_decompressedDataOffset = 0;\n\nvoid initDecompressor() {\n    memset(g_decompressedConfigData, 0, MAX_CONFIG_DATA_BUFFER_SIZE);\n    g_decompressedDataOffset = 0;\n}\n\nint decompress_rle_chunk(const uint8_t* input_ptr, uint8_t compressed_len,\n                         uint8_t* output_ptr, uint16_t output_buffer_max_len,\n                         uint16_t current_output_offset) {\n    if (input_ptr == NULL || output_ptr == NULL || compressed_len % 2 != 0) {\n        return -1;\n    }\n\n    uint16_t bytes_written_in_chunk = 0;\n    uint8_t input_bytes_processed = 0;\n\n    while (input_bytes_processed < compressed_len) {\n        if (input_bytes_processed + 2 > compressed_len) {\n            return -2;\n        }\n\n        uint8_t byte_value = input_ptr[input_bytes_processed];\n        uint8_t repeat_count = input_ptr[input_bytes_processed + 1];\n\n        if ((uint32_t)current_output_offset + bytes_written_in_chunk + repeat_count > output_buffer_max_len) {\n            return -3;\n        }\n\n        for (uint8_t i = 0; i < repeat_count; ++i) {\n            output_ptr[current_output_offset + bytes_written_in_chunk] = byte_value;\n            bytes_written_in_chunk++;\n        }\n        input_bytes_processed += 2;\n    }\n    return bytes_written_in_chunk;\n}\n\nint processCompressedConfigPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len == 0 || packet_len > COMPRESSED_PACKET_MAX_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_packet_offset = 0;\n    \n    while (current_packet_offset < packet_len) {\n        if (current_packet_offset + sizeof(CompressedChunkHeader) > packet_len) {\n            return -2;\n        }\n\n        const CompressedChunkHeader* header = (const CompressedChunkHeader*)(packet + current_packet_offset);\n        uint8_t chunk_type = header->chunk_type;\n        uint8_t compressed_chunk_len = header->compressed_len;\n\n        if (current_packet_offset + sizeof(CompressedChunkHeader) + compressed_chunk_len > packet_len) {\n            return -3;\n        }\n\n        const uint8_t* chunk_data_ptr = packet + current_packet_offset + sizeof(CompressedChunkHeader);\n\n        int decompress_result;\n        if (chunk_type == 0x01) {\n            decompress_result = decompress_rle_chunk(chunk_data_ptr, compressed_chunk_len,\n                                                    g_decompressedConfigData,\n                                                    MAX_CONFIG_DATA_BUFFER_SIZE,\n                                                    g_decompressedDataOffset);\n            if (decompress_result < 0) {\n                return -4;\n            }\n            g_decompressedDataOffset += decompress_result;\n        } else {\n\n        }\n\n        current_packet_offset += sizeof(CompressedChunkHeader) + compressed_chunk_len;\n    }\n\n    return 0;\n}\n\nvoid receiveCompressedUpdate(const uint8_t* data, uint16_t len) {\n    initDecompressor();\n    processCompressedConfigPacket(data, len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_VEHICLE_PARAMS 256\n#define CAN_PAYLOAD_MAX_SIZE 8\n\nstatic uint8_t g_vehicleParameters[MAX_VEHICLE_PARAMS];\n\nvoid initVehicleParameters() {\n    memset(g_vehicleParameters, 0, MAX_VEHICLE_PARAMS);\n}\n\nint processParameterUpdate(const uint8_t* can_payload, uint8_t payload_len) {\n    if (can_payload == NULL || payload_len < 3) {\n        return -1;\n    }\n\n    uint16_t param_index = (can_payload[0] << 8) | can_payload[1];\n    uint8_t param_value = can_payload[2];\n\n    g_vehicleParameters[param_index] = param_value;\n\n    return 0;\n}\n\nvoid receiveCANMessage(const uint8_t* data, uint8_t len) {\n    processParameterUpdate(data, len);\n}\n\nuint8_t getVehicleParameter(uint8_t index) {\n    if (index < MAX_VEHICLE_PARAMS) {\n        return g_vehicleParameters[index];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_VEHICLE_PARAMS 256\n#define CAN_PAYLOAD_MAX_SIZE 8\n\nstatic uint8_t g_vehicleParameters[MAX_VEHICLE_PARAMS];\n\nvoid initVehicleParameters() {\n    memset(g_vehicleParameters, 0, MAX_VEHICLE_PARAMS);\n}\n\nint processParameterUpdate(const uint8_t* can_payload, uint8_t payload_len) {\n    if (can_payload == NULL || payload_len < 3) {\n        return -1;\n    }\n\n    uint16_t param_index = (can_payload[0] << 8) | can_payload[1];\n    uint8_t param_value = can_payload[2];\n\n    if (param_index >= MAX_VEHICLE_PARAMS) {\n        return -2;\n    }\n    \n    g_vehicleParameters[param_index] = param_value;\n\n    return 0;\n}\n\nvoid receiveCANMessage(const uint8_t* data, uint8_t len) {\n    processParameterUpdate(data, len);\n}\n\nuint8_t getVehicleParameter(uint8_t index) {\n    if (index < MAX_VEHICLE_PARAMS) {\n        return g_vehicleParameters[index];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define CONFIG_MEM_SIZE 1024\n#define MAX_PATCH_ENTRIES 16\n#define MAX_PATCH_PACKET_SIZE 512\n\nstatic uint8_t g_configMemory[CONFIG_MEM_SIZE];\n\ntypedef struct {\n    uint16_t offset;\n    uint8_t  length;\n} PatchEntryHeader;\n\ntypedef struct {\n    uint8_t          command_id;\n    uint8_t          num_patches;\n} PatchPacketHeader;\n\nvoid initConfigMemory() {\n    memset(g_configMemory, 0xAA, CONFIG_MEM_SIZE);\n}\n\nint applyConfigurationPatches(const uint8_t* raw_packet, uint16_t packet_len) {\n    if (raw_packet == NULL || packet_len < sizeof(PatchPacketHeader)) {\n        return -1;\n    }\n\n    const PatchPacketHeader* header = (const PatchPacketHeader*)raw_packet;\n    if (header->command_id != 0x01) {\n        return -2;\n    }\n\n    if (header->num_patches == 0 || header->num_patches > MAX_PATCH_ENTRIES) {\n        return -3;\n    }\n\n    uint16_t current_payload_offset = sizeof(PatchPacketHeader);\n    for (uint8_t i = 0; i < header->num_patches; ++i) {\n        if (current_payload_offset + sizeof(PatchEntryHeader) > packet_len) {\n            return -4;\n        }\n        \n        const PatchEntryHeader* entry_header = (const PatchEntryHeader*)(raw_packet + current_payload_offset);\n        \n        if (current_payload_offset + sizeof(PatchEntryHeader) + entry_header->length > packet_len) {\n            return -5;\n        }\n\n        if (entry_header->offset >= CONFIG_MEM_SIZE) {\n            return -6;\n        }\n\n        const uint8_t* patch_data_src = raw_packet + current_payload_offset + sizeof(PatchEntryHeader);\n        for (uint8_t j = 0; j < entry_header->length; ++j) {\n            g_configMemory[entry_header->offset + j] = patch_data_src[j];\n        }\n\n        current_payload_offset += sizeof(PatchEntryHeader) + entry_header->length;\n    }\n\n    return 0;\n}\n\nuint8_t getConfigByte(uint16_t offset) {\n    if (offset < CONFIG_MEM_SIZE) {\n        return g_configMemory[offset];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define CONFIG_MEM_SIZE 1024\n#define MAX_PATCH_ENTRIES 16\n#define MAX_PATCH_PACKET_SIZE 512\n\nstatic uint8_t g_configMemory[CONFIG_MEM_SIZE];\n\ntypedef struct {\n    uint16_t offset;\n    uint8_t  length;\n} PatchEntryHeader;\n\ntypedef struct {\n    uint8_t          command_id;\n    uint8_t          num_patches;\n} PatchPacketHeader;\n\nvoid initConfigMemory() {\n    memset(g_configMemory, 0xAA, CONFIG_MEM_SIZE);\n}\n\nint applyConfigurationPatches(const uint8_t* raw_packet, uint16_t packet_len) {\n    if (raw_packet == NULL || packet_len < sizeof(PatchPacketHeader)) {\n        return -1;\n    }\n\n    const PatchPacketHeader* header = (const PatchPacketHeader*)raw_packet;\n    if (header->command_id != 0x01) {\n        return -2;\n    }\n\n    if (header->num_patches == 0 || header->num_patches > MAX_PATCH_ENTRIES) {\n        return -3;\n    }\n\n    uint16_t current_payload_offset = sizeof(PatchPacketHeader);\n    for (uint8_t i = 0; i < header->num_patches; ++i) {\n        if (current_payload_offset + sizeof(PatchEntryHeader) > packet_len) {\n            return -4;\n        }\n        \n        const PatchEntryHeader* entry_header = (const PatchEntryHeader*)(raw_packet + current_payload_offset);\n        \n        if (current_payload_offset + sizeof(PatchEntryHeader) + entry_header->length > packet_len) {\n            return -5;\n        }\n\n        if (entry_header->offset >= CONFIG_MEM_SIZE || (uint32_t)entry_header->offset + entry_header->length > CONFIG_MEM_SIZE) {\n            return -6;\n        }\n\n        const uint8_t* patch_data_src = raw_packet + current_payload_offset + sizeof(PatchEntryHeader);\n        for (uint8_t j = 0; j < entry_header->length; ++j) {\n            g_configMemory[entry_header->offset + j] = patch_data_src[j];\n        }\n\n        current_payload_offset += sizeof(PatchEntryHeader) + entry_header->length;\n    }\n\n    return 0;\n}\n\nuint8_t getConfigByte(uint16_t offset) {\n    if (offset < CONFIG_MEM_SIZE) {\n        return g_configMemory[offset];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_DATA_REGION_SIZE 512\n#define MAX_COMMAND_PAYLOAD_SIZE 64\n\nstatic uint8_t g_diagDataRegion[DIAG_DATA_REGION_SIZE];\n\ntypedef struct {\n    uint16_t target_address;\n    uint8_t  data_length;\n    uint8_t  data[MAX_COMMAND_PAYLOAD_SIZE];\n} DiagWriteCommand;\n\nvoid initDiagDataRegion() {\n    memset(g_diagDataRegion, 0x00, DIAG_DATA_REGION_SIZE);\n}\n\nint processDiagWriteCommand_Vulnerable(const uint8_t* raw_command_data, uint16_t raw_command_len) {\n    if (raw_command_data == NULL || raw_command_len < (sizeof(uint16_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    DiagWriteCommand cmd;\n    cmd.target_address = (raw_command_data[0] << 8) | raw_command_data[1];\n    cmd.data_length = raw_command_data[2];\n\n    if (raw_command_len != (sizeof(uint16_t) + sizeof(uint8_t) + cmd.data_length)) {\n        return -2;\n    }\n\n    if (cmd.data_length > MAX_COMMAND_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    if (cmd.target_address >= DIAG_DATA_REGION_SIZE) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < cmd.data_length; ++i) {\n        g_diagDataRegion[cmd.target_address + i] = raw_command_data[3 + i];\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticCommand(const uint8_t* data, uint16_t len) {\n    processDiagWriteCommand_Vulnerable(data, len);\n}\n\nuint8_t getDiagDataByte(uint16_t index) {\n    if (index < DIAG_DATA_REGION_SIZE) {\n        return g_diagDataRegion[index];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_DATA_REGION_SIZE 512\n#define MAX_COMMAND_PAYLOAD_SIZE 64\n\nstatic uint8_t g_diagDataRegion[DIAG_DATA_REGION_SIZE];\n\ntypedef struct {\n    uint16_t target_address;\n    uint8_t  data_length;\n    uint8_t  data[MAX_COMMAND_PAYLOAD_SIZE];\n} DiagWriteCommand;\n\nvoid initDiagDataRegion() {\n    memset(g_diagDataRegion, 0x00, DIAG_DATA_REGION_SIZE);\n}\n\nint processDiagWriteCommand_Fixed(const uint8_t* raw_command_data, uint16_t raw_command_len) {\n    if (raw_command_data == NULL || raw_command_len < (sizeof(uint16_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    DiagWriteCommand cmd;\n    cmd.target_address = (raw_command_data[0] << 8) | raw_command_data[1];\n    cmd.data_length = raw_command_data[2];\n\n    if (raw_command_len != (sizeof(uint16_t) + sizeof(uint8_t) + cmd.data_length)) {\n        return -2;\n    }\n\n    if (cmd.data_length > MAX_COMMAND_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    if (cmd.target_address >= DIAG_DATA_REGION_SIZE || (uint32_t)cmd.target_address + cmd.data_length > DIAG_DATA_REGION_SIZE) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < cmd.data_length; ++i) {\n        g_diagDataRegion[cmd.target_address + i] = raw_command_data[3 + i];\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticCommand_Fixed(const uint8_t* data, uint16_t len) {\n    processDiagWriteCommand_Fixed(data, len);\n}\n\nuint8_t getDiagDataByte(uint16_t index) {\n    if (index < DIAG_DATA_REGION_SIZE) {\n        return g_diagDataRegion[index];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define CONFIG_TABLE_SIZE 256 \n\nstatic uint8_t g_configTable[CONFIG_TABLE_SIZE];\n\ntypedef enum {\n    CFG_TYPE_UINT8 = 0,\n    CFG_TYPE_UINT16,\n    CFG_TYPE_UINT32,\n    CFG_TYPE_MAX\n} ConfigDataType;\n\nstatic uint8_t getConfigTypeSize(ConfigDataType type) {\n    switch (type) {\n        case CFG_TYPE_UINT8:  return 1;\n        case CFG_TYPE_UINT16: return 2;\n        case CFG_TYPE_UINT32: return 4;\n        default: return 0;\n    }\n}\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t offset;\n    ConfigDataType data_type;\n} ConfigEntryDescriptor;\n\nstatic const ConfigEntryDescriptor g_cfgDescriptors[] = {\n    {0x1001, 0, CFG_TYPE_UINT16},\n    {0x1002, 2, CFG_TYPE_UINT8},\n    {0x1003, 3, CFG_TYPE_UINT32},\n    {0x1004, 7, CFG_TYPE_UINT16},\n    {0x2001, 250, CFG_TYPE_UINT8},\n    {0x2002, 255, CFG_TYPE_UINT16}\n};\n#define NUM_CFG_ENTRIES (sizeof(g_cfgDescriptors) / sizeof(ConfigEntryDescriptor))\n\nvoid initConfigTable() {\n    memset(g_configTable, 0, CONFIG_TABLE_SIZE);\n}\n\nint updateConfigEntryValue(uint16_t entry_id, const uint8_t* new_value_bytes, uint8_t max_value_len) {\n    if (new_value_bytes == NULL || max_value_len == 0) {\n        return -1;\n    }\n\n    const ConfigEntryDescriptor* target_entry = NULL;\n    for (int i = 0; i < NUM_CFG_ENTRIES; ++i) {\n        if (g_cfgDescriptors[i].entry_id == entry_id) {\n            target_entry = &g_cfgDescriptors[i];\n            break;\n        }\n    }\n\n    if (target_entry == NULL) {\n        return -2;\n    }\n\n    uint8_t required_size = getConfigTypeSize(target_entry->data_type);\n\n    if (required_size == 0 || required_size > max_value_len) {\n        return -3;\n    }\n\n    if (target_entry->offset >= CONFIG_TABLE_SIZE) {\n        return -5;\n    }\n\n    switch (target_entry->data_type) {\n        case CFG_TYPE_UINT8:\n            g_configTable[target_entry->offset] = new_value_bytes[0];\n            break;\n        case CFG_TYPE_UINT16:\n            *(uint16_t*)(g_configTable + target_entry->offset) = *(uint16_t*)new_value_bytes;\n            break;\n        case CFG_TYPE_UINT32:\n            *(uint32_t*)(g_configTable + target_entry->offset) = *(uint32_t*)new_value_bytes;\n            break;\n        default:\n            return -4;\n    }\n\n    return 0;\n}\n\nvoid simulateConfigUpdate(uint16_t id, const uint8_t* data, uint8_t len) {\n    updateConfigEntryValue(id, data, len);\n}\n\nuint8_t getConfigByte(uint16_t offset) {\n    if (offset < CONFIG_TABLE_SIZE) {\n        return g_configTable[offset];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define CONFIG_TABLE_SIZE 256 \n\nstatic uint8_t g_configTable[CONFIG_TABLE_SIZE];\n\ntypedef enum {\n    CFG_TYPE_UINT8 = 0,\n    CFG_TYPE_UINT16,\n    CFG_TYPE_UINT32,\n    CFG_TYPE_MAX\n} ConfigDataType;\n\nstatic uint8_t getConfigTypeSize(ConfigDataType type) {\n    switch (type) {\n        case CFG_TYPE_UINT8:  return 1;\n        case CFG_TYPE_UINT16: return 2;\n        case CFG_TYPE_UINT32: return 4;\n        default: return 0;\n    }\n}\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t offset;\n    ConfigDataType data_type;\n} ConfigEntryDescriptor;\n\nstatic const ConfigEntryDescriptor g_cfgDescriptors[] = {\n    {0x1001, 0, CFG_TYPE_UINT16},\n    {0x1002, 2, CFG_TYPE_UINT8},\n    {0x1003, 3, CFG_TYPE_UINT32},\n    {0x1004, 7, CFG_TYPE_UINT16},\n    {0x2001, 250, CFG_TYPE_UINT8},\n    {0x2002, 255, CFG_TYPE_UINT16}\n};\n#define NUM_CFG_ENTRIES (sizeof(g_cfgDescriptors) / sizeof(ConfigEntryDescriptor))\n\nvoid initConfigTable() {\n    memset(g_configTable, 0, CONFIG_TABLE_SIZE);\n}\n\nint updateConfigEntryValue(uint16_t entry_id, const uint8_t* new_value_bytes, uint8_t max_value_len) {\n    if (new_value_bytes == NULL || max_value_len == 0) {\n        return -1;\n    }\n\n    const ConfigEntryDescriptor* target_entry = NULL;\n    for (int i = 0; i < NUM_CFG_ENTRIES; ++i) {\n        if (g_cfgDescriptors[i].entry_id == entry_id) {\n            target_entry = &g_cfgDescriptors[i];\n            break;\n        }\n    }\n\n    if (target_entry == NULL) {\n        return -2;\n    }\n\n    uint8_t required_size = getConfigTypeSize(target_entry->data_type);\n\n    if (required_size == 0 || required_size > max_value_len) {\n        return -3;\n    }\n\n    if ((uint32_t)target_entry->offset + required_size > CONFIG_TABLE_SIZE) {\n        return -5;\n    }\n\n    switch (target_entry->data_type) {\n        case CFG_TYPE_UINT8:\n            g_configTable[target_entry->offset] = new_value_bytes[0];\n            break;\n        case CFG_TYPE_UINT16:\n            *(uint16_t*)(g_configTable + target_entry->offset) = *(uint16_t*)new_value_bytes;\n            break;\n        case CFG_TYPE_UINT32:\n            *(uint32_t*)(g_configTable + target_entry->offset) = *(uint32_t*)new_value_bytes;\n            break;\n        default:\n            return -4;\n    }\n\n    return 0;\n}\n\nvoid simulateConfigUpdate(uint16_t id, const uint8_t* data, uint8_t len) {\n    updateConfigEntryValue(id, data, len);\n}\n\nuint8_t getConfigByte(uint16_t offset) {\n    if (offset < CONFIG_TABLE_SIZE) {\n        return g_configTable[offset];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define SENSOR_DATA_BUFFER_SIZE 256 \n#define MAX_SENSOR_LOG_ENTRIES 10   \n\ntypedef struct {\n    uint16_t sensor_id;\n    uint16_t timestamp;\n    uint16_t data_length;      \n    uint16_t data_offset;     \n} SensorLogEntry;\n\nstatic uint8_t g_sensorDataBuffer[SENSOR_DATA_BUFFER_SIZE];\nstatic SensorLogEntry g_sensorLogEntries[MAX_SENSOR_LOG_ENTRIES];\n\nstatic uint8_t g_nextLogEntryIndex = 0;\nstatic uint16_t g_sensorDataWriteOffset = 0;\n\nvoid initSensorLogger() {\n    memset(g_sensorDataBuffer, 0, sizeof(g_sensorDataBuffer));\n    memset(g_sensorLogEntries, 0, sizeof(g_sensorLogEntries));\n    g_nextLogEntryIndex = 0;\n    g_sensorDataWriteOffset = 0;\n}\n\nint logSensorData(uint16_t sensor_id, uint16_t timestamp, const uint8_t* raw_data, uint16_t raw_data_len) {\n    if (raw_data == NULL || raw_data_len == 0) {\n        return -1; \n    }\n    \n    if (g_nextLogEntryIndex >= MAX_SENSOR_LOG_ENTRIES) {\n        return -2; \n    }\n\n    if (raw_data_len > SENSOR_DATA_BUFFER_SIZE) {\n        return -3; \n    }\n\n    g_sensorLogEntries[g_nextLogEntryIndex].sensor_id = sensor_id;\n    g_sensorLogEntries[g_nextLogEntryIndex].timestamp = timestamp;\n    g_sensorLogEntries[g_nextLogEntryIndex].data_length = raw_data_len;\n    g_sensorLogEntries[g_nextLogEntryIndex].data_offset = g_sensorDataWriteOffset;\n\n    memcpy(g_sensorDataBuffer + g_sensorDataWriteOffset, raw_data, raw_data_len);\n\n    g_sensorDataWriteOffset += raw_data_len;\n\n    g_nextLogEntryIndex++;\n\n    return 0; \n}\n\nvoid simulateSensorDataReception(uint16_t id, uint16_t ts, const uint8_t* data, uint16_t len) {\n    logSensorData(id, ts, data, len);\n}\n\nuint8_t getLoggedSensorDataByte(uint16_t index) {\n    if (index < SENSOR_DATA_BUFFER_SIZE) {\n        return g_sensorDataBuffer[index];\n    }\n    return 0xFF;\n}\n\nconst SensorLogEntry* getSensorLogEntry(uint8_t index) {\n    if (index < g_nextLogEntryIndex) {\n        return &g_sensorLogEntries[index];\n    }\n    return NULL;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define SENSOR_DATA_BUFFER_SIZE 256 \n#define MAX_SENSOR_LOG_ENTRIES 10   \n\ntypedef struct {\n    uint16_t sensor_id;\n    uint16_t timestamp;\n    uint16_t data_length;      \n    uint16_t data_offset;     \n} SensorLogEntry;\n\nstatic uint8_t g_sensorDataBuffer[SENSOR_DATA_BUFFER_SIZE];\nstatic SensorLogEntry g_sensorLogEntries[MAX_SENSOR_LOG_ENTRIES];\n\nstatic uint8_t g_nextLogEntryIndex = 0;\nstatic uint16_t g_sensorDataWriteOffset = 0;\n\nvoid initSensorLogger() {\n    memset(g_sensorDataBuffer, 0, sizeof(g_sensorDataBuffer));\n    memset(g_sensorLogEntries, 0, sizeof(g_sensorLogEntries));\n    g_nextLogEntryIndex = 0;\n    g_sensorDataWriteOffset = 0;\n}\n\nint logSensorData(uint16_t sensor_id, uint16_t timestamp, const uint8_t* raw_data, uint16_t raw_data_len) {\n    if (raw_data == NULL || raw_data_len == 0) {\n        return -1; \n    }\n    \n    if (g_nextLogEntryIndex >= MAX_SENSOR_LOG_ENTRIES) {\n        return -2; \n    }\n\n    if (raw_data_len > SENSOR_DATA_BUFFER_SIZE) {\n        return -3; \n    }\n\n    if (g_sensorDataWriteOffset + raw_data_len > SENSOR_DATA_BUFFER_SIZE) {\n        return -4; \n    }\n\n    g_sensorLogEntries[g_nextLogEntryIndex].sensor_id = sensor_id;\n    g_sensorLogEntries[g_nextLogEntryIndex].timestamp = timestamp;\n    g_sensorLogEntries[g_nextLogEntryIndex].data_length = raw_data_len;\n    g_sensorLogEntries[g_nextLogEntryIndex].data_offset = g_sensorDataWriteOffset;\n\n    memcpy(g_sensorDataBuffer + g_sensorDataWriteOffset, raw_data, raw_data_len);\n\n    g_sensorDataWriteOffset += raw_data_len;\n\n    g_nextLogEntryIndex++;\n\n    return 0; \n}\n\nvoid simulateSensorDataReception(uint16_t id, uint16_t ts, const uint8_t* data, uint16_t len) {\n    logSensorData(id, ts, data, len);\n}\n\nuint8_t getLoggedSensorDataByte(uint16_t index) {\n    if (index < SENSOR_DATA_BUFFER_SIZE) {\n        return g_sensorDataBuffer[index];\n    }\n    return 0xFF;\n}\n\nconst SensorLogEntry* getSensorLogEntry(uint8_t index) {\n    if (index < g_nextLogEntryIndex) {\n        return &g_sensorLogEntries[index];\n    }\n    return NULL;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_EVENT_RECORDS 10\n#define MAX_EVENT_DATA_LEN 60 \n#define EVENT_LOG_BUFFER_SIZE (MAX_EVENT_RECORDS * (sizeof(EventRecordHeader) + MAX_EVENT_DATA_LEN))\n\ntypedef struct {\n    uint8_t event_type;\n    uint8_t data_len;\n} EventRecordHeader;\n\nstatic uint8_t g_eventLogBuffer[EVENT_LOG_BUFFER_SIZE];\nstatic uint16_t g_currentLogWriteOffset = 0;\n\nvoid initEventLog(void) {\n    memset(g_eventLogBuffer, 0, EVENT_LOG_BUFFER_SIZE);\n    g_currentLogWriteOffset = 0;\n}\n\nint addEventToLog(const uint8_t* raw_event_data, uint16_t event_total_len) {\n    if (raw_event_data == NULL || event_total_len < sizeof(EventRecordHeader)) {\n        return -1;\n    }\n\n    uint8_t received_event_type = raw_event_data[0];\n    uint8_t received_data_len = raw_event_data[1];\n\n    if (received_data_len > MAX_EVENT_DATA_LEN) {\n        return -2;\n    }\n\n    if (sizeof(EventRecordHeader) + received_data_len > event_total_len) {\n        return -3;\n    }\n\n    uint16_t record_packed_size = sizeof(EventRecordHeader) + received_data_len;\n\n    g_eventLogBuffer[g_currentLogWriteOffset] = received_event_type;\n    g_currentLogWriteOffset++;\n    g_eventLogBuffer[g_currentLogWriteOffset] = received_data_len;\n    g_currentLogWriteOffset++;\n\n    for (uint8_t i = 0; i < received_data_len; ++i) {\n        g_eventLogBuffer[g_currentLogWriteOffset + i] = raw_event_data[sizeof(EventRecordHeader) + i];\n    }\n    g_currentLogWriteOffset += received_data_len;\n\n    return 0;\n}\n\nvoid processIncomingEventStream(const uint8_t* data, uint16_t len) {\n    addEventToLog(data, len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_EVENT_RECORDS 10\n#define MAX_EVENT_DATA_LEN 60 \n#define EVENT_LOG_BUFFER_SIZE (MAX_EVENT_RECORDS * (sizeof(EventRecordHeader) + MAX_EVENT_DATA_LEN))\n\ntypedef struct {\n    uint8_t event_type;\n    uint8_t data_len;\n} EventRecordHeader;\n\nstatic uint8_t g_eventLogBuffer[EVENT_LOG_BUFFER_SIZE];\nstatic uint16_t g_currentLogWriteOffset = 0;\n\nvoid initEventLog(void) {\n    memset(g_eventLogBuffer, 0, EVENT_LOG_BUFFER_SIZE);\n    g_currentLogWriteOffset = 0;\n}\n\nint addEventToLog(const uint8_t* raw_event_data, uint16_t event_total_len) {\n    if (raw_event_data == NULL || event_total_len < sizeof(EventRecordHeader)) {\n        return -1;\n    }\n\n    uint8_t received_event_type = raw_event_data[0];\n    uint8_t received_data_len = raw_event_data[1];\n\n    if (received_data_len > MAX_EVENT_DATA_LEN) {\n        return -2;\n    }\n\n    if (sizeof(EventRecordHeader) + received_data_len > event_total_len) {\n        return -3;\n    }\n\n    uint16_t record_packed_size = sizeof(EventRecordHeader) + received_data_len;\n\n    if (g_currentLogWriteOffset + record_packed_size > EVENT_LOG_BUFFER_SIZE) {\n        return -4;\n    }\n\n    g_eventLogBuffer[g_currentLogWriteOffset] = received_event_type;\n    g_currentLogWriteOffset++;\n    g_eventLogBuffer[g_currentLogWriteOffset] = received_data_len;\n    g_currentLogWriteOffset++;\n\n    for (uint8_t i = 0; i < received_data_len; ++i) {\n        g_eventLogBuffer[g_currentLogWriteOffset + i] = raw_event_data[sizeof(EventRecordHeader) + i];\n    }\n    g_currentLogWriteOffset += received_data_len;\n\n    return 0;\n}\n\nvoid processIncomingEventStream(const uint8_t* data, uint16_t len) {\n    addEventToLog(data, len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define CALIBRATION_STORAGE_SIZE 128\n#define INITIAL_CALIBRATION_DATA_LEN 10\n#define MAX_PARAM_PAYLOAD_LEN 60\n\nstatic uint8_t g_calibrationStorage[CALIBRATION_STORAGE_SIZE];\nstatic uint16_t g_currentCalibrationOffset = 0;\n\nvoid initCalibrationManager() {\n    memset(g_calibrationStorage, 0, CALIBRATION_STORAGE_SIZE);\n    for (uint8_t i = 0; i < INITIAL_CALIBRATION_DATA_LEN; ++i) {\n        g_calibrationStorage[i] = i * 2;\n    }\n    g_currentCalibrationOffset = INITIAL_CALIBRATION_DATA_LEN;\n}\n\nint processCalibrationPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len < 1) {\n        return -1;\n    }\n\n    uint16_t current_packet_read_offset = 0;\n    uint8_t num_params = packet[current_packet_read_offset++];\n\n    if (num_params == 0) {\n        return 0;\n    }\n\n    if (current_packet_read_offset >= packet_len) {\n        return -2;\n    }\n\n    uint8_t anticipated_new_data_total_len = 0;\n\n    uint16_t temp_packet_offset_check = current_packet_read_offset;\n    for (uint8_t i = 0; i < num_params; ++i) {\n        if (temp_packet_offset_check + 2 > packet_len) {\n            return -3;\n        }\n\n        uint8_t param_id = packet[temp_packet_offset_check];\n        uint8_t param_len = packet[temp_packet_offset_check + 1];\n        \n        temp_packet_offset_check += 2;\n\n        if (param_len > MAX_PARAM_PAYLOAD_LEN) {\n             return -4;\n        }\n\n        if (temp_packet_offset_check + param_len > packet_len) {\n            return -5;\n        }\n\n        uint8_t entry_size_in_storage = 1 + param_len;\n\n        anticipated_new_data_total_len += entry_size_in_storage;\n\n        temp_packet_offset_check += param_len;\n    }\n\n    if ((uint16_t)g_currentCalibrationOffset + anticipated_new_data_total_len > CALIBRATION_STORAGE_SIZE) {\n        return -6;\n    }\n\n    current_packet_read_offset = 1;\n\n    for (uint8_t i = 0; i < num_params; ++i) {\n        uint8_t param_id = packet[current_packet_read_offset++];\n        uint8_t param_len = packet[current_packet_read_offset++];\n        \n        g_calibrationStorage[g_currentCalibrationOffset++] = param_id;\n\n        for (uint8_t j = 0; j < param_len; ++j) {\n            g_calibrationStorage[g_currentCalibrationOffset++] = packet[current_packet_read_offset++];\n        }\n    }\n\n    return 0;\n}\n\nvoid handleCalibrationUpdate(const uint8_t* data, uint16_t len) {\n    processCalibrationPacket(data, len);\n}\n\nuint8_t getCalibrationByte(uint8_t index) {\n    if (index < CALIBRATION_STORAGE_SIZE) {\n        return g_calibrationStorage[index];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define CALIBRATION_STORAGE_SIZE 128\n#define INITIAL_CALIBRATION_DATA_LEN 10\n#define MAX_PARAM_PAYLOAD_LEN 60\n\nstatic uint8_t g_calibrationStorage[CALIBRATION_STORAGE_SIZE];\nstatic uint16_t g_currentCalibrationOffset = 0;\n\nvoid initCalibrationManager() {\n    memset(g_calibrationStorage, 0, CALIBRATION_STORAGE_SIZE);\n    for (uint8_t i = 0; i < INITIAL_CALIBRATION_DATA_LEN; ++i) {\n        g_calibrationStorage[i] = i * 2;\n    }\n    g_currentCalibrationOffset = INITIAL_CALIBRATION_DATA_LEN;\n}\n\nint processCalibrationPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len < 1) {\n        return -1;\n    }\n\n    uint16_t current_packet_read_offset = 0;\n    uint8_t num_params = packet[current_packet_read_offset++];\n\n    if (num_params == 0) {\n        return 0;\n    }\n\n    if (current_packet_read_offset >= packet_len) {\n        return -2;\n    }\n\n    uint16_t anticipated_new_data_total_len = 0;\n\n    uint16_t temp_packet_offset_check = current_packet_read_offset;\n    for (uint8_t i = 0; i < num_params; ++i) {\n        if (temp_packet_offset_check + 2 > packet_len) {\n            return -3;\n        }\n\n        uint8_t param_id = packet[temp_packet_offset_check];\n        uint8_t param_len = packet[temp_packet_offset_check + 1];\n        \n        temp_packet_offset_check += 2;\n\n        if (param_len > MAX_PARAM_PAYLOAD_LEN) {\n             return -4;\n        }\n\n        if (temp_packet_offset_check + param_len > packet_len) {\n            return -5;\n        }\n\n        uint16_t entry_size_in_storage = 1 + param_len;\n\n        if (anticipated_new_data_total_len > (0xFFFF - entry_size_in_storage)) { \n            return -7;\n        }\n        anticipated_new_data_total_len += entry_size_in_storage;\n\n        temp_packet_offset_check += param_len;\n    }\n\n    if (g_currentCalibrationOffset + anticipated_new_data_total_len > CALIBRATION_STORAGE_SIZE) {\n        return -6;\n    }\n\n    current_packet_read_offset = 1;\n\n    for (uint8_t i = 0; i < num_params; ++i) {\n        uint8_t param_id = packet[current_packet_read_offset++];\n        uint8_t param_len = packet[current_packet_read_offset++];\n        \n        g_calibrationStorage[g_currentCalibrationOffset++] = param_id;\n\n        for (uint8_t j = 0; j < param_len; ++j) {\n            g_calibrationStorage[g_currentCalibrationOffset++] = packet[current_packet_read_offset++];\n        }\n    }\n\n    return 0;\n}\n\nvoid handleCalibrationUpdate(const uint8_t* data, uint16_t len) {\n    processCalibrationPacket(data, len);\n}\n\nuint8_t getCalibrationByte(uint8_t index) {\n    if (index < CALIBRATION_STORAGE_SIZE) {\n        return g_calibrationStorage[index];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_CONFIG_BANKS 4\n#define CONFIG_BANK_SIZE 128\n\nstatic uint8_t g_vehicleConfigMemory[NUM_CONFIG_BANKS][CONFIG_BANK_SIZE];\n\ntypedef struct {\n    uint8_t* current_bank_ptr;\n    uint8_t  bank_index;\n    uint16_t total_banks_size;\n} ConfigManagerContext;\n\nstatic ConfigManagerContext g_configManager;\n\nvoid initConfigManager() {\n    memset(g_vehicleConfigMemory, 0, sizeof(g_vehicleConfigMemory));\n    g_configManager.current_bank_ptr = NULL;\n    g_configManager.bank_index = 0xFF;\n    g_configManager.total_banks_size = NUM_CONFIG_BANKS * CONFIG_BANK_SIZE;\n}\n\nint selectConfigBank(uint8_t bank_idx) {\n    if (bank_idx >= NUM_CONFIG_BANKS) {\n        g_configManager.current_bank_ptr = NULL;\n        g_configManager.bank_index = 0xFF;\n        return -1;\n    }\n    g_configManager.current_bank_ptr = g_vehicleConfigMemory[bank_idx];\n    g_configManager.bank_index = bank_idx;\n    return 0;\n}\n\nint updateConfigParameter(const uint8_t* raw_msg, uint16_t msg_len) {\n    if (g_configManager.current_bank_ptr == NULL || g_configManager.bank_index == 0xFF) {\n        return -1;\n    }\n\n    if (raw_msg == NULL || msg_len < 2) {\n        return -2;\n    }\n\n    uint8_t offset_in_bank = raw_msg[0];\n    uint8_t data_len = raw_msg[1];\n\n    if (data_len == 0) {\n        return 0;\n    }\n\n    if (msg_len < (2 + data_len)) {\n        return -3;\n    }\n\n    if (offset_in_bank >= CONFIG_BANK_SIZE) {\n        return -4;\n    }\n\n    const uint8_t* data_source = raw_msg + 2;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_configManager.current_bank_ptr[offset_in_bank + i] = data_source[i];\n    }\n\n    return 0;\n}\n\nvoid handleIncomingConfigMessage(uint8_t bank_id, const uint8_t* data, uint16_t len) {\n    if (selectConfigBank(bank_id) == 0) {\n        updateConfigParameter(data, len);\n    }\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_CONFIG_BANKS 4\n#define CONFIG_BANK_SIZE 128\n\nstatic uint8_t g_vehicleConfigMemory[NUM_CONFIG_BANKS][CONFIG_BANK_SIZE];\n\ntypedef struct {\n    uint8_t* current_bank_ptr;\n    uint8_t  bank_index;\n    uint16_t total_banks_size;\n} ConfigManagerContext;\n\nstatic ConfigManagerContext g_configManager;\n\nvoid initConfigManager() {\n    memset(g_vehicleConfigMemory, 0, sizeof(g_vehicleConfigMemory));\n    g_configManager.current_bank_ptr = NULL;\n    g_configManager.bank_index = 0xFF;\n    g_configManager.total_banks_size = NUM_CONFIG_BANKS * CONFIG_BANK_SIZE;\n}\n\nint selectConfigBank(uint8_t bank_idx) {\n    if (bank_idx >= NUM_CONFIG_BANKS) {\n        g_configManager.current_bank_ptr = NULL;\n        g_configManager.bank_index = 0xFF;\n        return -1;\n    }\n    g_configManager.current_bank_ptr = g_vehicleConfigMemory[bank_idx];\n    g_configManager.bank_index = bank_idx;\n    return 0;\n}\n\nint updateConfigParameter(const uint8_t* raw_msg, uint16_t msg_len) {\n    if (g_configManager.current_bank_ptr == NULL || g_configManager.bank_index == 0xFF) {\n        return -1;\n    }\n\n    if (raw_msg == NULL || msg_len < 2) {\n        return -2;\n    }\n\n    uint8_t offset_in_bank = raw_msg[0];\n    uint8_t data_len = raw_msg[1];\n\n    if (data_len == 0) {\n        return 0;\n    }\n\n    if (msg_len < (2 + data_len)) {\n        return -3;\n    }\n\n    if ((uint16_t)offset_in_bank + data_len > CONFIG_BANK_SIZE) {\n        return -4;\n    }\n\n    const uint8_t* data_source = raw_msg + 2;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_configManager.current_bank_ptr[offset_in_bank + i] = data_source[i];\n    }\n\n    return 0;\n}\n\nvoid handleIncomingConfigMessage(uint8_t bank_id, const uint8_t* data, uint16_t len) {\n    if (selectConfigBank(bank_id) == 0) {\n        updateConfigParameter(data, len);\n    }\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOG_MESSAGE_SIZE 256 // Maximum size of an incoming diagnostic log message\n#define INTERNAL_RECORD_BUFFER_SIZE 64 // Fixed-size buffer for a single log record entry\n\n// A simplified log record structure stored internally\ntypedef struct {\n    uint8_t type;\n    uint8_t length; // Actual length of 'data' copied\n    uint8_t data[INTERNAL_RECORD_BUFFER_SIZE];\n} DiagnosticLogRecord;\n\n// Global instance of the current log record being processed/stored\nstatic DiagnosticLogRecord currentLogRecord;\n\n// Initializes the log record buffer with zeros\nvoid initDiagnosticLogRecord() {\n    memset(&currentLogRecord, 0, sizeof(DiagnosticLogRecord));\n}\n\n// Function to process an incoming diagnostic message and store relevant part\n// This function is vulnerable to buffer overflow if 'data_length' from the message\n// is greater than INTERNAL_RECORD_BUFFER_SIZE.\nint processDiagnosticMessage(const uint8_t* message_data, uint16_t message_len) {\n    if (message_data == NULL || message_len < 2) { // Requires at least tag and length\n        return -1; // Invalid input message\n    }\n\n    uint16_t current_offset = 0;\n\n    // Assume message_data format: [tag (1 byte)][length (1 byte)][data (length bytes)]\n    uint8_t data_tag = message_data[current_offset];\n    current_offset++;\n    uint8_t data_length = message_data[current_offset]; // Length of the data payload\n    current_offset++;\n\n    // Check if the declared data_length fits within the remainder of the incoming message\n    // This check is correctly performed against the source message length.\n    if (current_offset + data_length > message_len) {\n        return -2; // Malformed message: declared length exceeds actual message bounds\n    }\n\n    const uint8_t* source_data_ptr = message_data + current_offset;\n\n    // Store the processed data into the internal log record structure.\n    // The 'data_length' can be up to 254 bytes (MAX_LOG_MESSAGE_SIZE - 2), \n    // which is much larger than INTERNAL_RECORD_BUFFER_SIZE (64 bytes).\n    currentLogRecord.type = data_tag;\n    currentLogRecord.length = data_length; // This 'length' might be > INTERNAL_RECORD_BUFFER_SIZE\n\n    // VULNERABILITY: The loop iterates 'data_length' times, potentially writing\n    // past the end of 'currentLogRecord.data' array (size INTERNAL_RECORD_BUFFER_SIZE).\n    for (uint8_t i = 0; i < data_length; ++i) {\n        currentLogRecord.data[i] = source_data_ptr[i];\n    }\n\n    return 0;\n}\n\n// Public interface to simulate receiving a diagnostic message\nvoid receiveDiagnosticData(const uint8_t* data, uint16_t len) {\n    initDiagnosticLogRecord();\n    processDiagnosticMessage(data, len);\n}\n\n// Helper function to get a byte from the stored log record data\nuint8_t getLogRecordByte(uint8_t index) {\n    if (index < INTERNAL_RECORD_BUFFER_SIZE) {\n        return currentLogRecord.data[index];\n    }\n    return 0xFF; // Indicate out of bounds read or invalid index\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOG_MESSAGE_SIZE 256 // Maximum size of an incoming diagnostic log message\n#define INTERNAL_RECORD_BUFFER_SIZE 64 // Fixed-size buffer for a single log record entry\n\n// A simplified log record structure stored internally\ntypedef struct {\n    uint8_t type;\n    uint8_t length; // Actual length of 'data' copied\n    uint8_t data[INTERNAL_RECORD_BUFFER_SIZE];\n} DiagnosticLogRecord;\n\n// Global instance of the current log record being processed/stored\nstatic DiagnosticLogRecord currentLogRecord;\n\n// Initializes the log record buffer with zeros\nvoid initDiagnosticLogRecord() {\n    memset(&currentLogRecord, 0, sizeof(DiagnosticLogRecord));\n}\n\n// Function to process an incoming diagnostic message and store relevant part\n// This function is now fixed against buffer overflow by limiting the copy length.\nint processDiagnosticMessage(const uint8_t* message_data, uint16_t message_len) {\n    if (message_data == NULL || message_len < 2) { // Requires at least tag and length\n        return -1; // Invalid input message\n    }\n\n    uint16_t current_offset = 0;\n\n    // Assume message_data format: [tag (1 byte)][length (1 byte)][data (length bytes)]\n    uint8_t data_tag = message_data[current_offset];\n    current_offset++;\n    uint8_t data_length = message_data[current_offset]; // Length of the data payload\n    current_offset++;\n\n    // Check if the declared data_length fits within the remainder of the incoming message\n    if (current_offset + data_length > message_len) {\n        return -2; // Malformed message: declared length exceeds actual message bounds\n    }\n\n    const uint8_t* source_data_ptr = message_data + current_offset;\n\n    // Determine the actual number of bytes to copy to prevent overflow\n    uint8_t bytes_to_copy = data_length;\n    if (bytes_to_copy > INTERNAL_RECORD_BUFFER_SIZE) {\n        bytes_to_copy = INTERNAL_RECORD_BUFFER_SIZE; // Truncate if incoming data is too large\n    }\n\n    // Store the processed data into the internal log record structure.\n    currentLogRecord.type = data_tag;\n    // The 'length' field should reflect the actual data copied, not the requested length.\n    currentLogRecord.length = bytes_to_copy;\n\n    // FIXED: The loop now uses 'bytes_to_copy' which is bounded by INTERNAL_RECORD_BUFFER_SIZE.\n    for (uint8_t i = 0; i < bytes_to_copy; ++i) {\n        currentLogRecord.data[i] = source_data_ptr[i];\n    }\n\n    // It might be necessary to pad the rest of the buffer with zeros if partial data is copied,\n    // but for simplicity, we only focus on preventing the overflow here.\n\n    return 0;\n}\n\n// Public interface to simulate receiving a diagnostic message\nvoid receiveDiagnosticData(const uint8_t* data, uint16_t len) {\n    initDiagnosticLogRecord();\n    processDiagnosticMessage(data, len);\n}\n\n// Helper function to get a byte from the stored log record data\nuint8_t getLogRecordByte(uint8_t index) {\n    if (index < INTERNAL_RECORD_BUFFER_SIZE) {\n        return currentLogRecord.data[index];\n    }\n    return 0xFF; // Indicate out of bounds read or invalid index\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define ECU_REG_MAP_SIZE 100\n\nstatic uint8_t g_ecuRegisterMap[ECU_REG_MAP_SIZE];\n\nvoid initEcuRegisterMap() {\n    memset(g_ecuRegisterMap, 0, ECU_REG_MAP_SIZE);\n}\n\nint setEcuRegisterBitfield(uint8_t start_byte_offset, uint8_t start_bit_in_byte, uint8_t num_bits, uint16_t value) {\n    if (start_byte_offset >= ECU_REG_MAP_SIZE || start_bit_in_byte >= 8 || num_bits == 0) {\n        return -1;\n    }\n\n    uint16_t mask = (1 << num_bits) - 1;\n    if (num_bits > 16) {\n        mask = 0xFFFF;\n    }\n    value &= mask;\n\n    uint8_t current_byte_idx = start_byte_offset;\n    uint8_t bits_written = 0;\n    uint8_t bits_remaining_in_field = num_bits;\n\n    while (bits_remaining_in_field > 0) {\n        uint8_t bits_in_current_chunk;\n        if (bits_written == 0) {\n            bits_in_current_chunk = 8 - start_bit_in_byte;\n        } else {\n            bits_in_current_chunk = 8;\n            start_bit_in_byte = 0;\n        }\n        \n        if (bits_in_current_chunk > bits_remaining_in_field) {\n            bits_in_current_chunk = bits_remaining_in_field;\n        }\n        \n        uint8_t current_byte_value = g_ecuRegisterMap[current_byte_idx];\n\n        uint8_t local_mask = ((1 << bits_in_current_chunk) - 1) << start_bit_in_byte;\n        current_byte_value &= ~local_mask;\n\n        uint8_t value_part = (value >> bits_written) & ((1 << bits_in_current_chunk) - 1);\n        current_byte_value |= (value_part << start_bit_in_byte);\n\n        g_ecuRegisterMap[current_byte_idx] = current_byte_value;\n\n        bits_written += bits_in_current_chunk;\n        bits_remaining_in_field -= bits_in_current_chunk;\n        current_byte_idx++;\n    }\n\n    return 0;\n}\n\nvoid handleEcuConfigCommand(const uint8_t* command_payload, uint8_t payload_len) {\n    if (command_payload == NULL || payload_len < 4) {\n        return;\n    }\n\n    uint8_t byte_offset = command_payload[0];\n    uint8_t bit_offset = command_payload[1] & 0x07;\n    uint8_t num_bits = command_payload[2];\n\n    uint16_t value = 0;\n    if (payload_len >= 5) {\n        value = (command_payload[3] << 8) | command_payload[4];\n    } else if (payload_len == 4) {\n        value = command_payload[3];\n    }\n\n    setEcuRegisterBitfield(byte_offset, bit_offset, num_bits, value);\n}\n\nuint8_t getEcuRegisterByte(uint8_t offset) {\n    if (offset < ECU_REG_MAP_SIZE) {\n        return g_ecuRegisterMap[offset];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define ECU_REG_MAP_SIZE 100\n\nstatic uint8_t g_ecuRegisterMap[ECU_REG_MAP_SIZE];\n\nvoid initEcuRegisterMap() {\n    memset(g_ecuRegisterMap, 0, ECU_REG_MAP_SIZE);\n}\n\nint setEcuRegisterBitfield(uint8_t start_byte_offset, uint8_t start_bit_in_byte, uint8_t num_bits, uint16_t value) {\n    if (start_byte_offset >= ECU_REG_MAP_SIZE || start_bit_in_byte >= 8 || num_bits == 0) {\n        return -1;\n    }\n\n    uint16_t required_bytes_span = (uint16_t)start_bit_in_byte + num_bits;\n    uint8_t last_affected_byte_idx = start_byte_offset + (required_bytes_span - 1) / 8;\n\n    if (last_affected_byte_idx >= ECU_REG_MAP_SIZE) {\n        return -2;\n    }\n\n    uint16_t mask = (1 << num_bits) - 1;\n    if (num_bits > 16) {\n        mask = 0xFFFF;\n    }\n    value &= mask;\n\n    uint8_t current_byte_idx = start_byte_offset;\n    uint8_t bits_written = 0;\n    uint8_t bits_remaining_in_field = num_bits;\n\n    while (bits_remaining_in_field > 0) {\n        uint8_t bits_in_current_chunk;\n        if (bits_written == 0) {\n            bits_in_current_chunk = 8 - start_bit_in_byte;\n        } else {\n            bits_in_current_chunk = 8;\n            start_bit_in_byte = 0;\n        }\n        \n        if (bits_in_current_chunk > bits_remaining_in_field) {\n            bits_in_current_chunk = bits_remaining_in_field;\n        }\n        \n        uint8_t current_byte_value = g_ecuRegisterMap[current_byte_idx];\n\n        uint8_t local_mask = ((1 << bits_in_current_chunk) - 1) << start_bit_in_byte;\n        current_byte_value &= ~local_mask;\n\n        uint8_t value_part = (value >> bits_written) & ((1 << bits_in_current_chunk) - 1);\n        current_byte_value |= (value_part << start_bit_in_byte);\n\n        g_ecuRegisterMap[current_byte_idx] = current_byte_value;\n\n        bits_written += bits_in_current_chunk;\n        bits_remaining_in_field -= bits_in_current_chunk;\n        current_byte_idx++;\n    }\n\n    return 0;\n}\n\nvoid handleEcuConfigCommand(const uint8_t* command_payload, uint8_t payload_len) {\n    if (command_payload == NULL || payload_len < 4) {\n        return;\n    }\n\n    uint8_t byte_offset = command_payload[0];\n    uint8_t bit_offset = command_payload[1] & 0x07;\n    uint8_t num_bits = command_payload[2];\n\n    uint16_t value = 0;\n    if (payload_len >= 5) {\n        value = (command_payload[3] << 8) | command_payload[4];\n    } else if (payload_len == 4) {\n        value = command_payload[3];\n    }\n\n    setEcuRegisterBitfield(byte_offset, bit_offset, num_bits, value);\n}\n\nuint8_t getEcuRegisterByte(uint8_t offset) {\n    if (offset < ECU_REG_MAP_SIZE) {\n        return g_ecuRegisterMap[offset];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define FIRMWARE_UPDATE_BUFFER_SIZE 1024\n#define NUM_FIRMWARE_SECTIONS 4\n\ntypedef struct {\n    uint16_t base_address;\n    uint16_t size;\n} FirmwareSectionInfo;\n\nstatic uint8_t g_firmwareUpdateBuffer[FIRMWARE_UPDATE_BUFFER_SIZE];\n\nstatic const FirmwareSectionInfo g_firmwareSections[NUM_FIRMWARE_SECTIONS] = {\n    {0, 200},\n    {200, 300},\n    {500, 100},\n    {600, 424}\n};\n\nvoid initFirmwareUpdater() {\n    memset(g_firmwareUpdateBuffer, 0xFF, FIRMWARE_UPDATE_BUFFER_SIZE);\n}\n\nint writeFirmwareBlock(uint8_t section_id, uint8_t block_offset_in_section, uint8_t block_len, const uint8_t* data_payload) {\n    if (data_payload == NULL || block_len == 0) {\n        return -1;\n    }\n\n    if (section_id >= NUM_FIRMWARE_SECTIONS) {\n        return -2;\n    }\n\n    const FirmwareSectionInfo* section = &g_firmwareSections[section_id];\n\n    uint8_t end_offset_check = block_offset_in_section + block_len;\n\n    if (block_offset_in_section >= section->size || end_offset_check > section->size) {\n        return -3;\n    }\n\n    uint16_t dest_address = section->base_address + block_offset_in_section;\n\n    for (uint8_t i = 0; i < block_len; ++i) {\n        g_firmwareUpdateBuffer[dest_address + i] = data_payload[i];\n    }\n\n    return 0;\n}\n\nvoid updateFirmwareSection(uint8_t section_id, uint8_t offset, uint8_t len, const uint8_t* data) {\n    if (g_firmwareUpdateBuffer[0] == 0xFF) {\n        initFirmwareUpdater();\n    }\n    writeFirmwareBlock(section_id, offset, len, data);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define FIRMWARE_UPDATE_BUFFER_SIZE 1024\n#define NUM_FIRMWARE_SECTIONS 4\n\ntypedef struct {\n    uint16_t base_address;\n    uint16_t size;\n} FirmwareSectionInfo;\n\nstatic uint8_t g_firmwareUpdateBuffer[FIRMWARE_UPDATE_BUFFER_SIZE];\n\nstatic const FirmwareSectionInfo g_firmwareSections[NUM_FIRMWARE_SECTIONS] = {\n    {0, 200},\n    {200, 300},\n    {500, 100},\n    {600, 424}\n};\n\nvoid initFirmwareUpdater() {\n    memset(g_firmwareUpdateBuffer, 0xFF, FIRMWARE_UPDATE_BUFFER_SIZE);\n}\n\nint writeFirmwareBlock(uint8_t section_id, uint8_t block_offset_in_section, uint8_t block_len, const uint8_t* data_payload) {\n    if (data_payload == NULL || block_len == 0) {\n        return -1;\n    }\n\n    if (section_id >= NUM_FIRMWARE_SECTIONS) {\n        return -2;\n    }\n\n    const FirmwareSectionInfo* section = &g_firmwareSections[section_id];\n\n    uint16_t required_section_end_offset = (uint16_t)block_offset_in_section + block_len;\n\n    if (block_offset_in_section >= section->size || required_section_end_offset > section->size) {\n        return -3;\n    }\n\n    uint16_t dest_address = section->base_address + block_offset_in_section;\n\n    if ((uint32_t)dest_address + block_len > FIRMWARE_UPDATE_BUFFER_SIZE) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < block_len; ++i) {\n        g_firmwareUpdateBuffer[dest_address + i] = data_payload[i];\n    }\n\n    return 0;\n}\n\nvoid updateFirmwareSection(uint8_t section_id, uint8_t offset, uint8_t len, const uint8_t* data) {\n    if (g_firmwareUpdateBuffer[0] == 0xFF) {\n        initFirmwareUpdater();\n    }\n    writeFirmwareBlock(section_id, offset, len, data);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_LOG_TOTAL_BUFFER_SIZE 256\n#define DIAG_LOG_ENTRY_HEADER_SIZE 8 // Example header: Event ID (1), Reserved (5), DataLength (2)\n#define DIAG_LOG_MAX_PAYLOAD_SIZE 64 // Max size of data payload for a single entry\n\n// The main circular buffer for diagnostic logs\nstatic uint8_t g_diagLogBuffer[DIAG_LOG_TOTAL_BUFFER_SIZE];\n// Pointer to the start of the current active log entry being filled\n// This pointer moves in a circular fashion within g_diagLogBuffer.\nstatic uint16_t g_currentEntryStart = 0;\n\nvoid initDiagnosticLogger() {\n    memset(g_diagLogBuffer, 0, DIAG_LOG_TOTAL_BUFFER_SIZE);\n    g_currentEntryStart = 0;\n}\n\n// This function is called to prepare space for a new log entry.\n// It reserves the space and writes a simplified header.\n// 'intended_payload_len' is the expected maximum length of data for this entry's payload.\nint createNewLogEntry(uint8_t event_type, uint16_t intended_payload_len) {\n    uint16_t total_entry_size = DIAG_LOG_ENTRY_HEADER_SIZE + intended_payload_len;\n\n    if (intended_payload_len > DIAG_LOG_MAX_PAYLOAD_SIZE) {\n        return -1; // Payload length exceeds maximum allowed for any single entry\n    }\n    if (total_entry_size > DIAG_LOG_TOTAL_BUFFER_SIZE) {\n        return -2; // Entry too large for the entire buffer\n    }\n\n    // Handle circular buffer wrap-around for the start of the new entry.\n    // If the new entry doesn't fit contiguously, wrap to the beginning.\n    if (g_currentEntryStart + total_entry_size > DIAG_LOG_TOTAL_BUFFER_SIZE) {\n        g_currentEntryStart = 0; // Wrap to beginning of buffer\n    }\n\n    // Write simplified header data at g_currentEntryStart\n    g_diagLogBuffer[g_currentEntryStart] = event_type; // Byte 0: Event Type\n    // Bytes 1-5 reserved/other header fields (for simplicity, assumed to be 0)\n    // Bytes 6-7: Data Length (MSB, LSB) - stored here for later reference\n    g_diagLogBuffer[g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE - 2] = (uint8_t)(intended_payload_len >> 8);\n    g_diagLogBuffer[g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE - 1] = (uint8_t)(intended_payload_len & 0xFF);\n\n    return 0; // Success\n}\n\n// This function is used to update a specific byte within the payload\n// of the *current* active log entry. This is often used for incrementally\n// filling or correcting log data.\n// 'payload_offset': The offset FROM THE START OF THE PAYLOAD AREA of the current entry.\n// 'value': The byte value to write.\n//\n// VULNERABILITY: Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-119)\n// The function calculates an absolute write position based on 'g_currentEntryStart',\n// 'DIAG_LOG_ENTRY_HEADER_SIZE', and the user-controlled 'payload_offset'.\n// It only checks if the 'absolute_write_pos' is within the 'DIAG_LOG_TOTAL_BUFFER_SIZE'.\n// It *does not* check if 'payload_offset' exceeds the 'intended_payload_len' (or\n// 'DIAG_LOG_MAX_PAYLOAD_SIZE') that was declared when the entry was created.\n// An attacker can provide a 'payload_offset' value that is greater than the \n// current entry's intended payload length, but still within the total buffer size.\n// This leads to writing past the end of the current log entry's designated payload area,\n// potentially corrupting the header of the next log entry or other critical adjacent data.\nint updateLogEntryPayloadByte(uint16_t payload_offset, uint8_t value) {\n    uint16_t absolute_write_pos = g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE + payload_offset;\n\n    // This check is insufficient. It only prevents writing outside the entire static buffer.\n    // It does not prevent writing outside the *allocated space for the current entry's payload*.\n    if (absolute_write_pos >= DIAG_LOG_TOTAL_BUFFER_SIZE) {\n        return -1; // Attempt to write beyond total log buffer boundaries\n    }\n\n    g_diagLogBuffer[absolute_write_pos] = value;\n    return 0;\n}\n\n// After an entry is fully populated, this function advances the write pointer.\n// 'actual_payload_len': The actual number of payload bytes written for this entry.\nvoid finalizeLogEntry(uint16_t actual_payload_len) {\n    g_currentEntryStart = (g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE + actual_payload_len) % DIAG_LOG_TOTAL_BUFFER_SIZE;\n}\n\n// Public interface to simulate logging a vehicle event with a given data block.\n// This function itself appears safe by respecting effective_payload_len.\nvoid logVehicleEvent(uint8_t event_type, const uint8_t* event_data, uint16_t event_data_len) {\n    if (event_data == NULL || event_data_len == 0) return;\n\n    uint16_t effective_payload_len = event_data_len;\n    if (effective_payload_len > DIAG_LOG_MAX_PAYLOAD_SIZE) {\n        effective_payload_len = DIAG_LOG_MAX_PAYLOAD_SIZE;\n    }\n\n    if (createNewLogEntry(event_type, effective_payload_len) == 0) {\n        for (uint16_t i = 0; i < effective_payload_len; ++i) {\n            // This loop iterates within the correctly bounded effective_payload_len.\n            // The vulnerability is in `updateLogEntryPayloadByte` if called directly\n            // with a manipulated offset.\n            updateLogEntryPayloadByte(i, event_data[i]);\n        }\n        finalizeLogEntry(effective_payload_len);\n    }\n}\n\n// Function simulating an external call that might exploit the vulnerability.\n// In a real system, 'payload_offset' might be extracted from a malicious CAN message\n// or a diagnostic command that allows direct memory access for debugging.\nvoid maliciousDiagnosticPoke(uint16_t offset_from_payload_start, uint8_t value) {\n    // This call directly exploits the lack of bounds checking for payload_offset\n    // within updateLogEntryPayloadByte, allowing a write outside the current entry's\n    // logical payload boundary but within the overall buffer.\n    updateLogEntryPayloadByte(offset_from_payload_start, value);\n}\n\n// Example of how a diagnostic command handler might use these functions\nvoid processDiagnosticCommand(uint8_t command_id, uint8_t* command_payload, uint16_t payload_len) {\n    initDiagnosticLogger(); // Initialize for demonstration\n\n    switch(command_id) {\n        case 0x01: // Standard event logging command\n            logVehicleEvent(0x55, command_payload, payload_len);\n            break;\n        case 0x02: // Special command to 'poke' a byte in the current log entry's data area\n            if (payload_len >= 3) {\n                uint16_t offset = (command_payload[0] << 8) | command_payload[1];\n                uint8_t val = command_payload[2];\n                maliciousDiagnosticPoke(offset, val); // Attacker controls 'offset'\n            }\n            break;\n        // ... other commands\n    }\n}\n", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_LOG_TOTAL_BUFFER_SIZE 256\n#define DIAG_LOG_ENTRY_HEADER_SIZE 8 // Example header: Event ID (1), Reserved (5), DataLength (2)\n#define DIAG_LOG_MAX_PAYLOAD_SIZE 64 // Max size of data payload for a single entry\n\n// The main circular buffer for diagnostic logs\nstatic uint8_t g_diagLogBuffer[DIAG_LOG_TOTAL_BUFFER_SIZE];\n// Pointer to the start of the current active log entry being filled\n// This pointer moves in a circular fashion within g_diagLogBuffer.\nstatic uint16_t g_currentEntryStart = 0;\n\nvoid initDiagnosticLogger() {\n    memset(g_diagLogBuffer, 0, DIAG_LOG_TOTAL_BUFFER_SIZE);\n    g_currentEntryStart = 0;\n}\n\n// This function is called to prepare space for a new log entry.\n// It reserves the space and writes a simplified header.\n// 'intended_payload_len' is the expected maximum length of data for this entry's payload.\nint createNewLogEntry(uint8_t event_type, uint16_t intended_payload_len) {\n    uint16_t total_entry_size = DIAG_LOG_ENTRY_HEADER_SIZE + intended_payload_len;\n\n    if (intended_payload_len > DIAG_LOG_MAX_PAYLOAD_SIZE) {\n        return -1; // Payload length exceeds maximum allowed for any single entry\n    }\n    if (total_entry_size > DIAG_LOG_TOTAL_BUFFER_SIZE) {\n        return -2; // Entry too large for the entire buffer\n    }\n\n    // Handle circular buffer wrap-around for the start of the new entry.\n    // If the new entry doesn't fit contiguously, wrap to the beginning.\n    if (g_currentEntryStart + total_entry_size > DIAG_LOG_TOTAL_BUFFER_SIZE) {\n        g_currentEntryStart = 0; // Wrap to beginning of buffer\n    }\n\n    // Write simplified header data at g_currentEntryStart\n    g_diagLogBuffer[g_currentEntryStart] = event_type; // Byte 0: Event Type\n    // Bytes 1-5 reserved/other header fields (for simplicity, assumed to be 0)\n    // Bytes 6-7: Data Length (MSB, LSB) - stored here for later reference\n    g_diagLogBuffer[g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE - 2] = (uint8_t)(intended_payload_len >> 8);\n    g_diagLogBuffer[g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE - 1] = (uint8_t)(intended_payload_len & 0xFF);\n\n    return 0; // Success\n}\n\n// This function is used to update a specific byte within the payload\n// of the *current* active log entry. This is often used for incrementally\n// filling or correcting log data.\n// 'payload_offset': The offset FROM THE START OF THE PAYLOAD AREA of the current entry.\n// 'value': The byte value to write.\nint updateLogEntryPayloadByte(uint16_t payload_offset, uint8_t value) {\n    // Retrieve the intended payload length for the current entry from its header.\n    // This assumes g_currentEntryStart points to a valid header of an active entry.\n    uint16_t stored_intended_payload_len = (g_diagLogBuffer[g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE - 2] << 8) |\n                                           g_diagLogBuffer[g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE - 1];\n\n    // FIX: Add a bounds check to ensure 'payload_offset' is within the intended payload area.\n    if (payload_offset >= stored_intended_payload_len) {\n        return -2; // Attempt to write beyond the intended payload area for this entry\n    }\n\n    uint16_t absolute_write_pos = g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE + payload_offset;\n\n    // Defensive check: This condition should ideally not be reached if the intended_payload_len\n    // was correctly validated when the entry was created, and payload_offset is now validated.\n    if (absolute_write_pos >= DIAG_LOG_TOTAL_BUFFER_SIZE) {\n        return -1; // Attempt to write beyond total log buffer boundaries (should be caught earlier)\n    }\n\n    g_diagLogBuffer[absolute_write_pos] = value;\n    return 0;\n}\n\n// After an entry is fully populated, this function advances the write pointer.\n// 'actual_payload_len': The actual number of payload bytes written for this entry.\nvoid finalizeLogEntry(uint16_t actual_payload_len) {\n    g_currentEntryStart = (g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE + actual_payload_len) % DIAG_LOG_TOTAL_BUFFER_SIZE;\n}\n\n// Public interface to simulate logging a vehicle event with a given data block.\n// This function itself appears safe by respecting effective_payload_len.\nvoid logVehicleEvent(uint8_t event_type, const uint8_t* event_data, uint16_t event_data_len) {\n    if (event_data == NULL || event_data_len == 0) return;\n\n    uint16_t effective_payload_len = event_data_len;\n    if (effective_payload_len > DIAG_LOG_MAX_PAYLOAD_SIZE) {\n        effective_payload_len = DIAG_LOG_MAX_PAYLOAD_SIZE;\n    }\n\n    if (createNewLogEntry(event_type, effective_payload_len) == 0) {\n        for (uint16_t i = 0; i < effective_payload_len; ++i) {\n            updateLogEntryPayloadByte(i, event_data[i]);\n        }\n        finalizeLogEntry(effective_payload_len);\n    }\n}\n\n// Function simulating an external call that might have attempted to exploit the vulnerability.\nvoid maliciousDiagnosticPoke(uint16_t offset_from_payload_start, uint8_t value) {\n    // Now, updateLogEntryPayloadByte is protected and will return an error\n    // if the offset is out of the logical bounds of the current entry's payload.\n    updateLogEntryPayloadByte(offset_from_payload_start, value);\n}\n\n// Example of how a diagnostic command handler might use these functions\nvoid processDiagnosticCommand(uint8_t command_id, uint8_t* command_payload, uint16_t payload_len) {\n    initDiagnosticLogger(); // Initialize for demonstration\n\n    switch(command_id) {\n        case 0x01: // Standard event logging command\n            logVehicleEvent(0x55, command_payload, payload_len);\n            break;\n        case 0x02: // Special command to 'poke' a byte in the current log entry's data area\n            if (payload_len >= 3) {\n                uint16_t offset = (command_payload[0] << 8) | command_payload[1];\n                uint8_t val = command_payload[2];\n                maliciousDiagnosticPoke(offset, val);\n            }\n            break;\n        // ... other commands\n    }\n}\n", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_TELEMETRY_DATA_BLOCKS 4\n#define TELEMETRY_DATA_BLOCK_SIZE 64\n\nstatic uint8_t g_telemetryDataBlocks[MAX_TELEMETRY_DATA_BLOCKS][TELEMETRY_DATA_BLOCK_SIZE];\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t block_idx;\n    uint8_t start_offset;\n    uint8_t data_len;\n} TelemetryUpdateCommandHeader;\n\nvoid initTelemetryData() {\n    for (int i = 0; i < MAX_TELEMETRY_DATA_BLOCKS; ++i) {\n        memset(g_telemetryDataBlocks[i], 0x00, TELEMETRY_DATA_BLOCK_SIZE);\n    }\n}\n\nint processTelemetryUpdate(const uint8_t* msg_payload, uint16_t payload_total_len) {\n    if (msg_payload == NULL || payload_total_len < sizeof(TelemetryUpdateCommandHeader)) {\n        return -1;\n    }\n\n    const TelemetryUpdateCommandHeader* header = (const TelemetryUpdateCommandHeader*)msg_payload;\n\n    if (header->command_id != 0x01) {\n        return -2;\n    }\n\n    if (header->block_idx >= MAX_TELEMETRY_DATA_BLOCKS) {\n        return -3;\n    }\n    if (header->start_offset >= TELEMETRY_DATA_BLOCK_SIZE) {\n        return -4;\n    }\n\n    if (payload_total_len < sizeof(TelemetryUpdateCommandHeader) + header->data_len) {\n        return -5;\n    }\n\n    const uint8_t* data_to_write = msg_payload + sizeof(TelemetryUpdateCommandHeader);\n\n    for (uint8_t i = 0; i < header->data_len; ++i) {\n        g_telemetryDataBlocks[header->block_idx][header->start_offset + i] = data_to_write[i];\n    }\n\n    return 0;\n}\n\nvoid receiveCANTelemetryCommand(const uint8_t* data, uint16_t len) {\n    initTelemetryData();\n    processTelemetryUpdate(data, len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_TELEMETRY_DATA_BLOCKS 4\n#define TELEMETRY_DATA_BLOCK_SIZE 64\n\nstatic uint8_t g_telemetryDataBlocks[MAX_TELEMETRY_DATA_BLOCKS][TELEMETRY_DATA_BLOCK_SIZE];\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t block_idx;\n    uint8_t start_offset;\n    uint8_t data_len;\n} TelemetryUpdateCommandHeader;\n\nvoid initTelemetryData() {\n    for (int i = 0; i < MAX_TELEMETRY_DATA_BLOCKS; ++i) {\n        memset(g_telemetryDataBlocks[i], 0x00, TELEMETRY_DATA_BLOCK_SIZE);\n    }\n}\n\nint processTelemetryUpdate(const uint8_t* msg_payload, uint16_t payload_total_len) {\n    if (msg_payload == NULL || payload_total_len < sizeof(TelemetryUpdateCommandHeader)) {\n        return -1;\n    }\n\n    const TelemetryUpdateCommandHeader* header = (const TelemetryUpdateCommandHeader*)msg_payload;\n\n    if (header->command_id != 0x01) {\n        return -2;\n    }\n\n    if (header->block_idx >= MAX_TELEMETRY_DATA_BLOCKS) {\n        return -3;\n    }\n    if (header->start_offset >= TELEMETRY_DATA_BLOCK_SIZE) {\n        return -4;\n    }\n\n    if (payload_total_len < sizeof(TelemetryUpdateCommandHeader) + header->data_len) {\n        return -5;\n    }\n\n    if ((uint16_t)header->start_offset + header->data_len > TELEMETRY_DATA_BLOCK_SIZE) {\n        return -6;\n    }\n\n    const uint8_t* data_to_write = msg_payload + sizeof(TelemetryUpdateCommandHeader);\n\n    for (uint8_t i = 0; i < header->data_len; ++i) {\n        g_telemetryDataBlocks[header->block_idx][header->start_offset + i] = data_to_write[i];\n    }\n\n    return 0;\n}\n\nvoid receiveCANTelemetryCommand(const uint8_t* data, uint16_t len) {\n    initTelemetryData();\n    processTelemetryUpdate(data, len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_DATA_STORAGE_SIZE 250\n\nstatic uint8_t g_diagDataStore[DIAG_DATA_STORAGE_SIZE];\n\nvoid initDiagnosticDataStore() {\n    memset(g_diagDataStore, 0, DIAG_DATA_STORAGE_SIZE);\n}\n\nint updateDiagnosticBlock(uint16_t offset, uint8_t len, const uint8_t* data) {\n    if (data == NULL || len == 0) {\n        return -1;\n    }\n\n    if (offset >= DIAG_DATA_STORAGE_SIZE) {\n        return -2;\n    }\n\n    for (uint8_t i = 0; i < len; ++i) {\n        g_diagDataStore[offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid handleDiagnosticUpdateMessage(const uint8_t* msg_raw, uint16_t msg_raw_len) {\n    if (msg_raw == NULL || msg_raw_len < 3) {\n        return;\n    }\n\n    uint16_t current_read_pos = 0;\n\n    uint16_t block_offset = (msg_raw[current_read_pos] << 8) | msg_raw[current_read_pos + 1];\n    current_read_pos += 2;\n\n    uint8_t block_len = msg_raw[current_read_pos];\n    current_read_pos += 1;\n\n    if (current_read_pos + block_len > msg_raw_len) {\n        return;\n    }\n\n    const uint8_t* payload_ptr = msg_raw + current_read_pos;\n\n    updateDiagnosticBlock(block_offset, block_len, payload_ptr);\n}\n\nuint8_t getDiagDataByte(uint16_t index) {\n    if (index < DIAG_DATA_STORAGE_SIZE) {\n        return g_diagDataStore[index];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_DATA_STORAGE_SIZE 250\n\nstatic uint8_t g_diagDataStore[DIAG_DATA_STORAGE_SIZE];\n\nvoid initDiagnosticDataStore() {\n    memset(g_diagDataStore, 0, DIAG_DATA_STORAGE_SIZE);\n}\n\nint updateDiagnosticBlock(uint16_t offset, uint8_t len, const uint8_t* data) {\n    if (data == NULL || len == 0) {\n        return -1;\n    }\n\n    if (offset >= DIAG_DATA_STORAGE_SIZE) {\n        return -2;\n    }\n\n    if ((uint32_t)offset + len > DIAG_DATA_STORAGE_SIZE) {\n        return -3;\n    }\n\n    for (uint8_t i = 0; i < len; ++i) {\n        g_diagDataStore[offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid handleDiagnosticUpdateMessage(const uint8_t* msg_raw, uint16_t msg_raw_len) {\n    if (msg_raw == NULL || msg_raw_len < 3) {\n        return;\n    }\n\n    uint16_t current_read_pos = 0;\n\n    uint16_t block_offset = (msg_raw[current_read_pos] << 8) | msg_raw[current_read_pos + 1];\n    current_read_pos += 2;\n\n    uint8_t block_len = msg_raw[current_read_pos];\n    current_read_pos += 1;\n\n    if (current_read_pos + block_len > msg_raw_len) {\n        return;\n    }\n\n    const uint8_t* payload_ptr = msg_raw + current_read_pos;\n\n    updateDiagnosticBlock(block_offset, block_len, payload_ptr);\n}\n\nuint8_t getDiagDataByte(uint16_t index) {\n    if (index < DIAG_DATA_STORAGE_SIZE) {\n        return g_diagDataStore[index];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_BUFFER_SIZE 256\n#define MAX_TELEMETRY_PACKET_SIZE 512\n\nstatic uint8_t g_telemetryBuffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_telemetryCurrentOffset = 0;\n\ntypedef struct {\n    uint8_t sensor_id;\n    uint8_t data_type;\n    uint16_t data_len;\n} TelemetryDataHeader;\n\nvoid initTelemetryAggregator() {\n    memset(g_telemetryBuffer, 0x00, TELEMETRY_BUFFER_SIZE);\n    g_telemetryCurrentOffset = 0;\n}\n\nint appendSingleTelemetryEntry(const uint8_t* raw_entry_data, uint16_t raw_entry_len) {\n    if (raw_entry_data == NULL || raw_entry_len < sizeof(TelemetryDataHeader)) {\n        return -1;\n    }\n\n    uint8_t sensor_id = raw_entry_data[0];\n    uint8_t data_type = raw_entry_data[1];\n    uint16_t received_data_len = (raw_entry_data[2] << 8) | raw_entry_data[3];\n    const uint8_t* actual_data_ptr = raw_entry_data + sizeof(TelemetryDataHeader);\n\n    if (sizeof(TelemetryDataHeader) + received_data_len > raw_entry_len) {\n        return -2;\n    }\n\n    uint16_t entry_total_size = sizeof(TelemetryDataHeader) + received_data_len;\n\n    if (g_telemetryCurrentOffset + entry_total_size > TELEMETRY_BUFFER_SIZE) {\n        return -3;\n    }\n\n    uint8_t* write_ptr = g_telemetryBuffer + g_telemetryCurrentOffset;\n    *write_ptr++ = sensor_id;\n    *write_ptr++ = data_type;\n    *write_ptr++ = (uint8_t)(received_data_len >> 8);\n    *write_ptr++ = (uint8_t)(received_data_len & 0xFF);\n\n    for (uint16_t i = 0; i < received_data_len; ++i) {\n        *write_ptr++ = actual_data_ptr[i];\n    }\n\n    g_telemetryCurrentOffset += entry_total_size;\n\n    return 0;\n}\n\nint processTelemetryPacket(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len == 0) {\n        return -1;\n    }\n    if (packet_len > MAX_TELEMETRY_PACKET_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_packet_offset = 0;\n    while (current_packet_offset < packet_len) {\n        if (current_packet_offset + sizeof(TelemetryDataHeader) > packet_len) {\n            return -2;\n        }\n\n        uint16_t entry_data_len_in_header = (packet_data[current_packet_offset + 2] << 8) | packet_data[current_packet_offset + 3];\n        uint16_t entry_expected_total_len = sizeof(TelemetryDataHeader) + entry_data_len_in_header;\n\n        if (current_packet_offset + entry_expected_total_len > packet_len) {\n            return -3;\n        }\n\n        int result = appendSingleTelemetryEntry(packet_data + current_packet_offset, entry_expected_total_len);\n        if (result != 0) {\n            return result;\n        }\n        current_packet_offset += entry_expected_total_len;\n    }\n    return 0;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_BUFFER_SIZE 256\n#define MAX_TELEMETRY_PACKET_SIZE 512\n#define MAX_SINGLE_ENTRY_PAYLOAD_LEN (TELEMETRY_BUFFER_SIZE - sizeof(TelemetryDataHeader)) \n\nstatic uint8_t g_telemetryBuffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_telemetryCurrentOffset = 0;\n\ntypedef struct {\n    uint8_t sensor_id;\n    uint8_t data_type;\n    uint16_t data_len;\n} TelemetryDataHeader;\n\nvoid initTelemetryAggregator() {\n    memset(g_telemetryBuffer, 0x00, TELEMETRY_BUFFER_SIZE);\n    g_telemetryCurrentOffset = 0;\n}\n\nint appendSingleTelemetryEntry(const uint8_t* raw_entry_data, uint16_t raw_entry_len) {\n    if (raw_entry_data == NULL || raw_entry_len < sizeof(TelemetryDataHeader)) {\n        return -1;\n    }\n\n    uint8_t sensor_id = raw_entry_data[0];\n    uint8_t data_type = raw_entry_data[1];\n    uint16_t received_data_len = (raw_entry_data[2] << 8) | raw_entry_data[3];\n    const uint8_t* actual_data_ptr = raw_entry_data + sizeof(TelemetryDataHeader);\n\n    if (sizeof(TelemetryDataHeader) + received_data_len > raw_entry_len) {\n        return -2;\n    }\n\n    uint16_t effective_data_len = received_data_len;\n    if (effective_data_len > MAX_SINGLE_ENTRY_PAYLOAD_LEN) {\n        effective_data_len = MAX_SINGLE_ENTRY_PAYLOAD_LEN;\n    }\n\n    uint32_t entry_total_size_check = (uint32_t)sizeof(TelemetryDataHeader) + effective_data_len;\n\n    if ((uint32_t)g_telemetryCurrentOffset + entry_total_size_check > TELEMETRY_BUFFER_SIZE) {\n        return -3;\n    }\n\n    uint8_t* write_ptr = g_telemetryBuffer + g_telemetryCurrentOffset;\n    *write_ptr++ = sensor_id;\n    *write_ptr++ = data_type;\n    *write_ptr++ = (uint8_t)(effective_data_len >> 8);\n    *write_ptr++ = (uint8_t)(effective_data_len & 0xFF);\n\n    for (uint16_t i = 0; i < effective_data_len; ++i) {\n        *write_ptr++ = actual_data_ptr[i];\n    }\n\n    g_telemetryCurrentOffset += (uint16_t)entry_total_size_check;\n\n    return 0;\n}\n\nint processTelemetryPacket(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len == 0) {\n        return -1;\n    }\n    if (packet_len > MAX_TELEMETRY_PACKET_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_packet_offset = 0;\n    while (current_packet_offset < packet_len) {\n        if (current_packet_offset + sizeof(TelemetryDataHeader) > packet_len) {\n            return -2;\n        }\n\n        uint16_t entry_data_len_in_header = (packet_data[current_packet_offset + 2] << 8) | packet_data[current_packet_offset + 3];\n        \n        uint32_t entry_expected_total_len_check = (uint32_t)sizeof(TelemetryDataHeader) + entry_data_len_in_header;\n        uint16_t entry_expected_total_len;\n\n        if (entry_expected_total_len_check > (uint32_t)packet_len - current_packet_offset) {\n            entry_expected_total_len = packet_len - current_packet_offset;\n        } else {\n            entry_expected_total_len = (uint16_t)entry_expected_total_len_check;\n        }\n\n        if (current_packet_offset + entry_expected_total_len > packet_len) {\n             return -3;\n        }\n\n        int result = appendSingleTelemetryEntry(packet_data + current_packet_offset, entry_expected_total_len);\n        if (result != 0) {\n            return result;\n        }\n        current_packet_offset += entry_expected_total_len;\n    }\n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdio.h>\n\n#define DIAG_REPORT_BUFFER_SIZE 64\n#define MAX_VIN_LENGTH 17\n\ntypedef struct {\n    uint16_t dtc_code;\n    uint32_t timestamp;\n    char component_id[5];\n    char vin[MAX_VIN_LENGTH + 1];\n} DiagnosticReportData;\n\nstatic char g_diagnosticReportBuffer[DIAG_REPORT_BUFFER_SIZE];\n\nstatic int append_to_report_buffer(const char* str, uint32_t len, uint32_t* current_offset, uint32_t buffer_size) {\n    if (str == NULL || *current_offset >= buffer_size) {\n        return -1;\n    }\n\n    uint32_t remaining_space = buffer_size - *current_offset;\n    uint32_t bytes_to_copy = len;\n\n    if (bytes_to_copy > remaining_space) {\n        bytes_to_copy = remaining_space;\n    }\n    \n    for (uint32_t i = 0; i < bytes_to_copy; ++i) {\n        g_diagnosticReportBuffer[*current_offset + i] = str[i];\n    }\n    *current_offset += bytes_to_copy;\n\n    return 0;\n}\n\nint generateDiagnosticReport(const DiagnosticReportData* data) {\n    if (data == NULL) {\n        return -1;\n    }\n\n    uint32_t current_pos = 0;\n    memset(g_diagnosticReportBuffer, 0, DIAG_REPORT_BUFFER_SIZE);\n\n    const char* prefix = ", "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdio.h>\n\n#define DIAG_REPORT_BUFFER_SIZE 64\n#define MAX_VIN_LENGTH 17\n\ntypedef struct {\n    uint16_t dtc_code;\n    uint32_t timestamp;\n    char component_id[5];\n    char vin[MAX_VIN_LENGTH + 1];\n} DiagnosticReportData;\n\nstatic char g_diagnosticReportBuffer[DIAG_REPORT_BUFFER_SIZE];\n\nstatic int append_to_report_buffer_safe(const char* str, uint32_t len, uint32_t* current_offset, uint32_t buffer_size) {\n    if (str == NULL || *current_offset >= buffer_size) {\n        return -1;\n    }\n\n    uint32_t remaining_space_for_data = 0;\n    if (buffer_size > *current_offset) {\n        remaining_space_for_data = buffer_size - *current_offset - 1; \n    }\n\n    uint32_t bytes_to_copy = len;\n    if (bytes_to_copy > remaining_space_for_data) {\n        bytes_to_copy = remaining_space_for_data;\n    }\n    \n    for (uint32_t i = 0; i < bytes_to_copy; ++i) {\n        g_diagnosticReportBuffer[*current_offset + i] = str[i];\n    }\n    *current_offset += bytes_to_copy;\n\n    return 0;\n}\n\nint generateDiagnosticReport(const DiagnosticReportData* data) {\n    if (data == NULL) {\n        return -1;\n    }\n\n    uint32_t current_pos = 0;\n    memset(g_diagnosticReportBuffer, 0, DIAG_REPORT_BUFFER_SIZE);\n\n    const char* prefix = ", "analysis": ""}
