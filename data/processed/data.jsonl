{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <string.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n#define CAN_PAYLOAD_MAX_SUPPORTED 256\n#define DIAG_PROCESSING_BUFFER_SIZE 128\n\ntypedef struct {\n    uint32_t arbitrationId;\n    uint8_t  dlc;\n    uint8_t  data[CAN_PAYLOAD_MAX_SUPPORTED];\n} CanRxFrame;\n\ntypedef struct {\n    uint8_t currentServiceId;\n    uint8_t diagnosticDataBuffer[DIAG_PROCESSING_BUFFER_SIZE];\n    uint16_t dataReceivedLength;\n    bool processingActive;\n} DiagnosticHandlerContext;\n\nstatic DiagnosticHandlerContext g_diagContext = {0};\n\nvoid initDiagnosticHandler(void) {\n    memset(&g_diagContext, 0, sizeof(DiagnosticHandlerContext));\n    g_diagContext.processingActive = false;\n}\n\nint handleIncomingDiagnosticMessage(const CanRxFrame* frame) {\n    if (frame == NULL || frame->dlc == 0) {\n        return -1;\n    }\n\n    memcpy(g_diagContext.diagnosticDataBuffer, frame->data, frame->dlc);\n\n    g_diagContext.dataReceivedLength = frame->dlc;\n    g_diagContext.processingActive = true;\n    g_diagContext.currentServiceId = g_diagContext.diagnosticDataBuffer[0];\n\n    if (g_diagContext.currentServiceId == 0x22) {\n        // Process data identifier request\n    } else if (g_diagContext.currentServiceId == 0x2E) {\n        // Process write request\n    }\n\n    return 0;\n}", "fixed_code": "#include <string.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n#define CAN_PAYLOAD_MAX_SUPPORTED 256\n#define DIAG_PROCESSING_BUFFER_SIZE 128\n\ntypedef struct {\n    uint32_t arbitrationId;\n    uint8_t  dlc;\n    uint8_t  data[CAN_PAYLOAD_MAX_SUPPORTED];\n} CanRxFrame;\n\ntypedef struct {\n    uint8_t currentServiceId;\n    uint8_t diagnosticDataBuffer[DIAG_PROCESSING_BUFFER_SIZE];\n    uint16_t dataReceivedLength;\n    bool processingActive;\n} DiagnosticHandlerContext;\n\nstatic DiagnosticHandlerContext g_diagContext = {0};\n\nvoid initDiagnosticHandler(void) {\n    memset(&g_diagContext, 0, sizeof(DiagnosticHandlerContext));\n    g_diagContext.processingActive = false;\n}\n\nint handleIncomingDiagnosticMessage(const CanRxFrame* frame) {\n    if (frame == NULL || frame->dlc == 0) {\n        return -1;\n    }\n\n    uint16_t bytesToCopy = frame->dlc;\n    if (bytesToCopy > DIAG_PROCESSING_BUFFER_SIZE) {\n        bytesToCopy = DIAG_PROCESSING_BUFFER_SIZE;\n    }\n\n    memcpy(g_diagContext.diagnosticDataBuffer, frame->data, bytesToCopy);\n\n    g_diagContext.dataReceivedLength = bytesToCopy;\n    g_diagContext.processingActive = true;\n    g_diagContext.currentServiceId = g_diagContext.diagnosticDataBuffer[0];\n\n    if (g_diagContext.currentServiceId == 0x22) {\n        // Process data identifier request\n    } else if (g_diagContext.currentServiceId == 0x2E) {\n        // Process write request\n    }\n\n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <string.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n// Vehicle parameter IDs\n#define VEHICLE_PARAM_SENSOR_CALIBRATION_A 0x10\n#define VEHICLE_PARAM_VEHICLE_IDENTIFIER   0x11\n#define VEHICLE_PARAM_DIAG_LIFETIME_COUNTER 0x12\n\n// Maximum length for vehicle identifier string\n#define VEHICLE_IDENTIFIER_MAX_LEN 16\n\n// Structure to hold vehicle configuration parameters\ntypedef struct {\n    uint16_t sensorCalibrationValueA;       // 2 bytes\n    char     vehicleIdentifier[VEHICLE_IDENTIFIER_MAX_LEN]; // 16 bytes buffer for C string\n    uint32_t diagnosticLifetimeCounter;     // 4 bytes\n    uint8_t  featureFlags[4];               // 4 bytes of feature flags\n} VehicleSystemConfiguration;\n\n// Global instance of the vehicle configuration\nstatic VehicleSystemConfiguration g_systemConfig;\n\n// Function to initialize the configuration\nvoid systemConfigInit() {\n    g_systemConfig.sensorCalibrationValueA = 512;\n    strncpy(g_systemConfig.vehicleIdentifier, \"DEFAULT_VIN_XYZ\", VEHICLE_IDENTIFIER_MAX_LEN - 1);\n    g_systemConfig.vehicleIdentifier[VEHICLE_IDENTIFIER_MAX_LEN - 1] = '\\0';\n    g_systemConfig.diagnosticLifetimeCounter = 0;\n    memset(g_systemConfig.featureFlags, 0, sizeof(g_systemConfig.featureFlags));\n}\n\n// Function to process an incoming update request for a specific vehicle parameter\n// This function could be called by a diagnostic service handler or a CAN message handler.\n// paramId: The ID of the parameter to update.\n// data: Pointer to the new data for the parameter.\n// dataLen: The length of the new data in bytes.\nint updateVehicleParameter(uint8_t paramId, const uint8_t* data, uint16_t dataLen) {\n    if (data == NULL || dataLen == 0) {\n        return -1; // Invalid input\n    }\n\n    switch (paramId) {\n        case VEHICLE_PARAM_SENSOR_CALIBRATION_A:\n            if (dataLen == sizeof(uint16_t)) {\n                // Assuming little-endian or byte-order handled by caller/system\n                g_systemConfig.sensorCalibrationValueA = *(uint16_t*)data;\n            } else {\n                return -2; // Incorrect data length for calibration value\n            }\n            break;\n\n        case VEHICLE_PARAM_VEHICLE_IDENTIFIER:\n            // Vulnerability: No explicit length check against VEHICLE_IDENTIFIER_MAX_LEN\n            // The memcpy copies 'dataLen' bytes. If dataLen > VEHICLE_IDENTIFIER_MAX_LEN,\n            // it will write past the end of 'vehicleIdentifier', overflowing into\n            // 'diagnosticLifetimeCounter' and 'featureFlags'.\n            memcpy(g_systemConfig.vehicleIdentifier, data, dataLen);\n            // This line attempts to null-terminate, but only if dataLen < buffer size,\n            // which doesn't protect against overflow if dataLen is too large.\n            if (dataLen < VEHICLE_IDENTIFIER_MAX_LEN) {\n                g_systemConfig.vehicleIdentifier[dataLen] = '\\0';\n            } else {\n                g_systemConfig.vehicleIdentifier[VEHICLE_IDENTIFIER_MAX_LEN - 1] = '\\0';\n            }\n            break;\n\n        case VEHICLE_PARAM_DIAG_LIFETIME_COUNTER:\n            if (dataLen == sizeof(uint32_t)) {\n                g_systemConfig.diagnosticLifetimeCounter = *(uint32_t*)data;\n            } else {\n                return -2; // Incorrect data length for lifetime counter\n            }\n            break;\n\n        default:\n            return -3; // Unknown parameter ID\n    }\n\n    return 0; // Parameter updated successfully\n}\n\n// Example usage context (not part of the vulnerability, just for completeness)\nvoid simulateIncomingMessage(uint8_t id, const uint8_t* payload, uint16_t len) {\n    updateVehicleParameter(id, payload, len);\n}", "fixed_code": "#include <string.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n// Vehicle parameter IDs\n#define VEHICLE_PARAM_SENSOR_CALIBRATION_A 0x10\n#define VEHICLE_PARAM_VEHICLE_IDENTIFIER   0x11\n#define VEHICLE_PARAM_DIAG_LIFETIME_COUNTER 0x12\n\n// Maximum length for vehicle identifier string\n#define VEHICLE_IDENTIFIER_MAX_LEN 16\n\n// Structure to hold vehicle configuration parameters\ntypedef struct {\n    uint16_t sensorCalibrationValueA;       // 2 bytes\n    char     vehicleIdentifier[VEHICLE_IDENTIFIER_MAX_LEN]; // 16 bytes buffer for C string\n    uint32_t diagnosticLifetimeCounter;     // 4 bytes\n    uint8_t  featureFlags[4];               // 4 bytes of feature flags\n} VehicleSystemConfiguration;\n\n// Global instance of the vehicle configuration\nstatic VehicleSystemConfiguration g_systemConfig;\n\n// Function to initialize the configuration\nvoid systemConfigInit() {\n    g_systemConfig.sensorCalibrationValueA = 512;\n    strncpy(g_systemConfig.vehicleIdentifier, \"DEFAULT_VIN_XYZ\", VEHICLE_IDENTIFIER_MAX_LEN - 1);\n    g_systemConfig.vehicleIdentifier[VEHICLE_IDENTIFIER_MAX_LEN - 1] = '\\0';\n    g_systemConfig.diagnosticLifetimeCounter = 0;\n    memset(g_systemConfig.featureFlags, 0, sizeof(g_systemConfig.featureFlags));\n}\n\n// Function to process an incoming update request for a specific vehicle parameter\n// This function could be called by a diagnostic service handler or a CAN message handler.\n// paramId: The ID of the parameter to update.\n// data: Pointer to the new data for the parameter.\n// dataLen: The length of the new data in bytes.\nint updateVehicleParameter(uint8_t paramId, const uint8_t* data, uint16_t dataLen) {\n    if (data == NULL || dataLen == 0) {\n        return -1; // Invalid input\n    }\n\n    switch (paramId) {\n        case VEHICLE_PARAM_SENSOR_CALIBRATION_A:\n            if (dataLen == sizeof(uint16_t)) {\n                // Assuming little-endian or byte-order handled by caller/system\n                g_systemConfig.sensorCalibrationValueA = *(uint16_t*)data;\n            } else {\n                return -2; // Incorrect data length for calibration value\n            }\n            break;\n\n        case VEHICLE_PARAM_VEHICLE_IDENTIFIER:\n            // Fix: Add explicit length check against the buffer's capacity\n            uint16_t bytesToCopy = dataLen;\n            if (bytesToCopy >= VEHICLE_IDENTIFIER_MAX_LEN) { // Use >= to account for null terminator space if applicable\n                bytesToCopy = VEHICLE_IDENTIFIER_MAX_LEN - 1; // Truncate to fit, leaving space for null terminator\n            }\n            memcpy(g_systemConfig.vehicleIdentifier, data, bytesToCopy);\n            g_systemConfig.vehicleIdentifier[bytesToCopy] = '\\0'; // Ensure null termination\n            break;\n\n        case VEHICLE_PARAM_DIAG_LIFETIME_COUNTER:\n            if (dataLen == sizeof(uint32_t)) {\n                g_systemConfig.diagnosticLifetimeCounter = *(uint32_t*)data;\n            } else {\n                return -2; // Incorrect data length for lifetime counter\n            }\n            break;\n\n        default:\n            return -3; // Unknown parameter ID\n    }\n\n    return 0; // Parameter updated successfully\n}\n\n// Example usage context (not part of the vulnerability, just for completeness)\nvoid simulateIncomingMessage(uint8_t id, const uint8_t* payload, uint16_t len) {\n    updateVehicleParameter(id, payload, len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CONFIG_NAME_MAX_LEN 32\n#define CONFIG_VALUE_MAX_LEN 64\n#define MAX_CONFIG_PARAMS 10\n\ntypedef enum {\n    PARAM_TYPE_UINT8,\n    PARAM_TYPE_UINT16,\n    PARAM_TYPE_UINT32,\n    PARAM_TYPE_STRING,\n    PARAM_TYPE_BOOL\n} ConfigParamType;\n\ntypedef struct {\n    char name[CONFIG_NAME_MAX_LEN];\n    ConfigParamType type;\n    uint8_t value_len;\n    union {\n        uint8_t  u8_val;\n        uint16_t u16_val;\n        uint32_t u32_val;\n        char     str_val[CONFIG_VALUE_MAX_LEN];\n        bool     bool_val;\n    } value;\n} ConfigurationParameter;\n\nstatic ConfigurationParameter g_vehicleConfig[MAX_CONFIG_PARAMS];\nstatic uint8_t g_numConfigParams = 0;\n\nint parseConfigurationParameter(const uint8_t* stream, uint16_t stream_len, ConfigurationParameter* param_out) {\n    if (stream == NULL || param_out == NULL || stream_len < 2) {\n        return -1;\n    }\n\n    uint16_t bytes_consumed = 0;\n\n    uint8_t name_len = stream[bytes_consumed++];\n    if (name_len >= CONFIG_NAME_MAX_LEN || bytes_consumed + name_len > stream_len) {\n        return -1;\n    }\n    memcpy(param_out->name, stream + bytes_consumed, name_len);\n    param_out->name[name_len] = '\\0';\n    bytes_consumed += name_len;\n\n    param_out->type = (ConfigParamType)stream[bytes_consumed++];\n    if (bytes_consumed > stream_len) {\n        return -1;\n    }\n\n    switch (param_out->type) {\n        case PARAM_TYPE_UINT8:\n            if (bytes_consumed + sizeof(uint8_t) > stream_len) return -1;\n            param_out->value.u8_val = stream[bytes_consumed];\n            param_out->value_len = sizeof(uint8_t);\n            bytes_consumed += sizeof(uint8_t);\n            break;\n        case PARAM_TYPE_UINT16:\n            if (bytes_consumed + sizeof(uint16_t) > stream_len) return -1;\n            param_out->value.u16_val = (uint16_t)((stream[bytes_consumed] << 8) | stream[bytes_consumed+1]);\n            param_out->value_len = sizeof(uint16_t);\n            bytes_consumed += sizeof(uint16_t);\n            break;\n        case PARAM_TYPE_UINT32:\n            if (bytes_consumed + sizeof(uint32_t) > stream_len) return -1;\n            param_out->value.u32_val = (uint32_t)((stream[bytes_consumed] << 24) | (stream[bytes_consumed+1] << 16) |\n                                                   (stream[bytes_consumed+2] << 8) | stream[bytes_consumed+3]);\n            param_out->value_len = sizeof(uint32_t);\n            bytes_consumed += sizeof(uint32_t);\n            break;\n        case PARAM_TYPE_BOOL:\n            if (bytes_consumed + sizeof(bool) > stream_len) return -1;\n            param_out->value.bool_val = (bool)stream[bytes_consumed];\n            param_out->value_len = sizeof(bool);\n            bytes_consumed += sizeof(bool);\n            break;\n        case PARAM_TYPE_STRING:\n            if (bytes_consumed >= stream_len) return -1;\n            uint8_t str_actual_len = stream[bytes_consumed++];\n            if (str_actual_len > CONFIG_VALUE_MAX_LEN || bytes_consumed + str_actual_len > stream_len) {\n                return -1;\n            }\n            memcpy(param_out->value.str_val, stream + bytes_consumed, str_actual_len);\n            param_out->value.str_val[str_actual_len] = '\\0';\n            param_out->value_len = str_actual_len;\n            bytes_consumed += str_actual_len;\n            break;\n        default:\n            return -1;\n    }\n\n    return bytes_consumed;\n}\n\nint loadVehicleConfiguration(const uint8_t* config_stream, uint16_t stream_total_len) {\n    if (config_stream == NULL || stream_total_len == 0) {\n        return -1;\n    }\n\n    uint16_t current_stream_pos = 0;\n    g_numConfigParams = 0;\n\n    while (current_stream_pos < stream_total_len && g_numConfigParams < MAX_CONFIG_PARAMS) {\n        int bytes_parsed = parseConfigurationParameter(\n                                config_stream + current_stream_pos,\n                                stream_total_len - current_stream_pos,\n                                &g_vehicleConfig[g_numConfigParams]\n                           );\n\n        if (bytes_parsed <= 0) {\n            return -1;\n        }\n        current_stream_pos += bytes_parsed;\n        g_numConfigParams++;\n    }\n\n    return 0;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CONFIG_NAME_MAX_LEN 32\n#define CONFIG_VALUE_MAX_LEN 64\n#define MAX_CONFIG_PARAMS 10\n\ntypedef enum {\n    PARAM_TYPE_UINT8,\n    PARAM_TYPE_UINT16,\n    PARAM_TYPE_UINT32,\n    PARAM_TYPE_STRING,\n    PARAM_TYPE_BOOL\n} ConfigParamType;\n\ntypedef struct {\n    char name[CONFIG_NAME_MAX_LEN];\n    ConfigParamType type;\n    uint8_t value_len;\n    union {\n        uint8_t  u8_val;\n        uint16_t u16_val;\n        uint32_t u32_val;\n        char     str_val[CONFIG_VALUE_MAX_LEN];\n        bool     bool_val;\n    } value;\n} ConfigurationParameter;\n\nstatic ConfigurationParameter g_vehicleConfig[MAX_CONFIG_PARAMS];\nstatic uint8_t g_numConfigParams = 0;\n\nint parseConfigurationParameter(const uint8_t* stream, uint16_t stream_len, ConfigurationParameter* param_out) {\n    if (stream == NULL || param_out == NULL || stream_len < 2) {\n        return -1;\n    }\n\n    uint16_t bytes_consumed = 0;\n\n    uint8_t name_len = stream[bytes_consumed++];\n    if (name_len >= CONFIG_NAME_MAX_LEN || bytes_consumed + name_len > stream_len) {\n        return -1;\n    }\n    memcpy(param_out->name, stream + bytes_consumed, name_len);\n    param_out->name[name_len] = '\\0';\n    bytes_consumed += name_len;\n\n    param_out->type = (ConfigParamType)stream[bytes_consumed++];\n    if (bytes_consumed > stream_len) {\n        return -1;\n    }\n\n    switch (param_out->type) {\n        case PARAM_TYPE_UINT8:\n            if (bytes_consumed + sizeof(uint8_t) > stream_len) return -1;\n            param_out->value.u8_val = stream[bytes_consumed];\n            param_out->value_len = sizeof(uint8_t);\n            bytes_consumed += sizeof(uint8_t);\n            break;\n        case PARAM_TYPE_UINT16:\n            if (bytes_consumed + sizeof(uint16_t) > stream_len) return -1;\n            param_out->value.u16_val = (uint16_t)((stream[bytes_consumed] << 8) | stream[bytes_consumed+1]);\n            param_out->value_len = sizeof(uint16_t);\n            bytes_consumed += sizeof(uint16_t);\n            break;\n        case PARAM_TYPE_UINT32:\n            if (bytes_consumed + sizeof(uint32_t) > stream_len) return -1;\n            param_out->value.u32_val = (uint32_t)((stream[bytes_consumed] << 24) | (stream[bytes_consumed+1] << 16) |\n                                                   (stream[bytes_consumed+2] << 8) | stream[bytes_consumed+3]);\n            param_out->value_len = sizeof(uint32_t);\n            bytes_consumed += sizeof(uint32_t);\n            break;\n        case PARAM_TYPE_BOOL:\n            if (bytes_consumed + sizeof(bool) > stream_len) return -1;\n            param_out->value.bool_val = (bool)stream[bytes_consumed];\n            param_out->value_len = sizeof(bool);\n            bytes_consumed += sizeof(bool);\n            break;\n        case PARAM_TYPE_STRING:\n            if (bytes_consumed >= stream_len) return -1;\n            uint8_t str_actual_len = stream[bytes_consumed++];\n            if (str_actual_len >= CONFIG_VALUE_MAX_LEN || bytes_consumed + str_actual_len > stream_len) {\n                return -1;\n            }\n            memcpy(param_out->value.str_val, stream + bytes_consumed, str_actual_len);\n            param_out->value.str_val[str_actual_len] = '\\0';\n            param_out->value_len = str_actual_len;\n            bytes_consumed += str_actual_len;\n            break;\n        default:\n            return -1;\n    }\n\n    return bytes_consumed;\n}\n\nint loadVehicleConfiguration(const uint8_t* config_stream, uint16_t stream_total_len) {\n    if (config_stream == NULL || stream_total_len == 0) {\n        return -1;\n    }\n\n    uint16_t current_stream_pos = 0;\n    g_numConfigParams = 0;\n\n    while (current_stream_pos < stream_total_len && g_numConfigParams < MAX_CONFIG_PARAMS) {\n        int bytes_parsed = parseConfigurationParameter(\n                                config_stream + current_stream_pos,\n                                stream_total_len - current_stream_pos,\n                                &g_vehicleConfig[g_numConfigParams]\n                           );\n\n        if (bytes_parsed <= 0) {\n            return -1;\n        }\n        current_stream_pos += bytes_parsed;\n        g_numConfigParams++;\n    }\n\n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRY_PAYLOAD_SIZE 62\n#define LOG_ACCUMULATOR_BUFFER_SIZE 256\n\ntypedef enum {\n    LOG_TYPE_GENERIC_INFO = 0x01,\n    LOG_TYPE_CRITICAL_FAULT = 0x02,\n    LOG_TYPE_SENSOR_DATA = 0x03,\n    LOG_TYPE_TELEMETRY_EVENT = 0x04\n} LogEntryType;\n\ntypedef struct {\n    uint8_t type;\n    uint8_t data_length;\n    uint8_t data[MAX_LOG_ENTRY_PAYLOAD_SIZE];\n} InternalLogEntry;\n\nstatic uint8_t g_logAccumulatorBuffer[LOG_ACCUMULATOR_BUFFER_SIZE];\nstatic uint16_t g_logAccumulatorCurrentPos = 0;\n\ntypedef struct {\n    const uint8_t* stream_ptr;\n    uint16_t stream_total_len;\n    uint16_t current_stream_offset;\n} DataStreamReaderContext;\n\nint processIncomingLogEntry(DataStreamReaderContext* reader_ctx) {\n    if (reader_ctx == NULL || reader_ctx->stream_ptr == NULL) {\n        return -1;\n    }\n\n    if (reader_ctx->current_stream_offset + 2 > reader_ctx->stream_total_len) {\n        return -1;\n    }\n\n    uint8_t log_type = reader_ctx->stream_ptr[reader_ctx->current_stream_offset];\n    uint8_t payload_len_from_stream = reader_ctx->stream_ptr[reader_ctx->current_stream_offset + 1];\n\n    if (reader_ctx->current_stream_offset + 2 + payload_len_from_stream > reader_ctx->stream_total_len) {\n        return -1;\n    }\n\n    InternalLogEntry temp_log_entry;\n    temp_log_entry.type = log_type;\n    temp_log_entry.data_length = payload_len_from_stream;\n\n    memcpy(temp_log_entry.data, reader_ctx->stream_ptr + reader_ctx->current_stream_offset + 2, payload_len_from_stream);\n\n    uint16_t total_entry_size_to_accumulate = 2 + payload_len_from_stream;\n\n    if (g_logAccumulatorCurrentPos + total_entry_size_to_accumulate > LOG_ACCUMULATOR_BUFFER_SIZE) {\n        return -1;\n    }\n\n    memcpy(g_logAccumulatorBuffer + g_logAccumulatorCurrentPos, &temp_log_entry, total_entry_size_to_accumulate);\n    g_logAccumulatorCurrentPos += total_entry_size_to_accumulate;\n\n    return total_entry_size_to_accumulate;\n}\n\nint processDiagnosticDataBlock(const uint8_t* diagnostic_data, uint16_t data_block_len) {\n    if (diagnostic_data == NULL || data_block_len < 2) {\n        return -1;\n    }\n\n    DataStreamReaderContext reader_ctx = {\n        .stream_ptr = diagnostic_data,\n        .stream_total_len = data_block_len,\n        .current_stream_offset = 0\n    };\n\n    g_logAccumulatorCurrentPos = 0;\n\n    while (reader_ctx.current_stream_offset < reader_ctx.stream_total_len) {\n        int bytes_consumed = processIncomingLogEntry(&reader_ctx);\n        if (bytes_consumed <= 0) {\n            return -1;\n        }\n        reader_ctx.current_stream_offset += bytes_consumed;\n    }\n\n    return g_logAccumulatorCurrentPos;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRY_PAYLOAD_SIZE 62\n#define LOG_ACCUMULATOR_BUFFER_SIZE 256\n\ntypedef enum {\n    LOG_TYPE_GENERIC_INFO = 0x01,\n    LOG_TYPE_CRITICAL_FAULT = 0x02,\n    LOG_TYPE_SENSOR_DATA = 0x03,\n    LOG_TYPE_TELEMETRY_EVENT = 0x04\n} LogEntryType;\n\ntypedef struct {\n    uint8_t type;\n    uint8_t data_length;\n    uint8_t data[MAX_LOG_ENTRY_PAYLOAD_SIZE];\n} InternalLogEntry;\n\nstatic uint8_t g_logAccumulatorBuffer[LOG_ACCUMULATOR_BUFFER_SIZE];\nstatic uint16_t g_logAccumulatorCurrentPos = 0;\n\ntypedef struct {\n    const uint8_t* stream_ptr;\n    uint16_t stream_total_len;\n    uint16_t current_stream_offset;\n} DataStreamReaderContext;\n\nint processIncomingLogEntry(DataStreamReaderContext* reader_ctx) {\n    if (reader_ctx == NULL || reader_ctx->stream_ptr == NULL) {\n        return -1;\n    }\n\n    if (reader_ctx->current_stream_offset + 2 > reader_ctx->stream_total_len) {\n        return -1;\n    }\n\n    uint8_t log_type = reader_ctx->stream_ptr[reader_ctx->current_stream_offset];\n    uint8_t payload_len_from_stream = reader_ctx->stream_ptr[reader_ctx->current_stream_offset + 1];\n\n    if (reader_ctx->current_stream_offset + 2 + payload_len_from_stream > reader_ctx->stream_total_len) {\n        return -1;\n    }\n\n    InternalLogEntry temp_log_entry;\n    temp_log_entry.type = log_type;\n\n    uint8_t bytes_to_copy = payload_len_from_stream;\n    if (bytes_to_copy > MAX_LOG_ENTRY_PAYLOAD_SIZE) {\n        bytes_to_copy = MAX_LOG_ENTRY_PAYLOAD_SIZE;\n    }\n    \n    temp_log_entry.data_length = bytes_to_copy;\n\n    memcpy(temp_log_entry.data, reader_ctx->stream_ptr + reader_ctx->current_stream_offset + 2, bytes_to_copy);\n\n    uint16_t total_entry_size_consumed_from_stream = 2 + payload_len_from_stream;\n\n    uint16_t total_entry_size_to_store_in_accumulator = 2 + bytes_to_copy;\n\n    if (g_logAccumulatorCurrentPos + total_entry_size_to_store_in_accumulator > LOG_ACCUMULATOR_BUFFER_SIZE) {\n        return -1;\n    }\n\n    memcpy(g_logAccumulatorBuffer + g_logAccumulatorCurrentPos, &temp_log_entry, total_entry_size_to_store_in_accumulator);\n    g_logAccumulatorCurrentPos += total_entry_size_to_store_in_accumulator;\n\n    return total_entry_size_consumed_from_stream;\n}\n\nint processDiagnosticDataBlock(const uint8_t* diagnostic_data, uint16_t data_block_len) {\n    if (diagnostic_data == NULL || data_block_len < 2) {\n        return -1;\n    }\n\n    DataStreamReaderContext reader_ctx = {\n        .stream_ptr = diagnostic_data,\n        .stream_total_len = data_block_len,\n        .current_stream_offset = 0\n    };\n\n    g_logAccumulatorCurrentPos = 0;\n\n    while (reader_ctx.current_stream_offset < reader_ctx.stream_total_len) {\n        int bytes_consumed = processIncomingLogEntry(&reader_ctx);\n        if (bytes_consumed <= 0) {\n            return -1;\n        }\n        reader_ctx.current_stream_offset += bytes_consumed;\n    }\n\n    return g_logAccumulatorCurrentPos;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_PACKET_PAYLOAD_SIZE 500\n#define TELEMETRY_HEADER_SIZE 5\n\n#define TEMP_DISPLAY_BUFFER_CAPACITY 80\n\ntypedef enum {\n    TELEMETRY_TYPE_INVALID = 0x00,\n    TELEMETRY_TYPE_SENSOR_READING = 0x01,\n    TELEMETRY_TYPE_EVENT_LOG = 0x02,\n    TELEMETRY_TYPE_DIAGNOSTIC_FAULT = 0x03\n} TelemetryPacketType;\n\nvoid displayEventDescription(const uint8_t* description_data, uint8_t description_len) {\n    char temp_display_buffer[TEMP_DISPLAY_BUFFER_CAPACITY];\n\n    if (description_data == NULL) {\n        return;\n    }\n\n    memcpy(temp_display_buffer, description_data, description_len);\n\n    if (description_len < TEMP_DISPLAY_BUFFER_CAPACITY) {\n        temp_display_buffer[description_len] = '\\0';\n    } else {\n        temp_display_buffer[TEMP_DISPLAY_BUFFER_CAPACITY - 1] = '\\0';\n    }\n}\n\nint handleIncomingTelemetryFrame(const uint8_t* frame_data, uint16_t frame_len) {\n    if (frame_data == NULL || frame_len < TELEMETRY_HEADER_SIZE) {\n        return -1;\n    }\n\n    uint16_t packet_id = (frame_data[0] << 8) | frame_data[1];\n    uint8_t packet_type = frame_data[2];\n    uint16_t payload_len = (frame_data[3] << 8) | frame_data[4];\n\n    if (TELEMETRY_HEADER_SIZE + payload_len > frame_len) {\n        return -1;\n    }\n\n    if (payload_len > MAX_PACKET_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    const uint8_t* payload_ptr = frame_data + TELEMETRY_HEADER_SIZE;\n\n    switch (packet_type) {\n        case TELEMETRY_TYPE_EVENT_LOG: {\n            uint16_t min_event_payload_size = sizeof(uint32_t) + sizeof(uint16_t) + sizeof(uint8_t);\n            if (payload_len < min_event_payload_size) {\n                return -1;\n            }\n\n            uint32_t timestamp = (payload_ptr[0] << 24) | (payload_ptr[1] << 16) |\n                                 (payload_ptr[2] << 8) | payload_ptr[3];\n            uint16_t event_code = (payload_ptr[4] << 8) | payload_ptr[5];\n            uint8_t description_len = payload_ptr[6];\n\n            if (description_len > (payload_len - min_event_payload_size)) {\n                return -1;\n            }\n\n            const uint8_t* description_ptr = payload_ptr + min_event_payload_size;\n\n            displayEventDescription(description_ptr, description_len);\n            break;\n        }\n        case TELEMETRY_TYPE_SENSOR_READING:\n            break;\n        case TELEMETRY_TYPE_DIAGNOSTIC_FAULT:\n            break;\n        default:\n            return -1;\n    }\n\n    return 0;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_PACKET_PAYLOAD_SIZE 500\n#define TELEMETRY_HEADER_SIZE 5\n\n#define TEMP_DISPLAY_BUFFER_CAPACITY 80\n\ntypedef enum {\n    TELEMETRY_TYPE_INVALID = 0x00,\n    TELEMETRY_TYPE_SENSOR_READING = 0x01,\n    TELEMETRY_TYPE_EVENT_LOG = 0x02,\n    TELEMETRY_TYPE_DIAGNOSTIC_FAULT = 0x03\n} TelemetryPacketType;\n\nvoid displayEventDescription(const uint8_t* description_data, uint8_t description_len) {\n    char temp_display_buffer[TEMP_DISPLAY_BUFFER_CAPACITY];\n\n    if (description_data == NULL) {\n        return;\n    }\n\n    uint8_t bytes_to_copy = description_len;\n    if (bytes_to_copy >= TEMP_DISPLAY_BUFFER_CAPACITY) {\n        bytes_to_copy = TEMP_DISPLAY_BUFFER_CAPACITY - 1;\n    }\n    \n    memcpy(temp_display_buffer, description_data, bytes_to_copy);\n    temp_display_buffer[bytes_to_copy] = '\\0';\n}\n\nint handleIncomingTelemetryFrame(const uint8_t* frame_data, uint16_t frame_len) {\n    if (frame_data == NULL || frame_len < TELEMETRY_HEADER_SIZE) {\n        return -1;\n    }\n\n    uint16_t packet_id = (frame_data[0] << 8) | frame_data[1];\n    uint8_t packet_type = frame_data[2];\n    uint16_t payload_len = (frame_data[3] << 8) | frame_data[4];\n\n    if (TELEMETRY_HEADER_SIZE + payload_len > frame_len) {\n        return -1;\n    }\n\n    if (payload_len > MAX_PACKET_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    const uint8_t* payload_ptr = frame_data + TELEMETRY_HEADER_SIZE;\n\n    switch (packet_type) {\n        case TELEMETRY_TYPE_EVENT_LOG: {\n            uint16_t min_event_payload_size = sizeof(uint32_t) + sizeof(uint16_t) + sizeof(uint8_t);\n            if (payload_len < min_event_payload_size) {\n                return -1;\n            }\n\n            uint32_t timestamp = (payload_ptr[0] << 24) | (payload_ptr[1] << 16) |\n                                 (payload_ptr[2] << 8) | payload_ptr[3];\n            uint16_t event_code = (payload_ptr[4] << 8) | payload_ptr[5];\n            uint8_t description_len = payload_ptr[6];\n\n            if (description_len > (payload_len - min_event_payload_size)) {\n                return -1;\n            }\n\n            const uint8_t* description_ptr = payload_ptr + min_event_payload_size;\n\n            displayEventDescription(description_ptr, description_len);\n            break;\n        }\n        case TELEMETRY_TYPE_SENSOR_READING:\n            break;\n        case TELEMETRY_TYPE_DIAGNOSTIC_FAULT:\n            break;\n        default:\n            return -1;\n    }\n\n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_MSG_SIZE 1024\n#define DIAG_DATA_RECORD_BUF_SIZE 100\n\n#define DIAG_CMD_READ_DATA_BY_ID 0x22\n#define DIAG_CMD_WRITE_DATA_BY_ID 0x2E\n#define DIAG_CMD_ROUTINE_CONTROL 0x31\n\ntypedef struct {\n    uint8_t service_id;\n    uint16_t data_identifier;\n    uint16_t data_offset_in_pdu;\n    uint16_t data_length;\n} DiagServiceRecordHeader;\n\nstatic uint8_t g_currentDiagPDU[MAX_DIAG_MSG_SIZE];\nstatic uint16_t g_currentPDULength = 0;\n\nstatic uint8_t g_dataRecordProcessingBuffer[DIAG_DATA_RECORD_BUF_SIZE];\n\nvoid resetDiagnosticPDU() {\n    memset(g_currentDiagPDU, 0, sizeof(g_currentDiagPDU));\n    g_currentPDULength = 0;\n}\n\nint receiveDiagnosticPDU(const uint8_t* pdu_data, uint16_t pdu_len) {\n    if (pdu_data == NULL || pdu_len == 0 || pdu_len > MAX_DIAG_MSG_SIZE) {\n        return -1;\n    }\n    memcpy(g_currentDiagPDU, pdu_data, pdu_len);\n    g_currentPDULength = pdu_len;\n    return 0;\n}\n\nint processDiagDataRecordPayload(const DiagServiceRecordHeader* record_header) {\n    if (record_header == NULL) {\n        return -1;\n    }\n\n    uint16_t payload_offset = record_header->data_offset_in_pdu;\n    uint16_t payload_len = record_header->data_length;\n\n    if (payload_offset + payload_len > g_currentPDULength) {\n        return -1;\n    }\n\n    const uint8_t* source_ptr = g_currentDiagPDU + payload_offset;\n\n    memcpy(g_dataRecordProcessingBuffer, source_ptr, payload_len);\n\n    if (record_header->service_id == DIAG_CMD_READ_DATA_BY_ID) {\n\n    } else if (record_header->service_id == DIAG_CMD_WRITE_DATA_BY_ID) {\n\n    }\n    \n    return 0;\n}\n\nint handleIncomingDiagnosticMessage(const uint8_t* raw_pdu, uint16_t raw_pdu_len) {\n    if (receiveDiagnosticPDU(raw_pdu, raw_pdu_len) != 0) {\n        return -1;\n    }\n\n    if (raw_pdu_len < sizeof(DiagServiceRecordHeader)) {\n        return -1;\n    }\n\n    DiagServiceRecordHeader parsed_header;\n    memcpy(&parsed_header, g_currentDiagPDU, sizeof(DiagServiceRecordHeader));\n\n    return processDiagDataRecordPayload(&parsed_header);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_MSG_SIZE 1024\n#define DIAG_DATA_RECORD_BUF_SIZE 100\n\n#define DIAG_CMD_READ_DATA_BY_ID 0x22\n#define DIAG_CMD_WRITE_DATA_BY_ID 0x2E\n#define DIAG_CMD_ROUTINE_CONTROL 0x31\n\ntypedef struct {\n    uint8_t service_id;\n    uint16_t data_identifier;\n    uint16_t data_offset_in_pdu;\n    uint16_t data_length;\n} DiagServiceRecordHeader;\n\nstatic uint8_t g_currentDiagPDU[MAX_DIAG_MSG_SIZE];\nstatic uint16_t g_currentPDULength = 0;\n\nstatic uint8_t g_dataRecordProcessingBuffer[DIAG_DATA_RECORD_BUF_SIZE];\n\nvoid resetDiagnosticPDU() {\n    memset(g_currentDiagPDU, 0, sizeof(g_currentDiagPDU));\n    g_currentPDULength = 0;\n}\n\nint receiveDiagnosticPDU(const uint8_t* pdu_data, uint16_t pdu_len) {\n    if (pdu_data == NULL || pdu_len == 0 || pdu_len > MAX_DIAG_MSG_SIZE) {\n        return -1;\n    }\n    memcpy(g_currentDiagPDU, pdu_data, pdu_len);\n    g_currentPDULength = pdu_len;\n    return 0;\n}\n\nint processDiagDataRecordPayload(const DiagServiceRecordHeader* record_header) {\n    if (record_header == NULL) {\n        return -1;\n    }\n\n    uint16_t payload_offset = record_header->data_offset_in_pdu;\n    uint16_t payload_len = record_header->data_length;\n\n    if (payload_offset + payload_len > g_currentPDULength) {\n        return -1;\n    }\n\n    const uint8_t* source_ptr = g_currentDiagPDU + payload_offset;\n\n    uint16_t bytes_to_copy = payload_len;\n    if (bytes_to_copy > DIAG_DATA_RECORD_BUF_SIZE) {\n        bytes_to_copy = DIAG_DATA_RECORD_BUF_SIZE;\n    }\n    \n    memcpy(g_dataRecordProcessingBuffer, source_ptr, bytes_to_copy);\n\n    if (record_header->service_id == DIAG_CMD_READ_DATA_BY_ID) {\n\n    } else if (record_header->service_id == DIAG_CMD_WRITE_DATA_BY_ID) {\n\n    }\n    \n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_FIRMWARE_CHUNK_SIZE 256\n#define FIRMWARE_BLOCK_BUFFER_SIZE 4096\n#define TOTAL_FIRMWARE_IMAGE_SIZE 1048576\n\ntypedef struct {\n    uint32_t address_offset;\n    uint16_t data_length;\n    uint8_t  data[MAX_FIRMWARE_CHUNK_SIZE];\n} FirmwarePacket;\n\ntypedef struct {\n    uint32_t current_block_address;\n    uint8_t  firmware_block_buffer[FIRMWARE_BLOCK_BUFFER_SIZE];\n    uint32_t bytes_in_current_block;\n    bool     update_in_progress;\n} FirmwareUpdateContext;\n\nstatic FirmwareUpdateContext g_fwUpdateContext = {0};\n\nvoid initFirmwareUpdater() {\n    memset(&g_fwUpdateContext, 0, sizeof(FirmwareUpdateContext));\n    g_fwUpdateContext.update_in_progress = false;\n}\n\nint handleFirmwarePacket(const FirmwarePacket* packet) {\n    if (packet == NULL || packet->data_length == 0 || packet->data_length > MAX_FIRMWARE_CHUNK_SIZE) {\n        return -1;\n    }\n\n    if (!g_fwUpdateContext.update_in_progress) {\n        return -1;\n    }\n\n    uint32_t global_target_offset = packet->address_offset;\n    uint16_t chunk_len = packet->data_length;\n\n    if (global_target_offset + chunk_len > TOTAL_FIRMWARE_IMAGE_SIZE) {\n        return -2;\n    }\n\n    uint32_t packet_block_base_address = global_target_offset / FIRMWARE_BLOCK_BUFFER_SIZE * FIRMWARE_BLOCK_BUFFER_SIZE;\n    uint32_t offset_within_block = global_target_offset % FIRMWARE_BLOCK_BUFFER_SIZE;\n\n    if (g_fwUpdateContext.current_block_address != packet_block_base_address) {\n        memset(g_fwUpdateContext.firmware_block_buffer, 0, FIRMWARE_BLOCK_BUFFER_SIZE);\n        g_fwUpdateContext.bytes_in_current_block = 0;\n        g_fwUpdateContext.current_block_address = packet_block_base_address;\n    }\n\n    memcpy(g_fwUpdateContext.firmware_block_buffer + offset_within_block, packet->data, chunk_len);\n\n    if (offset_within_block + chunk_len > g_fwUpdateContext.bytes_in_current_block) {\n        g_fwUpdateContext.bytes_in_current_block = offset_within_block + chunk_len;\n    }\n\n    return 0;\n}\n\nvoid startFirmwareUpdate() {\n    g_fwUpdateContext.update_in_progress = true;\n    g_fwUpdateContext.current_block_address = 0;\n    g_fwUpdateContext.bytes_in_current_block = 0;\n    memset(g_fwUpdateContext.firmware_block_buffer, 0, FIRMWARE_BLOCK_BUFFER_SIZE);\n}\n\nvoid endFirmwareUpdate() {\n    g_fwUpdateContext.update_in_progress = false;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_FIRMWARE_CHUNK_SIZE 256\n#define FIRMWARE_BLOCK_BUFFER_SIZE 4096\n#define TOTAL_FIRMWARE_IMAGE_SIZE 1048576\n\ntypedef struct {\n    uint32_t address_offset;\n    uint16_t data_length;\n    uint8_t  data[MAX_FIRMWARE_CHUNK_SIZE];\n} FirmwarePacket;\n\ntypedef struct {\n    uint32_t current_block_address;\n    uint8_t  firmware_block_buffer[FIRMWARE_BLOCK_BUFFER_SIZE];\n    uint32_t bytes_in_current_block;\n    bool     update_in_progress;\n} FirmwareUpdateContext;\n\nstatic FirmwareUpdateContext g_fwUpdateContext = {0};\n\nvoid initFirmwareUpdater() {\n    memset(&g_fwUpdateContext, 0, sizeof(FirmwareUpdateContext));\n    g_fwUpdateContext.update_in_progress = false;\n}\n\nint handleFirmwarePacket(const FirmwarePacket* packet) {\n    if (packet == NULL || packet->data_length == 0 || packet->data_length > MAX_FIRMWARE_CHUNK_SIZE) {\n        return -1;\n    }\n\n    if (!g_fwUpdateContext.update_in_progress) {\n        return -1;\n    }\n\n    uint32_t global_target_offset = packet->address_offset;\n    uint16_t chunk_len = packet->data_length;\n\n    if (global_target_offset + chunk_len > TOTAL_FIRMWARE_IMAGE_SIZE) {\n        return -2;\n    }\n\n    uint32_t packet_block_base_address = global_target_offset / FIRMWARE_BLOCK_BUFFER_SIZE * FIRMWARE_BLOCK_BUFFER_SIZE;\n    uint32_t offset_within_block = global_target_offset % FIRMWARE_BLOCK_BUFFER_SIZE;\n\n    if (g_fwUpdateContext.current_block_address != packet_block_base_address) {\n        memset(g_fwUpdateContext.firmware_block_buffer, 0, FIRMWARE_BLOCK_BUFFER_SIZE);\n        g_fwUpdateContext.bytes_in_current_block = 0;\n        g_fwUpdateContext.current_block_address = packet_block_base_address;\n    }\n\n    if (offset_within_block + chunk_len > FIRMWARE_BLOCK_BUFFER_SIZE) {\n        return -3;\n    }\n\n    memcpy(g_fwUpdateContext.firmware_block_buffer + offset_within_block, packet->data, chunk_len);\n\n    if (offset_within_block + chunk_len > g_fwUpdateContext.bytes_in_current_block) {\n        g_fwUpdateContext.bytes_in_current_block = offset_within_block + chunk_len;\n    }\n\n    return 0;\n}\n\nvoid startFirmwareUpdate() {\n    g_fwUpdateContext.update_in_progress = true;\n    g_fwUpdateContext.current_block_address = 0;\n    g_fwUpdateContext.bytes_in_current_block = 0;\n    memset(g_fwUpdateContext.firmware_block_buffer, 0, FIRMWARE_BLOCK_BUFFER_SIZE);\n}\n\nvoid endFirmwareUpdate() {\n    g_fwUpdateContext.update_in_progress = false;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAG_MESSAGE_MAX_SIZE 1024\n#define MAX_RECORD_PAYLOAD_SIZE 128\n#define TEMP_PROCESSING_BUFFER_SIZE 64\n\ntypedef struct {\n    uint16_t message_id;\n    uint16_t total_payload_len;\n} DiagnosticMessageHeader;\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_len;\n} DiagnosticRecordMinimalHeader;\n\nint processDiagnosticMessage(const uint8_t* msg_buffer, uint16_t msg_len) {\n    if (msg_buffer == NULL || msg_len < sizeof(DiagnosticMessageHeader)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n    \n    uint16_t message_id = (msg_buffer[0] << 8) | msg_buffer[1];\n    current_offset += sizeof(uint16_t);\n\n    uint16_t total_payload_len = (msg_buffer[current_offset] << 8) | msg_buffer[current_offset+1];\n    current_offset += sizeof(uint16_t);\n\n    if (current_offset + total_payload_len > msg_len) {\n        return -2;\n    }\n\n    uint16_t payload_bytes_processed = 0;\n    while (payload_bytes_processed < total_payload_len) {\n        if (payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader) > total_payload_len) {\n            return -3;\n        }\n\n        const DiagnosticRecordMinimalHeader* record_header = \n            (const DiagnosticRecordMinimalHeader*)(msg_buffer + current_offset + payload_bytes_processed);\n        \n        uint8_t record_type = record_header->record_type;\n        uint8_t record_data_len = record_header->record_len; \n\n        if (record_data_len > MAX_RECORD_PAYLOAD_SIZE ||\n            payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader) + record_data_len > total_payload_len) {\n            return -4;\n        }\n\n        const uint8_t* record_data_ptr = msg_buffer + current_offset + payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader);\n\n        if (record_type == 0x05) {\n            char temp_processing_buffer[TEMP_PROCESSING_BUFFER_SIZE];\n\n            memcpy(temp_processing_buffer, record_data_ptr, record_data_len);\n\n            if (record_data_len < TEMP_PROCESSING_BUFFER_SIZE) {\n                temp_processing_buffer[record_data_len] = '\\0';\n            } else {\n                temp_processing_buffer[TEMP_PROCESSING_BUFFER_SIZE - 1] = '\\0';\n            }\n        }\n\n        payload_bytes_processed += sizeof(DiagnosticRecordMinimalHeader) + record_data_len;\n    }\n\n    return 0;\n}\n\nvoid simulateIncomingDiagnosticFrame(const uint8_t* data, uint16_t length) {\n    processDiagnosticMessage(data, length);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAG_MESSAGE_MAX_SIZE 1024\n#define MAX_RECORD_PAYLOAD_SIZE 128\n#define TEMP_PROCESSING_BUFFER_SIZE 64\n\ntypedef struct {\n    uint16_t message_id;\n    uint16_t total_payload_len;\n} DiagnosticMessageHeader;\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_len;\n} DiagnosticRecordMinimalHeader;\n\nint processDiagnosticMessage(const uint8_t* msg_buffer, uint16_t msg_len) {\n    if (msg_buffer == NULL || msg_len < sizeof(DiagnosticMessageHeader)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n    \n    uint16_t message_id = (msg_buffer[0] << 8) | msg_buffer[1];\n    current_offset += sizeof(uint16_t);\n\n    uint16_t total_payload_len = (msg_buffer[current_offset] << 8) | msg_buffer[current_offset+1];\n    current_offset += sizeof(uint16_t);\n\n    if (current_offset + total_payload_len > msg_len) {\n        return -2;\n    }\n\n    uint16_t payload_bytes_processed = 0;\n    while (payload_bytes_processed < total_payload_len) {\n        if (payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader) > total_payload_len) {\n            return -3;\n        }\n\n        const DiagnosticRecordMinimalHeader* record_header = \n            (const DiagnosticRecordMinimalHeader*)(msg_buffer + current_offset + payload_bytes_processed);\n        \n        uint8_t record_type = record_header->record_type;\n        uint8_t record_data_len = record_header->record_len; \n\n        if (record_data_len > MAX_RECORD_PAYLOAD_SIZE ||\n            payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader) + record_data_len > total_payload_len) {\n            return -4;\n        }\n\n        const uint8_t* record_data_ptr = msg_buffer + current_offset + payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader);\n\n        if (record_type == 0x05) {\n            char temp_processing_buffer[TEMP_PROCESSING_BUFFER_SIZE];\n            uint8_t bytes_to_copy = record_data_len;\n\n            if (bytes_to_copy >= TEMP_PROCESSING_BUFFER_SIZE) {\n                bytes_to_copy = TEMP_PROCESSING_BUFFER_SIZE - 1;\n            }\n            \n            memcpy(temp_processing_buffer, record_data_ptr, bytes_to_copy);\n            temp_processing_buffer[bytes_to_copy] = '\\0';\n        }\n\n        payload_bytes_processed += sizeof(DiagnosticRecordMinimalHeader) + record_data_len;\n    }\n\n    return 0;\n}\n\nvoid simulateIncomingDiagnosticFrame(const uint8_t* data, uint16_t length) {\n    processDiagnosticMessage(data, length);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_PAYLOAD_SIZE 256\n#define MAX_VEHICLE_FEATURES 32\n\ntypedef struct {\n    uint8_t feature_index; \n    uint8_t new_state;     \n} FeatureUpdateRequest;\n\nstatic uint8_t g_vehicleFeatureStates[MAX_VEHICLE_FEATURES]; \n\nvoid initVehicleFeatures() {\n    memset(g_vehicleFeatureStates, 0, sizeof(g_vehicleFeatureStates));\n}\n\nint processFeatureUpdateCommand(const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len < 1) {\n        return -1; \n    }\n\n    uint8_t num_updates = payload[0];\n    uint16_t expected_len = 1 + (num_updates * sizeof(FeatureUpdateRequest));\n\n    if (expected_len > payload_len) {\n        return -1; \n    }\n\n    for (uint8_t i = 0; i < num_updates; ++i) {\n        uint16_t current_offset = 1 + (i * sizeof(FeatureUpdateRequest));\n        \n        if (current_offset + sizeof(FeatureUpdateRequest) > payload_len) {\n            return -1; \n        }\n\n        FeatureUpdateRequest current_request;\n        current_request.feature_index = payload[current_offset];\n        current_request.new_state = payload[current_offset + 1];\n\n        g_vehicleFeatureStates[current_request.feature_index] = current_request.new_state;\n    }\n\n    return 0; \n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_PAYLOAD_SIZE 256\n#define MAX_VEHICLE_FEATURES 32\n\ntypedef struct {\n    uint8_t feature_index; \n    uint8_t new_state;     \n} FeatureUpdateRequest;\n\nstatic uint8_t g_vehicleFeatureStates[MAX_VEHICLE_FEATURES]; \n\nvoid initVehicleFeatures() {\n    memset(g_vehicleFeatureStates, 0, sizeof(g_vehicleFeatureStates));\n}\n\nint processFeatureUpdateCommand(const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len < 1) {\n        return -1; \n    }\n\n    uint8_t num_updates = payload[0];\n    uint16_t expected_len = 1 + (num_updates * sizeof(FeatureUpdateRequest));\n\n    if (expected_len > payload_len || expected_len > MAX_DIAG_PAYLOAD_SIZE) {\n        return -1; \n    }\n\n    for (uint8_t i = 0; i < num_updates; ++i) {\n        uint16_t current_offset = 1 + (i * sizeof(FeatureUpdateRequest));\n        \n        if (current_offset + sizeof(FeatureUpdateRequest) > payload_len) {\n            return -1; \n        }\n\n        FeatureUpdateRequest current_request;\n        current_request.feature_index = payload[current_offset];\n        current_request.new_state = payload[current_offset + 1];\n\n        if (current_request.feature_index >= MAX_VEHICLE_FEATURES) {\n            return -2; \n        }\n        \n        g_vehicleFeatureStates[current_request.feature_index] = current_request.new_state;\n    }\n\n    return 0; \n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_LOG_BUFFER_SIZE 4096\n#define MAX_DTC_SNAPSHOT_DATA 1024\n\ntypedef struct {\n    uint16_t dtcCode;\n    uint32_t timestamp;\n    uint16_t snapshotDataLen;\n} DiagLogEntryHeader;\n\nstatic uint8_t g_diagLogBuffer[DIAG_LOG_BUFFER_SIZE];\nstatic uint32_t g_logWritePointer = 0;\n\nvoid initDiagnosticLog() {\n    memset(g_diagLogBuffer, 0, DIAG_LOG_BUFFER_SIZE);\n    g_logWritePointer = 0;\n}\n\nint addDiagnosticEventToLog(uint16_t dtc, uint32_t timestamp, const uint8_t* snapshot_data, uint16_t snapshot_data_len) {\n    if (snapshot_data == NULL && snapshot_data_len > 0) {\n        return -1;\n    }\n\n    uint32_t entry_header_size = sizeof(DiagLogEntryHeader);\n    uint32_t entry_total_size = entry_header_size + snapshot_data_len;\n\n    if (g_logWritePointer + entry_total_size > DIAG_LOG_BUFFER_SIZE) {\n        g_logWritePointer = 0;\n    }\n\n    DiagLogEntryHeader header;\n    header.dtcCode = dtc;\n    header.timestamp = timestamp;\n    header.snapshotDataLen = snapshot_data_len;\n\n    memcpy(g_diagLogBuffer + g_logWritePointer, &header, entry_header_size);\n    g_logWritePointer += entry_header_size;\n\n    memcpy(g_diagLogBuffer + g_logWritePointer, snapshot_data, snapshot_data_len);\n    g_logWritePointer += snapshot_data_len;\n\n    return 0;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_LOG_BUFFER_SIZE 4096\n#define MAX_DTC_SNAPSHOT_DATA 1024\n\ntypedef struct {\n    uint16_t dtcCode;\n    uint32_t timestamp;\n    uint16_t snapshotDataLen;\n} DiagLogEntryHeader;\n\nstatic uint8_t g_diagLogBuffer[DIAG_LOG_BUFFER_SIZE];\nstatic uint32_t g_logWritePointer = 0;\n\nvoid initDiagnosticLog() {\n    memset(g_diagLogBuffer, 0, DIAG_LOG_BUFFER_SIZE);\n    g_logWritePointer = 0;\n}\n\nint addDiagnosticEventToLog(uint16_t dtc, uint32_t timestamp, const uint8_t* snapshot_data, uint16_t snapshot_data_len) {\n    if (snapshot_data == NULL && snapshot_data_len > 0) {\n        return -1;\n    }\n\n    if (snapshot_data_len > MAX_DTC_SNAPSHOT_DATA) {\n        return -2;\n    }\n\n    uint32_t entry_header_size = sizeof(DiagLogEntryHeader);\n    uint32_t entry_total_size = entry_header_size + snapshot_data_len;\n\n    if (entry_total_size > DIAG_LOG_BUFFER_SIZE) {\n        return -3;\n    }\n\n    if (g_logWritePointer + entry_total_size > DIAG_LOG_BUFFER_SIZE) {\n        g_logWritePointer = 0;\n    }\n\n    DiagLogEntryHeader header;\n    header.dtcCode = dtc;\n    header.timestamp = timestamp;\n    header.snapshotDataLen = snapshot_data_len;\n\n    memcpy(g_diagLogBuffer + g_logWritePointer, &header, entry_header_size);\n    g_logWritePointer += entry_header_size;\n\n    memcpy(g_diagLogBuffer + g_logWritePointer, snapshot_data, snapshot_data_len);\n    g_logWritePointer += snapshot_data_len;\n\n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 64\n#define MAX_COMMAND_PAYLOAD_SIZE 128\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t parameter_idx;\n    uint8_t data_length;\n    uint8_t data[MAX_COMMAND_PAYLOAD_SIZE - 3];\n} VehicleCommand;\n\nstatic uint8_t g_vehicleConfigArea[VEHICLE_CONFIG_BUFFER_SIZE];\n\nvoid initVehicleConfigArea() {\n    memset(g_vehicleConfigArea, 0x00, VEHICLE_CONFIG_BUFFER_SIZE);\n}\n\n#define CMD_UPDATE_CONFIG_DATA 0x05\n#define CMD_READ_CONFIG_DATA   0x06\n\nint processVehicleCommand(const VehicleCommand* cmd) {\n    if (cmd == NULL) {\n        return -1;\n    }\n\n    if (cmd->command_id == CMD_UPDATE_CONFIG_DATA) {\n        uint8_t start_offset = cmd->parameter_idx;\n        uint8_t data_to_copy = cmd->data_length;\n\n        if (start_offset >= VEHICLE_CONFIG_BUFFER_SIZE) {\n            return -2;\n        }\n\n        if (data_to_copy > (MAX_COMMAND_PAYLOAD_SIZE - (sizeof(cmd->command_id) + sizeof(cmd->parameter_idx) + sizeof(cmd->data_length)))) {\n             return -3;\n        }\n\n        memcpy(g_vehicleConfigArea + start_offset, cmd->data, data_to_copy);\n\n        return 0;\n    } else if (cmd->command_id == CMD_READ_CONFIG_DATA) {\n        return 0;\n    }\n    \n    return -4;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 64\n#define MAX_COMMAND_PAYLOAD_SIZE 128\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t parameter_idx;\n    uint8_t data_length;\n    uint8_t data[MAX_COMMAND_PAYLOAD_SIZE - 3];\n} VehicleCommand;\n\nstatic uint8_t g_vehicleConfigArea[VEHICLE_CONFIG_BUFFER_SIZE];\n\nvoid initVehicleConfigArea() {\n    memset(g_vehicleConfigArea, 0x00, VEHICLE_CONFIG_BUFFER_SIZE);\n}\n\n#define CMD_UPDATE_CONFIG_DATA 0x05\n#define CMD_READ_CONFIG_DATA   0x06\n\nint processVehicleCommand(const VehicleCommand* cmd) {\n    if (cmd == NULL) {\n        return -1;\n    }\n\n    if (cmd->command_id == CMD_UPDATE_CONFIG_DATA) {\n        uint8_t start_offset = cmd->parameter_idx;\n        uint8_t data_to_copy = cmd->data_length;\n\n        if (start_offset >= VEHICLE_CONFIG_BUFFER_SIZE) {\n            return -2;\n        }\n\n        if (data_to_copy > (MAX_COMMAND_PAYLOAD_SIZE - (sizeof(cmd->command_id) + sizeof(cmd->parameter_idx) + sizeof(cmd->data_length)))) {\n             return -3;\n        }\n\n        uint8_t available_space = VEHICLE_CONFIG_BUFFER_SIZE - start_offset;\n        uint8_t actual_bytes_to_copy = data_to_copy;\n\n        if (actual_bytes_to_copy > available_space) {\n            actual_bytes_to_copy = available_space;\n        }\n\n        memcpy(g_vehicleConfigArea + start_offset, cmd->data, actual_bytes_to_copy);\n\n        if (data_to_copy > actual_bytes_to_copy) {\n            return -5;\n        }\n\n        return 0;\n    } else if (cmd->command_id == CMD_READ_CONFIG_DATA) {\n        return 0;\n    }\n    \n    return -4;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define DATA_LOG_BUFFER_SIZE 256\n#define MAX_LOG_ENTRY_PAYLOAD_SIZE 60\n\ntypedef struct {\n    uint8_t  type;\n    uint8_t  payload_len;\n} LogEntryHeader;\n\nstatic uint8_t g_logBuffer[DATA_LOG_BUFFER_SIZE];\nstatic uint16_t g_logBufferWriteHead = 0;\n\nvoid initDataLogger() {\n    memset(g_logBuffer, 0, DATA_LOG_BUFFER_SIZE);\n    g_logBufferWriteHead = 0;\n}\n\nint addLogEntry(uint8_t type, const uint8_t* payload_data, uint8_t payload_len) {\n    if (payload_data == NULL) {\n        return -1;\n    }\n\n    if (payload_len > MAX_LOG_ENTRY_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    uint16_t required_total_entry_size = sizeof(LogEntryHeader) + payload_len;\n\n    if (required_total_entry_size > DATA_LOG_BUFFER_SIZE) {\n        return -3;\n    }\n\n    // Construct the header\n    LogEntryHeader header = { .type = type, .payload_len = payload_len };\n\n    // Write header to current position\n    memcpy(g_logBuffer + g_logBufferWriteHead, &header, sizeof(LogEntryHeader));\n    uint16_t current_entry_payload_offset = g_logBufferWriteHead + sizeof(LogEntryHeader);\n\n    // Write payload data following the header\n    // VULNERABILITY: If current_entry_payload_offset + payload_len extends beyond DATA_LOG_BUFFER_SIZE,\n    // this memcpy will write out-of-bounds, even though the total required_total_entry_size fits\n    // into the conceptual circular buffer space. The single memcpy doesn't handle wrapping.\n    memcpy(g_logBuffer + current_entry_payload_offset, payload_data, payload_len);\n\n    // Update write head for the next entry, correctly handling circular buffer logic\n    g_logBufferWriteHead = (g_logBufferWriteHead + required_total_entry_size) % DATA_LOG_BUFFER_SIZE;\n\n    return 0;\n}\n\n// Dummy function to simulate usage in a larger context (e.g., error handling)\nvoid simulateSensorDTCLog(uint8_t dtc_code, const uint8_t* dtc_data, uint8_t data_len) {\n    // In a real scenario, dtc_data might contain additional diagnostic info\n    // The dtc_code itself could be part of the payload or processed separately.\n    // Here, we just pass the raw data.\n    addLogEntry(dtc_code, dtc_data, data_len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define DATA_LOG_BUFFER_SIZE 256\n#define MAX_LOG_ENTRY_PAYLOAD_SIZE 60\n\ntypedef struct {\n    uint8_t  type;\n    uint8_t  payload_len;\n} LogEntryHeader;\n\nstatic uint8_t g_logBuffer[DATA_LOG_BUFFER_SIZE];\nstatic uint16_t g_logBufferWriteHead = 0;\n\nvoid initDataLogger() {\n    memset(g_logBuffer, 0, DATA_LOG_BUFFER_SIZE);\n    g_logBufferWriteHead = 0;\n}\n\nint addLogEntry(uint8_t type, const uint8_t* payload_data, uint8_t payload_len) {\n    if (payload_data == NULL) {\n        return -1;\n    }\n\n    if (payload_len > MAX_LOG_ENTRY_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    uint16_t required_total_entry_size = sizeof(LogEntryHeader) + payload_len;\n\n    if (required_total_entry_size > DATA_LOG_BUFFER_SIZE) {\n        return -3;\n    }\n    \n    LogEntryHeader header = { .type = type, .payload_len = payload_len };\n\n    uint16_t current_write_pos = g_logBufferWriteHead;\n    uint16_t bytes_to_copy_this_segment;\n\n    // Write Header - handle potential wrap-around\n    bytes_to_copy_this_segment = sizeof(LogEntryHeader);\n    if (current_write_pos + bytes_to_copy_this_segment > DATA_LOG_BUFFER_SIZE) {\n        uint16_t first_part_len = DATA_LOG_BUFFER_SIZE - current_write_pos;\n        memcpy(g_logBuffer + current_write_pos, &header, first_part_len);\n        memcpy(g_logBuffer, (uint8_t*)&header + first_part_len, bytes_to_copy_this_segment - first_part_len);\n    } else {\n        memcpy(g_logBuffer + current_write_pos, &header, bytes_to_copy_this_segment);\n    }\n    current_write_pos = (current_write_pos + bytes_to_copy_this_segment) % DATA_LOG_BUFFER_SIZE;\n\n    // Write Payload - handle potential wrap-around\n    bytes_to_copy_this_segment = payload_len;\n    if (current_write_pos + bytes_to_copy_this_segment > DATA_LOG_BUFFER_SIZE) {\n        uint16_t first_part_len = DATA_LOG_BUFFER_SIZE - current_write_pos;\n        memcpy(g_logBuffer + current_write_pos, payload_data, first_part_len);\n        memcpy(g_logBuffer, payload_data + first_part_len, bytes_to_copy_this_segment - first_part_len);\n    } else {\n        memcpy(g_logBuffer + current_write_pos, payload_data, bytes_to_copy_this_segment);\n    }\n\n    // Update global write head for the next entry\n    g_logBufferWriteHead = (g_logBufferWriteHead + required_total_entry_size) % DATA_LOG_BUFFER_SIZE;\n\n    return 0;\n}\n\n// Dummy function to simulate usage in a larger context (e.g., error handling)\nvoid simulateSensorDTCLog(uint8_t dtc_code, const uint8_t* dtc_data, uint8_t data_len) {\n    addLogEntry(dtc_code, dtc_data, data_len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define CALIBRATION_DATA_SIZE 256\n#define MAX_CAN_DLC 8\n\ntypedef struct {\n    uint8_t  command_id;\n    uint8_t  segment_offset_high;\n    uint8_t  segment_offset_low;\n    uint8_t  segment_length;\n    uint8_t  data[MAX_CAN_DLC - 4];\n} CanCalibrationUpdatePacket;\n\nstatic uint8_t g_calibrationData[CALIBRATION_DATA_SIZE];\n\nvoid initCalibrationSystem() {\n    memset(g_calibrationData, 0xFF, CALIBRATION_DATA_SIZE);\n}\n\nint processCalibrationUpdate(const CanCalibrationUpdatePacket* packet_data, uint8_t actual_can_dlc) {\n    if (packet_data == NULL || actual_can_dlc < 4) {\n        return -1;\n    }\n\n    if (packet_data->command_id != 0x01) {\n        return -2;\n    }\n\n    uint16_t segment_offset = ((uint16_t)packet_data->segment_offset_high << 8) | packet_data->segment_offset_low;\n    uint8_t segment_length = packet_data->segment_length;\n\n    if (segment_length > (actual_can_dlc - 4)) {\n        return -3;\n    }\n\n    if (segment_offset >= CALIBRATION_DATA_SIZE) {\n        return -4;\n    }\n\n    memcpy(g_calibrationData + segment_offset, packet_data->data, segment_length);\n\n    return 0;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define CALIBRATION_DATA_SIZE 256\n#define MAX_CAN_DLC 8\n\ntypedef struct {\n    uint8_t  command_id;\n    uint8_t  segment_offset_high;\n    uint8_t  segment_offset_low;\n    uint8_t  segment_length;\n    uint8_t  data[MAX_CAN_DLC - 4];\n} CanCalibrationUpdatePacket;\n\nstatic uint8_t g_calibrationData[CALIBRATION_DATA_SIZE];\n\nvoid initCalibrationSystem() {\n    memset(g_calibrationData, 0xFF, CALIBRATION_DATA_SIZE);\n}\n\nint processCalibrationUpdate(const CanCalibrationUpdatePacket* packet_data, uint8_t actual_can_dlc) {\n    if (packet_data == NULL || actual_can_dlc < 4) {\n        return -1;\n    }\n\n    if (packet_data->command_id != 0x01) {\n        return -2;\n    }\n\n    uint16_t segment_offset = ((uint16_t)packet_data->segment_offset_high << 8) | packet_data->segment_offset_low;\n    uint8_t segment_length = packet_data->segment_length;\n\n    if (segment_length > (actual_can_dlc - 4)) {\n        return -3;\n    }\n\n    if (segment_offset >= CALIBRATION_DATA_SIZE) {\n        return -4;\n    }\n\n    if (segment_length > (CALIBRATION_DATA_SIZE - segment_offset)) {\n        return -5;\n    }\n\n    memcpy(g_calibrationData + segment_offset, packet_data->data, segment_length);\n\n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_BLOCK_SIZE 512\n\n#define MAX_VEHICLE_NAME_LEN 32\n#define MAX_LICENSE_PLATE_LEN 16\n\n#define CONFIG_ID_VEHICLE_NAME 0x01\n#define CONFIG_ID_LICENSE_PLATE 0x02\n#define CONFIG_ID_SPEED_LIMIT_ENABLED 0x03\n#define CONFIG_ID_MAX_SPEED_VALUE 0x04\n\nstatic char g_vehicleName[MAX_VEHICLE_NAME_LEN + 1];\nstatic char g_licensePlate[MAX_LICENSE_PLATE_LEN + 1];\nstatic uint8_t g_speedLimitEnabled = 0;\nstatic uint16_t g_maxSpeedValue = 0;\n\ntypedef struct {\n    uint8_t param_id;\n    uint8_t param_len;\n} ConfigParamHeader;\n\nvoid resetVehicleConfig() {\n    memset(g_vehicleName, 0, sizeof(g_vehicleName));\n    memset(g_licensePlate, 0, sizeof(g_licensePlate));\n    g_speedLimitEnabled = 0;\n    g_maxSpeedValue = 0;\n    strcpy(g_vehicleName, \"DEFAULT_VEHICLE\");\n    strcpy(g_licensePlate, \"DEFAULT_PLATE\");\n}\n\nint applyVehicleConfiguration(const uint8_t* config_data_block, uint16_t block_len) {\n    if (config_data_block == NULL || block_len == 0 || block_len > MAX_CONFIG_BLOCK_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    while (current_offset < block_len) {\n        if (current_offset + sizeof(ConfigParamHeader) > block_len) {\n            return -2;\n        }\n\n        const ConfigParamHeader* header = (const ConfigParamHeader*)(config_data_block + current_offset);\n        uint8_t param_id = header->param_id;\n        uint8_t param_len = header->param_len;\n\n        if (current_offset + sizeof(ConfigParamHeader) + param_len > block_len) {\n            return -3;\n        }\n\n        const uint8_t* param_value_ptr = config_data_block + current_offset + sizeof(ConfigParamHeader);\n\n        switch (param_id) {\n            case CONFIG_ID_VEHICLE_NAME:\n                memcpy(g_vehicleName, param_value_ptr, param_len);\n                if (param_len < MAX_VEHICLE_NAME_LEN + 1) {\n                    g_vehicleName[param_len] = '\\0';\n                } else {\n                    g_vehicleName[MAX_VEHICLE_NAME_LEN] = '\\0';\n                }\n                break;\n            case CONFIG_ID_LICENSE_PLATE:\n                memcpy(g_licensePlate, param_value_ptr, param_len);\n                if (param_len < MAX_LICENSE_PLATE_LEN + 1) {\n                    g_licensePlate[param_len] = '\\0';\n                } else {\n                    g_licensePlate[MAX_LICENSE_PLATE_LEN] = '\\0';\n                }\n                break;\n            case CONFIG_ID_SPEED_LIMIT_ENABLED:\n                if (param_len == 1) {\n                    g_speedLimitEnabled = param_value_ptr[0];\n                }\n                break;\n            case CONFIG_ID_MAX_SPEED_VALUE:\n                if (param_len == sizeof(uint16_t)) {\n                    g_maxSpeedValue = (param_value_ptr[0] << 8) | param_value_ptr[1];\n                }\n                break;\n            default:\n                break;\n        }\n\n        current_offset += sizeof(ConfigParamHeader) + param_len;\n    }\n\n    return 0;\n}\n\nvoid simulateConfigUpdate(const uint8_t* data, uint16_t len) {\n    resetVehicleConfig();\n    applyVehicleConfiguration(data, len);\n}\n\nconst char* getVehicleName() {\n    return g_vehicleName;\n}\n\nconst char* getLicensePlate() {\n    return g_licensePlate;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_BLOCK_SIZE 512\n\n#define MAX_VEHICLE_NAME_LEN 32\n#define MAX_LICENSE_PLATE_LEN 16\n\n#define CONFIG_ID_VEHICLE_NAME 0x01\n#define CONFIG_ID_LICENSE_PLATE 0x02\n#define CONFIG_ID_SPEED_LIMIT_ENABLED 0x03\n#define CONFIG_ID_MAX_SPEED_VALUE 0x04\n\nstatic char g_vehicleName[MAX_VEHICLE_NAME_LEN + 1];\nstatic char g_licensePlate[MAX_LICENSE_PLATE_LEN + 1];\nstatic uint8_t g_speedLimitEnabled = 0;\nstatic uint16_t g_maxSpeedValue = 0;\n\ntypedef struct {\n    uint8_t param_id;\n    uint8_t param_len;\n} ConfigParamHeader;\n\nvoid resetVehicleConfig() {\n    memset(g_vehicleName, 0, sizeof(g_vehicleName));\n    memset(g_licensePlate, 0, sizeof(g_licensePlate));\n    g_speedLimitEnabled = 0;\n    g_maxSpeedValue = 0;\n    strcpy(g_vehicleName, \"DEFAULT_VEHICLE\");\n    strcpy(g_licensePlate, \"DEFAULT_PLATE\");\n}\n\nint applyVehicleConfiguration(const uint8_t* config_data_block, uint16_t block_len) {\n    if (config_data_block == NULL || block_len == 0 || block_len > MAX_CONFIG_BLOCK_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    while (current_offset < block_len) {\n        if (current_offset + sizeof(ConfigParamHeader) > block_len) {\n            return -2;\n        }\n\n        const ConfigParamHeader* header = (const ConfigParamHeader*)(config_data_block + current_offset);\n        uint8_t param_id = header->param_id;\n        uint8_t param_len = header->param_len;\n\n        if (current_offset + sizeof(ConfigParamHeader) + param_len > block_len) {\n            return -3;\n        }\n\n        const uint8_t* param_value_ptr = config_data_block + current_offset + sizeof(ConfigParamHeader);\n\n        switch (param_id) {\n            case CONFIG_ID_VEHICLE_NAME: {\n                uint8_t bytes_to_copy = param_len;\n                if (bytes_to_copy > MAX_VEHICLE_NAME_LEN) {\n                    bytes_to_copy = MAX_VEHICLE_NAME_LEN;\n                }\n                memcpy(g_vehicleName, param_value_ptr, bytes_to_copy);\n                g_vehicleName[bytes_to_copy] = '\\0';\n                break;\n            }\n            case CONFIG_ID_LICENSE_PLATE: {\n                uint8_t bytes_to_copy = param_len;\n                if (bytes_to_copy > MAX_LICENSE_PLATE_LEN) {\n                    bytes_to_copy = MAX_LICENSE_PLATE_LEN;\n                }\n                memcpy(g_licensePlate, param_value_ptr, bytes_to_copy);\n                g_licensePlate[bytes_to_copy] = '\\0';\n                break;\n            }\n            case CONFIG_ID_SPEED_LIMIT_ENABLED:\n                if (param_len == 1) {\n                    g_speedLimitEnabled = param_value_ptr[0];\n                }\n                break;\n            case CONFIG_ID_MAX_SPEED_VALUE:\n                if (param_len == sizeof(uint16_t)) {\n                    g_maxSpeedValue = (param_value_ptr[0] << 8) | param_value_ptr[1];\n                }\n                break;\n            default:\n                break;\n        }\n\n        current_offset += sizeof(ConfigParamHeader) + param_len;\n    }\n\n    return 0;\n}\n\nvoid simulateConfigUpdate(const uint8_t* data, uint16_t len) {\n    resetVehicleConfig();\n    applyVehicleConfiguration(data, len);\n}\n\nconst char* getVehicleName() {\n    return g_vehicleName;\n}\n\nconst char* getLicensePlate() {\n    return g_licensePlate;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_INCOMING_FAULT_MSG_SIZE 256\n#define MAX_FAULT_DESCRIPTION_LEN 64\n\ntypedef enum {\n    SEVERITY_INFO = 0,\n    SEVERITY_WARNING,\n    SEVERITY_CRITICAL\n} FaultSeverity;\n\ntypedef struct {\n    uint16_t      fault_id;\n    FaultSeverity severity;\n    char          description[MAX_FAULT_DESCRIPTION_LEN];\n} ParsedFaultEntry;\n\nstatic ParsedFaultEntry g_lastFaultEntry;\n\nvoid initFaultEntry() {\n    memset(&g_lastFaultEntry, 0, sizeof(ParsedFaultEntry));\n}\n\nint processFaultMessage(const uint8_t* raw_msg, uint16_t msg_len) {\n    if (raw_msg == NULL || msg_len < (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    if (msg_len > MAX_INCOMING_FAULT_MSG_SIZE) {\n        return -2;\n    }\n\n    uint16_t current_offset = 0;\n\n    g_lastFaultEntry.fault_id = (raw_msg[current_offset] << 8) | raw_msg[current_offset + 1];\n    current_offset += sizeof(uint16_t);\n\n    g_lastFaultEntry.severity = (FaultSeverity)raw_msg[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    uint8_t incoming_description_len = raw_msg[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    if (current_offset + incoming_description_len > msg_len) {\n        return -3;\n    }\n\n    memcpy(g_lastFaultEntry.description, raw_msg + current_offset, incoming_description_len);\n\n    if (incoming_description_len < MAX_FAULT_DESCRIPTION_LEN) {\n        g_lastFaultEntry.description[incoming_description_len] = '\\0';\n    } else {\n        g_lastFaultEntry.description[MAX_FAULT_DESCRIPTION_LEN - 1] = '\\0';\n    }\n\n    return 0;\n}\n\nconst ParsedFaultEntry* getLastFaultEntry() {\n    return &g_lastFaultEntry;\n}\n\nvoid receiveSimulatedFaultData(const uint8_t* data, uint16_t len) {\n    processFaultMessage(data, len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_INCOMING_FAULT_MSG_SIZE 256\n#define MAX_FAULT_DESCRIPTION_LEN 64\n\ntypedef enum {\n    SEVERITY_INFO = 0,\n    SEVERITY_WARNING,\n    SEVERITY_CRITICAL\n} FaultSeverity;\n\ntypedef struct {\n    uint16_t      fault_id;\n    FaultSeverity severity;\n    char          description[MAX_FAULT_DESCRIPTION_LEN];\n} ParsedFaultEntry;\n\nstatic ParsedFaultEntry g_lastFaultEntry;\n\nvoid initFaultEntry() {\n    memset(&g_lastFaultEntry, 0, sizeof(ParsedFaultEntry));\n}\n\nint processFaultMessage(const uint8_t* raw_msg, uint16_t msg_len) {\n    if (raw_msg == NULL || msg_len < (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    if (msg_len > MAX_INCOMING_FAULT_MSG_SIZE) {\n        return -2;\n    }\n\n    uint16_t current_offset = 0;\n\n    g_lastFaultEntry.fault_id = (raw_msg[current_offset] << 8) | raw_msg[current_offset + 1];\n    current_offset += sizeof(uint16_t);\n\n    g_lastFaultEntry.severity = (FaultSeverity)raw_msg[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    uint8_t incoming_description_len = raw_msg[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    if (current_offset + incoming_description_len > msg_len) {\n        return -3;\n    }\n\n    uint8_t bytes_to_copy = incoming_description_len;\n    if (bytes_to_copy >= MAX_FAULT_DESCRIPTION_LEN) {\n        bytes_to_copy = MAX_FAULT_DESCRIPTION_LEN - 1;\n    }\n    \n    memcpy(g_lastFaultEntry.description, raw_msg + current_offset, bytes_to_copy);\n    g_lastFaultEntry.description[bytes_to_copy] = '\\0';\n\n    return 0;\n}\n\nconst ParsedFaultEntry* getLastFaultEntry() {\n    return &g_lastFaultEntry;\n}\n\nvoid receiveSimulatedFaultData(const uint8_t* data, uint16_t len) {\n    processFaultMessage(data, len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_EVENT_BUFFER_SIZE 512\n#define MAX_EVENT_DESCRIPTION_LEN 100\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp;\n    uint8_t  severity;\n    uint8_t  description_len; \n} DiagnosticEventHeader;\n\nstatic uint8_t g_eventRecordBuffer[DIAG_EVENT_BUFFER_SIZE];\nstatic uint16_t g_bufferWritePointer = 0;\n\nvoid initDiagnosticRecorder() {\n    memset(g_eventRecordBuffer, 0, DIAG_EVENT_BUFFER_SIZE);\n    g_bufferWritePointer = 0;\n}\n\nint recordDiagnosticEvent(uint16_t id, uint32_t ts, uint8_t sev, const char* desc, uint8_t desc_len) {\n    uint16_t fixed_header_size = sizeof(DiagnosticEventHeader);\n    uint16_t total_event_size_to_write = fixed_header_size + desc_len;\n\n    if (total_event_size_to_write > DIAG_EVENT_BUFFER_SIZE) {\n        return -1;\n    }\n\n    uint16_t write_start_pos = g_bufferWritePointer;\n    if (write_start_pos + total_event_size_to_write > DIAG_EVENT_BUFFER_SIZE) {\n        write_start_pos = 0;\n    }\n\n    uint8_t* current_write_ptr = g_eventRecordBuffer + write_start_pos;\n\n    *(uint16_t*)current_write_ptr = id;\n    current_write_ptr += sizeof(uint16_t);\n    *(uint32_t*)current_write_ptr = ts;\n    current_write_ptr += sizeof(uint32_t);\n    *current_write_ptr = sev;\n    current_write_ptr += sizeof(uint8_t);\n    *current_write_ptr = desc_len; \n    current_write_ptr += sizeof(uint8_t);\n\n    memcpy(current_write_ptr, desc, desc_len);\n\n    g_bufferWritePointer = (write_start_pos + total_event_size_to_write) % DIAG_EVENT_BUFFER_SIZE;\n\n    return 0;\n}\n\nvoid simulateIncomingEvent(uint16_t id, uint32_t ts, uint8_t sev, const char* desc, uint8_t desc_len) {\n    recordDiagnosticEvent(id, ts, sev, desc, desc_len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_EVENT_BUFFER_SIZE 512\n#define MAX_EVENT_DESCRIPTION_LEN 100\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp;\n    uint8_t  severity;\n    uint8_t  description_len; \n} DiagnosticEventHeader;\n\nstatic uint8_t g_eventRecordBuffer[DIAG_EVENT_BUFFER_SIZE];\nstatic uint16_t g_bufferWritePointer = 0;\n\nvoid initDiagnosticRecorder() {\n    memset(g_eventRecordBuffer, 0, DIAG_EVENT_BUFFER_SIZE);\n    g_bufferWritePointer = 0;\n}\n\nint recordDiagnosticEvent(uint16_t id, uint32_t ts, uint8_t sev, const char* desc, uint8_t desc_len) {\n    uint16_t fixed_header_size = sizeof(DiagnosticEventHeader);\n    \n    uint8_t actual_desc_bytes_to_copy = desc_len;\n    if (actual_desc_bytes_to_copy > MAX_EVENT_DESCRIPTION_LEN) {\n        actual_desc_bytes_to_copy = MAX_EVENT_DESCRIPTION_LEN;\n    }\n\n    uint16_t total_event_size_to_write = fixed_header_size + actual_desc_bytes_to_copy;\n\n    if (total_event_size_to_write > DIAG_EVENT_BUFFER_SIZE) {\n        return -1;\n    }\n\n    uint16_t write_start_pos = g_bufferWritePointer;\n    if (write_start_pos + total_event_size_to_write > DIAG_EVENT_BUFFER_SIZE) {\n        write_start_pos = 0;\n    }\n\n    uint8_t* current_write_ptr = g_eventRecordBuffer + write_start_pos;\n\n    *(uint16_t*)current_write_ptr = id;\n    current_write_ptr += sizeof(uint16_t);\n    *(uint32_t*)current_write_ptr = ts;\n    current_write_ptr += sizeof(uint32_t);\n    *current_write_ptr = sev;\n    current_write_ptr += sizeof(uint8_t);\n    *current_write_ptr = actual_desc_bytes_to_copy; \n    current_write_ptr += sizeof(uint8_t);\n\n    memcpy(current_write_ptr, desc, actual_desc_bytes_to_copy);\n\n    g_bufferWritePointer = (write_start_pos + total_event_size_to_write) % DIAG_EVENT_BUFFER_SIZE;\n\n    return 0;\n}\n\nvoid simulateIncomingEvent(uint16_t id, uint32_t ts, uint8_t sev, const char* desc, uint8_t desc_len) {\n    recordDiagnosticEvent(id, ts, sev, desc, desc_len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define OTA_FIRMWARE_STAGING_BUFFER_SIZE 4096\n#define MAX_FRAGMENT_PAYLOAD_SIZE 64\n\nstatic uint8_t g_firmwareStagingBuffer[OTA_FIRMWARE_STAGING_BUFFER_SIZE];\nstatic uint32_t g_totalFirmwareSize = 0;\nstatic uint32_t g_bytesReceived = 0;\n\ntypedef struct {\n    uint16_t fragment_offset;\n    uint8_t  fragment_length;\n    uint8_t  data[MAX_FRAGMENT_PAYLOAD_SIZE];\n} OtaFragmentPacket;\n\nvoid initOtaStaging() {\n    memset(g_firmwareStagingBuffer, 0, OTA_FIRMWARE_STAGING_BUFFER_SIZE);\n    g_totalFirmwareSize = 0;\n    g_bytesReceived = 0;\n}\n\nvoid setExpectedFirmwareSize(uint32_t total_size) {\n    if (total_size > OTA_FIRMWARE_STAGING_BUFFER_SIZE) {\n        g_totalFirmwareSize = OTA_FIRMWARE_STAGING_BUFFER_SIZE; \n    } else {\n        g_totalFirmwareSize = total_size;\n    }\n}\n\nint processFirmwareFragment(const OtaFragmentPacket* fragment_packet) {\n    if (fragment_packet == NULL) {\n        return -1;\n    }\n\n    uint16_t offset = fragment_packet->fragment_offset;\n    uint8_t length = fragment_packet->fragment_length;\n\n    if (length > MAX_FRAGMENT_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    // Vulnerability: The check 'offset >= g_totalFirmwareSize' only verifies the starting\n    // offset against the logical firmware size, which itself is capped at the buffer size.\n    // However, it does not check if 'offset + length' exceeds the actual physical buffer size.\n    // An attacker can craft a packet where 'offset' is just below 'g_totalFirmwareSize'\n    // and 'length' causes the write to go past the end of g_firmwareStagingBuffer.\n    if (offset >= g_totalFirmwareSize) {\n        return -3;\n    }\n\n    memcpy(g_firmwareStagingBuffer + offset, fragment_packet->data, length);\n\n    if (offset + length > g_bytesReceived) {\n        g_bytesReceived = offset + length;\n    }\n\n    return 0;\n}\n\nvoid simulateOtaFragmentReception(const OtaFragmentPacket* packet) {\n    processFirmwareFragment(packet);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define OTA_FIRMWARE_STAGING_BUFFER_SIZE 4096\n#define MAX_FRAGMENT_PAYLOAD_SIZE 64\n\nstatic uint8_t g_firmwareStagingBuffer[OTA_FIRMWARE_STAGING_BUFFER_SIZE];\nstatic uint32_t g_totalFirmwareSize = 0;\nstatic uint32_t g_bytesReceived = 0;\n\ntypedef struct {\n    uint16_t fragment_offset;\n    uint8_t  fragment_length;\n    uint8_t  data[MAX_FRAGMENT_PAYLOAD_SIZE];\n} OtaFragmentPacket;\n\nvoid initOtaStaging() {\n    memset(g_firmwareStagingBuffer, 0, OTA_FIRMWARE_STAGING_BUFFER_SIZE);\n    g_totalFirmwareSize = 0;\n    g_bytesReceived = 0;\n}\n\nvoid setExpectedFirmwareSize(uint32_t total_size) {\n    if (total_size > OTA_FIRMWARE_STAGING_BUFFER_SIZE) {\n        g_totalFirmwareSize = OTA_FIRMWARE_STAGING_BUFFER_SIZE; \n    } else {\n        g_totalFirmwareSize = total_size;\n    }\n}\n\nint processFirmwareFragment(const OtaFragmentPacket* fragment_packet) {\n    if (fragment_packet == NULL) {\n        return -1;\n    }\n\n    uint16_t offset = fragment_packet->fragment_offset;\n    uint8_t length = fragment_packet->fragment_length;\n\n    if (length > MAX_FRAGMENT_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    // Fixed: Added explicit checks to ensure that the entire write operation\n    // (offset + length) remains within the bounds of the physical staging buffer\n    // and also within the expected logical firmware size.\n    if (offset >= OTA_FIRMWARE_STAGING_BUFFER_SIZE || \n        (uint32_t)offset + length > OTA_FIRMWARE_STAGING_BUFFER_SIZE || \n        (uint32_t)offset + length > g_totalFirmwareSize) {\n        return -3;\n    }\n\n    memcpy(g_firmwareStagingBuffer + offset, fragment_packet->data, length);\n\n    if (offset + length > g_bytesReceived) {\n        g_bytesReceived = offset + length;\n    }\n\n    return 0;\n}\n\nvoid simulateOtaFragmentReception(const OtaFragmentPacket* packet) {\n    processFirmwareFragment(packet);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_STORAGE_SIZE 1024\n#define DIAG_RESPONSE_BUFFER_SIZE 256\n\nstatic uint8_t g_vehicleConfig[VEHICLE_CONFIG_STORAGE_SIZE];\n\nvoid initVehicleConfig() {\n    for (int i = 0; i < VEHICLE_CONFIG_STORAGE_SIZE; ++i) {\n        g_vehicleConfig[i] = (uint8_t)(i % 0xFF);\n    }\n}\n\ntypedef struct {\n    uint16_t serviceId;\n    uint16_t configAreaOffset;\n    uint16_t bytesToRead;\n} DiagReadConfigRequest;\n\ntypedef struct {\n    uint16_t serviceIdResponse;\n    uint8_t data[DIAG_RESPONSE_BUFFER_SIZE];\n    uint16_t dataLength;\n} DiagReadConfigResponse;\n\nint handleDiagReadConfigRequest(const DiagReadConfigRequest* request, DiagReadConfigResponse* response) {\n    if (request == NULL || response == NULL) {\n        return -1;\n    }\n\n    if (request->serviceId != 0x22) {\n        return -1;\n    }\n\n    uint16_t offset = request->configAreaOffset;\n    uint16_t length = request->bytesToRead;\n\n    uint16_t total_read_end_idx = offset + length;\n\n    if (total_read_end_idx > VEHICLE_CONFIG_STORAGE_SIZE) {\n        return -2;\n    }\n\n    if (offset >= VEHICLE_CONFIG_STORAGE_SIZE) {\n        return -2;\n    }\n\n    uint16_t bytes_to_copy = length;\n    if (bytes_to_copy > DIAG_RESPONSE_BUFFER_SIZE) {\n        bytes_to_copy = DIAG_RESPONSE_BUFFER_SIZE;\n    }\n\n    memcpy(response->data, g_vehicleConfig + offset, bytes_to_copy);\n\n    response->serviceIdResponse = 0x62;\n    response->dataLength = bytes_to_copy;\n\n    return 0;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_STORAGE_SIZE 1024\n#define DIAG_RESPONSE_BUFFER_SIZE 256\n\nstatic uint8_t g_vehicleConfig[VEHICLE_CONFIG_STORAGE_SIZE];\n\nvoid initVehicleConfig() {\n    for (int i = 0; i < VEHICLE_CONFIG_STORAGE_SIZE; ++i) {\n        g_vehicleConfig[i] = (uint8_t)(i % 0xFF);\n    }\n}\n\ntypedef struct {\n    uint16_t serviceId;\n    uint16_t configAreaOffset;\n    uint16_t bytesToRead;\n} DiagReadConfigRequest;\n\ntypedef struct {\n    uint16_t serviceIdResponse;\n    uint8_t data[DIAG_RESPONSE_BUFFER_SIZE];\n    uint16_t dataLength;\n} DiagReadConfigResponse;\n\nint handleDiagReadConfigRequest(const DiagReadConfigRequest* request, DiagReadConfigResponse* response) {\n    if (request == NULL || response == NULL) {\n        return -1;\n    }\n\n    if (request->serviceId != 0x22) {\n        return -1;\n    }\n\n    uint16_t offset = request->configAreaOffset;\n    uint16_t length = request->bytesToRead;\n\n    if (offset >= VEHICLE_CONFIG_STORAGE_SIZE || (uint32_t)offset + length > VEHICLE_CONFIG_STORAGE_SIZE) {\n        return -2;\n    }\n\n    uint16_t bytes_to_copy = length;\n    if (bytes_to_copy > DIAG_RESPONSE_BUFFER_SIZE) {\n        bytes_to_copy = DIAG_RESPONSE_BUFFER_SIZE;\n    }\n    if (bytes_to_copy > (VEHICLE_CONFIG_STORAGE_SIZE - offset)) {\n        bytes_to_copy = VEHICLE_CONFIG_STORAGE_SIZE - offset;\n    }\n\n    memcpy(response->data, g_vehicleConfig + offset, bytes_to_copy);\n\n    response->serviceIdResponse = 0x62;\n    response->dataLength = bytes_to_copy;\n\n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_REPORT_PAYLOAD_SIZE 128\n#define DIAG_DATA_BUFFER_SIZE 64\n#define MAX_DIAG_DATA_ID_ENTRIES 5\n\ntypedef struct {\n    uint16_t id;\n    uint8_t  data[DIAG_DATA_BUFFER_SIZE];\n    uint8_t  current_len;\n} DiagnosticDataEntry;\n\nstatic DiagnosticDataEntry g_diagDataStore[MAX_DIAG_DATA_ID_ENTRIES];\nstatic uint8_t g_diagDataCount = 0;\n\nvoid initDiagnosticDataStore() {\n    memset(g_diagDataStore, 0, sizeof(g_diagDataStore));\n}\n\nint processDiagnosticReport(uint16_t report_id, const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len == 0 || payload_len > MAX_REPORT_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    if (report_id == 0x10) {\n        if (payload_len < (1 + 2 + 1)) {\n            return -2;\n        }\n\n        uint8_t entry_index = payload[0];\n        uint16_t data_id = (payload[1] << 8) | payload[2];\n        uint8_t data_len = payload[3];\n\n        if (entry_index >= MAX_DIAG_DATA_ID_ENTRIES) {\n            return -3;\n        }\n\n        if (data_len > (payload_len - (1 + 2 + 1))) {\n            return -4;\n        }\n\n        int found_idx = -1;\n        for (int i = 0; i < g_diagDataCount; ++i) {\n            if (g_diagDataStore[i].id == data_id) {\n                found_idx = i;\n                break;\n            }\n        }\n\n        if (found_idx == -1) {\n            if (g_diagDataCount < MAX_DIAG_DATA_ID_ENTRIES) {\n                found_idx = g_diagDataCount++;\n                g_diagDataStore[found_idx].id = data_id;\n            } else {\n                return -5;\n            }\n        }\n\n        memcpy(g_diagDataStore[found_idx].data, payload + (1 + 2 + 1), data_len);\n        g_diagDataStore[found_idx].current_len = data_len;\n\n        return 0;\n\n    } else if (report_id == 0x20) {\n        return 0;\n    }\n\n    return -99;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_REPORT_PAYLOAD_SIZE 128\n#define DIAG_DATA_BUFFER_SIZE 64\n#define MAX_DIAG_DATA_ID_ENTRIES 5\n\ntypedef struct {\n    uint16_t id;\n    uint8_t  data[DIAG_DATA_BUFFER_SIZE];\n    uint8_t  current_len;\n} DiagnosticDataEntry;\n\nstatic DiagnosticDataEntry g_diagDataStore[MAX_DIAG_DATA_ID_ENTRIES];\nstatic uint8_t g_diagDataCount = 0;\n\nvoid initDiagnosticDataStore() {\n    memset(g_diagDataStore, 0, sizeof(g_diagDataStore));\n}\n\nint processDiagnosticReport(uint16_t report_id, const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len == 0 || payload_len > MAX_REPORT_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    if (report_id == 0x10) {\n        if (payload_len < (1 + 2 + 1)) {\n            return -2;\n        }\n\n        uint8_t entry_index = payload[0];\n        uint16_t data_id = (payload[1] << 8) | payload[2];\n        uint8_t data_len = payload[3];\n\n        if (entry_index >= MAX_DIAG_DATA_ID_ENTRIES) {\n            return -3;\n        }\n\n        if (data_len > (payload_len - (1 + 2 + 1))) {\n            return -4;\n        }\n        \n        int found_idx = -1;\n        for (int i = 0; i < g_diagDataCount; ++i) {\n            if (g_diagDataStore[i].id == data_id) {\n                found_idx = i;\n                break;\n            }\n        }\n\n        if (found_idx == -1) {\n            if (g_diagDataCount < MAX_DIAG_DATA_ID_ENTRIES) {\n                found_idx = g_diagDataCount++;\n                g_diagDataStore[found_idx].id = data_id;\n            } else {\n                return -5;\n            }\n        }\n\n        uint8_t bytes_to_copy = data_len;\n        if (bytes_to_copy > DIAG_DATA_BUFFER_SIZE) {\n            bytes_to_copy = DIAG_DATA_BUFFER_SIZE;\n        }\n\n        memcpy(g_diagDataStore[found_idx].data, payload + (1 + 2 + 1), bytes_to_copy);\n        g_diagDataStore[found_idx].current_len = bytes_to_copy;\n\n        if (data_len > DIAG_DATA_BUFFER_SIZE) {\n            return -6;\n        }\n\n        return 0;\n\n    } else if (report_id == 0x20) {\n        return 0;\n    }\n\n    return -99;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define DRIVER_MESSAGE_BUFFER_SIZE 32\n#define PROTOCOL_MAX_MESSAGE_LEN 64\n\nstatic char g_driverWelcomeMessage[DRIVER_MESSAGE_BUFFER_SIZE];\nstatic uint8_t g_messageLength = 0;\n\nvoid initDriverProfile() {\n    memset(g_driverWelcomeMessage, 0, sizeof(g_driverWelcomeMessage));\n    const char* default_msg = \"Hello Driver!\";\n    uint8_t default_len = strlen(default_msg);\n    if (default_len < DRIVER_MESSAGE_BUFFER_SIZE) {\n        strncpy(g_driverWelcomeMessage, default_msg, default_len);\n        g_driverWelcomeMessage[default_len] = '\\0';\n        g_messageLength = default_len;\n    } else {\n        strncpy(g_driverWelcomeMessage, default_msg, DRIVER_MESSAGE_BUFFER_SIZE - 1);\n        g_driverWelcomeMessage[DRIVER_MESSAGE_BUFFER_SIZE - 1] = '\\0';\n        g_messageLength = DRIVER_MESSAGE_BUFFER_SIZE - 1;\n    }\n}\n\nint updateDriverWelcomeMessage(const char* new_message, uint8_t message_len) {\n    if (new_message == NULL) {\n        return -1;\n    }\n\n    if (message_len > PROTOCOL_MAX_MESSAGE_LEN) {\n        return -2;\n    }\n\n    memcpy(g_driverWelcomeMessage, new_message, message_len);\n\n    if (message_len < DRIVER_MESSAGE_BUFFER_SIZE) {\n        g_driverWelcomeMessage[message_len] = '\\0';\n        g_messageLength = message_len;\n    } else {\n        g_driverWelcomeMessage[DRIVER_MESSAGE_BUFFER_SIZE - 1] = '\\0';\n        g_messageLength = DRIVER_MESSAGE_BUFFER_SIZE - 1;\n    }\n\n    return 0;\n}\n\nconst char* getDriverWelcomeMessage() {\n    return g_driverWelcomeMessage;\n}\n\nuint8_t getDriverWelcomeMessageLength() {\n    return g_messageLength;\n}\n\nvoid simulateCanMessage(const char* data, uint8_t len) {\n    updateDriverWelcomeMessage(data, len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define DRIVER_MESSAGE_BUFFER_SIZE 32\n#define PROTOCOL_MAX_MESSAGE_LEN 64\n\nstatic char g_driverWelcomeMessage[DRIVER_MESSAGE_BUFFER_SIZE];\nstatic uint8_t g_messageLength = 0;\n\nvoid initDriverProfile() {\n    memset(g_driverWelcomeMessage, 0, sizeof(g_driverWelcomeMessage));\n    const char* default_msg = \"Hello Driver!\";\n    uint8_t default_len = strlen(default_msg);\n    uint8_t actual_copy_len = default_len;\n    if (actual_copy_len >= DRIVER_MESSAGE_BUFFER_SIZE) {\n        actual_copy_len = DRIVER_MESSAGE_BUFFER_SIZE - 1;\n    }\n    strncpy(g_driverWelcomeMessage, default_msg, actual_copy_len);\n    g_driverWelcomeMessage[actual_copy_len] = '\\0';\n    g_messageLength = actual_copy_len;\n}\n\nint updateDriverWelcomeMessage(const char* new_message, uint8_t message_len) {\n    if (new_message == NULL) {\n        return -1;\n    }\n\n    if (message_len > PROTOCOL_MAX_MESSAGE_LEN) {\n        return -2;\n    }\n\n    uint8_t bytes_to_copy = message_len;\n    if (bytes_to_copy >= DRIVER_MESSAGE_BUFFER_SIZE) {\n        bytes_to_copy = DRIVER_MESSAGE_BUFFER_SIZE - 1;\n    }\n\n    memcpy(g_driverWelcomeMessage, new_message, bytes_to_copy);\n\n    g_driverWelcomeMessage[bytes_to_copy] = '\\0';\n    g_messageLength = bytes_to_copy;\n\n    return 0;\n}\n\nconst char* getDriverWelcomeMessage() {\n    return g_driverWelcomeMessage;\n}\n\nuint8_t getDriverWelcomeMessageLength() {\n    return g_messageLength;\n}\n\nvoid simulateCanMessage(const char* data, uint8_t len) {\n    updateDriverWelcomeMessage(data, len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE 256\n#define MAX_INCOMING_PACKET_SIZE 512\n\nstatic uint8_t g_telemetryStorageBuffer[MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE];\nstatic uint16_t g_currentStorageWriteOffset = 0;\n\nvoid initTelemetryStorage() {\n    memset(g_telemetryStorageBuffer, 0, MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE);\n    g_currentStorageWriteOffset = 0;\n}\n\nint processTelemetryDataPacket(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len == 0 || packet_len > MAX_INCOMING_PACKET_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_packet_read_offset = 0;\n\n    while (current_packet_read_offset < packet_len) {\n        if (current_packet_read_offset + 2 > packet_len) {\n            return -1;\n        }\n\n        uint8_t record_id = packet_data[current_packet_read_offset];\n        uint8_t data_len = packet_data[current_packet_read_offset + 1];\n\n        if (current_packet_read_offset + 2 + data_len > packet_len) {\n            return -1;\n        }\n\n        const uint8_t* record_data_ptr = packet_data + current_packet_read_offset + 2;\n\n        g_telemetryStorageBuffer[g_currentStorageWriteOffset] = record_id;\n        g_currentStorageWriteOffset++;\n\n        g_telemetryStorageBuffer[g_currentStorageWriteOffset] = data_len;\n        g_currentStorageWriteOffset++;\n\n        for (int i = 0; i < data_len; ++i) {\n            g_telemetryStorageBuffer[g_currentStorageWriteOffset + i] = record_data_ptr[i];\n        }\n        g_currentStorageWriteOffset += data_len;\n\n        current_packet_read_offset += 2 + data_len;\n    }\n\n    return 0;\n}\n\nvoid systemReceiveTelemetry(const uint8_t* raw_telemetry_packet, uint16_t packet_size) {\n    if (g_currentStorageWriteOffset == 0) {\n        initTelemetryStorage();\n    }\n    processTelemetryDataPacket(raw_telemetry_packet, packet_size);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE 256\n#define MAX_INCOMING_PACKET_SIZE 512\n\nstatic uint8_t g_telemetryStorageBuffer[MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE];\nstatic uint16_t g_currentStorageWriteOffset = 0;\n\nvoid initTelemetryStorage() {\n    memset(g_telemetryStorageBuffer, 0, MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE);\n    g_currentStorageWriteOffset = 0;\n}\n\nint processTelemetryDataPacket(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len == 0 || packet_len > MAX_INCOMING_PACKET_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_packet_read_offset = 0;\n\n    while (current_packet_read_offset < packet_len) {\n        if (current_packet_read_offset + 2 > packet_len) {\n            return -1;\n        }\n\n        uint8_t record_id = packet_data[current_packet_read_offset];\n        uint8_t data_len = packet_data[current_packet_read_offset + 1];\n\n        if (current_packet_read_offset + 2 + data_len > packet_len) {\n            return -1;\n        }\n\n        uint16_t record_storage_size = 2 + data_len;\n\n        if (g_currentStorageWriteOffset + record_storage_size > MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE) {\n            return -2;\n        }\n\n        const uint8_t* record_data_ptr = packet_data + current_packet_read_offset + 2;\n\n        g_telemetryStorageBuffer[g_currentStorageWriteOffset] = record_id;\n        g_currentStorageWriteOffset++;\n\n        g_telemetryStorageBuffer[g_currentStorageWriteOffset] = data_len;\n        g_currentStorageWriteOffset++;\n\n        for (int i = 0; i < data_len; ++i) {\n            g_telemetryStorageBuffer[g_currentStorageWriteOffset + i] = record_data_ptr[i];\n        }\n        g_currentStorageWriteOffset += data_len;\n\n        current_packet_read_offset += 2 + data_len;\n    }\n\n    return 0;\n}\n\nvoid systemReceiveTelemetry(const uint8_t* raw_telemetry_packet, uint16_t packet_size) {\n    if (g_currentStorageWriteOffset == 0) {\n        initTelemetryStorage();\n    }\n    processTelemetryDataPacket(raw_telemetry_packet, packet_size);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DTC_METADATA_PROTO_MAX 60\n#define MAX_INTERNAL_DTC_METADATA_SIZE 30\n\n#define MAX_LOGGED_DTC_RECORDS 20\n#define DTC_RECORD_FIXED_SIZE (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t))\n#define SINGLE_DTC_RECORD_STORAGE_SIZE (DTC_RECORD_FIXED_SIZE + MAX_INTERNAL_DTC_METADATA_SIZE)\n#define DTC_LOG_BUFFER_TOTAL_SIZE (MAX_LOGGED_DTC_RECORDS * SINGLE_DTC_RECORD_STORAGE_SIZE)\n\ntypedef struct {\n    uint16_t dtc_id;\n    uint8_t status_byte;\n    uint8_t metadata_len;\n    uint8_t metadata[MAX_INTERNAL_DTC_METADATA_SIZE];\n} DTCRecord;\n\nstatic uint8_t g_dtc_log_buffer[DTC_LOG_BUFFER_TOTAL_SIZE];\nstatic uint16_t g_current_log_pos = 0;\n\nvoid initDTCLoggingSystem() {\n    memset(g_dtc_log_buffer, 0, DTC_LOG_BUFFER_TOTAL_SIZE);\n    g_current_log_pos = 0;\n}\n\nint addDTCRecord(uint16_t dtc_code, uint8_t status_byte, const uint8_t* metadata, uint8_t metadata_len) {\n    if (metadata == NULL && metadata_len > 0) {\n        return -1;\n    }\n\n    if (metadata_len > MAX_DTC_METADATA_PROTO_MAX) {\n        return -2;\n    }\n\n    DTCRecord temp_record;\n    temp_record.dtc_id = dtc_code;\n    temp_record.status_byte = status_byte;\n    temp_record.metadata_len = metadata_len;\n\n    memcpy(temp_record.metadata, metadata, metadata_len);\n\n    uint16_t record_effective_size = DTC_RECORD_FIXED_SIZE + metadata_len;\n\n    if (g_current_log_pos + record_effective_size > DTC_LOG_BUFFER_TOTAL_SIZE) {\n        return -3;\n    }\n\n    memcpy(g_dtc_log_buffer + g_current_log_pos, &temp_record, record_effective_size);\n    g_current_log_pos += record_effective_size;\n\n    return 0;\n}\n\nuint16_t getDTCLogCount() {\n    if (SINGLE_DTC_RECORD_STORAGE_SIZE == 0) return 0;\n    return g_current_log_pos / SINGLE_DTC_RECORD_STORAGE_SIZE;\n}\n\nvoid simulateExternalDTCReport(uint16_t dtc, uint8_t status, const uint8_t* data, uint8_t data_len) {\n    addDTCRecord(dtc, status, data, data_len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DTC_METADATA_PROTO_MAX 60\n#define MAX_INTERNAL_DTC_METADATA_SIZE 30\n\n#define MAX_LOGGED_DTC_RECORDS 20\n#define DTC_RECORD_FIXED_SIZE (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t))\n#define SINGLE_DTC_RECORD_STORAGE_SIZE (DTC_RECORD_FIXED_SIZE + MAX_INTERNAL_DTC_METADATA_SIZE)\n#define DTC_LOG_BUFFER_TOTAL_SIZE (MAX_LOGGED_DTC_RECORDS * SINGLE_DTC_RECORD_STORAGE_SIZE)\n\ntypedef struct {\n    uint16_t dtc_id;\n    uint8_t status_byte;\n    uint8_t metadata_len;\n    uint8_t metadata[MAX_INTERNAL_DTC_METADATA_SIZE];\n} DTCRecord;\n\nstatic uint8_t g_dtc_log_buffer[DTC_LOG_BUFFER_TOTAL_SIZE];\nstatic uint16_t g_current_log_pos = 0;\n\nvoid initDTCLoggingSystem() {\n    memset(g_dtc_log_buffer, 0, DTC_LOG_BUFFER_TOTAL_SIZE);\n    g_current_log_pos = 0;\n}\n\nint addDTCRecord(uint16_t dtc_code, uint8_t status_byte, const uint8_t* metadata, uint8_t metadata_len) {\n    if (metadata == NULL && metadata_len > 0) {\n        return -1;\n    }\n\n    if (metadata_len > MAX_DTC_METADATA_PROTO_MAX) {\n        return -2;\n    }\n\n    DTCRecord temp_record;\n    temp_record.dtc_id = dtc_code;\n    temp_record.status_byte = status_byte;\n\n    uint8_t actual_copy_len = metadata_len;\n    if (actual_copy_len > MAX_INTERNAL_DTC_METADATA_SIZE) {\n        actual_copy_len = MAX_INTERNAL_DTC_METADATA_SIZE;\n    }\n    temp_record.metadata_len = actual_copy_len;\n    \n    memcpy(temp_record.metadata, metadata, actual_copy_len);\n\n    uint16_t record_effective_size = DTC_RECORD_FIXED_SIZE + temp_record.metadata_len;\n\n    if (g_current_log_pos + record_effective_size > DTC_LOG_BUFFER_TOTAL_SIZE) {\n        return -3;\n    }\n\n    memcpy(g_dtc_log_buffer + g_current_log_pos, &temp_record, record_effective_size);\n    g_current_log_pos += record_effective_size;\n\n    return 0;\n}\n\nuint16_t getDTCLogCount() {\n    if (SINGLE_DTC_RECORD_STORAGE_SIZE == 0) return 0;\n    return g_current_log_pos / SINGLE_DTC_RECORD_STORAGE_SIZE;\n}\n\nvoid simulateExternalDTCReport(uint16_t dtc, uint8_t status, const uint8_t* data, uint8_t data_len) {\n    addDTCRecord(dtc, status, data, data_len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_PACKET_SIZE 1500\n#define PARAMETER_RECORD_FIXED_HEADER_SIZE (sizeof(uint16_t) + sizeof(uint8_t)) \n\nstatic uint8_t g_vehicleConfigMemory[512];\n\nint processVehicleConfigUpdate(const uint8_t* message_data, uint16_t message_len) {\n    if (message_data == NULL || message_len < sizeof(uint16_t)) {\n        return -1;\n    }\n\n    uint16_t num_params = (message_data[0] << 8) | message_data[1];\n    uint16_t current_read_offset = sizeof(uint16_t);\n\n    uint16_t total_payload_bytes_expected = 0;\n\n    for (uint16_t i = 0; i < num_params; ++i) {\n        if (current_read_offset + PARAMETER_RECORD_FIXED_HEADER_SIZE > message_len) {\n            return -2;\n        }\n\n        uint8_t data_len = message_data[current_read_offset + sizeof(uint16_t)];\n\n        if (current_read_offset + PARAMETER_RECORD_FIXED_HEADER_SIZE + data_len > message_len) {\n            return -3;\n        }\n\n        uint16_t param_record_size = PARAMETER_RECORD_FIXED_HEADER_SIZE + data_len;\n        total_payload_bytes_expected += param_record_size;\n\n        current_read_offset += param_record_size;\n    }\n\n    if (current_read_offset != message_len) {\n        return -4;\n    }\n\n    uint8_t* temp_stage_buffer = (uint8_t*)malloc(total_payload_bytes_expected);\n    if (temp_stage_buffer == NULL) {\n        return -5;\n    }\n\n    memcpy(temp_stage_buffer, message_data + sizeof(uint16_t), message_len - sizeof(uint16_t));\n\n    free(temp_stage_buffer);\n\n    return 0;\n}", "fixed_code": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_PACKET_SIZE 1500\n#define PARAMETER_RECORD_FIXED_HEADER_SIZE (sizeof(uint16_t) + sizeof(uint8_t)) \n#define MAX_TOTAL_CONFIG_PAYLOAD_SIZE (MAX_PACKET_SIZE - sizeof(uint16_t))\n\nstatic uint8_t g_vehicleConfigMemory[512];\n\nint processVehicleConfigUpdate(const uint8_t* message_data, uint16_t message_len) {\n    if (message_data == NULL || message_len < sizeof(uint16_t)) {\n        return -1;\n    }\n\n    uint16_t num_params = (message_data[0] << 8) | message_data[1];\n    uint16_t current_read_offset = sizeof(uint16_t);\n\n    uint32_t total_payload_bytes_expected = 0;\n\n    for (uint16_t i = 0; i < num_params; ++i) {\n        if (current_read_offset + PARAMETER_RECORD_FIXED_HEADER_SIZE > message_len) {\n            return -2;\n        }\n\n        uint8_t data_len = message_data[current_read_offset + sizeof(uint16_t)];\n\n        if (current_read_offset + PARAMETER_RECORD_FIXED_HEADER_SIZE + data_len > message_len) {\n            return -3;\n        }\n\n        uint32_t param_record_size = (uint32_t)PARAMETER_RECORD_FIXED_HEADER_SIZE + data_len;\n        \n        if (total_payload_bytes_expected > (MAX_TOTAL_CONFIG_PAYLOAD_SIZE - param_record_size)) {\n            return -6;\n        }\n        total_payload_bytes_expected += param_record_size;\n\n        current_read_offset += param_record_size;\n    }\n\n    if (current_read_offset != message_len) {\n        return -4;\n    }\n\n    if (total_payload_bytes_expected > MAX_TOTAL_CONFIG_PAYLOAD_SIZE) {\n        return -8;\n    }\n    \n    uint8_t* temp_stage_buffer = (uint8_t*)malloc(total_payload_bytes_expected);\n    if (temp_stage_buffer == NULL) {\n        return -5;\n    }\n\n    memcpy(temp_stage_buffer, message_data + sizeof(uint16_t), total_payload_bytes_expected);\n\n    free(temp_stage_buffer);\n\n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define FIRMWARE_CONFIG_BUFFER_SIZE 256\n#define MAX_INCOMING_PARAM_DATA_SIZE 64\n\nstatic uint8_t g_firmwareConfigData[FIRMWARE_CONFIG_BUFFER_SIZE];\n\nvoid initFirmwareConfig() {\n    memset(g_firmwareConfigData, 0x00, FIRMWARE_CONFIG_BUFFER_SIZE);\n    g_firmwareConfigData[0] = 0xAA;\n    g_firmwareConfigData[1] = 0xBB;\n}\n\nint updateFirmwareConfigSegment(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len < 2) {\n        return -1;\n    }\n\n    uint8_t config_area_offset = packet_data[0];\n    uint8_t data_segment_length = packet_data[1];\n\n    if (2 + data_segment_length > packet_len) {\n        return -2;\n    }\n\n    if (data_segment_length > MAX_INCOMING_PARAM_DATA_SIZE) {\n        return -3;\n    }\n\n    if (config_area_offset >= FIRMWARE_CONFIG_BUFFER_SIZE) {\n        return -4;\n    }\n\n    const uint8_t* actual_data_ptr = packet_data + 2;\n\n    for (uint8_t i = 0; i < data_segment_length; ++i) {\n        g_firmwareConfigData[config_area_offset + i] = actual_data_ptr[i];\n    }\n\n    return 0;\n}\n\nvoid handleFirmwareUpdateMessage(const uint8_t* msg_payload, uint16_t payload_size) {\n    updateFirmwareConfigSegment(msg_payload, payload_size);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define FIRMWARE_CONFIG_BUFFER_SIZE 256\n#define MAX_INCOMING_PARAM_DATA_SIZE 64\n\nstatic uint8_t g_firmwareConfigData[FIRMWARE_CONFIG_BUFFER_SIZE];\n\nvoid initFirmwareConfig() {\n    memset(g_firmwareConfigData, 0x00, FIRMWARE_CONFIG_BUFFER_SIZE);\n    g_firmwareConfigData[0] = 0xAA;\n    g_firmwareConfigData[1] = 0xBB;\n}\n\nint updateFirmwareConfigSegment(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len < 2) {\n        return -1;\n    }\n\n    uint8_t config_area_offset = packet_data[0];\n    uint8_t data_segment_length = packet_data[1];\n\n    if (2 + data_segment_length > packet_len) {\n        return -2;\n    }\n\n    if (data_segment_length > MAX_INCOMING_PARAM_DATA_SIZE) {\n        return -3;\n    }\n\n    if (config_area_offset >= FIRMWARE_CONFIG_BUFFER_SIZE) {\n        return -4;\n    }\n\n    if (config_area_offset + data_segment_length > FIRMWARE_CONFIG_BUFFER_SIZE) {\n        return -5;\n    }\n\n    const uint8_t* actual_data_ptr = packet_data + 2;\n\n    for (uint8_t i = 0; i < data_segment_length; ++i) {\n        g_firmwareConfigData[config_area_offset + i] = actual_data_ptr[i];\n    }\n\n    return 0;\n}\n\nvoid handleFirmwareUpdateMessage(const uint8_t* msg_payload, uint16_t payload_size) {\n    updateFirmwareConfigSegment(msg_payload, payload_size);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define AGGREGATED_DATA_BUFFER_SIZE 256\n#define MAX_INCOMING_PACKET_SIZE 512\n\nstatic uint8_t g_aggregatedDataBuffer[AGGREGATED_DATA_BUFFER_SIZE];\nstatic uint16_t g_currentAggregatedLen = 0;\n\nvoid initDataAggregator() {\n    memset(g_aggregatedDataBuffer, 0, AGGREGATED_DATA_BUFFER_SIZE);\n    g_currentAggregatedLen = 0;\n}\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_length;\n} DataRecordHeader;\n\nint processDiagnosticDataPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len < 1) {\n        return -1;\n    }\n\n    uint16_t current_packet_offset = 0;\n    uint8_t record_count = packet[current_packet_offset++];\n\n    if (record_count == 0) {\n        g_currentAggregatedLen = 0;\n        return 0;\n    }\n    if (current_packet_offset >= packet_len) {\n        return -2;\n    }\n\n    g_currentAggregatedLen = 0;\n\n    for (int i = 0; i < record_count; ++i) {\n        if (current_packet_offset + sizeof(DataRecordHeader) > packet_len) {\n            return -3;\n        }\n\n        DataRecordHeader header;\n        header.record_type = packet[current_packet_offset];\n        current_packet_offset++;\n        header.record_length = packet[current_packet_offset];\n        current_packet_offset++;\n\n        if (current_packet_offset + header.record_length > packet_len) {\n            return -4;\n        }\n\n        for (uint8_t j = 0; j < header.record_length; ++j) {\n            g_aggregatedDataBuffer[g_currentAggregatedLen++] = packet[current_packet_offset++];\n        }\n    }\n\n    return 0;\n}\n\nvoid receiveDataPacket(const uint8_t* data, uint16_t len) {\n    processDiagnosticDataPacket(data, len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define AGGREGATED_DATA_BUFFER_SIZE 256\n#define MAX_INCOMING_PACKET_SIZE 512\n\nstatic uint8_t g_aggregatedDataBuffer[AGGREGATED_DATA_BUFFER_SIZE];\nstatic uint16_t g_currentAggregatedLen = 0;\n\nvoid initDataAggregator() {\n    memset(g_aggregatedDataBuffer, 0, AGGREGATED_DATA_BUFFER_SIZE);\n    g_currentAggregatedLen = 0;\n}\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_length;\n} DataRecordHeader;\n\nint processDiagnosticDataPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len < 1) {\n        return -1;\n    }\n\n    uint16_t current_packet_offset = 0;\n    uint8_t record_count = packet[current_packet_offset++];\n\n    if (record_count == 0) {\n        g_currentAggregatedLen = 0;\n        return 0;\n    }\n    if (current_packet_offset >= packet_len) {\n        return -2;\n    }\n\n    g_currentAggregatedLen = 0;\n\n    for (int i = 0; i < record_count; ++i) {\n        if (current_packet_offset + sizeof(DataRecordHeader) > packet_len) {\n            return -3;\n        }\n\n        DataRecordHeader header;\n        header.record_type = packet[current_packet_offset];\n        current_packet_offset++;\n        header.record_length = packet[current_packet_offset];\n        current_packet_offset++;\n\n        if (current_packet_offset + header.record_length > packet_len) {\n            return -4;\n        }\n\n        uint16_t bytes_to_copy_into_agg_buffer = header.record_length;\n        if (g_currentAggregatedLen + bytes_to_copy_into_agg_buffer > AGGREGATED_DATA_BUFFER_SIZE) {\n            bytes_to_copy_into_agg_buffer = AGGREGATED_DATA_BUFFER_SIZE - g_currentAggregatedLen;\n            if (bytes_to_copy_into_agg_buffer == 0) {\n                current_packet_offset += header.record_length;\n                continue;\n            }\n        }\n        \n        for (uint8_t j = 0; j < bytes_to_copy_into_agg_buffer; ++j) {\n            g_aggregatedDataBuffer[g_currentAggregatedLen++] = packet[current_packet_offset++];\n        }\n\n        current_packet_offset += (header.record_length - bytes_to_copy_into_agg_buffer);\n\n        if (g_currentAggregatedLen == AGGREGATED_DATA_BUFFER_SIZE) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nvoid receiveDataPacket(const uint8_t* data, uint16_t len) {\n    processDiagnosticDataPacket(data, len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define EVENT_LOG_BUFFER_SIZE 256\n#define MAX_SINGLE_EVENT_PAYLOAD_SIZE 64\n\ntypedef struct {\n    uint8_t event_id;\n    uint8_t payload_len;\n} EventLogHeader;\n\nstatic uint8_t g_eventLogBuffer[EVENT_LOG_BUFFER_SIZE];\nstatic uint16_t g_logWritePointer = 0;\n\nvoid initEventLogger() {\n    memset(g_eventLogBuffer, 0, EVENT_LOG_BUFFER_SIZE);\n    g_logWritePointer = 0;\n}\n\nint addEventToLog(uint8_t event_type, const uint8_t* event_data, uint8_t data_len) {\n    if (event_data == NULL) {\n        return -1;\n    }\n\n    if (data_len > MAX_SINGLE_EVENT_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    uint16_t entry_total_size = sizeof(EventLogHeader) + data_len;\n\n    // Vulnerability: The total size of the entry (header + data) is not checked against\n    // the remaining capacity of the global buffer before writing.\n    // An attacker can send a data_len that, while individually small (e.g., < MAX_SINGLE_EVENT_PAYLOAD_SIZE),\n    // causes an out-of-bounds write when combined with a specific g_logWritePointer value.\n    // For example, if g_logWritePointer is 250, and data_len is 8 (entry_total_size = 2+8=10),\n    // the copy will attempt to write up to index 250+2+7 = 259, overflowing the 256-byte buffer.\n\n    g_eventLogBuffer[g_logWritePointer] = event_type;\n    g_eventLogBuffer[g_logWritePointer + 1] = data_len;\n\n    // The loop iterates based on 'data_len' without an explicit bounds check for 'g_eventLogBuffer'\n    // on each iteration, relying only on previous checks that are insufficient.\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_eventLogBuffer[g_logWritePointer + 2 + i] = event_data[i];\n    }\n\n    g_logWritePointer += entry_total_size;\n\n    return 0;\n}\n\nvoid simulateDTCRecording(uint8_t dtc_code, const uint8_t* diagnostic_info, uint8_t info_len) {\n    if (g_logWritePointer == 0) {\n        initEventLogger();\n    }\n    addEventToLog(dtc_code, diagnostic_info, info_len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define EVENT_LOG_BUFFER_SIZE 256\n#define MAX_SINGLE_EVENT_PAYLOAD_SIZE 64\n\ntypedef struct {\n    uint8_t event_id;\n    uint8_t payload_len;\n} EventLogHeader;\n\nstatic uint8_t g_eventLogBuffer[EVENT_LOG_BUFFER_SIZE];\nstatic uint16_t g_logWritePointer = 0;\n\nvoid initEventLogger() {\n    memset(g_eventLogBuffer, 0, EVENT_LOG_BUFFER_SIZE);\n    g_logWritePointer = 0;\n}\n\nint addEventToLog(uint8_t event_type, const uint8_t* event_data, uint8_t data_len) {\n    if (event_data == NULL) {\n        return -1;\n    }\n\n    if (data_len > MAX_SINGLE_EVENT_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    uint16_t entry_total_size = sizeof(EventLogHeader) + data_len;\n\n    // FIX: Ensure the entire new entry (header + data) fits within the buffer.\n    if (g_logWritePointer + entry_total_size > EVENT_LOG_BUFFER_SIZE) {\n        return -3; // Not enough space, prevent overflow\n    }\n\n    g_eventLogBuffer[g_logWritePointer] = event_type;\n    g_eventLogBuffer[g_logWritePointer + 1] = data_len;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        // No further bounds check needed within the loop as the aggregate check above guarantees space.\n        g_eventLogBuffer[g_logWritePointer + 2 + i] = event_data[i];\n    }\n\n    g_logWritePointer += entry_total_size;\n\n    return 0;\n}\n\nvoid simulateDTCRecording(uint8_t dtc_code, const uint8_t* diagnostic_info, uint8_t info_len) {\n    if (g_logWritePointer == 0) {\n        initEventLogger();\n    }\n    addEventToLog(dtc_code, diagnostic_info, info_len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define REASSEMBLY_BUFFER_SIZE 256\n#define MAX_FRAGMENT_PAYLOAD_SIZE 64\n#define FRAGMENT_HEADER_SIZE 6\n\ntypedef struct {\n    uint16_t fragment_id;\n    uint16_t offset;\n    uint16_t length;\n} FragmentHeader;\n\nstatic uint8_t g_reassemblyBuffer[REASSEMBLY_BUFFER_SIZE];\nstatic uint16_t g_reassembledLength = 0;\n\nvoid initReassemblyBuffer() {\n    memset(g_reassemblyBuffer, 0, REASSEMBLY_BUFFER_SIZE);\n    g_reassembledLength = 0;\n}\n\nint processDataFragment(const uint8_t* raw_fragment_data, uint16_t raw_fragment_len) {\n    if (raw_fragment_data == NULL || raw_fragment_len < FRAGMENT_HEADER_SIZE) {\n        return -1;\n    }\n\n    FragmentHeader header;\n    header.fragment_id = (raw_fragment_data[0] << 8) | raw_fragment_data[1];\n    header.offset      = (raw_fragment_data[2] << 8) | raw_fragment_data[3];\n    header.length      = (raw_fragment_data[4] << 8) | raw_fragment_data[5];\n\n    if (FRAGMENT_HEADER_SIZE + header.length > raw_fragment_len) {\n        return -2;\n    }\n\n    if (header.length > MAX_FRAGMENT_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    for (uint16_t i = 0; i < header.length; ++i) {\n        g_reassemblyBuffer[header.offset + i] = raw_fragment_data[FRAGMENT_HEADER_SIZE + i];\n    }\n\n    if (header.offset + header.length > g_reassembledLength) {\n        g_reassembledLength = header.offset + header.length;\n    }\n\n    return 0;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define REASSEMBLY_BUFFER_SIZE 256\n#define MAX_FRAGMENT_PAYLOAD_SIZE 64\n#define FRAGMENT_HEADER_SIZE 6\n\ntypedef struct {\n    uint16_t fragment_id;\n    uint16_t offset;\n    uint16_t length;\n} FragmentHeader;\n\nstatic uint8_t g_reassemblyBuffer[REASSEMBLY_BUFFER_SIZE];\nstatic uint16_t g_reassembledLength = 0;\n\nvoid initReassemblyBuffer() {\n    memset(g_reassemblyBuffer, 0, REASSEMBLY_BUFFER_SIZE);\n    g_reassembledLength = 0;\n}\n\nint processDataFragment(const uint8_t* raw_fragment_data, uint16_t raw_fragment_len) {\n    if (raw_fragment_data == NULL || raw_fragment_len < FRAGMENT_HEADER_SIZE) {\n        return -1;\n    }\n\n    FragmentHeader header;\n    header.fragment_id = (raw_fragment_data[0] << 8) | raw_fragment_data[1];\n    header.offset      = (raw_fragment_data[2] << 8) | raw_fragment_data[3];\n    header.length      = (raw_fragment_data[4] << 8) | raw_fragment_data[5];\n\n    if (FRAGMENT_HEADER_SIZE + header.length > raw_fragment_len) {\n        return -2;\n    }\n\n    if (header.length > MAX_FRAGMENT_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    if (header.offset >= REASSEMBLY_BUFFER_SIZE || (header.length > 0 && header.offset + header.length > REASSEMBLY_BUFFER_SIZE)) {\n        return -4;\n    }\n\n    for (uint16_t i = 0; i < header.length; ++i) {\n        g_reassemblyBuffer[header.offset + i] = raw_fragment_data[FRAGMENT_HEADER_SIZE + i];\n    }\n\n    if (header.offset + header.length > g_reassembledLength) {\n        g_reassembledLength = header.offset + header.length;\n    }\n\n    return 0;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CALIBRATION_BLOCK_SIZE 64\n#define NUM_CALIBRATION_BLOCKS 8\n#define TOTAL_CALIBRATION_SIZE (CALIBRATION_BLOCK_SIZE * NUM_CALIBRATION_BLOCKS)\n\nstatic uint8_t g_calibrationData[TOTAL_CALIBRATION_SIZE];\nstatic bool g_calibrationInitialized = false;\n\nvoid initCalibrationSystem() {\n    memset(g_calibrationData, 0, TOTAL_CALIBRATION_SIZE);\n    g_calibrationInitialized = true;\n}\n\nint processCalibrationFragment(const uint8_t* msg_payload, uint16_t payload_len) {\n    if (!g_calibrationInitialized || msg_payload == NULL || payload_len < 5) {\n        return -1;\n    }\n\n    uint8_t block_idx = msg_payload[0];\n    uint16_t block_offset = (msg_payload[1] << 8) | msg_payload[2];\n    uint16_t data_len = (msg_payload[3] << 8) | msg_payload[4];\n\n    if (payload_len < (5 + data_len)) {\n        return -2;\n    }\n\n    if (block_idx >= NUM_CALIBRATION_BLOCKS) {\n        return -3;\n    }\n    \n    if (block_offset >= CALIBRATION_BLOCK_SIZE) {\n        return -4;\n    }\n\n    const uint8_t* data_payload = msg_payload + 5;\n\n    uint16_t global_start_offset = (uint16_t)block_idx * CALIBRATION_BLOCK_SIZE + block_offset;\n\n    for (uint16_t i = 0; i < data_len; ++i) {\n        g_calibrationData[global_start_offset + i] = data_payload[i];\n    }\n    \n    return 0;\n}\n\nvoid handleCANCalibrationMessage(const uint8_t* can_data, uint16_t can_dlc) {\n    processCalibrationFragment(can_data, can_dlc);\n}\n\nuint8_t getCalibrationByte(uint16_t index) {\n    if (index < TOTAL_CALIBRATION_SIZE) {\n        return g_calibrationData[index];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CALIBRATION_BLOCK_SIZE 64\n#define NUM_CALIBRATION_BLOCKS 8\n#define TOTAL_CALIBRATION_SIZE (CALIBRATION_BLOCK_SIZE * NUM_CALIBRATION_BLOCKS)\n\nstatic uint8_t g_calibrationData[TOTAL_CALIBRATION_SIZE];\nstatic bool g_calibrationInitialized = false;\n\nvoid initCalibrationSystem() {\n    memset(g_calibrationData, 0, TOTAL_CALIBRATION_SIZE);\n    g_calibrationInitialized = true;\n}\n\nint processCalibrationFragment(const uint8_t* msg_payload, uint16_t payload_len) {\n    if (!g_calibrationInitialized || msg_payload == NULL || payload_len < 5) {\n        return -1;\n    }\n\n    uint8_t block_idx = msg_payload[0];\n    uint16_t block_offset = (msg_payload[1] << 8) | msg_payload[2];\n    uint16_t data_len = (msg_payload[3] << 8) | msg_payload[4];\n\n    if (payload_len < (5 + data_len)) {\n        return -2;\n    }\n\n    if (block_idx >= NUM_CALIBRATION_BLOCKS) {\n        return -3;\n    }\n\n    const uint8_t* data_payload = msg_payload + 5;\n\n    uint16_t global_start_offset = (uint16_t)block_idx * CALIBRATION_BLOCK_SIZE + block_offset;\n\n    if (global_start_offset >= TOTAL_CALIBRATION_SIZE || \n        global_start_offset + data_len > TOTAL_CALIBRATION_SIZE) {\n        return -5;\n    }\n\n    for (uint16_t i = 0; i < data_len; ++i) {\n        g_calibrationData[global_start_offset + i] = data_payload[i];\n    }\n    \n    return 0;\n}\n\nvoid handleCANCalibrationMessage(const uint8_t* can_data, uint16_t can_dlc) {\n    processCalibrationFragment(can_data, can_dlc);\n}\n\nuint8_t getCalibrationByte(uint16_t index) {\n    if (index < TOTAL_CALIBRATION_SIZE) {\n        return g_calibrationData[index];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_CAN_FRAME_DATA_LENGTH 8\n#define VEHICLE_STATE_SENSOR_ID 0x01\n#define TIRE_PRESSURE_SENSOR_ID 0x02\n#define FUEL_LEVEL_SENSOR_ID 0x03\n#define VEHICLE_DIAGNOSTIC_DATA_ID 0x04\n\n#define MAX_SENSOR_DATA_PAYLOAD 60 \n\n#define DIAGNOSTIC_STRING_BUFFER_SIZE 30\n\ntypedef struct {\n    uint8_t sensor_id;\n    uint8_t data_length; \n    uint8_t data[MAX_SENSOR_DATA_PAYLOAD]; \n} SensorPacketSegment;\n\nint processSensorTelemetryStream(const uint8_t* msg_buffer, uint16_t msg_len) {\n    if (msg_buffer == NULL || msg_len < (sizeof(uint8_t) * 2)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    while (current_offset < msg_len) {\n        if (current_offset + sizeof(uint8_t) * 2 > msg_len) {\n            return -2;\n        }\n\n        uint8_t sensor_id = msg_buffer[current_offset];\n        uint8_t data_len = msg_buffer[current_offset + 1];\n\n        if (current_offset + sizeof(uint8_t) * 2 + data_len > msg_len) {\n            return -3;\n        }\n        \n        const uint8_t* sensor_data_ptr = msg_buffer + current_offset + sizeof(uint8_t) * 2;\n\n        if (sensor_id == VEHICLE_DIAGNOSTIC_DATA_ID) {\n            char diagnostic_buffer[DIAGNOSTIC_STRING_BUFFER_SIZE];\n            memset(diagnostic_buffer, 0, DIAGNOSTIC_STRING_BUFFER_SIZE); \n\n            for (int i = 0; i < data_len; ++i) {\n                diagnostic_buffer[i] = (char)sensor_data_ptr[i];\n            }\n            diagnostic_buffer[data_len] = '\\0'; \n\n        }\n\n        current_offset += (sizeof(uint8_t) * 2 + data_len);\n    }\n\n    return 0;\n}\n\nvoid handleTelemetryStream(const uint8_t* stream, uint16_t len) {\n    processSensorTelemetryStream(stream, len);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_CAN_FRAME_DATA_LENGTH 8\n#define VEHICLE_STATE_SENSOR_ID 0x01\n#define TIRE_PRESSURE_SENSOR_ID 0x02\n#define FUEL_LEVEL_SENSOR_ID 0x03\n#define VEHICLE_DIAGNOSTIC_DATA_ID 0x04\n\n#define MAX_SENSOR_DATA_PAYLOAD 60 \n\n#define DIAGNOSTIC_STRING_BUFFER_SIZE 30\n\ntypedef struct {\n    uint8_t sensor_id;\n    uint8_t data_length; \n    uint8_t data[MAX_SENSOR_DATA_PAYLOAD]; \n} SensorPacketSegment;\n\nint processSensorTelemetryStream(const uint8_t* msg_buffer, uint16_t msg_len) {\n    if (msg_buffer == NULL || msg_len < (sizeof(uint8_t) * 2)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    while (current_offset < msg_len) {\n        if (current_offset + sizeof(uint8_t) * 2 > msg_len) {\n            return -2;\n        }\n\n        uint8_t sensor_id = msg_buffer[current_offset];\n        uint8_t data_len = msg_buffer[current_offset + 1];\n\n        if (current_offset + sizeof(uint8_t) * 2 + data_len > msg_len) {\n            return -3;\n        }\n        \n        const uint8_t* sensor_data_ptr = msg_buffer + current_offset + sizeof(uint8_t) * 2;\n\n        if (sensor_id == VEHICLE_DIAGNOSTIC_DATA_ID) {\n            char diagnostic_buffer[DIAGNOSTIC_STRING_BUFFER_SIZE];\n            memset(diagnostic_buffer, 0, DIAGNOSTIC_STRING_BUFFER_SIZE); \n\n            uint8_t bytes_to_copy = data_len;\n            if (bytes_to_copy >= DIAGNOSTIC_STRING_BUFFER_SIZE) {\n                bytes_to_copy = DIAGNOSTIC_STRING_BUFFER_SIZE - 1; \n            }\n\n            for (int i = 0; i < bytes_to_copy; ++i) {\n                diagnostic_buffer[i] = (char)sensor_data_ptr[i];\n            }\n            diagnostic_buffer[bytes_to_copy] = '\\0'; \n\n        }\n\n        current_offset += (sizeof(uint8_t) * 2 + data_len);\n    }\n\n    return 0;\n}\n\nvoid handleTelemetryStream(const uint8_t* stream, uint16_t len) {\n    processSensorTelemetryStream(stream, len);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define CRITICAL_CALIBRATION_VALUES_COUNT 10 \n#define CALIBRATION_BUFFER_SIZE (CRITICAL_CALIBRATION_VALUES_COUNT * sizeof(uint16_t))\n\nstatic uint16_t g_criticalCalibrationValues[CRITICAL_CALIBRATION_VALUES_COUNT];\n\nvoid initCalibrationValues() {\n    memset(g_criticalCalibrationValues, 0, CALIBRATION_BUFFER_SIZE);\n    for (uint8_t i = 0; i < CRITICAL_CALIBRATION_VALUES_COUNT; ++i) {\n        g_criticalCalibrationValues[i] = (i + 1) * 100;\n    }\n}\n\ntypedef struct {\n    uint8_t  group_id;\n    uint8_t  item_offset;\n    uint16_t new_value;\n} CalibrationUpdateCommand;\n\nint applyCalibrationUpdate(const CalibrationUpdateCommand* command) {\n    if (command == NULL) {\n        return -1;\n    }\n\n    uint8_t group_id = command->group_id;\n    uint8_t item_offset = command->item_offset;\n    uint16_t new_value = command->new_value;\n\n    uint8_t effective_index_base_8bit;\n\n    switch (group_id) {\n        case 0:\n            effective_index_base_8bit = 0;\n            break;\n        case 1:\n            effective_index_base_8bit = 5;\n            break;\n        case 2:\n            effective_index_base_8bit = 250;\n            break;\n        default:\n            return -2;\n    }\n\n    uint8_t final_index_8bit = effective_index_base_8bit + item_offset;\n\n    if (final_index_8bit >= CRITICAL_CALIBRATION_VALUES_COUNT) {\n        return -3;\n    }\n\n    g_criticalCalibrationValues[final_index_8bit] = new_value;\n\n    return 0;\n}\n\nvoid simulateExternalCalibrationUpdate(uint8_t group, uint8_t offset, uint16_t value) {\n    CalibrationUpdateCommand cmd = { .group_id = group, .item_offset = offset, .new_value = value };\n    applyCalibrationUpdate(&cmd);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define CRITICAL_CALIBRATION_VALUES_COUNT 10 \n#define CALIBRATION_BUFFER_SIZE (CRITICAL_CALIBRATION_VALUES_COUNT * sizeof(uint16_t))\n\nstatic uint16_t g_criticalCalibrationValues[CRITICAL_CALIBRATION_VALUES_COUNT];\n\nvoid initCalibrationValues() {\n    memset(g_criticalCalibrationValues, 0, CALIBRATION_BUFFER_SIZE);\n    for (uint8_t i = 0; i < CRITICAL_CALIBRATION_VALUES_COUNT; ++i) {\n        g_criticalCalibrationValues[i] = (i + 1) * 100;\n    }\n}\n\ntypedef struct {\n    uint8_t  group_id;\n    uint8_t  item_offset;\n    uint16_t new_value;\n} CalibrationUpdateCommand;\n\nint applyCalibrationUpdate(const CalibrationUpdateCommand* command) {\n    if (command == NULL) {\n        return -1;\n    }\n\n    uint8_t group_id = command->group_id;\n    uint8_t item_offset = command->item_offset;\n    uint16_t new_value = command->new_value;\n\n    uint16_t effective_index_base; \n\n    switch (group_id) {\n        case 0:\n            effective_index_base = 0;\n            break;\n        case 1:\n            effective_index_base = 5;\n            break;\n        case 2:\n            effective_index_base = 250;\n            break;\n        default:\n            return -2;\n    }\n\n    uint16_t final_index = effective_index_base + item_offset;\n\n    if (final_index >= CRITICAL_CALIBRATION_VALUES_COUNT) {\n        return -3;\n    }\n\n    g_criticalCalibrationValues[final_index] = new_value;\n\n    return 0;\n}\n\nvoid simulateExternalCalibrationUpdate(uint8_t group, uint8_t offset, uint16_t value) {\n    CalibrationUpdateCommand cmd = { .group_id = group, .item_offset = offset, .new_value = value };\n    applyCalibrationUpdate(&cmd);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n// Define CAN message IDs for specific diagnostic services\n#define CAN_ID_CONFIG_UPDATE_SERVICE 0x18F00100\n#define CAN_ID_STATUS_REQUEST_SERVICE 0x18F00200\n\n// Maximum number of configurable parameters\n#define MAX_CONFIG_PARAMETERS 64\n\n// Structure for a single configurable parameter entry\ntypedef struct {\n    uint8_t id;\n    uint8_t value;\n    uint8_t type; \n} ConfigParameterEntry;\n\n// Main ECU configuration storage\nstatic ConfigParameterEntry ecu_config_store[MAX_CONFIG_PARAMETERS];\n\n// Initializes the ECU configuration store with default values\nvoid init_ecu_config_store() {\n    for (int i = 0; i < MAX_CONFIG_PARAMETERS; ++i) {\n        ecu_config_store[i].id = (uint8_t)i;\n        ecu_config_store[i].value = 0x00;\n        ecu_config_store[i].type = 0x00; \n    }\n}\n\n// Function to process a CAN diagnostic message payload\n// This function assumes the msg_id has already been validated to be a config update service.\n// The payload format for config update: [param_index_byte][param_value_byte]\n// This service allows setting a single parameter at a time.\nint process_config_update_payload(const uint8_t* payload, uint8_t payload_len) {\n    if (payload == NULL || payload_len < 2) {\n        return -1; \n    }\n\n    uint8_t param_idx_received = payload[0]; \n    uint8_t new_param_value = payload[1];\n\n    // The vulnerability: No bounds check on param_idx_received.\n    // An attacker can send param_idx_received >= MAX_CONFIG_PARAMETERS\n    // to write to memory outside ecu_config_store.\n    ecu_config_store[param_idx_received].value = new_param_value;\n\n    return 0; \n}\n\n// Main entry point for processing incoming CAN messages\n// This function would typically be called by a CAN driver interrupt or polling loop.\nint handle_can_diagnostic_message(uint32_t can_id, const uint8_t* data_bytes, uint8_t data_len) {\n    if (data_bytes == NULL || data_len == 0) {\n        return -1; \n    }\n\n    switch (can_id) {\n        case CAN_ID_CONFIG_UPDATE_SERVICE:\n            return process_config_update_payload(data_bytes, data_len);\n        case CAN_ID_STATUS_REQUEST_SERVICE:\n            // Placeholder for status request handling logic\n            return 0;\n        default:\n            return -99; \n    }\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n// Define CAN message IDs for specific diagnostic services\n#define CAN_ID_CONFIG_UPDATE_SERVICE 0x18F00100\n#define CAN_ID_STATUS_REQUEST_SERVICE 0x18F00200\n\n// Maximum number of configurable parameters\n#define MAX_CONFIG_PARAMETERS 64\n\n// Structure for a single configurable parameter entry\ntypedef struct {\n    uint8_t id;\n    uint8_t value;\n    uint8_t type; \n} ConfigParameterEntry;\n\n// Main ECU configuration storage\nstatic ConfigParameterEntry ecu_config_store[MAX_CONFIG_PARAMETERS];\n\n// Initializes the ECU configuration store with default values\nvoid init_ecu_config_store() {\n    for (int i = 0; i < MAX_CONFIG_PARAMETERS; ++i) {\n        ecu_config_store[i].id = (uint8_t)i;\n        ecu_config_store[i].value = 0x00;\n        ecu_config_store[i].type = 0x00; \n    }\n}\n\n// Function to process a CAN diagnostic message payload\n// This function assumes the msg_id has already been validated to be a config update service.\n// The payload format for config update: [param_index_byte][param_value_byte]\n// This service allows setting a single parameter at a time.\nint process_config_update_payload(const uint8_t* payload, uint8_t payload_len) {\n    if (payload == NULL || payload_len < 2) {\n        return -1; \n    }\n\n    uint8_t param_idx_received = payload[0];\n    uint8_t new_param_value = payload[1];\n\n    // The fix: Add a bounds check for param_idx_received\n    if (param_idx_received >= MAX_CONFIG_PARAMETERS) {\n        return -2; \n    }\n\n    ecu_config_store[param_idx_received].value = new_param_value;\n\n    return 0; \n}\n\n// Main entry point for processing incoming CAN messages\n// This function would typically be called by a CAN driver interrupt or polling loop.\nint handle_can_diagnostic_message(uint32_t can_id, const uint8_t* data_bytes, uint8_t data_len) {\n    if (data_bytes == NULL || data_len == 0) {\n        return -1; \n    }\n\n    switch (can_id) {\n        case CAN_ID_CONFIG_UPDATE_SERVICE:\n            return process_config_update_payload(data_bytes, data_len);\n        case CAN_ID_STATUS_REQUEST_SERVICE:\n            // Placeholder for status request handling logic\n            return 0;\n        default:\n            return -99; \n    }\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_SENSOR_PROFILES 4\n#define SENSOR_PROFILE_BUFFER_SIZE 64\n#define MAX_CALIBRATION_PAYLOAD_SIZE 32\n\nstatic uint8_t g_sensorCalibrationProfiles[NUM_SENSOR_PROFILES][SENSOR_PROFILE_BUFFER_SIZE];\n\nvoid initSensorCalibrationProfiles() {\n    for (int i = 0; i < NUM_SENSOR_PROFILES; ++i) {\n        memset(g_sensorCalibrationProfiles[i], 0x00, SENSOR_PROFILE_BUFFER_SIZE);\n        g_sensorCalibrationProfiles[i][0] = i;\n    }\n}\n\ntypedef struct {\n    uint8_t  profile_index;\n    uint8_t  data_offset;\n    uint8_t  data_length;\n    uint8_t  payload[MAX_CALIBRATION_PAYLOAD_SIZE];\n} SensorCalibrationUpdateMsg;\n\nint applyCalibrationUpdate(const SensorCalibrationUpdateMsg* msg) {\n    if (msg == NULL) {\n        return -1;\n    }\n\n    uint8_t profile_idx = msg->profile_index;\n    uint8_t offset = msg->data_offset;\n    uint8_t length = msg->data_length;\n    const uint8_t* data = msg->payload;\n\n    if (profile_idx >= NUM_SENSOR_PROFILES) {\n        return -2;\n    }\n\n    if (length == 0 || length > MAX_CALIBRATION_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    if (offset >= SENSOR_PROFILE_BUFFER_SIZE) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < length; ++i) {\n        g_sensorCalibrationProfiles[profile_idx][offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid simulateCalibrationMessage(uint8_t p_idx, uint8_t off, uint8_t len, const uint8_t* payload_data) {\n    SensorCalibrationUpdateMsg msg;\n    msg.profile_index = p_idx;\n    msg.data_offset = off;\n    msg.data_length = len;\n    if (len > MAX_CALIBRATION_PAYLOAD_SIZE) {\n        len = MAX_CALIBRATION_PAYLOAD_SIZE; \n    }\n    for (uint8_t i = 0; i < len; ++i) {\n        msg.payload[i] = payload_data[i];\n    }\n    applyCalibrationUpdate(&msg);\n}\n\nuint8_t getCalibrationByte(uint8_t profile_idx, uint8_t offset) {\n    if (profile_idx < NUM_SENSOR_PROFILES && offset < SENSOR_PROFILE_BUFFER_SIZE) {\n        return g_sensorCalibrationProfiles[profile_idx][offset];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_SENSOR_PROFILES 4\n#define SENSOR_PROFILE_BUFFER_SIZE 64\n#define MAX_CALIBRATION_PAYLOAD_SIZE 32\n\nstatic uint8_t g_sensorCalibrationProfiles[NUM_SENSOR_PROFILES][SENSOR_PROFILE_BUFFER_SIZE];\n\nvoid initSensorCalibrationProfiles() {\n    for (int i = 0; i < NUM_SENSOR_PROFILES; ++i) {\n        memset(g_sensorCalibrationProfiles[i], 0x00, SENSOR_PROFILE_BUFFER_SIZE);\n        g_sensorCalibrationProfiles[i][0] = i;\n    }\n}\n\ntypedef struct {\n    uint8_t  profile_index;\n    uint8_t  data_offset;\n    uint8_t  data_length;\n    uint8_t  payload[MAX_CALIBRATION_PAYLOAD_SIZE];\n} SensorCalibrationUpdateMsg;\n\nint applyCalibrationUpdate(const SensorCalibrationUpdateMsg* msg) {\n    if (msg == NULL) {\n        return -1;\n    }\n\n    uint8_t profile_idx = msg->profile_index;\n    uint8_t offset = msg->data_offset;\n    uint8_t length = msg->data_length;\n    const uint8_t* data = msg->payload;\n\n    if (profile_idx >= NUM_SENSOR_PROFILES) {\n        return -2;\n    }\n\n    if (length == 0 || length > MAX_CALIBRATION_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    if (offset >= SENSOR_PROFILE_BUFFER_SIZE) {\n        return -4;\n    }\n\n    if ((uint16_t)offset + length > SENSOR_PROFILE_BUFFER_SIZE) {\n        return -5;\n    }\n\n    for (uint8_t i = 0; i < length; ++i) {\n        g_sensorCalibrationProfiles[profile_idx][offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid simulateCalibrationMessage(uint8_t p_idx, uint8_t off, uint8_t len, const uint8_t* payload_data) {\n    SensorCalibrationUpdateMsg msg;\n    msg.profile_index = p_idx;\n    msg.data_offset = off;\n    msg.data_length = len;\n    if (len > MAX_CALIBRATION_PAYLOAD_SIZE) {\n        len = MAX_CALIBRATION_PAYLOAD_SIZE; \n    }\n    for (uint8_t i = 0; i < len; ++i) {\n        msg.payload[i] = payload_data[i];\n    }\n    applyCalibrationUpdate(&msg);\n}\n\nuint8_t getCalibrationByte(uint8_t profile_idx, uint8_t offset) {\n    if (profile_idx < NUM_SENSOR_PROFILES && offset < SENSOR_PROFILE_BUFFER_SIZE) {\n        return g_sensorCalibrationProfiles[profile_idx][offset];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_VEHICLE_COMPONENTS 10\n#define BASE_INTERVAL_ARRAY_SIZE NUM_VEHICLE_COMPONENTS\n#define PROFILE_MODIFIER_ARRAY_SIZE (NUM_VEHICLE_COMPONENTS * 2) \n\nstatic uint16_t g_componentBaseIntervals[BASE_INTERVAL_ARRAY_SIZE];\nstatic int16_t g_componentProfileModifiers[PROFILE_MODIFIER_ARRAY_SIZE];\n\ntypedef struct {\n    uint8_t component_idx;\n    uint8_t profile_offset;\n    int8_t adjustment_value;\n} MaintenanceUpdateReq;\n\nvoid initMaintenanceSystem() {\n    memset(g_componentBaseIntervals, 0, sizeof(g_componentBaseIntervals));\n    memset(g_componentProfileModifiers, 0, sizeof(g_componentProfileModifiers));\n    for (uint8_t i = 0; i < NUM_VEHICLE_COMPONENTS; ++i) {\n        g_componentBaseIntervals[i] = 1000 + (i * 10);\n        g_componentProfileModifiers[i * 2] = 0;\n        g_componentProfileModifiers[i * 2 + 1] = -50;\n    }\n}\n\nint applyMaintenanceScheduleUpdate(const MaintenanceUpdateReq* req) {\n    if (req == NULL) {\n        return -1;\n    }\n\n    if (req->component_idx >= NUM_VEHICLE_COMPONENTS) {\n        return -2;\n    }\n\n    uint16_t effective_modifier_index = (uint16_t)(req->component_idx * 2) + req->profile_offset;\n\n    g_componentProfileModifiers[effective_modifier_index] += req->adjustment_value;\n\n    g_componentBaseIntervals[req->component_idx] += (req->adjustment_value / 2);\n\n    return 0;\n}\n\nvoid simulateMaintenanceRequest(uint8_t comp_id, uint8_t profile_off, int8_t adj_val) {\n    MaintenanceUpdateReq request = { .component_idx = comp_id, .profile_offset = profile_off, .adjustment_value = adj_val };\n    applyMaintenanceScheduleUpdate(&request);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_VEHICLE_COMPONENTS 10\n#define BASE_INTERVAL_ARRAY_SIZE NUM_VEHICLE_COMPONENTS\n#define PROFILE_MODIFIER_ARRAY_SIZE (NUM_VEHICLE_COMPONENTS * 2) \n\nstatic uint16_t g_componentBaseIntervals[BASE_INTERVAL_ARRAY_SIZE];\nstatic int16_t g_componentProfileModifiers[PROFILE_MODIFIER_ARRAY_SIZE];\n\ntypedef struct {\n    uint8_t component_idx;\n    uint8_t profile_offset;\n    int8_t adjustment_value;\n} MaintenanceUpdateReq;\n\nvoid initMaintenanceSystem() {\n    memset(g_componentBaseIntervals, 0, sizeof(g_componentBaseIntervals));\n    memset(g_componentProfileModifiers, 0, sizeof(g_componentProfileModifiers));\n    for (uint8_t i = 0; i < NUM_VEHICLE_COMPONENTS; ++i) {\n        g_componentBaseIntervals[i] = 1000 + (i * 10);\n        g_componentProfileModifiers[i * 2] = 0;\n        g_componentProfileModifiers[i * 2 + 1] = -50;\n    }\n}\n\nint applyMaintenanceScheduleUpdate(const MaintenanceUpdateReq* req) {\n    if (req == NULL) {\n        return -1;\n    }\n\n    if (req->component_idx >= NUM_VEHICLE_COMPONENTS) {\n        return -2;\n    }\n\n    uint16_t effective_modifier_index = (uint16_t)(req->component_idx * 2) + req->profile_offset;\n\n    if (effective_modifier_index >= PROFILE_MODIFIER_ARRAY_SIZE) {\n        return -3;\n    }\n\n    g_componentProfileModifiers[effective_modifier_index] += req->adjustment_value;\n\n    g_componentBaseIntervals[req->component_idx] += (req->adjustment_value / 2);\n\n    return 0;\n}\n\nvoid simulateMaintenanceRequest(uint8_t comp_id, uint8_t profile_off, int8_t adj_val) {\n    MaintenanceUpdateReq request = { .component_idx = comp_id, .profile_offset = profile_off, .adjustment_value = adj_val };\n    applyMaintenanceScheduleUpdate(&request);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_ENGINE_CALIBRATION_POINTS 100\n#define MAX_PAYLOAD_FOR_CALIBRATION 512\n\ntypedef struct {\n    uint16_t rpm_target;\n    uint16_t fuel_injection_pulse;\n} EngineCalibrationPoint;\n\nstatic EngineCalibrationPoint g_engineCalibrationTable[MAX_ENGINE_CALIBRATION_POINTS];\n\nvoid initEngineCalibration() {\n    memset(g_engineCalibrationTable, 0, sizeof(g_engineCalibrationTable));\n    for (int i = 0; i < MAX_ENGINE_CALIBRATION_POINTS; ++i) {\n        g_engineCalibrationTable[i].rpm_target = 800 + i * 10;\n        g_engineCalibrationTable[i].fuel_injection_pulse = 100 + i * 2;\n    }\n}\n\nint updateEngineCalibration(const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len < 4) {\n        return -1;\n    }\n\n    uint16_t start_index = (payload[0] << 8) | payload[1];\n    uint16_t num_points = (payload[2] << 8) | payload[3];\n\n    uint16_t data_offset = 4;\n    uint16_t expected_data_len = num_points * sizeof(EngineCalibrationPoint);\n\n    if (data_offset + expected_data_len > payload_len) {\n        return -2;\n    }\n    \n    if (start_index >= MAX_ENGINE_CALIBRATION_POINTS) {\n        return -3;\n    }\n\n    for (uint16_t i = 0; i < num_points; ++i) {\n        uint16_t current_data_ptr_offset = data_offset + (i * sizeof(EngineCalibrationPoint));\n        \n        g_engineCalibrationTable[start_index + i].rpm_target = \n            (payload[current_data_ptr_offset] << 8) | payload[current_data_ptr_offset + 1];\n        g_engineCalibrationTable[start_index + i].fuel_injection_pulse = \n            (payload[current_data_ptr_offset + 2] << 8) | payload[current_data_ptr_offset + 3];\n    }\n\n    return 0;\n}\n\nvoid simulateCanMessage(const uint8_t* data, uint16_t len) {\n    updateEngineCalibration(data, len);\n}\n\nEngineCalibrationPoint getCalibrationPoint(uint16_t index) {\n    if (index < MAX_ENGINE_CALIBRATION_POINTS) {\n        return g_engineCalibrationTable[index];\n    }\n    EngineCalibrationPoint invalid = {0,0};\n    return invalid;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_ENGINE_CALIBRATION_POINTS 100\n#define MAX_PAYLOAD_FOR_CALIBRATION 512\n\ntypedef struct {\n    uint16_t rpm_target;\n    uint16_t fuel_injection_pulse;\n} EngineCalibrationPoint;\n\nstatic EngineCalibrationPoint g_engineCalibrationTable[MAX_ENGINE_CALIBRATION_POINTS];\n\nvoid initEngineCalibration() {\n    memset(g_engineCalibrationTable, 0, sizeof(g_engineCalibrationTable));\n    for (int i = 0; i < MAX_ENGINE_CALIBRATION_POINTS; ++i) {\n        g_engineCalibrationTable[i].rpm_target = 800 + i * 10;\n        g_engineCalibrationTable[i].fuel_injection_pulse = 100 + i * 2;\n    }\n}\n\nint updateEngineCalibration(const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len < 4) {\n        return -1;\n    }\n\n    uint16_t start_index = (payload[0] << 8) | payload[1];\n    uint16_t num_points = (payload[2] << 8) | payload[3];\n\n    uint16_t data_offset = 4;\n    uint16_t expected_data_len = num_points * sizeof(EngineCalibrationPoint);\n\n    if (data_offset + expected_data_len > payload_len) {\n        return -2;\n    }\n    \n    if (start_index >= MAX_ENGINE_CALIBRATION_POINTS || (num_points > 0 && (uint32_t)start_index + num_points > MAX_ENGINE_CALIBRATION_POINTS)) {\n        return -3;\n    }\n\n    for (uint16_t i = 0; i < num_points; ++i) {\n        uint16_t current_data_ptr_offset = data_offset + (i * sizeof(EngineCalibrationPoint));\n        \n        g_engineCalibrationTable[start_index + i].rpm_target = \n            (payload[current_data_ptr_offset] << 8) | payload[current_data_ptr_offset + 1];\n        g_engineCalibrationTable[start_index + i].fuel_injection_pulse = \n            (payload[current_data_ptr_offset + 2] << 8) | payload[current_data_ptr_offset + 3];\n    }\n\n    return 0;\n}\n\nvoid simulateCanMessage(const uint8_t* data, uint16_t len) {\n    updateEngineCalibration(data, len);\n}\n\nEngineCalibrationPoint getCalibrationPoint(uint16_t index) {\n    if (index < MAX_ENGINE_CALIBRATION_POINTS) {\n        return g_engineCalibrationTable[index];\n    }\n    EngineCalibrationPoint invalid = {0,0};\n    return invalid;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_FIRMWARE_SIZE 0x10000 \n#define FRAGMENT_MAX_PAYLOAD_SIZE 256 \n\nstatic uint8_t g_firmwareBuffer[VEHICLE_FIRMWARE_SIZE];\n\nvoid initFirmwareBuffer() {\n    memset(g_firmwareBuffer, 0, VEHICLE_FIRMWARE_SIZE);\n}\n\nstatic int processFirmwareFragment(uint16_t fragment_offset, uint8_t fragment_len, const uint8_t* fragment_data) {\n    if (fragment_data == NULL || fragment_len == 0) {\n        return -1;\n    }\n\n    if ((uint32_t)fragment_offset + fragment_len > VEHICLE_FIRMWARE_SIZE) {\n        return -2;\n    }\n\n    for (uint8_t i = 0; i < fragment_len; ++i) {\n        g_firmwareBuffer[fragment_offset + i] = fragment_data[i];\n    }\n\n    return 0;\n}\n\nint handleFirmwareUpdateMessage(const uint8_t* message, uint16_t message_len) {\n    if (message == NULL || message_len < (1 + sizeof(uint16_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    uint8_t service_id = message[0];\n    if (service_id != 0x34) {\n        return -2;\n    }\n\n    uint16_t offset_idx = 1;\n    uint16_t fragment_offset = (message[offset_idx] << 8) | message[offset_idx+1];\n    \n    uint16_t len_idx = offset_idx + sizeof(uint16_t);\n    uint8_t fragment_len = message[len_idx];\n\n    const uint8_t* fragment_data = message + len_idx + sizeof(uint8_t);\n    uint16_t actual_data_in_msg_len = message_len - (len_idx + sizeof(uint8_t));\n\n    if (fragment_len > FRAGMENT_MAX_PAYLOAD_SIZE) {\n        return -3;\n    }\n    \n    return processFirmwareFragment(fragment_offset, fragment_len, fragment_data);\n}\n\nuint8_t getFirmwareByte(uint32_t index) {\n    if (index < VEHICLE_FIRMWARE_SIZE) {\n        return g_firmwareBuffer[index];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_FIRMWARE_SIZE 0x10000 \n#define FRAGMENT_MAX_PAYLOAD_SIZE 256 \n\nstatic uint8_t g_firmwareBuffer[VEHICLE_FIRMWARE_SIZE];\n\nvoid initFirmwareBuffer() {\n    memset(g_firmwareBuffer, 0, VEHICLE_FIRMWARE_SIZE);\n}\n\nstatic int processFirmwareFragment(uint16_t fragment_offset, uint8_t fragment_len, const uint8_t* fragment_data) {\n    if (fragment_data == NULL || fragment_len == 0) {\n        return -1;\n    }\n\n    if ((uint32_t)fragment_offset + fragment_len > VEHICLE_FIRMWARE_SIZE) {\n        return -2;\n    }\n\n    for (uint8_t i = 0; i < fragment_len; ++i) {\n        g_firmwareBuffer[fragment_offset + i] = fragment_data[i];\n    }\n\n    return 0;\n}\n\nint handleFirmwareUpdateMessage(const uint8_t* message, uint16_t message_len) {\n    if (message == NULL || message_len < (1 + sizeof(uint16_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    uint8_t service_id = message[0];\n    if (service_id != 0x34) {\n        return -2;\n    }\n\n    uint16_t offset_idx = 1;\n    uint16_t fragment_offset = (message[offset_idx] << 8) | message[offset_idx+1];\n    \n    uint16_t len_idx = offset_idx + sizeof(uint16_t);\n    uint8_t fragment_len = message[len_idx];\n\n    const uint8_t* fragment_data = message + len_idx + sizeof(uint8_t);\n    uint16_t actual_data_in_msg_len = message_len - (len_idx + sizeof(uint8_t));\n\n    if (fragment_len > FRAGMENT_MAX_PAYLOAD_SIZE) {\n        return -3;\n    }\n    \n    if (fragment_len > actual_data_in_msg_len) { \n        return -4; \n    }\n\n    return processFirmwareFragment(fragment_offset, fragment_len, fragment_data);\n}\n\nuint8_t getFirmwareByte(uint32_t index) {\n    if (index < VEHICLE_FIRMWARE_SIZE) {\n        return g_firmwareBuffer[index];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n// Max number of distinct sensor data types\n#define MAX_SENSORS 4\n\n// Fixed size buffer for each sensor's aggregated data\n// This is intentionally smaller than MAX_TELEMETRY_PACKET_PAYLOAD\n#define SENSOR_DATA_BUFFER_SIZE 32\n\n// Maximum payload size for an incoming telemetry packet\n// This represents the maximum data that can be carried by the communication protocol.\n#define MAX_TELEMETRY_PACKET_PAYLOAD 64\n\n// Storage for sensor data. Each sensor has its own fixed-size buffer.\nstatic uint8_t g_sensorDataBuffers[MAX_SENSORS][SENSOR_DATA_BUFFER_SIZE];\n// Current valid length for each sensor's buffer\nstatic uint8_t g_sensorDataLengths[MAX_SENSORS];\n\n// Structure representing an incoming telemetry packet\ntypedef struct {\n    uint8_t  sensor_id;  // Identifier for the sensor (0 to MAX_SENSORS-1)\n    uint16_t data_len;   // Length of the data payload in this packet\n    uint8_t  data[MAX_TELEMETRY_PACKET_PAYLOAD]; // Raw data payload\n} TelemetryPacket;\n\n// Initialize sensor data buffers to zeros and lengths to zero\nvoid initSensorDataStorage() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        memset(g_sensorDataBuffers[i], 0, SENSOR_DATA_BUFFER_SIZE);\n        g_sensorDataLengths[i] = 0;\n    }\n}\n\n// Process an incoming telemetry packet\n// This function stores the sensor data into the respective buffer based on sensor_id.\nint processTelemetryPacket(const TelemetryPacket* packet) {\n    if (packet == NULL) {\n        return -1; // Invalid packet pointer\n    }\n\n    // 1. Validate sensor ID against the maximum number of sensors\n    if (packet->sensor_id >= MAX_SENSORS) {\n        return -2; // Invalid sensor ID, out of bounds for the array of buffers\n    }\n\n    // 2. Validate incoming data length against the packet's maximum allowed payload size.\n    // This check ensures the data doesn't exceed what the packet structure can hold.\n    if (packet->data_len > MAX_TELEMETRY_PACKET_PAYLOAD) {\n        return -3; // Data length exceeds the maximum payload defined for the packet format\n    }\n\n    // VULNERABILITY: Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-119)\n    // The 'packet->data_len' is checked against 'MAX_TELEMETRY_PACKET_PAYLOAD' (64 bytes), which is\n    // the maximum size the incoming packet *can* carry. However, the destination buffer\n    // 'g_sensorDataBuffers[packet->sensor_id]' is only 'SENSOR_DATA_BUFFER_SIZE' (32 bytes).\n    // If an attacker sends a 'data_len' value that is valid for the packet (e.g., 40 bytes),\n    // but larger than 'SENSOR_DATA_BUFFER_SIZE', the 'memcpy' will write beyond the bounds of\n    // the targeted sensor's buffer, potentially overwriting data in adjacent buffers\n    // or other critical memory regions.\n    memcpy(g_sensorDataBuffers[packet->sensor_id], packet->data, packet->data_len);\n    \n    // Update the stored length, note that it will be truncated if packet->data_len > 255,\n    // but the overflow happens during memcpy if packet->data_len > SENSOR_DATA_BUFFER_SIZE\n    g_sensorDataLengths[packet->sensor_id] = (uint8_t)packet->data_len;\n\n    return 0; // Success\n}\n\n// Dummy function to simulate receiving a raw data buffer from a communication interface.\n// In a real system, 'raw_data_buffer' would be parsed into a 'TelemetryPacket' structure.\nvoid receiveSensorData(const uint8_t* raw_data_buffer) {\n    processTelemetryPacket((const TelemetryPacket*)raw_data_buffer);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n// Max number of distinct sensor data types\n#define MAX_SENSORS 4\n\n// Fixed size buffer for each sensor's aggregated data\n// This is intentionally smaller than MAX_TELEMETRY_PACKET_PAYLOAD\n#define SENSOR_DATA_BUFFER_SIZE 32\n\n// Maximum payload size for an incoming telemetry packet\n// This represents the maximum data that can be carried by the communication protocol.\n#define MAX_TELEMETRY_PACKET_PAYLOAD 64\n\n// Storage for sensor data. Each sensor has its own fixed-size buffer.\nstatic uint8_t g_sensorDataBuffers[MAX_SENSORS][SENSOR_DATA_BUFFER_SIZE];\n// Current valid length for each sensor's buffer\nstatic uint8_t g_sensorDataLengths[MAX_SENSORS];\n\n// Structure representing an incoming telemetry packet\ntypedef struct {\n    uint8_t  sensor_id;  // Identifier for the sensor (0 to MAX_SENSORS-1)\n    uint16_t data_len;   // Length of the data payload in this packet\n    uint8_t  data[MAX_TELEMETRY_PACKET_PAYLOAD]; // Raw data payload\n} TelemetryPacket;\n\n// Initialize sensor data buffers to zeros and lengths to zero\nvoid initSensorDataStorage() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        memset(g_sensorDataBuffers[i], 0, SENSOR_DATA_BUFFER_SIZE);\n        g_sensorDataLengths[i] = 0;\n    }\n}\n\n// Process an incoming telemetry packet\n// This function stores the sensor data into the respective buffer based on sensor_id.\nint processTelemetryPacket(const TelemetryPacket* packet) {\n    if (packet == NULL) {\n        return -1; // Invalid packet pointer\n    }\n\n    // 1. Validate sensor ID against the maximum number of sensors\n    if (packet->sensor_id >= MAX_SENSORS) {\n        return -2; // Invalid sensor ID, out of bounds for the array of buffers\n    }\n\n    // 2. Validate incoming data length against the packet's maximum allowed payload size.\n    // This check ensures the data doesn't exceed what the packet structure can hold.\n    if (packet->data_len > MAX_TELEMETRY_PACKET_PAYLOAD) {\n        return -3; // Data length exceeds the maximum payload defined for the packet format\n    }\n\n    // FIX: Add a bounds check to ensure the incoming data length does not exceed\n    // the actual capacity of the destination buffer for the specific sensor.\n    if (packet->data_len > SENSOR_DATA_BUFFER_SIZE) {\n        // Option: Return an error indicating that the data is too large for this sensor's buffer.\n        // Alternatively, one could truncate the data, but returning an error is often safer.\n        return -4; // Data length too large for the specific sensor's buffer\n    }\n\n    memcpy(g_sensorDataBuffers[packet->sensor_id], packet->data, packet->data_len);\n    \n    // Update the stored length after successful copy.\n    g_sensorDataLengths[packet->sensor_id] = (uint8_t)packet->data_len;\n\n    return 0; // Success\n}\n\n// Dummy function to simulate receiving a raw data buffer from a communication interface.\n// In a real system, 'raw_data_buffer' would be parsed into a 'TelemetryPacket' structure.\nvoid receiveSensorData(const uint8_t* raw_data_buffer) {\n    processTelemetryPacket((const TelemetryPacket*)raw_data_buffer);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_BUFFER_SIZE 256\n#define MAX_TELEMETRY_PAYLOAD_LEN 8 \n\nstatic uint8_t g_telemetryDataBuffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_currentBufferWriteOffset = 0;\n\ntypedef enum {\n    TELEMETRY_TYPE_ENGINE_STATUS = 0,\n    TELEMETRY_TYPE_BATTERY_INFO,\n    TELEMETRY_TYPE_TIRE_PRESSURE,\n    TELEMETRY_TYPE_COUNT\n} TelemetryBlockType;\n\ntypedef struct {\n    uint8_t item_size;\n    uint8_t num_items;\n} TelemetryBlockMetadata;\n\nstatic const TelemetryBlockMetadata g_telemetryMetadata[TELEMETRY_TYPE_COUNT] = {\n    {10, 10}, \n    {5, 5},   \n    {8, 10}   \n};\n\nstatic uint16_t g_telemetryTypeBaseOffsets[TELEMETRY_TYPE_COUNT];\n\nvoid initTelemetrySystem() {\n    memset(g_telemetryDataBuffer, 0, TELEMETRY_BUFFER_SIZE);\n    g_currentBufferWriteOffset = 0;\n\n    uint16_t current_offset = 0;\n    for (int i = 0; i < TELEMETRY_TYPE_COUNT; ++i) {\n        g_telemetryTypeBaseOffsets[i] = current_offset;\n        current_offset += (uint16_t)g_telemetryMetadata[i].item_size * g_telemetryMetadata[i].num_items;\n    }\n    g_currentBufferWriteOffset = current_offset; \n}\n\nint updateTelemetryDataItem(TelemetryBlockType telemetry_type, uint8_t item_index, \n                            uint8_t update_offset, uint8_t data_len, const uint8_t* data_payload) {\n    \n    if (telemetry_type >= TELEMETRY_TYPE_COUNT || data_payload == NULL || data_len == 0) {\n        return -1;\n    }\n\n    if (item_index >= g_telemetryMetadata[telemetry_type].num_items) {\n        return -2;\n    }\n\n    if (data_len > MAX_TELEMETRY_PAYLOAD_LEN) {\n        return -3;\n    }\n\n    uint16_t item_base_addr = g_telemetryTypeBaseOffsets[telemetry_type] + \n                              (uint16_t)item_index * g_telemetryMetadata[telemetry_type].item_size;\n\n    uint16_t dest_offset = item_base_addr + update_offset;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_telemetryDataBuffer[dest_offset + i] = data_payload[i];\n    }\n\n    return 0;\n}\n\nvoid simulateCanTelemetryUpdate(TelemetryBlockType type, uint8_t index, uint8_t offset, uint8_t len, const uint8_t* data) {\n    updateTelemetryDataItem(type, index, offset, len, data);\n}\n\nuint8_t getTelemetryDataByte(uint16_t global_offset) {\n    if (global_offset < TELEMETRY_BUFFER_SIZE) {\n        return g_telemetryDataBuffer[global_offset];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_BUFFER_SIZE 256\n#define MAX_TELEMETRY_PAYLOAD_LEN 8 \n\nstatic uint8_t g_telemetryDataBuffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_currentBufferWriteOffset = 0;\n\ntypedef enum {\n    TELEMETRY_TYPE_ENGINE_STATUS = 0,\n    TELEMETRY_TYPE_BATTERY_INFO,\n    TELEMETRY_TYPE_TIRE_PRESSURE,\n    TELEMETRY_TYPE_COUNT\n} TelemetryBlockType;\n\ntypedef struct {\n    uint8_t item_size;\n    uint8_t num_items;\n} TelemetryBlockMetadata;\n\nstatic const TelemetryBlockMetadata g_telemetryMetadata[TELEMETRY_TYPE_COUNT] = {\n    {10, 10}, \n    {5, 5},   \n    {8, 10}   \n};\n\nstatic uint16_t g_telemetryTypeBaseOffsets[TELEMETRY_TYPE_COUNT];\n\nvoid initTelemetrySystem() {\n    memset(g_telemetryDataBuffer, 0, TELEMETRY_BUFFER_SIZE);\n    g_currentBufferWriteOffset = 0;\n\n    uint16_t current_offset = 0;\n    for (int i = 0; i < TELEMETRY_TYPE_COUNT; ++i) {\n        g_telemetryTypeBaseOffsets[i] = current_offset;\n        current_offset += (uint16_t)g_telemetryMetadata[i].item_size * g_telemetryMetadata[i].num_items;\n    }\n    g_currentBufferWriteOffset = current_offset;\n}\n\nint updateTelemetryDataItem(TelemetryBlockType telemetry_type, uint8_t item_index, \n                            uint8_t update_offset, uint8_t data_len, const uint8_t* data_payload) {\n    \n    if (telemetry_type >= TELEMETRY_TYPE_COUNT || data_payload == NULL || data_len == 0) {\n        return -1;\n    }\n\n    if (item_index >= g_telemetryMetadata[telemetry_type].num_items) {\n        return -2;\n    }\n\n    if (data_len > MAX_TELEMETRY_PAYLOAD_LEN) {\n        return -3;\n    }\n\n    uint16_t item_base_addr = g_telemetryTypeBaseOffsets[telemetry_type] + \n                              (uint16_t)item_index * g_telemetryMetadata[telemetry_type].item_size;\n\n    uint16_t dest_offset = item_base_addr + update_offset;\n    \n    if (update_offset >= g_telemetryMetadata[telemetry_type].item_size) {\n        return -4;\n    }\n\n    if ((uint16_t)update_offset + data_len > g_telemetryMetadata[telemetry_type].item_size ||\n        dest_offset + data_len > TELEMETRY_BUFFER_SIZE) {\n        return -5;\n    }\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_telemetryDataBuffer[dest_offset + i] = data_payload[i];\n    }\n\n    return 0;\n}\n\nvoid simulateCanTelemetryUpdate(TelemetryBlockType type, uint8_t index, uint8_t offset, uint8_t len, const uint8_t* data) {\n    updateTelemetryDataItem(type, index, offset, len, data);\n}\n\nuint8_t getTelemetryDataByte(uint16_t global_offset) {\n    if (global_offset < TELEMETRY_BUFFER_SIZE) {\n        return g_telemetryDataBuffer[global_offset];\n    }\n    return 0xFF;\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define FIRMWARE_STAGING_BUFFER_SIZE 2048 \n#define MAX_FW_PACKAGE_SIZE 4096 \n#define MAX_FW_BLOCKS 16 \n\ntypedef struct {\n    uint16_t block_id;\n    uint16_t block_offset; \n    uint16_t block_length;\n} FirmwareBlockDescriptor;\n\ntypedef struct {\n    uint16_t total_data_length; \n    uint8_t num_blocks;\n} FirmwarePackageHeader;\n\nstatic uint8_t g_firmwareStagingBuffer[FIRMWARE_STAGING_BUFFER_SIZE];\nstatic uint16_t g_stagingWritePointer = 0; \n\nvoid initFirmwareStagingSystem() {\n    memset(g_firmwareStagingBuffer, 0, FIRMWARE_STAGING_BUFFER_SIZE);\n    g_stagingWritePointer = 0;\n}\n\nint processFirmwareUpdatePackage(const uint8_t* package_payload, uint16_t payload_len) {\n    if (package_payload == NULL || payload_len < sizeof(FirmwarePackageHeader)) {\n        return -1; \n    }\n\n    FirmwarePackageHeader header;\n    header.total_data_length = (uint16_t)(package_payload[0] << 8 | package_payload[1]);\n    header.num_blocks = package_payload[2];\n\n    if (payload_len < sizeof(FirmwarePackageHeader) + (header.num_blocks * sizeof(FirmwareBlockDescriptor))) {\n        return -2; \n    }\n    if (header.num_blocks > MAX_FW_BLOCKS) {\n        return -3; \n    }\n\n    uint16_t descriptor_offset = sizeof(FirmwarePackageHeader);\n    uint16_t data_offset = descriptor_offset + (header.num_blocks * sizeof(FirmwareBlockDescriptor));\n\n    if (data_offset + header.total_data_length > payload_len) {\n        return -4; \n    }\n\n    g_stagingWritePointer = 0; \n\n    for (uint8_t i = 0; i < header.num_blocks; ++i) {\n        uint16_t current_descriptor_pos = descriptor_offset + (i * sizeof(FirmwareBlockDescriptor));\n        if (current_descriptor_pos + sizeof(FirmwareBlockDescriptor) > payload_len) {\n            return -5; \n        }\n\n        FirmwareBlockDescriptor block_desc;\n        block_desc.block_id = (uint16_t)(package_payload[current_descriptor_pos] << 8 | package_payload[current_descriptor_pos + 1]);\n        block_desc.block_offset = (uint16_t)(package_payload[current_descriptor_pos + 2] << 8 | package_payload[current_descriptor_pos + 3]);\n        block_desc.block_length = (uint16_t)(package_payload[current_descriptor_pos + 4] << 8 | package_payload[current_descriptor_pos + 5]);\n\n        if (block_desc.block_offset + block_desc.block_length > header.total_data_length) {\n            return -6; \n        }\n        if (data_offset + block_desc.block_offset + block_desc.block_length > payload_len) {\n            return -7; \n        }\n\n        for (uint16_t j = 0; j < block_desc.block_length; ++j) {\n            g_firmwareStagingBuffer[g_stagingWritePointer] = package_payload[data_offset + block_desc.block_offset + j];\n            g_stagingWritePointer++;\n        }\n    }\n\n    return 0; \n}\n\nvoid receiveFirmwarePackage(const uint8_t* data, uint16_t length) {\n    initFirmwareStagingSystem();\n    processFirmwareUpdatePackage(data, length);\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define FIRMWARE_STAGING_BUFFER_SIZE 2048 \n#define MAX_FW_PACKAGE_SIZE 4096 \n#define MAX_FW_BLOCKS 16 \n\ntypedef struct {\n    uint16_t block_id;\n    uint16_t block_offset; \n    uint16_t block_length;\n} FirmwareBlockDescriptor;\n\ntypedef struct {\n    uint16_t total_data_length; \n    uint8_t num_blocks;\n} FirmwarePackageHeader;\n\nstatic uint8_t g_firmwareStagingBuffer[FIRMWARE_STAGING_BUFFER_SIZE];\nstatic uint16_t g_stagingWritePointer = 0; \n\nvoid initFirmwareStagingSystem() {\n    memset(g_firmwareStagingBuffer, 0, FIRMWARE_STAGING_BUFFER_SIZE);\n    g_stagingWritePointer = 0;\n}\n\nint processFirmwareUpdatePackage(const uint8_t* package_payload, uint16_t payload_len) {\n    if (package_payload == NULL || payload_len < sizeof(FirmwarePackageHeader)) {\n        return -1; \n    }\n\n    FirmwarePackageHeader header;\n    header.total_data_length = (uint16_t)(package_payload[0] << 8 | package_payload[1]);\n    header.num_blocks = package_payload[2];\n\n    if (payload_len < sizeof(FirmwarePackageHeader) + (header.num_blocks * sizeof(FirmwareBlockDescriptor))) {\n        return -2; \n    }\n    if (header.num_blocks > MAX_FW_BLOCKS) {\n        return -3; \n    }\n\n    uint16_t descriptor_offset = sizeof(FirmwarePackageHeader);\n    uint16_t data_offset = descriptor_offset + (header.num_blocks * sizeof(FirmwareBlockDescriptor));\n\n    if (data_offset + header.total_data_length > payload_len) {\n        return -4; \n    }\n\n    g_stagingWritePointer = 0; \n\n    for (uint8_t i = 0; i < header.num_blocks; ++i) {\n        uint16_t current_descriptor_pos = descriptor_offset + (i * sizeof(FirmwareBlockDescriptor));\n        if (current_descriptor_pos + sizeof(FirmwareBlockDescriptor) > payload_len) {\n            return -5; \n        }\n\n        FirmwareBlockDescriptor block_desc;\n        block_desc.block_id = (uint16_t)(package_payload[current_descriptor_pos] << 8 | package_payload[current_descriptor_pos + 1]);\n        block_desc.block_offset = (uint16_t)(package_payload[current_descriptor_pos + 2] << 8 | package_payload[current_descriptor_pos + 3]);\n        block_desc.block_length = (uint16_t)(package_payload[current_descriptor_pos + 4] << 8 | package_payload[current_descriptor_pos + 5]);\n\n        if (block_desc.block_offset + block_desc.block_length > header.total_data_length) {\n            return -6; \n        }\n        if (data_offset + block_desc.block_offset + block_desc.block_length > payload_len) {\n            return -7; \n        }\n\n        if (g_stagingWritePointer + block_desc.block_length > FIRMWARE_STAGING_BUFFER_SIZE) {\n            return -8;\n        }\n\n        for (uint16_t j = 0; j < block_desc.block_length; ++j) {\n            g_firmwareStagingBuffer[g_stagingWritePointer] = package_payload[data_offset + block_desc.block_offset + j];\n            g_stagingWritePointer++;\n        }\n    }\n\n    return 0; \n}\n\nvoid receiveFirmwarePackage(const uint8_t* data, uint16_t length) {\n    initFirmwareStagingSystem();\n    processFirmwareUpdatePackage(data, length);\n}", "analysis": ""}
{"cwe_id": "CWE-119", "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.", "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define ENGINE_PARAM_MAP_SIZE 256\n#define MAX_PARAM_UPDATE_LENGTH 64\n\nstatic uint8_t g_engineParamMap[ENGINE_PARAM_MAP_SIZE];\n\nvoid initializeEngineParameters() {\n    memset(g_engineParamMap, 0x00, ENGINE_PARAM_MAP_SIZE);\n    for (uint16_t i = 0; i < ENGINE_PARAM_MAP_SIZE; ++i) {\n        g_engineParamMap[i] = (uint8_t)(i % 0xFF);\n    }\n}\n\nint updateEngineParameterSegment(uint8_t param_offset, const uint8_t* update_data, uint8_t update_len) {\n    if (update_data == NULL || update_len == 0) {\n        return -1;\n    }\n\n    if (param_offset >= ENGINE_PARAM_MAP_SIZE) {\n        return -2;\n    }\n\n    if (update_len > MAX_PARAM_UPDATE_LENGTH) {\n        return -3;\n    }\n\n    for (uint8_t i = 0; i < update_len; ++i) {\n        g_engineParamMap[param_offset + i] = update_data[i];\n    }\n\n    return 0;\n}\n\nvoid handleParamUpdateMessage(uint8_t offset, const uint8_t* data, uint8_t len) {\n    updateEngineParameterSegment(offset, data, len);\n}\n\nuint8_t getEngineParameter(uint8_t index) {\n    if (index < ENGINE_PARAM_MAP_SIZE) {\n        return g_engineParamMap[index];\n    }\n    return 0xFF;\n}", "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define ENGINE_PARAM_MAP_SIZE 256\n#define MAX_PARAM_UPDATE_LENGTH 64\n\nstatic uint8_t g_engineParamMap[ENGINE_PARAM_MAP_SIZE];\n\nvoid initializeEngineParameters() {\n    memset(g_engineParamMap, 0x00, ENGINE_PARAM_MAP_SIZE);\n    for (uint16_t i = 0; i < ENGINE_PARAM_MAP_SIZE; ++i) {\n        g_engineParamMap[i] = (uint8_t)(i % 0xFF);\n    }\n}\n\nint updateEngineParameterSegment(uint8_t param_offset, const uint8_t* update_data, uint8_t update_len) {\n    if (update_data == NULL || update_len == 0) {\n        return -1;\n    }\n\n    if (param_offset >= ENGINE_PARAM_MAP_SIZE) {\n        return -2;\n    }\n\n    if (update_len > MAX_PARAM_UPDATE_LENGTH) {\n        return -3;\n    }\n\n    if ((uint16_t)param_offset + update_len > ENGINE_PARAM_MAP_SIZE) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < update_len; ++i) {\n        g_engineParamMap[param_offset + i] = update_data[i];\n    }\n\n    return 0;\n}\n\nvoid handleParamUpdateMessage(uint8_t offset, const uint8_t* data, uint8_t len) {\n    updateEngineParameterSegment(offset, data, len);\n}\n\nuint8_t getEngineParameter(uint8_t index) {\n    if (index < ENGINE_PARAM_MAP_SIZE) {\n        return g_engineParamMap[index];\n    }\n    return 0xFF;\n}", "analysis": ""}
