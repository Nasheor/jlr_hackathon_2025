[
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stddef.h>\n\ntypedef struct {\n    unsigned int message_id;\n    unsigned char data[8];\n    unsigned char data_length;\n    unsigned long long timestamp_us;\n} CanMessage;\n\n#define MAX_CAN_LOG_ENTRIES 256\nstatic CanMessage message_log_buffer[MAX_CAN_LOG_ENTRIES];\nstatic unsigned int latest_entry_index = 0;\n\nvoid logCanMessage(const CanMessage* msg) {\n    if (msg == NULL) {\n        return;\n    }\n    message_log_buffer[latest_entry_index] = *msg;\n    latest_entry_index = (latest_entry_index + 1) % MAX_CAN_LOG_ENTRIES;\n}\n\ntypedef enum {\n    DIAG_GET_STATUS,\n    DIAG_RETRIEVE_PAST_MESSAGE,\n    DIAG_OVERWRITE_HISTORICAL_MESSAGE,\n    DIAG_PERFORM_CHECKSUM_CALC\n} DiagnosticCommandType;\n\ntypedef struct {\n    DiagnosticCommandType type;\n    int historical_offset_steps;\n    CanMessage payload_data;\n} DiagnosticCommand;\n\nvoid processDiagnosticCommand_Vulnerable(const DiagnosticCommand* cmd) {\n    if (cmd == NULL) {\n        return;\n    }\n\n    switch (cmd->type) {\n        case DIAG_OVERWRITE_HISTORICAL_MESSAGE: {\n            unsigned int current_head_idx = (latest_entry_index == 0) ? (MAX_CAN_LOG_ENTRIES - 1) : (latest_entry_index - 1);\n\n            int target_idx_calc = (int)current_head_idx - cmd->historical_offset_steps;\n\n            message_log_buffer[target_idx_calc] = cmd->payload_data;\n\n            break;\n        }\n        case DIAG_RETRIEVE_PAST_MESSAGE:\n            break;\n        case DIAG_GET_STATUS:\n            break;\n        case DIAG_PERFORM_CHECKSUM_CALC:\n            break;\n        default:\n            break;\n    }\n}",
    "fixed_code": "#include <stddef.h>\n\ntypedef struct {\n    unsigned int message_id;\n    unsigned char data[8];\n    unsigned char data_length;\n    unsigned long long timestamp_us;\n} CanMessage;\n\n#define MAX_CAN_LOG_ENTRIES 256\nstatic CanMessage message_log_buffer[MAX_CAN_LOG_ENTRIES];\nstatic unsigned int latest_entry_index = 0;\n\nvoid logCanMessage(const CanMessage* msg) {\n    if (msg == NULL) {\n        return;\n    }\n    message_log_buffer[latest_entry_index] = *msg;\n    latest_entry_index = (latest_entry_index + 1) % MAX_CAN_LOG_ENTRIES;\n}\n\ntypedef enum {\n    DIAG_GET_STATUS,\n    DIAG_RETRIEVE_PAST_MESSAGE,\n    DIAG_OVERWRITE_HISTORICAL_MESSAGE,\n    DIAG_PERFORM_CHECKSUM_CALC\n} DiagnosticCommandType;\n\ntypedef struct {\n    DiagnosticCommandType type;\n    int historical_offset_steps;\n    CanMessage payload_data;\n} DiagnosticCommand;\n\nvoid processDiagnosticCommand_Fixed(const DiagnosticCommand* cmd) {\n    if (cmd == NULL) {\n        return;\n    }\n\n    switch (cmd->type) {\n        case DIAG_OVERWRITE_HISTORICAL_MESSAGE: {\n            unsigned int current_head_idx = (latest_entry_index == 0) ? (MAX_CAN_LOG_ENTRIES - 1) : (latest_entry_index - 1);\n\n            if (cmd->historical_offset_steps < 0 || cmd->historical_offset_steps >= MAX_CAN_LOG_ENTRIES) {\n                return;\n            }\n\n            unsigned int target_idx_safe = (current_head_idx - (unsigned int)cmd->historical_offset_steps + MAX_CAN_LOG_ENTRIES) % MAX_CAN_LOG_ENTRIES;\n\n            message_log_buffer[target_idx_safe] = cmd->payload_data;\n\n            break;\n        }\n        case DIAG_RETRIEVE_PAST_MESSAGE:\n            break;\n        case DIAG_GET_STATUS:\n            break;\n        case DIAG_PERFORM_CHECKSUM_CALC:\n            break;\n        default:\n            break;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_PENDING_TASKS 128\n#define TASK_DESCRIPTION_MAX_LEN 32\n\ntypedef enum {\n    TASK_STATE_IDLE,\n    TASK_STATE_PENDING,\n    TASK_STATE_RUNNING,\n    TASK_STATE_COMPLETED,\n    TASK_STATE_ERROR\n} TaskState;\n\ntypedef struct {\n    uint16_t task_id;\n    uint16_t priority;\n    TaskState state;\n    char description[TASK_DESCRIPTION_MAX_LEN];\n    void (*task_handler)(void);\n} TaskDescriptor;\n\nstatic TaskDescriptor g_task_queue[MAX_PENDING_TASKS];\nstatic uint16_t g_current_task_count = 0;\n\nvoid dummy_veh_handler(void) {\n    // Simulate some vehicle operation\n}\n\nuint16_t scheduleVehicleTask(uint16_t priority, const char* desc) {\n    if (g_current_task_count < MAX_PENDING_TASKS) {\n        g_task_queue[g_current_task_count].task_id = g_current_task_count;\n        g_task_queue[g_current_task_count].priority = priority;\n        g_task_queue[g_current_task_count].state = TASK_STATE_PENDING;\n        strncpy(g_task_queue[g_current_task_count].description, desc, TASK_DESCRIPTION_MAX_LEN - 1);\n        g_task_queue[g_current_task_count].description[TASK_DESCRIPTION_MAX_LEN - 1] = '\\0';\n        g_task_queue[g_current_task_count].task_handler = dummy_veh_handler;\n        g_current_task_count++;\n        return g_current_task_count - 1;\n    }\n    return (uint16_t)-1;\n}\n\nvoid cancelLastVehicleTasks_Vulnerable(int rollback_count) {\n    if (rollback_count <= 0) {\n        return;\n    }\n\n    // This loop intends to mark the last 'rollback_count' tasks as IDLE and clear their IDs.\n    // However, if 'rollback_count' is greater than 'g_current_task_count', the calculated\n    // 'target_idx' will become negative, leading to a buffer underwrite.\n    for (int i = 0; i < rollback_count; ++i) {\n        // g_current_task_count is unsigned, but subtraction with signed 'i' and '1'\n        // will cause implicit conversion to int, potentially resulting in a negative 'target_idx'.\n        int target_idx = (int)g_current_task_count - 1 - i;\n\n        // Buffer underwrite occurs here if target_idx is negative.\n        // Example: If g_current_task_count is 1 (meaning task at index 0 is valid),\n        // and rollback_count is 5:\n        // i=0: target_idx = 0. g_task_queue[0].state = TASK_STATE_IDLE; OK.\n        // i=1: target_idx = -1. g_task_queue[-1].state = TASK_STATE_IDLE; BUFFER UNDERWRITE!\n        // i=2: target_idx = -2. g_task_queue[-2].state = TASK_STATE_IDLE; BUFFER UNDERWRITE!\n        g_task_queue[target_idx].state = TASK_STATE_IDLE;\n        g_task_queue[target_idx].task_id = 0;\n    }\n\n    // After the loop, update the total count of active tasks.\n    // This part is conceptually separate from the loop's underwrite, but part of the overall logic.\n    if (g_current_task_count < rollback_count) {\n        g_current_task_count = 0;\n    } else {\n        g_current_task_count -= rollback_count;\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_PENDING_TASKS 128\n#define TASK_DESCRIPTION_MAX_LEN 32\n\ntypedef enum {\n    TASK_STATE_IDLE,\n    TASK_STATE_PENDING,\n    TASK_STATE_RUNNING,\n    TASK_STATE_COMPLETED,\n    TASK_STATE_ERROR\n} TaskState;\n\ntypedef struct {\n    uint16_t task_id;\n    uint16_t priority;\n    TaskState state;\n    char description[TASK_DESCRIPTION_MAX_LEN];\n    void (*task_handler)(void);\n} TaskDescriptor;\n\nstatic TaskDescriptor g_task_queue[MAX_PENDING_TASKS];\nstatic uint16_t g_current_task_count = 0;\n\nvoid dummy_veh_handler(void) {\n    // Simulate some vehicle operation\n}\n\nuint16_t scheduleVehicleTask(uint16_t priority, const char* desc) {\n    if (g_current_task_count < MAX_PENDING_TASKS) {\n        g_task_queue[g_current_task_count].task_id = g_current_task_count;\n        g_task_queue[g_current_task_count].priority = priority;\n        g_task_queue[g_current_task_count].state = TASK_STATE_PENDING;\n        strncpy(g_task_queue[g_current_task_count].description, desc, TASK_DESCRIPTION_MAX_LEN - 1);\n        g_task_queue[g_current_task_count].description[TASK_DESCRIPTION_MAX_LEN - 1] = '\\0';\n        g_task_queue[g_current_task_count].task_handler = dummy_veh_handler;\n        g_current_task_count++;\n        return g_current_task_count - 1;\n    }\n    return (uint16_t)-1;\n}\n\nvoid cancelLastVehicleTasks_Fixed(int rollback_count) {\n    if (rollback_count <= 0) {\n        return;\n    }\n\n    // Calculate the actual number of tasks to rollback, preventing underflow.\n    // This ensures that 'actual_rollback' does not exceed the number of currently active tasks,\n    // thus guaranteeing 'target_idx' remains non-negative.\n    int actual_rollback = (rollback_count > g_current_task_count) ? (int)g_current_task_count : rollback_count;\n\n    // Iterate backwards, setting task state and ID to their default/cleared values.\n    for (int i = 0; i < actual_rollback; ++i) {\n        int target_idx = (int)g_current_task_count - 1 - i;\n\n        // With 'actual_rollback' correctly clamping the loop iterations,\n        // 'target_idx' will always be within valid bounds (>= 0).\n        g_task_queue[target_idx].state = TASK_STATE_IDLE;\n        g_task_queue[target_idx].task_id = 0;\n    }\n\n    // Update the global count of active tasks based on the actual number rolled back.\n    g_current_task_count -= actual_rollback;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_VEHICLE_EVENTS 100\n#define EVENT_NAME_MAX_LEN 16\n\ntypedef enum {\n    EVENT_TYPE_NONE = 0,\n    EVENT_TYPE_SENSOR_ERROR,\n    EVENT_TYPE_DIAGNOSTIC_REQUEST,\n    EVENT_TYPE_CRITICAL_ALERT,\n    EVENT_TYPE_PERFORMANCE_LOG\n} VehicleEventType;\n\ntypedef struct {\n    VehicleEventType type;\n    uint32_t timestamp;\n    char name[EVENT_NAME_MAX_LEN];\n    uint8_t severity;\n    bool active;\n} VehicleEvent;\n\nstatic VehicleEvent vehicle_event_log[MAX_VEHICLE_EVENTS];\nstatic int next_event_idx = 0;\n\nvoid initEventLog() {\n    for (int i = 0; i < MAX_VEHICLE_EVENTS; ++i) {\n        memset(&vehicle_event_log[i], 0, sizeof(VehicleEvent));\n        vehicle_event_log[i].type = EVENT_TYPE_NONE;\n        vehicle_event_log[i].active = false;\n    }\n    next_event_idx = 0;\n}\n\nvoid addVehicleEvent(VehicleEventType type, uint32_t timestamp, const char* name, uint8_t severity) {\n    if (next_event_idx < MAX_VEHICLE_EVENTS) {\n        vehicle_event_log[next_event_idx].type = type;\n        vehicle_event_log[next_event_idx].timestamp = timestamp;\n        strncpy(vehicle_event_log[next_event_idx].name, name, EVENT_NAME_MAX_LEN - 1);\n        vehicle_event_log[next_event_idx].name[EVENT_NAME_MAX_LEN - 1] = '\\0';\n        vehicle_event_log[next_event_idx].severity = severity;\n        vehicle_event_log[next_event_idx].active = true;\n        next_event_idx++;\n    }\n}\n\nvoid promoteVehicleEvent_Vulnerable(int current_event_index, int priority_offset) {\n    if (current_event_index < 0 || current_event_index >= next_event_idx || next_event_idx == 0) {\n        return;\n    }\n\n    int target_idx = current_event_index - priority_offset;\n\n    vehicle_event_log[target_idx] = vehicle_event_log[current_event_index];\n\n    vehicle_event_log[current_event_index].active = false;\n    vehicle_event_log[current_event_index].type = EVENT_TYPE_NONE;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_VEHICLE_EVENTS 100\n#define EVENT_NAME_MAX_LEN 16\n\ntypedef enum {\n    EVENT_TYPE_NONE = 0,\n    EVENT_TYPE_SENSOR_ERROR,\n    EVENT_TYPE_DIAGNOSTIC_REQUEST,\n    EVENT_TYPE_CRITICAL_ALERT,\n    EVENT_TYPE_PERFORMANCE_LOG\n} VehicleEventType;\n\ntypedef struct {\n    VehicleEventType type;\n    uint32_t timestamp;\n    char name[EVENT_NAME_MAX_LEN];\n    uint8_t severity;\n    bool active;\n} VehicleEvent;\n\nstatic VehicleEvent vehicle_event_log[MAX_VEHICLE_EVENTS];\nstatic int next_event_idx = 0;\n\nvoid initEventLog() {\n    for (int i = 0; i < MAX_VEHICLE_EVENTS; ++i) {\n        memset(&vehicle_event_log[i], 0, sizeof(VehicleEvent));\n        vehicle_event_log[i].type = EVENT_TYPE_NONE;\n        vehicle_event_log[i].active = false;\n    }\n    next_event_idx = 0;\n}\n\nvoid addVehicleEvent(VehicleEventType type, uint32_t timestamp, const char* name, uint8_t severity) {\n    if (next_event_idx < MAX_VEHICLE_EVENTS) {\n        vehicle_event_log[next_event_idx].type = type;\n        vehicle_event_log[next_event_idx].timestamp = timestamp;\n        strncpy(vehicle_event_log[next_event_idx].name, name, EVENT_NAME_MAX_LEN - 1);\n        vehicle_event_log[next_event_idx].name[EVENT_NAME_MAX_LEN - 1] = '\\0';\n        vehicle_event_log[next_event_idx].severity = severity;\n        vehicle_event_log[next_event_idx].active = true;\n        next_event_idx++;\n    }\n}\n\nvoid promoteVehicleEvent_Fixed(int current_event_index, int priority_offset) {\n    if (current_event_index < 0 || current_event_index >= next_event_idx || next_event_idx == 0) {\n        return;\n    }\n\n    if (priority_offset < 0) {\n        priority_offset = 0;\n    }\n    \n    int target_idx = current_event_index - priority_offset;\n\n    if (target_idx < 0) {\n        target_idx = 0;\n    }\n\n    if (target_idx != current_event_index) {\n        vehicle_event_log[target_idx] = vehicle_event_log[current_event_index];\n\n        vehicle_event_log[current_event_index].active = false;\n        vehicle_event_log[current_event_index].type = EVENT_TYPE_NONE;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define SCRATCHPAD_BUFFER_SIZE 128\n#define RAW_DATA_BUFFER_SIZE 512\n\nstatic uint8_t g_raw_data_stream[RAW_DATA_BUFFER_SIZE];\nstatic uint32_t g_raw_data_len = 0;\n\nstatic int32_t g_current_record_offset = 0;\n\nvoid fill_raw_data(const uint8_t* data, uint32_t len)\n{\n    if (len > RAW_DATA_BUFFER_SIZE) {\n        len = RAW_DATA_BUFFER_SIZE;\n    }\n    memcpy(g_raw_data_stream, data, len);\n    g_raw_data_len = len;\n    g_current_record_offset = 0;\n}\n\nvoid process_extracted_record(const uint8_t* record_data, uint32_t record_len)\n{\n}\n\nbool extract_record_to_scratchpad(uint8_t* scratchpad_buffer, uint32_t scratchpad_max_len, uint32_t record_len)\n{\n    if (g_current_record_offset < 0 || g_current_record_offset + record_len > g_raw_data_len || record_len > scratchpad_max_len) {\n        return false;\n    }\n    memcpy(scratchpad_buffer, g_raw_data_stream + g_current_record_offset, record_len);\n    process_extracted_record(scratchpad_buffer, record_len);\n    return true;\n}\n\nvoid recalibrate_record_offset_vulnerable(int32_t offset_delta)\n{\n    int32_t proposed_offset = g_current_record_offset + offset_delta;\n\n    if (proposed_offset > (int32_t)g_raw_data_len) {\n        proposed_offset = (int32_t)g_raw_data_len;\n    }\n    g_raw_data_stream[proposed_offset] = 0x00;\n\n    g_current_record_offset = proposed_offset;\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define SCRATCHPAD_BUFFER_SIZE 128\n#define RAW_DATA_BUFFER_SIZE 512\n\nstatic uint8_t g_raw_data_stream[RAW_DATA_BUFFER_SIZE];\nstatic uint32_t g_raw_data_len = 0;\n\nstatic int32_t g_current_record_offset = 0;\n\nvoid fill_raw_data(const uint8_t* data, uint32_t len)\n{\n    if (len > RAW_DATA_BUFFER_SIZE) {\n        len = RAW_DATA_BUFFER_SIZE;\n    }\n    memcpy(g_raw_data_stream, data, len);\n    g_raw_data_len = len;\n    g_current_record_offset = 0;\n}\n\nvoid process_extracted_record(const uint8_t* record_data, uint32_t record_len)\n{\n}\n\nbool extract_record_to_scratchpad(uint8_t* scratchpad_buffer, uint32_t scratchpad_max_len, uint32_t record_len)\n{\n    if (g_current_record_offset < 0 || g_current_record_offset + record_len > g_raw_data_len || record_len > scratchpad_max_len) {\n        return false;\n    }\n    memcpy(scratchpad_buffer, g_raw_data_stream + g_current_record_offset, record_len);\n    process_extracted_record(scratchpad_buffer, record_len);\n    return true;\n}\n\nvoid recalibrate_record_offset_fixed(int32_t offset_delta)\n{\n    int32_t proposed_offset = g_current_record_offset + offset_delta;\n\n    if (proposed_offset < 0) {\n        proposed_offset = 0;\n    } else if (proposed_offset > (int32_t)g_raw_data_len) {\n        proposed_offset = (int32_t)g_raw_data_len;\n    }\n\n    if (g_raw_data_len > 0 && proposed_offset < (int32_t)g_raw_data_len) {\n        g_raw_data_stream[proposed_offset] = 0x00;\n    }\n\n    g_current_record_offset = proposed_offset;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define FIRMWARE_SCRATCHPAD_SIZE 1024\n\nstatic uint8_t g_firmware_scratchpad[FIRMWARE_SCRATCHPAD_SIZE];\nstatic size_t g_active_data_size = 0;\n\nvoid init_firmware_scratchpad() {\n    memset(g_firmware_scratchpad, 0xFF, FIRMWARE_SCRATCHPAD_SIZE);\n    g_active_data_size = 0;\n}\n\nbool write_firmware_block(const uint8_t* data, size_t len) {\n    if (g_active_data_size + len > FIRMWARE_SCRATCHPAD_SIZE) {\n        return false;\n    }\n    memcpy(g_firmware_scratchpad + g_active_data_size, data, len);\n    g_active_data_size += len;\n    return true;\n}\n\nvoid apply_firmware_patch_Vulnerable(const uint8_t* patch_data, size_t patch_len, int rewind_bytes) {\n    if (patch_data == NULL || patch_len == 0) {\n        return;\n    }\n\n    int target_start_offset = (int)g_active_data_size - rewind_bytes;\n\n    memcpy(g_firmware_scratchpad + target_start_offset, patch_data, patch_len);\n\n    if (target_start_offset + patch_len > g_active_data_size) {\n        g_active_data_size = target_start_offset + patch_len;\n    }\n    if (g_active_data_size > FIRMWARE_SCRATCHPAD_SIZE) {\n        g_active_data_size = FIRMWARE_SCRATCHPAD_SIZE;\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define FIRMWARE_SCRATCHPAD_SIZE 1024\n\nstatic uint8_t g_firmware_scratchpad[FIRMWARE_SCRATCHPAD_SIZE];\nstatic size_t g_active_data_size = 0;\n\nvoid init_firmware_scratchpad() {\n    memset(g_firmware_scratchpad, 0xFF, FIRMWARE_SCRATCHPAD_SIZE);\n    g_active_data_size = 0;\n}\n\nbool write_firmware_block(const uint8_t* data, size_t len) {\n    if (g_active_data_size + len > FIRMWARE_SCRATCHPAD_SIZE) {\n        return false;\n    }\n    memcpy(g_firmware_scratchpad + g_active_data_size, data, len);\n    g_active_data_size += len;\n    return true;\n}\n\nvoid apply_firmware_patch_Fixed(const uint8_t* patch_data, size_t patch_len, int rewind_bytes) {\n    if (patch_data == NULL || patch_len == 0) {\n        return;\n    }\n\n    int target_start_offset_calc = (int)g_active_data_size - rewind_bytes;\n\n    if (target_start_offset_calc < 0) {\n        target_start_offset_calc = 0;\n    }\n    \n    if ((size_t)target_start_offset_calc + patch_len > FIRMWARE_SCRATCHPAD_SIZE) {\n        return;\n    }\n\n    size_t actual_target_start_offset = (size_t)target_start_offset_calc;\n\n    memcpy(g_firmware_scratchpad + actual_target_start_offset, patch_data, patch_len);\n\n    if (actual_target_start_offset + patch_len > g_active_data_size) {\n        g_active_data_size = actual_target_start_offset + patch_len;\n    }\n    if (g_active_data_size > FIRMWARE_SCRATCHPAD_SIZE) {\n        g_active_data_size = FIRMWARE_SCRATCHPAD_SIZE;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_DATA_BUFFER_SIZE 512\n#define MAX_DIAG_FRAME_SIZE 256\n#define FRAME_LENGTH_INDICATOR_OFFSET_FROM_END 2\n\nstatic uint8_t g_diag_raw_buffer[DIAG_DATA_BUFFER_SIZE];\nstatic uint32_t g_diag_buffer_current_len = 0;\n\nvoid receiveDiagData(const uint8_t* data, uint32_t len) {\n    if (len > DIAG_DATA_BUFFER_SIZE - g_diag_buffer_current_len) {\n        len = DIAG_DATA_BUFFER_SIZE - g_diag_buffer_current_len;\n    }\n    if (len > 0) {\n        memcpy(g_diag_raw_buffer + g_diag_buffer_current_len, data, len);\n        g_diag_buffer_current_len += len;\n    }\n}\n\nvoid processDiagFrame(const uint8_t* frame_data, uint32_t frame_len) {\n    if (frame_data && frame_len > 0) {\n        volatile uint8_t check_byte = frame_data[0];\n        (void)check_byte;\n    }\n}\n\nvoid extractLastDiagFrame_Vulnerable() {\n    if (g_diag_buffer_current_len < FRAME_LENGTH_INDICATOR_OFFSET_FROM_END) {\n        return;\n    }\n\n    uint8_t frame_total_len_indicator = g_diag_raw_buffer[g_diag_buffer_current_len - FRAME_LENGTH_INDICATOR_OFFSET_FROM_END];\n\n    int start_idx_signed = (int)g_diag_buffer_current_len - frame_total_len_indicator;\n\n    uint8_t extracted_frame_buffer[MAX_DIAG_FRAME_SIZE];\n\n    if (frame_total_len_indicator > 0) {\n        g_diag_raw_buffer[start_idx_signed] = 0x00;\n    }\n\n    memcpy(extracted_frame_buffer, g_diag_raw_buffer + start_idx_signed, frame_total_len_indicator);\n    processDiagFrame(extracted_frame_buffer, frame_total_len_indicator);\n\n    g_diag_buffer_current_len -= frame_total_len_indicator;\n    if (g_diag_buffer_current_len < 0) g_diag_buffer_current_len = 0;\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_DATA_BUFFER_SIZE 512\n#define MAX_DIAG_FRAME_SIZE 256\n#define FRAME_LENGTH_INDICATOR_OFFSET_FROM_END 2\n\nstatic uint8_t g_diag_raw_buffer[DIAG_DATA_BUFFER_SIZE];\nstatic uint32_t g_diag_buffer_current_len = 0;\n\nvoid receiveDiagData(const uint8_t* data, uint32_t len) {\n    if (len > DIAG_DATA_BUFFER_SIZE - g_diag_buffer_current_len) {\n        len = DIAG_DATA_BUFFER_SIZE - g_diag_buffer_current_len;\n    }\n    if (len > 0) {\n        memcpy(g_diag_raw_buffer + g_diag_buffer_current_len, data, len);\n        g_diag_buffer_current_len += len;\n    }\n}\n\nvoid processDiagFrame(const uint8_t* frame_data, uint32_t frame_len) {\n    if (frame_data && frame_len > 0) {\n        volatile uint8_t check_byte = frame_data[0];\n        (void)check_byte;\n    }\n}\n\nvoid extractLastDiagFrame_Fixed() {\n    if (g_diag_buffer_current_len < FRAME_LENGTH_INDICATOR_OFFSET_FROM_END) {\n        return;\n    }\n\n    uint8_t frame_total_len_indicator = g_diag_raw_buffer[g_diag_buffer_current_len - FRAME_LENGTH_INDICATOR_OFFSET_FROM_END];\n\n    int start_idx_signed = (int)g_diag_buffer_current_len - frame_total_len_indicator;\n\n    if (start_idx_signed < 0) {\n        return; \n    }\n\n    if (frame_total_len_indicator > MAX_DIAG_FRAME_SIZE ||\n        (uint32_t)start_idx_signed + frame_total_len_indicator > g_diag_buffer_current_len) {\n        return;\n    }\n\n    uint32_t frame_start_idx = (uint32_t)start_idx_signed;\n\n    uint8_t extracted_frame_buffer[MAX_DIAG_FRAME_SIZE];\n\n    if (frame_total_len_indicator > 0) {\n        g_diag_raw_buffer[frame_start_idx] = 0x00;\n    }\n\n    memcpy(extracted_frame_buffer, g_diag_raw_buffer + frame_start_idx, frame_total_len_indicator);\n    processDiagFrame(extracted_frame_buffer, frame_total_len_indicator);\n\n    g_diag_buffer_current_len -= frame_total_len_indicator;\n    if (g_diag_buffer_current_len < 0) g_diag_buffer_current_len = 0;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SENSOR_READING_BUFFER_SIZE 256\n#define MAX_SENSOR_VALUE 4095\n\ntypedef struct {\n    uint16_t value;\n    uint32_t timestamp;\n    uint8_t sensor_id;\n    bool valid;\n} SensorReading;\n\nstatic SensorReading g_sensor_data_buffer[SENSOR_READING_BUFFER_SIZE];\nstatic uint16_t g_write_head_idx = 0; \nstatic bool g_buffer_wrapped = false; \n\nvoid initSensorBuffer() {\n    for (int i = 0; i < SENSOR_READING_BUFFER_SIZE; ++i) {\n        memset(&g_sensor_data_buffer[i], 0, sizeof(SensorReading));\n        g_sensor_data_buffer[i].valid = false;\n    }\n    g_write_head_idx = 0;\n    g_buffer_wrapped = false;\n}\n\nvoid addSensorReading(uint16_t value, uint8_t sensor_id, uint32_t timestamp) {\n    g_sensor_data_buffer[g_write_head_idx].value = value;\n    g_sensor_data_buffer[g_write_head_idx].timestamp = timestamp;\n    g_sensor_data_buffer[g_write_head_idx].sensor_id = sensor_id;\n    g_sensor_data_buffer[g_write_head_idx].valid = true;\n\n    g_write_head_idx++;\n    if (g_write_head_idx >= SENSOR_READING_BUFFER_SIZE) {\n        g_write_head_idx = 0;\n        g_buffer_wrapped = true;\n    }\n}\n\nvoid adjustHistoricalSensorReading_Vulnerable(int32_t backward_offset_steps, uint16_t new_value) {\n    if (g_write_head_idx == 0 && !g_buffer_wrapped) {\n        return;\n    }\n\n    uint16_t last_written_actual_idx;\n    if (g_write_head_idx == 0 && g_buffer_wrapped) {\n        last_written_actual_idx = SENSOR_READING_BUFFER_SIZE - 1;\n    } else if (g_write_head_idx > 0) {\n        last_written_actual_idx = g_write_head_idx - 1;\n    } else {\n        return;\n    }\n\n    SensorReading* target_ptr = &g_sensor_data_buffer[last_written_actual_idx];\n\n    target_ptr -= backward_offset_steps;\n\n    target_ptr->value = new_value;\n    target_ptr->valid = true;\n}\n",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SENSOR_READING_BUFFER_SIZE 256\n#define MAX_SENSOR_VALUE 4095\n\ntypedef struct {\n    uint16_t value;\n    uint32_t timestamp;\n    uint8_t sensor_id;\n    bool valid;\n} SensorReading;\n\nstatic SensorReading g_sensor_data_buffer[SENSOR_READING_BUFFER_SIZE];\nstatic uint16_t g_write_head_idx = 0; \nstatic bool g_buffer_wrapped = false; \n\nvoid initSensorBuffer() {\n    for (int i = 0; i < SENSOR_READING_BUFFER_SIZE; ++i) {\n        memset(&g_sensor_data_buffer[i], 0, sizeof(SensorReading));\n        g_sensor_data_buffer[i].valid = false;\n    }\n    g_write_head_idx = 0;\n    g_buffer_wrapped = false;\n}\n\nvoid addSensorReading(uint16_t value, uint8_t sensor_id, uint32_t timestamp) {\n    g_sensor_data_buffer[g_write_head_idx].value = value;\n    g_sensor_data_buffer[g_write_head_idx].timestamp = timestamp;\n    g_sensor_data_buffer[g_write_head_idx].sensor_id = sensor_id;\n    g_sensor_data_buffer[g_write_head_idx].valid = true;\n\n    g_write_head_idx++;\n    if (g_write_head_idx >= SENSOR_READING_BUFFER_SIZE) {\n        g_write_head_idx = 0;\n        g_buffer_wrapped = true;\n    }\n}\n\nvoid adjustHistoricalSensorReading_Fixed(int32_t backward_offset_steps, uint16_t new_value) {\n    if (g_write_head_idx == 0 && !g_buffer_wrapped) {\n        return;\n    }\n\n    if (backward_offset_steps < 0) {\n        return;\n    }\n\n    uint16_t last_written_actual_idx;\n    if (g_write_head_idx == 0 && g_buffer_wrapped) {\n        last_written_actual_idx = SENSOR_READING_BUFFER_SIZE - 1;\n    } else if (g_write_head_idx > 0) {\n        last_written_actual_idx = g_write_head_idx - 1;\n    } else {\n        return;\n    }\n\n    uint16_t valid_entries_count = g_buffer_wrapped ? SENSOR_READING_BUFFER_SIZE : g_write_head_idx;\n\n    if (backward_offset_steps >= valid_entries_count) {\n        return;\n    }\n\n    uint16_t target_idx = (last_written_actual_idx - backward_offset_steps + SENSOR_READING_BUFFER_SIZE) % SENSOR_READING_BUFFER_SIZE;\n\n    g_sensor_data_buffer[target_idx].value = new_value;\n    g_sensor_data_buffer[target_idx].valid = true;\n}\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_DTC_HISTORY 64\n#define DTC_CODE_LEN 6\n\ntypedef struct {\n    char code[DTC_CODE_LEN];\n    uint32_t timestamp_ms;\n    bool active;\n    uint8_t severity;\n} DTC_Entry;\n\nstatic DTC_Entry dtc_history_buffer[MAX_DTC_HISTORY];\nstatic int dtc_history_count = 0;\n\nvoid add_dtc_to_history(const char* dtc_code, uint32_t timestamp, uint8_t severity) {\n    if (dtc_history_count < MAX_DTC_HISTORY) {\n        strncpy(dtc_history_buffer[dtc_history_count].code, dtc_code, DTC_CODE_LEN);\n        dtc_history_buffer[dtc_history_count].code[DTC_CODE_LEN - 1] = '\\0';\n        dtc_history_buffer[dtc_history_count].timestamp_ms = timestamp;\n        dtc_history_buffer[dtc_history_count].active = false;\n        dtc_history_buffer[dtc_history_count].severity = severity;\n        dtc_history_count++;\n    }\n}\n\nvoid revert_last_dtc_clears_Vulnerable(int num_to_revert) {\n    if (num_to_revert <= 0) {\n        return;\n    }\n\n    for (int i = 0; i < num_to_revert; ++i) {\n        int target_idx = dtc_history_count - 1 - i;\n        dtc_history_buffer[target_idx].active = true;\n        dtc_history_buffer[target_idx].severity = 0xFF;\n    }\n\n    if (dtc_history_count < num_to_revert) {\n        dtc_history_count = 0;\n    } else {\n        dtc_history_count -= num_to_revert;\n    }\n}\n\nDTC_Entry* get_dtc_history_entry(int index) {\n    if (index >= 0 && index < dtc_history_count) {\n        return &dtc_history_buffer[index];\n    }\n    return NULL;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_DTC_HISTORY 64\n#define DTC_CODE_LEN 6\n\ntypedef struct {\n    char code[DTC_CODE_LEN];\n    uint32_t timestamp_ms;\n    bool active;\n    uint8_t severity;\n} DTC_Entry;\n\nstatic DTC_Entry dtc_history_buffer[MAX_DTC_HISTORY];\nstatic int dtc_history_count = 0;\n\nvoid add_dtc_to_history(const char* dtc_code, uint32_t timestamp, uint8_t severity) {\n    if (dtc_history_count < MAX_DTC_HISTORY) {\n        strncpy(dtc_history_buffer[dtc_history_count].code, dtc_code, DTC_CODE_LEN);\n        dtc_history_buffer[dtc_history_count].code[DTC_CODE_LEN - 1] = '\\0';\n        dtc_history_buffer[dtc_history_count].timestamp_ms = timestamp;\n        dtc_history_buffer[dtc_history_count].active = false;\n        dtc_history_buffer[dtc_history_count].severity = severity;\n        dtc_history_count++;\n    }\n}\n\nvoid revert_last_dtc_clears_Fixed(int num_to_revert) {\n    if (num_to_revert <= 0) {\n        return;\n    }\n\n    int actual_revert_count = num_to_revert;\n    if (actual_revert_count > dtc_history_count) {\n        actual_revert_count = dtc_history_count;\n    }\n    \n    for (int i = 0; i < actual_revert_count; ++i) {\n        int target_idx = dtc_history_count - 1 - i;\n        dtc_history_buffer[target_idx].active = true;\n        dtc_history_buffer[target_idx].severity = 0xFF;\n    }\n\n    dtc_history_count -= actual_revert_count;\n    if (dtc_history_count < 0) {\n        dtc_history_count = 0;\n    }\n}\n\nDTC_Entry* get_dtc_history_entry(int index) {\n    if (index >= 0 && index < dtc_history_count) {\n        return &dtc_history_buffer[index];\n    }\n    return NULL;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define EVENT_LOG_BUFFER_SIZE 32\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp_ms;\n    bool processed;\n    uint8_t severity;\n} VehicleEventLogEntry;\n\nstatic VehicleEventLogEntry g_event_log[EVENT_LOG_BUFFER_SIZE];\nstatic uint16_t g_log_write_ptr = 0;\nstatic uint16_t g_num_logged_events = 0;\n\nvoid init_event_log() {\n    for (int i = 0; i < EVENT_LOG_BUFFER_SIZE; ++i) {\n        memset(&g_event_log[i], 0, sizeof(VehicleEventLogEntry));\n        g_event_log[i].processed = false;\n    }\n    g_log_write_ptr = 0;\n    g_num_logged_events = 0;\n}\n\nvoid add_event_log_entry(uint16_t id, uint32_t timestamp, uint8_t severity) {\n    if (g_num_logged_events < EVENT_LOG_BUFFER_SIZE) {\n        g_num_logged_events++;\n    }\n    g_event_log[g_log_write_ptr].event_id = id;\n    g_event_log[g_log_write_ptr].timestamp_ms = timestamp;\n    g_event_log[g_log_write_ptr].processed = false;\n    g_event_log[g_log_write_ptr].severity = severity;\n    g_log_write_ptr = (g_log_write_ptr + 1) % EVENT_LOG_BUFFER_SIZE;\n}\n\nvoid mark_event_processed_vulnerable(uint16_t steps_back) {\n    if (g_num_logged_events == 0) {\n        return;\n    }\n\n    int last_event_idx = (g_log_write_ptr == 0) ? (EVENT_LOG_BUFFER_SIZE - 1) : (g_log_write_ptr - 1);\n\n    int target_raw_idx = last_event_idx - steps_back;\n\n    g_event_log[target_raw_idx].processed = true;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define EVENT_LOG_BUFFER_SIZE 32\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp_ms;\n    bool processed;\n    uint8_t severity;\n} VehicleEventLogEntry;\n\nstatic VehicleEventLogEntry g_event_log[EVENT_LOG_BUFFER_SIZE];\nstatic uint16_t g_log_write_ptr = 0;\nstatic uint16_t g_num_logged_events = 0;\n\nvoid init_event_log() {\n    for (int i = 0; i < EVENT_LOG_BUFFER_SIZE; ++i) {\n        memset(&g_event_log[i], 0, sizeof(VehicleEventLogEntry));\n        g_event_log[i].processed = false;\n    }\n    g_log_write_ptr = 0;\n    g_num_logged_events = 0;\n}\n\nvoid add_event_log_entry(uint16_t id, uint32_t timestamp, uint8_t severity) {\n    if (g_num_logged_events < EVENT_LOG_BUFFER_SIZE) {\n        g_num_logged_events++;\n    }\n    g_event_log[g_log_write_ptr].event_id = id;\n    g_event_log[g_log_write_ptr].timestamp_ms = timestamp;\n    g_event_log[g_log_write_ptr].processed = false;\n    g_event_log[g_log_write_ptr].severity = severity;\n    g_log_write_ptr = (g_log_write_ptr + 1) % EVENT_LOG_BUFFER_SIZE;\n}\n\nvoid mark_event_processed_fixed(uint16_t steps_back) {\n    if (g_num_logged_events == 0) {\n        return;\n    }\n\n    int last_event_idx = (g_log_write_ptr == 0) ? (EVENT_LOG_BUFFER_SIZE - 1) : (g_log_write_ptr - 1);\n\n    int target_raw_idx = last_event_idx - steps_back;\n\n    if (target_raw_idx < 0 || steps_back >= g_num_logged_events) {\n        return;\n    }\n\n    uint16_t actual_target_idx = (uint16_t)target_raw_idx;\n    \n    g_event_log[actual_target_idx].processed = true;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#define DATA_BUFFER_SIZE 256\n\nstatic uint8_t g_data_buffer[DATA_BUFFER_SIZE];\nstatic size_t g_data_stored_len = 0;\n\nvoid initialize_data_buffer() {\n    for (size_t i = 0; i < DATA_BUFFER_SIZE; ++i) {\n        g_data_buffer[i] = 0;\n    }\n    g_data_stored_len = 0;\n}\n\nbool append_data_block(const uint8_t* data, size_t len) {\n    if (g_data_stored_len + len > DATA_BUFFER_SIZE) {\n        return false;\n    }\n    for (size_t i = 0; i < len; ++i) {\n        g_data_buffer[g_data_stored_len + i] = data[i];\n    }\n    g_data_stored_len += len;\n    return true;\n}\n\nvoid process_data_block_status_vulnerable(int32_t relative_offset) {\n    if (g_data_stored_len == 0) {\n        return;\n    }\n\n    int32_t target_idx = (int32_t)g_data_stored_len - 1 + relative_offset;\n\n    g_data_buffer[target_idx] = 0xFF;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#define DATA_BUFFER_SIZE 256\n\nstatic uint8_t g_data_buffer[DATA_BUFFER_SIZE];\nstatic size_t g_data_stored_len = 0;\n\nvoid initialize_data_buffer() {\n    for (size_t i = 0; i < DATA_BUFFER_SIZE; ++i) {\n        g_data_buffer[i] = 0;\n    }\n    g_data_stored_len = 0;\n}\n\nbool append_data_block(const uint8_t* data, size_t len) {\n    if (g_data_stored_len + len > DATA_BUFFER_SIZE) {\n        return false;\n    }\n    for (size_t i = 0; i < len; ++i) {\n        g_data_buffer[g_data_stored_len + i] = data[i];\n    }\n    g_data_stored_len += len;\n    return true;\n}\n\nvoid process_data_block_status_fixed(int32_t relative_offset) {\n    if (g_data_stored_len == 0) {\n        return;\n    }\n\n    int32_t target_idx = (int32_t)g_data_stored_len - 1 + relative_offset;\n\n    if (target_idx < 0 || target_idx >= (int32_t)g_data_stored_len) {\n        return;\n    }\n    \n    g_data_buffer[target_idx] = 0xFF;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAG_HISTORY_CAPACITY 50\n#define DIAG_REQ_DATA_MAX_SIZE 24\n\ntypedef struct {\n    uint32_t request_id;\n    uint32_t timestamp_ms;\n    uint8_t  request_data[DIAG_REQ_DATA_MAX_SIZE];\n    uint8_t  data_len;\n    bool     processed;\n} DiagRequestEntry;\n\nstatic DiagRequestEntry g_diag_history[DIAG_HISTORY_CAPACITY];\nstatic size_t g_current_history_size = 0;\n\nvoid init_diag_history() {\n    memset(g_diag_history, 0, sizeof(g_diag_history));\n    g_current_history_size = 0;\n}\n\nvoid add_diag_request(uint32_t id, uint32_t timestamp, const uint8_t* data, uint8_t len) {\n    if (g_current_history_size < DIAG_HISTORY_CAPACITY) {\n        DiagRequestEntry* target_entry = &g_diag_history[g_current_history_size];\n        target_entry->request_id = id;\n        target_entry->timestamp_ms = timestamp;\n        uint8_t actual_len = (len > DIAG_REQ_DATA_MAX_SIZE) ? DIAG_REQ_DATA_MAX_SIZE : len;\n        memcpy(target_entry->request_data, data, actual_len);\n        target_entry->data_len = actual_len;\n        target_entry->processed = false;\n        g_current_history_size++;\n    }\n}\n\nvoid archive_recent_diag_requests_vulnerable(uint16_t steps_to_archive) {\n    if (g_current_history_size == 0 || steps_to_archive == 0) {\n        return;\n    }\n\n    DiagRequestEntry* current_entry_ptr = &g_diag_history[g_current_history_size - 1];\n\n    for (uint16_t i = 0; i < steps_to_archive; ++i) {\n        current_entry_ptr->processed = true;\n        memset(current_entry_ptr->request_data, 0, DIAG_REQ_DATA_MAX_SIZE);\n        current_entry_ptr--;\n    }\n\n    if (g_current_history_size < steps_to_archive) {\n        g_current_history_size = 0;\n    } else {\n        g_current_history_size -= steps_to_archive;\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAG_HISTORY_CAPACITY 50\n#define DIAG_REQ_DATA_MAX_SIZE 24\n\ntypedef struct {\n    uint32_t request_id;\n    uint32_t timestamp_ms;\n    uint8_t  request_data[DIAG_REQ_DATA_MAX_SIZE];\n    uint8_t  data_len;\n    bool     processed;\n} DiagRequestEntry;\n\nstatic DiagRequestEntry g_diag_history[DIAG_HISTORY_CAPACITY];\nstatic size_t g_current_history_size = 0;\n\nvoid init_diag_history() {\n    memset(g_diag_history, 0, sizeof(g_diag_history));\n    g_current_history_size = 0;\n}\n\nvoid add_diag_request(uint32_t id, uint32_t timestamp, const uint8_t* data, uint8_t len) {\n    if (g_current_history_size < DIAG_HISTORY_CAPACITY) {\n        DiagRequestEntry* target_entry = &g_diag_history[g_current_history_size];\n        target_entry->request_id = id;\n        target_entry->timestamp_ms = timestamp;\n        uint8_t actual_len = (len > DIAG_REQ_DATA_MAX_SIZE) ? DIAG_REQ_DATA_MAX_SIZE : len;\n        memcpy(target_entry->request_data, data, actual_len);\n        target_entry->data_len = actual_len;\n        target_entry->processed = false;\n        g_current_history_size++;\n    }\n}\n\nvoid archive_recent_diag_requests_fixed(uint16_t steps_to_archive) {\n    if (g_current_history_size == 0 || steps_to_archive == 0) {\n        return;\n    }\n\n    uint16_t actual_steps_to_archive = (steps_to_archive > g_current_history_size) ? (uint16_t)g_current_history_size : steps_to_archive;\n\n    DiagRequestEntry* current_entry_ptr = &g_diag_history[g_current_history_size - 1];\n\n    for (uint16_t i = 0; i < actual_steps_to_archive; ++i) {\n        current_entry_ptr->processed = true;\n        memset(current_entry_ptr->request_data, 0, DIAG_REQ_DATA_MAX_SIZE);\n        current_entry_ptr--;\n    }\n\n    g_current_history_size -= actual_steps_to_archive;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n// Define sizes for buffers and maximums\n#define MAX_COMMAND_PAYLOAD_SIZE 128\n#define COMMAND_FRAME_HEADER_SIZE (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t)) // command_id + payload_length + reserved_byte\n#define COMMAND_BUFFER_TOTAL_SIZE 256 // Total buffer for received raw command data\n\n// Structure representing the layout of a diagnostic command frame\n// This is used for interpretation of the raw byte stream\ntypedef struct {\n    uint16_t command_id;      // Unique identifier for the command\n    uint8_t  payload_length;  // Actual length of the payload data\n    uint8_t  reserved_byte;   // Reserved for future use or alignment\n    // The 'payload' and 'final_status_marker' fields are conceptual for layout.\n    // The actual payload size varies, and final_status_marker is placed based on payload_length.\n    uint8_t  payload[MAX_COMMAND_PAYLOAD_SIZE]; // Placeholder for payload data\n    uint8_t  final_status_marker; // A byte that's expected to be written at the end of the payload section\n} DiagnosticCommandFrame;\n\n// Global buffer to hold raw received command data\nstatic uint8_t g_rx_command_buffer[COMMAND_BUFFER_TOTAL_SIZE];\n// Current valid length of data in g_rx_command_buffer\nstatic uint32_t g_rx_data_length = 0;\n\n// Function to simulate receiving raw command data into the buffer\nvoid receive_raw_command(const uint8_t* data, uint32_t len) {\n    if (len > COMMAND_BUFFER_TOTAL_SIZE) {\n        len = COMMAND_BUFFER_TOTAL_SIZE;\n    }\n    memcpy(g_rx_command_buffer, data, len);\n    g_rx_data_length = len;\n}\n\n// Dummy function to simulate processing a command frame\nvoid process_parsed_command(const DiagnosticCommandFrame* frame) {\n    // In a real system, this would parse and execute the command logic\n    // For demonstration, we just access a member to avoid unused variable warnings\n    volatile uint16_t cmd_id = frame->command_id;\n    (void)cmd_id;\n}\n\n// Vulnerable function: Updates a status byte at a calculated position relative to the end of the command's payload.\n// The 'external_status_offset' is provided by a higher layer, potentially influenced by external input.\n// The vulnerability arises if 'external_status_offset' is large enough to make the calculated\n// target index negative, leading to a buffer underwrite.\nvoid update_command_final_status_vulnerable(uint8_t status_value, uint8_t external_status_offset) {\n    // Ensure at least header size is present before accessing frame fields\n    if (g_rx_data_length < COMMAND_FRAME_HEADER_SIZE) {\n        return;\n    }\n\n    // Cast the raw buffer to the frame structure for easier field access\n    DiagnosticCommandFrame* current_frame = (DiagnosticCommandFrame*)g_rx_command_buffer;\n\n    // Get the effective payload length from the received command data. This value is attacker-controlled.\n    uint8_t effective_payload_len = current_frame->payload_length;\n\n    // Calculate the intended base position for the status byte:\n    // This is the start of the buffer + size of header + effective payload length.\n    // From this base, 'external_status_offset' moves the write position backwards.\n    // Example: If payload_length is 0, base_pos is COMMAND_FRAME_HEADER_SIZE (4 bytes).\n    // If external_status_offset is 5, target_idx becomes 4 - 5 = -1.\n    // No bounds check on effective_payload_len or the resulting target_idx.\n    int32_t target_idx = (int32_t)(COMMAND_FRAME_HEADER_SIZE + effective_payload_len) - external_status_offset;\n\n    // Perform the write operation directly to the raw buffer.\n    // This is where the buffer underwrite occurs if target_idx is negative.\n    g_rx_command_buffer[target_idx] = status_value;\n\n    // Simulate subsequent command processing\n    process_parsed_command(current_frame);\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMAND_PAYLOAD_SIZE 128\n#define COMMAND_FRAME_HEADER_SIZE (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t))\n#define COMMAND_BUFFER_TOTAL_SIZE 256\n\ntypedef struct {\n    uint16_t command_id;\n    uint8_t  payload_length;\n    uint8_t  reserved_byte;\n    uint8_t  payload[MAX_COMMAND_PAYLOAD_SIZE];\n    uint8_t  final_status_marker;\n} DiagnosticCommandFrame;\n\nstatic uint8_t g_rx_command_buffer[COMMAND_BUFFER_TOTAL_SIZE];\nstatic uint32_t g_rx_data_length = 0;\n\nvoid receive_raw_command(const uint8_t* data, uint32_t len) {\n    if (len > COMMAND_BUFFER_TOTAL_SIZE) {\n        len = COMMAND_BUFFER_TOTAL_SIZE;\n    }\n    memcpy(g_rx_command_buffer, data, len);\n    g_rx_data_length = len;\n}\n\nvoid process_parsed_command(const DiagnosticCommandFrame* frame) {\n    volatile uint16_t cmd_id = frame->command_id;\n    (void)cmd_id;\n}\n\n// Fixed function: Prevents buffer underwrite by validating the calculated target index.\nvoid update_command_final_status_fixed(uint8_t status_value, uint8_t external_status_offset) {\n    if (g_rx_data_length < COMMAND_FRAME_HEADER_SIZE) {\n        return;\n    }\n\n    DiagnosticCommandFrame* current_frame = (DiagnosticCommandFrame*)g_rx_command_buffer;\n    uint8_t effective_payload_len = current_frame->payload_length;\n\n    // Sanitize effective_payload_len to prevent calculations beyond valid data\n    // and ensure the calculated base position doesn't exceed the buffer bounds\n    if (effective_payload_len > MAX_COMMAND_PAYLOAD_SIZE ||\n        (COMMAND_FRAME_HEADER_SIZE + effective_payload_len) > g_rx_data_length) {\n        // The frame is malformed or incomplete, cannot safely determine end of payload\n        return;\n    }\n\n    int32_t base_pos = (int32_t)(COMMAND_FRAME_HEADER_SIZE + effective_payload_len);\n    int32_t target_idx = base_pos - external_status_offset;\n\n    // CRITICAL FIX: Validate target_idx to prevent buffer underwrite or overflow.\n    // target_idx must be non-negative and within the bounds of the currently received data.\n    if (target_idx < 0 || target_idx >= (int32_t)g_rx_data_length) {\n        return; // Prevent out-of-bounds access\n    }\n\n    g_rx_command_buffer[target_idx] = status_value;\n\n    process_parsed_command(current_frame);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_PACKET_BUFFER_SIZE 512\n#define MIN_PACKET_HEADER_SIZE 8\n\nstatic uint8_t g_rx_packet_buffer[MAX_PACKET_BUFFER_SIZE];\nstatic uint32_t g_current_rx_data_len = 0;\n\ntypedef struct {\n    uint16_t packet_id;\n    uint8_t  packet_type;\n    uint8_t  flags;\n    uint16_t payload_length;\n    int16_t  checksum_offset;\n} PacketHeaderStruct;\n\nvoid receive_raw_packet_data(const uint8_t* data, uint32_t len) {\n    if (len > MAX_PACKET_BUFFER_SIZE) {\n        len = MAX_PACKET_BUFFER_SIZE;\n    }\n    memcpy(g_rx_packet_buffer, data, len);\n    g_current_rx_data_len = len;\n}\n\nvoid process_packet_payload(uint8_t* payload, uint16_t len) {\n    if (len > 0) {\n        volatile uint8_t first_byte = payload[0];\n        (void)first_byte;\n    }\n}\n\nvoid finalize_and_process_packet_vulnerable(void) {\n    if (g_current_rx_data_len < MIN_PACKET_HEADER_SIZE) {\n        return;\n    }\n\n    PacketHeaderStruct* header = (PacketHeaderStruct*)g_rx_packet_buffer;\n\n    uint16_t effective_payload_len = header->payload_length;\n    int16_t effective_checksum_offset = header->checksum_offset;\n\n    if (sizeof(PacketHeaderStruct) + effective_payload_len > g_current_rx_data_len ||\n        sizeof(PacketHeaderStruct) + effective_payload_len > MAX_PACKET_BUFFER_SIZE) {\n        return;\n    }\n    \n    uint8_t calculated_checksum = 0xAA;\n\n    int32_t target_byte_index = effective_checksum_offset;\n\n    g_rx_packet_buffer[target_byte_index] = calculated_checksum;\n\n    process_packet_payload(g_rx_packet_buffer + sizeof(PacketHeaderStruct), effective_payload_len);\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_PACKET_BUFFER_SIZE 512\n#define MIN_PACKET_HEADER_SIZE 8\n\nstatic uint8_t g_rx_packet_buffer[MAX_PACKET_BUFFER_SIZE];\nstatic uint32_t g_current_rx_data_len = 0;\n\ntypedef struct {\n    uint16_t packet_id;\n    uint8_t  packet_type;\n    uint8_t  flags;\n    uint16_t payload_length;\n    int16_t  checksum_offset;\n} PacketHeaderStruct;\n\nvoid receive_raw_packet_data(const uint8_t* data, uint32_t len) {\n    if (len > MAX_PACKET_BUFFER_SIZE) {\n        len = MAX_PACKET_BUFFER_SIZE;\n    }\n    memcpy(g_rx_packet_buffer, data, len);\n    g_current_rx_data_len = len;\n}\n\nvoid process_packet_payload(uint8_t* payload, uint16_t len) {\n    if (len > 0) {\n        volatile uint8_t first_byte = payload[0];\n        (void)first_byte;\n    }\n}\n\nvoid finalize_and_process_packet_fixed(void) {\n    if (g_current_rx_data_len < MIN_PACKET_HEADER_SIZE) {\n        return;\n    }\n\n    PacketHeaderStruct* header = (PacketHeaderStruct*)g_rx_packet_buffer;\n\n    uint16_t effective_payload_len = header->payload_length;\n    int16_t effective_checksum_offset = header->checksum_offset;\n\n    if (sizeof(PacketHeaderStruct) + effective_payload_len > g_current_rx_data_len ||\n        sizeof(PacketHeaderStruct) + effective_payload_len > MAX_PACKET_BUFFER_SIZE) {\n        return;\n    }\n    \n    uint8_t calculated_checksum = 0xAA;\n\n    int32_t target_byte_index = effective_checksum_offset;\n\n    if (target_byte_index < 0 || target_byte_index >= (int32_t)g_current_rx_data_len) {\n        return;\n    }\n\n    g_rx_packet_buffer[target_byte_index] = calculated_checksum;\n\n    process_packet_payload(g_rx_packet_buffer + sizeof(PacketHeaderStruct), effective_payload_len);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_FAULT_ENTRIES 64\n#define DTC_CODE_LEN 6 \n\ntypedef enum {\n    FAULT_STATUS_ACTIVE,\n    FAULT_STATUS_CLEARED,\n    FAULT_STATUS_HISTORY\n} FaultStatus;\n\ntypedef struct {\n    char dtc_code[DTC_CODE_LEN + 1]; \n    uint32_t timestamp;\n    uint8_t severity;\n    FaultStatus status;\n} FaultEntry;\n\nstatic FaultEntry g_fault_log[MAX_FAULT_ENTRIES];\nstatic int g_fault_count = 0; \nstatic int g_write_ptr = 0; \n\nvoid init_fault_log() {\n    for (int i = 0; i < MAX_FAULT_ENTRIES; ++i) {\n        memset(&g_fault_log[i], 0, sizeof(FaultEntry));\n        g_fault_log[i].status = FAULT_STATUS_CLEARED;\n    }\n    g_fault_count = 0;\n    g_write_ptr = 0;\n}\n\nvoid log_dtc(const char* dtc, uint32_t timestamp, uint8_t severity) {\n    strncpy(g_fault_log[g_write_ptr].dtc_code, dtc, DTC_CODE_LEN);\n    g_fault_log[g_write_ptr].dtc_code[DTC_CODE_LEN] = '\\0';\n    g_fault_log[g_write_ptr].timestamp = timestamp;\n    g_fault_log[g_write_ptr].severity = severity;\n    g_fault_log[g_write_ptr].status = FAULT_STATUS_ACTIVE;\n\n    g_write_ptr = (g_write_ptr + 1) % MAX_FAULT_ENTRIES;\n    if (g_fault_count < MAX_FAULT_ENTRIES) {\n        g_fault_count++;\n    }\n}\n\nvoid revert_last_faults_vulnerable(int num_to_revert) {\n    if (num_to_revert <= 0) {\n        return;\n    }\n\n    if (g_fault_count == 0) {\n        return;\n    }\n\n    int current_tail_idx = (g_write_ptr - 1 + MAX_FAULT_ENTRIES) % MAX_FAULT_ENTRIES;\n\n    for (int i = 0; i < num_to_revert; ++i) {\n        \n        int target_idx_vulnerable = current_tail_idx - i;\n\n        g_fault_log[target_idx_vulnerable].status = FAULT_STATUS_CLEARED;\n        memset(g_fault_log[target_idx_vulnerable].dtc_code, 0, DTC_CODE_LEN + 1);\n        g_fault_log[target_idx_vulnerable].timestamp = 0;\n        g_fault_log[target_idx_vulnerable].severity = 0;\n\n        if (g_fault_count > 0) {\n            g_fault_count--;\n        } else {\n            g_fault_count = 0;\n        }\n    }\n\n    g_write_ptr = (g_write_ptr - num_to_revert + MAX_FAULT_ENTRIES) % MAX_FAULT_ENTRIES;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_FAULT_ENTRIES 64\n#define DTC_CODE_LEN 6 \n\ntypedef enum {\n    FAULT_STATUS_ACTIVE,\n    FAULT_STATUS_CLEARED,\n    FAULT_STATUS_HISTORY\n} FaultStatus;\n\ntypedef struct {\n    char dtc_code[DTC_CODE_LEN + 1]; \n    uint32_t timestamp;\n    uint8_t severity;\n    FaultStatus status;\n} FaultEntry;\n\nstatic FaultEntry g_fault_log[MAX_FAULT_ENTRIES];\nstatic int g_fault_count = 0; \nstatic int g_write_ptr = 0; \n\nvoid init_fault_log() {\n    for (int i = 0; i < MAX_FAULT_ENTRIES; ++i) {\n        memset(&g_fault_log[i], 0, sizeof(FaultEntry));\n        g_fault_log[i].status = FAULT_STATUS_CLEARED;\n    }\n    g_fault_count = 0;\n    g_write_ptr = 0;\n}\n\nvoid log_dtc(const char* dtc, uint32_t timestamp, uint8_t severity) {\n    strncpy(g_fault_log[g_write_ptr].dtc_code, dtc, DTC_CODE_LEN);\n    g_fault_log[g_write_ptr].dtc_code[DTC_CODE_LEN] = '\\0';\n    g_fault_log[g_write_ptr].timestamp = timestamp;\n    g_fault_log[g_write_ptr].severity = severity;\n    g_fault_log[g_write_ptr].status = FAULT_STATUS_ACTIVE;\n\n    g_write_ptr = (g_write_ptr + 1) % MAX_FAULT_ENTRIES;\n    if (g_fault_count < MAX_FAULT_ENTRIES) {\n        g_fault_count++;\n    }\n}\n\nvoid revert_last_faults_fixed(int num_to_revert) {\n    if (num_to_revert <= 0) {\n        return;\n    }\n\n    if (g_fault_count == 0) {\n        return;\n    }\n\n    int actual_num_to_revert = (num_to_revert > g_fault_count) ? g_fault_count : num_to_revert;\n\n    int start_clear_idx = (g_write_ptr - 1 + MAX_FAULT_ENTRIES) % MAX_FAULT_ENTRIES;\n\n    for (int i = 0; i < actual_num_to_revert; ++i) {\n        int target_idx_fixed = (start_clear_idx - i + MAX_FAULT_ENTRIES) % MAX_FAULT_ENTRIES;\n\n        g_fault_log[target_idx_fixed].status = FAULT_STATUS_CLEARED;\n        memset(g_fault_log[target_idx_fixed].dtc_code, 0, DTC_CODE_LEN + 1);\n        g_fault_log[target_idx_fixed].timestamp = 0;\n        g_fault_log[target_idx_fixed].severity = 0;\n    }\n\n    g_write_ptr = (g_write_ptr - actual_num_to_revert + MAX_FAULT_ENTRIES) % MAX_FAULT_ENTRIES;\n    g_fault_count -= actual_num_to_revert;\n    if (g_fault_count < 0) {\n        g_fault_count = 0;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define LOG_CONTEXT_BUFFER_SIZE 64\n#define LOG_ENTRY_FOOTPRINT_SIZE 4\n\nstatic uint8_t g_log_context_buffer[LOG_CONTEXT_BUFFER_SIZE];\nstatic uint32_t g_current_log_end_ptr_offset = 0;\n\nvoid init_log_context() {\n    memset(g_log_context_buffer, 0, LOG_CONTEXT_BUFFER_SIZE);\n    g_current_log_end_ptr_offset = 0;\n}\n\nbool add_log_context_entry(uint32_t entry_value) {\n    if (g_current_log_end_ptr_offset + LOG_ENTRY_FOOTPRINT_SIZE > LOG_CONTEXT_BUFFER_SIZE) {\n        g_current_log_end_ptr_offset = 0;\n    }\n    g_log_context_buffer[g_current_log_end_ptr_offset + 0] = (uint8_t)(entry_value >> 24);\n    g_log_context_buffer[g_current_log_end_ptr_offset + 1] = (uint8_t)(entry_value >> 16);\n    g_log_context_buffer[g_current_log_end_ptr_offset + 2] = (uint8_t)(entry_value >> 8);\n    g_log_context_buffer[g_current_log_end_ptr_offset + 3] = (uint8_t)(entry_value);\n\n    g_current_log_end_ptr_offset += LOG_ENTRY_FOOTPRINT_SIZE;\n    return true;\n}\n\nvoid update_historical_log_context_vulnerable(int16_t offset_from_current, uint32_t new_context_value) {\n    if (g_current_log_end_ptr_offset == 0) {\n        return;\n    }\n    \n    int32_t target_byte_offset = (int32_t)g_current_log_end_ptr_offset - (offset_from_current * LOG_ENTRY_FOOTPRINT_SIZE);\n\n    g_log_context_buffer[target_byte_offset + 0] = (uint8_t)(new_context_value >> 24);\n    g_log_context_buffer[target_byte_offset + 1] = (uint8_t)(new_context_value >> 16);\n    g_log_context_buffer[target_byte_offset + 2] = (uint8_t)(new_context_value >> 8);\n    g_log_context_buffer[target_byte_offset + 3] = (uint8_t)(new_context_value);\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define LOG_CONTEXT_BUFFER_SIZE 64\n#define LOG_ENTRY_FOOTPRINT_SIZE 4\n\nstatic uint8_t g_log_context_buffer[LOG_CONTEXT_BUFFER_SIZE];\nstatic uint32_t g_current_log_end_ptr_offset = 0;\n\nvoid init_log_context_fixed() {\n    memset(g_log_context_buffer, 0, LOG_CONTEXT_BUFFER_SIZE);\n    g_current_log_end_ptr_offset = 0;\n}\n\nbool add_log_context_entry_fixed(uint32_t entry_value) {\n    if (g_current_log_end_ptr_offset + LOG_ENTRY_FOOTPRINT_SIZE > LOG_CONTEXT_BUFFER_SIZE) {\n        g_current_log_end_ptr_offset = 0;\n    }\n    g_log_context_buffer[g_current_log_end_ptr_offset + 0] = (uint8_t)(entry_value >> 24);\n    g_log_context_buffer[g_current_log_end_ptr_offset + 1] = (uint8_t)(entry_value >> 16);\n    g_log_context_buffer[g_current_log_end_ptr_offset + 2] = (uint8_t)(entry_value >> 8);\n    g_log_context_buffer[g_current_log_end_ptr_offset + 3] = (uint8_t)(entry_value);\n\n    g_current_log_end_ptr_offset += LOG_ENTRY_FOOTPRINT_SIZE;\n    return true;\n}\n\nvoid update_historical_log_context_fixed(int16_t offset_from_current, uint32_t new_context_value) {\n    if (g_current_log_end_ptr_offset == 0) {\n        return;\n    }\n\n    int32_t potential_target_byte_offset = (int32_t)g_current_log_end_ptr_offset - (offset_from_current * LOG_ENTRY_FOOTPRINT_SIZE);\n\n    if (potential_target_byte_offset < 0) {\n        return;\n    }\n\n    uint32_t target_byte_offset = (uint32_t)potential_target_byte_offset;\n\n    if (target_byte_offset + LOG_ENTRY_FOOTPRINT_SIZE > LOG_CONTEXT_BUFFER_SIZE) {\n        return;\n    }\n    \n    g_log_context_buffer[target_byte_offset + 0] = (uint8_t)(new_context_value >> 24);\n    g_log_context_buffer[target_byte_offset + 1] = (uint8_t)(new_context_value >> 16);\n    g_log_context_buffer[target_byte_offset + 2] = (uint8_t)(new_context_value >> 8);\n    g_log_context_buffer[target_byte_offset + 3] = (uint8_t)(new_context_value);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define LOG_BUFFER_SIZE 32\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t event_id;\n    uint8_t severity;\n    bool active;\n    uint8_t data[4];\n} VehicleLogEntry;\n\nstatic VehicleLogEntry g_vehicle_event_log[LOG_BUFFER_SIZE];\nstatic uint32_t g_write_head_idx = 0;\nstatic uint32_t g_num_active_entries = 0;\n\nvoid init_vehicle_log() {\n    for (uint32_t i = 0; i < LOG_BUFFER_SIZE; ++i) {\n        memset(&g_vehicle_event_log[i], 0, sizeof(VehicleLogEntry));\n        g_vehicle_event_log[i].active = false;\n    }\n    g_write_head_idx = 0;\n    g_num_active_entries = 0;\n}\n\nvoid add_log_entry(uint16_t event_id, uint8_t severity, const uint8_t* data, uint32_t timestamp) {\n    g_vehicle_event_log[g_write_head_idx].timestamp_ms = timestamp;\n    g_vehicle_event_log[g_write_head_idx].event_id = event_id;\n    g_vehicle_event_log[g_write_head_idx].severity = severity;\n    g_vehicle_event_log[g_write_head_idx].active = true;\n    if (data) {\n        memcpy(g_vehicle_event_log[g_write_head_idx].data, data, sizeof(g_vehicle_event_log[g_write_head_idx].data));\n    }\n\n    g_write_head_idx = (g_write_head_idx + 1) % LOG_BUFFER_SIZE;\n    if (g_num_active_entries < LOG_BUFFER_SIZE) {\n        g_num_active_entries++;\n    }\n}\n\nvoid update_historical_log_status_vulnerable(int relative_offset_from_newest, bool new_active_status) {\n    if (g_num_active_entries == 0) {\n        return;\n    }\n\n    int newest_entry_absolute_idx = (int)g_write_head_idx - 1;\n    if (newest_entry_absolute_idx < 0) {\n        newest_entry_absolute_idx = LOG_BUFFER_SIZE - 1;\n    }\n\n    int target_log_idx_signed = newest_entry_absolute_idx - relative_offset_from_newest;\n\n    g_vehicle_event_log[target_log_idx_signed].active = new_active_status;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define LOG_BUFFER_SIZE 32\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t event_id;\n    uint8_t severity;\n    bool active;\n    uint8_t data[4];\n} VehicleLogEntry;\n\nstatic VehicleLogEntry g_vehicle_event_log[LOG_BUFFER_SIZE];\nstatic uint32_t g_write_head_idx = 0;\nstatic uint32_t g_num_active_entries = 0;\n\nvoid init_vehicle_log_fixed() {\n    for (uint32_t i = 0; i < LOG_BUFFER_SIZE; ++i) {\n        memset(&g_vehicle_event_log[i], 0, sizeof(VehicleLogEntry));\n        g_vehicle_event_log[i].active = false;\n    }\n    g_write_head_idx = 0;\n    g_num_active_entries = 0;\n}\n\nvoid add_log_entry_fixed(uint16_t event_id, uint8_t severity, const uint8_t* data, uint32_t timestamp) {\n    g_vehicle_event_log[g_write_head_idx].timestamp_ms = timestamp;\n    g_vehicle_event_log[g_write_head_idx].event_id = event_id;\n    g_vehicle_event_log[g_write_head_idx].severity = severity;\n    g_vehicle_event_log[g_write_head_idx].active = true;\n    if (data) {\n        memcpy(g_vehicle_event_log[g_write_head_idx].data, data, sizeof(g_vehicle_event_log[g_write_head_idx].data));\n    }\n\n    g_write_head_idx = (g_write_head_idx + 1) % LOG_BUFFER_SIZE;\n    if (g_num_active_entries < LOG_BUFFER_SIZE) {\n        g_num_active_entries++;\n    }\n}\n\nvoid update_historical_log_status_fixed(int relative_offset_from_newest, bool new_active_status) {\n    if (g_num_active_entries == 0) {\n        return;\n    }\n\n    if (relative_offset_from_newest < 0 || (uint32_t)relative_offset_from_newest >= g_num_active_entries) {\n        return;\n    }\n\n    int newest_entry_absolute_idx = (int)g_write_head_idx - 1;\n    if (newest_entry_absolute_idx < 0) {\n        newest_entry_absolute_idx = LOG_BUFFER_SIZE - 1;\n    }\n\n    int target_log_idx = (newest_entry_absolute_idx - relative_offset_from_newest + LOG_BUFFER_SIZE) % LOG_BUFFER_SIZE;\n\n    g_vehicle_event_log[target_log_idx].active = new_active_status;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_SENSORS 8\n#define SENSOR_HISTORY_BUFFER_SIZE 10\n\ntypedef struct {\n    uint16_t sensor_id;\n    int32_t readings[SENSOR_HISTORY_BUFFER_SIZE];\n    uint8_t current_idx;\n    uint8_t count;\n} SensorHistory;\n\nstatic SensorHistory g_sensor_data_history[MAX_SENSORS];\n\nvoid init_sensor_history() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        g_sensor_data_history[i].sensor_id = (uint16_t)-1;\n        memset(g_sensor_data_history[i].readings, 0, sizeof(g_sensor_data_history[i].readings));\n        g_sensor_data_history[i].current_idx = 0;\n        g_sensor_data_history[i].count = 0;\n    }\n}\n\nbool add_sensor_reading_to_history(uint16_t sensor_id, int32_t reading) {\n    int sensor_idx = -1;\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        if (g_sensor_data_history[i].sensor_id == sensor_id || g_sensor_data_history[i].sensor_id == (uint16_t)-1) {\n            sensor_idx = i;\n            if (g_sensor_data_history[i].sensor_id == (uint16_t)-1) {\n                g_sensor_data_history[i].sensor_id = sensor_id;\n            }\n            break;\n        }\n    }\n\n    if (sensor_idx == -1) {\n        return false;\n    }\n\n    SensorHistory* history = &g_sensor_data_history[sensor_idx];\n    history->readings[history->current_idx] = reading;\n    history->current_idx = (history->current_idx + 1) % SENSOR_HISTORY_BUFFER_SIZE;\n    if (history->count < SENSOR_HISTORY_BUFFER_SIZE) {\n        history->count++;\n    }\n    return true;\n}\n\nvoid update_historical_reading_vulnerable(uint16_t sensor_id, int32_t offset_from_current, int32_t new_value) {\n    int sensor_idx = -1;\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        if (g_sensor_data_history[i].sensor_id == sensor_id) {\n            sensor_idx = i;\n            break;\n        }\n    }\n\n    if (sensor_idx == -1) {\n        return;\n    }\n\n    SensorHistory* history = &g_sensor_data_history[sensor_idx];\n\n    if (history->count == 0) {\n        return;\n    }\n\n    int32_t effective_last_idx = (history->current_idx == 0) ? (SENSOR_HISTORY_BUFFER_SIZE - 1) : (history->current_idx - 1);\n\n    int32_t target_raw_idx = effective_last_idx - offset_from_current;\n\n    history->readings[target_raw_idx] = new_value;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_SENSORS 8\n#define SENSOR_HISTORY_BUFFER_SIZE 10\n\ntypedef struct {\n    uint16_t sensor_id;\n    int32_t readings[SENSOR_HISTORY_BUFFER_SIZE];\n    uint8_t current_idx;\n    uint8_t count;\n} SensorHistory;\n\nstatic SensorHistory g_sensor_data_history[MAX_SENSORS];\n\nvoid init_sensor_history_fixed() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        g_sensor_data_history[i].sensor_id = (uint16_t)-1;\n        memset(g_sensor_data_history[i].readings, 0, sizeof(g_sensor_data_history[i].readings));\n        g_sensor_data_history[i].current_idx = 0;\n        g_sensor_data_history[i].count = 0;\n    }\n}\n\nbool add_sensor_reading_to_history_fixed(uint16_t sensor_id, int32_t reading) {\n    int sensor_idx = -1;\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        if (g_sensor_data_history[i].sensor_id == sensor_id || g_sensor_data_history[i].sensor_id == (uint16_t)-1) {\n            sensor_idx = i;\n            if (g_sensor_data_history[i].sensor_id == (uint16_t)-1) {\n                g_sensor_data_history[i].sensor_id = sensor_id;\n            }\n            break;\n        }\n    }\n\n    if (sensor_idx == -1) {\n        return false;\n    }\n\n    SensorHistory* history = &g_sensor_data_history[sensor_idx];\n    history->readings[history->current_idx] = reading;\n    history->current_idx = (history->current_idx + 1) % SENSOR_HISTORY_BUFFER_SIZE;\n    if (history->count < SENSOR_HISTORY_BUFFER_SIZE) {\n        history->count++;\n    }\n    return true;\n}\n\nvoid update_historical_reading_fixed(uint16_t sensor_id, int32_t offset_from_current, int32_t new_value) {\n    int sensor_idx = -1;\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        if (g_sensor_data_history[i].sensor_id == sensor_id) {\n            sensor_idx = i;\n            break;\n        }\n    }\n\n    if (sensor_idx == -1) {\n        return;\n    }\n\n    SensorHistory* history = &g_sensor_data_history[sensor_idx];\n\n    if (history->count == 0) {\n        return;\n    }\n\n    if (offset_from_current < 0 || offset_from_current >= history->count) {\n        return;\n    }\n\n    int32_t effective_last_idx = (history->current_idx == 0) ? (SENSOR_HISTORY_BUFFER_SIZE - 1) : (history->current_idx - 1);\n\n    int32_t target_idx_calc = effective_last_idx - offset_from_current;\n    int32_t target_idx = (target_idx_calc + SENSOR_HISTORY_BUFFER_SIZE) % SENSOR_HISTORY_BUFFER_SIZE;\n\n    history->readings[target_idx] = new_value;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_SENSOR_READINGS 100\n\ntypedef struct {\n    uint16_t value;\n    uint16_t timestamp_ms;\n} SensorReading;\n\nstatic SensorReading g_sensor_readings_buffer[MAX_SENSOR_READINGS];\nstatic uint32_t g_num_readings_stored = 0;\n\nvoid init_sensor_buffer() {\n    memset(g_sensor_readings_buffer, 0, sizeof(g_sensor_readings_buffer));\n    g_num_readings_stored = 0;\n}\n\nvoid add_sensor_reading(uint16_t value, uint16_t timestamp) {\n    if (g_num_readings_stored < MAX_SENSOR_READINGS) {\n        g_sensor_readings_buffer[g_num_readings_stored].value = value;\n        g_sensor_readings_buffer[g_num_readings_stored].timestamp_ms = timestamp;\n        g_num_readings_stored++;\n    }\n}\n\nvoid process_reading(SensorReading* reading) {\n    if (reading != NULL) {\n        volatile uint16_t val = reading->value;\n        (void)val;\n    }\n}\n\nvoid invalidate_old_sensor_readings_vulnerable(uint32_t offset_from_end, uint32_t num_to_invalidate) {\n    if (g_num_readings_stored == 0 || num_to_invalidate == 0) {\n        return;\n    }\n\n    // Calculate the starting pointer for invalidation.\n    // 'g_num_readings_stored - 1' gives the index of the last valid reading.\n    // Subtracting 'offset_from_end' from this pointer can cause it to point\n    // before the beginning of the 'g_sensor_readings_buffer' array if 'offset_from_end'\n    // is greater than the current valid range.\n    SensorReading* current_ptr = &g_sensor_readings_buffer[g_num_readings_stored - 1];\n    current_ptr -= offset_from_end; // VULNERABILITY: 'current_ptr' can become negative (underflow) here.\n\n    // Iterate 'num_to_invalidate' times, writing to the potentially underflowed pointer.\n    // If 'current_ptr' is before the buffer, these writes will be buffer underwrites.\n    for (uint32_t i = 0; i < num_to_invalidate; ++i) {\n        // The write occurs here. If 'current_ptr' points before the buffer,\n        // this operation will underwrite memory.\n        current_ptr->value = 0xDEAD;       \n        current_ptr->timestamp_ms = 0xDEFE;\n        current_ptr++;                     \n    }\n\n    // Adjust the number of stored readings based on what was *intended* to be invalidated.\n    // This part is conceptually separate from the underwrite, but part of the overall logic.\n    if (g_num_readings_stored > (offset_from_end + num_to_invalidate)) {\n        g_num_readings_stored -= (offset_from_end + num_to_invalidate);\n    } else {\n        g_num_readings_stored = 0;\n    }\n\n    if (g_num_readings_stored > 0) {\n        process_reading(&g_sensor_readings_buffer[0]);\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_SENSOR_READINGS 100\n\ntypedef struct {\n    uint16_t value;\n    uint16_t timestamp_ms;\n} SensorReading;\n\nstatic SensorReading g_sensor_readings_buffer[MAX_SENSOR_READINGS];\nstatic uint32_t g_num_readings_stored = 0;\n\nvoid init_sensor_buffer() {\n    memset(g_sensor_readings_buffer, 0, sizeof(g_sensor_readings_buffer));\n    g_num_readings_stored = 0;\n}\n\nvoid add_sensor_reading(uint16_t value, uint16_t timestamp) {\n    if (g_num_readings_stored < MAX_SENSOR_READINGS) {\n        g_sensor_readings_buffer[g_num_readings_stored].value = value;\n        g_sensor_readings_buffer[g_num_readings_stored].timestamp_ms = timestamp;\n        g_num_readings_stored++;\n    }\n}\n\nvoid process_reading(SensorReading* reading) {\n    if (reading != NULL) {\n        volatile uint16_t val = reading->value;\n        (void)val;\n    }\n}\n\nvoid invalidate_old_sensor_readings_fixed(uint32_t offset_from_end, uint32_t num_to_invalidate) {\n    if (g_num_readings_stored == 0 || num_to_invalidate == 0) {\n        return;\n    }\n\n    // Determine the actual starting index for invalidation.\n    // Ensure 'actual_start_idx' does not go below zero by clamping 'offset_from_end'.\n    uint32_t actual_start_idx;\n    if (offset_from_end >= g_num_readings_stored) {\n        actual_start_idx = 0; // If offset is too large, start from the very beginning of valid data.\n    } else {\n        actual_start_idx = g_num_readings_stored - offset_from_end; // Calculate valid start index.\n    }\n\n    // Determine the actual number of elements to invalidate from 'actual_start_idx'.\n    // This ensures we don't try to invalidate more elements than are available from 'actual_start_idx' to the end of valid data.\n    uint32_t available_from_start_idx = g_num_readings_stored - actual_start_idx;\n    uint32_t actual_num_to_invalidate = (num_to_invalidate > available_from_start_idx) ? available_from_start_idx : num_to_invalidate;\n\n    // Perform invalidation within the validated range.\n    for (uint32_t i = 0; i < actual_num_to_invalidate; ++i) {\n        // Access is now guaranteed to be within [0, g_num_readings_stored - 1],\n        // preventing buffer underwrite.\n        g_sensor_readings_buffer[actual_start_idx + i].value = 0xDEAD;       \n        g_sensor_readings_buffer[actual_start_idx + i].timestamp_ms = 0xDEFE;\n    }\n\n    // Adjust the number of stored readings to reflect the actual truncation.\n    g_num_readings_stored = actual_start_idx; \n\n    if (g_num_readings_stored > 0) {\n        process_reading(&g_sensor_readings_buffer[0]);\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_MAX_SIZE 256\n#define CONFIG_CHUNK_SIZE 16\n\nstatic uint8_t g_vehicle_config_store[VEHICLE_CONFIG_MAX_SIZE];\nstatic size_t g_current_config_size = 0;\n\nvoid init_vehicle_config_store() {\n    memset(g_vehicle_config_store, 0xFF, VEHICLE_CONFIG_MAX_SIZE);\n    g_current_config_size = 0;\n}\n\nbool write_config_chunk(const uint8_t* data, size_t len) {\n    if (len == 0 || len > CONFIG_CHUNK_SIZE || g_current_config_size + len > VEHICLE_CONFIG_MAX_SIZE) {\n        return false;\n    }\n    memcpy(g_vehicle_config_store + g_current_config_size, data, len);\n    g_current_config_size += len;\n    return true;\n}\n\nvoid purge_config_segment_Vulnerable(int16_t offset_chunks_from_end, uint16_t chunks_to_purge) {\n    if (g_current_config_size == 0 || chunks_to_purge == 0) {\n        return;\n    }\n\n    int32_t total_bytes_to_clear = (int32_t)chunks_to_purge * CONFIG_CHUNK_SIZE;\n\n    int32_t start_byte_to_clear = (int32_t)g_current_config_size - ((int32_t)offset_chunks_from_end * CONFIG_CHUNK_SIZE) - total_bytes_to_clear;\n\n    for (int32_t i = 0; i < total_bytes_to_clear; ++i) {\n        g_vehicle_config_store[start_byte_to_clear + i] = 0x00;\n    }\n}\n",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_MAX_SIZE 256\n#define CONFIG_CHUNK_SIZE 16\n\nstatic uint8_t g_vehicle_config_store[VEHICLE_CONFIG_MAX_SIZE];\nstatic size_t g_current_config_size = 0;\n\nvoid init_vehicle_config_store_fixed() {\n    memset(g_vehicle_config_store, 0xFF, VEHICLE_CONFIG_MAX_SIZE);\n    g_current_config_size = 0;\n}\n\nbool write_config_chunk_fixed(const uint8_t* data, size_t len) {\n    if (len == 0 || len > CONFIG_CHUNK_SIZE || g_current_config_size + len > VEHICLE_CONFIG_MAX_SIZE) {\n        return false;\n    }\n    memcpy(g_vehicle_config_store + g_current_config_size, data, len);\n    g_current_config_size += len;\n    return true;\n}\n\nvoid purge_config_segment_Fixed(int16_t offset_chunks_from_end, uint16_t chunks_to_purge) {\n    if (g_current_config_size == 0 || chunks_to_purge == 0) {\n        return;\n    }\n\n    int32_t total_bytes_to_clear = (int32_t)chunks_to_purge * CONFIG_CHUNK_SIZE;\n\n    int32_t potential_start_byte_to_clear = (int32_t)g_current_config_size - ((int32_t)offset_chunks_from_end * CONFIG_CHUNK_SIZE) - total_bytes_to_clear;\n\n    if (potential_start_byte_to_clear < 0) {\n        return;\n    }\n\n    if (potential_start_byte_to_clear + total_bytes_to_clear > g_current_config_size) {\n        total_bytes_to_clear = g_current_config_size - potential_start_byte_to_clear;\n        if (total_bytes_to_clear <= 0) return;\n    }\n\n    for (int32_t i = 0; i < total_bytes_to_clear; ++i) {\n        g_vehicle_config_store[potential_start_byte_to_clear + i] = 0x00;\n    }\n}\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CONFIG_LOG_BUFFER_SIZE 128\n#define CONFIG_ENTRY_SIZE 8 \n\nstatic uint8_t g_config_log_buffer[CONFIG_LOG_BUFFER_SIZE];\nstatic uint32_t g_log_current_offset = 0; \n\nvoid init_config_log() {\n    memset(g_config_log_buffer, 0, CONFIG_LOG_BUFFER_SIZE);\n    g_log_current_offset = 0;\n}\n\nbool log_config_state(uint64_t state_value) {\n    if (g_log_current_offset + CONFIG_ENTRY_SIZE > CONFIG_LOG_BUFFER_SIZE) {\n        return false;\n    }\n    g_config_log_buffer[g_log_current_offset + 0] = (uint8_t)(state_value);\n    g_config_log_buffer[g_log_current_offset + 1] = (uint8_t)(state_value >> 8);\n    g_config_log_buffer[g_log_current_offset + 2] = (uint8_t)(state_value >> 16);\n    g_config_log_buffer[g_log_current_offset + 3] = (uint8_t)(state_value >> 24);\n    g_config_log_buffer[g_log_current_offset + 4] = (uint8_t)(state_value >> 32);\n    g_config_log_buffer[g_log_current_offset + 5] = (uint8_t)(state_value >> 40);\n    g_config_log_buffer[g_log_current_offset + 6] = (uint8_t)(state_value >> 48);\n    g_config_log_buffer[g_log_current_offset + 7] = (uint8_t)(state_value >> 56);\n    g_log_current_offset += CONFIG_ENTRY_SIZE;\n    return true;\n}\n\nvoid revert_and_mark_config_state_vulnerable(uint32_t entry_count_to_revert, uint8_t marker_value) {\n    if (g_log_current_offset == 0) {\n        return;\n    }\n\n    uint32_t bytes_to_revert = entry_count_to_revert * CONFIG_ENTRY_SIZE;\n\n    int32_t target_byte_offset = (int32_t)g_log_current_offset - (int32_t)bytes_to_revert;\n\n    if (target_byte_offset < 0) {\n        g_log_current_offset = 0;\n    } else {\n        g_log_current_offset = (uint32_t)target_byte_offset;\n    }\n\n    g_config_log_buffer[target_byte_offset - 1] = marker_value;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CONFIG_LOG_BUFFER_SIZE 128\n#define CONFIG_ENTRY_SIZE 8 \n\nstatic uint8_t g_config_log_buffer[CONFIG_LOG_BUFFER_SIZE];\nstatic uint32_t g_log_current_offset = 0; \n\nvoid init_config_log_fixed() {\n    memset(g_config_log_buffer, 0, CONFIG_LOG_BUFFER_SIZE);\n    g_log_current_offset = 0;\n}\n\nbool log_config_state_fixed(uint64_t state_value) {\n    if (g_log_current_offset + CONFIG_ENTRY_SIZE > CONFIG_LOG_BUFFER_SIZE) {\n        return false;\n    }\n    g_config_log_buffer[g_log_current_offset + 0] = (uint8_t)(state_value);\n    g_config_log_buffer[g_log_current_offset + 1] = (uint8_t)(state_value >> 8);\n    g_config_log_buffer[g_log_current_offset + 2] = (uint8_t)(state_value >> 16);\n    g_config_log_buffer[g_log_current_offset + 3] = (uint8_t)(state_value >> 24);\n    g_config_log_buffer[g_log_current_offset + 4] = (uint8_t)(state_value >> 32);\n    g_config_log_buffer[g_log_current_offset + 5] = (uint8_t)(state_value >> 40);\n    g_config_log_buffer[g_log_current_offset + 6] = (uint8_t)(state_value >> 48);\n    g_config_log_buffer[g_log_current_offset + 7] = (uint8_t)(state_value >> 56);\n    g_log_current_offset += CONFIG_ENTRY_SIZE;\n    return true;\n}\n\nvoid revert_and_mark_config_state_fixed(uint32_t entry_count_to_revert, uint8_t marker_value) {\n    if (g_log_current_offset == 0) {\n        return;\n    }\n\n    uint32_t bytes_to_revert = entry_count_to_revert * CONFIG_ENTRY_SIZE;\n\n    int32_t potential_target_byte_offset = (int32_t)g_log_current_offset - (int32_t)bytes_to_revert;\n\n    if (potential_target_byte_offset < 0) {\n        g_log_current_offset = 0;\n    } else {\n        g_log_current_offset = (uint32_t)potential_target_byte_offset;\n    }\n\n    int32_t marker_idx = potential_target_byte_offset - 1;\n    if (marker_idx >= 0 && (uint32_t)marker_idx < CONFIG_LOG_BUFFER_SIZE) {\n        g_config_log_buffer[marker_idx] = marker_value;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SENSOR_DATA_BUFFER_SIZE 32\n#define MAX_SENSOR_VALUE 1023\n\ntypedef struct {\n    uint16_t value;\n    uint32_t timestamp_ms;\n    uint8_t  status_flags;\n} SensorSample;\n\nstatic SensorSample g_sensor_data_buffer[SENSOR_DATA_BUFFER_SIZE];\nstatic uint8_t g_next_write_idx = 0;\nstatic bool g_buffer_full = false;\n\nvoid init_sensor_data_buffer() {\n    memset(g_sensor_data_buffer, 0, sizeof(g_sensor_data_buffer));\n    g_next_write_idx = 0;\n    g_buffer_full = false;\n}\n\nvoid add_sensor_sample(uint16_t value, uint32_t timestamp, uint8_t flags) {\n    g_sensor_data_buffer[g_next_write_idx].value = value;\n    g_sensor_data_buffer[g_next_write_idx].timestamp_ms = timestamp;\n    g_sensor_data_buffer[g_next_write_idx].status_flags = flags;\n\n    g_next_write_idx = (g_next_write_idx + 1) % SENSOR_DATA_BUFFER_SIZE;\n    if (g_next_write_idx == 0) {\n        g_buffer_full = true;\n    }\n}\n\nvoid update_historical_sensor_value_vulnerable(int32_t sample_offset_from_last, uint16_t new_value) {\n    if (!g_buffer_full && g_next_write_idx == 0) {\n        return;\n    }\n\n    int32_t last_sample_idx = (g_next_write_idx == 0 && g_buffer_full) ?\n                              (SENSOR_DATA_BUFFER_SIZE - 1) :\n                              (g_next_write_idx - 1);\n\n    int32_t target_idx = last_sample_idx - sample_offset_from_last;\n\n    g_sensor_data_buffer[target_idx].value = new_value;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SENSOR_DATA_BUFFER_SIZE 32\n#define MAX_SENSOR_VALUE 1023\n\ntypedef struct {\n    uint16_t value;\n    uint32_t timestamp_ms;\n    uint8_t  status_flags;\n} SensorSample;\n\nstatic SensorSample g_sensor_data_buffer_fixed[SENSOR_DATA_BUFFER_SIZE];\nstatic uint8_t g_next_write_idx_fixed = 0;\nstatic bool g_buffer_full_fixed = false;\n\nvoid init_sensor_data_buffer_fixed() {\n    memset(g_sensor_data_buffer_fixed, 0, sizeof(g_sensor_data_buffer_fixed));\n    g_next_write_idx_fixed = 0;\n    g_buffer_full_fixed = false;\n}\n\nvoid add_sensor_sample_fixed(uint16_t value, uint32_t timestamp, uint8_t flags) {\n    g_sensor_data_buffer_fixed[g_next_write_idx_fixed].value = value;\n    g_sensor_data_buffer_fixed[g_next_write_idx_fixed].timestamp_ms = timestamp;\n    g_sensor_data_buffer_fixed[g_next_write_idx_fixed].status_flags = flags;\n\n    g_next_write_idx_fixed = (g_next_write_idx_fixed + 1) % SENSOR_DATA_BUFFER_SIZE;\n    if (g_next_write_idx_fixed == 0) {\n        g_buffer_full_fixed = true;\n    }\n}\n\nvoid update_historical_sensor_value_fixed(int32_t sample_offset_from_last, uint16_t new_value) {\n    if (!g_buffer_full_fixed && g_next_write_idx_fixed == 0) {\n        return;\n    }\n\n    int32_t last_sample_idx = (g_next_write_idx_fixed == 0 && g_buffer_full_fixed) ?\n                              (SENSOR_DATA_BUFFER_SIZE - 1) :\n                              (g_next_write_idx_fixed - 1);\n\n    int32_t current_samples_count = g_buffer_full_fixed ? SENSOR_DATA_BUFFER_SIZE : g_next_write_idx_fixed;\n\n    if (sample_offset_from_last < 0 || sample_offset_from_last >= current_samples_count) {\n        return;\n    }\n\n    int32_t target_idx = (last_sample_idx - sample_offset_from_last + SENSOR_DATA_BUFFER_SIZE) % SENSOR_DATA_BUFFER_SIZE;\n\n    g_sensor_data_buffer_fixed[target_idx].value = new_value;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define VEHICLE_SENSOR_HISTORY_SIZE 10\n\ntypedef struct {\n    uint16_t sensor_id;\n    int32_t value;\n    uint32_t timestamp_ms;\n    bool valid;\n} VehicleSensorReading;\n\nstatic VehicleSensorReading g_sensor_history_buffer[VEHICLE_SENSOR_HISTORY_SIZE];\nstatic uint8_t g_history_head_idx = 0;\nstatic uint8_t g_history_count = 0;\n\nvoid init_sensor_history_buffer() {\n    for (uint8_t i = 0; i < VEHICLE_SENSOR_HISTORY_SIZE; ++i) {\n        memset(&g_sensor_history_buffer[i], 0, sizeof(VehicleSensorReading));\n        g_sensor_history_buffer[i].valid = false;\n    }\n    g_history_head_idx = 0;\n    g_history_count = 0;\n}\n\nbool add_sensor_reading(uint16_t sensor_id, int32_t value, uint32_t timestamp_ms) {\n    g_sensor_history_buffer[g_history_head_idx].sensor_id = sensor_id;\n    g_sensor_history_buffer[g_history_head_idx].value = value;\n    g_sensor_history_buffer[g_history_head_idx].timestamp_ms = timestamp_ms;\n    g_sensor_history_buffer[g_history_head_idx].valid = true;\n\n    g_history_head_idx = (g_history_head_idx + 1) % VEHICLE_SENSOR_HISTORY_SIZE;\n    if (g_history_count < VEHICLE_SENSOR_HISTORY_SIZE) {\n        g_history_count++;\n    }\n    return true;\n}\n\nvoid invalidate_n_last_readings_vulnerable(int8_t num_to_invalidate) {\n    if (g_history_count == 0 || num_to_invalidate <= 0) {\n        return;\n    }\n\n    int16_t start_logical_idx = (int16_t)g_history_head_idx - num_to_invalidate;\n\n    for (int8_t i = 0; i < num_to_invalidate; ++i) {\n        g_sensor_history_buffer[start_logical_idx + i].valid = false;\n        g_sensor_history_buffer[start_logical_idx + i].value = 0;\n    }\n\n    if (num_to_invalidate >= g_history_count) {\n        g_history_count = 0;\n        g_history_head_idx = 0;\n    } else {\n        g_history_count -= num_to_invalidate;\n        g_history_head_idx = (g_history_head_idx - num_to_invalidate + VEHICLE_SENSOR_HISTORY_SIZE) % VEHICLE_SENSOR_HISTORY_SIZE;\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define VEHICLE_SENSOR_HISTORY_SIZE 10\n\ntypedef struct {\n    uint16_t sensor_id;\n    int32_t value;\n    uint32_t timestamp_ms;\n    bool valid;\n} VehicleSensorReading;\n\nstatic VehicleSensorReading g_sensor_history_buffer[VEHICLE_SENSOR_HISTORY_SIZE];\nstatic uint8_t g_history_head_idx = 0;\nstatic uint8_t g_history_count = 0;\n\nvoid init_sensor_history_buffer_fixed() {\n    for (uint8_t i = 0; i < VEHICLE_SENSOR_HISTORY_SIZE; ++i) {\n        memset(&g_sensor_history_buffer[i], 0, sizeof(VehicleSensorReading));\n        g_sensor_history_buffer[i].valid = false;\n    }\n    g_history_head_idx = 0;\n    g_history_count = 0;\n}\n\nbool add_sensor_reading_fixed(uint16_t sensor_id, int32_t value, uint32_t timestamp_ms) {\n    g_sensor_history_buffer[g_history_head_idx].sensor_id = sensor_id;\n    g_sensor_history_buffer[g_history_head_idx].value = value;\n    g_sensor_history_buffer[g_history_head_idx].timestamp_ms = timestamp_ms;\n    g_sensor_history_buffer[g_history_head_idx].valid = true;\n\n    g_history_head_idx = (g_history_head_idx + 1) % VEHICLE_SENSOR_HISTORY_SIZE;\n    if (g_history_count < VEHICLE_SENSOR_HISTORY_SIZE) {\n        g_history_count++;\n    }\n    return true;\n}\n\nvoid invalidate_n_last_readings_fixed(int8_t num_to_invalidate) {\n    if (g_history_count == 0 || num_to_invalidate <= 0) {\n        return;\n    }\n\n    int8_t actual_to_invalidate = (num_to_invalidate > g_history_count) ? g_history_count : num_to_invalidate;\n\n    for (int8_t i = 1; i <= actual_to_invalidate; ++i) {\n        uint8_t target_idx = (g_history_head_idx - i + VEHICLE_SENSOR_HISTORY_SIZE) % VEHICLE_SENSOR_HISTORY_SIZE;\n        g_sensor_history_buffer[target_idx].valid = false;\n        g_sensor_history_buffer[target_idx].value = 0;\n    }\n\n    g_history_count -= actual_to_invalidate;\n    g_history_head_idx = (g_history_head_idx - actual_to_invalidate + VEHICLE_SENSOR_HISTORY_SIZE) % VEHICLE_SENSOR_HISTORY_SIZE;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 256\n\nstatic uint8_t g_vehicle_config_data[VEHICLE_CONFIG_BUFFER_SIZE];\nstatic uint16_t g_active_config_segment_base_idx = 0;\n\nvoid init_vehicle_config() {\n    memset(g_vehicle_config_data, 0xFF, VEHICLE_CONFIG_BUFFER_SIZE);\n    g_active_config_segment_base_idx = 0;\n}\n\nbool set_active_config_segment(uint16_t segment_id) {\n    if (segment_id == 0x01) {\n        g_active_config_segment_base_idx = 0;\n    } else if (segment_id == 0x02) {\n        g_active_config_segment_base_idx = 50;\n    } else if (segment_id == 0x03) {\n        g_active_config_segment_base_idx = 120;\n    } else {\n        return false;\n    }\n    return true;\n}\n\nvoid update_config_segment_vulnerable(int16_t relative_start_offset, const uint8_t* data, uint16_t data_len) {\n    if (data == NULL || data_len == 0) {\n        return;\n    }\n\n    int32_t target_abs_idx = (int32_t)g_active_config_segment_base_idx + relative_start_offset;\n\n    if (target_abs_idx + data_len > VEHICLE_CONFIG_BUFFER_SIZE || data_len > VEHICLE_CONFIG_BUFFER_SIZE) {\n        return;\n    }\n\n    memcpy(&g_vehicle_config_data[target_abs_idx], data, data_len);\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 256\n\nstatic uint8_t g_vehicle_config_data_fixed[VEHICLE_CONFIG_BUFFER_SIZE];\nstatic uint16_t g_active_config_segment_base_idx_fixed = 0;\n\nvoid init_vehicle_config_fixed() {\n    memset(g_vehicle_config_data_fixed, 0xFF, VEHICLE_CONFIG_BUFFER_SIZE);\n    g_active_config_segment_base_idx_fixed = 0;\n}\n\nbool set_active_config_segment_fixed(uint16_t segment_id) {\n    if (segment_id == 0x01) {\n        g_active_config_segment_base_idx_fixed = 0;\n    } else if (segment_id == 0x02) {\n        g_active_config_segment_base_idx_fixed = 50;\n    } else if (segment_id == 0x03) {\n        g_active_config_segment_base_idx_fixed = 120;\n    } else {\n        return false;\n    }\n    return true;\n}\n\nvoid update_config_segment_fixed(int16_t relative_start_offset, const uint8_t* data, uint16_t data_len) {\n    if (data == NULL || data_len == 0) {\n        return;\n    }\n\n    int32_t target_abs_idx = (int32_t)g_active_config_segment_base_idx_fixed + relative_start_offset;\n\n    if (target_abs_idx < 0 ||\n        target_abs_idx + data_len > VEHICLE_CONFIG_BUFFER_SIZE ||\n        data_len > VEHICLE_CONFIG_BUFFER_SIZE) {\n        return;\n    }\n\n    memcpy(&g_vehicle_config_data_fixed[target_abs_idx], data, data_len);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMAND_LOG_ENTRIES 64\n#define LOG_ENTRY_WORD_SIZE 2\n\nstatic uint16_t g_command_log_buffer[MAX_COMMAND_LOG_ENTRIES * LOG_ENTRY_WORD_SIZE];\nstatic uint32_t g_log_current_idx = 0;\n\nvoid init_command_logger() {\n    memset(g_command_log_buffer, 0, sizeof(g_command_log_buffer));\n    g_log_current_idx = 0;\n}\n\nbool log_command_execution(uint16_t command_id, uint16_t timestamp_ms) {\n    if (g_log_current_idx + LOG_ENTRY_WORD_SIZE > MAX_COMMAND_LOG_ENTRIES * LOG_ENTRY_WORD_SIZE) {\n        return false;\n    }\n    g_command_log_buffer[g_log_current_idx] = command_id;\n    g_command_log_buffer[g_log_current_idx + 1] = timestamp_ms;\n    g_log_current_idx += LOG_ENTRY_WORD_SIZE;\n    return true;\n}\n\nvoid process_log_entry_conceptually(uint16_t cmd_id, uint16_t ts) {\n    volatile uint16_t dummy_cmd = cmd_id;\n    volatile uint16_t dummy_ts = ts;\n    (void)dummy_cmd;\n    (void)dummy_ts;\n}\n\nvoid clear_log_segment_and_mark_boundary_vulnerable(int32_t offset_from_end_words, uint32_t words_to_clear) {\n    if (g_log_current_idx == 0 || words_to_clear == 0) {\n        return;\n    }\n\n    int32_t segment_start_idx = (int32_t)g_log_current_idx - offset_from_end_words;\n\n    uint32_t actual_words_to_clear = words_to_clear;\n    if (segment_start_idx < 0) {\n        if (segment_start_idx + (int32_t)words_to_clear < 0) {\n            actual_words_to_clear = 0;\n        } else {\n            actual_words_to_clear = words_to_clear + segment_start_idx;\n            if (actual_words_to_clear < 0) actual_words_to_clear = 0;\n            segment_start_idx = 0;\n        }\n    }\n    \n    for (uint32_t i = 0; i < actual_words_to_clear; ++i) {\n        if (segment_start_idx + i < (int32_t)(MAX_COMMAND_LOG_ENTRIES * LOG_ENTRY_WORD_SIZE)) {\n            g_command_log_buffer[segment_start_idx + i] = 0x0000;\n        }\n    }\n\n    g_command_log_buffer[segment_start_idx - 1] = 0xC0DE;\n\n    g_log_current_idx = (uint32_t)segment_start_idx;\n    process_log_entry_conceptually(g_command_log_buffer[g_log_current_idx], g_command_log_buffer[g_log_current_idx + 1]);\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMAND_LOG_ENTRIES 64\n#define LOG_ENTRY_WORD_SIZE 2\n\nstatic uint16_t g_command_log_buffer[MAX_COMMAND_LOG_ENTRIES * LOG_ENTRY_WORD_SIZE];\nstatic uint32_t g_log_current_idx = 0;\n\nvoid init_command_logger_fixed() {\n    memset(g_command_log_buffer, 0, sizeof(g_command_log_buffer));\n    g_log_current_idx = 0;\n}\n\nbool log_command_execution_fixed(uint16_t command_id, uint16_t timestamp_ms) {\n    if (g_log_current_idx + LOG_ENTRY_WORD_SIZE > MAX_COMMAND_LOG_ENTRIES * LOG_ENTRY_WORD_SIZE) {\n        return false;\n    }\n    g_command_log_buffer[g_log_current_idx] = command_id;\n    g_command_log_buffer[g_log_current_idx + 1] = timestamp_ms;\n    g_log_current_idx += LOG_ENTRY_WORD_SIZE;\n    return true;\n}\n\nvoid process_log_entry_conceptually_fixed(uint16_t cmd_id, uint16_t ts) {\n    volatile uint16_t dummy_cmd = cmd_id;\n    volatile uint16_t dummy_ts = ts;\n    (void)dummy_cmd;\n    (void)dummy_ts;\n}\n\nvoid clear_log_segment_and_mark_boundary_fixed(int32_t offset_from_end_words, uint32_t words_to_clear) {\n    if (g_log_current_idx == 0 || words_to_clear == 0) {\n        return;\n    }\n\n    int32_t segment_start_idx = (int32_t)g_log_current_idx - offset_from_end_words;\n\n    uint32_t actual_words_to_clear = words_to_clear;\n    if (segment_start_idx < 0) {\n        if (segment_start_idx + (int32_t)words_to_clear < 0) {\n            actual_words_to_clear = 0;\n        } else {\n            actual_words_to_clear = words_to_clear + segment_start_idx;\n            if (actual_words_to_clear < 0) actual_words_to_clear = 0;\n            segment_start_idx = 0;\n        }\n    }\n    \n    for (uint32_t i = 0; i < actual_words_to_clear; ++i) {\n        if (segment_start_idx + i < (int32_t)(MAX_COMMAND_LOG_ENTRIES * LOG_ENTRY_WORD_SIZE)) {\n            g_command_log_buffer[segment_start_idx + i] = 0x0000;\n        }\n    }\n\n    if (segment_start_idx - 1 >= 0 && (uint32_t)(segment_start_idx - 1) < (MAX_COMMAND_LOG_ENTRIES * LOG_ENTRY_WORD_SIZE)) {\n        g_command_log_buffer[segment_start_idx - 1] = 0xC0DE;\n    }\n\n    g_log_current_idx = (uint32_t)segment_start_idx;\n    if (g_log_current_idx + 1 < MAX_COMMAND_LOG_ENTRIES * LOG_ENTRY_WORD_SIZE) {\n        process_log_entry_conceptually_fixed(g_command_log_buffer[g_log_current_idx], g_command_log_buffer[g_log_current_idx + 1]);\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define TRACE_BUFFER_SIZE 256\n#define TRACE_ENTRY_SIZE 16\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint8_t  data[TRACE_ENTRY_SIZE - sizeof(uint32_t) - sizeof(uint16_t)];\n} TraceEntry;\n\nstatic uint8_t g_trace_buffer[TRACE_BUFFER_SIZE];\nstatic uint16_t g_trace_write_ptr = 0; \n\nvoid init_trace_buffer() {\n    memset(g_trace_buffer, 0, TRACE_BUFFER_SIZE);\n    g_trace_write_ptr = 0;\n}\n\nbool add_trace_entry(uint32_t timestamp, uint16_t event_id, const uint8_t* data) {\n    if (g_trace_write_ptr + TRACE_ENTRY_SIZE > TRACE_BUFFER_SIZE) {\n        g_trace_write_ptr = 0; \n    }\n    \n    if (TRACE_ENTRY_SIZE > TRACE_BUFFER_SIZE) return false; \n\n    TraceEntry new_entry;\n    new_entry.timestamp = timestamp;\n    new_entry.event_id = event_id;\n    memcpy(new_entry.data, data, sizeof(new_entry.data));\n\n    memcpy(&g_trace_buffer[g_trace_write_ptr], &new_entry, TRACE_ENTRY_SIZE);\n    g_trace_write_ptr += TRACE_ENTRY_SIZE;\n    return true;\n}\n\nvoid set_trace_metadata_marker_vulnerable(int16_t meta_offset_multiplier, uint8_t marker_value) {\n    const int16_t BASE_METADATA_OFFSET = -2; \n\n    int32_t total_negative_offset = (int32_t)BASE_METADATA_OFFSET * meta_offset_multiplier;\n\n    int32_t target_idx = (int32_t)g_trace_write_ptr + total_negative_offset;\n\n    g_trace_buffer[target_idx] = marker_value;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define TRACE_BUFFER_SIZE 256\n#define TRACE_ENTRY_SIZE 16\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint8_t  data[TRACE_ENTRY_SIZE - sizeof(uint32_t) - sizeof(uint16_t)];\n} TraceEntry;\n\nstatic uint8_t g_trace_buffer[TRACE_BUFFER_SIZE];\nstatic uint16_t g_trace_write_ptr = 0; \n\nvoid init_trace_buffer_fixed() {\n    memset(g_trace_buffer, 0, TRACE_BUFFER_SIZE);\n    g_trace_write_ptr = 0;\n}\n\nbool add_trace_entry_fixed(uint32_t timestamp, uint16_t event_id, const uint8_t* data) {\n    if (g_trace_write_ptr + TRACE_ENTRY_SIZE > TRACE_BUFFER_SIZE) {\n        g_trace_write_ptr = 0; \n    }\n    \n    if (TRACE_ENTRY_SIZE > TRACE_BUFFER_SIZE) return false; \n\n    TraceEntry new_entry;\n    new_entry.timestamp = timestamp;\n    new_entry.event_id = event_id;\n    memcpy(new_entry.data, data, sizeof(new_entry.data));\n\n    memcpy(&g_trace_buffer[g_trace_write_ptr], &new_entry, TRACE_ENTRY_SIZE);\n    g_trace_write_ptr += TRACE_ENTRY_SIZE;\n    return true;\n}\n\nvoid set_trace_metadata_marker_fixed(int16_t meta_offset_multiplier, uint8_t marker_value) {\n    const int16_t BASE_METADATA_OFFSET = -2; \n\n    int32_t total_negative_offset = (int32_t)BASE_METADATA_OFFSET * meta_offset_multiplier;\n\n    int32_t target_idx = (int32_t)g_trace_write_ptr + total_negative_offset;\n\n    if (target_idx < 0 || target_idx >= TRACE_BUFFER_SIZE) {\n        return; \n    }\n\n    g_trace_buffer[target_idx] = marker_value;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\ntypedef uint32_t CalibrationParameter;\n\n#define TOTAL_CALIBRATION_AREA_SIZE 256\n\nstatic CalibrationParameter g_calibration_area[TOTAL_CALIBRATION_AREA_SIZE];\n\nstatic uint16_t g_active_cal_data_end_idx = 0;\n\nvoid init_calibration_system() {\n    memset(g_calibration_area, 0x00, sizeof(g_calibration_area));\n    g_active_cal_data_end_idx = 0;\n}\n\nint16_t add_calibration_block(const CalibrationParameter* data, uint16_t num_params) {\n    if (g_active_cal_data_end_idx + num_params > TOTAL_CALIBRATION_AREA_SIZE) {\n        return -1;\n    }\n    uint16_t start_idx = g_active_cal_data_end_idx;\n    for (uint16_t i = 0; i < num_params; ++i) {\n        g_calibration_area[start_idx + i] = data[i];\n    }\n    g_active_cal_data_end_idx += num_params;\n    return start_idx;\n}\n\nCalibrationParameter get_calibration_param(uint16_t index) {\n    if (index < TOTAL_CALIBRATION_AREA_SIZE) {\n        return g_calibration_area[index];\n    }\n    return 0;\n}\n\nvoid rollback_calibration_value_vulnerable(uint16_t offset_from_end, CalibrationParameter new_value) {\n    if (g_active_cal_data_end_idx == 0) {\n        return;\n    }\n\n    int32_t target_idx = (int32_t)g_active_cal_data_end_idx - 1 - (int32_t)offset_from_end;\n\n    g_calibration_area[target_idx] = new_value;\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\ntypedef uint32_t CalibrationParameter;\n\n#define TOTAL_CALIBRATION_AREA_SIZE 256\n\nstatic CalibrationParameter g_calibration_area[TOTAL_CALIBRATION_AREA_SIZE];\n\nstatic uint16_t g_active_cal_data_end_idx = 0;\n\nvoid init_calibration_system_fixed() {\n    memset(g_calibration_area, 0x00, sizeof(g_calibration_area));\n    g_active_cal_data_end_idx = 0;\n}\n\nint16_t add_calibration_block_fixed(const CalibrationParameter* data, uint16_t num_params) {\n    if (g_active_cal_data_end_idx + num_params > TOTAL_CALIBRATION_AREA_SIZE) {\n        return -1;\n    }\n    uint16_t start_idx = g_active_cal_data_end_idx;\n    for (uint16_t i = 0; i < num_params; ++i) {\n        g_calibration_area[start_idx + i] = data[i];\n    }\n    g_active_cal_data_end_idx += num_params;\n    return start_idx;\n}\n\nCalibrationParameter get_calibration_param_fixed(uint16_t index) {\n    if (index < TOTAL_CALIBRATION_AREA_SIZE) {\n        return g_calibration_area[index];\n    }\n    return 0;\n}\n\nvoid rollback_calibration_value_fixed(uint16_t offset_from_end, CalibrationParameter new_value) {\n    if (g_active_cal_data_end_idx == 0) {\n        return;\n    }\n\n    int32_t potential_target_idx = (int32_t)g_active_cal_data_end_idx - 1 - (int32_t)offset_from_end;\n\n    if (potential_target_idx < 0 || potential_target_idx >= (int32_t)g_active_cal_data_end_idx) {\n        return;\n    }\n\n    uint16_t target_idx = (uint16_t)potential_target_idx;\n    g_calibration_area[target_idx] = new_value;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_VEHICLE_EVENTS 100\n#define EVENT_ENTRY_WORD_SIZE 4\n\ntypedef struct {\n    uint32_t event_id;\n    uint32_t timestamp_ms;\n    uint32_t flags;\n    uint32_t reserved;\n} VehicleEventEntry;\n\nstatic uint32_t g_event_log_words[MAX_VEHICLE_EVENTS * EVENT_ENTRY_WORD_SIZE];\nstatic uint16_t g_next_write_word_idx = 0;\nstatic uint16_t g_num_logged_events = 0;\n\nvoid init_event_logger() {\n    memset(g_event_log_words, 0, sizeof(g_event_log_words));\n    g_next_write_word_idx = 0;\n    g_num_logged_events = 0;\n}\n\nbool log_vehicle_event(uint32_t event_id, uint32_t timestamp, uint32_t flags) {\n    if (g_num_logged_events >= MAX_VEHICLE_EVENTS) {\n        return false;\n    }\n\n    uint16_t current_entry_start_word_idx = g_next_write_word_idx;\n\n    g_event_log_words[current_entry_start_word_idx + 0] = event_id;\n    g_event_log_words[current_entry_start_word_idx + 1] = timestamp;\n    g_event_log_words[current_entry_start_word_idx + 2] = flags;\n    g_event_log_words[current_entry_start_word_idx + 3] = 0;\n\n    g_next_write_word_idx += EVENT_ENTRY_WORD_SIZE;\n    g_num_logged_events++;\n    return true;\n}\n\nvoid update_event_flags_vulnerable(uint16_t event_index_from_latest, uint32_t new_flags) {\n    if (g_num_logged_events == 0) {\n        return;\n    }\n\n    uint16_t latest_event_start_word_idx = g_next_write_word_idx - EVENT_ENTRY_WORD_SIZE;\n\n    int32_t target_event_start_word_idx = (int32_t)latest_event_start_word_idx - ((int32_t)event_index_from_latest * EVENT_ENTRY_WORD_SIZE);\n\n    g_event_log_words[target_event_start_word_idx + 2] = new_flags;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_VEHICLE_EVENTS 100\n#define EVENT_ENTRY_WORD_SIZE 4\n\ntypedef struct {\n    uint32_t event_id;\n    uint32_t timestamp_ms;\n    uint32_t flags;\n    uint32_t reserved;\n} VehicleEventEntry;\n\nstatic uint32_t g_event_log_words[MAX_VEHICLE_EVENTS * EVENT_ENTRY_WORD_SIZE];\nstatic uint16_t g_next_write_word_idx = 0;\nstatic uint16_t g_num_logged_events = 0;\n\nvoid init_event_logger() {\n    memset(g_event_log_words, 0, sizeof(g_event_log_words));\n    g_next_write_word_idx = 0;\n    g_num_logged_events = 0;\n}\n\nbool log_vehicle_event(uint32_t event_id, uint32_t timestamp, uint32_t flags) {\n    if (g_num_logged_events >= MAX_VEHICLE_EVENTS) {\n        return false;\n    }\n\n    uint16_t current_entry_start_word_idx = g_next_write_word_idx;\n\n    g_event_log_words[current_entry_start_word_idx + 0] = event_id;\n    g_event_log_words[current_entry_start_word_idx + 1] = timestamp;\n    g_event_log_words[current_entry_start_word_idx + 2] = flags;\n    g_event_log_words[current_entry_start_word_idx + 3] = 0;\n\n    g_next_write_word_idx += EVENT_ENTRY_WORD_SIZE;\n    g_num_logged_events++;\n    return true;\n}\n\nvoid update_event_flags_fixed(uint16_t event_index_from_latest, uint32_t new_flags) {\n    if (g_num_logged_events == 0) {\n        return;\n    }\n\n    if (event_index_from_latest >= g_num_logged_events) {\n        return;\n    }\n\n    uint16_t latest_event_start_word_idx = g_next_write_word_idx - EVENT_ENTRY_WORD_SIZE;\n\n    uint16_t target_event_start_word_idx = latest_event_start_word_idx - (event_index_from_latest * EVENT_ENTRY_WORD_SIZE);\n\n    g_event_log_words[target_event_start_word_idx + 2] = new_flags;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define EVENT_BUFFER_SIZE_BYTES 512\n#define MAX_EVENT_PAYLOAD_BYTES 250\n\nstatic uint8_t g_vehicle_event_buffer[EVENT_BUFFER_SIZE_BYTES];\nstatic uint16_t g_event_write_head_offset = 0;\nstatic uint16_t g_num_active_events = 0;\n\ntypedef struct {\n    uint8_t  status_flags;\n    uint8_t  event_type_id;\n    uint16_t payload_len;\n} EventHeader;\n\n#define EVENT_HEADER_BYTE_SIZE (sizeof(EventHeader))\n\nuint32_t calculate_data_crc_dummy(const uint8_t* data, uint16_t len) {\n    uint32_t crc = 0;\n    if (data == NULL) return 0;\n    for (uint16_t i = 0; i < len; ++i) {\n        crc += data[i];\n    }\n    return crc;\n}\n\nvoid event_buffer_init() {\n    memset(g_vehicle_event_buffer, 0, sizeof(g_vehicle_event_buffer));\n    g_event_write_head_offset = 0;\n    g_num_active_events = 0;\n}\n\nbool event_buffer_add_event(uint8_t type_id, const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len == 0 || payload_len > MAX_EVENT_PAYLOAD_BYTES) {\n        return false;\n    }\n\n    if (g_event_write_head_offset + EVENT_HEADER_BYTE_SIZE + payload_len > EVENT_BUFFER_SIZE_BYTES) {\n        g_event_write_head_offset = 0;\n        if (g_event_write_head_offset + EVENT_HEADER_BYTE_SIZE + payload_len > EVENT_BUFFER_SIZE_BYTES) {\n            return false;\n        }\n    }\n\n    EventHeader* header_ptr = (EventHeader*)(g_vehicle_event_buffer + g_event_write_head_offset);\n    header_ptr->status_flags = 0x01;\n    header_ptr->event_type_id = type_id;\n    header_ptr->payload_len = payload_len;\n\n    memcpy(g_vehicle_event_buffer + g_event_write_head_offset + EVENT_HEADER_BYTE_SIZE, payload, payload_len);\n\n    g_event_write_head_offset += (EVENT_HEADER_BYTE_SIZE + payload_len);\n    g_num_active_events++;\n    return true;\n}\n\nvoid mark_event_as_processed_vulnerable(uint16_t event_data_offset, uint8_t new_status) {\n    g_vehicle_event_buffer[event_data_offset - EVENT_HEADER_BYTE_SIZE] = new_status;\n}\n\nbool get_event_payload(uint16_t event_data_offset, uint8_t* buffer, uint16_t* len) {\n    if (event_data_offset >= EVENT_BUFFER_SIZE_BYTES) return false;\n\n    int32_t header_offset = (int32_t)event_data_offset - EVENT_HEADER_BYTE_SIZE;\n    if (header_offset < 0) return false;\n\n    EventHeader* header_ptr = (EventHeader*)(g_vehicle_event_buffer + header_offset);\n\n    if (header_offset + EVENT_HEADER_BYTE_SIZE + header_ptr->payload_len > EVENT_BUFFER_SIZE_BYTES) {\n        return false;\n    }\n\n    if (buffer && len) {\n        if (*len < header_ptr->payload_len) {\n            *len = header_ptr->payload_len;\n            return false;\n        }\n        memcpy(buffer, g_vehicle_event_buffer + event_data_offset, header_ptr->payload_len);\n        *len = header_ptr->payload_len;\n        return true;\n    }\n    return false;\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define EVENT_BUFFER_SIZE_BYTES 512\n#define MAX_EVENT_PAYLOAD_BYTES 250\n\nstatic uint8_t g_vehicle_event_buffer_fixed[EVENT_BUFFER_SIZE_BYTES];\nstatic uint16_t g_event_write_head_offset_fixed = 0;\nstatic uint16_t g_num_active_events_fixed = 0;\n\ntypedef struct {\n    uint8_t  status_flags;\n    uint8_t  event_type_id;\n    uint16_t payload_len;\n} EventHeader;\n\n#define EVENT_HEADER_BYTE_SIZE (sizeof(EventHeader))\n\nuint32_t calculate_data_crc_dummy_fixed(const uint8_t* data, uint16_t len) {\n    uint32_t crc = 0;\n    if (data == NULL) return 0;\n    for (uint16_t i = 0; i < len; ++i) {\n        crc += data[i];\n    }\n    return crc;\n}\n\nvoid event_buffer_init_fixed() {\n    memset(g_vehicle_event_buffer_fixed, 0, sizeof(g_vehicle_event_buffer_fixed));\n    g_event_write_head_offset_fixed = 0;\n    g_num_active_events_fixed = 0;\n}\n\nbool event_buffer_add_event_fixed(uint8_t type_id, const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len == 0 || payload_len > MAX_EVENT_PAYLOAD_BYTES) {\n        return false;\n    }\n\n    if (g_event_write_head_offset_fixed + EVENT_HEADER_BYTE_SIZE + payload_len > EVENT_BUFFER_SIZE_BYTES) {\n        g_event_write_head_offset_fixed = 0;\n        if (g_event_write_head_offset_fixed + EVENT_HEADER_BYTE_SIZE + payload_len > EVENT_BUFFER_SIZE_BYTES) {\n            return false;\n        }\n    }\n\n    EventHeader* header_ptr = (EventHeader*)(g_vehicle_event_buffer_fixed + g_event_write_head_offset_fixed);\n    header_ptr->status_flags = 0x01;\n    header_ptr->event_type_id = type_id;\n    header_ptr->payload_len = payload_len;\n\n    memcpy(g_vehicle_event_buffer_fixed + g_event_write_head_offset_fixed + EVENT_HEADER_BYTE_SIZE, payload, payload_len);\n\n    g_event_write_head_offset_fixed += (EVENT_HEADER_BYTE_SIZE + payload_len);\n    g_num_active_events_fixed++;\n    return true;\n}\n\nvoid mark_event_as_processed_fixed(uint16_t event_data_offset, uint8_t new_status) {\n    int32_t status_byte_index = (int32_t)event_data_offset - EVENT_HEADER_BYTE_SIZE;\n\n    if (status_byte_index < 0 || status_byte_index >= EVENT_BUFFER_SIZE_BYTES) {\n        return;\n    }\n    \n    g_vehicle_event_buffer_fixed[status_byte_index] = new_status;\n}\n\nbool get_event_payload_fixed(uint16_t event_data_offset, uint8_t* buffer, uint16_t* len) {\n    if (event_data_offset >= EVENT_BUFFER_SIZE_BYTES) return false;\n\n    int32_t header_offset = (int32_t)event_data_offset - EVENT_HEADER_BYTE_SIZE;\n    if (header_offset < 0) return false;\n\n    EventHeader* header_ptr = (EventHeader*)(g_vehicle_event_buffer_fixed + header_offset);\n\n    if (header_offset + EVENT_HEADER_BYTE_SIZE + header_ptr->payload_len > EVENT_BUFFER_SIZE_BYTES) {\n        return false;\n    }\n\n    if (buffer && len) {\n        if (*len < header_ptr->payload_len) {\n            *len = header_ptr->payload_len;\n            return false;\n        }\n        memcpy(buffer, g_vehicle_event_buffer_fixed + event_data_offset, header_ptr->payload_len);\n        *len = header_ptr->payload_len;\n        return true;\n    }\n    return false;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_SCRATCHPAD_BUFFER_SIZE 512\n\nstatic uint8_t g_diag_scratchpad_buffer[DIAG_SCRATCHPAD_BUFFER_SIZE];\nstatic int16_t g_current_diag_data_start_offset = 0;\nstatic uint16_t g_current_diag_data_size = 0;\n\nvoid init_diag_scratchpad() {\n    memset(g_diag_scratchpad_buffer, 0x00, DIAG_SCRATCHPAD_BUFFER_SIZE);\n    g_current_diag_data_start_offset = 0;\n    g_current_diag_data_size = 0;\n}\n\nbool append_diag_data(const uint8_t* data, uint16_t len) {\n    if (data == NULL || len == 0) {\n        return false;\n    }\n    if ((g_current_diag_data_start_offset + g_current_diag_data_size + len) > DIAG_SCRATCHPAD_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_diag_scratchpad_buffer + g_current_diag_data_start_offset + g_current_diag_data_size, data, len);\n    g_current_diag_data_size += len;\n    return true;\n}\n\nvoid trim_diag_data_start_vulnerable(uint16_t data_units_to_trim, uint16_t unit_nominal_size) {\n    if (data_units_to_trim == 0 || unit_nominal_size == 0) {\n        return;\n    }\n\n    int16_t bytes_to_shift = (int16_t)((uint32_t)data_units_to_trim * unit_nominal_size);\n\n    g_current_diag_data_start_offset += bytes_to_shift;\n\n    if (bytes_to_shift < g_current_diag_data_size) {\n        g_current_diag_data_size -= bytes_to_shift;\n    } else {\n        g_current_diag_data_size = 0;\n    }\n\n    if (g_current_diag_data_start_offset >= DIAG_SCRATCHPAD_BUFFER_SIZE) {\n        g_current_diag_data_start_offset = 0;\n        g_current_diag_data_size = 0;\n    }\n}\n\nvoid set_first_unit_status_vulnerable(uint8_t new_status) {\n    if (g_current_diag_data_size == 0) {\n        return;\n    }\n\n    g_diag_scratchpad_buffer[g_current_diag_data_start_offset] = new_status;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_SCRATCHPAD_BUFFER_SIZE 512\n\nstatic uint8_t g_diag_scratchpad_buffer[DIAG_SCRATCHPAD_BUFFER_SIZE];\nstatic int16_t g_current_diag_data_start_offset = 0;\nstatic uint16_t g_current_diag_data_size = 0;\n\nvoid init_diag_scratchpad() {\n    memset(g_diag_scratchpad_buffer, 0x00, DIAG_SCRATCHPAD_BUFFER_SIZE);\n    g_current_diag_data_start_offset = 0;\n    g_current_diag_data_size = 0;\n}\n\nbool append_diag_data(const uint8_t* data, uint16_t len) {\n    if (data == NULL || len == 0) {\n        return false;\n    }\n    if ((g_current_diag_data_start_offset + g_current_diag_data_size + len) > DIAG_SCRATCHPAD_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_diag_scratchpad_buffer + g_current_diag_data_start_offset + g_current_diag_data_size, data, len);\n    g_current_diag_data_size += len;\n    return true;\n}\n\nvoid trim_diag_data_start_fixed(uint16_t data_units_to_trim, uint16_t unit_nominal_size) {\n    if (data_units_to_trim == 0 || unit_nominal_size == 0) {\n        return;\n    }\n\n    uint32_t bytes_to_shift_calc = (uint32_t)data_units_to_trim * unit_nominal_size;\n\n    if (bytes_to_shift_calc > g_current_diag_data_size) {\n        bytes_to_shift_calc = g_current_diag_data_size;\n    }\n\n    int16_t actual_bytes_to_shift = (int16_t)bytes_to_shift_calc;\n\n    if ((int32_t)g_current_diag_data_start_offset + actual_bytes_to_shift < 0) {\n        g_current_diag_data_start_offset = 0;\n        g_current_diag_data_size = 0;\n        return;\n    }\n\n    g_current_diag_data_start_offset += actual_bytes_to_shift;\n    g_current_diag_data_size -= actual_bytes_to_shift;\n\n    if (g_current_diag_data_start_offset >= DIAG_SCRATCHPAD_BUFFER_SIZE) {\n        g_current_diag_data_start_offset = 0;\n        g_current_diag_data_size = 0;\n    }\n}\n\nvoid set_first_unit_status_fixed(uint8_t new_status) {\n    if (g_current_diag_data_size == 0) {\n        return;\n    }\n\n    if (g_current_diag_data_start_offset < 0 || g_current_diag_data_start_offset >= DIAG_SCRATCHPAD_BUFFER_SIZE) {\n        return;\n    }\n\n    g_diag_scratchpad_buffer[g_current_diag_data_start_offset] = new_status;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_ANOMALIES 64\n#define STATUS_BUFFER_START_OFFSET 10\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t sensor_id;\n    int32_t  value;\n    uint8_t  flags;\n} AnomalyEvent;\n\nstatic AnomalyEvent g_anomaly_events[MAX_ANOMALIES];\nstatic int g_num_anomalies = 0;\n\nstatic uint8_t g_event_processing_status[MAX_ANOMALIES + STATUS_BUFFER_START_OFFSET];\n\nvoid init_anomaly_system() {\n    memset(g_anomaly_events, 0, sizeof(g_anomaly_events));\n    memset(g_event_processing_status, 0, sizeof(g_event_processing_status));\n    g_num_anomalies = 0;\n}\n\nbool add_anomaly_event(uint32_t ts, uint16_t sid, int32_t val, uint8_t flgs) {\n    if (g_num_anomalies >= MAX_ANOMALIES) {\n        return false;\n    }\n    g_anomaly_events[g_num_anomalies].timestamp = ts;\n    g_anomaly_events[g_num_anomalies].sensor_id = sid;\n    g_anomaly_events[g_num_anomalies].value = val;\n    g_anomaly_events[g_num_anomalies].flags = flgs;\n    g_event_processing_status[STATUS_BUFFER_START_OFFSET + g_num_anomalies] = 0x01;\n    g_num_anomalies++;\n    return true;\n}\n\nstatic int find_anomaly_event_index(uint32_t ts, uint16_t sid) {\n    for (int i = 0; i < g_num_anomalies; ++i) {\n        if (g_anomaly_events[i].timestamp == ts && g_anomaly_events[i].sensor_id == sid) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid update_anomaly_status_property_vulnerable(uint32_t ts, uint16_t sid, int16_t offset_from_base_status, uint8_t new_value) {\n    int event_idx = find_anomaly_event_index(ts, sid);\n    if (event_idx == -1) {\n        return;\n    }\n\n    int base_status_idx = STATUS_BUFFER_START_OFFSET + event_idx;\n\n    int target_status_idx = base_status_idx + offset_from_base_status;\n\n    g_event_processing_status[target_status_idx] = new_value;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_ANOMALIES 64\n#define STATUS_BUFFER_START_OFFSET 10\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t sensor_id;\n    int32_t  value;\n    uint8_t  flags;\n} AnomalyEvent;\n\nstatic AnomalyEvent g_anomaly_events[MAX_ANOMALIES];\nstatic int g_num_anomalies = 0;\n\nstatic uint8_t g_event_processing_status[MAX_ANOMALIES + STATUS_BUFFER_START_OFFSET];\n\nvoid init_anomaly_system() {\n    memset(g_anomaly_events, 0, sizeof(g_anomaly_events));\n    memset(g_event_processing_status, 0, sizeof(g_event_processing_status));\n    g_num_anomalies = 0;\n}\n\nbool add_anomaly_event(uint32_t ts, uint16_t sid, int32_t val, uint8_t flgs) {\n    if (g_num_anomalies >= MAX_ANOMALIES) {\n        return false;\n    }\n    g_anomaly_events[g_num_anomalies].timestamp = ts;\n    g_anomaly_events[g_num_anomalies].sensor_id = sid;\n    g_anomaly_events[g_num_anomalies].value = val;\n    g_anomaly_events[g_num_anomalies].flags = flgs;\n    g_event_processing_status[STATUS_BUFFER_START_OFFSET + g_num_anomalies] = 0x01;\n    g_num_anomalies++;\n    return true;\n}\n\nstatic int find_anomaly_event_index(uint32_t ts, uint16_t sid) {\n    for (int i = 0; i < g_num_anomalies; ++i) {\n        if (g_anomaly_events[i].timestamp == ts && g_anomaly_events[i].sensor_id == sid) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid update_anomaly_status_property_fixed(uint32_t ts, uint16_t sid, int16_t offset_from_base_status, uint8_t new_value) {\n    int event_idx = find_anomaly_event_index(ts, sid);\n    if (event_idx == -1) {\n        return;\n    }\n\n    int base_status_idx = STATUS_BUFFER_START_OFFSET + event_idx;\n\n    int potential_target_status_idx = base_status_idx + offset_from_base_status;\n\n    if (potential_target_status_idx < 0 || potential_target_status_idx >= (MAX_ANOMALIES + STATUS_BUFFER_START_OFFSET)) {\n        return;\n    }\n\n    uint16_t target_status_idx = (uint16_t)potential_target_status_idx;\n\n    g_event_processing_status[target_status_idx] = new_value;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_DIAG_EVENTS 50\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp_ms;\n    uint8_t status_flags;\n} DiagEvent;\n\nstatic DiagEvent g_diag_event_log[MAX_DIAG_EVENTS];\nstatic uint32_t g_event_log_count = 0;\n\nvoid init_event_log() {\n    memset(g_diag_event_log, 0, sizeof(g_diag_event_log));\n    g_event_log_count = 0;\n}\n\nbool add_diag_event(uint16_t id, uint32_t timestamp) {\n    if (g_event_log_count < MAX_DIAG_EVENTS) {\n        g_diag_event_log[g_event_log_count].event_id = id;\n        g_diag_event_log[g_event_log_count].timestamp_ms = timestamp;\n        g_diag_event_log[g_event_log_count].status_flags = 0x00;\n        g_event_log_count++;\n        return true;\n    }\n    return false;\n}\n\nvoid classify_recent_events_vulnerable(uint32_t window_size, uint8_t classification_status) {\n    if (g_event_log_count == 0 || window_size == 0) {\n        return;\n    }\n\n    int32_t start_index = (int32_t)g_event_log_count - (int32_t)window_size;\n\n    for (uint32_t i = 0; i < window_size; ++i) {\n        g_diag_event_log[start_index + i].status_flags |= classification_status;\n    }\n\n    if (g_event_log_count <= window_size) {\n        g_event_log_count = 0;\n    } else {\n        g_event_log_count -= window_size;\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_DIAG_EVENTS 50\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp_ms;\n    uint8_t status_flags;\n} DiagEvent;\n\nstatic DiagEvent g_diag_event_log[MAX_DIAG_EVENTS];\nstatic uint32_t g_event_log_count = 0;\n\nvoid init_event_log_fixed() {\n    memset(g_diag_event_log, 0, sizeof(g_diag_event_log));\n    g_event_log_count = 0;\n}\n\nbool add_diag_event_fixed(uint16_t id, uint32_t timestamp) {\n    if (g_event_log_count < MAX_DIAG_EVENTS) {\n        g_diag_event_log[g_event_log_count].event_id = id;\n        g_diag_event_log[g_event_log_count].timestamp_ms = timestamp;\n        g_diag_event_log[g_event_log_count].status_flags = 0x00;\n        g_event_log_count++;\n        return true;\n    }\n    return false;\n}\n\nvoid classify_recent_events_fixed(uint32_t window_size, uint8_t classification_status) {\n    if (g_event_log_count == 0 || window_size == 0) {\n        return;\n    }\n\n    uint32_t actual_start_index;\n    uint32_t actual_window_size;\n\n    if (window_size >= g_event_log_count) {\n        actual_start_index = 0;\n        actual_window_size = g_event_log_count;\n    } else {\n        actual_start_index = g_event_log_count - window_size;\n        actual_window_size = window_size;\n    }\n\n    for (uint32_t i = 0; i < actual_window_size; ++i) {\n        g_diag_event_log[actual_start_index + i].status_flags |= classification_status;\n    }\n\n    g_event_log_count = actual_start_index;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define MAX_DIAG_PACKET_SIZE 256\n#define DIAG_DATA_AREA_OFFSET 8\n\ntypedef struct {\n    uint16_t command_id;\n    uint16_t data_length;\n    uint32_t timestamp;\n} DiagnosticHeader;\n\nstatic uint8_t g_diag_packet_buffer[MAX_DIAG_PACKET_SIZE];\nstatic size_t g_current_packet_len = 0;\n\nvoid clear_diag_buffer() {\n    memset(g_diag_packet_buffer, 0, MAX_DIAG_PACKET_SIZE);\n    g_current_packet_len = 0;\n}\n\nvoid receive_diag_packet(const uint8_t* raw_data, size_t len) {\n    if (len > MAX_DIAG_PACKET_SIZE) {\n        len = MAX_DIAG_PACKET_SIZE;\n    }\n    memcpy(g_diag_packet_buffer, raw_data, len);\n    g_current_packet_len = len;\n}\n\ntypedef struct {\n    int16_t relative_offset;\n    uint8_t  field_id;\n    uint8_t  field_size;\n} DataFieldDescriptor;\n\nvoid process_diagnostic_fields_vulnerable(const DataFieldDescriptor* fields, size_t num_fields, uint8_t update_value) {\n    if (g_current_packet_len < DIAG_DATA_AREA_OFFSET) {\n        return;\n    }\n\n    uint8_t* data_ptr = g_diag_packet_buffer + DIAG_DATA_AREA_OFFSET;\n    size_t data_area_size = g_current_packet_len - DIAG_DATA_AREA_OFFSET;\n\n    for (size_t i = 0; i < num_fields; ++i) {\n        const DataFieldDescriptor* field = &fields[i];\n\n        if (field->field_size == 0 || field->field_size > data_area_size) {\n            continue;\n        }\n\n        uint8_t* target_addr = data_ptr + field->relative_offset;\n\n        *target_addr = update_value;\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define MAX_DIAG_PACKET_SIZE 256\n#define DIAG_DATA_AREA_OFFSET 8\n\ntypedef struct {\n    uint16_t command_id;\n    uint16_t data_length;\n    uint32_t timestamp;\n} DiagnosticHeader;\n\nstatic uint8_t g_diag_packet_buffer[MAX_DIAG_PACKET_SIZE];\nstatic size_t g_current_packet_len = 0;\n\nvoid clear_diag_buffer() {\n    memset(g_diag_packet_buffer, 0, MAX_DIAG_PACKET_SIZE);\n    g_current_packet_len = 0;\n}\n\nvoid receive_diag_packet(const uint8_t* raw_data, size_t len) {\n    if (len > MAX_DIAG_PACKET_SIZE) {\n        len = MAX_DIAG_PACKET_SIZE;\n    }\n    memcpy(g_diag_packet_buffer, raw_data, len);\n    g_current_packet_len = len;\n}\n\ntypedef struct {\n    int16_t relative_offset;\n    uint8_t  field_id;\n    uint8_t  field_size;\n} DataFieldDescriptor;\n\nvoid process_diagnostic_fields_fixed(const DataFieldDescriptor* fields, size_t num_fields, uint8_t update_value) {\n    if (g_current_packet_len < DIAG_DATA_AREA_OFFSET) {\n        return;\n    }\n\n    uint8_t* data_ptr = g_diag_packet_buffer + DIAG_DATA_AREA_OFFSET;\n    size_t data_area_size = g_current_packet_len - DIAG_DATA_AREA_OFFSET;\n\n    for (size_t i = 0; i < num_fields; ++i) {\n        const DataFieldDescriptor* field = &fields[i];\n\n        if (field->relative_offset < 0) {\n            continue;\n        }\n\n        size_t current_field_offset = (size_t)field->relative_offset;\n\n        if (current_field_offset + field->field_size > data_area_size || field->field_size == 0) {\n            continue;\n        }\n\n        uint8_t* target_addr = data_ptr + current_field_offset;\n\n        *target_addr = update_value;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_MESSAGE_BUFFER_SIZE 16\n#define MAX_MESSAGE_LEN 64\n\ntypedef struct {\n    char message[MAX_MESSAGE_LEN];\n    uint32_t timestamp;\n    bool processed;\n    uint8_t status_flags;\n} DiagnosticMessage;\n\nstatic DiagnosticMessage g_diag_message_buffer[DIAG_MESSAGE_BUFFER_SIZE];\nstatic uint8_t g_current_write_idx = 0;\nstatic uint8_t g_active_message_count = 0;\n\nvoid init_diag_system_vulnerable() {\n    for (uint8_t i = 0; i < DIAG_MESSAGE_BUFFER_SIZE; ++i) {\n        memset(&g_diag_message_buffer[i], 0, sizeof(DiagnosticMessage));\n        g_diag_message_buffer[i].processed = true;\n        g_diag_message_buffer[i].status_flags = 0x00;\n    }\n    g_current_write_idx = 0;\n    g_active_message_count = 0;\n}\n\nvoid add_diag_message_vulnerable(const char* msg_str, uint32_t timestamp) {\n    strncpy(g_diag_message_buffer[g_current_write_idx].message, msg_str, MAX_MESSAGE_LEN - 1);\n    g_diag_message_buffer[g_current_write_idx].message[MAX_MESSAGE_LEN - 1] = '\\0';\n    g_diag_message_buffer[g_current_write_idx].timestamp = timestamp;\n    g_diag_message_buffer[g_current_write_idx].processed = false;\n    g_diag_message_buffer[g_current_write_idx].status_flags = 0x01;\n\n    g_current_write_idx = (g_current_write_idx + 1) % DIAG_MESSAGE_BUFFER_SIZE;\n    if (g_active_message_count < DIAG_MESSAGE_BUFFER_SIZE) {\n        g_active_message_count++;\n    }\n}\n\nvoid revert_message_processing_vulnerable(int16_t messages_to_revert) {\n    if (messages_to_revert <= 0 || g_active_message_count == 0) {\n        return;\n    }\n\n    int16_t last_message_physical_idx = (g_current_write_idx == 0 && g_active_message_count == DIAG_MESSAGE_BUFFER_SIZE) ?\n                                        (DIAG_MESSAGE_BUFFER_SIZE - 1) : (g_current_write_idx - 1);\n\n    for (int16_t i = 0; i < messages_to_revert; ++i) {\n        int16_t target_idx = last_message_physical_idx - i;\n\n        g_diag_message_buffer[target_idx].processed = false;\n        g_diag_message_buffer[target_idx].status_flags = 0x02;\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_MESSAGE_BUFFER_SIZE 16\n#define MAX_MESSAGE_LEN 64\n\ntypedef struct {\n    char message[MAX_MESSAGE_LEN];\n    uint32_t timestamp;\n    bool processed;\n    uint8_t status_flags;\n} DiagnosticMessage;\n\nstatic DiagnosticMessage g_diag_message_buffer_fixed[DIAG_MESSAGE_BUFFER_SIZE];\nstatic uint8_t g_current_write_idx_fixed = 0;\nstatic uint8_t g_active_message_count_fixed = 0;\n\nvoid init_diag_system_fixed() {\n    for (uint8_t i = 0; i < DIAG_MESSAGE_BUFFER_SIZE; ++i) {\n        memset(&g_diag_message_buffer_fixed[i], 0, sizeof(DiagnosticMessage));\n        g_diag_message_buffer_fixed[i].processed = true;\n        g_diag_message_buffer_fixed[i].status_flags = 0x00;\n    }\n    g_current_write_idx_fixed = 0;\n    g_active_message_count_fixed = 0;\n}\n\nvoid add_diag_message_fixed(const char* msg_str, uint32_t timestamp) {\n    strncpy(g_diag_message_buffer_fixed[g_current_write_idx_fixed].message, msg_str, MAX_MESSAGE_LEN - 1);\n    g_diag_message_buffer_fixed[g_current_write_idx_fixed].message[MAX_MESSAGE_LEN - 1] = '\\0';\n    g_diag_message_buffer_fixed[g_current_write_idx_fixed].timestamp = timestamp;\n    g_diag_message_buffer_fixed[g_current_write_idx_fixed].processed = false;\n    g_diag_message_buffer_fixed[g_current_write_idx_fixed].status_flags = 0x01;\n\n    g_current_write_idx_fixed = (g_current_write_idx_fixed + 1) % DIAG_MESSAGE_BUFFER_SIZE;\n    if (g_active_message_count_fixed < DIAG_MESSAGE_BUFFER_SIZE) {\n        g_active_message_count_fixed++;\n    }\n}\n\nvoid revert_message_processing_fixed(int16_t messages_to_revert) {\n    if (messages_to_revert <= 0 || g_active_message_count_fixed == 0) {\n        return;\n    }\n\n    int16_t actual_messages_to_revert = (messages_to_revert > g_active_message_count_fixed) ?\n                                         g_active_message_count_fixed : messages_to_revert;\n\n    int16_t last_message_physical_idx = (g_current_write_idx_fixed == 0 && g_active_message_count_fixed == DIAG_MESSAGE_BUFFER_SIZE) ?\n                                        (DIAG_MESSAGE_BUFFER_SIZE - 1) : (g_current_write_idx_fixed - 1);\n\n    for (int16_t i = 0; i < actual_messages_to_revert; ++i) {\n        int16_t target_idx = (last_message_physical_idx - i + DIAG_MESSAGE_BUFFER_SIZE) % DIAG_MESSAGE_BUFFER_SIZE;\n\n        g_diag_message_buffer_fixed[target_idx].processed = false;\n        g_diag_message_buffer_fixed[target_idx].status_flags = 0x02;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <string.h>\n\n#define MAX_DIAG_EVENTS 10\n#define DIAG_EVENT_DATA_SIZE 16\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp;\n    uint8_t  data_len;\n    uint8_t  diag_data[DIAG_EVENT_DATA_SIZE];\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diag_event_buffer[MAX_DIAG_EVENTS];\nstatic uint8_t g_num_active_events = 0;\n\nvoid init_diag_system() {\n    for (uint8_t i = 0; i < MAX_DIAG_EVENTS; ++i) {\n        memset(&g_diag_event_buffer[i], 0, sizeof(DiagnosticEvent));\n    }\n    g_num_active_events = 0;\n}\n\nbool add_diag_event(uint16_t event_id, uint32_t timestamp, const uint8_t* initial_data, uint8_t initial_data_len) {\n    if (g_num_active_events >= MAX_DIAG_EVENTS) {\n        return false;\n    }\n    if (initial_data_len > DIAG_EVENT_DATA_SIZE) {\n        initial_data_len = DIAG_EVENT_DATA_SIZE;\n    }\n\n    g_diag_event_buffer[g_num_active_events].event_id = event_id;\n    g_diag_event_buffer[g_num_active_events].timestamp = timestamp;\n    g_diag_event_buffer[g_num_active_events].data_len = initial_data_len;\n    if (initial_data && initial_data_len > 0) {\n        for (uint8_t i = 0; i < initial_data_len; ++i) {\n            g_diag_event_buffer[g_num_active_events].diag_data[i] = initial_data[i];\n        }\n    }\n    g_num_active_events++;\n    return true;\n}\n\nvoid clear_diag_data_byte_vulnerable(uint16_t target_event_id, int16_t relative_offset_from_data_end) {\n    int event_idx = -1;\n    for (int i = 0; i < g_num_active_events; ++i) {\n        if (g_diag_event_buffer[i].event_id == target_event_id) {\n            event_idx = i;\n            break;\n        }\n    }\n\n    if (event_idx == -1 || g_diag_event_buffer[event_idx].data_len == 0) {\n        return;\n    }\n\n    int32_t target_byte_index = (int32_t)g_diag_event_buffer[event_idx].data_len - 1 - relative_offset_from_data_end;\n\n    g_diag_event_buffer[event_idx].diag_data[target_byte_index] = 0x00;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <string.h>\n\n#define MAX_DIAG_EVENTS 10\n#define DIAG_EVENT_DATA_SIZE 16\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp;\n    uint8_t  data_len;\n    uint8_t  diag_data[DIAG_EVENT_DATA_SIZE];\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diag_event_buffer[MAX_DIAG_EVENTS];\nstatic uint8_t g_num_active_events = 0;\n\nvoid init_diag_system_fixed() {\n    for (uint8_t i = 0; i < MAX_DIAG_EVENTS; ++i) {\n        memset(&g_diag_event_buffer[i], 0, sizeof(DiagnosticEvent));\n    }\n    g_num_active_events = 0;\n}\n\nbool add_diag_event_fixed(uint16_t event_id, uint32_t timestamp, const uint8_t* initial_data, uint8_t initial_data_len) {\n    if (g_num_active_events >= MAX_DIAG_EVENTS) {\n        return false;\n    }\n    if (initial_data_len > DIAG_EVENT_DATA_SIZE) {\n        initial_data_len = DIAG_EVENT_DATA_SIZE;\n    }\n\n    g_diag_event_buffer[g_num_active_events].event_id = event_id;\n    g_diag_event_buffer[g_num_active_events].timestamp = timestamp;\n    g_diag_event_buffer[g_num_active_events].data_len = initial_data_len;\n    if (initial_data && initial_data_len > 0) {\n        for (uint8_t i = 0; i < initial_data_len; ++i) {\n            g_diag_event_buffer[g_num_active_events].diag_data[i] = initial_data[i];\n        }\n    }\n    g_num_active_events++;\n    return true;\n}\n\nvoid clear_diag_data_byte_fixed(uint16_t target_event_id, int16_t relative_offset_from_data_end) {\n    int event_idx = -1;\n    for (int i = 0; i < g_num_active_events; ++i) {\n        if (g_diag_event_buffer[i].event_id == target_event_id) {\n            event_idx = i;\n            break;\n        }\n    }\n\n    if (event_idx == -1 || g_diag_event_buffer[event_idx].data_len == 0) {\n        return;\n    }\n\n    int32_t target_byte_index = (int32_t)g_diag_event_buffer[event_idx].data_len - 1 - relative_offset_from_data_end;\n\n    if (target_byte_index < 0 || target_byte_index >= g_diag_event_buffer[event_idx].data_len) {\n        return;\n    }\n\n    g_diag_event_buffer[event_idx].diag_data[target_byte_index] = 0x00;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MEMORY_POOL_SIZE 512\n#define MAX_POOL_ALLOCATIONS 16\n\nstatic uint8_t s_ecu_memory_pool[MEMORY_POOL_SIZE];\nstatic int32_t s_pool_current_offset = 0;\n\ntypedef struct {\n    int32_t offset;\n    uint16_t size;\n    bool active;\n} PoolAllocationEntry;\n\nstatic PoolAllocationEntry s_allocation_table[MAX_POOL_ALLOCATIONS];\nstatic uint8_t s_num_active_allocations = 0;\n\nvoid init_ecu_memory_pool() {\n    memset(s_ecu_memory_pool, 0, MEMORY_POOL_SIZE);\n    s_pool_current_offset = 0;\n    for (int i = 0; i < MAX_POOL_ALLOCATIONS; ++i) {\n        s_allocation_table[i].active = false;\n        s_allocation_table[i].offset = 0;\n        s_allocation_table[i].size = 0;\n    }\n    s_num_active_allocations = 0;\n}\n\nvoid* allocate_pool_block(uint16_t size) {\n    if (s_num_active_allocations >= MAX_POOL_ALLOCATIONS) {\n        return NULL;\n    }\n    if ((s_pool_current_offset + size) > MEMORY_POOL_SIZE) {\n        return NULL;\n    }\n\n    void* ptr = &s_ecu_memory_pool[s_pool_current_offset];\n    s_allocation_table[s_num_active_allocations].offset = s_pool_current_offset;\n    s_allocation_table[s_num_active_allocations].size = size;\n    s_allocation_table[s_num_active_allocations].active = true;\n    s_num_active_allocations++;\n    s_pool_current_offset += size;\n    return ptr;\n}\n\nvoid reclaim_last_pool_block_vulnerable(uint16_t size_to_reclaim) {\n    if (s_pool_current_offset == 0) {\n        return;\n    }\n\n    s_pool_current_offset -= size_to_reclaim;\n\n    s_ecu_memory_pool[s_pool_current_offset] = 0xDE;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MEMORY_POOL_SIZE 512\n#define MAX_POOL_ALLOCATIONS 16\n\nstatic uint8_t s_ecu_memory_pool[MEMORY_POOL_SIZE];\nstatic int32_t s_pool_current_offset = 0;\n\ntypedef struct {\n    int32_t offset;\n    uint16_t size;\n    bool active;\n} PoolAllocationEntry;\n\nstatic PoolAllocationEntry s_allocation_table[MAX_POOL_ALLOCATIONS];\nstatic uint8_t s_num_active_allocations = 0;\n\nvoid init_ecu_memory_pool_fixed() {\n    memset(s_ecu_memory_pool, 0, MEMORY_POOL_SIZE);\n    s_pool_current_offset = 0;\n    for (int i = 0; i < MAX_POOL_ALLOCATIONS; ++i) {\n        s_allocation_table[i].active = false;\n        s_allocation_table[i].offset = 0;\n        s_allocation_table[i].size = 0;\n    }\n    s_num_active_allocations = 0;\n}\n\nvoid* allocate_pool_block_fixed(uint16_t size) {\n    if (s_num_active_allocations >= MAX_POOL_ALLOCATIONS) {\n        return NULL;\n    }\n    if ((s_pool_current_offset + size) > MEMORY_POOL_SIZE) {\n        return NULL;\n    }\n\n    void* ptr = &s_ecu_memory_pool[s_pool_current_offset];\n    s_allocation_table[s_num_active_allocations].offset = s_pool_current_offset;\n    s_allocation_table[s_num_active_allocations].size = size;\n    s_allocation_table[s_num_active_allocations].active = true;\n    s_num_active_allocations++;\n    s_pool_current_offset += size;\n    return ptr;\n}\n\nvoid reclaim_last_pool_block_fixed(uint16_t size_to_reclaim) {\n    if (s_pool_current_offset == 0) {\n        return;\n    }\n\n    if ((int32_t)size_to_reclaim > s_pool_current_offset) {\n        s_pool_current_offset = 0;\n        return;\n    }\n\n    s_pool_current_offset -= size_to_reclaim;\n\n    s_ecu_memory_pool[s_pool_current_offset] = 0xAD;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define LOG_BUFFER_SIZE 32 \n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t speed_kph;\n    uint16_t rpm;\n    uint8_t gear;\n    uint8_t brake_status;\n} VehicleState;\n\nstatic VehicleState g_state_log_buffer[LOG_BUFFER_SIZE];\nstatic int16_t g_latest_entry_idx = -1; \nstatic uint16_t g_active_entry_count = 0; \n\nvoid init_vehicle_state_logger() {\n    memset(g_state_log_buffer, 0, sizeof(g_state_log_buffer));\n    g_latest_entry_idx = -1;\n    g_active_entry_count = 0;\n}\n\nvoid add_vehicle_state_entry(uint32_t ts, uint16_t speed, uint16_t rpm, uint8_t gear_val, uint8_t brake_stat) {\n    g_latest_entry_idx = (g_latest_entry_idx + 1) % LOG_BUFFER_SIZE;\n    if (g_active_entry_count < LOG_BUFFER_SIZE) {\n        g_active_entry_count++;\n    }\n\n    g_state_log_buffer[g_latest_entry_idx].timestamp_ms = ts;\n    g_state_log_buffer[g_latest_entry_idx].speed_kph = speed;\n    g_state_log_buffer[g_latest_entry_idx].rpm = rpm;\n    g_state_log_buffer[g_latest_entry_idx].gear = gear_val;\n    g_state_log_buffer[g_latest_entry_idx].brake_status = brake_stat;\n}\n\nvoid update_historic_brake_status_vulnerable(uint16_t relative_past_steps, uint8_t new_brake_status) {\n    if (g_active_entry_count == 0) {\n        return;\n    }\n\n    int16_t target_idx = g_latest_entry_idx - relative_past_steps;\n\n    g_state_log_buffer[target_idx].brake_status = new_brake_status;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define LOG_BUFFER_SIZE 32\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t speed_kph;\n    uint16_t rpm;\n    uint8_t gear;\n    uint8_t brake_status;\n} VehicleState;\n\nstatic VehicleState g_state_log_buffer[LOG_BUFFER_SIZE];\nstatic int16_t g_latest_entry_idx = -1;\nstatic uint16_t g_active_entry_count = 0;\n\nvoid init_vehicle_state_logger_fixed() {\n    memset(g_state_log_buffer, 0, sizeof(g_state_log_buffer));\n    g_latest_entry_idx = -1;\n    g_active_entry_count = 0;\n}\n\nvoid add_vehicle_state_entry_fixed(uint32_t ts, uint16_t speed, uint16_t rpm, uint8_t gear_val, uint8_t brake_stat) {\n    g_latest_entry_idx = (g_latest_entry_idx + 1) % LOG_BUFFER_SIZE;\n    if (g_active_entry_count < LOG_BUFFER_SIZE) {\n        g_active_entry_count++;\n    }\n\n    g_state_log_buffer[g_latest_entry_idx].timestamp_ms = ts;\n    g_state_log_buffer[g_latest_entry_idx].speed_kph = speed;\n    g_state_log_buffer[g_latest_entry_idx].rpm = rpm;\n    g_state_log_buffer[g_latest_entry_idx].gear = gear_val;\n    g_state_log_buffer[g_latest_entry_idx].brake_status = brake_stat;\n}\n\nvoid update_historic_brake_status_fixed(uint16_t relative_past_steps, uint8_t new_brake_status) {\n    if (g_active_entry_count == 0) {\n        return;\n    }\n\n    if (relative_past_steps >= g_active_entry_count) {\n        return;\n    }\n\n    int16_t target_idx_calc = g_latest_entry_idx - relative_past_steps;\n    int16_t target_idx = (target_idx_calc % LOG_BUFFER_SIZE + LOG_BUFFER_SIZE) % LOG_BUFFER_SIZE;\n\n    g_state_log_buffer[target_idx].brake_status = new_brake_status;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CALIBRATION_DATA_SIZE 256\n#define VALID_CALIBRATION_CONTEXT_MAX_OFFSET 150\n\nstatic uint16_t g_system_calibrations[CALIBRATION_DATA_SIZE];\nstatic int16_t g_active_calibration_base_offset = 0;\n\nvoid init_calibration_system() {\n    memset(g_system_calibrations, 0xFF, sizeof(g_system_calibrations));\n    g_active_calibration_base_offset = 0;\n}\n\nvoid set_active_calibration_context_vulnerable(uint16_t context_id) {\n    switch (context_id) {\n        case 0x01: \n            g_active_calibration_base_offset = 0;\n            break;\n        case 0x02: \n            g_active_calibration_base_offset = 50;\n            break;\n        case 0x03: \n            g_active_calibration_base_offset = 100;\n            break;\n        case 0xFF: \n            g_active_calibration_base_offset = -10; \n            break;\n        default: \n            g_active_calibration_base_offset = 0; \n            break;\n    }\n}\n\nstatic void log_calibration_update_attempt(int32_t index, uint16_t value) {\n    volatile int32_t dummy_idx = index;\n    volatile uint16_t dummy_val = value;\n    (void)dummy_idx;\n    (void)dummy_val;\n}\n\nvoid modify_calibration_value_vulnerable(int16_t relative_index_within_context, uint16_t new_value) {\n    int32_t target_absolute_index = g_active_calibration_base_offset + relative_index_within_context;\n\n    log_calibration_update_attempt(target_absolute_index, new_value);\n\n    g_system_calibrations[target_absolute_index] = new_value;\n}\n",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CALIBRATION_DATA_SIZE 256\n#define VALID_CALIBRATION_CONTEXT_MAX_OFFSET 150\n\nstatic uint16_t g_system_calibrations_fixed[CALIBRATION_DATA_SIZE];\nstatic int16_t g_active_calibration_base_offset_fixed = 0;\n\nvoid init_calibration_system_fixed() {\n    memset(g_system_calibrations_fixed, 0xFF, sizeof(g_system_calibrations_fixed));\n    g_active_calibration_base_offset_fixed = 0;\n}\n\nvoid set_active_calibration_context_fixed(uint16_t context_id) {\n    switch (context_id) {\n        case 0x01: \n            g_active_calibration_base_offset_fixed = 0;\n            break;\n        case 0x02: \n            g_active_calibration_base_offset_fixed = 50;\n            break;\n        case 0x03: \n            g_active_calibration_base_offset_fixed = 100;\n            break;\n        case 0xFF: \n            g_active_calibration_base_offset_fixed = -1; \n            break;\n        default: \n            g_active_calibration_base_offset_fixed = 0; \n            break;\n    }\n}\n\nstatic void log_calibration_update_attempt_fixed(int32_t index, uint16_t value) {\n    volatile int32_t dummy_idx = index;\n    volatile uint16_t dummy_val = value;\n    (void)dummy_idx;\n    (void)dummy_val;\n}\n\nvoid modify_calibration_value_fixed(int16_t relative_index_within_context, uint16_t new_value) {\n    int32_t target_absolute_index = g_active_calibration_base_offset_fixed + relative_index_within_context;\n\n    if (target_absolute_index < 0 || target_absolute_index >= CALIBRATION_DATA_SIZE) {\n        log_calibration_update_attempt_fixed(-1, new_value);\n        return;\n    }\n\n    log_calibration_update_attempt_fixed(target_absolute_index, new_value);\n\n    g_system_calibrations_fixed[target_absolute_index] = new_value;\n}\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_SENSOR_READINGS 64\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    int16_t  temperature_celsius;\n    uint16_t pressure_kpa;\n    uint8_t  sensor_status; \n} SensorReading;\n\nstatic SensorReading g_sensor_data_log[MAX_SENSOR_READINGS];\nstatic uint16_t g_current_log_size = 0; \n\nvoid init_sensor_log() {\n    memset(g_sensor_data_log, 0, sizeof(g_sensor_data_log));\n    g_current_log_size = 0;\n}\n\nbool add_sensor_reading(uint32_t ts, int16_t temp, uint16_t press, uint8_t status) {\n    if (g_current_log_size >= MAX_SENSOR_READINGS) {\n        return false; \n    }\n    g_sensor_data_log[g_current_log_size].timestamp_ms = ts;\n    g_sensor_data_log[g_current_log_size].temperature_celsius = temp;\n    g_sensor_data_log[g_current_log_size].pressure_kpa = press;\n    g_sensor_data_log[g_current_log_size].sensor_status = status;\n    g_current_log_size++;\n    return true;\n}\n\nvoid correct_sensor_readings_backward_vulnerable(uint16_t start_offset_from_end, uint16_t correction_window_size) {\n    if (g_current_log_size == 0 || correction_window_size == 0) {\n        return;\n    }\n\n    int32_t effective_start_idx = (int32_t)g_current_log_size - 1 - start_offset_from_end;\n\n    for (int32_t i = 0; i < (int32_t)correction_window_size; ++i) {\n        int32_t current_idx = effective_start_idx - i;\n\n        if (current_idx >= (int32_t)g_current_log_size) {\n            continue;\n        }\n\n        if (g_sensor_data_log[current_idx].sensor_status == 1) { \n            if (current_idx + 1 < g_current_log_size) {\n                g_sensor_data_log[current_idx].temperature_celsius = g_sensor_data_log[current_idx+1].temperature_celsius;\n            } else if (current_idx - 1 >= 0) {\n                g_sensor_data_log[current_idx].temperature_celsius = g_sensor_data_log[current_idx-1].temperature_celsius;\n            } else {\n                g_sensor_data_log[current_idx].temperature_celsius = 0;\n            }\n        }\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_SENSOR_READINGS 64\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    int16_t  temperature_celsius;\n    uint16_t pressure_kpa;\n    uint8_t  sensor_status; \n} SensorReading;\n\nstatic SensorReading g_sensor_data_log_fixed[MAX_SENSOR_READINGS];\nstatic uint16_t g_current_log_size_fixed = 0; \n\nvoid init_sensor_log_fixed() {\n    memset(g_sensor_data_log_fixed, 0, sizeof(g_sensor_data_log_fixed));\n    g_current_log_size_fixed = 0;\n}\n\nbool add_sensor_reading_fixed(uint32_t ts, int16_t temp, uint16_t press, uint8_t status) {\n    if (g_current_log_size_fixed >= MAX_SENSOR_READINGS) {\n        return false; \n    }\n    g_sensor_data_log_fixed[g_current_log_size_fixed].timestamp_ms = ts;\n    g_sensor_data_log_fixed[g_current_log_size_fixed].temperature_celsius = temp;\n    g_sensor_data_log_fixed[g_current_log_size_fixed].pressure_kpa = press;\n    g_sensor_data_log_fixed[g_current_log_size_fixed].sensor_status = status;\n    g_current_log_size_fixed++;\n    return true;\n}\n\nvoid correct_sensor_readings_backward_fixed(uint16_t start_offset_from_end, uint16_t correction_window_size) {\n    if (g_current_log_size_fixed == 0 || correction_window_size == 0) {\n        return;\n    }\n\n    int32_t effective_start_idx = (int32_t)g_current_log_size_fixed - 1 - start_offset_from_end;\n\n    if (effective_start_idx < 0) {\n        return;\n    }\n\n    int32_t actual_window_size = (int32_t)correction_window_size;\n    if ((effective_start_idx - (actual_window_size - 1)) < 0) {\n        actual_window_size = effective_start_idx + 1;\n    }\n\n    for (int32_t i = 0; i < actual_window_size; ++i) {\n        int32_t current_idx = effective_start_idx - i;\n\n        if (current_idx >= (int32_t)g_current_log_size_fixed || current_idx < 0) { \n            continue;\n        }\n\n        if (g_sensor_data_log_fixed[current_idx].sensor_status == 1) { \n            if (current_idx + 1 < g_current_log_size_fixed) {\n                g_sensor_data_log_fixed[current_idx].temperature_celsius = g_sensor_data_log_fixed[current_idx+1].temperature_celsius;\n            } else if (current_idx - 1 >= 0) {\n                g_sensor_data_log_fixed[current_idx].temperature_celsius = g_sensor_data_log_fixed[current_idx-1].temperature_celsius;\n            } else {\n                g_sensor_data_log_fixed[current_idx].temperature_celsius = 0;\n            }\n        }\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define RECORD_BUFFER_SIZE 256\n#define HEADER_MAGIC_BYTE 0xAA\n#define FOOTER_MAGIC_BYTE 0x55\n#define MIN_RECORD_SIZE 8\n\nstatic uint8_t g_diagnostic_record_buffer[RECORD_BUFFER_SIZE];\nstatic int32_t g_last_record_start_offset = -1;\n\nbool parse_record(uint32_t offset) {\n    if (offset < 0 || offset >= RECORD_BUFFER_SIZE) return false;\n    volatile uint8_t magic = g_diagnostic_record_buffer[offset];\n    (void)magic;\n    return true;\n}\n\nvoid init_diagnostic_buffer() {\n    memset(g_diagnostic_record_buffer, 0, RECORD_BUFFER_SIZE);\n    g_last_record_start_offset = -1;\n}\n\nbool add_diagnostic_record(const uint8_t* payload, uint8_t payload_len) {\n    uint32_t record_total_len = 1 + 1 + payload_len + 1;\n    if (record_total_len > RECORD_BUFFER_SIZE || record_total_len < MIN_RECORD_SIZE) {\n        return false;\n    }\n\n    int32_t next_write_offset;\n    if (g_last_record_start_offset == -1) {\n        next_write_offset = 0;\n    } else {\n        uint8_t prev_payload_len = g_diagnostic_record_buffer[g_last_record_start_offset + 1];\n        next_write_offset = g_last_record_start_offset + (1 + 1 + prev_payload_len + 1);\n    }\n\n    if (next_write_offset + record_total_len > RECORD_BUFFER_SIZE) {\n        next_write_offset = 0;\n    }\n\n    g_diagnostic_record_buffer[next_write_offset] = HEADER_MAGIC_BYTE;\n    g_diagnostic_record_buffer[next_write_offset + 1] = payload_len;\n    memcpy(g_diagnostic_record_buffer + next_write_offset + 2, payload, payload_len);\n    g_diagnostic_record_buffer[next_write_offset + 2 + payload_len] = FOOTER_MAGIC_BYTE;\n\n    g_last_record_start_offset = next_write_offset;\n    return true;\n}\n\nvoid update_segment_marker_vulnerable(int16_t offset_from_last_record_start, uint8_t marker_value) {\n    if (g_last_record_start_offset == -1) {\n        return;\n    }\n\n    int32_t target_index = g_last_record_start_offset + offset_from_last_record_start;\n\n    g_diagnostic_record_buffer[target_index] = marker_value;\n\n    parse_record(g_last_record_start_offset);\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define RECORD_BUFFER_SIZE 256\n#define HEADER_MAGIC_BYTE 0xAA\n#define FOOTER_MAGIC_BYTE 0x55\n#define MIN_RECORD_SIZE 8\n\nstatic uint8_t g_diagnostic_record_buffer_fixed[RECORD_BUFFER_SIZE];\nstatic int32_t g_last_record_start_offset_fixed = -1;\n\nbool parse_record_fixed(uint32_t offset) {\n    if (offset < 0 || offset >= RECORD_BUFFER_SIZE) return false;\n    volatile uint8_t magic = g_diagnostic_record_buffer_fixed[offset];\n    (void)magic;\n    return true;\n}\n\nvoid init_diagnostic_buffer_fixed() {\n    memset(g_diagnostic_record_buffer_fixed, 0, RECORD_BUFFER_SIZE);\n    g_last_record_start_offset_fixed = -1;\n}\n\nbool add_diagnostic_record_fixed(const uint8_t* payload, uint8_t payload_len) {\n    uint32_t record_total_len = 1 + 1 + payload_len + 1;\n    if (record_total_len > RECORD_BUFFER_SIZE || record_total_len < MIN_RECORD_SIZE) {\n        return false;\n    }\n\n    int32_t next_write_offset;\n    if (g_last_record_start_offset_fixed == -1) {\n        next_write_offset = 0;\n    } else {\n        uint8_t prev_payload_len = g_diagnostic_record_buffer_fixed[g_last_record_start_offset_fixed + 1];\n        next_write_offset = g_last_record_start_offset_fixed + (1 + 1 + prev_payload_len + 1);\n    }\n\n    if (next_write_offset + record_total_len > RECORD_BUFFER_SIZE) {\n        next_write_offset = 0;\n    }\n\n    g_diagnostic_record_buffer_fixed[next_write_offset] = HEADER_MAGIC_BYTE;\n    g_diagnostic_record_buffer_fixed[next_write_offset + 1] = payload_len;\n    memcpy(g_diagnostic_record_buffer_fixed + next_write_offset + 2, payload, payload_len);\n    g_diagnostic_record_buffer_fixed[next_write_offset + 2 + payload_len] = FOOTER_MAGIC_BYTE;\n\n    g_last_record_start_offset_fixed = next_write_offset;\n    return true;\n}\n\nvoid update_segment_marker_fixed(int16_t offset_from_last_record_start, uint8_t marker_value) {\n    if (g_last_record_start_offset_fixed == -1) {\n        return;\n    }\n\n    int32_t target_index = g_last_record_start_offset_fixed + offset_from_last_record_start;\n\n    if (target_index < 0 || target_index >= RECORD_BUFFER_SIZE) {\n        return;\n    }\n\n    g_diagnostic_record_buffer_fixed[target_index] = marker_value;\n\n    parse_record_fixed(g_last_record_start_offset_fixed);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SCRATCHPAD_BUFFER_SIZE 256\n#define MAX_TEMP_DATA_BLOCKS 16\n\ntypedef struct {\n    uint16_t start_offset;\n    uint16_t size;\n    bool active;\n} TempDataBlock;\n\nstatic uint8_t g_scratchpad_buffer[SCRATCHPAD_BUFFER_SIZE];\nstatic TempDataBlock g_data_blocks_meta[MAX_TEMP_DATA_BLOCKS];\nstatic uint8_t g_num_active_blocks = 0;\n\nvoid init_scratchpad_manager() {\n    memset(g_scratchpad_buffer, 0, SCRATCHPAD_BUFFER_SIZE);\n    memset(g_data_blocks_meta, 0, sizeof(g_data_blocks_meta));\n    g_num_active_blocks = 0;\n}\n\nint16_t allocate_data_block(uint16_t requested_size) {\n    if (g_num_active_blocks >= MAX_TEMP_DATA_BLOCKS || requested_size == 0) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n    if (g_num_active_blocks > 0) {\n        TempDataBlock *last_block = &g_data_blocks_meta[g_num_active_blocks - 1];\n        current_offset = last_block->start_offset + last_block->size;\n    }\n\n    if (current_offset + requested_size > SCRATCHPAD_BUFFER_SIZE) {\n        return -1;\n    }\n\n    g_data_blocks_meta[g_num_active_blocks].start_offset = current_offset;\n    g_data_blocks_meta[g_num_active_blocks].size = requested_size;\n    g_data_blocks_meta[g_num_active_blocks].active = true;\n    g_num_active_blocks++;\n\n    return g_num_active_blocks - 1;\n}\n\nvoid write_block_data(int16_t block_idx, uint16_t offset_in_block, uint8_t value) {\n    if (block_idx < 0 || block_idx >= g_num_active_blocks || !g_data_blocks_meta[block_idx].active) {\n        return;\n    }\n    if (offset_in_block >= g_data_blocks_meta[block_idx].size) {\n        return;\n    }\n\n    uint16_t actual_buffer_idx = g_data_blocks_meta[block_idx].start_offset + offset_in_block;\n    if (actual_buffer_idx < SCRATCHPAD_BUFFER_SIZE) {\n        g_scratchpad_buffer[actual_buffer_idx] = value;\n    }\n}\n\nvoid adjust_block_byte_vulnerable(int16_t block_idx, int32_t relative_offset_from_start, uint8_t new_value) {\n    if (block_idx < 0 || block_idx >= g_num_active_blocks || !g_data_blocks_meta[block_idx].active) {\n        return; \n    }\n\n    uint16_t block_start = g_data_blocks_meta[block_idx].start_offset;\n\n    int32_t target_idx = (int32_t)block_start + relative_offset_from_start;\n\n    g_scratchpad_buffer[target_idx] = new_value;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SCRATCHPAD_BUFFER_SIZE 256\n#define MAX_TEMP_DATA_BLOCKS 16\n\ntypedef struct {\n    uint16_t start_offset;\n    uint16_t size;\n    bool active;\n} TempDataBlock;\n\nstatic uint8_t g_scratchpad_buffer_fixed[SCRATCHPAD_BUFFER_SIZE];\nstatic TempDataBlock g_data_blocks_meta_fixed[MAX_TEMP_DATA_BLOCKS];\nstatic uint8_t g_num_active_blocks_fixed = 0;\n\nvoid init_scratchpad_manager_fixed() {\n    memset(g_scratchpad_buffer_fixed, 0, SCRATCHPAD_BUFFER_SIZE);\n    memset(g_data_blocks_meta_fixed, 0, sizeof(g_data_blocks_meta_fixed));\n    g_num_active_blocks_fixed = 0;\n}\n\nint16_t allocate_data_block_fixed(uint16_t requested_size) {\n    if (g_num_active_blocks_fixed >= MAX_TEMP_DATA_BLOCKS || requested_size == 0) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n    if (g_num_active_blocks_fixed > 0) {\n        TempDataBlock *last_block = &g_data_blocks_meta_fixed[g_num_active_blocks_fixed - 1];\n        current_offset = last_block->start_offset + last_block->size;\n    }\n\n    if (current_offset + requested_size > SCRATCHPAD_BUFFER_SIZE) {\n        return -1;\n    }\n\n    g_data_blocks_meta_fixed[g_num_active_blocks_fixed].start_offset = current_offset;\n    g_data_blocks_meta_fixed[g_num_active_blocks_fixed].size = requested_size;\n    g_data_blocks_meta_fixed[g_num_active_blocks_fixed].active = true;\n    g_num_active_blocks_fixed++;\n\n    return g_num_active_blocks_fixed - 1;\n}\n\nvoid write_block_data_fixed(int16_t block_idx, uint16_t offset_in_block, uint8_t value) {\n    if (block_idx < 0 || block_idx >= g_num_active_blocks_fixed || !g_data_blocks_meta_fixed[block_idx].active) {\n        return;\n    }\n    if (offset_in_block >= g_data_blocks_meta_fixed[block_idx].size) {\n        return;\n    }\n\n    uint16_t actual_buffer_idx = g_data_blocks_meta_fixed[block_idx].start_offset + offset_in_block;\n    if (actual_buffer_idx < SCRATCHPAD_BUFFER_SIZE) {\n        g_scratchpad_buffer_fixed[actual_buffer_idx] = value;\n    }\n}\n\nvoid adjust_block_byte_fixed(int16_t block_idx, int32_t relative_offset_from_start, uint8_t new_value) {\n    if (block_idx < 0 || block_idx >= g_num_active_blocks_fixed || !g_data_blocks_meta_fixed[block_idx].active) {\n        return; \n    }\n\n    uint16_t block_start = g_data_blocks_meta_fixed[block_idx].start_offset;\n    uint16_t block_size = g_data_blocks_meta_fixed[block_idx].size;\n\n    int32_t potential_target_idx = (int32_t)block_start + relative_offset_from_start;\n\n    if (potential_target_idx < 0 || potential_target_idx >= SCRATCHPAD_BUFFER_SIZE) {\n        return; \n    }\n\n    uint16_t target_idx = (uint16_t)potential_target_idx;\n\n    if (target_idx < block_start || target_idx >= (block_start + block_size)) {\n        return; \n    }\n\n    g_scratchpad_buffer_fixed[target_idx] = new_value;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_EVENT_BUFFER_SIZE 512\n\nstatic uint8_t g_event_data_buffer[MAX_EVENT_BUFFER_SIZE];\nstatic int32_t g_current_event_sequence_start = 0;\nstatic uint16_t g_active_buffer_length = 0;\n\nvoid init_event_recorder() {\n    memset(g_event_data_buffer, 0, MAX_EVENT_BUFFER_SIZE);\n    g_current_event_sequence_start = 0;\n    g_active_buffer_length = 0;\n}\n\nbool record_raw_event_data(const uint8_t* data, uint16_t len) {\n    if (len == 0 || data == NULL) return false;\n    if (g_active_buffer_length + len > MAX_EVENT_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_event_data_buffer + g_active_buffer_length, data, len);\n    g_active_buffer_length += len;\n    return true;\n}\n\nconst uint8_t* get_event_data_at_offset(int32_t offset, uint16_t* len) {\n    if (offset < 0 || offset >= g_active_buffer_length) {\n        if (len) *len = 0;\n        return NULL;\n    }\n    if (len) *len = (uint16_t)(g_active_buffer_length - offset);\n    return g_event_data_buffer + offset;\n}\n\nvoid set_event_sequence_start_backward_vulnerable(uint16_t relative_back_offset_bytes) {\n    g_current_event_sequence_start -= relative_back_offset_bytes;\n}\n\nvoid mark_current_event_status_vulnerable(uint8_t status_code) {\n    g_event_data_buffer[g_current_event_sequence_start] = status_code;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_EVENT_BUFFER_SIZE_FIXED 512\n\nstatic uint8_t g_event_data_buffer_fixed[MAX_EVENT_BUFFER_SIZE_FIXED];\nstatic int32_t g_current_event_sequence_start_fixed = 0;\nstatic uint16_t g_active_buffer_length_fixed = 0;\n\nvoid init_event_recorder_fixed() {\n    memset(g_event_data_buffer_fixed, 0, MAX_EVENT_BUFFER_SIZE_FIXED);\n    g_current_event_sequence_start_fixed = 0;\n    g_active_buffer_length_fixed = 0;\n}\n\nbool record_raw_event_data_fixed(const uint8_t* data, uint16_t len) {\n    if (len == 0 || data == NULL) return false;\n    if (g_active_buffer_length_fixed + len > MAX_EVENT_BUFFER_SIZE_FIXED) {\n        return false;\n    }\n    memcpy(g_event_data_buffer_fixed + g_active_buffer_length_fixed, data, len);\n    g_active_buffer_length_fixed += len;\n    return true;\n}\n\nconst uint8_t* get_event_data_at_offset_fixed(int32_t offset, uint16_t* len) {\n    if (offset < 0 || offset >= g_active_buffer_length_fixed) {\n        if (len) *len = 0;\n        return NULL;\n    }\n    if (len) *len = (uint16_t)(g_active_buffer_length_fixed - offset);\n    return g_event_data_buffer_fixed + offset;\n}\n\nvoid set_event_sequence_start_backward_fixed(uint16_t relative_back_offset_bytes) {\n    int32_t proposed_offset = g_current_event_sequence_start_fixed - relative_back_offset_bytes;\n\n    if (proposed_offset < 0) {\n        g_current_event_sequence_start_fixed = 0;\n    } else {\n        g_current_event_sequence_start_fixed = proposed_offset;\n    }\n}\n\nvoid mark_current_event_status_fixed(uint8_t status_code) {\n    if (g_current_event_sequence_start_fixed < 0 || g_current_event_sequence_start_fixed >= MAX_EVENT_BUFFER_SIZE_FIXED) {\n        return;\n    }\n    g_event_data_buffer_fixed[g_current_event_sequence_start_fixed] = status_code;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_TELEMETRY_BUFFER_SIZE 1024\n#define EVENT_BLOCK_SIZE 32\n\nstatic uint8_t g_telemetry_buffer[MAX_TELEMETRY_BUFFER_SIZE];\nstatic int32_t g_active_event_start_offset = 0;\n\nvoid init_telemetry_system() {\n    memset(g_telemetry_buffer, 0, MAX_TELEMETRY_BUFFER_SIZE);\n    g_active_event_start_offset = 0;\n}\n\nbool log_telemetry_event(const uint8_t* event_data) {\n    static uint32_t current_write_pos = 0;\n\n    if (current_write_pos + EVENT_BLOCK_SIZE > MAX_TELEMETRY_BUFFER_SIZE) {\n        current_write_pos = 0;\n    }\n\n    memcpy(g_telemetry_buffer + current_write_pos, event_data, EVENT_BLOCK_SIZE);\n    \n    current_write_pos += EVENT_BLOCK_SIZE;\n\n    return true;\n}\n\nvoid process_telemetry_block_at_offset(int32_t offset) {\n    if (offset < 0 || offset + EVENT_BLOCK_SIZE > MAX_TELEMETRY_BUFFER_SIZE) {\n        return;\n    }\n    volatile uint32_t timestamp_ms = *(uint32_t*)(g_telemetry_buffer + offset);\n    (void)timestamp_ms;\n}\n\nvoid shift_telemetry_pointer_backward_vulnerable(uint16_t blocks_to_shift) {\n    if (blocks_to_shift == 0) {\n        return;\n    }\n\n    g_active_event_start_offset -= (int32_t)blocks_to_shift * EVENT_BLOCK_SIZE;\n\n    g_telemetry_buffer[g_active_event_start_offset - 1] = 0xDE;\n\n    if (g_active_event_start_offset >= 0 && g_active_event_start_offset < MAX_TELEMETRY_BUFFER_SIZE) {\n        process_telemetry_block_at_offset(g_active_event_start_offset);\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_TELEMETRY_BUFFER_SIZE 1024\n#define EVENT_BLOCK_SIZE 32\n\nstatic uint8_t g_telemetry_buffer_fixed[MAX_TELEMETRY_BUFFER_SIZE];\nstatic int32_t g_active_event_start_offset_fixed = 0;\n\nvoid init_telemetry_system_fixed() {\n    memset(g_telemetry_buffer_fixed, 0, MAX_TELEMETRY_BUFFER_SIZE);\n    g_active_event_start_offset_fixed = 0;\n}\n\nbool log_telemetry_event_fixed(const uint8_t* event_data) {\n    static uint32_t current_write_pos_fixed = 0;\n\n    if (current_write_pos_fixed + EVENT_BLOCK_SIZE > MAX_TELEMETRY_BUFFER_SIZE) {\n        current_write_pos_fixed = 0;\n    }\n\n    memcpy(g_telemetry_buffer_fixed + current_write_pos_fixed, event_data, EVENT_BLOCK_SIZE);\n    \n    current_write_pos_fixed += EVENT_BLOCK_SIZE;\n    return true;\n}\n\nvoid process_telemetry_block_at_offset_fixed(int32_t offset) {\n    if (offset < 0 || offset + EVENT_BLOCK_SIZE > MAX_TELEMETRY_BUFFER_SIZE) {\n        return;\n    }\n    volatile uint32_t timestamp_ms = *(uint32_t*)(g_telemetry_buffer_fixed + offset);\n    (void)timestamp_ms;\n}\n\nvoid shift_telemetry_pointer_backward_fixed(uint16_t blocks_to_shift) {\n    if (blocks_to_shift == 0) {\n        return;\n    }\n\n    int32_t new_offset = g_active_event_start_offset_fixed - ((int32_t)blocks_to_shift * EVENT_BLOCK_SIZE);\n\n    if (new_offset < 0) {\n        new_offset = 0;\n    }\n    \n    g_active_event_start_offset_fixed = new_offset;\n\n    if (g_active_event_start_offset_fixed > 0 && g_active_event_start_offset_fixed - 1 >= 0) {\n        g_telemetry_buffer_fixed[g_active_event_start_offset_fixed - 1] = 0xAD;\n    }\n\n    if (g_active_event_start_offset_fixed >= 0 && g_active_event_start_offset_fixed < MAX_TELEMETRY_BUFFER_SIZE) {\n        process_telemetry_block_at_offset_fixed(g_active_event_start_offset_fixed);\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define REASM_BUFFER_SIZE 256\n#define MIN_MESSAGE_HEADER_SIZE 4\n\ntypedef struct {\n    uint16_t id;\n    uint16_t length;\n    uint8_t  payload[1]; \n} MessageHeader;\n\nstatic uint8_t g_reasm_buffer[REASM_BUFFER_SIZE];\nstatic uint16_t g_filled_size = 0;\n\nvoid init_reasm_buffer() {\n    memset(g_reasm_buffer, 0, REASM_BUFFER_SIZE);\n    g_filled_size = 0;\n}\n\nbool add_reasm_data(const uint8_t* data, uint16_t len) {\n    if (g_filled_size + len > REASM_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_reasm_buffer + g_filled_size, data, len);\n    g_filled_size += len;\n    return true;\n}\n\nvoid finalize_message_block_vulnerable(int16_t message_start_offset) {\n    if (message_start_offset < 0 || message_start_offset >= g_filled_size) {\n        return;\n    }\n\n    if (message_start_offset + MIN_MESSAGE_HEADER_SIZE > g_filled_size) {\n        return;\n    }\n\n    MessageHeader* msg_header = (MessageHeader*)(g_reasm_buffer + message_start_offset);\n    uint16_t message_length = msg_header->length;\n\n    if (message_start_offset + message_length > g_filled_size || message_length == 0) {\n        return;\n    }\n\n    uint8_t calculated_status_byte = 0xAF;\n\n    g_reasm_buffer[message_start_offset - 1] = calculated_status_byte;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define REASM_BUFFER_SIZE 256\n#define MIN_MESSAGE_HEADER_SIZE 4\n\ntypedef struct {\n    uint16_t id;\n    uint16_t length;\n    uint8_t  payload[1];\n} MessageHeader;\n\nstatic uint8_t g_reasm_buffer_fixed[REASM_BUFFER_SIZE];\nstatic uint16_t g_filled_size_fixed = 0;\n\nvoid init_reasm_buffer_fixed() {\n    memset(g_reasm_buffer_fixed, 0, REASM_BUFFER_SIZE);\n    g_filled_size_fixed = 0;\n}\n\nbool add_reasm_data_fixed(const uint8_t* data, uint16_t len) {\n    if (g_filled_size_fixed + len > REASM_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_reasm_buffer_fixed + g_filled_size_fixed, data, len);\n    g_filled_size_fixed += len;\n    return true;\n}\n\nvoid finalize_message_block_fixed(int16_t message_start_offset) {\n    if (message_start_offset < 0 || message_start_offset >= g_filled_size_fixed) {\n        return;\n    }\n\n    if (message_start_offset + MIN_MESSAGE_HEADER_SIZE > g_filled_size_fixed) {\n        return;\n    }\n\n    MessageHeader* msg_header = (MessageHeader*)(g_reasm_buffer_fixed + message_start_offset);\n    uint16_t message_length = msg_header->length;\n\n    if (message_start_offset + message_length > g_filled_size_fixed || message_length == 0) {\n        return;\n    }\n\n    uint8_t calculated_status_byte = 0xAF;\n\n    if (message_start_offset - 1 < 0) {\n        return; \n    }\n\n    g_reasm_buffer_fixed[message_start_offset - 1] = calculated_status_byte;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_STORAGE_SIZE 128\n#define CONFIG_VALUE_BYTE_SIZE 4\n\nstatic uint8_t g_vehicle_config_storage[VEHICLE_CONFIG_STORAGE_SIZE];\nstatic uint32_t g_current_config_data_len = 0;\n\nvoid init_ecu_config_manager() {\n    memset(g_vehicle_config_storage, 0, VEHICLE_CONFIG_STORAGE_SIZE);\n    g_current_config_data_len = 0;\n}\n\nvoid load_config_data_block(const uint8_t* data, uint32_t len) {\n    if (len > VEHICLE_CONFIG_STORAGE_SIZE) {\n        len = VEHICLE_CONFIG_STORAGE_SIZE;\n    }\n    memcpy(g_vehicle_config_storage, data, len);\n    g_current_config_data_len = len;\n}\n\nvoid update_past_config_value_vulnerable(uint32_t start_index_bytes, uint8_t backward_steps_slots, int32_t new_value) {\n    if (start_index_bytes >= g_current_config_data_len) {\n        return;\n    }\n\n    int32_t target_byte_offset = (int32_t)start_index_bytes - ((int32_t)backward_steps_slots * CONFIG_VALUE_BYTE_SIZE);\n\n    g_vehicle_config_storage[target_byte_offset + 0] = (uint8_t)(new_value >> 24);\n    g_vehicle_config_storage[target_byte_offset + 1] = (uint8_t)(new_value >> 16);\n    g_vehicle_config_storage[target_byte_offset + 2] = (uint8_t)(new_value >> 8);\n    g_vehicle_config_storage[target_byte_offset + 3] = (uint8_t)(new_value);\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_STORAGE_SIZE 128\n#define CONFIG_VALUE_BYTE_SIZE 4\n\nstatic uint8_t g_vehicle_config_storage[VEHICLE_CONFIG_STORAGE_SIZE];\nstatic uint32_t g_current_config_data_len = 0;\n\nvoid init_ecu_config_manager() {\n    memset(g_vehicle_config_storage, 0, VEHICLE_CONFIG_STORAGE_SIZE);\n    g_current_config_data_len = 0;\n}\n\nvoid load_config_data_block(const uint8_t* data, uint32_t len) {\n    if (len > VEHICLE_CONFIG_STORAGE_SIZE) {\n        len = VEHICLE_CONFIG_STORAGE_SIZE;\n    }\n    memcpy(g_vehicle_config_storage, data, len);\n    g_current_config_data_len = len;\n}\n\nvoid update_past_config_value_fixed(uint32_t start_index_bytes, uint8_t backward_steps_slots, int32_t new_value) {\n    if (start_index_bytes >= g_current_config_data_len) {\n        return;\n    }\n\n    int32_t target_byte_offset = (int32_t)start_index_bytes - ((int32_t)backward_steps_slots * CONFIG_VALUE_BYTE_SIZE);\n\n    if (target_byte_offset < 0 || (target_byte_offset + CONFIG_VALUE_BYTE_SIZE) > VEHICLE_CONFIG_STORAGE_SIZE) {\n        return;\n    }\n\n    g_vehicle_config_storage[target_byte_offset + 0] = (uint8_t)(new_value >> 24);\n    g_vehicle_config_storage[target_byte_offset + 1] = (uint8_t)(new_value >> 16);\n    g_vehicle_config_storage[target_byte_offset + 2] = (uint8_t)(new_value >> 8);\n    g_vehicle_config_storage[target_byte_offset + 3] = (uint8_t)(new_value);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CAN_DIAG_BUFFER_SIZE 256\n#define CAN_MSG_HEADER_SIZE  4\n#define MIN_MSG_PAYLOAD_SIZE 1\n#define MAX_MSG_PAYLOAD_SIZE (CAN_DIAG_BUFFER_SIZE - CAN_MSG_HEADER_SIZE)\n\ntypedef struct {\n    uint16_t message_id;\n    uint8_t  payload_len;\n    uint8_t  control_byte;\n    uint8_t  payload_data[MAX_MSG_PAYLOAD_SIZE];\n} CAN_DiagMessage;\n\nstatic uint8_t g_diag_raw_buffer[CAN_DIAG_BUFFER_SIZE];\nstatic int32_t g_current_buffer_offset = 0;\nstatic uint32_t g_data_in_buffer = 0;\n\nvoid init_diag_buffer() {\n    memset(g_diag_raw_buffer, 0, CAN_DIAG_BUFFER_SIZE);\n    g_current_buffer_offset = 0;\n    g_data_in_buffer = 0;\n}\n\nbool append_diag_data(const uint8_t* data, uint16_t len) {\n    if (g_data_in_buffer + len > CAN_DIAG_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_diag_raw_buffer + g_data_in_buffer, data, len);\n    g_data_in_buffer += len;\n    return true;\n}\n\nvoid process_complete_diag_message(const CAN_DiagMessage* msg) {\n    volatile uint16_t id = msg->message_id;\n    (void)id;\n}\n\nvoid mark_message_pre_header_vulnerable(uint8_t marker_byte) {\n    g_diag_raw_buffer[g_current_buffer_offset - 1] = marker_byte;\n    \n    if (g_current_buffer_offset < g_data_in_buffer) {\n        CAN_DiagMessage* current_msg = (CAN_DiagMessage*)(g_diag_raw_buffer + g_current_buffer_offset);\n        process_complete_diag_message(current_msg);\n    }\n}\n\nvoid advance_buffer_offset(uint16_t bytes_consumed) {\n    if (g_current_buffer_offset + bytes_consumed <= g_data_in_buffer) {\n        g_current_buffer_offset += bytes_consumed;\n    } else {\n        g_current_buffer_offset = g_data_in_buffer;\n    }\n    if (g_current_buffer_offset == g_data_in_buffer) {\n        g_current_buffer_offset = 0;\n        g_data_in_buffer = 0;\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CAN_DIAG_BUFFER_SIZE_FIXED 256\n#define CAN_MSG_HEADER_SIZE_FIXED  4\n#define MIN_MSG_PAYLOAD_SIZE_FIXED 1\n#define MAX_MSG_PAYLOAD_SIZE_FIXED (CAN_DIAG_BUFFER_SIZE_FIXED - CAN_MSG_HEADER_SIZE_FIXED)\n\ntypedef struct {\n    uint16_t message_id;\n    uint8_t  payload_len;\n    uint8_t  control_byte;\n    uint8_t  payload_data[MAX_MSG_PAYLOAD_SIZE_FIXED];\n} CAN_DiagMessage_Fixed;\n\nstatic uint8_t g_diag_raw_buffer_fixed[CAN_DIAG_BUFFER_SIZE_FIXED];\nstatic int32_t g_current_buffer_offset_fixed = 0;\nstatic uint32_t g_data_in_buffer_fixed = 0;\n\nvoid init_diag_buffer_fixed() {\n    memset(g_diag_raw_buffer_fixed, 0, CAN_DIAG_BUFFER_SIZE_FIXED);\n    g_current_buffer_offset_fixed = 0;\n    g_data_in_buffer_fixed = 0;\n}\n\nbool append_diag_data_fixed(const uint8_t* data, uint16_t len) {\n    if (g_data_in_buffer_fixed + len > CAN_DIAG_BUFFER_SIZE_FIXED) {\n        return false;\n    }\n    memcpy(g_diag_raw_buffer_fixed + g_data_in_buffer_fixed, data, len);\n    g_data_in_buffer_fixed += len;\n    return true;\n}\n\nvoid process_complete_diag_message_fixed(const CAN_DiagMessage_Fixed* msg) {\n    volatile uint16_t id = msg->message_id;\n    (void)id;\n}\n\nvoid mark_message_pre_header_fixed(uint8_t marker_byte) {\n    if (g_current_buffer_offset_fixed > 0) {\n        g_diag_raw_buffer_fixed[g_current_buffer_offset_fixed - 1] = marker_byte;\n    } else {\n        return;\n    }\n    \n    if (g_current_buffer_offset_fixed < g_data_in_buffer_fixed) {\n        CAN_DiagMessage_Fixed* current_msg = (CAN_DiagMessage_Fixed*)(g_diag_raw_buffer_fixed + g_current_buffer_offset_fixed);\n        process_complete_diag_message_fixed(current_msg);\n    }\n}\n\nvoid advance_buffer_offset_fixed(uint16_t bytes_consumed) {\n    if (g_current_buffer_offset_fixed + bytes_consumed <= g_data_in_buffer_fixed) {\n        g_current_buffer_offset_fixed += bytes_consumed;\n    } else {\n        g_current_buffer_offset_fixed = g_data_in_buffer_fixed;\n    }\n    if (g_current_buffer_offset_fixed == g_data_in_buffer_fixed) {\n        g_current_buffer_offset_fixed = 0;\n        g_data_in_buffer_fixed = 0;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SENSOR_HISTORY_BUFFER_SIZE 8\n#define INITIAL_OFFSET_VALUE 0\n\nstatic int16_t g_sensor_readings_history[SENSOR_HISTORY_BUFFER_SIZE];\nstatic int16_t g_current_history_idx = -1; \nstatic uint8_t g_filled_count = 0; \n\nvoid init_sensor_history_module() {\n    memset(g_sensor_readings_history, INITIAL_OFFSET_VALUE, sizeof(g_sensor_readings_history));\n    g_current_history_idx = -1;\n    g_filled_count = 0;\n}\n\nvoid record_sensor_reading(int16_t reading) {\n    if (g_filled_count < SENSOR_HISTORY_BUFFER_SIZE) {\n        g_current_history_idx++;\n        g_filled_count++;\n    } else {\n        g_current_history_idx = (g_current_history_idx + 1) % SENSOR_HISTORY_BUFFER_SIZE;\n    }\n    g_sensor_readings_history[g_current_history_idx] = reading;\n}\n\nvoid adjust_historical_sensor_value_vulnerable(int16_t correction_value, uint8_t lookback_depth) {\n    if (g_filled_count == 0) {\n        return;\n    }\n\n    if (lookback_depth == 0 || lookback_depth > g_filled_count) {\n        return;\n    }\n\n    int16_t source_idx = g_current_history_idx - (int16_t)lookback_depth;\n\n    g_sensor_readings_history[source_idx] += correction_value;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SENSOR_HISTORY_BUFFER_SIZE 8\n#define INITIAL_OFFSET_VALUE 0\n\nstatic int16_t g_sensor_readings_history_fixed[SENSOR_HISTORY_BUFFER_SIZE];\nstatic int16_t g_current_history_idx_fixed = -1;\nstatic uint8_t g_filled_count_fixed = 0;\n\nvoid init_sensor_history_module_fixed() {\n    memset(g_sensor_readings_history_fixed, INITIAL_OFFSET_VALUE, sizeof(g_sensor_readings_history_fixed));\n    g_current_history_idx_fixed = -1;\n    g_filled_count_fixed = 0;\n}\n\nvoid record_sensor_reading_fixed(int16_t reading) {\n    if (g_filled_count_fixed < SENSOR_HISTORY_BUFFER_SIZE) {\n        g_current_history_idx_fixed++;\n        g_filled_count_fixed++;\n    } else {\n        g_current_history_idx_fixed = (g_current_history_idx_fixed + 1) % SENSOR_HISTORY_BUFFER_SIZE;\n    }\n    g_sensor_readings_history_fixed[g_current_history_idx_fixed] = reading;\n}\n\nvoid adjust_historical_sensor_value_fixed(int16_t correction_value, uint8_t lookback_depth) {\n    if (g_filled_count_fixed == 0) {\n        return;\n    }\n\n    if (lookback_depth >= g_filled_count_fixed) {\n        return;\n    }\n\n    int32_t raw_target_idx = (int32_t)g_current_history_idx_fixed - (int32_t)lookback_depth;\n    int16_t source_idx = (raw_target_idx % SENSOR_HISTORY_BUFFER_SIZE + SENSOR_HISTORY_BUFFER_SIZE) % SENSOR_HISTORY_BUFFER_SIZE;\n\n    g_sensor_readings_history_fixed[source_idx] += correction_value;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CALIBRATION_POOL_SIZE 512\n#define NUM_CALIBRATION_BLOCKS 4\n\ntypedef struct {\n    uint16_t base_address; \n    uint16_t length;       \n    bool     is_active;    \n} CalibrationBlock;\n\nstatic uint8_t g_calibration_pool[CALIBRATION_POOL_SIZE];\n\nstatic CalibrationBlock g_calibration_blocks[NUM_CALIBRATION_BLOCKS] = {\n    { .base_address = 0,   .length = 100, .is_active = true },  \n    { .base_address = 100, .length = 150, .is_active = true },  \n    { .base_address = 250, .length = 50,  .is_active = true },  \n    { .base_address = 300, .length = 200, .is_active = true }   \n};\n\nvoid init_calibration_manager_vulnerable() {\n    memset(g_calibration_pool, 0xFF, CALIBRATION_POOL_SIZE);\n}\n\nuint8_t read_calibration_byte_vulnerable(uint8_t block_id, int16_t relative_offset) {\n    if (block_id >= NUM_CALIBRATION_BLOCKS || !g_calibration_blocks[block_id].is_active) {\n        return 0xFF;\n    }\n\n    CalibrationBlock* block = &g_calibration_blocks[block_id];\n    int32_t absolute_idx = (int32_t)block->base_address + relative_offset;\n\n    if (absolute_idx < 0 || absolute_idx >= CALIBRATION_POOL_SIZE) {\n        return 0xFF;\n    }\n\n    if (relative_offset < 0 || relative_offset >= block->length) {\n        return 0xFF;\n    }\n\n    return g_calibration_pool[absolute_idx];\n}\n\nvoid update_calibration_value_vulnerable(uint8_t block_id, int16_t relative_offset, uint8_t new_value) {\n    if (block_id >= NUM_CALIBRATION_BLOCKS || !g_calibration_blocks[block_id].is_active) {\n        return;\n    }\n\n    CalibrationBlock* block = &g_calibration_blocks[block_id];\n\n    int32_t target_absolute_idx = (int32_t)block->base_address + relative_offset;\n\n    g_calibration_pool[target_absolute_idx] = new_value;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stbool.h>\n#include <string.h>\n\n#define CALIBRATION_POOL_SIZE 512\n#define NUM_CALIBRATION_BLOCKS 4\n\ntypedef struct {\n    uint16_t base_address; \n    uint16_t length;       \n    bool     is_active;    \n} CalibrationBlock;\n\nstatic uint8_t g_calibration_pool_fixed[CALIBRATION_POOL_SIZE];\n\nstatic CalibrationBlock g_calibration_blocks_fixed[NUM_CALIBRATION_BLOCKS] = {\n    { .base_address = 0,   .length = 100, .is_active = true },  \n    { .base_address = 100, .length = 150, .is_active = true },  \n    { .base_address = 250, .length = 50,  .is_active = true },  \n    { .base_address = 300, .length = 200, .is_active = true }   \n};\n\nvoid init_calibration_manager_fixed() {\n    memset(g_calibration_pool_fixed, 0xFF, CALIBRATION_POOL_SIZE);\n}\n\nuint8_t read_calibration_byte_fixed(uint8_t block_id, int16_t relative_offset) {\n    if (block_id >= NUM_CALIBRATION_BLOCKS || !g_calibration_blocks_fixed[block_id].is_active) {\n        return 0xFF;\n    }\n\n    CalibrationBlock* block = &g_calibration_blocks_fixed[block_id];\n    int32_t absolute_idx = (int32_t)block->base_address + relative_offset;\n\n    if (absolute_idx < 0 || absolute_idx >= CALIBRATION_POOL_SIZE) {\n        return 0xFF;\n    }\n\n    if (relative_offset < 0 || relative_offset >= block->length) {\n        return 0xFF;\n    }\n\n    return g_calibration_pool_fixed[absolute_idx];\n}\n\nvoid update_calibration_value_fixed(uint8_t block_id, int16_t relative_offset, uint8_t new_value) {\n    if (block_id >= NUM_CALIBRATION_BLOCKS || !g_calibration_blocks_fixed[block_id].is_active) {\n        return;\n    }\n\n    CalibrationBlock* block = &g_calibration_blocks_fixed[block_id];\n\n    if (relative_offset < 0 || relative_offset >= block->length) {\n        return;\n    }\n\n    int32_t target_absolute_idx = (int32_t)block->base_address + relative_offset;\n\n    if (target_absolute_idx < 0 || target_absolute_idx >= CALIBRATION_POOL_SIZE) {\n        return;\n    }\n    \n    g_calibration_pool_fixed[target_absolute_idx] = new_value;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CONFIG_BUFFER_SIZE 512\n#define MAX_BLOCK_PAYLOAD_SIZE 128\n#define BLOCK_HEADER_SIZE (sizeof(uint16_t) + sizeof(uint8_t))\n\nstatic uint8_t g_config_store[CONFIG_BUFFER_SIZE];\nstatic uint32_t g_current_data_end = 0;\n\nvoid init_config_store() {\n    memset(g_config_store, 0, CONFIG_BUFFER_SIZE);\n    g_current_data_end = 0;\n}\n\nbool add_config_block(uint16_t type, const uint8_t* payload, uint8_t payload_len) {\n    if (payload_len > MAX_BLOCK_PAYLOAD_SIZE) {\n        return false;\n    }\n    uint32_t block_total_size = BLOCK_HEADER_SIZE + payload_len;\n\n    if (g_current_data_end + block_total_size > CONFIG_BUFFER_SIZE) {\n        return false;\n    }\n\n    uint8_t* dest_ptr = g_config_store + g_current_data_end;\n\n    *(uint16_t*)dest_ptr = type;\n    dest_ptr[2] = payload_len;\n    memcpy(dest_ptr + BLOCK_HEADER_SIZE, payload, payload_len);\n\n    g_current_data_end += block_total_size;\n    return true;\n}\n\nvoid process_config_block_at_offset(uint32_t offset) {\n    if (offset >= g_current_data_end) return;\n    volatile uint16_t block_type_val = *(uint16_t*)(g_config_store + offset);\n    (void)block_type_val;\n}\n\nvoid rewind_config_buffer_vulnerable(uint8_t rewind_level) {\n    if (g_current_data_end == 0) {\n        return;\n    }\n\n    #define CONCEPTUAL_SEGMENT_SIZE 32\n\n    uint32_t total_rewind_bytes = (uint32_t)rewind_level * CONCEPTUAL_SEGMENT_SIZE;\n\n    int32_t start_clear_idx_signed = (int32_t)g_current_data_end - total_rewind_bytes;\n\n    for (uint32_t i = 0; i < total_rewind_bytes; ++i) {\n        g_config_store[start_clear_idx_signed + i] = 0x00;\n    }\n\n    if (start_clear_idx_signed < 0) {\n        g_current_data_end = 0;\n    } else {\n        g_current_data_end = (uint32_t)start_clear_idx_signed;\n    }\n\n    process_config_block_at_offset(g_current_data_end > 0 ? g_current_data_end - 1 : 0);\n}",
    "fixed_code": "#include <stdint.h>\n#include <stbool.h>\n#include <string.h>\n\n#define CONFIG_BUFFER_SIZE_FIXED 512\n#define MAX_BLOCK_PAYLOAD_SIZE_FIXED 128\n#define BLOCK_HEADER_SIZE_FIXED (sizeof(uint16_t) + sizeof(uint8_t))\n\nstatic uint8_t g_config_store_fixed[CONFIG_BUFFER_SIZE_FIXED];\nstatic uint32_t g_current_data_end_fixed = 0;\n\nvoid init_config_store_fixed() {\n    memset(g_config_store_fixed, 0, CONFIG_BUFFER_SIZE_FIXED);\n    g_current_data_end_fixed = 0;\n}\n\nbool add_config_block_fixed(uint16_t type, const uint8_t* payload, uint8_t payload_len) {\n    if (payload_len > MAX_BLOCK_PAYLOAD_SIZE_FIXED) {\n        return false;\n    }\n    uint32_t block_total_size = BLOCK_HEADER_SIZE_FIXED + payload_len;\n\n    if (g_current_data_end_fixed + block_total_size > CONFIG_BUFFER_SIZE_FIXED) {\n        return false;\n    }\n\n    uint8_t* dest_ptr = g_config_store_fixed + g_current_data_end_fixed;\n\n    *(uint16_t*)dest_ptr = type;\n    dest_ptr[2] = payload_len;\n    memcpy(dest_ptr + BLOCK_HEADER_SIZE_FIXED, payload, payload_len);\n\n    g_current_data_end_fixed += block_total_size;\n    return true;\n}\n\nvoid process_config_block_at_offset_fixed(uint32_t offset) {\n    if (offset >= g_current_data_end_fixed) return;\n    volatile uint16_t block_type_val = *(uint16_t*)(g_config_store_fixed + offset);\n    (void)block_type_val;\n}\n\nvoid rewind_config_buffer_fixed(uint8_t rewind_level) {\n    if (g_current_data_end_fixed == 0) {\n        return;\n    }\n\n    #define CONCEPTUAL_SEGMENT_SIZE_FIXED 32\n\n    uint32_t total_rewind_bytes = (uint32_t)rewind_level * CONCEPTUAL_SEGMENT_SIZE_FIXED;\n\n    uint32_t actual_start_clear_idx;\n    uint32_t bytes_to_clear_in_buffer;\n\n    if (total_rewind_bytes >= g_current_data_end_fixed) {\n        actual_start_clear_idx = 0;\n        bytes_to_clear_in_buffer = g_current_data_end_fixed;\n    } else {\n        actual_start_clear_idx = g_current_data_end_fixed - total_rewind_bytes;\n        bytes_to_clear_in_buffer = total_rewind_bytes;\n    }\n\n    for (uint32_t i = 0; i < bytes_to_clear_in_buffer; ++i) {\n        g_config_store_fixed[actual_start_clear_idx + i] = 0x00;\n    }\n\n    g_current_data_end_fixed = actual_start_clear_idx;\n\n    process_config_block_at_offset_fixed(g_current_data_end_fixed > 0 ? g_current_data_end_fixed - 1 : 0);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_EVENT_BUFFER_SIZE 32\n#define DIAG_EVENT_DATA_LEN 8\n\ntypedef struct {\n    uint32_t event_timestamp;\n    uint16_t event_id;\n    uint8_t event_data[DIAG_EVENT_DATA_LEN];\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diag_event_buffer[DIAG_EVENT_BUFFER_SIZE];\nstatic int32_t g_diag_write_idx = -1; \nstatic uint32_t g_events_in_buffer = 0;\n\nvoid init_diag_event_recorder() {\n    memset(g_diag_event_buffer, 0, sizeof(g_diag_event_buffer));\n    g_diag_write_idx = -1;\n    g_events_in_buffer = 0;\n}\n\nvoid record_diagnostic_event(uint16_t id, const uint8_t* data) {\n    g_diag_write_idx = (g_diag_write_idx + 1) % DIAG_EVENT_BUFFER_SIZE;\n    g_diag_event_buffer[g_diag_write_idx].event_timestamp = 0xDEADBEEF; \n    g_diag_event_buffer[g_diag_write_idx].event_id = id;\n    memcpy(g_diag_event_buffer[g_diag_write_idx].event_data, data, DIAG_EVENT_DATA_LEN);\n    g_events_in_buffer++;\n}\n\nDiagnosticEvent* get_previous_diag_event_vulnerable(uint32_t steps_back) {\n    if (g_events_in_buffer == 0) {\n        return NULL;\n    }\n\n    int32_t target_idx_raw = g_diag_write_idx - steps_back;\n\n    int32_t final_target_idx = target_idx_raw % DIAG_EVENT_BUFFER_SIZE;\n\n    return &g_diag_event_buffer[final_target_idx];\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_EVENT_BUFFER_SIZE 32\n#define DIAG_EVENT_DATA_LEN 8\n\ntypedef struct {\n    uint32_t event_timestamp;\n    uint16_t event_id;\n    uint8_t event_data[DIAG_EVENT_DATA_LEN];\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diag_event_buffer_fixed[DIAG_EVENT_BUFFER_SIZE];\nstatic int32_t g_diag_write_idx_fixed = -1; \nstatic uint32_t g_events_in_buffer_fixed = 0;\n\nvoid init_diag_event_recorder_fixed() {\n    memset(g_diag_event_buffer_fixed, 0, sizeof(g_diag_event_buffer_fixed));\n    g_diag_write_idx_fixed = -1;\n    g_events_in_buffer_fixed = 0;\n}\n\nvoid record_diagnostic_event_fixed(uint16_t id, const uint8_t* data) {\n    g_diag_write_idx_fixed = (g_diag_write_idx_fixed + 1) % DIAG_EVENT_BUFFER_SIZE;\n    g_diag_event_buffer_fixed[g_diag_write_idx_fixed].event_timestamp = 0xDEADBEEF; \n    g_diag_event_buffer_fixed[g_diag_write_idx_fixed].event_id = id;\n    memcpy(g_diag_event_buffer_fixed[g_diag_write_idx_fixed].event_data, data, DIAG_EVENT_DATA_LEN);\n    g_events_in_buffer_fixed++;\n}\n\nDiagnosticEvent* get_previous_diag_event_fixed(uint32_t steps_back) {\n    if (g_events_in_buffer_fixed == 0) {\n        return NULL;\n    }\n\n    uint32_t current_valid_elements = (g_events_in_buffer_fixed < DIAG_EVENT_BUFFER_SIZE) ? g_events_in_buffer_fixed : DIAG_EVENT_BUFFER_SIZE;\n\n    if (steps_back >= current_valid_elements) {\n        return NULL;\n    }\n\n    int32_t target_idx_raw = g_diag_write_idx_fixed - steps_back;\n\n    int32_t final_target_idx = (target_idx_raw % DIAG_EVENT_BUFFER_SIZE + DIAG_EVENT_BUFFER_SIZE) % DIAG_EVENT_BUFFER_SIZE;\n\n    return &g_diag_event_buffer_fixed[final_target_idx];\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CAL_DATA_BANK_SIZE_BYTES 1024\n#define CAL_BLOCK_SIZE_BYTES 16\n\nstatic uint8_t g_calibration_bank[CAL_DATA_BANK_SIZE_BYTES];\nstatic size_t g_next_free_offset = 0;\n\nvoid init_calibration_bank() {\n    memset(g_calibration_bank, 0xFF, CAL_DATA_BANK_SIZE_BYTES);\n    g_next_free_offset = 0;\n}\n\nbool write_calibration_block(uint16_t id, const uint8_t* data) {\n    if (g_next_free_offset + CAL_BLOCK_SIZE_BYTES > CAL_DATA_BANK_SIZE_BYTES) {\n        return false;\n    }\n\n    uint8_t* block_ptr = g_calibration_bank + g_next_free_offset;\n    *((uint16_t*)block_ptr) = id; \n    *((uint16_t*)(block_ptr + 2)) = 0; \n    memcpy(block_ptr + 4, data, CAL_BLOCK_SIZE_BYTES - 4);\n\n    g_next_free_offset += CAL_BLOCK_SIZE_BYTES;\n    return true;\n}\n\nvoid invalidate_previous_cal_block_vulnerable(uint16_t blocks_ago_to_invalidate) {\n    if (g_next_free_offset == 0) {\n        return;\n    }\n\n    int32_t target_offset_signed = (int32_t)g_next_free_offset - ((int32_t)blocks_ago_to_invalidate * CAL_BLOCK_SIZE_BYTES);\n\n    *((uint16_t*)(g_calibration_bank + target_offset_signed)) = 0x0000;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CAL_DATA_BANK_SIZE_BYTES 1024\n#define CAL_BLOCK_SIZE_BYTES 16\n\nstatic uint8_t g_calibration_bank[CAL_DATA_BANK_SIZE_BYTES];\nstatic size_t g_next_free_offset = 0;\n\nvoid init_calibration_bank() {\n    memset(g_calibration_bank, 0xFF, CAL_DATA_BANK_SIZE_BYTES);\n    g_next_free_offset = 0;\n}\n\nbool write_calibration_block(uint16_t id, const uint8_t* data) {\n    if (g_next_free_offset + CAL_BLOCK_SIZE_BYTES > CAL_DATA_BANK_SIZE_BYTES) {\n        return false;\n    }\n\n    uint8_t* block_ptr = g_calibration_bank + g_next_free_offset;\n    *((uint16_t*)block_ptr) = id; \n    *((uint16_t*)(block_ptr + 2)) = 0; \n    memcpy(block_ptr + 4, data, CAL_BLOCK_SIZE_BYTES - 4);\n\n    g_next_free_offset += CAL_BLOCK_SIZE_BYTES;\n    return true;\n}\n\nvoid invalidate_previous_cal_block_fixed(uint16_t blocks_ago_to_invalidate) {\n    if (g_next_free_offset == 0) {\n        return;\n    }\n\n    int32_t target_offset_signed = (int32_t)g_next_free_offset - ((int32_t)blocks_ago_to_invalidate * CAL_BLOCK_SIZE_BYTES);\n\n    if (target_offset_signed < 0 || target_offset_signed >= CAL_DATA_BANK_SIZE_BYTES || (target_offset_signed % CAL_BLOCK_SIZE_BYTES != 0)) {\n        return;\n    }\n    \n    *((uint16_t*)(g_calibration_bank + target_offset_signed)) = 0x0000;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRIES 32\n#define LOG_ENTRY_SIZE 8\n\ntypedef struct {\n    uint32_t event_id;\n    uint32_t timestamp;\n} LogEntry;\n\nstatic LogEntry g_diag_log_buffer[MAX_LOG_ENTRIES];\nstatic uint16_t g_log_count = 0;\n\nvoid init_diag_log() {\n    memset(g_diag_log_buffer, 0, sizeof(g_diag_log_buffer));\n    g_log_count = 0;\n}\n\nbool add_log_entry(uint32_t event_id, uint32_t timestamp) {\n    if (g_log_count >= MAX_LOG_ENTRIES) {\n        return false;\n    }\n    g_diag_log_buffer[g_log_count].event_id = event_id;\n    g_diag_log_buffer[g_log_count].timestamp = timestamp;\n    g_log_count++;\n    return true;\n}\n\nvoid clear_log_segment_vulnerable(uint16_t entries_to_clear_from_end) {\n    if (g_log_count == 0) {\n        return;\n    }\n\n    if (entries_to_clear_from_end > g_log_count) {\n        g_log_count = 0;\n        return;\n    }\n\n    g_log_count -= entries_to_clear_from_end;\n\n    ((uint8_t*)g_diag_log_buffer)[g_log_count * LOG_ENTRY_SIZE - 1] = 0xDE;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRIES 32\n#define LOG_ENTRY_SIZE 8\n\ntypedef struct {\n    uint32_t event_id;\n    uint32_t timestamp;\n} LogEntry;\n\nstatic LogEntry g_diag_log_buffer_fixed[MAX_LOG_ENTRIES];\nstatic uint16_t g_log_count_fixed = 0;\n\nvoid init_diag_log_fixed() {\n    memset(g_diag_log_buffer_fixed, 0, sizeof(g_diag_log_buffer_fixed));\n    g_log_count_fixed = 0;\n}\n\nbool add_log_entry_fixed(uint32_t event_id, uint32_t timestamp) {\n    if (g_log_count_fixed >= MAX_LOG_ENTRIES) {\n        return false;\n    }\n    g_diag_log_buffer_fixed[g_log_count_fixed].event_id = event_id;\n    g_diag_log_buffer_fixed[g_log_count_fixed].timestamp = timestamp;\n    g_log_count_fixed++;\n    return true;\n}\n\nvoid clear_log_segment_fixed(uint16_t entries_to_clear_from_end) {\n    if (g_log_count_fixed == 0) {\n        return;\n    }\n\n    if (entries_to_clear_from_end > g_log_count_fixed) {\n        g_log_count_fixed = 0;\n    } else {\n        g_log_count_fixed -= entries_to_clear_from_end;\n    }\n\n    int32_t marker_byte_index = (int32_t)g_log_count_fixed * LOG_ENTRY_SIZE - 1;\n\n    if (marker_byte_index >= 0 && marker_byte_index < (int32_t)(MAX_LOG_ENTRIES * LOG_ENTRY_SIZE)) {\n        ((uint8_t*)g_diag_log_buffer_fixed)[marker_byte_index] = 0xDE;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define TEMP_DATA_SCRATCHPAD_SIZE 128\n#define DATA_SECTION_START_OFFSET 8\n\nstatic uint8_t g_processing_scratchpad[TEMP_DATA_SCRATCHPAD_SIZE];\nstatic uint16_t g_current_scratchpad_data_len = 0;\n\nvoid init_scratchpad_processing() {\n    memset(g_processing_scratchpad, 0, TEMP_DATA_SCRATCHPAD_SIZE);\n    g_current_scratchpad_data_len = 0;\n}\n\nbool load_data_to_scratchpad(const uint8_t* data, uint16_t len) {\n    if (len > (TEMP_DATA_SCRATCHPAD_SIZE - DATA_SECTION_START_OFFSET)) {\n        return false;\n    }\n    memcpy(g_processing_scratchpad + DATA_SECTION_START_OFFSET, data, len);\n    g_current_scratchpad_data_len = len;\n    return true;\n}\n\nvoid apply_data_transform_vulnerable(uint8_t transform_type_marker, int16_t relative_start_offset) {\n    if (g_current_scratchpad_data_len == 0) {\n        return;\n    }\n\n    int32_t target_absolute_index = DATA_SECTION_START_OFFSET + relative_start_offset;\n\n    g_processing_scratchpad[target_absolute_index] = transform_type_marker;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define TEMP_DATA_SCRATCHPAD_SIZE_FIXED 128\n#define DATA_SECTION_START_OFFSET_FIXED 8\n\nstatic uint8_t g_processing_scratchpad_fixed[TEMP_DATA_SCRATCHPAD_SIZE_FIXED];\nstatic uint16_t g_current_scratchpad_data_len_fixed = 0;\n\nvoid init_scratchpad_processing_fixed() {\n    memset(g_processing_scratchpad_fixed, 0, TEMP_DATA_SCRATCHPAD_SIZE_FIXED);\n    g_current_scratchpad_data_len_fixed = 0;\n}\n\nbool load_data_to_scratchpad_fixed(const uint8_t* data, uint16_t len) {\n    if (len > (TEMP_DATA_SCRATCHPAD_SIZE_FIXED - DATA_SECTION_START_OFFSET_FIXED)) {\n        return false;\n    }\n    memcpy(g_processing_scratchpad_fixed + DATA_SECTION_START_OFFSET_FIXED, data, len);\n    g_current_scratchpad_data_len_fixed = len;\n    return true;\n}\n\nvoid apply_data_transform_fixed(uint8_t transform_type_marker, int16_t relative_start_offset) {\n    if (g_current_scratchpad_data_len_fixed == 0) {\n        return;\n    }\n\n    int32_t target_absolute_index = DATA_SECTION_START_OFFSET_FIXED + relative_start_offset;\n\n    if (target_absolute_index < 0 || target_absolute_index >= TEMP_DATA_SCRATCHPAD_SIZE_FIXED) {\n        return;\n    }\n\n    g_processing_scratchpad_fixed[target_absolute_index] = transform_type_marker;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CAL_DATA_BUFFER_SIZE 256\n#define CAL_PAGE_SIZE 16\n\nclass VehicleCalibrationManagerVulnerable {\nprivate:\n    uint8_t m_calibration_data[CAL_DATA_BUFFER_SIZE];\n    uint16_t m_current_data_size;\n\npublic:\n    VehicleCalibrationManagerVulnerable() : m_current_data_size(0) {\n        memset(m_calibration_data, 0xFF, CAL_DATA_BUFFER_SIZE);\n    }\n\n    bool write_calibration_segment(const uint8_t* data, uint16_t len) {\n        if (m_current_data_size + len > CAL_DATA_BUFFER_SIZE) {\n            return false;\n        }\n        memcpy(m_calibration_data + m_current_data_size, data, len);\n        m_current_data_size += len;\n        return true;\n    }\n\n    void reset_leading_segment_vulnerable(uint8_t segment_id, int16_t metadata_adjust, uint16_t reset_length) {\n        if (reset_length == 0) {\n            return;\n        }\n\n        uint32_t base_offset_bytes = (uint32_t)segment_id * CAL_PAGE_SIZE;\n        int32_t target_start_index = (int32_t)base_offset_bytes + metadata_adjust;\n\n        for (uint32_t i = 0; i < reset_length; ++i) {\n            m_calibration_data[target_start_index + i] = 0x00;\n        }\n\n        if (target_start_index >= 0 && target_start_index < m_current_data_size) {\n            volatile uint8_t check_byte = m_calibration_data[target_start_index];\n            (void)check_byte;\n        }\n    }\n};",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CAL_DATA_BUFFER_SIZE 256\n#define CAL_PAGE_SIZE 16\n\nclass VehicleCalibrationManagerFixed {\nprivate:\n    uint8_t m_calibration_data_fixed[CAL_DATA_BUFFER_SIZE];\n    uint16_t m_current_data_size_fixed;\n\npublic:\n    VehicleCalibrationManagerFixed() : m_current_data_size_fixed(0) {\n        memset(m_calibration_data_fixed, 0xFF, CAL_DATA_BUFFER_SIZE);\n    }\n\n    bool write_calibration_segment_fixed(const uint8_t* data, uint16_t len) {\n        if (m_current_data_size_fixed + len > CAL_DATA_BUFFER_SIZE) {\n            return false;\n        }\n        memcpy(m_calibration_data_fixed + m_current_data_size_fixed, data, len);\n        m_current_data_size_fixed += len;\n        return true;\n    }\n\n    void reset_leading_segment_fixed(uint8_t segment_id, int16_t metadata_adjust, uint16_t reset_length) {\n        if (reset_length == 0) {\n            return;\n        }\n\n        uint32_t base_offset_bytes = (uint32_t)segment_id * CAL_PAGE_SIZE;\n        int32_t calculated_start_index = (int32_t)base_offset_bytes + metadata_adjust;\n\n        uint32_t actual_start_index = 0;\n        uint32_t effective_bytes_to_clear = 0;\n\n        if (calculated_start_index < 0) {\n            actual_start_index = 0;\n            effective_bytes_to_clear = (uint32_t)((int32_t)reset_length + calculated_start_index > 0 ? (int32_t)reset_length + calculated_start_index : 0);\n        } else {\n            actual_start_index = (uint32_t)calculated_start_index;\n            effective_bytes_to_clear = reset_length;\n        }\n\n        if (actual_start_index >= CAL_DATA_BUFFER_SIZE) {\n            return;\n        }\n        if (actual_start_index + effective_bytes_to_clear > CAL_DATA_BUFFER_SIZE) {\n            effective_bytes_to_clear = CAL_DATA_BUFFER_SIZE - actual_start_index;\n        }\n        \n        if (effective_bytes_to_clear == 0) {\n            return;\n        }\n\n        for (uint32_t i = 0; i < effective_bytes_to_clear; ++i) {\n            m_calibration_data_fixed[actual_start_index + i] = 0x00;\n        }\n\n        if (actual_start_index < m_current_data_size_fixed) {\n            volatile uint8_t check_byte = m_calibration_data_fixed[actual_start_index];\n            (void)check_byte;\n        }\n    }\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define TELEMETRY_BUFFER_CAPACITY 32\n#define TELEMETRY_PACKET_SIZE 16\n\ntypedef struct {\n    uint32_t timestamp;\n    uint8_t  packet_data[TELEMETRY_PACKET_SIZE - sizeof(uint32_t)];\n} TelemetryPacket;\n\nstatic TelemetryPacket g_telemetry_buffer[TELEMETRY_BUFFER_CAPACITY];\nstatic uint16_t g_telemetry_write_idx = 0;\nstatic uint16_t g_telemetry_count = 0;\n\nvoid init_telemetry_buffer() {\n    memset(g_telemetry_buffer, 0, sizeof(g_telemetry_buffer));\n    g_telemetry_write_idx = 0;\n    g_telemetry_count = 0;\n}\n\nvoid store_telemetry_packet(uint32_t timestamp, const uint8_t* data) {\n    if (data == NULL) return;\n\n    g_telemetry_buffer[g_telemetry_write_idx].timestamp = timestamp;\n    memcpy(g_telemetry_buffer[g_telemetry_write_idx].packet_data, data, TELEMETRY_PACKET_SIZE - sizeof(uint32_t));\n\n    g_telemetry_write_idx = (g_telemetry_write_idx + 1) % TELEMETRY_BUFFER_CAPACITY;\n    if (g_telemetry_count < TELEMETRY_BUFFER_CAPACITY) {\n        g_telemetry_count++;\n    }\n}\n\nvoid set_review_index_from_oldest_vulnerable(uint16_t num_steps_back) {\n    if (g_telemetry_count == 0) {\n        return;\n    }\n\n    uint16_t oldest_packet_logical_idx;\n    if (g_telemetry_count < TELEMETRY_BUFFER_CAPACITY) {\n        oldest_packet_logical_idx = 0;\n    } else {\n        oldest_packet_logical_idx = g_telemetry_write_idx;\n    }\n\n    int32_t target_idx_raw = (int32_t)oldest_packet_logical_idx - num_steps_back;\n\n    g_telemetry_buffer[target_idx_raw].timestamp = 0xFFFFFFFF;\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define TELEMETRY_BUFFER_CAPACITY 32\n#define TELEMETRY_PACKET_SIZE 16\n\ntypedef struct {\n    uint32_t timestamp;\n    uint8_t  packet_data[TELEMETRY_PACKET_SIZE - sizeof(uint32_t)];\n} TelemetryPacket;\n\nstatic TelemetryPacket g_telemetry_buffer_fixed[TELEMETRY_BUFFER_CAPACITY];\nstatic uint16_t g_telemetry_write_idx_fixed = 0;\nstatic uint16_t g_telemetry_count_fixed = 0;\n\nvoid init_telemetry_buffer_fixed() {\n    memset(g_telemetry_buffer_fixed, 0, sizeof(g_telemetry_buffer_fixed));\n    g_telemetry_write_idx_fixed = 0;\n    g_telemetry_count_fixed = 0;\n}\n\nvoid store_telemetry_packet_fixed(uint32_t timestamp, const uint8_t* data) {\n    if (data == NULL) return;\n\n    g_telemetry_buffer_fixed[g_telemetry_write_idx_fixed].timestamp = timestamp;\n    memcpy(g_telemetry_buffer_fixed[g_telemetry_write_idx_fixed].packet_data, data, TELEMETRY_PACKET_SIZE - sizeof(uint32_t));\n\n    g_telemetry_write_idx_fixed = (g_telemetry_write_idx_fixed + 1) % TELEMETRY_BUFFER_CAPACITY;\n    if (g_telemetry_count_fixed < TELEMETRY_BUFFER_CAPACITY) {\n        g_telemetry_count_fixed++;\n    }\n}\n\nvoid set_review_index_from_oldest_fixed(uint16_t num_steps_back) {\n    if (g_telemetry_count_fixed == 0) {\n        return;\n    }\n\n    uint16_t oldest_packet_logical_idx;\n    if (g_telemetry_count_fixed < TELEMETRY_BUFFER_CAPACITY) {\n        oldest_packet_logical_idx = 0;\n    } else {\n        oldest_packet_logical_idx = g_telemetry_write_idx_fixed;\n    }\n\n    int32_t target_idx_raw = (int32_t)oldest_packet_logical_idx - num_steps_back;\n\n    if (target_idx_raw < 0 || target_idx_raw >= TELEMETRY_BUFFER_CAPACITY || num_steps_back >= g_telemetry_count_fixed) {\n        return;\n    }\n    \n    g_telemetry_buffer_fixed[target_idx_raw].timestamp = 0xFFFFFFFF;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_LOG_BUFFER_SIZE 1024\n#define MAX_LOG_ENTRIES 50\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t sensor_id;\n    uint16_t value;\n    uint8_t  crc;\n} SensorLogEntry;\n\nstatic uint8_t g_sensor_data_log[MAX_LOG_BUFFER_SIZE];\nstatic uint16_t g_log_entry_offsets[MAX_LOG_ENTRIES];\nstatic uint16_t g_num_log_entries = 0;\nstatic uint16_t g_current_data_ptr = 0;\n\nvoid init_sensor_logger_vulnerable() {\n    memset(g_sensor_data_log, 0, MAX_LOG_BUFFER_SIZE);\n    memset(g_log_entry_offsets, 0, sizeof(g_log_entry_offsets));\n    g_num_log_entries = 0;\n    g_current_data_ptr = 0;\n}\n\nbool add_sensor_log_entry_vulnerable(uint32_t timestamp, uint16_t sensor_id, uint16_t value, uint8_t crc) {\n    if (g_num_log_entries >= MAX_LOG_ENTRIES) {\n        return false;\n    }\n\n    if (g_current_data_ptr + sizeof(SensorLogEntry) > MAX_LOG_BUFFER_SIZE) {\n        return false;\n    }\n\n    g_log_entry_offsets[g_num_log_entries] = g_current_data_ptr;\n\n    SensorLogEntry new_entry = {timestamp, sensor_id, value, crc};\n    memcpy(&g_sensor_data_log[g_current_data_ptr], &new_entry, sizeof(SensorLogEntry));\n\n    g_current_data_ptr += sizeof(SensorLogEntry);\n    g_num_log_entries++;\n    return true;\n}\n\nvoid set_entry_status_vulnerable(uint16_t entry_index, uint8_t status_byte) {\n    if (entry_index >= g_num_log_entries) {\n        return;\n    }\n\n    uint16_t entry_start_offset = g_log_entry_offsets[entry_index];\n\n    g_sensor_data_log[entry_start_offset - 1] = status_byte;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_LOG_BUFFER_SIZE 1024\n#define MAX_LOG_ENTRIES 50\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t sensor_id;\n    uint16_t value;\n    uint8_t  crc;\n} SensorLogEntry;\n\nstatic uint8_t g_sensor_data_log[MAX_LOG_BUFFER_SIZE];\nstatic uint16_t g_log_entry_offsets[MAX_LOG_ENTRIES];\nstatic uint16_t g_num_log_entries = 0;\nstatic uint16_t g_current_data_ptr = 0;\n\nvoid init_sensor_logger_fixed() {\n    memset(g_sensor_data_log, 0, MAX_LOG_BUFFER_SIZE);\n    memset(g_log_entry_offsets, 0, sizeof(g_log_entry_offsets));\n    g_num_log_entries = 0;\n    g_current_data_ptr = 0;\n}\n\nbool add_sensor_log_entry_fixed(uint32_t timestamp, uint16_t sensor_id, uint16_t value, uint8_t crc) {\n    if (g_num_log_entries >= MAX_LOG_ENTRIES) {\n        return false;\n    }\n\n    if (g_current_data_ptr + sizeof(SensorLogEntry) > MAX_LOG_BUFFER_SIZE) {\n        return false;\n    }\n\n    g_log_entry_offsets[g_num_log_entries] = g_current_data_ptr;\n\n    SensorLogEntry new_entry = {timestamp, sensor_id, value, crc};\n    memcpy(&g_sensor_data_log[g_current_data_ptr], &new_entry, sizeof(SensorLogEntry));\n\n    g_current_data_ptr += sizeof(SensorLogEntry);\n    g_num_log_entries++;\n    return true;\n}\n\nvoid set_entry_status_fixed(uint16_t entry_index, uint8_t status_byte) {\n    if (entry_index >= g_num_log_entries) {\n        return;\n    }\n\n    uint16_t entry_start_offset = g_log_entry_offsets[entry_index];\n\n    if (entry_start_offset > 0) {\n        g_sensor_data_log[entry_start_offset - 1] = status_byte;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_PARAM_LOG_ENTRIES 64\n#define PARAM_ENTRY_SIZE_BYTES 16\n\nstatic uint8_t g_param_log_buffer[MAX_PARAM_LOG_ENTRIES * PARAM_ENTRY_SIZE_BYTES];\nstatic int32_t g_current_active_log_idx = 0;\nstatic uint32_t g_total_logged_entries = 0;\n\nvoid init_param_logger() {\n    memset(g_param_log_buffer, 0, sizeof(g_param_log_buffer));\n    g_current_active_log_idx = 0;\n    g_total_logged_entries = 0;\n}\n\nbool log_param_entry(const uint8_t* param_data) {\n    if (g_total_logged_entries >= MAX_PARAM_LOG_ENTRIES) {\n        return false;\n    }\n    memcpy(g_param_log_buffer + (g_total_logged_entries * PARAM_ENTRY_SIZE_BYTES), param_data, PARAM_ENTRY_SIZE_BYTES);\n    g_total_logged_entries++;\n    return true;\n}\n\nvoid set_active_log_entry_vulnerable(int32_t offset_from_current) {\n    g_current_active_log_idx += offset_from_current;\n}\n\nvoid mark_active_entry_status_byte_vulnerable(uint8_t status_value, uint8_t relative_byte_offset) {\n    if (relative_byte_offset >= PARAM_ENTRY_SIZE_BYTES) {\n        return;\n    }\n    int32_t byte_target_idx = (g_current_active_log_idx * PARAM_ENTRY_SIZE_BYTES) + relative_byte_offset;\n    g_param_log_buffer[byte_target_idx] = status_value;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_PARAM_LOG_ENTRIES_FIXED 64\n#define PARAM_ENTRY_SIZE_BYTES_FIXED 16\n\nstatic uint8_t g_param_log_buffer_fixed[MAX_PARAM_LOG_ENTRIES_FIXED * PARAM_ENTRY_SIZE_BYTES_FIXED];\nstatic int32_t g_current_active_log_idx_fixed = 0;\nstatic uint32_t g_total_logged_entries_fixed = 0;\n\nvoid init_param_logger_fixed() {\n    memset(g_param_log_buffer_fixed, 0, sizeof(g_param_log_buffer_fixed));\n    g_current_active_log_idx_fixed = 0;\n    g_total_logged_entries_fixed = 0;\n}\n\nbool log_param_entry_fixed(const uint8_t* param_data) {\n    if (g_total_logged_entries_fixed >= MAX_PARAM_LOG_ENTRIES_FIXED) {\n        return false;\n    }\n    memcpy(g_param_log_buffer_fixed + (g_total_logged_entries_fixed * PARAM_ENTRY_SIZE_BYTES_FIXED), param_data, PARAM_ENTRY_SIZE_BYTES_FIXED);\n    g_total_logged_entries_fixed++;\n    return true;\n}\n\nvoid set_active_log_entry_fixed(int32_t offset_from_current) {\n    int32_t new_idx = g_current_active_log_idx_fixed + offset_from_current;\n    if (new_idx < 0) {\n        new_idx = 0;\n    }\n    if (g_total_logged_entries_fixed > 0 && new_idx >= (int32_t)g_total_logged_entries_fixed) {\n        new_idx = g_total_logged_entries_fixed - 1;\n    } else if (g_total_logged_entries_fixed == 0 && new_idx > 0) {\n        new_idx = 0;\n    }\n    g_current_active_log_idx_fixed = new_idx;\n}\n\nvoid mark_active_entry_status_byte_fixed(uint8_t status_value, uint8_t relative_byte_offset) {\n    if (relative_byte_offset >= PARAM_ENTRY_SIZE_BYTES_FIXED) {\n        return;\n    }\n    int32_t byte_target_idx = (g_current_active_log_idx_fixed * PARAM_ENTRY_SIZE_BYTES_FIXED) + relative_byte_offset;\n    if (byte_target_idx < 0 || byte_target_idx >= (int32_t)(MAX_PARAM_LOG_ENTRIES_FIXED * PARAM_ENTRY_SIZE_BYTES_FIXED)) {\n        return;\n    }\n    g_param_log_buffer_fixed[byte_target_idx] = status_value;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SENSOR_LOG_BUFFER_SIZE 64\n#define SENSOR_DATA_INVALID_MARKER 0xFF\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t sensor_id;\n    int16_t  value;\n} SensorLogEntry;\n\nstatic SensorLogEntry g_sensor_log_buffer[SENSOR_LOG_BUFFER_SIZE];\nstatic uint16_t g_log_head_idx = 0;\n\nvoid init_sensor_logger() {\n    memset(g_sensor_log_buffer, 0, sizeof(g_sensor_log_buffer));\n    g_log_head_idx = 0;\n}\n\nvoid add_sensor_reading(uint32_t ts, uint16_t id, int16_t val) {\n    g_sensor_log_buffer[g_log_head_idx].timestamp = ts;\n    g_sensor_log_buffer[g_log_head_idx].sensor_id = id;\n    g_sensor_log_buffer[g_log_head_idx].value = val;\n    g_log_head_idx = (g_log_head_idx + 1) % SENSOR_LOG_BUFFER_SIZE;\n}\n\nvoid invalidate_oldest_log_entries_vulnerable(uint16_t num_entries_to_invalidate) {\n    if (num_entries_to_invalidate == 0) {\n        return;\n    }\n\n    int32_t conceptual_start_offset = (int32_t)g_log_head_idx - num_entries_to_invalidate;\n\n    for (uint16_t i = 0; i < num_entries_to_invalidate; ++i) {\n        uint16_t target_idx = (uint16_t)((conceptual_start_offset + i) % SENSOR_LOG_BUFFER_SIZE);\n        g_sensor_log_buffer[target_idx].value = SENSOR_DATA_INVALID_MARKER;\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define SENSOR_LOG_BUFFER_SIZE 64\n#define SENSOR_DATA_INVALID_MARKER 0xFF\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t sensor_id;\n    int16_t  value;\n} SensorLogEntry;\n\nstatic SensorLogEntry g_sensor_log_buffer[SENSOR_LOG_BUFFER_SIZE];\nstatic uint16_t g_log_head_idx = 0;\n\nvoid init_sensor_logger() {\n    memset(g_sensor_log_buffer, 0, sizeof(g_sensor_log_buffer));\n    g_log_head_idx = 0;\n}\n\nvoid add_sensor_reading(uint32_t ts, uint16_t id, int16_t val) {\n    g_sensor_log_buffer[g_log_head_idx].timestamp = ts;\n    g_sensor_log_buffer[g_log_head_idx].sensor_id = id;\n    g_sensor_log_buffer[g_log_head_idx].value = val;\n    g_log_head_idx = (g_log_head_idx + 1) % SENSOR_LOG_BUFFER_SIZE;\n}\n\nvoid invalidate_oldest_log_entries_fixed(uint16_t num_entries_to_invalidate) {\n    if (num_entries_to_invalidate == 0) {\n        return;\n    }\n\n    uint16_t actual_entries_to_invalidate = num_entries_to_invalidate;\n    if (actual_entries_to_invalidate > SENSOR_LOG_BUFFER_SIZE) {\n        actual_entries_to_invalidate = SENSOR_LOG_BUFFER_SIZE;\n    }\n\n    for (uint16_t i = 0; i < actual_entries_to_invalidate; ++i) {\n        int32_t conceptual_index_for_modulo = (int32_t)g_log_head_idx - actual_entries_to_invalidate + i;\n        uint16_t target_idx = (uint16_t)(((conceptual_index_for_modulo % SENSOR_LOG_BUFFER_SIZE) + SENSOR_LOG_BUFFER_SIZE) % SENSOR_LOG_BUFFER_SIZE);\n        g_sensor_log_buffer[target_idx].value = SENSOR_DATA_INVALID_MARKER;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_DIAG_ENTRIES 32\n#define MESSAGE_LEN 24\n\ntypedef struct {\n    uint8_t priority;\n    uint32_t timestamp;\n    char message[MESSAGE_LEN];\n} DiagMessage;\n\nstatic DiagMessage g_diag_log_buffer[MAX_DIAG_ENTRIES];\nstatic uint8_t g_current_write_idx = 0;\nstatic uint8_t g_num_messages = 0;\n\nvoid init_diag_log() {\n    memset(g_diag_log_buffer, 0, sizeof(g_diag_log_buffer));\n    g_current_write_idx = 0;\n    g_num_messages = 0;\n}\n\nvoid add_diag_message(uint8_t priority, uint32_t timestamp, const char* msg) {\n    strncpy(g_diag_log_buffer[g_current_write_idx].message, msg, MESSAGE_LEN - 1);\n    g_diag_log_buffer[g_current_write_idx].message[MESSAGE_LEN - 1] = '\\0';\n    g_diag_log_buffer[g_current_write_idx].priority = priority;\n    g_diag_log_buffer[g_current_write_idx].timestamp = timestamp;\n\n    g_current_write_idx = (g_current_write_idx + 1) % MAX_DIAG_ENTRIES;\n    if (g_num_messages < MAX_DIAG_ENTRIES) {\n        g_num_messages++;\n    }\n}\n\nvoid modify_diag_message_vulnerable(uint8_t relative_idx_from_last, uint8_t new_priority, const char* new_msg) {\n    if (g_num_messages == 0) {\n        return;\n    }\n\n    int32_t last_entry_idx = (g_current_write_idx == 0) ? (MAX_DIAG_ENTRIES - 1) : (g_current_write_idx - 1);\n\n    int32_t target_actual_idx = last_entry_idx - relative_idx_from_last;\n\n    strncpy(g_diag_log_buffer[target_actual_idx].message, new_msg, MESSAGE_LEN - 1);\n    g_diag_log_buffer[target_actual_idx].message[MESSAGE_LEN - 1] = '\\0';\n    g_diag_log_buffer[target_actual_idx].priority = new_priority;\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_DIAG_ENTRIES_FIXED 32\n#define MESSAGE_LEN_FIXED 24\n\ntypedef struct {\n    uint8_t priority;\n    uint32_t timestamp;\n    char message[MESSAGE_LEN_FIXED];\n} DiagMessageFixed;\n\nstatic DiagMessageFixed g_diag_log_buffer_fixed[MAX_DIAG_ENTRIES_FIXED];\nstatic uint8_t g_current_write_idx_fixed = 0;\nstatic uint8_t g_num_messages_fixed = 0;\n\nvoid init_diag_log_fixed() {\n    memset(g_diag_log_buffer_fixed, 0, sizeof(g_diag_log_buffer_fixed));\n    g_current_write_idx_fixed = 0;\n    g_num_messages_fixed = 0;\n}\n\nvoid add_diag_message_fixed(uint8_t priority, uint32_t timestamp, const char* msg) {\n    strncpy(g_diag_log_buffer_fixed[g_current_write_idx_fixed].message, msg, MESSAGE_LEN_FIXED - 1);\n    g_diag_log_buffer_fixed[g_current_write_idx_fixed].message[MESSAGE_LEN_FIXED - 1] = '\\0';\n    g_diag_log_buffer_fixed[g_current_write_idx_fixed].priority = priority;\n    g_diag_log_buffer_fixed[g_current_write_idx_fixed].timestamp = timestamp;\n\n    g_current_write_idx_fixed = (g_current_write_idx_fixed + 1) % MAX_DIAG_ENTRIES_FIXED;\n    if (g_num_messages_fixed < MAX_DIAG_ENTRIES_FIXED) {\n        g_num_messages_fixed++;\n    }\n}\n\nvoid modify_diag_message_fixed(uint8_t relative_idx_from_last, uint8_t new_priority, const char* new_msg) {\n    if (g_num_messages_fixed == 0) {\n        return;\n    }\n\n    if (relative_idx_from_last >= g_num_messages_fixed) {\n        return;\n    }\n\n    int32_t last_entry_idx = (g_current_write_idx_fixed == 0) ? (MAX_DIAG_ENTRIES_FIXED - 1) : (g_current_write_idx_fixed - 1);\n\n    int32_t target_raw_idx = last_entry_idx - relative_idx_from_last;\n\n    uint8_t target_actual_idx = (target_raw_idx < 0) ? (uint8_t)(target_raw_idx + MAX_DIAG_ENTRIES_FIXED) : (uint8_t)target_raw_idx;\n\n    strncpy(g_diag_log_buffer_fixed[target_actual_idx].message, new_msg, MESSAGE_LEN_FIXED - 1);\n    g_diag_log_buffer_fixed[target_actual_idx].message[MESSAGE_LEN_FIXED - 1] = '\\0';\n    g_diag_log_buffer_fixed[target_actual_idx].priority = new_priority;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_SETTINGS_AREA_SIZE 256\n#define SETTING_BLOCK_DATA_SIZE 16\n#define SETTING_HEADER_SIZE 4\n\n#define TOTAL_BLOCK_SIZE (SETTING_HEADER_SIZE + SETTING_BLOCK_DATA_SIZE)\n\nstatic uint8_t g_vehicle_settings_area[VEHICLE_SETTINGS_AREA_SIZE];\nstatic size_t g_num_stored_blocks = 0;\n\nvoid init_vehicle_settings_storage() {\n    memset(g_vehicle_settings_area, 0, sizeof(g_vehicle_settings_area));\n    g_num_stored_blocks = 0;\n}\n\nbool store_new_setting_block(uint32_t header_flags, const uint8_t* block_data) {\n    if ((g_num_stored_blocks + 1) * TOTAL_BLOCK_SIZE > VEHICLE_SETTINGS_AREA_SIZE) {\n        return false;\n    }\n\n    size_t current_byte_offset = g_num_stored_blocks * TOTAL_BLOCK_SIZE;\n    *(uint32_t*)(g_vehicle_settings_area + current_byte_offset) = header_flags;\n    memcpy(g_vehicle_settings_area + current_byte_offset + SETTING_HEADER_SIZE, block_data, SETTING_BLOCK_DATA_SIZE);\n    g_num_stored_blocks++;\n    return true;\n}\n\nvoid adjust_setting_block_active_state_vulnerable(uint16_t target_block_index, int16_t offset_to_prev_block, bool activate) {\n    if (target_block_index >= g_num_stored_blocks) {\n        return;\n    }\n\n    size_t base_header_offset = target_block_index * TOTAL_BLOCK_SIZE;\n\n    int32_t effective_byte_offset = (int32_t)base_header_offset - (offset_to_prev_block * TOTAL_BLOCK_SIZE);\n\n    uint32_t* header_ptr = (uint32_t*)(g_vehicle_settings_area + effective_byte_offset);\n\n    if (activate) {\n        *header_ptr |= 0x01;\n    } else {\n        *header_ptr &= ~0x01;\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_SETTINGS_AREA_SIZE 256\n#define SETTING_BLOCK_DATA_SIZE 16\n#define SETTING_HEADER_SIZE 4\n\n#define TOTAL_BLOCK_SIZE (SETTING_HEADER_SIZE + SETTING_BLOCK_DATA_SIZE)\n\nstatic uint8_t g_vehicle_settings_area_fixed[VEHICLE_SETTINGS_AREA_SIZE];\nstatic size_t g_num_stored_blocks_fixed = 0;\n\nvoid init_vehicle_settings_storage_fixed() {\n    memset(g_vehicle_settings_area_fixed, 0, sizeof(g_vehicle_settings_area_fixed));\n    g_num_stored_blocks_fixed = 0;\n}\n\nbool store_new_setting_block_fixed(uint32_t header_flags, const uint8_t* block_data) {\n    if ((g_num_stored_blocks_fixed + 1) * TOTAL_BLOCK_SIZE > VEHICLE_SETTINGS_AREA_SIZE) {\n        return false;\n    }\n\n    size_t current_byte_offset = g_num_stored_blocks_fixed * TOTAL_BLOCK_SIZE;\n    *(uint32_t*)(g_vehicle_settings_area_fixed + current_byte_offset) = header_flags;\n    memcpy(g_vehicle_settings_area_fixed + current_byte_offset + SETTING_HEADER_SIZE, block_data, SETTING_BLOCK_DATA_SIZE);\n    g_num_stored_blocks_fixed++;\n    return true;\n}\n\nvoid adjust_setting_block_active_state_fixed(uint16_t target_block_index, int16_t offset_to_prev_block, bool activate) {\n    if (target_block_index >= g_num_stored_blocks_fixed) {\n        return;\n    }\n\n    size_t base_header_offset = target_block_index * TOTAL_BLOCK_SIZE;\n\n    int32_t potential_effective_byte_offset = (int32_t)base_header_offset - (offset_to_prev_block * TOTAL_BLOCK_SIZE);\n\n    if (potential_effective_byte_offset < 0 || (size_t)potential_effective_byte_offset + sizeof(uint32_t) > VEHICLE_SETTINGS_AREA_SIZE) {\n        return;\n    }\n\n    uint32_t* header_ptr = (uint32_t*)(g_vehicle_settings_area_fixed + potential_effective_byte_offset);\n\n    if (activate) {\n        *header_ptr |= 0x01;\n    } else {\n        *header_ptr &= ~0x01;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define SENSOR_EVENT_DATA_SIZE 8\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_type;\n    uint8_t  details[SENSOR_EVENT_DATA_SIZE];\n} SensorEvent;\n\n#define MAX_EVENT_LOG_ENTRIES 20\n\nstatic SensorEvent g_event_log[MAX_EVENT_LOG_ENTRIES];\nstatic int32_t g_current_event_count = 0;\n\nvoid init_event_log() {\n    memset(g_event_log, 0, sizeof(g_event_log));\n    g_current_event_count = 0;\n}\n\nbool add_sensor_event(uint16_t type, const uint8_t* details) {\n    if (g_current_event_count >= MAX_EVENT_LOG_ENTRIES) {\n        return false;\n    }\n    g_event_log[g_current_event_count].timestamp = 0x12345678;\n    g_event_log[g_current_event_count].event_type = type;\n    memcpy(g_event_log[g_current_event_count].details, details, SENSOR_EVENT_DATA_SIZE);\n    g_current_event_count++;\n    return true;\n}\n\nvoid rewind_event_log_and_update_marker_vulnerable(uint32_t steps_to_rewind, uint8_t marker_value) {\n    if (g_current_event_count == 0) {\n        return;\n    }\n\n    int32_t new_logical_end_idx = g_current_event_count - (int32_t)steps_to_rewind;\n\n    if (new_logical_end_idx < 0) {\n        new_logical_end_idx = 0;\n    }\n\n    g_current_event_count = new_logical_end_idx;\n\n    ((uint8_t*)g_event_log)[new_logical_end_idx * sizeof(SensorEvent) - 1] = marker_value;\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define SENSOR_EVENT_DATA_SIZE 8\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_type;\n    uint8_t  details[SENSOR_EVENT_DATA_SIZE];\n} SensorEvent;\n\n#define MAX_EVENT_LOG_ENTRIES 20\n\nstatic SensorEvent g_event_log_fixed[MAX_EVENT_LOG_ENTRIES];\nstatic int32_t g_current_event_count_fixed = 0;\n\nvoid init_event_log_fixed() {\n    memset(g_event_log_fixed, 0, sizeof(g_event_log_fixed));\n    g_current_event_count_fixed = 0;\n}\n\nbool add_sensor_event_fixed(uint16_t type, const uint8_t* details) {\n    if (g_current_event_count_fixed >= MAX_EVENT_LOG_ENTRIES) {\n        return false;\n    }\n    g_event_log_fixed[g_current_event_count_fixed].timestamp = 0x12345678;\n    g_event_log_fixed[g_current_event_count_fixed].event_type = type;\n    memcpy(g_event_log_fixed[g_current_event_count_fixed].details, details, SENSOR_EVENT_DATA_SIZE);\n    g_current_event_count_fixed++;\n    return true;\n}\n\nvoid rewind_event_log_and_update_marker_fixed(uint32_t steps_to_rewind, uint8_t marker_value) {\n    if (g_current_event_count_fixed == 0) {\n        return;\n    }\n\n    int32_t new_logical_end_idx = g_current_event_count_fixed - (int32_t)steps_to_rewind;\n\n    if (new_logical_end_idx < 0) {\n        new_logical_end_idx = 0;\n    }\n\n    g_current_event_count_fixed = new_logical_end_idx;\n\n    int32_t marker_byte_offset = new_logical_end_idx * sizeof(SensorEvent) - 1;\n\n    if (marker_byte_offset >= 0 && (size_t)marker_byte_offset < sizeof(g_event_log_fixed)) {\n        ((uint8_t*)g_event_log_fixed)[marker_byte_offset] = marker_value;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_CALIBRATION_POINTS 16\n#define CALIBRATION_DATA_SIZE 10 \n#define CALIBRATION_HEADER_SIZE 2 \n\n#define SINGLE_CAL_ENTRY_TOTAL_SIZE (CALIBRATION_HEADER_SIZE + CALIBRATION_DATA_SIZE)\n\n#define CAL_ENTRY_PREAMBLE_BYTE_OFFSET -1 \n\nstatic uint8_t g_calibration_buffer[MAX_CALIBRATION_POINTS * SINGLE_CAL_ENTRY_TOTAL_SIZE];\nstatic uint16_t g_active_cal_points = 0; \nstatic uint16_t g_current_calibration_ptr = 0; \n\nvoid initCalibrationBuffer() {\n    memset(g_calibration_buffer, 0, sizeof(g_calibration_buffer));\n    g_active_cal_points = 0;\n    g_current_calibration_ptr = 0;\n}\n\nint16_t addCalibrationEntry(uint16_t id, const uint8_t* data) {\n    if (g_active_cal_points >= MAX_CALIBRATION_POINTS) {\n        return -1; \n    }\n\n    uint32_t current_byte_offset = (uint32_t)g_current_calibration_ptr * SINGLE_CAL_ENTRY_TOTAL_SIZE;\n\n    g_calibration_buffer[current_byte_offset] = (uint8_t)(id >> 8);\n    g_calibration_buffer[current_byte_offset + 1] = (uint8_t)(id & 0xFF);\n\n    memcpy(&g_calibration_buffer[current_byte_offset + CALIBRATION_HEADER_SIZE], data, CALIBRATION_DATA_SIZE);\n\n    int16_t added_idx = g_current_calibration_ptr;\n    g_current_calibration_ptr++;\n    g_active_cal_points++;\n    return added_idx;\n}\n\nvoid updateCalibrationEntryPreamble_Vulnerable(uint16_t target_cal_idx, uint8_t preamble_status) {\n    if (target_cal_idx >= g_active_cal_points) {\n        return; \n    }\n\n    uint32_t entry_start_byte_pos = (uint32_t)target_cal_idx * SINGLE_CAL_ENTRY_TOTAL_SIZE;\n\n    int32_t target_byte_pos = (int32_t)entry_start_byte_pos + CAL_ENTRY_PREAMBLE_BYTE_OFFSET;\n\n    g_calibration_buffer[target_byte_pos] = preamble_status;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_CALIBRATION_POINTS 16\n#define CALIBRATION_DATA_SIZE 10 \n#define CALIBRATION_HEADER_SIZE 2 \n\n#define SINGLE_CAL_ENTRY_TOTAL_SIZE (CALIBRATION_HEADER_SIZE + CALIBRATION_DATA_SIZE)\n\n#define CAL_ENTRY_PREAMBLE_BYTE_OFFSET -1 \n\nstatic uint8_t g_calibration_buffer[MAX_CALIBRATION_POINTS * SINGLE_CAL_ENTRY_TOTAL_SIZE];\nstatic uint16_t g_active_cal_points = 0; \nstatic uint16_t g_current_calibration_ptr = 0; \n\nvoid initCalibrationBuffer() {\n    memset(g_calibration_buffer, 0, sizeof(g_calibration_buffer));\n    g_active_cal_points = 0;\n    g_current_calibration_ptr = 0;\n}\n\nint16_t addCalibrationEntry(uint16_t id, const uint8_t* data) {\n    if (g_active_cal_points >= MAX_CALIBRATION_POINTS) {\n        return -1; \n    }\n\n    uint32_t current_byte_offset = (uint32_t)g_current_calibration_ptr * SINGLE_CAL_ENTRY_TOTAL_SIZE;\n\n    g_calibration_buffer[current_byte_offset] = (uint8_t)(id >> 8);\n    g_calibration_buffer[current_byte_offset + 1] = (uint8_t)(id & 0xFF);\n\n    memcpy(&g_calibration_buffer[current_byte_offset + CALIBRATION_HEADER_SIZE], data, CALIBRATION_DATA_SIZE);\n\n    int16_t added_idx = g_current_calibration_ptr;\n    g_current_calibration_ptr++;\n    g_active_cal_points++;\n    return added_idx;\n}\n\nvoid updateCalibrationEntryPreamble_Fixed(uint16_t target_cal_idx, uint8_t preamble_status) {\n    if (target_cal_idx >= g_active_cal_points) {\n        return; \n    }\n\n    uint32_t entry_start_byte_pos = (uint32_t)target_cal_idx * SINGLE_CAL_ENTRY_TOTAL_SIZE;\n\n    int32_t target_byte_pos = (int32_t)entry_start_byte_pos + CAL_ENTRY_PREAMBLE_BYTE_OFFSET;\n\n    if (target_byte_pos >= 0 && target_byte_pos < (MAX_CALIBRATION_POINTS * SINGLE_CAL_ENTRY_TOTAL_SIZE)) {\n        g_calibration_buffer[target_byte_pos] = preamble_status;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_DTC_LOG_ENTRIES 32\n#define DTC_ID_LEN 8\n\ntypedef struct {\n    char dtc_id[DTC_ID_LEN + 1];\n    uint32_t timestamp_ms;\n    uint8_t severity_level; \n    bool active;\n    uint16_t associated_param_A;\n    uint16_t associated_param_B;\n} DiagnosticTroubleCodeEntry;\n\nstatic DiagnosticTroubleCodeEntry g_dtc_log_buffer_vulnerable[MAX_DTC_LOG_ENTRIES];\nstatic uint16_t g_next_write_idx_vulnerable = 0; \nstatic uint16_t g_num_logged_dtcs_vulnerable = 0;\n\nvoid init_dtc_logger_vulnerable() {\n    for (uint16_t i = 0; i < MAX_DTC_LOG_ENTRIES; ++i) {\n        memset(&g_dtc_log_buffer_vulnerable[i], 0, sizeof(DiagnosticTroubleCodeEntry));\n    }\n    g_next_write_idx_vulnerable = 0;\n    g_num_logged_dtcs_vulnerable = 0;\n}\n\nvoid log_dtc_entry_vulnerable(const char* id, uint32_t timestamp, uint8_t severity, uint16_t param_A, uint16_t param_B) {\n    strncpy(g_dtc_log_buffer_vulnerable[g_next_write_idx_vulnerable].dtc_id, id, DTC_ID_LEN);\n    g_dtc_log_buffer_vulnerable[g_next_write_idx_vulnerable].dtc_id[DTC_ID_LEN] = '\\0';\n    g_dtc_log_buffer_vulnerable[g_next_write_idx_vulnerable].timestamp_ms = timestamp;\n    g_dtc_log_buffer_vulnerable[g_next_write_idx_vulnerable].severity_level = severity;\n    g_dtc_log_buffer_vulnerable[g_next_write_idx_vulnerable].active = true;\n    g_dtc_log_buffer_vulnerable[g_next_write_idx_vulnerable].associated_param_A = param_A;\n    g_dtc_log_buffer_vulnerable[g_next_write_idx_vulnerable].associated_param_B = param_B;\n\n    g_next_write_idx_vulnerable = (g_next_write_idx_vulnerable + 1) % MAX_DTC_LOG_ENTRIES;\n    if (g_num_logged_dtcs_vulnerable < MAX_DTC_LOG_ENTRIES) {\n        g_num_logged_dtcs_vulnerable++;\n    }\n}\n\nvoid update_dtc_params_vulnerable(uint16_t offset_from_last, uint16_t new_param_A, uint16_t new_param_B) {\n    if (g_num_logged_dtcs_vulnerable == 0) {\n        return;\n    }\n\n    int32_t last_logged_idx = (g_next_write_idx_vulnerable == 0) ? (MAX_DTC_LOG_ENTRIES - 1) : (g_next_write_idx_vulnerable - 1);\n\n    int32_t target_idx_raw = last_logged_idx - offset_from_last;\n\n    uint16_t target_buffer_idx = (uint16_t)(target_idx_raw % MAX_DTC_LOG_ENTRIES);\n\n    g_dtc_log_buffer_vulnerable[target_buffer_idx].associated_param_A = new_param_A;\n    g_dtc_log_buffer_vulnerable[target_buffer_idx].associated_param_B = new_param_B;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_DTC_LOG_ENTRIES 32\n#define DTC_ID_LEN 8\n\ntypedef struct {\n    char dtc_id[DTC_ID_LEN + 1];\n    uint32_t timestamp_ms;\n    uint8_t severity_level; \n    bool active;\n    uint16_t associated_param_A;\n    uint16_t associated_param_B;\n} DiagnosticTroubleCodeEntry;\n\nstatic DiagnosticTroubleCodeEntry g_dtc_log_buffer_fixed[MAX_DTC_LOG_ENTRIES];\nstatic uint16_t g_next_write_idx_fixed = 0; \nstatic uint16_t g_num_logged_dtcs_fixed = 0;\n\nvoid init_dtc_logger_fixed() {\n    for (uint16_t i = 0; i < MAX_DTC_LOG_ENTRIES; ++i) {\n        memset(&g_dtc_log_buffer_fixed[i], 0, sizeof(DiagnosticTroubleCodeEntry));\n    }\n    g_next_write_idx_fixed = 0;\n    g_num_logged_dtcs_fixed = 0;\n}\n\nvoid log_dtc_entry_fixed(const char* id, uint32_t timestamp, uint8_t severity, uint16_t param_A, uint16_t param_B) {\n    strncpy(g_dtc_log_buffer_fixed[g_next_write_idx_fixed].dtc_id, id, DTC_ID_LEN);\n    g_dtc_log_buffer_fixed[g_next_write_idx_fixed].dtc_id[DTC_ID_LEN] = '\\0';\n    g_dtc_log_buffer_fixed[g_next_write_idx_fixed].timestamp_ms = timestamp;\n    g_dtc_log_buffer_fixed[g_next_write_idx_fixed].severity_level = severity;\n    g_dtc_log_buffer_fixed[g_next_write_idx_fixed].active = true;\n    g_dtc_log_buffer_fixed[g_next_write_idx_fixed].associated_param_A = param_A;\n    g_dtc_log_buffer_fixed[g_next_write_idx_fixed].associated_param_B = param_B;\n\n    g_next_write_idx_fixed = (g_next_write_idx_fixed + 1) % MAX_DTC_LOG_ENTRIES;\n    if (g_num_logged_dtcs_fixed < MAX_DTC_LOG_ENTRIES) {\n        g_num_logged_dtcs_fixed++;\n    }\n}\n\nvoid update_dtc_params_fixed(uint16_t offset_from_last, uint16_t new_param_A, uint16_t new_param_B) {\n    if (g_num_logged_dtcs_fixed == 0) {\n        return;\n    }\n\n    if (offset_from_last >= g_num_logged_dtcs_fixed) {\n        return;\n    }\n\n    uint16_t target_buffer_idx = (g_next_write_idx_fixed - (1 + offset_from_last) + MAX_DTC_LOG_ENTRIES * 2) % MAX_DTC_LOG_ENTRIES;\n\n    g_dtc_log_buffer_fixed[target_buffer_idx].associated_param_A = new_param_A;\n    g_dtc_log_buffer_fixed[target_buffer_idx].associated_param_B = new_param_B;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define ECU_STATE_LOG_BUFFER_SIZE 32\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t control_param_A;\n    uint16_t control_param_B;\n    uint32_t diagnostic_status_flags;\n} ECU_StateSnapshot;\n\nstatic ECU_StateSnapshot g_ecu_state_log[ECU_STATE_LOG_BUFFER_SIZE];\nstatic uint16_t g_log_next_idx = 0; \nstatic bool g_buffer_full = false; \n\nvoid init_ecu_log() {\n    memset(g_ecu_state_log, 0, sizeof(g_ecu_state_log));\n    g_log_next_idx = 0;\n    g_buffer_full = false;\n}\n\nvoid log_ecu_state(uint32_t ts, uint16_t paramA, uint16_t paramB, uint32_t flags) {\n    g_ecu_state_log[g_log_next_idx].timestamp = ts;\n    g_ecu_state_log[g_log_next_idx].control_param_A = paramA;\n    g_ecu_state_log[g_log_next_idx].control_param_B = paramB;\n    g_ecu_state_log[g_log_next_idx].diagnostic_status_flags = flags;\n\n    g_log_next_idx++;\n    if (g_log_next_idx >= ECU_STATE_LOG_BUFFER_SIZE) {\n        g_log_next_idx = 0;\n        g_buffer_full = true;\n    }\n}\n\nvoid adjust_snapshot_param_vulnerable(uint16_t relative_offset_from_latest, uint16_t new_param_A_value) {\n    if (!g_buffer_full && g_log_next_idx == 0) {\n        return;\n    }\n\n    uint16_t latest_entry_idx;\n    if (g_log_next_idx == 0 && g_buffer_full) {\n        latest_entry_idx = ECU_STATE_LOG_BUFFER_SIZE - 1;\n    } else if (g_log_next_idx > 0) {\n        latest_entry_idx = g_log_next_idx - 1;\n    } else {\n        return; \n    }\n\n    int32_t target_idx_conceptual = (int32_t)latest_entry_idx - relative_offset_from_latest;\n\n    g_ecu_state_log[target_idx_conceptual].control_param_A = new_param_A_value;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define ECU_STATE_LOG_BUFFER_SIZE 32\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t control_param_A;\n    uint16_t control_param_B;\n    uint32_t diagnostic_status_flags;\n} ECU_StateSnapshot;\n\nstatic ECU_StateSnapshot g_ecu_state_log_fixed[ECU_STATE_LOG_BUFFER_SIZE];\nstatic uint16_t g_log_next_idx_fixed = 0; \nstatic bool g_buffer_full_fixed = false; \n\nvoid init_ecu_log_fixed() {\n    memset(g_ecu_state_log_fixed, 0, sizeof(g_ecu_state_log_fixed));\n    g_log_next_idx_fixed = 0;\n    g_buffer_full_fixed = false;\n}\n\nvoid log_ecu_state_fixed(uint32_t ts, uint16_t paramA, uint16_t paramB, uint32_t flags) {\n    g_ecu_state_log_fixed[g_log_next_idx_fixed].timestamp = ts;\n    g_ecu_state_log_fixed[g_log_next_idx_fixed].control_param_A = paramA;\n    g_ecu_state_log_fixed[g_log_next_idx_fixed].control_param_B = paramB;\n    g_ecu_state_log_fixed[g_log_next_idx_fixed].diagnostic_status_flags = flags;\n\n    g_log_next_idx_fixed++;\n    if (g_log_next_idx_fixed >= ECU_STATE_LOG_BUFFER_SIZE) {\n        g_log_next_idx_fixed = 0;\n        g_buffer_full_fixed = true;\n    }\n}\n\nvoid adjust_snapshot_param_fixed(uint16_t relative_offset_from_latest, uint16_t new_param_A_value) {\n    uint16_t num_logged_entries = g_buffer_full_fixed ? ECU_STATE_LOG_BUFFER_SIZE : g_log_next_idx_fixed;\n\n    if (num_logged_entries == 0 || relative_offset_from_latest >= num_logged_entries) {\n        return; \n    }\n\n    uint16_t latest_entry_idx;\n    if (g_log_next_idx_fixed == 0 && g_buffer_full_fixed) {\n        latest_entry_idx = ECU_STATE_LOG_BUFFER_SIZE - 1;\n    } else {\n        latest_entry_idx = g_log_next_idx_fixed - 1;\n    }\n\n    int32_t target_idx_conceptual = (int32_t)latest_entry_idx - relative_offset_from_latest;\n    \n    uint16_t target_idx_fixed = (uint16_t)(((target_idx_conceptual % ECU_STATE_LOG_BUFFER_SIZE) + ECU_STATE_LOG_BUFFER_SIZE) % ECU_STATE_LOG_BUFFER_SIZE);\n\n    g_ecu_state_log_fixed[target_idx_fixed].control_param_A = new_param_A_value;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_TRIP_SEGMENTS 20\n#define TRIP_DATA_SIZE_BYTES 8\n\ntypedef struct {\n    uint16_t segment_id;\n    uint32_t start_time_ms;\n    uint8_t  segment_data[TRIP_DATA_SIZE_BYTES];\n    bool     is_valid;\n} TripSegment;\n\nstatic TripSegment g_trip_segment_buffer[MAX_TRIP_SEGMENTS];\nstatic uint8_t g_current_segment_count = 0;\n\nvoid init_trip_logger() {\n    memset(g_trip_segment_buffer, 0, sizeof(g_trip_segment_buffer));\n    g_current_segment_count = 0;\n}\n\nbool add_trip_segment(uint16_t id, uint32_t time, const uint8_t* data, uint8_t data_len) {\n    if (g_current_segment_count >= MAX_TRIP_SEGMENTS) {\n        return false;\n    }\n    if (data_len > TRIP_DATA_SIZE_BYTES) {\n        data_len = TRIP_DATA_SIZE_BYTES;\n    }\n\n    TripSegment* current_segment = &g_trip_segment_buffer[g_current_segment_count];\n    current_segment->segment_id = id;\n    current_segment->start_time_ms = time;\n    if (data) {\n        memcpy(current_segment->segment_data, data, data_len);\n    }\n    current_segment->is_valid = true;\n    g_current_segment_count++;\n    return true;\n}\n\nvoid process_active_segment(uint8_t index) {\n    if (index < g_current_segment_count && g_trip_segment_buffer[index].is_valid) {\n        volatile uint16_t id = g_trip_segment_buffer[index].segment_id;\n        (void)id;\n    }\n}\n\nvoid clear_N_latest_segments_vulnerable(uint8_t n_to_clear) {\n    if (g_current_segment_count == 0 || n_to_clear == 0) {\n        return;\n    }\n\n    int32_t start_clear_idx = (int32_t)g_current_segment_count - n_to_clear;\n\n    for (int32_t i = 0; i < n_to_clear; ++i) {\n        g_trip_segment_buffer[start_clear_idx + i].is_valid = false;\n    }\n    \n    if (g_current_segment_count > n_to_clear) {\n        g_current_segment_count -= n_to_clear;\n    } else {\n        g_current_segment_count = 0;\n    }\n\n    if (g_current_segment_count > 0) {\n        process_active_segment(0);\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_TRIP_SEGMENTS_FIXED 20\n#define TRIP_DATA_SIZE_BYTES_FIXED 8\n\ntypedef struct {\n    uint16_t segment_id;\n    uint32_t start_time_ms;\n    uint8_t  segment_data[TRIP_DATA_SIZE_BYTES_FIXED];\n    bool     is_valid;\n} TripSegmentFixed;\n\nstatic TripSegmentFixed g_trip_segment_buffer_fixed[MAX_TRIP_SEGMENTS_FIXED];\nstatic uint8_t g_current_segment_count_fixed = 0;\n\nvoid init_trip_logger_fixed() {\n    memset(g_trip_segment_buffer_fixed, 0, sizeof(g_trip_segment_buffer_fixed));\n    g_current_segment_count_fixed = 0;\n}\n\nbool add_trip_segment_fixed(uint16_t id, uint32_t time, const uint8_t* data, uint8_t data_len) {\n    if (g_current_segment_count_fixed >= MAX_TRIP_SEGMENTS_FIXED) {\n        return false;\n    }\n    if (data_len > TRIP_DATA_SIZE_BYTES_FIXED) {\n        data_len = TRIP_DATA_SIZE_BYTES_FIXED;\n    }\n\n    TripSegmentFixed* current_segment = &g_trip_segment_buffer_fixed[g_current_segment_count_fixed];\n    current_segment->segment_id = id;\n    current_segment->start_time_ms = time;\n    if (data) {\n        memcpy(current_segment->segment_data, data, data_len);\n    }\n    current_segment->is_valid = true;\n    g_current_segment_count_fixed++;\n    return true;\n}\n\nvoid process_active_segment_fixed(uint8_t index) {\n    if (index < g_current_segment_count_fixed && g_trip_segment_buffer_fixed[index].is_valid) {\n        volatile uint16_t id = g_trip_segment_buffer_fixed[index].segment_id;\n        (void)id;\n    }\n}\n\nvoid clear_N_latest_segments_fixed(uint8_t n_to_clear) {\n    if (g_current_segment_count_fixed == 0 || n_to_clear == 0) {\n        return;\n    }\n\n    uint8_t actual_segments_to_clear = n_to_clear;\n    if (actual_segments_to_clear > g_current_segment_count_fixed) {\n        actual_segments_to_clear = g_current_segment_count_fixed;\n    }\n\n    int32_t start_clear_idx = (int32_t)g_current_segment_count_fixed - actual_segments_to_clear;\n\n    for (int32_t i = 0; i < actual_segments_to_clear; ++i) {\n        g_trip_segment_buffer_fixed[start_clear_idx + i].is_valid = false;\n    }\n    \n    g_current_segment_count_fixed -= actual_segments_to_clear;\n\n    if (g_current_segment_count_fixed > 0) {\n        process_active_segment_fixed(0);\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_PROCESSED_SENSORS 128\n\ntypedef struct {\n    uint32_t sensor_id;\n    uint32_t processed_value;\n    bool valid;\n} ProcessedSensorEntry;\n\nstatic ProcessedSensorEntry g_processed_sensor_data_vulnerable[MAX_PROCESSED_SENSORS];\nstatic int16_t g_next_write_idx_vulnerable = 0;\n\nvoid init_sensor_data_buffer_vulnerable() {\n    memset(g_processed_sensor_data_vulnerable, 0, sizeof(g_processed_sensor_data_vulnerable));\n    g_next_write_idx_vulnerable = 0;\n}\n\nbool add_processed_sensor_data_vulnerable(uint32_t id, uint32_t value) {\n    if (g_next_write_idx_vulnerable >= MAX_PROCESSED_SENSORS) {\n        return false;\n    }\n    g_processed_sensor_data_vulnerable[g_next_write_idx_vulnerable].sensor_id = id;\n    g_processed_sensor_data_vulnerable[g_next_write_idx_vulnerable].processed_value = value;\n    g_processed_sensor_data_vulnerable[g_next_write_idx_vulnerable].valid = true;\n    g_next_write_idx_vulnerable++;\n    return true;\n}\n\nvoid mark_sensor_data_invalid_vulnerable(uint16_t historical_offset) {\n    if (g_next_write_idx_vulnerable == 0) {\n        return;\n    }\n\n    int16_t last_valid_idx = g_next_write_idx_vulnerable - 1;\n\n    int16_t target_idx = last_valid_idx - historical_offset;\n\n    g_processed_sensor_data_vulnerable[target_idx].valid = false;\n    g_processed_sensor_data_vulnerable[target_idx].processed_value = 0xFFFFFFFF;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_PROCESSED_SENSORS 128\n\ntypedef struct {\n    uint32_t sensor_id;\n    uint32_t processed_value;\n    bool valid;\n} ProcessedSensorEntry;\n\nstatic ProcessedSensorEntry g_processed_sensor_data_fixed[MAX_PROCESSED_SENSORS];\nstatic int16_t g_next_write_idx_fixed = 0;\n\nvoid init_sensor_data_buffer_fixed() {\n    memset(g_processed_sensor_data_fixed, 0, sizeof(g_processed_sensor_data_fixed));\n    g_next_write_idx_fixed = 0;\n}\n\nbool add_processed_sensor_data_fixed(uint32_t id, uint32_t value) {\n    if (g_next_write_idx_fixed >= MAX_PROCESSED_SENSORS) {\n        return false;\n    }\n    g_processed_sensor_data_fixed[g_next_write_idx_fixed].sensor_id = id;\n    g_processed_sensor_data_fixed[g_next_write_idx_fixed].processed_value = value;\n    g_processed_sensor_data_fixed[g_next_write_idx_fixed].valid = true;\n    g_next_write_idx_fixed++;\n    return true;\n}\n\nvoid mark_sensor_data_invalid_fixed(uint16_t historical_offset) {\n    if (g_next_write_idx_fixed == 0) {\n        return;\n    }\n\n    int16_t last_valid_idx = g_next_write_idx_fixed - 1;\n\n    int16_t target_idx = last_valid_idx - historical_offset;\n\n    if (target_idx < 0) {\n        return;\n    }\n\n    g_processed_sensor_data_fixed[target_idx].valid = false;\n    g_processed_sensor_data_fixed[target_idx].processed_value = 0xFFFFFFFF;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CALIBRATION_BUFFER_SIZE 256\n#define CALIBRATION_BLOCK_SIZE 16\n\nstatic uint8_t g_calibration_data[CALIBRATION_BUFFER_SIZE];\nstatic size_t g_num_active_blocks = 0;\n\nvoid init_calibration_store() {\n    memset(g_calibration_data, 0, CALIBRATION_BUFFER_SIZE);\n    g_num_active_blocks = 0;\n}\n\nbool add_calibration_block(const uint8_t* block_data) {\n    if ((g_num_active_blocks + 1) * CALIBRATION_BLOCK_SIZE > CALIBRATION_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_calibration_data + (g_num_active_blocks * CALIBRATION_BLOCK_SIZE), block_data, CALIBRATION_BLOCK_SIZE);\n    g_num_active_blocks++;\n    return true;\n}\n\n// This function shifts a block of calibration data within the buffer.\n// The vulnerability exists if 'relative_shift_steps' is a negative value\n// that causes 'effective_destination_byte_offset' to go below zero, leading\n// to a buffer underwrite when memmove attempts to write before the buffer's start.\nvoid rearrange_calibration_block_vulnerable(uint16_t block_index_to_move, int16_t relative_shift_steps) {\n    if (block_index_to_move >= g_num_active_blocks) {\n        return; \n    }\n\n    int32_t source_byte_offset = (int32_t)block_index_to_move * CALIBRATION_BLOCK_SIZE;\n    int32_t effective_destination_byte_offset = source_byte_offset + (relative_shift_steps * CALIBRATION_BLOCK_SIZE);\n\n    uint8_t* source_ptr = g_calibration_data + source_byte_offset;\n    uint8_t* destination_ptr = g_calibration_data + effective_destination_byte_offset;\n\n    memmove(destination_ptr, source_ptr, CALIBRATION_BLOCK_SIZE);\n}\n",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CALIBRATION_BUFFER_SIZE_FIXED 256\n#define CALIBRATION_BLOCK_SIZE_FIXED 16\n\nstatic uint8_t g_calibration_data_fixed[CALIBRATION_BUFFER_SIZE_FIXED];\nstatic size_t g_num_active_blocks_fixed = 0;\n\nvoid init_calibration_store_fixed() {\n    memset(g_calibration_data_fixed, 0, CALIBRATION_BUFFER_SIZE_FIXED);\n    g_num_active_blocks_fixed = 0;\n}\n\nbool add_calibration_block_fixed(const uint8_t* block_data) {\n    if ((g_num_active_blocks_fixed + 1) * CALIBRATION_BLOCK_SIZE_FIXED > CALIBRATION_BUFFER_SIZE_FIXED) {\n        return false;\n    }\n    memcpy(g_calibration_data_fixed + (g_num_active_blocks_fixed * CALIBRATION_BLOCK_SIZE_FIXED), block_data, CALIBRATION_BLOCK_SIZE_FIXED);\n    g_num_active_blocks_fixed++;\n    return true;\n}\n\nvoid rearrange_calibration_block_fixed(uint16_t block_index_to_move, int16_t relative_shift_steps) {\n    if (block_index_to_move >= g_num_active_blocks_fixed) {\n        return; \n    }\n\n    int32_t source_byte_offset = (int32_t)block_index_to_move * CALIBRATION_BLOCK_SIZE_FIXED;\n    int32_t effective_destination_byte_offset = source_byte_offset + (relative_shift_steps * CALIBRATION_BLOCK_SIZE_FIXED);\n\n    // CRITICAL FIX: Validate the calculated destination offset to prevent buffer underwrite.\n    // Check if the destination starts before the buffer or extends beyond its valid size.\n    if (effective_destination_byte_offset < 0 || \n        (size_t)effective_destination_byte_offset + CALIBRATION_BLOCK_SIZE_FIXED > CALIBRATION_BUFFER_SIZE_FIXED) {\n        return; \n    }\n\n    uint8_t* source_ptr = g_calibration_data_fixed + source_byte_offset;\n    uint8_t* destination_ptr = g_calibration_data_fixed + effective_destination_byte_offset;\n\n    memmove(destination_ptr, source_ptr, CALIBRATION_BLOCK_SIZE_FIXED);\n}\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CONFIG_AREA_SIZE 256\n#define ECU_MAX_PARAM_VALUE 0xFF\n\nstatic uint8_t g_ecu_config_area[CONFIG_AREA_SIZE];\n\ntypedef struct {\n    uint16_t param_id;\n    uint16_t base_offset;\n    uint8_t size;\n    int16_t lock_byte_offset;\n} ConfigParamMetadata;\n\nstatic const ConfigParamMetadata g_param_mapping[] = {\n    {0x0001, 0, 4, -1},\n    {0x0002, 4, 2, -3},\n    {0x0003, 6, 8, -7},\n    {0x0004, 14, 1, 0},\n    {0x0005, 15, 16, 17}\n};\n#define NUM_PARAM_MAPPINGS (sizeof(g_param_mapping) / sizeof(g_param_mapping[0]))\n\nvoid init_ecu_config_area() {\n    memset(g_ecu_config_area, ECU_MAX_PARAM_VALUE, CONFIG_AREA_SIZE);\n}\n\nbool get_config_parameter(uint16_t param_id, uint8_t* buffer, uint32_t buffer_len) {\n    for (int i = 0; i < NUM_PARAM_MAPPINGS; ++i) {\n        if (g_param_mapping[i].param_id == param_id) {\n            const ConfigParamMetadata* meta = &g_param_mapping[i];\n            if (buffer_len < meta->size || meta->base_offset + meta->size > CONFIG_AREA_SIZE) {\n                return false;\n            }\n            memcpy(buffer, g_ecu_config_area + meta->base_offset, meta->size);\n            return true;\n        }\n    }\n    return false;\n}\n\nbool update_config_parameter_vulnerable(uint16_t param_id, const uint8_t* new_data, uint32_t data_len) {\n    const ConfigParamMetadata* meta = NULL;\n    for (int i = 0; i < NUM_PARAM_MAPPINGS; ++i) {\n        if (g_param_mapping[i].param_id == param_id) {\n            meta = &g_param_mapping[i];\n            break;\n        }\n    }\n\n    if (meta == NULL) {\n        return false;\n    }\n\n    if (data_len != meta->size) {\n        return false;\n    }\n\n    if (meta->base_offset + meta->size > CONFIG_AREA_SIZE) {\n        return false;\n    }\n\n    int32_t lock_byte_absolute_offset = (int32_t)meta->base_offset + meta->lock_byte_offset;\n\n    g_ecu_config_area[lock_byte_absolute_offset] = 0xAA;\n\n    memcpy(g_ecu_config_area + meta->base_offset, new_data, data_len);\n\n    return true;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define CONFIG_AREA_SIZE 256\n#define ECU_MAX_PARAM_VALUE 0xFF\n\nstatic uint8_t g_ecu_config_area[CONFIG_AREA_SIZE];\n\ntypedef struct {\n    uint16_t param_id;\n    uint16_t base_offset;\n    uint8_t size;\n    int16_t lock_byte_offset;\n} ConfigParamMetadata;\n\nstatic const ConfigParamMetadata g_param_mapping[] = {\n    {0x0001, 0, 4, -1},\n    {0x0002, 4, 2, -3},\n    {0x0003, 6, 8, -7},\n    {0x0004, 14, 1, 0},\n    {0x0005, 15, 16, 17}\n};\n#define NUM_PARAM_MAPPINGS (sizeof(g_param_mapping) / sizeof(g_param_mapping[0]))\n\nvoid init_ecu_config_area() {\n    memset(g_ecu_config_area, ECU_MAX_PARAM_VALUE, CONFIG_AREA_SIZE);\n}\n\nbool get_config_parameter(uint16_t param_id, uint8_t* buffer, uint32_t buffer_len) {\n    for (int i = 0; i < NUM_PARAM_MAPPINGS; ++i) {\n        if (g_param_mapping[i].param_id == param_id) {\n            const ConfigParamMetadata* meta = &g_param_mapping[i];\n            if (buffer_len < meta->size || meta->base_offset + meta->size > CONFIG_AREA_SIZE) {\n                return false;\n            }\n            memcpy(buffer, g_ecu_config_area + meta->base_offset, meta->size);\n            return true;\n        }\n    }\n    return false;\n}\n\nbool update_config_parameter_fixed(uint16_t param_id, const uint8_t* new_data, uint32_t data_len) {\n    const ConfigParamMetadata* meta = NULL;\n    for (int i = 0; i < NUM_PARAM_MAPPINGS; ++i) {\n        if (g_param_mapping[i].param_id == param_id) {\n            meta = &g_param_mapping[i];\n            break;\n        }\n    }\n\n    if (meta == NULL) {\n        return false;\n    }\n\n    if (data_len != meta->size) {\n        return false;\n    }\n\n    if (meta->base_offset + meta->size > CONFIG_AREA_SIZE) {\n        return false;\n    }\n\n    int32_t lock_byte_absolute_offset = (int32_t)meta->base_offset + meta->lock_byte_offset;\n\n    if (lock_byte_absolute_offset < 0 || lock_byte_absolute_offset >= CONFIG_AREA_SIZE) {\n        return false;\n    }\n\n    g_ecu_config_area[lock_byte_absolute_offset] = 0xAA;\n\n    memcpy(g_ecu_config_area + meta->base_offset, new_data, data_len);\n\n    return true;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define FIRMWARE_DATA_BUFFER_SIZE 512\n#define MAX_FIRMWARE_CHUNK_SIZE 128\n\nstatic uint8_t g_firmware_data_buffer[FIRMWARE_DATA_BUFFER_SIZE];\nstatic uint8_t* g_firmware_write_ptr;\nstatic uint32_t g_firmware_data_current_len;\n\nstatic volatile uint8_t g_ecu_operational_mode = 0x01;\n\nvoid init_firmware_data_handler() {\n    memset(g_firmware_data_buffer, 0, FIRMWARE_DATA_BUFFER_SIZE);\n    g_firmware_write_ptr = g_firmware_data_buffer;\n    g_firmware_data_current_len = 0;\n    g_ecu_operational_mode = 0x01;\n}\n\nbool append_firmware_chunk(const uint8_t* chunk, uint16_t chunk_len) {\n    if (chunk == NULL || chunk_len == 0 || chunk_len > MAX_FIRMWARE_CHUNK_SIZE) {\n        return false;\n    }\n\n    if (g_firmware_data_current_len + chunk_len > FIRMWARE_DATA_BUFFER_SIZE) {\n        return false;\n    }\n\n    memcpy(g_firmware_write_ptr, chunk, chunk_len);\n    g_firmware_write_ptr += chunk_len;\n    g_firmware_data_current_len += chunk_len;\n    return true;\n}\n\nvoid rewind_firmware_data_vulnerable(uint16_t bytes_to_rewind) {\n    if (bytes_to_rewind > g_firmware_data_current_len) {\n        bytes_to_rewind = g_firmware_data_current_len;\n    }\n\n    g_firmware_write_ptr -= bytes_to_rewind;\n    g_firmware_data_current_len -= bytes_to_rewind;\n\n    *g_firmware_write_ptr = 0x00;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define FIRMWARE_DATA_BUFFER_SIZE 512\n#define MAX_FIRMWARE_CHUNK_SIZE 128\n\nstatic uint8_t g_firmware_data_buffer[FIRMWARE_DATA_BUFFER_SIZE];\nstatic uint8_t* g_firmware_write_ptr;\nstatic uint32_t g_firmware_data_current_len;\n\nstatic volatile uint8_t g_ecu_operational_mode = 0x01;\n\nvoid init_firmware_data_handler() {\n    memset(g_firmware_data_buffer, 0, FIRMWARE_DATA_BUFFER_SIZE);\n    g_firmware_write_ptr = g_firmware_data_buffer;\n    g_firmware_data_current_len = 0;\n    g_ecu_operational_mode = 0x01;\n}\n\nbool append_firmware_chunk(const uint8_t* chunk, uint16_t chunk_len) {\n    if (chunk == NULL || chunk_len == 0 || chunk_len > MAX_FIRMWARE_CHUNK_SIZE) {\n        return false;\n    }\n\n    if (g_firmware_data_current_len + chunk_len > FIRMWARE_DATA_BUFFER_SIZE) {\n        return false;\n    }\n\n    memcpy(g_firmware_write_ptr, chunk, chunk_len);\n    g_firmware_write_ptr += chunk_len;\n    g_firmware_data_current_len += chunk_len;\n    return true;\n}\n\nvoid rewind_firmware_data_fixed(uint16_t bytes_to_rewind) {\n    if (bytes_to_rewind > g_firmware_data_current_len) {\n        bytes_to_rewind = g_firmware_data_current_len;\n    }\n\n    uint8_t* proposed_write_ptr = g_firmware_write_ptr - bytes_to_rewind;\n    uint32_t proposed_data_len = g_firmware_data_current_len - bytes_to_rewind;\n\n    if (proposed_write_ptr < g_firmware_data_buffer) {\n        g_firmware_write_ptr = g_firmware_data_buffer;\n        g_firmware_data_current_len = 0;\n    } else {\n        g_firmware_write_ptr = proposed_write_ptr;\n        g_firmware_data_current_len = proposed_data_len;\n    }\n\n    if (g_firmware_write_ptr >= g_firmware_data_buffer && g_firmware_write_ptr < g_firmware_data_buffer + FIRMWARE_DATA_BUFFER_SIZE) {\n        *g_firmware_write_ptr = 0x00;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define COMMAND_QUEUE_SIZE 10\n#define COMMAND_PAYLOAD_SIZE 16\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t payload[COMMAND_PAYLOAD_SIZE];\n} CommandPacket;\n\n#define META_BUFFER_SIZE 4\n#define CMD_QUEUE_START_OFFSET META_BUFFER_SIZE\n#define TOTAL_SYSTEM_MEMORY_SIZE (META_BUFFER_SIZE + sizeof(CommandPacket) * COMMAND_QUEUE_SIZE)\n\nstatic uint8_t g_system_memory[TOTAL_SYSTEM_MEMORY_SIZE];\nstatic uint16_t g_cmd_queue_head = 0;\nstatic uint16_t g_cmd_queue_count = 0;\n\nvoid init_command_system_vulnerable() {\n    memset(g_system_memory, 0, TOTAL_SYSTEM_MEMORY_SIZE);\n    g_cmd_queue_head = 0;\n    g_cmd_queue_count = 0;\n    g_system_memory[0] = 0xAA;\n    g_system_memory[1] = 0xBB;\n    g_system_memory[2] = 0xCC;\n    g_system_memory[3] = 0xDD;\n}\n\nbool enqueue_command_vulnerable(const CommandPacket* cmd) {\n    if (g_cmd_queue_count >= COMMAND_QUEUE_SIZE) {\n        return false;\n    }\n    uint16_t tail_idx = (g_cmd_queue_head + g_cmd_queue_count) % COMMAND_QUEUE_SIZE;\n    ((CommandPacket*)(g_system_memory + CMD_QUEUE_START_OFFSET))[tail_idx] = *cmd;\n    g_cmd_queue_count++;\n    return true;\n}\n\nvoid process_and_mark_command_vulnerable(uint8_t processed_status_val, int16_t status_offset_from_head) {\n    if (g_cmd_queue_count == 0) {\n        return;\n    }\n\n    uint16_t actual_cmd_idx = g_cmd_queue_head;\n\n    CommandPacket current_cmd = ((CommandPacket*)(g_system_memory + CMD_QUEUE_START_OFFSET))[actual_cmd_idx];\n    (void)current_cmd;\n\n    g_cmd_queue_head = (g_cmd_queue_head + 1) % COMMAND_QUEUE_SIZE;\n    g_cmd_queue_count--;\n\n    int32_t target_byte_offset_from_system_start = (int32_t)CMD_QUEUE_START_OFFSET + (int32_t)(actual_cmd_idx * sizeof(CommandPacket)) + status_offset_from_head;\n    \n    g_system_memory[target_byte_offset_from_system_start] = processed_status_val;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define COMMAND_QUEUE_SIZE 10\n#define COMMAND_PAYLOAD_SIZE 16\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t payload[COMMAND_PAYLOAD_SIZE];\n} CommandPacket;\n\n#define META_BUFFER_SIZE 4\n#define CMD_QUEUE_START_OFFSET META_BUFFER_SIZE\n#define TOTAL_SYSTEM_MEMORY_SIZE (META_BUFFER_SIZE + sizeof(CommandPacket) * COMMAND_QUEUE_SIZE)\n\nstatic uint8_t g_system_memory_fixed[TOTAL_SYSTEM_MEMORY_SIZE];\nstatic uint16_t g_cmd_queue_head_fixed = 0;\nstatic uint16_t g_cmd_queue_count_fixed = 0;\n\nvoid init_command_system_fixed() {\n    memset(g_system_memory_fixed, 0, TOTAL_SYSTEM_MEMORY_SIZE);\n    g_cmd_queue_head_fixed = 0;\n    g_cmd_queue_count_fixed = 0;\n    g_system_memory_fixed[0] = 0xAA;\n    g_system_memory_fixed[1] = 0xBB;\n    g_system_memory_fixed[2] = 0xCC;\n    g_system_memory_fixed[3] = 0xDD;\n}\n\nbool enqueue_command_fixed(const CommandPacket* cmd) {\n    if (g_cmd_queue_count_fixed >= COMMAND_QUEUE_SIZE) {\n        return false;\n    }\n    uint16_t tail_idx = (g_cmd_queue_head_fixed + g_cmd_queue_count_fixed) % COMMAND_QUEUE_SIZE;\n    ((CommandPacket*)(g_system_memory_fixed + CMD_QUEUE_START_OFFSET))[tail_idx] = *cmd;\n    g_cmd_queue_count_fixed++;\n    return true;\n}\n\nvoid process_and_mark_command_fixed(uint8_t processed_status_val, int16_t status_offset_from_head) {\n    if (g_cmd_queue_count_fixed == 0) {\n        return;\n    }\n\n    uint16_t actual_cmd_idx = g_cmd_queue_head_fixed;\n\n    CommandPacket current_cmd = ((CommandPacket*)(g_system_memory_fixed + CMD_QUEUE_START_OFFSET))[actual_cmd_idx];\n    (void)current_cmd;\n\n    g_cmd_queue_head_fixed = (g_cmd_queue_head_fixed + 1) % COMMAND_QUEUE_SIZE;\n    g_cmd_queue_count_fixed--;\n\n    int32_t target_byte_offset_from_system_start = (int32_t)CMD_QUEUE_START_OFFSET + (int32_t)(actual_cmd_idx * sizeof(CommandPacket)) + status_offset_from_head;\n\n    if (target_byte_offset_from_system_start < 0 || target_byte_offset_from_system_start >= TOTAL_SYSTEM_MEMORY_SIZE) {\n        return;\n    }\n    \n    g_system_memory_fixed[target_byte_offset_from_system_start] = processed_status_val;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_LOG_CAPACITY 64\n\ntypedef struct {\n    uint32_t fault_code;\n    uint32_t timestamp;\n    uint8_t  level; \n    uint8_t  param_count;\n    uint16_t params[2];\n} DiagnosticLogEntry;\n\nstatic DiagnosticLogEntry g_diag_log_buffer[DIAG_LOG_CAPACITY];\nstatic uint16_t g_log_write_idx = 0;\nstatic uint16_t g_num_logged_entries = 0;\n\nvoid init_diag_logger_vulnerable() {\n    memset(g_diag_log_buffer, 0, sizeof(g_diag_log_buffer));\n    g_log_write_idx = 0;\n    g_num_logged_entries = 0;\n}\n\nvoid add_diag_entry_vulnerable(uint32_t code, uint32_t ts, uint8_t level, uint8_t p_count, uint16_t p1, uint16_t p2) {\n    if (g_num_logged_entries < DIAG_LOG_CAPACITY) {\n        g_diag_log_buffer[g_log_write_idx].fault_code = code;\n        g_diag_log_buffer[g_log_write_idx].timestamp = ts;\n        g_diag_log_buffer[g_log_write_idx].level = level;\n        g_diag_log_buffer[g_log_write_idx].param_count = p_count;\n        g_diag_log_buffer[g_log_write_idx].params[0] = p1;\n        g_diag_log_buffer[g_log_write_idx].params[1] = p2;\n        \n        g_log_write_idx = (g_log_write_idx + 1) % DIAG_LOG_CAPACITY;\n        g_num_logged_entries++;\n    } else {\n        g_diag_log_buffer[g_log_write_idx].fault_code = code;\n        g_diag_log_buffer[g_log_write_idx].timestamp = ts;\n        g_diag_log_buffer[g_log_write_idx].level = level;\n        g_diag_log_buffer[g_log_write_idx].param_count = p_count;\n        g_diag_log_buffer[g_log_write_idx].params[0] = p1;\n        g_diag_log_buffer[g_log_write_idx].params[1] = p2;\n        g_log_write_idx = (g_log_write_idx + 1) % DIAG_LOG_CAPACITY;\n    }\n}\n\nvoid clear_recent_diag_level_entries_vulnerable(uint8_t level_to_clear, uint16_t search_depth) {\n    if (g_num_logged_entries == 0 || search_depth == 0) {\n        return;\n    }\n\n    int32_t current_logical_tail_idx;\n    if (g_log_write_idx == 0) {\n        current_logical_tail_idx = DIAG_LOG_CAPACITY - 1;\n    } else {\n        current_logical_tail_idx = g_log_write_idx - 1;\n    }\n\n    for (uint16_t k = 0; k < search_depth; ++k) {\n        int32_t target_idx = current_logical_tail_idx - k;\n\n        if (g_diag_log_buffer[target_idx].level == level_to_clear) {\n            memset(&g_diag_log_buffer[target_idx], 0, sizeof(DiagnosticLogEntry));\n        }\n    }\n}\n",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_LOG_CAPACITY 64\n\ntypedef struct {\n    uint32_t fault_code;\n    uint32_t timestamp;\n    uint8_t  level; \n    uint8_t  param_count;\n    uint16_t params[2];\n} DiagnosticLogEntry;\n\nstatic DiagnosticLogEntry g_diag_log_buffer[DIAG_LOG_CAPACITY];\nstatic uint16_t g_log_write_idx = 0;\nstatic uint16_t g_num_logged_entries = 0;\n\nvoid init_diag_logger_fixed() {\n    memset(g_diag_log_buffer, 0, sizeof(g_diag_log_buffer));\n    g_log_write_idx = 0;\n    g_num_logged_entries = 0;\n}\n\nvoid add_diag_entry_fixed(uint32_t code, uint32_t ts, uint8_t level, uint8_t p_count, uint16_t p1, uint16_t p2) {\n    if (g_num_logged_entries < DIAG_LOG_CAPACITY) {\n        g_diag_log_buffer[g_log_write_idx].fault_code = code;\n        g_diag_log_buffer[g_log_write_idx].timestamp = ts;\n        g_diag_log_buffer[g_log_write_idx].level = level;\n        g_diag_log_buffer[g_log_write_idx].param_count = p_count;\n        g_diag_log_buffer[g_log_write_idx].params[0] = p1;\n        g_diag_log_buffer[g_log_write_idx].params[1] = p2;\n        \n        g_log_write_idx = (g_log_write_idx + 1) % DIAG_LOG_CAPACITY;\n        g_num_logged_entries++;\n    } else {\n        g_diag_log_buffer[g_log_write_idx].fault_code = code;\n        g_diag_log_buffer[g_log_write_idx].timestamp = ts;\n        g_diag_log_buffer[g_log_write_idx].level = level;\n        g_diag_log_buffer[g_log_write_idx].param_count = p_count;\n        g_diag_log_buffer[g_log_write_idx].params[0] = p1;\n        g_diag_log_buffer[g_log_write_idx].params[1] = p2;\n        g_log_write_idx = (g_log_write_idx + 1) % DIAG_LOG_CAPACITY;\n    }\n}\n\nvoid clear_recent_diag_level_entries_fixed(uint8_t level_to_clear, uint16_t search_depth) {\n    if (g_num_logged_entries == 0 || search_depth == 0) {\n        return;\n    }\n\n    uint16_t current_logical_tail_idx = (g_log_write_idx == 0) ? (DIAG_LOG_CAPACITY - 1) : (g_log_write_idx - 1);\n\n    uint16_t effective_search_depth = (search_depth > g_num_logged_entries) ? g_num_logged_entries : search_depth;\n\n    for (uint16_t k = 0; k < effective_search_depth; ++k) {\n        uint16_t target_idx = (current_logical_tail_idx - k + DIAG_LOG_CAPACITY) % DIAG_LOG_CAPACITY;\n\n        if (g_diag_log_buffer[target_idx].level == level_to_clear) {\n            memset(&g_diag_log_buffer[target_idx], 0, sizeof(DiagnosticLogEntry));\n        }\n    }\n}\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CONFIG_MEMORY_SIZE 512\n#define CONFIG_BLOCK_DATA_SIZE 26\n#define CONFIG_BLOCK_HEADER_SIZE 4\n#define CONFIG_BLOCK_CHECKSUM_SIZE 2\n#define CONFIG_BLOCK_SIZE (CONFIG_BLOCK_HEADER_SIZE + CONFIG_BLOCK_DATA_SIZE + CONFIG_BLOCK_CHECKSUM_SIZE)\n\n#define CONFIG_BLOCK_ID_OFFSET 0\n#define CONFIG_BLOCK_STATUS_OFFSET 2\n#define CONFIG_BLOCK_DATA_OFFSET 4\n#define CONFIG_BLOCK_DATA_MAX_LEN (CONFIG_BLOCK_SIZE - CONFIG_BLOCK_HEADER_SIZE - CONFIG_BLOCK_CHECKSUM_SIZE)\n#define CONFIG_BLOCK_CHECKSUM_OFFSET (CONFIG_BLOCK_SIZE - CONFIG_BLOCK_CHECKSUM_SIZE)\n\n#define MAX_CONFIG_BLOCKS (CONFIG_MEMORY_SIZE / CONFIG_BLOCK_SIZE)\n\nstatic uint8_t g_config_bank[CONFIG_MEMORY_SIZE];\nstatic bool g_block_in_use[MAX_CONFIG_BLOCKS];\n\nvoid init_config_manager() {\n    memset(g_config_bank, 0xFF, CONFIG_MEMORY_SIZE);\n    for (uint16_t i = 0; i < MAX_CONFIG_BLOCKS; ++i) {\n        g_block_in_use[i] = false;\n    }\n}\n\nbool allocate_config_block(uint16_t block_id, uint8_t initial_status) {\n    if (block_id >= MAX_CONFIG_BLOCKS || g_block_in_use[block_id]) {\n        return false;\n    }\n    uint16_t block_start_offset = block_id * CONFIG_BLOCK_SIZE;\n    if (block_start_offset + CONFIG_BLOCK_SIZE > CONFIG_MEMORY_SIZE) {\n        return false;\n    }\n    g_block_in_use[block_id] = true;\n    *(uint16_t*)(g_config_bank + block_start_offset + CONFIG_BLOCK_ID_OFFSET) = block_id;\n    g_config_bank[block_start_offset + CONFIG_BLOCK_STATUS_OFFSET] = initial_status;\n    memset(g_config_bank + block_start_offset + CONFIG_BLOCK_DATA_OFFSET, 0, CONFIG_BLOCK_DATA_MAX_LEN);\n    *(uint16_t*)(g_config_bank + block_start_offset + CONFIG_BLOCK_CHECKSUM_OFFSET) = 0;\n    return true;\n}\n\nbool write_config_data(uint16_t block_id, const uint8_t* data, uint8_t data_len) {\n    if (block_id >= MAX_CONFIG_BLOCKS || !g_block_in_use[block_id] || data_len > CONFIG_BLOCK_DATA_MAX_LEN) {\n        return false;\n    }\n    uint16_t data_start_offset = block_id * CONFIG_BLOCK_SIZE + CONFIG_BLOCK_DATA_OFFSET;\n    memcpy(g_config_bank + data_start_offset, data, data_len);\n    return true;\n}\n\nvoid update_config_checksum_vulnerable(uint16_t block_index, int16_t relative_checksum_offset, uint16_t new_checksum_value) {\n    if (block_index >= MAX_CONFIG_BLOCKS || !g_block_in_use[block_index]) {\n        return;\n    }\n\n    uint8_t* block_base_ptr = g_config_bank + (block_index * CONFIG_BLOCK_SIZE);\n\n    uint8_t* target_checksum_ptr = block_base_ptr + relative_checksum_offset;\n\n    *(uint16_t*)target_checksum_ptr = new_checksum_value;\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CONFIG_MEMORY_SIZE 512\n#define CONFIG_BLOCK_DATA_SIZE 26\n#define CONFIG_BLOCK_HEADER_SIZE 4\n#define CONFIG_BLOCK_CHECKSUM_SIZE 2\n#define CONFIG_BLOCK_SIZE (CONFIG_BLOCK_HEADER_SIZE + CONFIG_BLOCK_DATA_SIZE + CONFIG_BLOCK_CHECKSUM_SIZE)\n\n#define CONFIG_BLOCK_ID_OFFSET 0\n#define CONFIG_BLOCK_STATUS_OFFSET 2\n#define CONFIG_BLOCK_DATA_OFFSET 4\n#define CONFIG_BLOCK_DATA_MAX_LEN (CONFIG_BLOCK_SIZE - CONFIG_BLOCK_HEADER_SIZE - CONFIG_BLOCK_CHECKSUM_SIZE)\n#define CONFIG_BLOCK_CHECKSUM_OFFSET (CONFIG_BLOCK_SIZE - CONFIG_BLOCK_CHECKSUM_SIZE)\n\n#define MAX_CONFIG_BLOCKS (CONFIG_MEMORY_SIZE / CONFIG_BLOCK_SIZE)\n\nstatic uint8_t g_config_bank[CONFIG_MEMORY_SIZE];\nstatic bool g_block_in_use[MAX_CONFIG_BLOCKS];\n\nvoid init_config_manager() {\n    memset(g_config_bank, 0xFF, CONFIG_MEMORY_SIZE);\n    for (uint16_t i = 0; i < MAX_CONFIG_BLOCKS; ++i) {\n        g_block_in_use[i] = false;\n    }\n}\n\nbool allocate_config_block(uint16_t block_id, uint8_t initial_status) {\n    if (block_id >= MAX_CONFIG_BLOCKS || g_block_in_use[block_id]) {\n        return false;\n    }\n    uint16_t block_start_offset = block_id * CONFIG_BLOCK_SIZE;\n    if (block_start_offset + CONFIG_BLOCK_SIZE > CONFIG_MEMORY_SIZE) {\n        return false;\n    }\n    g_block_in_use[block_id] = true;\n    *(uint16_t*)(g_config_bank + block_start_offset + CONFIG_BLOCK_ID_OFFSET) = block_id;\n    g_config_bank[block_start_offset + CONFIG_BLOCK_STATUS_OFFSET] = initial_status;\n    memset(g_config_bank + block_start_offset + CONFIG_BLOCK_DATA_OFFSET, 0, CONFIG_BLOCK_DATA_MAX_LEN);\n    *(uint16_t*)(g_config_bank + block_start_offset + CONFIG_BLOCK_CHECKSUM_OFFSET) = 0;\n    return true;\n}\n\nbool write_config_data(uint16_t block_id, const uint8_t* data, uint8_t data_len) {\n    if (block_id >= MAX_CONFIG_BLOCKS || !g_block_in_use[block_id] || data_len > CONFIG_BLOCK_DATA_MAX_LEN) {\n        return false;\n    }\n    uint16_t data_start_offset = block_id * CONFIG_BLOCK_SIZE + CONFIG_BLOCK_DATA_OFFSET;\n    memcpy(g_config_bank + data_start_offset, data, data_len);\n    return true;\n}\n\nvoid update_config_checksum_fixed(uint16_t block_index, int16_t relative_checksum_offset, uint16_t new_checksum_value) {\n    if (block_index >= MAX_CONFIG_BLOCKS || !g_block_in_use[block_index]) {\n        return;\n    }\n\n    int32_t block_start_offset = (int32_t)block_index * CONFIG_BLOCK_SIZE;\n\n    int32_t target_offset_signed = block_start_offset + relative_checksum_offset;\n\n    if (target_offset_signed < 0 || (uint32_t)target_offset_signed + CONFIG_BLOCK_CHECKSUM_SIZE > CONFIG_MEMORY_SIZE) {\n        return;\n    }\n    \n    uint16_t target_offset = (uint16_t)target_offset_signed;\n\n    *(uint16_t*)(g_config_bank + target_offset) = new_checksum_value;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_FAULT_HISTORY_ENTRIES 32\n#define FAULT_DATA_SIZE 8\n\ntypedef struct {\n    uint32_t fault_code;\n    uint32_t timestamp;\n    uint8_t  data[FAULT_DATA_SIZE];\n    uint8_t  status_flags; \n} FaultHistoryEntry;\n\nstatic FaultHistoryEntry g_fault_history[MAX_FAULT_HISTORY_ENTRIES];\nstatic uint16_t g_current_history_idx = 0; \nstatic uint16_t g_num_active_faults = 0; \n\nvoid init_fault_history() {\n    memset(g_fault_history, 0, sizeof(g_fault_history));\n    g_current_history_idx = 0;\n    g_num_active_faults = 0;\n}\n\nvoid log_fault_event(uint32_t code, uint32_t timestamp, const uint8_t* data) {\n    if (g_num_active_faults < MAX_FAULT_HISTORY_ENTRIES) {\n        g_num_active_faults++;\n    }\n\n    FaultHistoryEntry* entry = &g_fault_history[g_current_history_idx];\n    entry->fault_code = code;\n    entry->timestamp = timestamp;\n    memcpy(entry->data, data, FAULT_DATA_SIZE);\n    entry->status_flags = 0x01; \n\n    g_current_history_idx = (g_current_history_idx + 1) % MAX_FAULT_HISTORY_ENTRIES;\n}\n\nvoid reactivate_cleared_faults_vulnerable(uint16_t num_to_reactivate) {\n    if (num_to_reactivate == 0 || g_num_active_faults == 0) {\n        return;\n    }\n\n    int16_t start_reactivate_idx = (g_current_history_idx == 0) ? \n                                   (MAX_FAULT_HISTORY_ENTRIES - 1) : \n                                   (g_current_history_idx - 1);\n\n    for (uint16_t i = 0; i < num_to_reactivate; ++i) {\n        uint16_t target_idx = (uint16_t)(start_reactivate_idx - i);\n        \n        g_fault_history[target_idx].status_flags = 0x01;\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stbool.h>\n#include <string.h>\n\n#define MAX_FAULT_HISTORY_ENTRIES 32\n#define FAULT_DATA_SIZE 8\n\ntypedef struct {\n    uint32_t fault_code;\n    uint32_t timestamp;\n    uint8_t  data[FAULT_DATA_SIZE];\n    uint8_t  status_flags; \n} FaultHistoryEntry;\n\nstatic FaultHistoryEntry g_fault_history_fixed[MAX_FAULT_HISTORY_ENTRIES];\nstatic uint16_t g_current_history_idx_fixed = 0; \nstatic uint16_t g_num_active_faults_fixed = 0; \n\nvoid init_fault_history_fixed() {\n    memset(g_fault_history_fixed, 0, sizeof(g_fault_history_fixed));\n    g_current_history_idx_fixed = 0;\n    g_num_active_faults_fixed = 0;\n}\n\nvoid log_fault_event_fixed(uint32_t code, uint32_t timestamp, const uint8_t* data) {\n    if (g_num_active_faults_fixed < MAX_FAULT_HISTORY_ENTRIES) {\n        g_num_active_faults_fixed++;\n    }\n\n    FaultHistoryEntry* entry = &g_fault_history_fixed[g_current_history_idx_fixed];\n    entry->fault_code = code;\n    entry->timestamp = timestamp;\n    memcpy(entry->data, data, FAULT_DATA_SIZE);\n    entry->status_flags = 0x01; \n\n    g_current_history_idx_fixed = (g_current_history_idx_fixed + 1) % MAX_FAULT_HISTORY_ENTRIES;\n}\n\nvoid reactivate_cleared_faults_fixed(uint16_t num_to_reactivate) {\n    if (num_to_reactivate == 0 || g_num_active_faults_fixed == 0) {\n        return;\n    }\n\n    uint16_t effective_to_reactivate = (num_to_reactivate > g_num_active_faults_fixed) ? g_num_active_faults_fixed : num_to_reactivate;\n\n    int16_t start_reactivate_idx = (g_current_history_idx_fixed == 0) ? \n                                   (MAX_FAULT_HISTORY_ENTRIES - 1) : \n                                   (g_current_history_idx_fixed - 1);\n\n    for (uint16_t i = 0; i < effective_to_reactivate; ++i) {\n        int32_t conceptual_idx = start_reactivate_idx - i;\n        uint16_t target_idx = (uint16_t)(((conceptual_idx % MAX_FAULT_HISTORY_ENTRIES) + MAX_FAULT_HISTORY_ENTRIES) % MAX_FAULT_HISTORY_ENTRIES);\n        \n        g_fault_history_fixed[target_idx].status_flags = 0x01;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define COMMAND_QUEUE_SIZE 10\n\ntypedef enum {\n    CMD_NONE = 0,\n    CMD_LOCK_DOOR,\n    CMD_UNLOCK_DOOR,\n    CMD_ADJUST_SEAT,\n    CMD_PERFORM_DIAG,\n    CMD_TOTAL\n} VehicleCommandId;\n\ntypedef struct {\n    VehicleCommandId id;\n    int16_t param1;\n    int16_t param2;\n    uint8_t flags;\n    bool processed;\n} VehicleCommand;\n\nstatic VehicleCommand g_command_queue[COMMAND_QUEUE_SIZE];\nstatic int g_command_queue_head = 0;\nstatic int g_command_queue_tail = 0;\nstatic int g_command_queue_count = 0;\n\nvoid init_command_queue_vulnerable() {\n    memset(g_command_queue, 0, sizeof(g_command_queue));\n    g_command_queue_head = 0;\n    g_command_queue_tail = 0;\n    g_command_queue_count = 0;\n}\n\nbool enqueue_command_vulnerable(VehicleCommandId id, int16_t p1, int16_t p2) {\n    if (g_command_queue_count >= COMMAND_QUEUE_SIZE) {\n        return false;\n    }\n\n    g_command_queue[g_command_queue_tail].id = id;\n    g_command_queue[g_command_queue_tail].param1 = p1;\n    g_command_queue[g_command_queue_tail].param2 = p2;\n    g_command_queue[g_command_queue_tail].flags = 0;\n    g_command_queue[g_command_queue_tail].processed = false;\n\n    g_command_queue_tail = (g_command_queue_tail + 1) % COMMAND_QUEUE_SIZE;\n    g_command_queue_count++;\n    return true;\n}\n\nbool dequeue_command_vulnerable(VehicleCommand* cmd_out) {\n    if (g_command_queue_count == 0) {\n        return false;\n    }\n\n    *cmd_out = g_command_queue[g_command_queue_head];\n    g_command_queue_head = (g_command_queue_head + 1) % COMMAND_QUEUE_SIZE;\n    g_command_queue_count--;\n    return true;\n}\n\nvoid reinsert_critical_command_vulnerable(VehicleCommand cmd) {\n    if (g_command_queue_count >= COMMAND_QUEUE_SIZE) {\n        return;\n    }\n\n    g_command_queue_head--;\n\n    g_command_queue[g_command_queue_head] = cmd;\n\n    g_command_queue_count++;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define COMMAND_QUEUE_SIZE 10\n\ntypedef enum {\n    CMD_NONE = 0,\n    CMD_LOCK_DOOR,\n    CMD_UNLOCK_DOOR,\n    CMD_ADJUST_SEAT,\n    CMD_PERFORM_DIAG,\n    CMD_TOTAL\n} VehicleCommandId;\n\ntypedef struct {\n    VehicleCommandId id;\n    int16_t param1;\n    int16_t param2;\n    uint8_t flags;\n    bool processed;\n} VehicleCommand;\n\nstatic VehicleCommand g_command_queue_fixed[COMMAND_QUEUE_SIZE];\nstatic int g_command_queue_head_fixed = 0;\nstatic int g_command_queue_tail_fixed = 0;\nstatic int g_command_queue_count_fixed = 0;\n\nvoid init_command_queue_fixed() {\n    memset(g_command_queue_fixed, 0, sizeof(g_command_queue_fixed));\n    g_command_queue_head_fixed = 0;\n    g_command_queue_tail_fixed = 0;\n    g_command_queue_count_fixed = 0;\n}\n\nbool enqueue_command_fixed(VehicleCommandId id, int16_t p1, int16_t p2) {\n    if (g_command_queue_count_fixed >= COMMAND_QUEUE_SIZE) {\n        return false;\n    }\n\n    g_command_queue_fixed[g_command_queue_tail_fixed].id = id;\n    g_command_queue_fixed[g_command_queue_tail_fixed].param1 = p1;\n    g_command_queue_fixed[g_command_queue_tail_fixed].param2 = p2;\n    g_command_queue_fixed[g_command_queue_tail_fixed].flags = 0;\n    g_command_queue_fixed[g_command_queue_tail_fixed].processed = false;\n\n    g_command_queue_tail_fixed = (g_command_queue_tail_fixed + 1) % COMMAND_QUEUE_SIZE;\n    g_command_queue_count_fixed++;\n    return true;\n}\n\nbool dequeue_command_fixed(VehicleCommand* cmd_out) {\n    if (g_command_queue_count_fixed == 0) {\n        return false;\n    }\n\n    *cmd_out = g_command_queue_fixed[g_command_queue_head_fixed];\n    g_command_queue_head_fixed = (g_command_queue_head_fixed + 1) % COMMAND_QUEUE_SIZE;\n    g_command_queue_count_fixed--;\n    return true;\n}\n\nvoid reinsert_critical_command_fixed(VehicleCommand cmd) {\n    if (g_command_queue_count_fixed >= COMMAND_QUEUE_SIZE) {\n        return;\n    }\n\n    g_command_queue_head_fixed = (g_command_queue_head_fixed - 1 + COMMAND_QUEUE_SIZE) % COMMAND_QUEUE_SIZE;\n\n    g_command_queue_fixed[g_command_queue_head_fixed] = cmd;\n\n    g_command_queue_count_fixed++;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DATA_CACHE_SIZE 256 \n#define SEGMENT_SIZE 16     \n#define METADATA_OFFSET_FROM_SEGMENT_START -4 \n\nstatic uint8_t g_vehicle_data_cache[DATA_CACHE_SIZE];\nstatic uint16_t g_num_active_segments = 0;\n\nvoid init_data_cache() {\n    memset(g_vehicle_data_cache, 0, DATA_CACHE_SIZE);\n    g_num_active_segments = 0;\n}\n\nbool add_data_segment(const uint8_t* segment_data) {\n    if ((g_num_active_segments + 1) * SEGMENT_SIZE > DATA_CACHE_SIZE) {\n        return false;\n    }\n    uint16_t write_offset = g_num_active_segments * SEGMENT_SIZE;\n    memcpy(g_vehicle_data_cache + write_offset, segment_data, SEGMENT_SIZE);\n    g_num_active_segments++;\n    return true;\n}\n\nvoid update_segment_control_byte_vulnerable(uint16_t segment_idx, uint8_t new_control_value) {\n    if (segment_idx >= g_num_active_segments) {\n        return;\n    }\n\n    uint16_t segment_start_offset = segment_idx * SEGMENT_SIZE;\n\n    int32_t control_byte_offset = (int32_t)segment_start_offset + METADATA_OFFSET_FROM_SEGMENT_START;\n\n    g_vehicle_data_cache[control_byte_offset] = new_control_value;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DATA_CACHE_SIZE 256 \n#define SEGMENT_SIZE 16     \n#define METADATA_OFFSET_FROM_SEGMENT_START -4 \n\nstatic uint8_t g_vehicle_data_cache_fixed[DATA_CACHE_SIZE];\nstatic uint16_t g_num_active_segments_fixed = 0;\n\nvoid init_data_cache_fixed() {\n    memset(g_vehicle_data_cache_fixed, 0, DATA_CACHE_SIZE);\n    g_num_active_segments_fixed = 0;\n}\n\nbool add_data_segment_fixed(const uint8_t* segment_data) {\n    if ((g_num_active_segments_fixed + 1) * SEGMENT_SIZE > DATA_CACHE_SIZE) {\n        return false;\n    }\n    uint16_t write_offset = g_num_active_segments_fixed * SEGMENT_SIZE;\n    memcpy(g_vehicle_data_cache_fixed + write_offset, segment_data, SEGMENT_SIZE);\n    g_num_active_segments_fixed++;\n    return true;\n}\n\nvoid update_segment_control_byte_fixed(uint16_t segment_idx, uint8_t new_control_value) {\n    if (segment_idx >= g_num_active_segments_fixed) {\n        return;\n    }\n\n    uint16_t segment_start_offset = segment_idx * SEGMENT_SIZE;\n\n    int32_t potential_control_byte_offset = (int32_t)segment_start_offset + METADATA_OFFSET_FROM_SEGMENT_START;\n\n    if (potential_control_byte_offset < 0 || potential_control_byte_offset >= DATA_CACHE_SIZE) {\n        return;\n    }\n\n    g_vehicle_data_cache_fixed[potential_control_byte_offset] = new_control_value;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define MAX_SENSOR_DATA_POINTS 128\n#define EVENT_DATA_SIZE 8\n\ntypedef struct {\n    uint16_t value;\n    uint16_t checksum;\n    uint8_t  event_data[EVENT_DATA_SIZE];\n} SensorDataPoint;\n\nstatic SensorDataPoint g_sensor_history[MAX_SENSOR_DATA_POINTS];\nstatic uint32_t g_num_history_points = 0;\nstatic int16_t g_current_engine_calibration = 100;\n\nvoid init_sensor_history_vulnerable() {\n    memset(g_sensor_history, 0, sizeof(g_sensor_history));\n    g_num_history_points = 0;\n    g_current_engine_calibration = 100;\n}\n\nvoid add_sensor_reading_vulnerable(uint16_t value, uint16_t checksum, const uint8_t* event_data) {\n    if (g_num_history_points < MAX_SENSOR_DATA_POINTS) {\n        g_sensor_history[g_num_history_points].value = value;\n        g_sensor_history[g_num_history_points].checksum = checksum;\n        memcpy(g_sensor_history[g_num_history_points].event_data, event_data, EVENT_DATA_SIZE);\n        g_num_history_points++;\n    } else {\n        for (uint32_t i = 0; i < MAX_SENSOR_DATA_POINTS - 1; ++i) {\n            g_sensor_history[i] = g_sensor_history[i+1];\n        }\n        g_sensor_history[MAX_SENSOR_DATA_POINTS - 1].value = value;\n        g_sensor_history[MAX_SENSOR_DATA_POINTS - 1].checksum = checksum;\n        memcpy(g_sensor_history[MAX_SENSOR_DATA_POINTS - 1].event_data, event_data, EVENT_DATA_SIZE);\n    }\n}\n\nvoid perform_data_analysis_vulnerable(SensorDataPoint* data_point) {\n    if (data_point != NULL) {\n        if (data_point->value > 500 && data_point->checksum == (uint16_t)(data_point->value ^ 0xFFFF)) {\n            g_current_engine_calibration += 5;\n        } else {\n            g_current_engine_calibration -= 1;\n        }\n    }\n}\n\nvoid calibrate_historical_readings_vulnerable(int32_t offset_from_current, uint32_t num_to_adjust, uint16_t new_value) {\n    if (g_num_history_points == 0 || num_to_adjust == 0) {\n        return;\n    }\n\n    int32_t start_idx = (int32_t)g_num_history_points - 1 - offset_from_current;\n\n    for (uint32_t i = 0; i < num_to_adjust; ++i) {\n        if (start_idx + i < MAX_SENSOR_DATA_POINTS) {\n            g_sensor_history[start_idx + i].value = new_value;\n            g_sensor_history[start_idx + i].checksum = (uint16_t)(new_value ^ 0xFFFF);\n        }\n    }\n\n    if (g_num_history_points > 0) {\n        perform_data_analysis_vulnerable(&g_sensor_history[g_num_history_points - 1]);\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n\n#define MAX_SENSOR_DATA_POINTS 128\n#define EVENT_DATA_SIZE 8\n\ntypedef struct {\n    uint16_t value;\n    uint16_t checksum;\n    uint8_t  event_data[EVENT_DATA_SIZE];\n} SensorDataPoint;\n\nstatic SensorDataPoint g_sensor_history[MAX_SENSOR_DATA_POINTS];\nstatic uint32_t g_num_history_points = 0;\nstatic int16_t g_current_engine_calibration = 100;\n\nvoid init_sensor_history_fixed() {\n    memset(g_sensor_history, 0, sizeof(g_sensor_history));\n    g_num_history_points = 0;\n    g_current_engine_calibration = 100;\n}\n\nvoid add_sensor_reading_fixed(uint16_t value, uint16_t checksum, const uint8_t* event_data) {\n    if (g_num_history_points < MAX_SENSOR_DATA_POINTS) {\n        g_sensor_history[g_num_history_points].value = value;\n        g_sensor_history[g_num_history_points].checksum = checksum;\n        memcpy(g_sensor_history[g_num_history_points].event_data, event_data, EVENT_DATA_SIZE);\n        g_num_history_points++;\n    } else {\n        for (uint32_t i = 0; i < MAX_SENSOR_DATA_POINTS - 1; ++i) {\n            g_sensor_history[i] = g_sensor_history[i+1];\n        }\n        g_sensor_history[MAX_SENSOR_DATA_POINTS - 1].value = value;\n        g_sensor_history[MAX_SENSOR_DATA_POINTS - 1].checksum = checksum;\n        memcpy(g_sensor_history[MAX_SENSOR_DATA_POINTS - 1].event_data, event_data, EVENT_DATA_SIZE);\n    }\n}\n\nvoid perform_data_analysis_fixed(SensorDataPoint* data_point) {\n    if (data_point != NULL) {\n        if (data_point->value > 500 && data_point->checksum == (uint16_t)(data_point->value ^ 0xFFFF)) {\n            g_current_engine_calibration += 5;\n        } else {\n            g_current_engine_calibration -= 1;\n        }\n    }\n}\n\nvoid calibrate_historical_readings_fixed(int32_t offset_from_current, uint32_t num_to_adjust, uint16_t new_value) {\n    if (g_num_history_points == 0 || num_to_adjust == 0) {\n        return;\n    }\n\n    int32_t calculated_start_idx = (int32_t)g_num_history_points - 1 - offset_from_current;\n\n    uint32_t actual_start_idx;\n    if (calculated_start_idx < 0) {\n        actual_start_idx = 0;\n    } else {\n        actual_start_idx = (uint32_t)calculated_start_idx;\n    }\n\n    uint32_t available_from_start_to_end = g_num_history_points - actual_start_idx;\n    uint32_t actual_num_to_adjust = (num_to_adjust > available_from_start_to_end) ? available_from_start_to_end : num_to_adjust;\n\n    for (uint32_t i = 0; i < actual_num_to_adjust; ++i) {\n        g_sensor_history[actual_start_idx + i].value = new_value;\n        g_sensor_history[actual_start_idx + i].checksum = (uint16_t)(new_value ^ 0xFFFF);\n    }\n\n    if (g_num_history_points > 0) {\n        perform_data_analysis_fixed(&g_sensor_history[g_num_history_points - 1]);\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n\n#define DATA_BUFFER_SIZE 128\n#define MIN_DATA_AREA_START 16 // Start of actual data after some header/metadata\n\nstatic uint8_t g_data_buffer[DATA_BUFFER_SIZE];\nstatic int16_t g_cursor_pos = MIN_DATA_AREA_START; // Current write position, initialized to start of data area\n\nvoid init_data_processor() {\n    memset(g_data_buffer, 0x00, DATA_BUFFER_SIZE);\n    // Initialize some header bytes that must not be overwritten\n    g_data_buffer[0] = 0xAA; // Magic byte\n    g_data_buffer[1] = 0x55; // Version byte\n    // ... (other header bytes up to MIN_DATA_AREA_START - 1)\n    g_cursor_pos = MIN_DATA_AREA_START;\n}\n\n// Simulates adding data to the buffer, moving the cursor forward\nvoid add_processed_data(const uint8_t* data, uint8_t len) {\n    if (g_cursor_pos + len <= DATA_BUFFER_SIZE) {\n        memcpy(&g_data_buffer[g_cursor_pos], data, len);\n        g_cursor_pos += len;\n    }\n}\n\n// Vulnerable function: Moves the cursor backward by 'steps' bytes\n// and attempts to \"invalidate\" the byte immediately preceding the new cursor position.\n// If 'steps' is large enough, 'g_cursor_pos' can become less than MIN_DATA_AREA_START,\n// causing 'temp_cursor_pos - 1' to underwrite into the header/metadata area (index < MIN_DATA_AREA_START)\n// or even before the start of the buffer (index < 0).\nvoid rollback_data_state_vulnerable(uint16_t steps) {\n    if (g_cursor_pos <= MIN_DATA_AREA_START) {\n        // No data to roll back or already at the beginning of the data area\n        return;\n    }\n\n    int16_t temp_cursor_pos = g_cursor_pos;\n\n    // Calculate the new cursor position\n    temp_cursor_pos -= steps;\n\n    // Update global cursor (potentially now negative or inside header area)\n    g_cursor_pos = temp_cursor_pos;\n\n    // Attempt to \"invalidate\" the byte immediately preceding the new cursor position.\n    // This is the vulnerable write. If temp_cursor_pos becomes 0, then temp_cursor_pos - 1 is -1,\n    // leading to a buffer underwrite. If temp_cursor_pos is positive but < MIN_DATA_AREA_START,\n    // it writes into the protected header area, which is also an underwrite relative to the data segment.\n    g_data_buffer[temp_cursor_pos - 1] = 0x00; // Invalidate previous byte\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n\n#define DATA_BUFFER_SIZE 128\n#define MIN_DATA_AREA_START 16 // Start of actual data after some header/metadata\n\nstatic uint8_t g_data_buffer[DATA_BUFFER_SIZE];\nstatic int16_t g_cursor_pos = MIN_DATA_AREA_START; // Current write position, initialized to start of data area\n\nvoid init_data_processor() {\n    memset(g_data_buffer, 0x00, DATA_BUFFER_SIZE);\n    g_data_buffer[0] = 0xAA; // Magic byte\n    g_data_buffer[1] = 0x55; // Version byte\n    g_cursor_pos = MIN_DATA_AREA_START;\n}\n\nvoid add_processed_data(const uint8_t* data, uint8_t len) {\n    if (g_cursor_pos + len <= DATA_BUFFER_SIZE) {\n        memcpy(&g_data_buffer[g_cursor_pos], data, len);\n        g_cursor_pos += len;\n    }\n}\n\n// Fixed function: Moves the cursor backward by 'steps' bytes safely.\n// It ensures that the new cursor position does not go below MIN_DATA_AREA_START\n// and prevents writing into the header/metadata area or before the buffer.\nvoid rollback_data_state_fixed(uint16_t steps) {\n    if (g_cursor_pos <= MIN_DATA_AREA_START) {\n        return; // No data to roll back or already at the beginning of the data area\n    }\n\n    int16_t proposed_new_cursor_pos = g_cursor_pos - steps;\n\n    // Clamp the new cursor position to not go below MIN_DATA_AREA_START.\n    // This ensures that the cursor always stays within or at the beginning of the intended data area.\n    int16_t actual_new_cursor_pos = (proposed_new_cursor_pos < MIN_DATA_AREA_START) ? MIN_DATA_AREA_START : proposed_new_cursor_pos;\n\n    // Update the global cursor position\n    g_cursor_pos = actual_new_cursor_pos;\n\n    // Only attempt to \"invalidate\" the byte if the new cursor position means there's\n    // a valid data byte immediately preceding it (i.e., not in the header section).\n    // The target index for the write (g_cursor_pos - 1) must be >= MIN_DATA_AREA_START.\n    if (g_cursor_pos > MIN_DATA_AREA_START) {\n        g_data_buffer[g_cursor_pos - 1] = 0x00; // Safely invalidate previous byte\n    }\n    // If g_cursor_pos is now MIN_DATA_AREA_START, it means all data has been logically\n    // rolled back, and there is no \"previous\" data byte in the data section to invalidate.\n    // The header area remains untouched.\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CAL_BUFFER_SIZE 256\n#define CAL_CHANGE_SIZE 8\n#define CAL_HEADER_SIZE 16\n\nstatic uint8_t g_calibration_data[CAL_BUFFER_SIZE];\nstatic uint16_t g_current_cal_data_end_offset = CAL_HEADER_SIZE;\n\nvoid init_calibration_module() {\n    memset(g_calibration_data, 0xFF, CAL_BUFFER_SIZE);\n    g_calibration_data[0] = 0xAA;\n    g_calibration_data[1] = 0x55;\n    g_calibration_data[CAL_HEADER_SIZE - 1] = 0x01;\n    g_current_cal_data_end_offset = CAL_HEADER_SIZE;\n}\n\nbool append_calibration_record(const uint8_t* record, uint16_t len) {\n    if (len != CAL_CHANGE_SIZE) {\n        return false;\n    }\n    if (g_current_cal_data_end_offset + len > CAL_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_calibration_data + g_current_cal_data_end_offset, record, len);\n    g_current_cal_data_end_offset += len;\n    return true;\n}\n\nvoid revert_calibration_history_vulnerable(int16_t num_steps_to_revert) {\n    int32_t new_effective_end_offset_signed = (int32_t)g_current_cal_data_end_offset - (num_steps_to_revert * CAL_CHANGE_SIZE);\n\n    g_calibration_data[new_effective_end_offset_signed - 1] = 0x00;\n\n    if (new_effective_end_offset_signed < CAL_HEADER_SIZE) {\n        g_current_cal_data_end_offset = CAL_HEADER_SIZE;\n    } else {\n        g_current_cal_data_end_offset = (uint16_t)new_effective_end_offset_signed;\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CAL_BUFFER_SIZE 256\n#define CAL_CHANGE_SIZE 8\n#define CAL_HEADER_SIZE 16\n\nstatic uint8_t g_calibration_data_fixed[CAL_BUFFER_SIZE];\nstatic uint16_t g_current_cal_data_end_offset_fixed = CAL_HEADER_SIZE;\n\nvoid init_calibration_module_fixed() {\n    memset(g_calibration_data_fixed, 0xFF, CAL_BUFFER_SIZE);\n    g_calibration_data_fixed[0] = 0xAA;\n    g_calibration_data_fixed[1] = 0x55;\n    g_calibration_data_fixed[CAL_HEADER_SIZE - 1] = 0x01;\n    g_current_cal_data_end_offset_fixed = CAL_HEADER_SIZE;\n}\n\nbool append_calibration_record_fixed(const uint8_t* record, uint16_t len) {\n    if (len != CAL_CHANGE_SIZE) {\n        return false;\n    }\n    if (g_current_cal_data_end_offset_fixed + len > CAL_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_calibration_data_fixed + g_current_cal_data_end_offset_fixed, record, len);\n    g_current_cal_data_end_offset_fixed += len;\n    return true;\n}\n\nvoid revert_calibration_history_fixed(int16_t num_steps_to_revert) {\n    int32_t new_effective_end_offset_signed = (int32_t)g_current_cal_data_end_offset_fixed - (num_steps_to_revert * CAL_CHANGE_SIZE);\n\n    int32_t marker_target_idx = new_effective_end_offset_signed - 1;\n\n    if (marker_target_idx >= (int32_t)CAL_HEADER_SIZE) {\n        g_calibration_data_fixed[marker_target_idx] = 0x00;\n    }\n\n    if (new_effective_end_offset_signed < CAL_HEADER_SIZE) {\n        g_current_cal_data_end_offset_fixed = CAL_HEADER_SIZE;\n    } else if (new_effective_end_offset_signed > CAL_BUFFER_SIZE) {\n        g_current_cal_data_end_offset_fixed = CAL_BUFFER_SIZE;\n    } else {\n        g_current_cal_data_end_offset_fixed = (uint16_t)new_effective_end_offset_signed;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_STATE_BUFFER_SIZE 256\n#define VEHICLE_STATE_CHUNK_SIZE 20\n#define VEHICLE_STATE_HEADER_SIZE 4\n\nstatic uint8_t g_vehicle_state_data_buffer[VEHICLE_STATE_BUFFER_SIZE];\nstatic uint8_t* g_next_state_write_ptr = g_vehicle_state_data_buffer;\nstatic size_t g_current_state_entries = 0;\n\nvoid init_vehicle_state_manager() {\n    memset(g_vehicle_state_data_buffer, 0, sizeof(g_vehicle_state_data_buffer));\n    g_next_state_write_ptr = g_vehicle_state_data_buffer;\n    g_current_state_entries = 0;\n}\n\nbool add_vehicle_state_entry(uint8_t status, const uint8_t* state_data) {\n    if (g_next_state_write_ptr + VEHICLE_STATE_HEADER_SIZE + VEHICLE_STATE_CHUNK_SIZE >\n        g_vehicle_state_data_buffer + VEHICLE_STATE_BUFFER_SIZE) {\n        return false;\n    }\n\n    *g_next_state_write_ptr = status;\n    *(g_next_state_write_ptr + 1) = 0xDE;\n    *(g_next_state_write_ptr + 2) = 0xAD;\n    *(g_next_state_write_ptr + 3) = 0xBE;\n\n    memcpy(g_next_state_write_ptr + VEHICLE_STATE_HEADER_SIZE, state_data, VEHICLE_STATE_CHUNK_SIZE);\n\n    g_next_state_write_ptr += (VEHICLE_STATE_HEADER_SIZE + VEHICLE_STATE_CHUNK_SIZE);\n    g_current_state_entries++;\n    return true;\n}\n\nvoid invalidate_oldest_vehicle_state_vulnerable(uint32_t entries_to_invalidate_from_end) {\n    if (g_current_state_entries == 0 || entries_to_invalidate_from_end == 0) {\n        return;\n    }\n\n    size_t entry_total_size = VEHICLE_STATE_HEADER_SIZE + VEHICLE_STATE_CHUNK_SIZE;\n\n    int32_t byte_offset_from_end = (int32_t)entries_to_invalidate_from_end * entry_total_size;\n\n    uint8_t* target_entry_header_ptr = g_next_state_write_ptr - byte_offset_from_end;\n\n    *target_entry_header_ptr = 0x00;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_STATE_BUFFER_SIZE_FIXED 256\n#define VEHICLE_STATE_CHUNK_SIZE_FIXED 20\n#define VEHICLE_STATE_HEADER_SIZE_FIXED 4\n\nstatic uint8_t g_vehicle_state_data_buffer_fixed[VEHICLE_STATE_BUFFER_SIZE_FIXED];\nstatic uint8_t* g_next_state_write_ptr_fixed = g_vehicle_state_data_buffer_fixed;\nstatic size_t g_current_state_entries_fixed = 0;\n\nvoid init_vehicle_state_manager_fixed() {\n    memset(g_vehicle_state_data_buffer_fixed, 0, sizeof(g_vehicle_state_data_buffer_fixed));\n    g_next_state_write_ptr_fixed = g_vehicle_state_data_buffer_fixed;\n    g_current_state_entries_fixed = 0;\n}\n\nbool add_vehicle_state_entry_fixed(uint8_t status, const uint8_t* state_data) {\n    if (g_next_state_write_ptr_fixed + VEHICLE_STATE_HEADER_SIZE_FIXED + VEHICLE_STATE_CHUNK_SIZE_FIXED >\n        g_vehicle_state_data_buffer_fixed + VEHICLE_STATE_BUFFER_SIZE_FIXED) {\n        return false;\n    }\n\n    *g_next_state_write_ptr_fixed = status;\n    *(g_next_state_write_ptr_fixed + 1) = 0xDE;\n    *(g_next_state_write_ptr_fixed + 2) = 0xAD;\n    *(g_next_state_write_ptr_fixed + 3) = 0xBE;\n\n    memcpy(g_next_state_write_ptr_fixed + VEHICLE_STATE_HEADER_SIZE_FIXED, state_data, VEHICLE_STATE_CHUNK_SIZE_FIXED);\n\n    g_next_state_write_ptr_fixed += (VEHICLE_STATE_HEADER_SIZE_FIXED + VEHICLE_STATE_CHUNK_SIZE_FIXED);\n    g_current_state_entries_fixed++;\n    return true;\n}\n\nvoid invalidate_oldest_vehicle_state_fixed(uint32_t entries_to_invalidate_from_end) {\n    if (g_current_state_entries_fixed == 0 || entries_to_invalidate_from_end == 0) {\n        return;\n    }\n\n    uint32_t actual_entries_to_invalidate = entries_to_invalidate_from_end;\n    if (actual_entries_to_invalidate > g_current_state_entries_fixed) {\n        actual_entries_to_invalidate = g_current_state_entries_fixed;\n    }\n\n    size_t entry_total_size = VEHICLE_STATE_HEADER_SIZE_FIXED + VEHICLE_STATE_CHUNK_SIZE_FIXED;\n\n    int32_t byte_offset_from_end = (int32_t)actual_entries_to_invalidate * entry_total_size;\n\n    uint8_t* target_entry_header_ptr = g_next_state_write_ptr_fixed - byte_offset_from_end;\n\n    if (target_entry_header_ptr >= g_vehicle_state_data_buffer_fixed) {\n        *target_entry_header_ptr = 0x00;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define TOTAL_MEMORY_POOL_SIZE 512\n#define PROFILE_DATA_SIZE 128\n#define PROFILE_METADATA_SIZE sizeof(uint8_t) \n#define PROFILE_ALLOC_SIZE (PROFILE_METADATA_SIZE + PROFILE_DATA_SIZE)\n\nstatic uint8_t g_memory_pool[TOTAL_MEMORY_POOL_SIZE];\nstatic uint8_t* g_active_profile_data_ptr = NULL;\n\nstatic const uint8_t default_profile_data[PROFILE_DATA_SIZE] = {\n    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,\n    0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,\n    0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,\n    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40,\n    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,\n    0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60,\n    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,\n    0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80\n};\n\nvoid init_profile_manager() {\n    memset(g_memory_pool, 0x00, TOTAL_MEMORY_POOL_SIZE);\n    g_active_profile_data_ptr = NULL;\n\n    int num_profiles = TOTAL_MEMORY_POOL_SIZE / PROFILE_ALLOC_SIZE;\n    for (int i = 0; i < num_profiles; ++i) {\n        uint8_t* current_profile_base = g_memory_pool + (i * PROFILE_ALLOC_SIZE);\n        *current_profile_base = 0x00;\n        memcpy(current_profile_base + PROFILE_METADATA_SIZE, default_profile_data, PROFILE_DATA_SIZE);\n    }\n\n    g_active_profile_data_ptr = g_memory_pool + PROFILE_METADATA_SIZE;\n    *(g_active_profile_data_ptr - PROFILE_METADATA_SIZE) = 0x01;\n}\n\nvoid utilize_active_profile() {\n    if (g_active_profile_data_ptr != NULL) {\n        volatile uint32_t sum = 0;\n        for (uint16_t i = 0; i < PROFILE_DATA_SIZE; ++i) {\n            sum += g_active_profile_data_ptr[i];\n        }\n        (void)sum;\n    }\n}\n\nvoid revert_active_profile_vulnerable(int16_t steps_backward) {\n    if (g_active_profile_data_ptr == NULL || steps_backward <= 0) {\n        return;\n    }\n\n    uint8_t* current_profile_base_ptr = g_active_profile_data_ptr - PROFILE_METADATA_SIZE;\n\n    uint8_t* proposed_new_profile_base_ptr = current_profile_base_ptr - (steps_backward * PROFILE_ALLOC_SIZE);\n\n    *(g_active_profile_data_ptr - PROFILE_METADATA_SIZE) = 0x00;\n\n    g_active_profile_data_ptr = proposed_new_profile_base_ptr + PROFILE_METADATA_SIZE;\n\n    *(g_active_profile_data_ptr - PROFILE_METADATA_SIZE) = 0x01;\n\n    utilize_active_profile();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define TOTAL_MEMORY_POOL_SIZE 512\n#define PROFILE_DATA_SIZE 128\n#define PROFILE_METADATA_SIZE sizeof(uint8_t) \n#define PROFILE_ALLOC_SIZE (PROFILE_METADATA_SIZE + PROFILE_DATA_SIZE)\n\nstatic uint8_t g_memory_pool_fixed[TOTAL_MEMORY_POOL_SIZE];\nstatic uint8_t* g_active_profile_data_ptr_fixed = NULL;\n\nstatic const uint8_t default_profile_data_fixed[PROFILE_DATA_SIZE] = {\n    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,\n    0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,\n    0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,\n    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40,\n    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,\n    0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60,\n    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,\n    0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80\n};\n\nvoid init_profile_manager_fixed() {\n    memset(g_memory_pool_fixed, 0x00, TOTAL_MEMORY_POOL_SIZE);\n    g_active_profile_data_ptr_fixed = NULL;\n\n    int num_profiles = TOTAL_MEMORY_POOL_SIZE / PROFILE_ALLOC_SIZE;\n    for (int i = 0; i < num_profiles; ++i) {\n        uint8_t* current_profile_base = g_memory_pool_fixed + (i * PROFILE_ALLOC_SIZE);\n        *current_profile_base = 0x00;\n        memcpy(current_profile_base + PROFILE_METADATA_SIZE, default_profile_data_fixed, PROFILE_DATA_SIZE);\n    }\n\n    g_active_profile_data_ptr_fixed = g_memory_pool_fixed + PROFILE_METADATA_SIZE;\n    *(g_active_profile_data_ptr_fixed - PROFILE_METADATA_SIZE) = 0x01;\n}\n\nvoid utilize_active_profile_fixed() {\n    if (g_active_profile_data_ptr_fixed != NULL) {\n        volatile uint32_t sum = 0;\n        for (uint16_t i = 0; i < PROFILE_DATA_SIZE; ++i) {\n            sum += g_active_profile_data_ptr_fixed[i];\n        }\n        (void)sum;\n    }\n}\n\nvoid revert_active_profile_fixed(int16_t steps_backward) {\n    if (g_active_profile_data_ptr_fixed == NULL || steps_backward <= 0) {\n        return;\n    }\n\n    uint8_t* current_profile_base_ptr = g_active_profile_data_ptr_fixed - PROFILE_METADATA_SIZE;\n\n    uint8_t* proposed_new_profile_base_ptr = current_profile_base_ptr - (steps_backward * PROFILE_ALLOC_SIZE);\n\n    if (proposed_new_profile_base_ptr < g_memory_pool_fixed) {\n        return;\n    }\n\n    if ((proposed_new_profile_base_ptr - g_memory_pool_fixed) % PROFILE_ALLOC_SIZE != 0) {\n        return;\n    }\n\n    *(g_active_profile_data_ptr_fixed - PROFILE_METADATA_SIZE) = 0x00;\n\n    g_active_profile_data_ptr_fixed = proposed_new_profile_base_ptr + PROFILE_METADATA_SIZE;\n\n    *(g_active_profile_data_ptr_fixed - PROFILE_METADATA_SIZE) = 0x01;\n\n    utilize_active_profile_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_EVENT_BUFFER_SIZE 16\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t event_id;\n    uint8_t  severity;\n    uint8_t  status;\n    uint8_t  data[4];\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diag_event_history[DIAG_EVENT_BUFFER_SIZE];\nstatic uint16_t g_write_idx = 0;\nstatic uint16_t g_num_events = 0;\n\nvoid init_diag_history() {\n    memset(g_diag_event_history, 0, sizeof(g_diag_event_history));\n    g_write_idx = 0;\n    g_num_events = 0;\n}\n\nbool add_diag_event(uint32_t timestamp, uint16_t id, uint8_t severity, uint8_t status, const uint8_t* data) {\n    if (data == NULL) {\n        return false;\n    }\n\n    g_diag_event_history[g_write_idx].timestamp_ms = timestamp;\n    g_diag_event_history[g_write_idx].event_id = id;\n    g_diag_event_history[g_write_idx].severity = severity;\n    g_diag_event_history[g_write_idx].status = status;\n    memcpy(g_diag_event_history[g_write_idx].data, data, sizeof(g_diag_event_history[g_write_idx].data));\n\n    g_write_idx = (g_write_idx + 1) % DIAG_EVENT_BUFFER_SIZE;\n    if (g_num_events < DIAG_EVENT_BUFFER_SIZE) {\n        g_num_events++;\n    }\n    return true;\n}\n\nvoid update_event_status_by_relative_offset_vulnerable(uint16_t offset_from_latest, uint8_t new_status) {\n    if (g_num_events == 0) {\n        return;\n    }\n\n    uint16_t latest_event_idx = (g_write_idx == 0) ? (DIAG_EVENT_BUFFER_SIZE - 1) : (g_write_idx - 1);\n\n    int16_t target_idx = latest_event_idx - offset_from_latest;\n\n    g_diag_event_history[target_idx].status = new_status;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_EVENT_BUFFER_SIZE 16\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t event_id;\n    uint8_t  severity;\n    uint8_t  status;\n    uint8_t  data[4];\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diag_event_history_fixed[DIAG_EVENT_BUFFER_SIZE];\nstatic uint16_t g_write_idx_fixed = 0;\nstatic uint16_t g_num_events_fixed = 0;\n\nvoid init_diag_history_fixed() {\n    memset(g_diag_event_history_fixed, 0, sizeof(g_diag_event_history_fixed));\n    g_write_idx_fixed = 0;\n    g_num_events_fixed = 0;\n}\n\nbool add_diag_event_fixed(uint32_t timestamp, uint16_t id, uint8_t severity, uint8_t status, const uint8_t* data) {\n    if (data == NULL) {\n        return false;\n    }\n\n    g_diag_event_history_fixed[g_write_idx_fixed].timestamp_ms = timestamp;\n    g_diag_event_history_fixed[g_write_idx_fixed].event_id = id;\n    g_diag_event_history_fixed[g_write_idx_fixed].severity = severity;\n    g_diag_event_history_fixed[g_write_idx_fixed].status = status;\n    memcpy(g_diag_event_history_fixed[g_write_idx_fixed].data, data, sizeof(g_diag_event_history_fixed[g_write_idx_fixed].data));\n\n    g_write_idx_fixed = (g_write_idx_fixed + 1) % DIAG_EVENT_BUFFER_SIZE;\n    if (g_num_events_fixed < DIAG_EVENT_BUFFER_SIZE) {\n        g_num_events_fixed++;\n    }\n    return true;\n}\n\nvoid update_event_status_by_relative_offset_fixed(uint16_t offset_from_latest, uint8_t new_status) {\n    if (g_num_events_fixed == 0) {\n        return;\n    }\n\n    uint16_t latest_event_idx = (g_write_idx_fixed == 0) ? (DIAG_EVENT_BUFFER_SIZE - 1) : (g_write_idx_fixed - 1);\n\n    if (offset_from_latest >= g_num_events_fixed) {\n        return;\n    }\n\n    int32_t conceptual_idx = (int32_t)latest_event_idx - offset_from_latest;\n    uint16_t target_idx = (uint16_t)((conceptual_idx % DIAG_EVENT_BUFFER_SIZE + DIAG_EVENT_BUFFER_SIZE) % DIAG_EVENT_BUFFER_SIZE);\n    \n    g_diag_event_history_fixed[target_idx].status = new_status;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define TRANSACTION_LOG_CAPACITY 16\n\ntypedef struct {\n    uint32_t transaction_id;\n    uint32_t timestamp;\n    uint8_t status_flags;\n    uint8_t data[4];\n} TransactionRecord;\n\nstatic TransactionRecord g_transaction_log[TRANSACTION_LOG_CAPACITY];\nstatic uint16_t g_current_transaction_count = 0;\nstatic uint16_t g_next_write_idx = 0;\n\nvoid init_transaction_manager() {\n    memset(g_transaction_log, 0, sizeof(g_transaction_log));\n    g_current_transaction_count = 0;\n    g_next_write_idx = 0;\n}\n\nvoid record_transaction(uint32_t id, uint32_t ts, const uint8_t* data_in) {\n    if (g_current_transaction_count < TRANSACTION_LOG_CAPACITY) {\n        g_current_transaction_count++;\n    }\n\n    TransactionRecord* entry = &g_transaction_log[g_next_write_idx];\n    entry->transaction_id = id;\n    entry->timestamp = ts;\n    entry->status_flags = 0x01;\n    memcpy(entry->data, data_in, sizeof(entry->data));\n\n    g_next_write_idx = (g_next_write_idx + 1) % TRANSACTION_LOG_CAPACITY;\n}\n\nvoid update_transaction_status_by_offset_vulnerable(uint16_t offset_from_current, uint8_t new_status_flag) {\n    if (g_current_transaction_count == 0 || offset_from_current >= g_current_transaction_count) {\n        return;\n    }\n\n    int32_t last_written_idx;\n    if (g_next_write_idx == 0) {\n        last_written_idx = TRANSACTION_LOG_CAPACITY - 1;\n    } else {\n        last_written_idx = g_next_write_idx - 1;\n    }\n\n    int32_t target_idx = last_written_idx - offset_from_current;\n\n    g_transaction_log[target_idx].status_flags = new_status_flag;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define TRANSACTION_LOG_CAPACITY 16\n\ntypedef struct {\n    uint32_t transaction_id;\n    uint32_t timestamp;\n    uint8_t status_flags;\n    uint8_t data[4];\n} TransactionRecord;\n\nstatic TransactionRecord g_transaction_log_fixed[TRANSACTION_LOG_CAPACITY];\nstatic uint16_t g_current_transaction_count_fixed = 0;\nstatic uint16_t g_next_write_idx_fixed = 0;\n\nvoid init_transaction_manager_fixed() {\n    memset(g_transaction_log_fixed, 0, sizeof(g_transaction_log_fixed));\n    g_current_transaction_count_fixed = 0;\n    g_next_write_idx_fixed = 0;\n}\n\nvoid record_transaction_fixed(uint32_t id, uint32_t ts, const uint8_t* data_in) {\n    if (g_current_transaction_count_fixed < TRANSACTION_LOG_CAPACITY) {\n        g_current_transaction_count_fixed++;\n    }\n\n    TransactionRecord* entry = &g_transaction_log_fixed[g_next_write_idx_fixed];\n    entry->transaction_id = id;\n    entry->timestamp = ts;\n    entry->status_flags = 0x01;\n    memcpy(entry->data, data_in, sizeof(entry->data));\n\n    g_next_write_idx_fixed = (g_next_write_idx_fixed + 1) % TRANSACTION_LOG_CAPACITY;\n}\n\nvoid update_transaction_status_by_offset_fixed(uint16_t offset_from_current, uint8_t new_status_flag) {\n    if (g_current_transaction_count_fixed == 0 || offset_from_current >= g_current_transaction_count_fixed) {\n        return;\n    }\n\n    int32_t last_written_idx;\n    if (g_next_write_idx_fixed == 0) {\n        last_written_idx = TRANSACTION_LOG_CAPACITY - 1;\n    } else {\n        last_written_idx = g_next_write_idx_fixed - 1;\n    }\n\n    int32_t conceptual_idx = last_written_idx - offset_from_current;\n\n    int16_t target_idx = (int16_t)(((conceptual_idx % TRANSACTION_LOG_CAPACITY) + TRANSACTION_LOG_CAPACITY) % TRANSACTION_LOG_CAPACITY);\n\n    g_transaction_log_fixed[target_idx].status_flags = new_status_flag;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_CONFIG_STATES 10\n#define CONFIG_DATA_BLOCK_SIZE 24\n#define CONFIG_VERSION_BYTE_SIZE 1\n#define CONFIG_STATE_TOTAL_SIZE (CONFIG_VERSION_BYTE_SIZE + CONFIG_DATA_BLOCK_SIZE)\n\nstatic uint8_t g_config_state_storage[MAX_CONFIG_STATES * CONFIG_STATE_TOTAL_SIZE];\nstatic int16_t g_current_active_config_idx = 0;\n\nvoid init_config_storage() {\n    memset(g_config_state_storage, 0, sizeof(g_config_state_storage));\n    g_current_active_config_idx = 0;\n    for (int i = 0; i < MAX_CONFIG_STATES; ++i) {\n        g_config_state_storage[i * CONFIG_STATE_TOTAL_SIZE] = 0x00;\n    }\n}\n\nbool store_config_state(const uint8_t* config_data, uint8_t version) {\n    if (config_data == NULL || version == 0x00) {\n        return false;\n    }\n    if (g_current_active_config_idx >= MAX_CONFIG_STATES) {\n        return false;\n    }\n\n    uint32_t write_offset = g_current_active_config_idx * CONFIG_STATE_TOTAL_SIZE;\n    g_config_state_storage[write_offset] = version;\n    memcpy(&g_config_state_storage[write_offset + CONFIG_VERSION_BYTE_SIZE], config_data, CONFIG_DATA_BLOCK_SIZE);\n\n    g_current_active_config_idx++;\n    return true;\n}\n\nvoid decrement_config_version_vulnerable(uint16_t offset_from_current) {\n    if (g_current_active_config_idx == 0 || offset_from_current == 0) {\n        return;\n    }\n\n    int32_t target_logical_idx = (g_current_active_config_idx - 1) - offset_from_current;\n\n    uint8_t current_version = g_config_state_storage[target_logical_idx * CONFIG_STATE_TOTAL_SIZE];\n    if (current_version > 0x01) {\n        g_config_state_storage[target_logical_idx * CONFIG_STATE_TOTAL_SIZE] = current_version - 1;\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_CONFIG_STATES 10\n#define CONFIG_DATA_BLOCK_SIZE 24\n#define CONFIG_VERSION_BYTE_SIZE 1\n#define CONFIG_STATE_TOTAL_SIZE (CONFIG_VERSION_BYTE_SIZE + CONFIG_DATA_BLOCK_SIZE)\n\nstatic uint8_t g_config_state_storage_fixed[MAX_CONFIG_STATES * CONFIG_STATE_TOTAL_SIZE];\nstatic int16_t g_current_active_config_idx_fixed = 0;\n\nvoid init_config_storage_fixed() {\n    memset(g_config_state_storage_fixed, 0, sizeof(g_config_state_storage_fixed));\n    g_current_active_config_idx_fixed = 0;\n    for (int i = 0; i < MAX_CONFIG_STATES; ++i) {\n        g_config_state_storage_fixed[i * CONFIG_STATE_TOTAL_SIZE] = 0x00;\n    }\n}\n\nbool store_config_state_fixed(const uint8_t* config_data, uint8_t version) {\n    if (config_data == NULL || version == 0x00) {\n        return false;\n    }\n    if (g_current_active_config_idx_fixed >= MAX_CONFIG_STATES) {\n        return false;\n    }\n\n    uint32_t write_offset = g_current_active_config_idx_fixed * CONFIG_STATE_TOTAL_SIZE;\n    g_config_state_storage_fixed[write_offset] = version;\n    memcpy(&g_config_state_storage_fixed[write_offset + CONFIG_VERSION_BYTE_SIZE], config_data, CONFIG_DATA_BLOCK_SIZE);\n\n    g_current_active_config_idx_fixed++;\n    return true;\n}\n\nvoid decrement_config_version_fixed(uint16_t offset_from_current) {\n    if (g_current_active_config_idx_fixed == 0 || offset_from_current == 0) {\n        return;\n    }\n\n    int32_t target_logical_idx = (g_current_active_config_idx_fixed - 1) - offset_from_current;\n\n    if (target_logical_idx < 0 || target_logical_idx >= MAX_CONFIG_STATES) {\n        return;\n    }\n\n    uint8_t current_version = g_config_state_storage_fixed[target_logical_idx * CONFIG_STATE_TOTAL_SIZE];\n    if (current_version > 0x01) {\n        g_config_state_storage_fixed[target_logical_idx * CONFIG_STATE_TOTAL_SIZE] = current_version - 1;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define EVENT_LOG_SIZE 256 \n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t event_type_id;\n    uint16_t metadata_flags;\n} VehicleEventEntry;\n\nstatic VehicleEventEntry g_event_log[EVENT_LOG_SIZE];\nstatic uint32_t g_current_log_head = 0; \nstatic bool g_log_wrapped = false; \n\nvoid init_event_logger_vulnerable() {\n    memset(g_event_log, 0, sizeof(g_event_log));\n    g_current_log_head = 0;\n    g_log_wrapped = false;\n}\n\nvoid log_vehicle_event_vulnerable(uint16_t type_id, uint32_t current_timestamp) {\n    g_event_log[g_current_log_head].timestamp_ms = current_timestamp;\n    g_event_log[g_current_log_head].event_type_id = type_id;\n    g_event_log[g_current_log_head].metadata_flags = 0; \n\n    g_current_log_head++;\n    if (g_current_log_head >= EVENT_LOG_SIZE) {\n        g_current_log_head = 0;\n        g_log_wrapped = true;\n    }\n}\n\nvoid mark_historical_event_vulnerable(uint32_t offset_from_head, uint16_t marker_flag) {\n    if (offset_from_head >= EVENT_LOG_SIZE && !g_log_wrapped) {\n        return; \n    }\n\n    int32_t target_logical_idx = (int32_t)g_current_log_head - 1 - (int32_t)offset_from_head;\n\n    g_event_log[target_logical_idx].metadata_flags |= marker_flag;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define EVENT_LOG_SIZE 256 \n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t event_type_id;\n    uint16_t metadata_flags;\n} VehicleEventEntry;\n\nstatic VehicleEventEntry g_event_log_fixed[EVENT_LOG_SIZE];\nstatic uint32_t g_current_log_head_fixed = 0; \nstatic bool g_log_wrapped_fixed = false; \n\nvoid init_event_logger_fixed() {\n    memset(g_event_log_fixed, 0, sizeof(g_event_log_fixed));\n    g_current_log_head_fixed = 0;\n    g_log_wrapped_fixed = false;\n}\n\nvoid log_vehicle_event_fixed(uint16_t type_id, uint32_t current_timestamp) {\n    g_event_log_fixed[g_current_log_head_fixed].timestamp_ms = current_timestamp;\n    g_event_log_fixed[g_current_log_head_fixed].event_type_id = type_id;\n    g_event_log_fixed[g_current_log_head_fixed].metadata_flags = 0; \n\n    g_current_log_head_fixed++;\n    if (g_current_log_head_fixed >= EVENT_LOG_SIZE) {\n        g_current_log_head_fixed = 0;\n        g_log_wrapped_fixed = true;\n    }\n}\n\nvoid mark_historical_event_fixed(uint32_t offset_from_head, uint16_t marker_flag) {\n    uint32_t last_written_idx;\n    if (g_current_log_head_fixed == 0) {\n        if (g_log_wrapped_fixed) {\n            last_written_idx = EVENT_LOG_SIZE - 1;\n        } else {\n            return; \n        }\n    } else {\n        last_written_idx = g_current_log_head_fixed - 1;\n    }\n\n    uint32_t available_history_count;\n    if (g_log_wrapped_fixed) {\n        available_history_count = EVENT_LOG_SIZE; \n    } else {\n        available_history_count = g_current_log_head_fixed; \n    }\n\n    if (offset_from_head >= available_history_count) {\n        return; \n    }\n\n    uint32_t safe_target_idx = (last_written_idx + EVENT_LOG_SIZE - offset_from_head) % EVENT_LOG_SIZE;\n\n    g_event_log_fixed[safe_target_idx].metadata_flags |= marker_flag;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define VEHICLE_COM_BUFFER_SIZE 256\n#define VEHICLE_COM_HEADER_LEN 5\n\ntypedef struct {\n    uint8_t start_marker;\n    uint8_t protocol_version;\n    uint8_t message_type;\n    uint8_t payload_length;\n    uint8_t checksum;\n    uint8_t payload_data[VEHICLE_COM_BUFFER_SIZE - VEHICLE_COM_HEADER_LEN];\n} VehicleComFrame;\n\nstatic uint8_t g_com_buffer[VEHICLE_COM_BUFFER_SIZE];\nstatic uint16_t g_current_frame_ptr_offset = 0;\nstatic uint16_t g_buffered_data_len = 0;\n\nvoid init_com_buffer() {\n    memset(g_com_buffer, 0, VEHICLE_COM_BUFFER_SIZE);\n    g_current_frame_ptr_offset = 0;\n    g_buffered_data_len = 0;\n}\n\nbool receive_com_data(const uint8_t* data, uint16_t len) {\n    if (len == 0 || data == NULL || (g_buffered_data_len + len > VEHICLE_COM_BUFFER_SIZE)) {\n        return false;\n    }\n    memcpy(g_com_buffer + g_buffered_data_len, data, len);\n    g_buffered_data_len += len;\n    return true;\n}\n\nbool set_current_frame_offset(uint16_t offset) {\n    if (offset < g_buffered_data_len && offset + VEHICLE_COM_HEADER_LEN <= g_buffered_data_len) {\n        g_current_frame_ptr_offset = offset;\n        return true;\n    }\n    return false;\n}\n\nvoid update_frame_control_field_vulnerable(uint16_t relative_to_frame_start_offset, int16_t internal_adjustment, uint8_t new_value) {\n    int32_t effective_target_idx = (int32_t)g_current_frame_ptr_offset +\n                                   (int32_t)relative_to_frame_start_offset +\n                                   (int32_t)internal_adjustment;\n\n    g_com_buffer[effective_target_idx] = new_value;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define VEHICLE_COM_BUFFER_SIZE_FIXED 256\n#define VEHICLE_COM_HEADER_LEN_FIXED 5\n\ntypedef struct {\n    uint8_t start_marker;\n    uint8_t protocol_version;\n    uint8_t message_type;\n    uint8_t payload_length;\n    uint8_t checksum;\n    uint8_t payload_data[VEHICLE_COM_BUFFER_SIZE_FIXED - VEHICLE_COM_HEADER_LEN_FIXED];\n} VehicleComFrame_Fixed;\n\nstatic uint8_t g_com_buffer_fixed[VEHICLE_COM_BUFFER_SIZE_FIXED];\nstatic uint16_t g_current_frame_ptr_offset_fixed = 0;\nstatic uint16_t g_buffered_data_len_fixed = 0;\n\nvoid init_com_buffer_fixed() {\n    memset(g_com_buffer_fixed, 0, VEHICLE_COM_BUFFER_SIZE_FIXED);\n    g_current_frame_ptr_offset_fixed = 0;\n    g_buffered_data_len_fixed = 0;\n}\n\nbool receive_com_data_fixed(const uint8_t* data, uint16_t len) {\n    if (len == 0 || data == NULL || (g_buffered_data_len_fixed + len > VEHICLE_COM_BUFFER_SIZE_FIXED)) {\n        return false;\n    }\n    memcpy(g_com_buffer_fixed + g_buffered_data_len_fixed, data, len);\n    g_buffered_data_len_fixed += len;\n    return true;\n}\n\nbool set_current_frame_offset_fixed(uint16_t offset) {\n    if (offset < g_buffered_data_len_fixed && offset + VEHICLE_COM_HEADER_LEN_FIXED <= g_buffered_data_len_fixed) {\n        g_current_frame_ptr_offset_fixed = offset;\n        return true;\n    }\n    return false;\n}\n\nvoid update_frame_control_field_fixed(uint16_t relative_to_frame_start_offset, int16_t internal_adjustment, uint8_t new_value) {\n    int32_t effective_target_idx = (int32_t)g_current_frame_ptr_offset_fixed +\n                                   (int32_t)relative_to_frame_start_offset +\n                                   (int32_t)internal_adjustment;\n\n    if (effective_target_idx < 0 || effective_target_idx >= VEHICLE_COM_BUFFER_SIZE_FIXED) {\n        return;\n    }\n\n    g_com_buffer_fixed[effective_target_idx] = new_value;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define FAULT_HISTORY_SIZE 10\n#define FAULT_CODE_MAX_LEN 8\n\ntypedef struct {\n    uint32_t timestamp;\n    char code[FAULT_CODE_MAX_LEN];\n    uint8_t severity;\n    bool active;\n} FaultEntry;\n\nstatic FaultEntry g_fault_history[FAULT_HISTORY_SIZE];\nstatic uint16_t g_next_write_idx = 0;\nstatic uint16_t g_num_logged_faults = 0;\n\nvoid init_fault_history_vulnerable() {\n    memset(g_fault_history, 0, sizeof(g_fault_history));\n    g_next_write_idx = 0;\n    g_num_logged_faults = 0;\n}\n\nvoid add_fault_entry_vulnerable(uint32_t timestamp, const char* code, uint8_t severity) {\n    if (g_num_logged_faults < FAULT_HISTORY_SIZE) {\n        g_num_logged_faults++;\n    }\n    \n    FaultEntry* entry = &g_fault_history[g_next_write_idx];\n    entry->timestamp = timestamp;\n    strncpy(entry->code, code, FAULT_CODE_MAX_LEN - 1);\n    entry->code[FAULT_CODE_MAX_LEN - 1] = '\\0';\n    entry->severity = severity;\n    entry->active = true;\n\n    g_next_write_idx = (g_next_write_idx + 1) % FAULT_HISTORY_SIZE;\n}\n\nvoid clear_recent_faults_vulnerable(uint16_t num_to_clear) {\n    if (g_num_logged_faults == 0 || num_to_clear == 0) {\n        return;\n    }\n\n    uint16_t actual_clear_count = (num_to_clear > g_num_logged_faults) ? g_num_logged_faults : num_to_clear;\n\n    int32_t last_fault_idx_phys = (g_next_write_idx == 0) ? (FAULT_HISTORY_SIZE - 1) : (g_next_write_idx - 1);\n\n    for (uint16_t i = 0; i < actual_clear_count; ++i) {\n        int32_t target_phys_idx = last_fault_idx_phys - i;\n        \n        g_fault_history[target_phys_idx].active = false;\n        g_fault_history[target_phys_idx].severity = 0;\n    }\n    \n    g_num_logged_faults -= actual_clear_count;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define FAULT_HISTORY_SIZE 10\n#define FAULT_CODE_MAX_LEN 8\n\ntypedef struct {\n    uint32_t timestamp;\n    char code[FAULT_CODE_MAX_LEN];\n    uint8_t severity;\n    bool active;\n} FaultEntry;\n\nstatic FaultEntry g_fault_history_fixed[FAULT_HISTORY_SIZE];\nstatic uint16_t g_next_write_idx_fixed = 0;\nstatic uint16_t g_num_logged_faults_fixed = 0;\n\nvoid init_fault_history_fixed() {\n    memset(g_fault_history_fixed, 0, sizeof(g_fault_history_fixed));\n    g_next_write_idx_fixed = 0;\n    g_num_logged_faults_fixed = 0;\n}\n\nvoid add_fault_entry_fixed(uint32_t timestamp, const char* code, uint8_t severity) {\n    if (g_num_logged_faults_fixed < FAULT_HISTORY_SIZE) {\n        g_num_logged_faults_fixed++;\n    }\n    \n    FaultEntry* entry = &g_fault_history_fixed[g_next_write_idx_fixed];\n    entry->timestamp = timestamp;\n    strncpy(entry->code, code, FAULT_CODE_MAX_LEN - 1);\n    entry->code[FAULT_CODE_MAX_LEN - 1] = '\\0';\n    entry->severity = severity;\n    entry->active = true;\n\n    g_next_write_idx_fixed = (g_next_write_idx_fixed + 1) % FAULT_HISTORY_SIZE;\n}\n\nvoid clear_recent_faults_fixed(uint16_t num_to_clear) {\n    if (g_num_logged_faults_fixed == 0 || num_to_clear == 0) {\n        return;\n    }\n\n    uint16_t actual_clear_count = (num_to_clear > g_num_logged_faults_fixed) ? g_num_logged_faults_fixed : num_to_clear;\n\n    uint16_t last_fault_idx_phys;\n    if (g_next_write_idx_fixed == 0) {\n        last_fault_idx_phys = FAULT_HISTORY_SIZE - 1;\n    } else {\n        last_fault_idx_phys = g_next_write_idx_fixed - 1;\n    }\n\n    for (uint16_t i = 0; i < actual_clear_count; ++i) {\n        uint16_t target_phys_idx = (last_fault_idx_phys - i + FAULT_HISTORY_SIZE) % FAULT_HISTORY_SIZE;\n        \n        g_fault_history_fixed[target_phys_idx].active = false;\n        g_fault_history_fixed[target_phys_idx].severity = 0;\n    }\n    \n    g_num_logged_faults_fixed -= actual_clear_count;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_CALIBRATION_TABLE_SIZE 256\n\nstatic uint16_t g_vehicle_calibration_table[VEHICLE_CALIBRATION_TABLE_SIZE];\nstatic uint16_t g_current_base_cal_idx = 0;\n\nvoid init_vehicle_calibration_system() {\n    for (uint16_t i = 0; i < VEHICLE_CALIBRATION_TABLE_SIZE; ++i) {\n        g_vehicle_calibration_table[i] = i * 2;\n    }\n    g_current_base_cal_idx = 0;\n}\n\nbool set_base_calibration_index(uint16_t base_idx) {\n    if (base_idx < VEHICLE_CALIBRATION_TABLE_SIZE) {\n        g_current_base_cal_idx = base_idx;\n        return true;\n    }\n    return false;\n}\n\nvoid apply_relative_calibration_adjustment_vulnerable(int16_t fine_tune_offset, uint16_t adjustment_value) {\n    int32_t target_index = (int32_t)g_current_base_cal_idx + fine_tune_offset;\n\n    g_vehicle_calibration_table[target_index] = adjustment_value;\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_CALIBRATION_TABLE_SIZE_FIXED 256\n\nstatic uint16_t g_vehicle_calibration_table_fixed[VEHICLE_CALIBRATION_TABLE_SIZE_FIXED];\nstatic uint16_t g_current_base_cal_idx_fixed = 0;\n\nvoid init_vehicle_calibration_system_fixed() {\n    for (uint16_t i = 0; i < VEHICLE_CALIBRATION_TABLE_SIZE_FIXED; ++i) {\n        g_vehicle_calibration_table_fixed[i] = i * 2;\n    }\n    g_current_base_cal_idx_fixed = 0;\n}\n\nbool set_base_calibration_index_fixed(uint16_t base_idx) {\n    if (base_idx < VEHICLE_CALIBRATION_TABLE_SIZE_FIXED) {\n        g_current_base_cal_idx_fixed = base_idx;\n        return true;\n    }\n    return false;\n}\n\nvoid apply_relative_calibration_adjustment_fixed(int16_t fine_tune_offset, uint16_t adjustment_value) {\n    int32_t target_index = (int32_t)g_current_base_cal_idx_fixed + fine_tune_offset;\n\n    if (target_index >= 0 && target_index < VEHICLE_CALIBRATION_TABLE_SIZE_FIXED) {\n        g_vehicle_calibration_table_fixed[target_index] = adjustment_value;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_DATA_BUF_SIZE 32\n#define MAX_COMMAND_LEN 16\n\nstatic uint8_t g_diag_data_buffer[DIAG_DATA_BUF_SIZE];\nstatic uint8_t g_current_diag_data_len = 0;\n\nvoid diag_init_buffer() {\n    memset(g_diag_data_buffer, 0, DIAG_DATA_BUF_SIZE);\n    g_current_diag_data_len = 0;\n}\n\nbool diag_load_data(const uint8_t* data, uint8_t len) {\n    if (len > DIAG_DATA_BUF_SIZE) {\n        return false;\n    }\n    memcpy(g_diag_data_buffer, data, len);\n    g_current_diag_data_len = len;\n    return true;\n}\n\nvoid process_diagnostic_command_vulnerable(uint8_t command_id, int16_t arg1, uint8_t arg2_value) {\n    if (command_id == 0x05) { \n        int32_t target_index = (int32_t)g_current_diag_data_len - arg1;\n\n        g_diag_data_buffer[target_index] = arg2_value;\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define DIAG_DATA_BUF_SIZE_FIXED 32\n#define MAX_COMMAND_LEN_FIXED 16\n\nstatic uint8_t g_diag_data_buffer_fixed[DIAG_DATA_BUF_SIZE_FIXED];\nstatic uint8_t g_current_diag_data_len_fixed = 0;\n\nvoid diag_init_buffer_fixed() {\n    memset(g_diag_data_buffer_fixed, 0, DIAG_DATA_BUF_SIZE_FIXED);\n    g_current_diag_data_len_fixed = 0;\n}\n\nbool diag_load_data_fixed(const uint8_t* data, uint8_t len) {\n    if (len > DIAG_DATA_BUF_SIZE_FIXED) {\n        return false;\n    }\n    memcpy(g_diag_data_buffer_fixed, data, len);\n    g_current_diag_data_len_fixed = len;\n    return true;\n}\n\nvoid process_diagnostic_command_fixed(uint8_t command_id, int16_t arg1, uint8_t arg2_value) {\n    if (command_id == 0x05) { \n        int32_t target_index = (int32_t)g_current_diag_data_len_fixed - arg1;\n\n        if (target_index >= 0 && target_index < DIAG_DATA_BUF_SIZE_FIXED) {\n            g_diag_data_buffer_fixed[target_index] = arg2_value;\n        }\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#define DIAG_EVENT_BUFFER_CAPACITY 64\n\ntypedef struct {\n    uint32_t event_timestamp;\n    uint16_t event_type;\n    int16_t event_value;\n    uint8_t event_status;\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diag_event_buffer[DIAG_EVENT_BUFFER_CAPACITY];\nstatic uint16_t g_event_write_ptr = 0;\nstatic uint16_t g_num_stored_events = 0;\n\nvoid init_diag_event_buffer_vulnerable() {\n    memset(g_diag_event_buffer, 0, sizeof(g_diag_event_buffer));\n    g_event_write_ptr = 0;\n    g_num_stored_events = 0;\n}\n\nbool add_diagnostic_event_vulnerable(uint32_t timestamp, uint16_t type, int16_t value) {\n    if (g_num_stored_events >= DIAG_EVENT_BUFFER_CAPACITY) {\n        return false;\n    }\n    g_diag_event_buffer[g_event_write_ptr].event_timestamp = timestamp;\n    g_diag_event_buffer[g_event_write_ptr].event_type = type;\n    g_diag_event_buffer[g_event_write_ptr].event_value = value;\n    g_diag_event_buffer[g_event_write_ptr].event_status = 0;\n    g_event_write_ptr = (g_event_write_ptr + 1) % DIAG_EVENT_BUFFER_CAPACITY;\n    g_num_stored_events++;\n    return true;\n}\n\nDiagnosticEvent* get_event_by_direct_index_vulnerable(uint16_t index) {\n    if (index >= DIAG_EVENT_BUFFER_CAPACITY || index >= g_num_stored_events) {\n        return NULL;\n    }\n    return &g_diag_event_buffer[index];\n}\n\nvoid update_event_status_by_relative_pointer_vulnerable(DiagnosticEvent* current_event_ptr, int16_t relative_steps_back, uint8_t new_status) {\n    if (current_event_ptr == NULL) {\n        return;\n    }\n\n    DiagnosticEvent* target_event_ptr = current_event_ptr - relative_steps_back;\n\n    target_event_ptr->event_status = new_status;\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#define DIAG_EVENT_BUFFER_CAPACITY_FIXED 64\n\ntypedef struct {\n    uint32_t event_timestamp;\n    uint16_t event_type;\n    int16_t event_value;\n    uint8_t event_status;\n} DiagnosticEvent_Fixed;\n\nstatic DiagnosticEvent_Fixed g_diag_event_buffer_fixed[DIAG_EVENT_BUFFER_CAPACITY_FIXED];\nstatic uint16_t g_event_write_ptr_fixed = 0;\nstatic uint16_t g_num_stored_events_fixed = 0;\n\nvoid init_diag_event_buffer_fixed() {\n    memset(g_diag_event_buffer_fixed, 0, sizeof(g_diag_event_buffer_fixed));\n    g_event_write_ptr_fixed = 0;\n    g_num_stored_events_fixed = 0;\n}\n\nbool add_diagnostic_event_fixed(uint32_t timestamp, uint16_t type, int16_t value) {\n    if (g_num_stored_events_fixed >= DIAG_EVENT_BUFFER_CAPACITY_FIXED) {\n        return false;\n    }\n    g_diag_event_buffer_fixed[g_event_write_ptr_fixed].event_timestamp = timestamp;\n    g_diag_event_buffer_fixed[g_event_write_ptr_fixed].event_type = type;\n    g_diag_event_buffer_fixed[g_event_write_ptr_fixed].event_value = value;\n    g_diag_event_buffer_fixed[g_event_write_ptr_fixed].event_status = 0;\n    g_event_write_ptr_fixed = (g_event_write_ptr_fixed + 1) % DIAG_EVENT_BUFFER_CAPACITY_FIXED;\n    g_num_stored_events_fixed++;\n    return true;\n}\n\nDiagnosticEvent_Fixed* get_event_by_direct_index_fixed(uint16_t index) {\n    if (index >= DIAG_EVENT_BUFFER_CAPACITY_FIXED || index >= g_num_stored_events_fixed) {\n        return NULL;\n    }\n    return &g_diag_event_buffer_fixed[index];\n}\n\nvoid update_event_status_by_relative_pointer_fixed(DiagnosticEvent_Fixed* current_event_ptr, int16_t relative_steps_back, uint8_t new_status) {\n    if (current_event_ptr == NULL) {\n        return;\n    }\n\n    ptrdiff_t current_idx = current_event_ptr - g_diag_event_buffer_fixed;\n\n    ptrdiff_t target_idx = current_idx - relative_steps_back;\n\n    if (target_idx < 0 || target_idx >= DIAG_EVENT_BUFFER_CAPACITY_FIXED) {\n        return;\n    }\n\n    g_diag_event_buffer_fixed[target_idx].event_status = new_status;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 512\n#define CONFIG_BLOCK_HEADER_SIZE 8\n#define MAX_CONFIG_PAYLOAD (VEHICLE_CONFIG_BUFFER_SIZE - CONFIG_BLOCK_HEADER_SIZE)\n\n#define GLOBAL_METADATA_OFFSET 16\n\nstatic uint8_t g_vehicle_config_buffer[VEHICLE_CONFIG_BUFFER_SIZE];\nstatic uint8_t* g_config_data_start_ptr;\nstatic uint16_t g_current_config_data_len = 0;\n\nvoid init_vehicle_config_manager() {\n    memset(g_vehicle_config_buffer, 0, VEHICLE_CONFIG_BUFFER_SIZE);\n    g_config_data_start_ptr = g_vehicle_config_buffer + GLOBAL_METADATA_OFFSET;\n    g_current_config_data_len = 0;\n\n    g_vehicle_config_buffer[0] = 0x01;\n    g_vehicle_config_buffer[1] = 0xAF;\n}\n\nint16_t add_config_block(uint16_t block_id, uint16_t version, const uint8_t* payload, uint32_t payload_len) {\n    if (payload == NULL || payload_len == 0 || payload_len > MAX_CONFIG_PAYLOAD) {\n        return -1;\n    }\n\n    uint32_t block_total_size = CONFIG_BLOCK_HEADER_SIZE + payload_len;\n    if (g_current_config_data_len + block_total_size > (VEHICLE_CONFIG_BUFFER_SIZE - GLOBAL_METADATA_OFFSET)) {\n        return -1;\n    }\n\n    uint16_t block_start_relative_offset = g_current_config_data_len;\n    uint8_t* current_write_ptr = g_config_data_start_ptr + block_start_relative_offset;\n\n    *(uint16_t*)current_write_ptr = block_id;\n    *(uint16_t*)(current_write_ptr + 2) = version;\n    *(uint32_t*)(current_write_ptr + 4) = payload_len;\n\n    memcpy(current_write_ptr + CONFIG_BLOCK_HEADER_SIZE, payload, payload_len);\n\n    g_current_config_data_len += block_total_size;\n    return block_start_relative_offset;\n}\n\nvoid update_global_metadata_vulnerable(uint16_t config_block_offset, int32_t meta_target_offset, uint8_t value) {\n    uint8_t* target_address = g_config_data_start_ptr + meta_target_offset;\n\n    *target_address = value;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stbool.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE_FIXED 512\n#define CONFIG_BLOCK_HEADER_SIZE_FIXED 8\n#define MAX_CONFIG_PAYLOAD_FIXED (VEHICLE_CONFIG_BUFFER_SIZE_FIXED - CONFIG_BLOCK_HEADER_SIZE_FIXED)\n\n#define GLOBAL_METADATA_OFFSET_FIXED 16\n\nstatic uint8_t g_vehicle_config_buffer_fixed[VEHICLE_CONFIG_BUFFER_SIZE_FIXED];\nstatic uint8_t* g_config_data_start_ptr_fixed;\nstatic uint16_t g_current_config_data_len_fixed = 0;\n\nvoid init_vehicle_config_manager_fixed() {\n    memset(g_vehicle_config_buffer_fixed, 0, VEHICLE_CONFIG_BUFFER_SIZE_FIXED);\n    g_config_data_start_ptr_fixed = g_vehicle_config_buffer_fixed + GLOBAL_METADATA_OFFSET_FIXED;\n    g_current_config_data_len_fixed = 0;\n\n    g_vehicle_config_buffer_fixed[0] = 0x01;\n    g_vehicle_config_buffer_fixed[1] = 0xAF;\n}\n\nint16_t add_config_block_fixed(uint16_t block_id, uint16_t version, const uint8_t* payload, uint32_t payload_len) {\n    if (payload == NULL || payload_len == 0 || payload_len > MAX_CONFIG_PAYLOAD_FIXED) {\n        return -1;\n    }\n\n    uint32_t block_total_size = CONFIG_BLOCK_HEADER_SIZE_FIXED + payload_len;\n    if (g_current_config_data_len_fixed + block_total_size > (VEHICLE_CONFIG_BUFFER_SIZE_FIXED - GLOBAL_METADATA_OFFSET_FIXED)) {\n        return -1;\n    }\n\n    uint16_t block_start_relative_offset = g_current_config_data_len_fixed;\n    uint8_t* current_write_ptr = g_config_data_start_ptr_fixed + block_start_relative_offset;\n\n    *(uint16_t*)current_write_ptr = block_id;\n    *(uint16_t*)(current_write_ptr + 2) = version;\n    *(uint32_t*)(current_write_ptr + 4) = payload_len;\n\n    memcpy(current_write_ptr + CONFIG_BLOCK_HEADER_SIZE_FIXED, payload, payload_len);\n\n    g_current_config_data_len_fixed += block_total_size;\n    return block_start_relative_offset;\n}\n\nvoid update_global_metadata_fixed(uint16_t config_block_offset, int32_t meta_target_offset, uint8_t value) {\n    uint8_t* potential_target_address = g_config_data_start_ptr_fixed + meta_target_offset;\n\n    if (potential_target_address < g_vehicle_config_buffer_fixed ||\n        potential_target_address >= (g_vehicle_config_buffer_fixed + VEHICLE_CONFIG_BUFFER_SIZE_FIXED)) {\n        return;\n    }\n\n    if (potential_target_address >= g_config_data_start_ptr_fixed) {\n        return;\n    }\n\n    *potential_target_address = value;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_CONFIG_ENTRIES 16\n#define CONFIG_VALUE_SIZE 4\n\ntypedef struct {\n    uint16_t param_id;\n    uint8_t  config_data[CONFIG_VALUE_SIZE];\n    uint8_t  status_flags;\n} ConfigEntry;\n\nstatic ConfigEntry g_config_entries[MAX_CONFIG_ENTRIES];\nstatic uint8_t g_num_config_entries = 0;\nstatic int16_t g_last_updated_idx = -1;\n\nvoid init_config_manager() {\n    memset(g_config_entries, 0, sizeof(g_config_entries));\n    g_num_config_entries = 0;\n    g_last_updated_idx = -1;\n}\n\nbool add_config_entry(uint16_t id, const uint8_t* data) {\n    if (g_num_config_entries >= MAX_CONFIG_ENTRIES) {\n        return false;\n    }\n    ConfigEntry* entry = &g_config_entries[g_num_config_entries];\n    entry->param_id = id;\n    memcpy(entry->config_data, data, CONFIG_VALUE_SIZE);\n    entry->status_flags = 0xFF;\n    g_last_updated_idx = g_num_config_entries;\n    g_num_config_entries++;\n    return true;\n}\n\nvoid access_config_entry(uint16_t index) {\n    if (index < g_num_config_entries) {\n        volatile uint16_t id = g_config_entries[index].param_id;\n        (void)id;\n    }\n}\n\nvoid update_preceding_config_marker_vulnerable(int16_t offset_from_first_entry, uint8_t marker_val) {\n    if (g_num_config_entries == 0) {\n        return;\n    }\n\n    int16_t target_idx = offset_from_first_entry;\n\n    if (target_idx < 0 || target_idx >= MAX_CONFIG_ENTRIES) {\n        return;\n    }\n\n    uint8_t* current_entry_byte_ptr = (uint8_t*)&g_config_entries[target_idx];\n\n    uint8_t* marker_location_ptr = current_entry_byte_ptr - 1;\n\n    *marker_location_ptr = marker_val;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_CONFIG_ENTRIES 16\n#define CONFIG_VALUE_SIZE 4\n\ntypedef struct {\n    uint16_t param_id;\n    uint8_t  config_data[CONFIG_VALUE_SIZE];\n    uint8_t  status_flags;\n} ConfigEntryFixed;\n\nstatic ConfigEntryFixed g_config_entries_fixed[MAX_CONFIG_ENTRIES];\nstatic uint8_t g_num_config_entries_fixed = 0;\nstatic int16_t g_last_updated_idx_fixed = -1;\n\nvoid init_config_manager_fixed() {\n    memset(g_config_entries_fixed, 0, sizeof(g_config_entries_fixed));\n    g_num_config_entries_fixed = 0;\n    g_last_updated_idx_fixed = -1;\n}\n\nbool add_config_entry_fixed(uint16_t id, const uint8_t* data) {\n    if (g_num_config_entries_fixed >= MAX_CONFIG_ENTRIES) {\n        return false;\n    }\n    ConfigEntryFixed* entry = &g_config_entries_fixed[g_num_config_entries_fixed];\n    entry->param_id = id;\n    memcpy(entry->config_data, data, CONFIG_VALUE_SIZE);\n    entry->status_flags = 0xFF;\n    g_last_updated_idx_fixed = g_num_config_entries_fixed;\n    g_num_config_entries_fixed++;\n    return true;\n}\n\nvoid access_config_entry_fixed(uint16_t index) {\n    if (index < g_num_config_entries_fixed) {\n        volatile uint16_t id = g_config_entries_fixed[index].param_id;\n        (void)id;\n    }\n}\n\nvoid update_preceding_config_marker_fixed(int16_t offset_from_first_entry, uint8_t marker_val) {\n    if (g_num_config_entries_fixed == 0) {\n        return;\n    }\n\n    int16_t target_idx = offset_from_first_entry;\n\n    if (target_idx < 0 || target_idx >= MAX_CONFIG_ENTRIES) {\n        return;\n    }\n\n    uint8_t* current_entry_byte_ptr = (uint8_t*)&g_config_entries_fixed[target_idx];\n\n    uint8_t* buffer_start_ptr = (uint8_t*)&g_config_entries_fixed[0];\n\n    uint8_t* marker_location_ptr = current_entry_byte_ptr - 1;\n\n    if (marker_location_ptr < buffer_start_ptr) {\n        return;\n    }\n\n    *marker_location_ptr = marker_val;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAGNOSTIC_BUFFER_SIZE 256\n#define DIAG_DATA_POINT_SIZE 4\n\nstatic uint8_t g_diagnostic_data_buffer[DIAGNOSTIC_BUFFER_SIZE];\nstatic int32_t g_current_read_offset = 0;\nstatic uint32_t g_bytes_stored = 0;\n\nvoid init_diagnostic_system() {\n    memset(g_diagnostic_data_buffer, 0, sizeof(g_diagnostic_data_buffer));\n    g_current_read_offset = 0;\n    g_bytes_stored = 0;\n}\n\nbool add_diagnostic_data(const uint8_t* data, uint32_t len) {\n    if (len == 0 || data == NULL || (g_bytes_stored + len) > DIAGNOSTIC_BUFFER_SIZE) {\n        return false;\n    }\n    memcpy(g_diagnostic_data_buffer + g_bytes_stored, data, len);\n    g_bytes_stored += len;\n    return true;\n}\n\nuint32_t process_diagnostic_data_point() {\n    if (g_current_read_offset < 0 || g_current_read_offset + DIAG_DATA_POINT_SIZE > g_bytes_stored) {\n        return 0xFFFFFFFF;\n    }\n    uint32_t data_point;\n    memcpy(&data_point, g_diagnostic_data_buffer + g_current_read_offset, DIAG_DATA_POINT_SIZE);\n    g_current_read_offset += DIAG_DATA_POINT_SIZE;\n    return data_point;\n}\n\nvoid rewind_and_invalidate_diagnostic_stream_vulnerable(uint32_t num_data_points_to_rewind) {\n    if (g_bytes_stored == 0) {\n        return;\n    }\n\n    uint32_t bytes_to_rewind = num_data_points_to_rewind * DIAG_DATA_POINT_SIZE;\n\n    int32_t new_read_offset = g_current_read_offset - bytes_to_rewind;\n\n    int32_t start_clear_idx = new_read_offset;\n    int32_t end_clear_idx = g_current_read_offset;\n\n    for (int32_t i = start_clear_idx; i < end_clear_idx; ++i) {\n        g_diagnostic_data_buffer[i] = 0x00;\n    }\n\n    if (new_read_offset < 0) {\n        g_current_read_offset = 0;\n    } else {\n        g_current_read_offset = new_read_offset;\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAGNOSTIC_BUFFER_SIZE_FIXED 256\n#define DIAG_DATA_POINT_SIZE_FIXED 4\n\nstatic uint8_t g_diagnostic_data_buffer_fixed[DIAGNOSTIC_BUFFER_SIZE_FIXED];\nstatic int32_t g_current_read_offset_fixed = 0;\nstatic uint32_t g_bytes_stored_fixed = 0;\n\nvoid init_diagnostic_system_fixed() {\n    memset(g_diagnostic_data_buffer_fixed, 0, sizeof(g_diagnostic_data_buffer_fixed));\n    g_current_read_offset_fixed = 0;\n    g_bytes_stored_fixed = 0;\n}\n\nbool add_diagnostic_data_fixed(const uint8_t* data, uint32_t len) {\n    if (len == 0 || data == NULL || (g_bytes_stored_fixed + len) > DIAGNOSTIC_BUFFER_SIZE_FIXED) {\n        return false;\n    }\n    memcpy(g_diagnostic_data_buffer_fixed + g_bytes_stored_fixed, data, len);\n    g_bytes_stored_fixed += len;\n    return true;\n}\n\nuint32_t process_diagnostic_data_point_fixed() {\n    if (g_current_read_offset_fixed < 0 || g_current_read_offset_fixed + DIAG_DATA_POINT_SIZE_FIXED > g_bytes_stored_fixed) {\n        return 0xFFFFFFFF;\n    }\n    uint32_t data_point;\n    memcpy(&data_point, g_diagnostic_data_buffer_fixed + g_current_read_offset_fixed, DIAG_DATA_POINT_SIZE_FIXED);\n    g_current_read_offset_fixed += DIAG_DATA_POINT_SIZE_FIXED;\n    return data_point;\n}\n\nvoid rewind_and_invalidate_diagnostic_stream_fixed(uint32_t num_data_points_to_rewind) {\n    if (g_bytes_stored_fixed == 0) {\n        return;\n    }\n\n    uint32_t desired_bytes_to_rewind = num_data_points_to_rewind * DIAG_DATA_POINT_SIZE_FIXED;\n\n    uint32_t actual_bytes_to_rewind;\n    if (desired_bytes_to_rewind > (uint32_t)g_current_read_offset_fixed) {\n        actual_bytes_to_rewind = (uint32_t)g_current_read_offset_fixed;\n    } else {\n        actual_bytes_to_rewind = desired_bytes_to_rewind;\n    }\n\n    int32_t new_read_offset = g_current_read_offset_fixed - actual_bytes_to_rewind;\n\n    int32_t start_clear_idx = new_read_offset;\n    int32_t end_clear_idx = g_current_read_offset_fixed;\n\n    for (int32_t i = start_clear_idx; i < end_clear_idx; ++i) {\n        g_diagnostic_data_buffer_fixed[i] = 0x00;\n    }\n\n    g_current_read_offset_fixed = new_read_offset;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define VEHICLE_SETTINGS_BANK_SIZE_BYTES 1024\n#define SETTINGS_BLOCK_SIZE_BYTES        64\n\ntypedef struct {\n    uint16_t version;\n    uint16_t crc;\n    uint8_t  active_flag; \n    uint8_t  _reserved[59]; \n} SettingsBlockHeader;\n\nstatic uint8_t g_settings_bank[VEHICLE_SETTINGS_BANK_SIZE_BYTES];\nstatic uint8_t* g_active_settings_block_ptr = NULL;\nstatic uint16_t g_last_stored_offset = 0;\n\nvoid init_settings_manager_vulnerable() {\n    memset(g_settings_bank, 0, VEHICLE_SETTINGS_BANK_SIZE_BYTES);\n    g_active_settings_block_ptr = g_settings_bank;\n    g_last_stored_offset = 0;\n    ((SettingsBlockHeader*)g_active_settings_block_ptr)->active_flag = 0xAA;\n}\n\nbool store_new_settings_vulnerable(const uint8_t* new_settings_data) {\n    if (g_last_stored_offset + SETTINGS_BLOCK_SIZE_BYTES > VEHICLE_SETTINGS_BANK_SIZE_BYTES) {\n        return false;\n    }\n\n    if (g_active_settings_block_ptr != NULL) {\n        ((SettingsBlockHeader*)g_active_settings_block_ptr)->active_flag = 0x55;\n    }\n\n    uint8_t* new_block_location = g_settings_bank + g_last_stored_offset;\n    memcpy(new_block_location, new_settings_data, SETTINGS_BLOCK_SIZE_BYTES);\n\n    ((SettingsBlockHeader*)new_block_location)->active_flag = 0xAA;\n\n    g_active_settings_block_ptr = new_block_location;\n    g_last_stored_offset += SETTINGS_BLOCK_SIZE_BYTES;\n    return true;\n}\n\nconst uint8_t* get_active_settings_vulnerable() {\n    return g_active_settings_block_ptr;\n}\n\nvoid rollback_settings_vulnerable(uint8_t steps_back) {\n    if (g_active_settings_block_ptr == NULL) {\n        return;\n    }\n\n    uint8_t* target_block_ptr = g_active_settings_block_ptr - (steps_back * SETTINGS_BLOCK_SIZE_BYTES);\n\n    ((SettingsBlockHeader*)target_block_ptr)->active_flag = 0xAA;\n\n    g_active_settings_block_ptr = target_block_ptr;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define VEHICLE_SETTINGS_BANK_SIZE_BYTES 1024\n#define SETTINGS_BLOCK_SIZE_BYTES        64\n\ntypedef struct {\n    uint16_t version;\n    uint16_t crc;\n    uint8_t  active_flag; \n    uint8_t  _reserved[59]; \n} SettingsBlockHeader;\n\nstatic uint8_t g_settings_bank_fixed[VEHICLE_SETTINGS_BANK_SIZE_BYTES];\nstatic uint8_t* g_active_settings_block_ptr_fixed = NULL;\nstatic uint16_t g_last_stored_offset_fixed = 0;\n\nvoid init_settings_manager_fixed() {\n    memset(g_settings_bank_fixed, 0, VEHICLE_SETTINGS_BANK_SIZE_BYTES);\n    g_active_settings_block_ptr_fixed = g_settings_bank_fixed;\n    g_last_stored_offset_fixed = 0;\n    ((SettingsBlockHeader*)g_active_settings_block_ptr_fixed)->active_flag = 0xAA;\n}\n\nbool store_new_settings_fixed(const uint8_t* new_settings_data) {\n    if (g_last_stored_offset_fixed + SETTINGS_BLOCK_SIZE_BYTES > VEHICLE_SETTINGS_BANK_SIZE_BYTES) {\n        return false;\n    }\n\n    if (g_active_settings_block_ptr_fixed != NULL) {\n        ((SettingsBlockHeader*)g_active_settings_block_ptr_fixed)->active_flag = 0x55;\n    }\n\n    uint8_t* new_block_location = g_settings_bank_fixed + g_last_stored_offset_fixed;\n    memcpy(new_block_location, new_settings_data, SETTINGS_BLOCK_SIZE_BYTES);\n\n    ((SettingsBlockHeader*)new_block_location)->active_flag = 0xAA;\n\n    g_active_settings_block_ptr_fixed = new_block_location;\n    g_last_stored_offset_fixed += SETTINGS_BLOCK_SIZE_BYTES;\n    return true;\n}\n\nconst uint8_t* get_active_settings_fixed() {\n    return g_active_settings_block_ptr_fixed;\n}\n\nvoid rollback_settings_fixed(uint8_t steps_back) {\n    if (g_active_settings_block_ptr_fixed == NULL || steps_back == 0) {\n        return;\n    }\n\n    uint8_t* potential_target_ptr = g_active_settings_block_ptr_fixed - (steps_back * SETTINGS_BLOCK_SIZE_BYTES);\n\n    if (potential_target_ptr < g_settings_bank_fixed) {\n        potential_target_ptr = g_settings_bank_fixed;\n    }\n\n    if (g_active_settings_block_ptr_fixed != potential_target_ptr) {\n        ((SettingsBlockHeader*)g_active_settings_block_ptr_fixed)->active_flag = 0x55;\n        g_active_settings_block_ptr_fixed = potential_target_ptr;\n        ((SettingsBlockHeader*)g_active_settings_block_ptr_fixed)->active_flag = 0xAA;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAG_EVENT_BUFFER_SIZE 256\n#define DIAG_EVENT_ENTRY_BYTE_SIZE 8\n\nstatic uint8_t g_diag_event_buffer[DIAG_EVENT_BUFFER_SIZE];\nstatic uint16_t g_active_event_count = 0;\nstatic uint16_t g_next_event_write_byte_idx = 0;\n\nvoid init_diag_event_manager() {\n    memset(g_diag_event_buffer, 0, DIAG_EVENT_BUFFER_SIZE);\n    g_active_event_count = 0;\n    g_next_event_write_byte_idx = 0;\n}\n\nbool record_diagnostic_event(uint32_t timestamp, uint32_t event_code) {\n    if ((g_next_event_write_byte_idx + DIAG_EVENT_ENTRY_BYTE_SIZE) > DIAG_EVENT_BUFFER_SIZE) {\n        return false;\n    }\n    \n    memcpy(g_diag_event_buffer + g_next_event_write_byte_idx, &timestamp, sizeof(timestamp));\n    memcpy(g_diag_event_buffer + g_next_event_write_byte_idx + sizeof(timestamp), &event_code, sizeof(event_code));\n    \n    g_next_event_write_byte_idx += DIAG_EVENT_ENTRY_BYTE_SIZE;\n    g_active_event_count++;\n    \n    return true;\n}\n\nvoid clear_recent_diag_events_and_mark_vulnerable(uint16_t events_to_purge, int16_t marker_byte_offset_from_new_end) {\n    if (g_active_event_count == 0) {\n        return;\n    }\n\n    uint16_t actual_events_to_purge = events_to_purge;\n    if (actual_events_to_purge > g_active_event_count) {\n        actual_events_to_purge = g_active_event_count;\n    }\n\n    g_active_event_count -= actual_events_to_purge;\n    g_next_event_write_byte_idx = g_active_event_count * DIAG_EVENT_ENTRY_BYTE_SIZE;\n\n    int32_t target_marker_byte_idx = (int32_t)g_next_event_write_byte_idx + marker_byte_offset_from_new_end;\n\n    g_diag_event_buffer[target_marker_byte_idx] = 0xDE;\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAG_EVENT_BUFFER_SIZE_FIXED 256\n#define DIAG_EVENT_ENTRY_BYTE_SIZE_FIXED 8\n\nstatic uint8_t g_diag_event_buffer_fixed[DIAG_EVENT_BUFFER_SIZE_FIXED];\nstatic uint16_t g_active_event_count_fixed = 0;\nstatic uint16_t g_next_event_write_byte_idx_fixed = 0;\n\nvoid init_diag_event_manager_fixed() {\n    memset(g_diag_event_buffer_fixed, 0, DIAG_EVENT_BUFFER_SIZE_FIXED);\n    g_active_event_count_fixed = 0;\n    g_next_event_write_byte_idx_fixed = 0;\n}\n\nbool record_diagnostic_event_fixed(uint32_t timestamp, uint32_t event_code) {\n    if ((g_next_event_write_byte_idx_fixed + DIAG_EVENT_ENTRY_BYTE_SIZE_FIXED) > DIAG_EVENT_BUFFER_SIZE_FIXED) {\n        return false;\n    }\n    \n    memcpy(g_diag_event_buffer_fixed + g_next_event_write_byte_idx_fixed, &timestamp, sizeof(timestamp));\n    memcpy(g_diag_event_buffer_fixed + g_next_event_write_byte_idx_fixed + sizeof(timestamp), &event_code, sizeof(event_code));\n    \n    g_next_event_write_byte_idx_fixed += DIAG_EVENT_ENTRY_BYTE_SIZE_FIXED;\n    g_active_event_count_fixed++;\n    \n    return true;\n}\n\nvoid clear_recent_diag_events_and_mark_fixed(uint16_t events_to_purge, int16_t marker_byte_offset_from_new_end) {\n    if (g_active_event_count_fixed == 0) {\n        return;\n    }\n\n    uint16_t actual_events_to_purge = events_to_purge;\n    if (actual_events_to_purge > g_active_event_count_fixed) {\n        actual_events_to_purge = g_active_event_count_fixed;\n    }\n\n    g_active_event_count_fixed -= actual_events_to_purge;\n    g_next_event_write_byte_idx_fixed = g_active_event_count_fixed * DIAG_EVENT_ENTRY_BYTE_SIZE_FIXED;\n\n    int32_t target_marker_byte_idx = (int32_t)g_next_event_write_byte_idx_fixed + marker_byte_offset_from_new_end;\n\n    if (target_marker_byte_idx >= 0 && target_marker_byte_idx < DIAG_EVENT_BUFFER_SIZE_FIXED) {\n        g_diag_event_buffer_fixed[target_marker_byte_idx] = 0xDE;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\nuint32_t get_current_timestamp() {\n    return 0xDEADBEEF; \n}\n\n#define DIAG_DATA_POINTS_HISTORY_SIZE 20\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t engine_runtime_hrs;\n    uint16_t km_driven_hundreds;\n    uint8_t  error_code_count;\n    bool     valid_entry;\n} DiagnosticSnapshot;\n\nstatic DiagnosticSnapshot g_diag_history_buffer[DIAG_DATA_POINTS_HISTORY_SIZE];\nstatic uint16_t g_diag_write_head_idx = 0;\nstatic uint16_t g_num_active_snapshots = 0;\n\nvoid init_diagnostic_history_vulnerable() {\n    for (uint16_t i = 0; i < DIAG_DATA_POINTS_HISTORY_SIZE; ++i) {\n        g_diag_history_buffer[i].valid_entry = false;\n    }\n    g_diag_write_head_idx = 0;\n    g_num_active_snapshots = 0;\n}\n\nvoid add_diag_snapshot_vulnerable(uint16_t runtime, uint16_t km_driven, uint8_t error_count) {\n    g_diag_history_buffer[g_diag_write_head_idx].timestamp_ms = get_current_timestamp();\n    g_diag_history_buffer[g_diag_write_head_idx].engine_runtime_hrs = runtime;\n    g_diag_history_buffer[g_diag_write_head_idx].km_driven_hundreds = km_driven;\n    g_diag_history_buffer[g_diag_write_head_idx].error_code_count = error_count;\n    g_diag_history_buffer[g_diag_write_head_idx].valid_entry = true;\n\n    g_diag_write_head_idx = (g_diag_write_head_idx + 1) % DIAG_DATA_POINTS_HISTORY_SIZE;\n    if (g_num_active_snapshots < DIAG_DATA_POINTS_HISTORY_SIZE) {\n        g_num_active_snapshots++;\n    }\n}\n\nvoid invalidate_recent_diag_snapshots_vulnerable(uint16_t num_to_invalidate) {\n    if (g_num_active_snapshots == 0 || num_to_invalidate == 0) {\n        return;\n    }\n\n    uint16_t actual_invalidate_count = num_to_invalidate;\n    if (actual_invalidate_count > g_num_active_snapshots) {\n        actual_invalidate_count = g_num_active_snapshots;\n    }\n\n    uint16_t latest_snapshot_idx;\n    if (g_diag_write_head_idx == 0) {\n        latest_snapshot_idx = DIAG_DATA_POINTS_HISTORY_SIZE - 1;\n    } else {\n        latest_snapshot_idx = g_diag_write_head_idx - 1;\n    }\n\n    for (uint16_t i = 0; i < actual_invalidate_count; ++i) {\n        uint16_t target_phys_idx = latest_snapshot_idx - i;\n\n        g_diag_history_buffer[target_phys_idx].valid_entry = false;\n        g_diag_history_buffer[target_phys_idx].engine_runtime_hrs = 0;\n        g_diag_history_buffer[target_phys_idx].km_driven_hundreds = 0;\n        g_diag_history_buffer[target_phys_idx].error_code_count = 0;\n    }\n\n    g_num_active_snapshots -= actual_invalidate_count;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\nuint32_t get_current_timestamp() {\n    return 0xDEADBEEF; \n}\n\n#define DIAG_DATA_POINTS_HISTORY_SIZE 20\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    uint16_t engine_runtime_hrs;\n    uint16_t km_driven_hundreds;\n    uint8_t  error_code_count;\n    bool     valid_entry;\n} DiagnosticSnapshot;\n\nstatic DiagnosticSnapshot g_diag_history_buffer_fixed[DIAG_DATA_POINTS_HISTORY_SIZE];\nstatic uint16_t g_diag_write_head_idx_fixed = 0;\nstatic uint16_t g_num_active_snapshots_fixed = 0;\n\nvoid init_diagnostic_history_fixed() {\n    for (uint16_t i = 0; i < DIAG_DATA_POINTS_HISTORY_SIZE; ++i) {\n        g_diag_history_buffer_fixed[i].valid_entry = false;\n    }\n    g_diag_write_head_idx_fixed = 0;\n    g_num_active_snapshots_fixed = 0;\n}\n\nvoid add_diag_snapshot_fixed(uint16_t runtime, uint16_t km_driven, uint8_t error_count) {\n    g_diag_history_buffer_fixed[g_diag_write_head_idx_fixed].timestamp_ms = get_current_timestamp();\n    g_diag_history_buffer_fixed[g_diag_write_head_idx_fixed].engine_runtime_hrs = runtime;\n    g_diag_history_buffer_fixed[g_diag_write_head_idx_fixed].km_driven_hundreds = km_driven;\n    g_diag_history_buffer_fixed[g_diag_write_head_idx_fixed].error_code_count = error_count;\n    g_diag_history_buffer_fixed[g_diag_write_head_idx_fixed].valid_entry = true;\n\n    g_diag_write_head_idx_fixed = (g_diag_write_head_idx_fixed + 1) % DIAG_DATA_POINTS_HISTORY_SIZE;\n    if (g_num_active_snapshots_fixed < DIAG_DATA_POINTS_HISTORY_SIZE) {\n        g_num_active_snapshots_fixed++;\n    }\n}\n\nvoid invalidate_recent_diag_snapshots_fixed(uint16_t num_to_invalidate) {\n    if (g_num_active_snapshots_fixed == 0 || num_to_invalidate == 0) {\n        return;\n    }\n\n    uint16_t actual_invalidate_count = num_to_invalidate;\n    if (actual_invalidate_count > g_num_active_snapshots_fixed) {\n        actual_invalidate_count = g_num_active_snapshots_fixed;\n    }\n\n    uint16_t latest_snapshot_idx;\n    if (g_diag_write_head_idx_fixed == 0) {\n        latest_snapshot_idx = DIAG_DATA_POINTS_HISTORY_SIZE - 1;\n    } else {\n        latest_snapshot_idx = g_diag_write_head_idx_fixed - 1;\n    }\n\n    for (uint16_t i = 0; i < actual_invalidate_count; ++i) {\n        uint16_t target_phys_idx = (latest_snapshot_idx - i + DIAG_DATA_POINTS_HISTORY_SIZE) % DIAG_DATA_POINTS_HISTORY_SIZE;\n\n        g_diag_history_buffer_fixed[target_phys_idx].valid_entry = false;\n        g_diag_history_buffer_fixed[target_phys_idx].engine_runtime_hrs = 0;\n        g_diag_history_buffer_fixed[target_phys_idx].km_driven_hundreds = 0;\n        g_diag_history_buffer_fixed[target_phys_idx].error_code_count = 0;\n    }\n\n    g_num_active_snapshots_fixed -= actual_invalidate_count;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMANDS 32\n#define INITIAL_COMMAND_OFFSET 5 \n\ntypedef enum {\n    CMD_TYPE_NONE = 0,\n    CMD_TYPE_ACCEL,\n    CMD_TYPE_BRAKE,\n    CMD_TYPE_STEER,\n    CMD_TYPE_PARK\n} CommandType;\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    CommandType type;\n    int16_t value;\n    bool is_active;\n} VehicleCommand;\n\nstatic VehicleCommand g_command_log[MAX_COMMANDS];\nstatic uint16_t g_next_write_idx = INITIAL_COMMAND_OFFSET;\nstatic uint16_t g_active_command_count = 0;\n\nvoid init_command_log() {\n    memset(g_command_log, 0, sizeof(g_command_log));\n    g_next_write_idx = INITIAL_COMMAND_OFFSET;\n    g_active_command_count = 0;\n}\n\nbool add_vehicle_command(CommandType type, int16_t value) {\n    if (g_next_write_idx >= MAX_COMMANDS) {\n        return false;\n    }\n    g_command_log[g_next_write_idx].timestamp_ms = 0xDEADBEEF;\n    g_command_log[g_next_write_idx].type = type;\n    g_command_log[g_next_write_idx].value = value;\n    g_command_log[g_next_write_idx].is_active = true;\n\n    g_next_write_idx++;\n    g_active_command_count++;\n    return true;\n}\n\nvoid cancel_command_by_logical_index_vulnerable(int16_t logical_cmd_idx) {\n    int32_t target_phys_idx = (int32_t)INITIAL_COMMAND_OFFSET + logical_cmd_idx;\n\n    if (target_phys_idx >= MAX_COMMANDS) {\n        return;\n    }\n\n    g_command_log[target_phys_idx].is_active = false;\n    g_command_log[target_phys_idx].type = CMD_TYPE_NONE;\n    g_command_log[target_phys_idx].value = 0;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMANDS_FIXED 32\n#define INITIAL_COMMAND_OFFSET_FIXED 5 \n\ntypedef enum {\n    CMD_TYPE_NONE_FIXED = 0,\n    CMD_TYPE_ACCEL_FIXED,\n    CMD_TYPE_BRAKE_FIXED,\n    CMD_TYPE_STEER_FIXED,\n    CMD_TYPE_PARK_FIXED\n} CommandType_Fixed;\n\ntypedef struct {\n    uint32_t timestamp_ms;\n    CommandType_Fixed type;\n    int16_t value;\n    bool is_active;\n} VehicleCommand_Fixed;\n\nstatic VehicleCommand_Fixed g_command_log_fixed[MAX_COMMANDS_FIXED];\nstatic uint16_t g_next_write_idx_fixed = INITIAL_COMMAND_OFFSET_FIXED;\nstatic uint16_t g_active_command_count_fixed = 0;\n\nvoid init_command_log_fixed() {\n    memset(g_command_log_fixed, 0, sizeof(g_command_log_fixed));\n    g_next_write_idx_fixed = INITIAL_COMMAND_OFFSET_FIXED;\n    g_active_command_count_fixed = 0;\n}\n\nbool add_vehicle_command_fixed(CommandType_Fixed type, int16_t value) {\n    if (g_next_write_idx_fixed >= MAX_COMMANDS_FIXED) {\n        return false;\n    }\n    g_command_log_fixed[g_next_write_idx_fixed].timestamp_ms = 0xDEADBEEF;\n    g_command_log_fixed[g_next_write_idx_fixed].type = type;\n    g_command_log_fixed[g_next_write_idx_fixed].value = value;\n    g_command_log_fixed[g_next_write_idx_fixed].is_active = true;\n\n    g_next_write_idx_fixed++;\n    g_active_command_count_fixed++;\n    return true;\n}\n\nvoid cancel_command_by_logical_index_fixed(int16_t logical_cmd_idx) {\n    int32_t target_phys_idx = (int32_t)INITIAL_COMMAND_OFFSET_FIXED + logical_cmd_idx;\n\n    if (target_phys_idx < INITIAL_COMMAND_OFFSET_FIXED ||\n        target_phys_idx >= g_next_write_idx_fixed ||\n        target_phys_idx >= MAX_COMMANDS_FIXED) {\n        return;\n    }\n\n    g_command_log_fixed[target_phys_idx].is_active = false;\n    g_command_log_fixed[target_phys_idx].type = CMD_TYPE_NONE_FIXED;\n    g_command_log_fixed[target_phys_idx].value = 0;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 256\n#define PATCH_BLOCK_MAX_SIZE 64\n#define CONFIG_AREA_START_OFFSET 10\n\nstatic uint8_t g_vehicle_config[VEHICLE_CONFIG_BUFFER_SIZE];\n\nvoid init_vehicle_config() {\n    memset(g_vehicle_config, 0, VEHICLE_CONFIG_BUFFER_SIZE);\n    for (int i = 0; i < (VEHICLE_CONFIG_BUFFER_SIZE - CONFIG_AREA_START_OFFSET); i++) {\n        g_vehicle_config[CONFIG_AREA_START_OFFSET + i] = (uint8_t)i;\n    }\n}\n\nvoid apply_config_patch_vulnerable(const uint8_t* patch_data, uint16_t patch_len, int16_t patch_start_addr_offset) {\n    if (patch_data == NULL || patch_len == 0 || patch_len > PATCH_BLOCK_MAX_SIZE) {\n        return;\n    }\n\n    int32_t absolute_target_address_idx = (int32_t)CONFIG_AREA_START_OFFSET + patch_start_addr_offset;\n\n    if (absolute_target_address_idx + patch_len > VEHICLE_CONFIG_BUFFER_SIZE) {\n        return;\n    }\n    \n    memcpy(g_vehicle_config + absolute_target_address_idx, patch_data, patch_len);\n\n    volatile uint8_t check_byte = g_vehicle_config[CONFIG_AREA_START_OFFSET];\n    (void)check_byte;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE_FIXED 256\n#define PATCH_BLOCK_MAX_SIZE_FIXED 64\n#define CONFIG_AREA_START_OFFSET_FIXED 10\n\nstatic uint8_t g_vehicle_config_fixed[VEHICLE_CONFIG_BUFFER_SIZE_FIXED];\n\nvoid init_vehicle_config_fixed() {\n    memset(g_vehicle_config_fixed, 0, VEHICLE_CONFIG_BUFFER_SIZE_FIXED);\n    for (int i = 0; i < (VEHICLE_CONFIG_BUFFER_SIZE_FIXED - CONFIG_AREA_START_OFFSET_FIXED); i++) {\n        g_vehicle_config_fixed[CONFIG_AREA_START_OFFSET_FIXED + i] = (uint8_t)i;\n    }\n}\n\nvoid apply_config_patch_fixed(const uint8_t* patch_data, uint16_t patch_len, int16_t patch_start_addr_offset) {\n    if (patch_data == NULL || patch_len == 0 || patch_len > PATCH_BLOCK_MAX_SIZE_FIXED) {\n        return;\n    }\n\n    int32_t absolute_target_address_idx = (int32_t)CONFIG_AREA_START_OFFSET_FIXED + patch_start_addr_offset;\n\n    if (absolute_target_address_idx < 0 ||\n        (absolute_target_address_idx + patch_len) > VEHICLE_CONFIG_BUFFER_SIZE_FIXED) {\n        return;\n    }\n    \n    memcpy(g_vehicle_config_fixed + absolute_target_address_idx, patch_data, patch_len);\n\n    volatile uint8_t check_byte = g_vehicle_config_fixed[CONFIG_AREA_START_OFFSET_FIXED];\n    (void)check_byte;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_CALIBRATION_RECORDS 100\n#define CALIBRATION_DATA_BLOCK_SIZE 16\n\ntypedef struct {\n    uint32_t record_id;\n    uint32_t timestamp_utc;\n    uint8_t  cal_data[CALIBRATION_DATA_BLOCK_SIZE];\n    uint8_t  record_status;\n    uint8_t  padding[3];\n} CalibrationRecord_t;\n\nstatic CalibrationRecord_t g_calibration_history[MAX_CALIBRATION_RECORDS];\nstatic int16_t g_current_record_count = 0;\n\nuint32_t get_current_timestamp_vulnerable() {\n    static uint32_t s_timestamp = 1000;\n    return s_timestamp++;\n}\n\nvoid CalHistory_Init_Vulnerable() {\n    memset(g_calibration_history, 0, sizeof(g_calibration_history));\n    g_current_record_count = 0;\n}\n\nbool CalHistory_AddRecord_Vulnerable(const uint8_t* data_block, uint32_t record_id) {\n    if (g_current_record_count >= MAX_CALIBRATION_RECORDS) {\n        return false;\n    }\n    if (data_block == NULL) {\n        return false;\n    }\n\n    g_calibration_history[g_current_record_count].record_id = record_id;\n    g_calibration_history[g_current_record_count].timestamp_utc = get_current_timestamp_vulnerable();\n    memcpy(g_calibration_history[g_current_record_count].cal_data, data_block, CALIBRATION_DATA_BLOCK_SIZE);\n    g_calibration_history[g_current_record_count].record_status = 1;\n\n    g_current_record_count++;\n    return true;\n}\n\nvoid CalHistory_MarkRecordInvalid_Vulnerable(uint16_t relative_offset) {\n    if (g_current_record_count == 0) {\n        return;\n    }\n\n    int16_t target_absolute_idx = g_current_record_count - 1 - relative_offset;\n\n    g_calibration_history[target_absolute_idx].record_status = 0;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_CALIBRATION_RECORDS_FIXED 100\n#define CALIBRATION_DATA_BLOCK_SIZE_FIXED 16\n\ntypedef struct {\n    uint32_t record_id;\n    uint32_t timestamp_utc;\n    uint8_t  cal_data[CALIBRATION_DATA_BLOCK_SIZE_FIXED];\n    uint8_t  record_status;\n    uint8_t  padding[3];\n} CalibrationRecord_t_Fixed;\n\nstatic CalibrationRecord_t_Fixed g_calibration_history_fixed[MAX_CALIBRATION_RECORDS_FIXED];\nstatic int16_t g_current_record_count_fixed = 0;\n\nuint32_t get_current_timestamp_fixed() {\n    static uint32_t s_timestamp_fixed = 1000;\n    return s_timestamp_fixed++;\n}\n\nvoid CalHistory_Init_Fixed() {\n    memset(g_calibration_history_fixed, 0, sizeof(g_calibration_history_fixed));\n    g_current_record_count_fixed = 0;\n}\n\nbool CalHistory_AddRecord_Fixed(const uint8_t* data_block, uint32_t record_id) {\n    if (g_current_record_count_fixed >= MAX_CALIBRATION_RECORDS_FIXED) {\n        return false;\n    }\n    if (data_block == NULL) {\n        return false;\n    }\n\n    g_calibration_history_fixed[g_current_record_count_fixed].record_id = record_id;\n    g_calibration_history_fixed[g_current_record_count_fixed].timestamp_utc = get_current_timestamp_fixed();\n    memcpy(g_calibration_history_fixed[g_current_record_count_fixed].cal_data, data_block, CALIBRATION_DATA_BLOCK_SIZE_FIXED);\n    g_calibration_history_fixed[g_current_record_count_fixed].record_status = 1;\n\n    g_current_record_count_fixed++;\n    return true;\n}\n\nvoid CalHistory_MarkRecordInvalid_Fixed(uint16_t relative_offset) {\n    if (g_current_record_count_fixed == 0) {\n        return;\n    }\n\n    int16_t target_absolute_idx = g_current_record_count_fixed - 1 - relative_offset;\n\n    if (target_absolute_idx < 0 || target_absolute_idx >= g_current_record_count_fixed) {\n        return;\n    }\n    \n    g_calibration_history_fixed[target_absolute_idx].record_status = 0;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_STATE_HISTORY_SIZE 64\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t speed_kmh;\n    uint16_t rpm;\n    uint8_t gear;\n    bool valid;\n} VehicleStateEntry;\n\nstatic VehicleStateEntry g_vehicle_state_log[VEHICLE_STATE_HISTORY_SIZE];\nstatic uint16_t g_current_log_entries = 0;\nstatic uint16_t g_next_write_idx = 0;\n\nvoid init_vehicle_state_log_vulnerable() {\n    memset(g_vehicle_state_log, 0, sizeof(g_vehicle_state_log));\n    g_current_log_entries = 0;\n    g_next_write_idx = 0;\n}\n\nvoid add_vehicle_state_entry_vulnerable(uint32_t timestamp, uint16_t speed, uint16_t rpm, uint8_t gear) {\n    g_vehicle_state_log[g_next_write_idx].timestamp = timestamp;\n    g_vehicle_state_log[g_next_write_idx].speed_kmh = speed;\n    g_vehicle_state_log[g_next_write_idx].rpm = rpm;\n    g_vehicle_state_log[g_next_write_idx].gear = gear;\n    g_vehicle_state_log[g_next_write_idx].valid = true;\n\n    g_next_write_idx = (g_next_write_idx + 1) % VEHICLE_STATE_HISTORY_SIZE;\n    if (g_current_log_entries < VEHICLE_STATE_HISTORY_SIZE) {\n        g_current_log_entries++;\n    }\n}\n\nvoid apply_historical_state_correction_vulnerable(uint16_t relative_offset_from_last, int16_t correction_value_speed) {\n    if (g_current_log_entries == 0) {\n        return;\n    }\n\n    int32_t last_valid_idx = (int32_t)g_next_write_idx - 1;\n    if (last_valid_idx < 0) {\n        last_valid_idx = VEHICLE_STATE_HISTORY_SIZE - 1;\n    }\n\n    int32_t target_idx = last_valid_idx - relative_offset_from_last;\n\n    g_vehicle_state_log[target_idx].speed_kmh += correction_value_speed;\n    g_vehicle_state_log[target_idx].valid = true;\n}",
    "fixed_code": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VEHICLE_STATE_HISTORY_SIZE 64\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t speed_kmh;\n    uint16_t rpm;\n    uint8_t gear;\n    bool valid;\n} VehicleStateEntry;\n\nstatic VehicleStateEntry g_vehicle_state_log_fixed[VEHICLE_STATE_HISTORY_SIZE];\nstatic uint16_t g_current_log_entries_fixed = 0;\nstatic uint16_t g_next_write_idx_fixed = 0;\n\nvoid init_vehicle_state_log_fixed() {\n    memset(g_vehicle_state_log_fixed, 0, sizeof(g_vehicle_state_log_fixed));\n    g_current_log_entries_fixed = 0;\n    g_next_write_idx_fixed = 0;\n}\n\nvoid add_vehicle_state_entry_fixed(uint32_t timestamp, uint16_t speed, uint16_t rpm, uint8_t gear) {\n    g_vehicle_state_log_fixed[g_next_write_idx_fixed].timestamp = timestamp;\n    g_vehicle_state_log_fixed[g_next_write_idx_fixed].speed_kmh = speed;\n    g_vehicle_state_log_fixed[g_next_write_idx_fixed].rpm = rpm;\n    g_vehicle_state_log_fixed[g_next_write_idx_fixed].gear = gear;\n    g_vehicle_state_log_fixed[g_next_write_idx_fixed].valid = true;\n\n    g_next_write_idx_fixed = (g_next_write_idx_fixed + 1) % VEHICLE_STATE_HISTORY_SIZE;\n    if (g_current_log_entries_fixed < VEHICLE_STATE_HISTORY_SIZE) {\n        g_current_log_entries_fixed++;\n    }\n}\n\nvoid apply_historical_state_correction_fixed(uint16_t relative_offset_from_last, int16_t correction_value_speed) {\n    if (g_current_log_entries_fixed == 0) {\n        return;\n    }\n\n    if (relative_offset_from_last >= g_current_log_entries_fixed) {\n        return;\n    }\n\n    uint16_t last_valid_idx = (g_next_write_idx_fixed - 1 + VEHICLE_STATE_HISTORY_SIZE) % VEHICLE_STATE_HISTORY_SIZE;\n\n    uint16_t target_idx = (last_valid_idx - relative_offset_from_last + VEHICLE_STATE_HISTORY_SIZE) % VEHICLE_STATE_HISTORY_SIZE;\n\n    g_vehicle_state_log_fixed[target_idx].speed_kmh += correction_value_speed;\n    g_vehicle_state_log_fixed[target_idx].valid = true;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMAND_HISTORY 64\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t status;\n    uint16_t value;\n    uint32_t timestamp_ms;\n} VehicleCommandEntry;\n\nstatic VehicleCommandEntry g_command_history[MAX_COMMAND_HISTORY];\nstatic uint16_t g_current_command_count = 0;\nstatic uint32_t g_current_time_ms = 0;\n\nvoid init_command_history_system() {\n    memset(g_command_history, 0, sizeof(g_command_history));\n    g_current_command_count = 0;\n    g_current_time_ms = 0;\n}\n\nvoid increment_system_time(uint32_t ms) {\n    g_current_time_ms += ms;\n}\n\nbool record_vehicle_command(uint8_t cmd_id, uint16_t val) {\n    if (g_current_command_count >= MAX_COMMAND_HISTORY) {\n        return false;\n    }\n\n    g_command_history[g_current_command_count].command_id = cmd_id;\n    g_command_history[g_current_command_count].status = 0x01;\n    g_command_history[g_current_command_count].value = val;\n    g_command_history[g_current_command_count].timestamp_ms = g_current_time_ms;\n    g_current_command_count++;\n    return true;\n}\n\n#define CMD_TYPE_BRAKE 0x05\n#define CMD_TYPE_ACCELERATE 0x06\n#define CMD_TYPE_PARK 0x07\n\n#define STATUS_PROCESSED 0x02\n#define STATUS_CANCELED_IMPACT 0x04\n\nvoid process_recent_commands_vulnerable() {\n    if (g_current_command_count == 0) {\n        return;\n    }\n\n    for (int i = (int)g_current_command_count - 1; i >= 0; --i) {\n        switch (g_command_history[i].command_id) {\n            case CMD_TYPE_BRAKE:\n                g_command_history[i - 1].status |= STATUS_CANCELED_IMPACT;\n                g_command_history[i].status = STATUS_PROCESSED;\n                break;\n            case CMD_TYPE_ACCELERATE:\n                g_command_history[i].status = STATUS_PROCESSED;\n                break;\n            case CMD_TYPE_PARK:\n                g_command_history[i].status = STATUS_PROCESSED;\n                break;\n            default:\n                break;\n        }\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMAND_HISTORY 64\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t status;\n    uint16_t value;\n    uint32_t timestamp_ms;\n} VehicleCommandEntry;\n\nstatic VehicleCommandEntry g_command_history[MAX_COMMAND_HISTORY];\nstatic uint16_t g_current_command_count = 0;\nstatic uint32_t g_current_time_ms = 0;\n\nvoid init_command_history_system() {\n    memset(g_command_history, 0, sizeof(g_command_history));\n    g_current_command_count = 0;\n    g_current_time_ms = 0;\n}\n\nvoid increment_system_time(uint32_t ms) {\n    g_current_time_ms += ms;\n}\n\nbool record_vehicle_command(uint8_t cmd_id, uint16_t val) {\n    if (g_current_command_count >= MAX_COMMAND_HISTORY) {\n        return false;\n    }\n\n    g_command_history[g_current_command_count].command_id = cmd_id;\n    g_command_history[g_current_command_count].status = 0x01;\n    g_command_history[g_current_command_count].value = val;\n    g_command_history[g_current_command_count].timestamp_ms = g_current_time_ms;\n    g_current_command_count++;\n    return true;\n}\n\n#define CMD_TYPE_BRAKE 0x05\n#define CMD_TYPE_ACCELERATE 0x06\n#define CMD_TYPE_PARK 0x07\n\n#define STATUS_PROCESSED 0x02\n#define STATUS_CANCELED_IMPACT 0x04\n\nvoid process_recent_commands_fixed() {\n    if (g_current_command_count == 0) {\n        return;\n    }\n\n    for (int i = (int)g_current_command_count - 1; i >= 0; --i) {\n        switch (g_command_history[i].command_id) {\n            case CMD_TYPE_BRAKE:\n                if (i > 0) { \n                    g_command_history[i - 1].status |= STATUS_CANCELED_IMPACT;\n                }\n                g_command_history[i].status = STATUS_PROCESSED;\n                break;\n            case CMD_TYPE_ACCELERATE:\n                g_command_history[i].status = STATUS_PROCESSED;\n                break;\n            case CMD_TYPE_PARK:\n                g_command_history[i].status = STATUS_PROCESSED;\n                break;\n            default:\n                break;\n        }\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-124",
    "cwe_description": "This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define COM_LOG_SIZE 16\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_code;\n    uint8_t  severity;\n} ComEvent;\n\nstatic ComEvent g_com_event_log[COM_LOG_SIZE];\nstatic uint16_t g_next_event_idx = 0;\nstatic uint16_t g_current_event_count = 0;\n\nvoid init_com_log() {\n    memset(g_com_event_log, 0, sizeof(g_com_event_log));\n    g_next_event_idx = 0;\n    g_current_event_count = 0;\n}\n\nvoid log_com_event(uint32_t ts, uint16_t code, uint8_t sev) {\n    g_com_event_log[g_next_event_idx].timestamp = ts;\n    g_com_event_log[g_next_event_idx].event_code = code;\n    g_com_event_log[g_next_event_idx].severity = sev;\n\n    g_next_event_idx = (g_next_event_idx + 1) % COM_LOG_SIZE;\n    if (g_current_event_count < COM_LOG_SIZE) {\n        g_current_event_count++;\n    }\n}\n\nvoid adjust_com_event_severity_vulnerable(uint8_t relative_offset_from_latest, uint8_t new_severity) {\n    if (g_current_event_count == 0) {\n        return;\n    }\n\n    int16_t latest_event_index;\n    if (g_next_event_idx == 0) {\n        latest_event_index = COM_LOG_SIZE - 1;\n    } else {\n        latest_event_index = g_next_event_idx - 1;\n    }\n\n    int16_t target_index = latest_event_index - (int16_t)relative_offset_from_latest;\n\n    g_com_event_log[target_index].severity = new_severity;\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define COM_LOG_SIZE 16\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_code;\n    uint8_t  severity;\n} ComEvent;\n\nstatic ComEvent g_com_event_log_fixed[COM_LOG_SIZE];\nstatic uint16_t g_next_event_idx_fixed = 0;\nstatic uint16_t g_current_event_count_fixed = 0;\n\nvoid init_com_log_fixed() {\n    memset(g_com_event_log_fixed, 0, sizeof(g_com_event_log_fixed));\n    g_next_event_idx_fixed = 0;\n    g_current_event_count_fixed = 0;\n}\n\nvoid log_com_event_fixed(uint32_t ts, uint16_t code, uint8_t sev) {\n    g_com_event_log_fixed[g_next_event_idx_fixed].timestamp = ts;\n    g_com_event_log_fixed[g_next_event_idx_fixed].event_code = code;\n    g_com_event_log_fixed[g_next_event_idx_fixed].severity = sev;\n\n    g_next_event_idx_fixed = (g_next_event_idx_fixed + 1) % COM_LOG_SIZE;\n    if (g_current_event_count_fixed < COM_LOG_SIZE) {\n        g_current_event_count_fixed++;\n    }\n}\n\nvoid adjust_com_event_severity_fixed(uint8_t relative_offset_from_latest, uint8_t new_severity) {\n    if (g_current_event_count_fixed == 0) {\n        return;\n    }\n\n    if (relative_offset_from_latest >= g_current_event_count_fixed) {\n        return;\n    }\n\n    int32_t latest_event_index;\n    if (g_next_event_idx_fixed == 0) {\n        latest_event_index = COM_LOG_SIZE - 1;\n    } else {\n        latest_event_index = g_next_event_idx_fixed - 1;\n    }\n\n    int32_t conceptual_target_index = latest_event_index - (int32_t)relative_offset_from_latest;\n    uint16_t target_index = (uint16_t)((conceptual_target_index % COM_LOG_SIZE + COM_LOG_SIZE) % COM_LOG_SIZE);\n\n    g_com_event_log_fixed[target_index].severity = new_severity;\n}",
    "analysis": ""
  }
]