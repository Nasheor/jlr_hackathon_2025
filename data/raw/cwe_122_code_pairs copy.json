[
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\ntypedef struct {\n    uint16_t messageId;\n    uint16_t payloadType;\n    uint16_t payloadLength; \n    uint8_t payload[512]; \n} DiagnosticMessage;\n\nchar* processDiagnosticReport(const DiagnosticMessage* msg) {\n    if (!msg || msg->payloadLength == 0) {\n        return NULL;\n    }\n\n    char* hex_payload_str = (char*)malloc(msg->payloadLength + 1);\n\n    if (hex_payload_str == NULL) {\n        return NULL;\n    }\n\n    for (uint16_t i = 0; i < msg->payloadLength; ++i) {\n        sprintf(&hex_payload_str[i * 2], \"%02X\", msg->payload[i]);\n    }\n    hex_payload_str[msg->payloadLength * 2] = '\\0';\n\n    return hex_payload_str;\n}",
    "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\ntypedef struct {\n    uint16_t messageId;\n    uint16_t payloadType;\n    uint16_t payloadLength; \n    uint8_t payload[512]; \n} DiagnosticMessage;\n\nchar* processDiagnosticReport(const DiagnosticMessage* msg) {\n    if (!msg || msg->payloadLength == 0) {\n        char* empty_str = (char*)malloc(1);\n        if (empty_str) {\n            empty_str[0] = '\\0';\n        }\n        return empty_str;\n    }\n\n    size_t required_size = (size_t)msg->payloadLength * 2 + 1;\n\n    char* hex_payload_str = (char*)malloc(required_size);\n\n    if (hex_payload_str == NULL) {\n        return NULL;\n    }\n\n    for (uint16_t i = 0; i < msg->payloadLength; ++i) {\n        sprintf(&hex_payload_str[i * 2], \"%02X\", msg->payload[i]);\n    }\n    hex_payload_str[msg->payloadLength * 2] = '\\0';\n\n    return hex_payload_str;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <stdlib.h>\n#include <stdint.h>\n\n#define MAX_ERROR_DESC_LEN 64\n\ntypedef struct {\n    uint32_t errorCode;\n    uint8_t severity;\n    char description[MAX_ERROR_DESC_LEN];\n} DiagnosticErrorEntry;\n\nclass ErrorLogManager {\npublic:\n    ErrorLogManager() : current_capacity(0), num_errors(0), error_entries(NULL) {\n        current_capacity = 4;\n        error_entries = (DiagnosticErrorEntry*)malloc(current_capacity * sizeof(DiagnosticErrorEntry));\n        if (!error_entries) {\n            // Handle allocation failure\n        }\n    }\n\n    ~ErrorLogManager() {\n        if (error_entries) {\n            free(error_entries);\n            error_entries = NULL;\n        }\n    }\n\n    bool addErrorEntryVulnerable(uint32_t code, uint8_t sev, const char* desc) {\n        if (!desc) {\n            return false;\n        }\n\n        if (num_errors >= current_capacity) {\n            size_t new_capacity = current_capacity * 2;\n            DiagnosticErrorEntry* new_entries = (DiagnosticErrorEntry*)realloc(error_entries, new_capacity * sizeof(DiagnosticErrorEntry));\n            if (!new_entries) {\n                return false;\n            }\n            error_entries = new_entries;\n            current_capacity = new_capacity;\n        }\n\n        error_entries[num_errors].errorCode = code;\n        error_entries[num_errors].severity = sev;\n\n        size_t desc_idx = 0;\n        // Vulnerable: No bounds check for 'desc_idx' against 'MAX_ERROR_DESC_LEN'\n        while (desc[desc_idx] != '\\0') {\n            error_entries[num_errors].description[desc_idx] = desc[desc_idx];\n            desc_idx++;\n        }\n        // If 'desc' is too long, 'desc_idx' can exceed 'MAX_ERROR_DESC_LEN - 1',\n        // leading to writing past the end of the 'description' array in heap-allocated memory.\n        // The null terminator write may also be out of bounds if desc_idx == MAX_ERROR_DESC_LEN.\n        error_entries[num_errors].description[desc_idx] = '\\0';\n\n        num_errors++;\n        return true;\n    }\n\nprivate:\n    size_t current_capacity;\n    size_t num_errors;\n    DiagnosticErrorEntry* error_entries;\n};\n",
    "fixed_code": "#include <stdlib.h>\n#include <stdint.h>\n\n#define MAX_ERROR_DESC_LEN 64\n\ntypedef struct {\n    uint32_t errorCode;\n    uint8_t severity;\n    char description[MAX_ERROR_DESC_LEN];\n} DiagnosticErrorEntry;\n\nclass ErrorLogManager {\npublic:\n    ErrorLogManager() : current_capacity(0), num_errors(0), error_entries(NULL) {\n        current_capacity = 4;\n        error_entries = (DiagnosticErrorEntry*)malloc(current_capacity * sizeof(DiagnosticErrorEntry));\n        if (!error_entries) {\n            // Handle allocation failure\n        }\n    }\n\n    ~ErrorLogManager() {\n        if (error_entries) {\n            free(error_entries);\n            error_entries = NULL;\n        }\n    }\n\n    bool addErrorEntryFixed(uint32_t code, uint8_t sev, const char* desc) {\n        if (!desc) {\n            return false;\n        }\n\n        if (num_errors >= current_capacity) {\n            size_t new_capacity = current_capacity * 2;\n            // Defensive check for potential integer overflow in 'new_capacity' calculation\n            if (new_capacity <= current_capacity) { \n                return false; \n            }\n            DiagnosticErrorEntry* new_entries = (DiagnosticErrorEntry*)realloc(error_entries, new_capacity * sizeof(DiagnosticErrorEntry));\n            if (!new_entries) {\n                return false;\n            }\n            error_entries = new_entries;\n            current_capacity = new_capacity;\n        }\n\n        error_entries[num_errors].errorCode = code;\n        error_entries[num_errors].severity = sev;\n\n        size_t desc_idx = 0;\n        // Fixed: Added bounds check for 'desc_idx' to ensure it doesn't exceed 'MAX_ERROR_DESC_LEN - 1'\n        // This ensures space for the null terminator and prevents heap overflow.\n        while (desc[desc_idx] != '\\0' && desc_idx < MAX_ERROR_DESC_LEN - 1) {\n            error_entries[num_errors].description[desc_idx] = desc[desc_idx];\n            desc_idx++;\n        }\n        // Always null-terminate within bounds, potentially truncating the string\n        error_entries[num_errors].description[desc_idx] = '\\0';\n\n        num_errors++;\n        return true;\n    }\n\nprivate:\n    size_t current_capacity;\n    size_t num_errors;\n    DiagnosticErrorEntry* error_entries;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    uint16_t packet_id;\n    uint16_t num_sensor_readings;\n} SensorDataPacketHeader;\n\nclass SensorDataProcessor {\npublic:\n    SensorDataProcessor() : processed_readings(nullptr), current_reading_count(0) {}\n\n    ~SensorDataProcessor() {\n        if (processed_readings) {\n            free(processed_readings);\n            processed_readings = nullptr;\n        }\n    }\n\n    bool processRawSensorDataVulnerable(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(SensorDataPacketHeader)) {\n            return false;\n        }\n\n        const SensorDataPacketHeader* header = reinterpret_cast<const SensorDataPacketHeader*>(packet_data);\n        uint16_t num_samples = header->num_sensor_readings;\n\n        size_t data_offset = sizeof(SensorDataPacketHeader);\n        size_t expected_data_bytes = num_samples * sizeof(uint16_t);\n\n        if (packet_length < (data_offset + expected_data_bytes)) {\n            return false;\n        }\n\n        if (processed_readings) {\n            free(processed_readings);\n            processed_readings = nullptr;\n        }\n\n        processed_readings = (uint16_t*)malloc(num_samples);\n\n        if (!processed_readings) {\n            return false;\n        }\n\n        memcpy(processed_readings, packet_data + data_offset, expected_data_bytes);\n\n        current_reading_count = num_samples;\n        return true;\n    }\n\n    uint16_t* getProcessedReadings() const { return processed_readings; }\n    uint16_t getReadingCount() const { return current_reading_count; }\n\nprivate:\n    uint16_t* processed_readings;\n    uint16_t current_reading_count;\n};\n",
    "fixed_code": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    uint16_t packet_id;\n    uint16_t num_sensor_readings;\n} SensorDataPacketHeader;\n\nclass SensorDataProcessor {\npublic:\n    SensorDataProcessor() : processed_readings(nullptr), current_reading_count(0) {}\n\n    ~SensorDataProcessor() {\n        if (processed_readings) {\n            free(processed_readings);\n            processed_readings = nullptr;\n        }\n    }\n\n    bool processRawSensorDataFixed(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(SensorDataPacketHeader)) {\n            return false;\n        }\n\n        const SensorDataPacketHeader* header = reinterpret_cast<const SensorDataPacketHeader*>(packet_data);\n        uint16_t num_samples = header->num_sensor_readings;\n\n        size_t data_offset = sizeof(SensorDataPacketHeader);\n        size_t expected_data_bytes = num_samples * sizeof(uint16_t);\n\n        if (num_samples > (SIZE_MAX / sizeof(uint16_t))) {\n             return false;\n        }\n\n        if (packet_length < (data_offset + expected_data_bytes)) {\n            return false;\n        }\n\n        if (processed_readings) {\n            free(processed_readings);\n            processed_readings = nullptr;\n        }\n\n        processed_readings = (uint16_t*)malloc(expected_data_bytes);\n\n        if (!processed_readings) {\n            return false;\n        }\n\n        memcpy(processed_readings, packet_data + data_offset, expected_data_bytes);\n\n        current_reading_count = num_samples;\n        return true;\n    }\n\n    uint16_t* getProcessedReadings() const { return processed_readings; }\n    uint16_t getReadingCount() const { return current_reading_count; }\n\nprivate:\n    uint16_t* processed_readings;\n    uint16_t current_reading_count;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n\ntypedef struct {\n    uint32_t config_id;\n    uint32_t data_length;\n} ConfigBlockHeader;\n\nclass VehicleConfigUpdater {\npublic:\n    VehicleConfigUpdater() : current_config_data(nullptr), current_config_size(0) {}\n\n    ~VehicleConfigUpdater() {\n        if (current_config_data) {\n            delete[] current_config_data;\n            current_config_data = nullptr;\n        }\n    }\n\n    const uint8_t* getCurrentConfigData() const {\n        return current_config_data;\n    }\n\n    uint32_t getCurrentConfigSize() const {\n        return current_config_size;\n    }\n\n    bool processConfigBlockVulnerable(const uint8_t* block_data, size_t block_len) {\n        if (!block_data || block_len < sizeof(ConfigBlockHeader)) {\n            return false;\n        }\n\n        const ConfigBlockHeader* header = reinterpret_cast<const ConfigBlockHeader*>(block_data);\n        uint32_t advertised_data_len = header->data_length;\n\n        uint8_t* temp_buffer = new (std::nothrow) uint8_t[advertised_data_len];\n        if (!temp_buffer) {\n            return false;\n        }\n\n        size_t actual_payload_bytes_in_block = block_len - sizeof(ConfigBlockHeader);\n\n        for (size_t i = 0; i < actual_payload_bytes_in_block; ++i) {\n            temp_buffer[i] = block_data[sizeof(ConfigBlockHeader) + i];\n        }\n\n        if (current_config_data) {\n            delete[] current_config_data;\n        }\n\n        current_config_data = temp_buffer;\n        current_config_size = advertised_data_len;\n\n        return true;\n    }\n\nprivate:\n    uint8_t* current_config_data;\n    uint32_t current_config_size;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <algorithm>\n\ntypedef struct {\n    uint32_t config_id;\n    uint32_t data_length;\n} ConfigBlockHeader;\n\nclass VehicleConfigUpdater {\npublic:\n    VehicleConfigUpdater() : current_config_data(nullptr), current_config_size(0) {}\n\n    ~VehicleConfigUpdater() {\n        if (current_config_data) {\n            delete[] current_config_data;\n            current_config_data = nullptr;\n        }\n    }\n\n    const uint8_t* getCurrentConfigData() const {\n        return current_config_data;\n    }\n\n    uint32_t getCurrentConfigSize() const {\n        return current_config_size;\n    }\n\n    bool processConfigBlockFixed(const uint8_t* block_data, size_t block_len) {\n        if (!block_data || block_len < sizeof(ConfigBlockHeader)) {\n            return false;\n        }\n\n        const ConfigBlockHeader* header = reinterpret_cast<const ConfigBlockHeader*>(block_data);\n        uint32_t advertised_data_len = header->data_length;\n\n        size_t actual_payload_bytes_in_block = block_len - sizeof(ConfigBlockHeader);\n\n        static const uint32_t MAX_ALLOWED_CONFIG_DATA_SIZE = 4096;\n        if (advertised_data_len > MAX_ALLOWED_CONFIG_DATA_SIZE) {\n            return false;\n        }\n\n        size_t bytes_to_copy = std::min((size_t)advertised_data_len, actual_payload_bytes_in_block);\n\n        uint8_t* temp_buffer = new (std::nothrow) uint8_t[advertised_data_len];\n        if (!temp_buffer) {\n            return false;\n        }\n\n        for (size_t i = 0; i < bytes_to_copy; ++i) {\n            temp_buffer[i] = block_data[sizeof(ConfigBlockHeader) + i];\n        }\n\n        if (current_config_data) {\n            delete[] current_config_data;\n        }\n\n        current_config_data = temp_buffer;\n        current_config_size = advertised_data_len;\n\n        return true;\n    }\n\nprivate:\n    uint8_t* current_config_data;\n    uint32_t current_config_size;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n\ntypedef struct {\n    uint16_t message_type;\n    uint16_t total_data_size;\n    uint16_t fragment_offset;\n    uint8_t  fragment_length;\n    uint8_t  payload[64];\n} TelemetryDataFragment;\n\nclass TelemetryDataAssembler {\nprivate:\n    uint8_t* assembled_data_buffer;\n    uint32_t current_assembled_length;\n    uint32_t expected_total_data_size;\n    bool     assembly_active;\n    uint16_t current_message_type;\n\npublic:\n    TelemetryDataAssembler() : assembled_data_buffer(nullptr), current_assembled_length(0),\n                               expected_total_data_size(0), assembly_active(false), current_message_type(0) {}\n\n    ~TelemetryDataAssembler() {\n        if (assembled_data_buffer) {\n            free(assembled_data_buffer);\n            assembled_data_buffer = nullptr;\n        }\n    }\n\n    void resetAssembly() {\n        if (assembled_data_buffer) {\n            free(assembled_data_buffer);\n        }\n        assembled_data_buffer = nullptr;\n        current_assembled_length = 0;\n        expected_total_data_size = 0;\n        assembly_active = false;\n        current_message_type = 0;\n    }\n\n    bool processFragmentVulnerable(const TelemetryDataFragment* fragment) {\n        if (!fragment || fragment->fragment_length > sizeof(fragment->payload)) {\n            return false;\n        }\n\n        if (!assembly_active) {\n            expected_total_data_size = fragment->total_data_size;\n            current_message_type = fragment->message_type;\n\n            if (expected_total_data_size == 0 || expected_total_data_size > 65535) {\n                return false;\n            }\n\n            assembled_data_buffer = (uint8_t*)malloc(expected_total_data_size);\n            if (!assembled_data_buffer) {\n                return false;\n            }\n            current_assembled_length = 0;\n            assembly_active = true;\n        } else {\n            if (fragment->message_type != current_message_type) {\n                return false;\n            }\n        }\n\n        for (uint8_t i = 0; i < fragment->fragment_length; ++i) {\n            assembled_data_buffer[fragment->fragment_offset + i] = fragment->payload[i];\n        }\n\n        uint32_t end_offset = fragment->fragment_offset + fragment->fragment_length;\n        if (end_offset > current_assembled_length) {\n            current_assembled_length = end_offset;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAssembledData() const {\n        if (current_assembled_length == expected_total_data_size) {\n            return assembled_data_buffer;\n        }\n        return nullptr;\n    }\n\n    uint32_t getAssembledLength() const {\n        return current_assembled_length;\n    }\n\n    uint32_t getExpectedTotalSize() const {\n        return expected_total_data_size;\n    }\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <algorithm>\n\ntypedef struct {\n    uint16_t message_type;\n    uint16_t total_data_size;\n    uint16_t fragment_offset;\n    uint8_t  fragment_length;\n    uint8_t  payload[64];\n} TelemetryDataFragment;\n\nclass TelemetryDataAssembler {\nprivate:\n    uint8_t* assembled_data_buffer;\n    uint32_t current_assembled_length;\n    uint32_t expected_total_data_size;\n    bool     assembly_active;\n    uint16_t current_message_type;\n\npublic:\n    TelemetryDataAssembler() : assembled_data_buffer(nullptr), current_assembled_length(0),\n                               expected_total_data_size(0), assembly_active(false), current_message_type(0) {}\n\n    ~TelemetryDataAssembler() {\n        if (assembled_data_buffer) {\n            free(assembled_data_buffer);\n            assembled_data_buffer = nullptr;\n        }\n    }\n\n    void resetAssembly() {\n        if (assembled_data_buffer) {\n            free(assembled_data_buffer);\n        }\n        assembled_data_buffer = nullptr;\n        current_assembled_length = 0;\n        expected_total_data_size = 0;\n        assembly_active = false;\n        current_message_type = 0;\n    }\n\n    bool processFragmentFixed(const TelemetryDataFragment* fragment) {\n        if (!fragment || fragment->fragment_length > sizeof(fragment->payload)) {\n            return false;\n        }\n\n        if (!assembly_active) {\n            expected_total_data_size = fragment->total_data_size;\n            current_message_type = fragment->message_type;\n\n            if (expected_total_data_size == 0 || expected_total_data_size > 65535) {\n                return false;\n            }\n\n            assembled_data_buffer = (uint8_t*)malloc(expected_total_data_size);\n            if (!assembled_data_buffer) {\n                return false;\n            }\n            current_assembled_length = 0;\n            assembly_active = true;\n        } else {\n            if (fragment->message_type != current_message_type) {\n                return false;\n            }\n        }\n\n        if (fragment->fragment_offset >= expected_total_data_size ||\n            (uint32_t)fragment->fragment_offset + fragment->fragment_length > expected_total_data_size) {\n            return false;\n        }\n\n        for (uint8_t i = 0; i < fragment->fragment_length; ++i) {\n            assembled_data_buffer[fragment->fragment_offset + i] = fragment->payload[i];\n        }\n\n        uint32_t end_offset = fragment->fragment_offset + fragment->fragment_length;\n        if (end_offset > current_assembled_length) {\n            current_assembled_length = end_offset;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAssembledData() const {\n        if (current_assembled_length == expected_total_data_size) {\n            return assembled_data_buffer;\n        }\n        return nullptr;\n    }\n\n    uint32_t getAssembledLength() const {\n        return current_assembled_length;\n    }\n\n    uint32_t getExpectedTotalSize() const {\n        return expected_total_data_size;\n    }\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRY_DESCRIPTION_LEN 256\n#define INITIAL_LOG_BUFFER_CAPACITY 1024\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t desc_length; \n} LogEntryHeader;\n\nclass DiagnosticLogBufferVulnerable {\npublic:\n    DiagnosticLogBufferVulnerable() :\n        log_buffer(nullptr),\n        current_data_size(0),\n        allocated_capacity(0)\n    {\n        log_buffer = (uint8_t*)malloc(INITIAL_LOG_BUFFER_CAPACITY);\n        if (log_buffer) {\n            allocated_capacity = INITIAL_LOG_BUFFER_CAPACITY;\n        }\n    }\n\n    ~DiagnosticLogBufferVulnerable() {\n        if (log_buffer) {\n            free(log_buffer);\n            log_buffer = nullptr;\n        }\n    }\n\n    bool addLogEntryVulnerable(uint32_t timestamp, uint16_t event_id, const char* description) {\n        if (!description) {\n            return false;\n        }\n\n        size_t actual_desc_len = strlen(description);\n        if (actual_desc_len >= MAX_LOG_ENTRY_DESCRIPTION_LEN) {\n            return false;\n        }\n\n        size_t required_entry_data_space = sizeof(LogEntryHeader) + actual_desc_len;\n\n        if (current_data_size + required_entry_data_space > allocated_capacity) {\n            size_t new_capacity = allocated_capacity * 2;\n            if (new_capacity <= allocated_capacity || new_capacity < current_data_size + required_entry_data_space) {\n                new_capacity = current_data_size + required_entry_data_space + INITIAL_LOG_BUFFER_CAPACITY;\n            }\n            \n            uint8_t* new_log_buffer = (uint8_t*)realloc(log_buffer, new_capacity);\n            if (!new_log_buffer) {\n                return false;\n            }\n            log_buffer = new_log_buffer;\n            allocated_capacity = new_capacity;\n        }\n\n        LogEntryHeader header;\n        header.timestamp = timestamp;\n        header.event_id = event_id;\n        header.desc_length = (uint16_t)actual_desc_len;\n\n        memcpy(log_buffer + current_data_size, &header, sizeof(LogEntryHeader));\n        \n        uint8_t* desc_dest_ptr = log_buffer + current_data_size + sizeof(LogEntryHeader);\n\n        for (size_t i = 0; i <= actual_desc_len; ++i) {\n            desc_dest_ptr[i] = description[i];\n        }\n\n        current_data_size += sizeof(LogEntryHeader) + actual_desc_len + 1;\n\n        return true;\n    }\n\n    const uint8_t* getRawLogBuffer() const {\n        return log_buffer;\n    n}\n\n    size_t getContainedDataSize() const {\n        return current_data_size;\n    }\n\nprivate:\n    uint8_t* log_buffer;\n    size_t current_data_size;\n    size_t allocated_capacity;\n};\n",
    "fixed_code": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRY_DESCRIPTION_LEN 256\n#define INITIAL_LOG_BUFFER_CAPACITY 1024\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t desc_length;\n} LogEntryHeader;\n\nclass DiagnosticLogBufferFixed {\npublic:\n    DiagnosticLogBufferFixed() :\n        log_buffer(nullptr),\n        current_data_size(0),\n        allocated_capacity(0)\n    {\n        log_buffer = (uint8_t*)malloc(INITIAL_LOG_BUFFER_CAPACITY);\n        if (log_buffer) {\n            allocated_capacity = INITIAL_LOG_BUFFER_CAPACITY;\n        }\n    }\n\n    ~DiagnosticLogBufferFixed() {\n        if (log_buffer) {\n            free(log_buffer);\n            log_buffer = nullptr;\n        }\n    }\n\n    bool addLogEntryFixed(uint32_t timestamp, uint16_t event_id, const char* description) {\n        if (!description) {\n            return false;\n        }\n\n        size_t actual_desc_len = strlen(description);\n        if (actual_desc_len >= MAX_LOG_ENTRY_DESCRIPTION_LEN) {\n            return false;\n        }\n\n        size_t required_entry_data_space = sizeof(LogEntryHeader) + actual_desc_len + 1; \n\n        if (current_data_size + required_entry_data_space > allocated_capacity) {\n            size_t new_capacity = allocated_capacity * 2;\n            if (new_capacity <= allocated_capacity || new_capacity < current_data_size + required_entry_data_space) {\n                new_capacity = current_data_size + required_entry_data_space + INITIAL_LOG_BUFFER_CAPACITY;\n            }\n            \n            uint8_t* new_log_buffer = (uint8_t*)realloc(log_buffer, new_capacity);\n            if (!new_log_buffer) {\n                return false;\n            }\n            log_buffer = new_log_buffer;\n            allocated_capacity = new_capacity;\n        }\n\n        LogEntryHeader header;\n        header.timestamp = timestamp;\n        header.event_id = event_id;\n        header.desc_length = (uint16_t)actual_desc_len;\n\n        memcpy(log_buffer + current_data_size, &header, sizeof(LogEntryHeader));\n        \n        uint8_t* desc_dest_ptr = log_buffer + current_data_size + sizeof(LogEntryHeader);\n\n        for (size_t i = 0; i <= actual_desc_len; ++i) {\n            desc_dest_ptr[i] = description[i];\n        }\n\n        current_data_size += sizeof(LogEntryHeader) + actual_desc_len + 1;\n\n        return true;\n    }\n\n    const uint8_t* getRawLogBuffer() const {\n        return log_buffer;\n    }\n\n    size_t getContainedDataSize() const {\n        return current_data_size;\n    }\n\nprivate:\n    uint8_t* log_buffer;\n    size_t current_data_size;\n    size_t allocated_capacity;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n\nstruct ProcessedTelemetryData {\n    uint32_t timestamp;\n    int32_t  engine_rpm;\n    int16_t  vehicle_speed;\n    uint8_t  gear_position;\n    bool     is_engine_on;\n};\n\nstruct RawTelemetryPacketHeader {\n    uint16_t packet_type;\n    uint16_t num_readings;\n    uint32_t total_payload_bytes;\n};\n\nclass TelemetryDataManager {\npublic:\n    TelemetryDataManager() : data_buffer(nullptr), buffer_capacity(0), current_data_count(0) {}\n\n    ~TelemetryDataManager() {\n        if (data_buffer) {\n            delete[] data_buffer;\n            data_buffer = nullptr;\n        }\n    }\n\n    bool processRawTelemetryPacketVulnerable(const uint8_t* raw_packet, size_t raw_packet_len) {\n        if (!raw_packet || raw_packet_len < sizeof(RawTelemetryPacketHeader)) {\n            return false;\n        }\n\n        const RawTelemetryPacketHeader* header = reinterpret_cast<const RawTelemetryPacketHeader*>(raw_packet);\n\n        if (static_cast<size_t>(header->total_payload_bytes) > (raw_packet_len - sizeof(RawTelemetryPacketHeader))) {\n            return false;\n        }\n\n        if (data_buffer) {\n            delete[] data_buffer;\n            data_buffer = nullptr;\n        }\n\n        buffer_capacity = header->num_readings;\n        data_buffer = new (std::nothrow) ProcessedTelemetryData[buffer_capacity];\n        if (!data_buffer) {\n            return false;\n        }\n\n        const uint8_t* payload_start = raw_packet + sizeof(RawTelemetryPacketHeader);\n        size_t bytes_to_copy = static_cast<size_t>(header->total_payload_bytes);\n\n        for (size_t i = 0; i < bytes_to_copy; ++i) {\n            reinterpret_cast<uint8_t*>(data_buffer)[i] = payload_start[i];\n        }\n\n        current_data_count = header->num_readings;\n\n        return true;\n    }\n\n    const ProcessedTelemetryData* getTelemetryData() const { return data_buffer; }\n    uint16_t getTelemetryCount() const { return current_data_count; }\n\nprivate:\n    ProcessedTelemetryData* data_buffer;\n    uint16_t                buffer_capacity;\n    uint16_t                current_data_count;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <algorithm>\n\nstruct ProcessedTelemetryData {\n    uint32_t timestamp;\n    int32_t  engine_rpm;\n    int16_t  vehicle_speed;\n    uint8_t  gear_position;\n    bool     is_engine_on;\n};\n\nstruct RawTelemetryPacketHeader {\n    uint16_t packet_type;\n    uint16_t num_readings;\n    uint32_t total_payload_bytes;\n};\n\nclass TelemetryDataManager {\npublic:\n    TelemetryDataManager() : data_buffer(nullptr), buffer_capacity(0), current_data_count(0) {}\n\n    ~TelemetryDataManager() {\n        if (data_buffer) {\n            delete[] data_buffer;\n            data_buffer = nullptr;\n        }\n    }\n\n    bool processRawTelemetryPacketFixed(const uint8_t* raw_packet, size_t raw_packet_len) {\n        if (!raw_packet || raw_packet_len < sizeof(RawTelemetryPacketHeader)) {\n            return false;\n        }\n\n        const RawTelemetryPacketHeader* header = reinterpret_cast<const RawTelemetryPacketHeader*>(raw_packet);\n\n        size_t max_actual_payload_in_packet = raw_packet_len - sizeof(RawTelemetryPacketHeader);\n\n        if (static_cast<size_t>(header->total_payload_bytes) > max_actual_payload_in_packet) {\n            return false;\n        }\n\n        size_t requested_num_readings = header->num_readings;\n        \n        if (requested_num_readings > (SIZE_MAX / sizeof(ProcessedTelemetryData))) {\n             return false;\n        }\n        size_t required_allocation_bytes = requested_num_readings * sizeof(ProcessedTelemetryData);\n\n        if (data_buffer) {\n            delete[] data_buffer;\n            data_buffer = nullptr;\n        }\n\n        data_buffer = new (std::nothrow) ProcessedTelemetryData[requested_num_readings];\n        if (!data_buffer) {\n            return false;\n        }\n        buffer_capacity = requested_num_readings;\n\n        size_t bytes_to_copy = std::min({\n            static_cast<size_t>(header->total_payload_bytes),\n            max_actual_payload_in_packet,\n            required_allocation_bytes\n        });\n\n        const uint8_t* payload_start = raw_packet + sizeof(RawTelemetryPacketHeader);\n        for (size_t i = 0; i < bytes_to_copy; ++i) {\n            reinterpret_cast<uint8_t*>(data_buffer)[i] = payload_start[i];\n        }\n\n        current_data_count = bytes_to_copy / sizeof(ProcessedTelemetryData);\n\n        return true;\n    }\n\n    const ProcessedTelemetryData* getTelemetryData() const { return data_buffer; }\n    uint16_t getTelemetryCount() const { return current_data_count; }\n\nprivate:\n    ProcessedTelemetryData* data_buffer;\n    uint16_t                buffer_capacity;\n    uint16_t                current_data_count;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n\ntypedef struct {\n    uint16_t packet_id;\n    uint16_t num_sensor_readings; \n} TelemetryPacketHeader;\n\nclass TelemetryProcessor {\npublic:\n    TelemetryProcessor() : sensor_data_buffer(nullptr), buffer_size(0) {}\n\n    ~TelemetryProcessor() {\n        if (sensor_data_buffer) {\n            free(sensor_data_buffer);\n            sensor_data_buffer = nullptr;\n        }\n    }\n\n    bool processTelemetryPacketVulnerable(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(TelemetryPacketHeader)) {\n            return false;\n        }\n\n        const TelemetryPacketHeader* header = reinterpret_cast<const TelemetryPacketHeader*>(packet_data);\n        uint16_t num_readings = header->num_sensor_readings;\n\n        size_t expected_payload_size = (size_t)num_readings * sizeof(uint16_t);\n        size_t expected_total_packet_size = sizeof(TelemetryPacketHeader) + expected_payload_size;\n\n        if (packet_length < expected_total_packet_size) {\n            return false;\n        }\n\n        if (sensor_data_buffer) {\n            free(sensor_data_buffer);\n            sensor_data_buffer = nullptr;\n            buffer_size = 0;\n        }\n\n        sensor_data_buffer = (uint16_t*)malloc(expected_payload_size);\n        if (!sensor_data_buffer) {\n            return false;\n        }\n        buffer_size = expected_payload_size;\n\n        const uint8_t* data_ptr = packet_data + sizeof(TelemetryPacketHeader);\n\n        for (uint16_t i = 0; i <= num_readings; ++i) {\n            sensor_data_buffer[i] = (uint16_t)(data_ptr[i * 2] | (data_ptr[i * 2 + 1] << 8));\n        }\n\n        return true;\n    }\n\n    const uint16_t* getSensorData() const { return sensor_data_buffer; }\n    size_t getBufferSize() const { return buffer_size; }\n\nprivate:\n    uint16_t* sensor_data_buffer;\n    size_t buffer_size;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n\ntypedef struct {\n    uint16_t packet_id;\n    uint16_t num_sensor_readings; \n} TelemetryPacketHeader;\n\nclass TelemetryProcessor {\npublic:\n    TelemetryProcessor() : sensor_data_buffer(nullptr), buffer_size(0) {}\n\n    ~TelemetryProcessor() {\n        if (sensor_data_buffer) {\n            free(sensor_data_buffer);\n            sensor_data_buffer = nullptr;\n        }\n    }\n\n    bool processTelemetryPacketFixed(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(TelemetryPacketHeader)) {\n            return false;\n        }\n\n        const TelemetryPacketHeader* header = reinterpret_cast<const TelemetryPacketHeader*>(packet_data);\n        uint16_t num_readings = header->num_sensor_readings;\n\n        static const uint16_t MAX_SENSOR_READINGS = 1024;\n        if (num_readings > MAX_SENSOR_READINGS) {\n            return false;\n        }\n\n        size_t expected_payload_size = (size_t)num_readings * sizeof(uint16_t);\n        size_t expected_total_packet_size = sizeof(TelemetryPacketHeader) + expected_payload_size;\n\n        if (num_readings > 0 && expected_payload_size / sizeof(uint16_t) != num_readings) {\n             return false;\n        }\n\n        if (packet_length < expected_total_packet_size) {\n            return false;\n        }\n\n        if (sensor_data_buffer) {\n            free(sensor_data_buffer);\n            sensor_data_buffer = nullptr;\n            buffer_size = 0;\n        }\n\n        sensor_data_buffer = (uint16_t*)malloc(expected_payload_size);\n        if (!sensor_data_buffer) {\n            return false;\n        }\n        buffer_size = expected_payload_size;\n\n        const uint8_t* data_ptr = packet_data + sizeof(TelemetryPacketHeader);\n\n        for (uint16_t i = 0; i < num_readings; ++i) {\n            sensor_data_buffer[i] = (uint16_t)(data_ptr[i * 2] | (data_ptr[i * 2 + 1] << 8));\n        }\n\n        return true;\n    }\n\n    const uint16_t* getSensorData() const { return sensor_data_buffer; }\n    size_t getBufferSize() const { return buffer_size; }\n\nprivate:\n    uint16_t* sensor_data_buffer;\n    size_t buffer_size;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n\ntypedef struct {\n    uint16_t record_id;\n    uint16_t data_size; \n} LogRecordHeader;\n\ntypedef struct {\n    uint32_t total_expected_payload_bytes; \n    uint16_t num_records;       \n} LogPacketHeader;\n\nclass VehicleLogProcessor {\npublic:\n    VehicleLogProcessor() :\n        internal_log_buffer(nullptr),\n        allocated_buffer_size(0) {}\n\n    ~VehicleLogProcessor() {\n        if (internal_log_buffer) {\n            delete[] internal_log_buffer;\n            internal_log_buffer = nullptr;\n        }\n    }\n\n    bool processLogPacketVulnerable(const uint8_t* raw_packet, size_t raw_packet_len) {\n        if (!raw_packet || raw_packet_len < sizeof(LogPacketHeader)) {\n            return false;\n        }\n\n        const LogPacketHeader* packet_header = reinterpret_cast<const LogPacketHeader*>(raw_packet);\n\n        if (raw_packet_len < (sizeof(LogPacketHeader) + packet_header->total_expected_payload_bytes)) {\n            return false;\n        }\n\n        if (internal_log_buffer) {\n            delete[] internal_log_buffer;\n        }\n        internal_log_buffer = new (std::nothrow) uint8_t[packet_header->total_expected_payload_bytes];\n        if (!internal_log_buffer) {\n            return false;\n        }\n        allocated_buffer_size = packet_header->total_expected_payload_bytes;\n\n        size_t current_raw_read_offset = sizeof(LogPacketHeader);\n        size_t current_internal_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_header->num_records; ++i) {\n            if (current_raw_read_offset + sizeof(LogRecordHeader) > raw_packet_len) {\n                return false;\n            }\n            const LogRecordHeader* record_header = reinterpret_cast<const LogRecordHeader*>(raw_packet + current_raw_read_offset);\n\n            uint16_t record_data_len = record_header->data_size;\n\n            for (uint16_t j = 0; j < record_data_len; ++j) {\n                internal_log_buffer[current_internal_write_offset + j] = raw_packet[current_raw_read_offset + sizeof(LogRecordHeader) + j];\n            }\n\n            current_raw_read_offset += sizeof(LogRecordHeader) + record_data_len;\n            current_internal_write_offset += record_data_len;\n\n            if (current_raw_read_offset > raw_packet_len) {\n                return false;\n            }\n        }\n\n        if (current_internal_write_offset > allocated_buffer_size) {\n            return false;\n        }\n        \n        if (current_internal_write_offset != packet_header->total_expected_payload_bytes) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getLogBuffer() const {\n        return internal_log_buffer;\n    }\n\n    size_t getAllocatedSize() const {\n        return allocated_buffer_size;\n    }\n\nprivate:\n    uint8_t* internal_log_buffer;\n    size_t allocated_buffer_size;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <algorithm>\n\ntypedef struct {\n    uint16_t record_id;\n    uint16_t data_size; \n} LogRecordHeader;\n\ntypedef struct {\n    uint32_t total_expected_payload_bytes; \n    uint16_t num_records;       \n} LogPacketHeader;\n\nclass VehicleLogProcessorFixed {\npublic:\n    VehicleLogProcessorFixed() :\n        internal_log_buffer(nullptr),\n        allocated_buffer_size(0) {}\n\n    ~VehicleLogProcessorFixed() {\n        if (internal_log_buffer) {\n            delete[] internal_log_buffer;\n            internal_log_buffer = nullptr;\n        }\n    }\n\n    bool processLogPacketFixed(const uint8_t* raw_packet, size_t raw_packet_len) {\n        if (!raw_packet || raw_packet_len < sizeof(LogPacketHeader)) {\n            return false;\n        }\n\n        const LogPacketHeader* packet_header = reinterpret_cast<const LogPacketHeader*>(raw_packet);\n\n        static const uint32_t MAX_EXPECTED_PAYLOAD_SIZE = 16 * 1024; \n        if (packet_header->total_expected_payload_bytes == 0 || packet_header->total_expected_payload_bytes > MAX_EXPECTED_PAYLOAD_SIZE) {\n            return false;\n        }\n\n        if (raw_packet_len < (sizeof(LogPacketHeader) + packet_header->total_expected_payload_bytes)) {\n            return false;\n        }\n\n        if (internal_log_buffer) {\n            delete[] internal_log_buffer;\n        }\n        internal_log_buffer = new (std::nothrow) uint8_t[packet_header->total_expected_payload_bytes];\n        if (!internal_log_buffer) {\n            return false;\n        }\n        allocated_buffer_size = packet_header->total_expected_payload_bytes;\n\n        size_t current_raw_read_offset = sizeof(LogPacketHeader);\n        size_t current_internal_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_header->num_records; ++i) {\n            if (current_raw_read_offset + sizeof(LogRecordHeader) > raw_packet_len) {\n                return false;\n            }\n            const LogRecordHeader* record_header = reinterpret_cast<const LogRecordHeader*>(raw_packet + current_raw_read_offset);\n\n            uint16_t record_data_len = record_header->data_size;\n\n            if (current_raw_read_offset + sizeof(LogRecordHeader) + record_data_len > raw_packet_len) {\n                return false;\n            }\n\n            if (current_internal_write_offset + record_data_len > allocated_buffer_size) {\n                return false;\n            }\n\n            for (uint16_t j = 0; j < record_data_len; ++j) {\n                internal_log_buffer[current_internal_write_offset + j] = raw_packet[current_raw_read_offset + sizeof(LogRecordHeader) + j];\n            }\n\n            current_raw_read_offset += sizeof(LogRecordHeader) + record_data_len;\n            current_internal_write_offset += record_data_len;\n        }\n\n        if (current_internal_write_offset != packet_header->total_expected_payload_bytes) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getLogBuffer() const {\n        return internal_log_buffer;\n    }\n\n    size_t getAllocatedSize() const {\n        return allocated_buffer_size;\n    }\n\nprivate:\n    uint8_t* internal_log_buffer;\n    size_t allocated_buffer_size;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n\ntypedef struct {\n    uint16_t param_id;\n    uint32_t payload_len;\n} ParameterHeader;\n\nclass VehicleDataAggregator {\npublic:\n    VehicleDataAggregator() : m_aggregated_data(nullptr), m_current_total_bytes(0), m_allocated_capacity_bytes(0) {}\n\n    ~VehicleDataAggregator() {\n        clear();\n    }\n\n    void clear() {\n        if (m_aggregated_data) {\n            delete[] m_aggregated_data;\n            m_aggregated_data = nullptr;\n        }\n        m_current_total_bytes = 0;\n        m_allocated_capacity_bytes = 0;\n    }\n\n    bool appendParameterBlockVulnerable(const uint8_t* raw_param_block, size_t block_length) {\n        if (!raw_param_block || block_length < sizeof(ParameterHeader)) {\n            return false;\n        }\n\n        const ParameterHeader* header = reinterpret_cast<const ParameterHeader*>(raw_param_block);\n        uint32_t incoming_payload_len = header->payload_len;\n\n        uint32_t required_new_total_size = m_current_total_bytes + incoming_payload_len; \n\n        if (block_length < sizeof(ParameterHeader) + incoming_payload_len) {\n            return false;\n        }\n        \n        if (required_new_total_size > m_allocated_capacity_bytes) {\n            uint8_t* new_buffer = new (std::nothrow) uint8_t[required_new_total_size];\n            if (!new_buffer) {\n                return false;\n            }\n            if (m_aggregated_data) {\n                memcpy(new_buffer, m_aggregated_data, m_current_total_bytes);\n                delete[] m_aggregated_data;\n            }\n            m_aggregated_data = new_buffer;\n            m_allocated_capacity_bytes = required_new_total_size;\n        }\n\n        memcpy(m_aggregated_data + m_current_total_bytes, raw_param_block + sizeof(ParameterHeader), incoming_payload_len);\n\n        m_current_total_bytes = required_new_total_size;\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedData() const {\n        return m_aggregated_data;\n    }\n\n    uint32_t getTotalAggregatedBytes() const {\n        return m_current_total_bytes;\n    }\n\nprivate:\n    uint8_t* m_aggregated_data;\n    uint32_t m_current_total_bytes;\n    uint32_t m_allocated_capacity_bytes;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n#include <limits>\n\ntypedef struct {\n    uint16_t param_id;\n    uint32_t payload_len;\n} ParameterHeader;\n\nclass VehicleDataAggregator {\npublic:\n    VehicleDataAggregator() : m_aggregated_data(nullptr), m_current_total_bytes(0), m_allocated_capacity_bytes(0) {}\n\n    ~VehicleDataAggregator() {\n        clear();\n    }\n\n    void clear() {\n        if (m_aggregated_data) {\n            delete[] m_aggregated_data;\n            m_aggregated_data = nullptr;\n        }\n        m_current_total_bytes = 0;\n        m_allocated_capacity_bytes = 0;\n    }\n\n    bool appendParameterBlockFixed(const uint8_t* raw_param_block, size_t block_length) {\n        if (!raw_param_block || block_length < sizeof(ParameterHeader)) {\n            return false;\n        }\n\n        const ParameterHeader* header = reinterpret_cast<const ParameterHeader*>(raw_param_block);\n        uint32_t incoming_payload_len = header->payload_len;\n\n        if (std::numeric_limits<uint32_t>::max() - incoming_payload_len < m_current_total_bytes) {\n            return false;\n        }\n\n        uint32_t required_new_total_size = m_current_total_bytes + incoming_payload_len; \n\n        if (block_length < sizeof(ParameterHeader) + incoming_payload_len) {\n            return false;\n        }\n        \n        if (required_new_total_size > m_allocated_capacity_bytes) {\n            uint8_t* new_buffer = new (std::nothrow) uint8_t[required_new_total_size];\n            if (!new_buffer) {\n                return false;\n            }\n            if (m_aggregated_data) {\n                memcpy(new_buffer, m_aggregated_data, m_current_total_bytes);\n                delete[] m_aggregated_data;\n            }\n            m_aggregated_data = new_buffer;\n            m_allocated_capacity_bytes = required_new_total_size;\n        }\n\n        memcpy(m_aggregated_data + m_current_total_bytes, raw_param_block + sizeof(ParameterHeader), incoming_payload_len);\n\n        m_current_total_bytes = required_new_total_size;\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedData() const {\n        return m_aggregated_data;\n    }\n\n    uint32_t getTotalAggregatedBytes() const {\n        return m_current_total_bytes;\n    }\n\nprivate:\n    uint8_t* m_aggregated_data;\n    uint32_t m_current_total_bytes;\n    uint32_t m_allocated_capacity_bytes;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <stdint.h>\n#include <stdlib.h>\n\n#define CHUNK_SIZE_BYTES 64\n\ntypedef struct {\n    uint32_t block_id;\n    uint32_t num_chunks; \n    uint32_t reserved; \n} DataBlockHeader;\n\nclass FirmwareUpdaterVulnerable {\npublic:\n    FirmwareUpdaterVulnerable() : firmware_buffer(nullptr), current_buffer_size(0) {}\n\n    ~FirmwareUpdaterVulnerable() {\n        if (firmware_buffer) {\n            free(firmware_buffer);\n            firmware_buffer = nullptr;\n        }\n    }\n\n    bool processFirmwareBlockVulnerable(const uint8_t* block_data, size_t data_len) {\n        if (!block_data || data_len < sizeof(DataBlockHeader)) {\n            return false;\n        }\n\n        const DataBlockHeader* header = reinterpret_cast<const DataBlockHeader*>(block_data);\n        uint32_t num_chunks = header->num_chunks;\n\n        uint32_t total_payload_size = num_chunks * CHUNK_SIZE_BYTES;\n\n        if (data_len < sizeof(DataBlockHeader) + total_payload_size) {\n            return false;\n        }\n\n        if (firmware_buffer) {\n            free(firmware_buffer);\n            firmware_buffer = nullptr;\n        }\n\n        firmware_buffer = (uint8_t*)malloc(total_payload_size);\n        if (!firmware_buffer) {\n            return false;\n        }\n        current_buffer_size = total_payload_size;\n\n        const uint8_t* source_data_ptr = block_data + sizeof(DataBlockHeader);\n        for (uint32_t i = 0; i < total_payload_size; ++i) {\n            firmware_buffer[i] = source_data_ptr[i];\n        }\n\n        return true;\n    }\n\n    const uint8_t* getFirmwareBuffer() const { return firmware_buffer; }\n    size_t getBufferSize() const { return current_buffer_size; }\n\nprivate:\n    uint8_t* firmware_buffer;\n    size_t current_buffer_size;\n};",
    "fixed_code": "#include <stdint.h>\n#include <stdlib.h>\n#include <limits> \n\n#define CHUNK_SIZE_BYTES 64\n\ntypedef struct {\n    uint32_t block_id;\n    uint32_t num_chunks; \n    uint32_t reserved; \n} DataBlockHeader;\n\nclass FirmwareUpdaterFixed {\npublic:\n    FirmwareUpdaterFixed() : firmware_buffer(nullptr), current_buffer_size(0) {}\n\n    ~FirmwareUpdaterFixed() {\n        if (firmware_buffer) {\n            free(firmware_buffer);\n            firmware_buffer = nullptr;\n        }\n    }\n\n    bool processFirmwareBlockFixed(const uint8_t* block_data, size_t data_len) {\n        if (!block_data || data_len < sizeof(DataBlockHeader)) {\n            return false;\n        }\n\n        const DataBlockHeader* header = reinterpret_cast<const DataBlockHeader*>(block_data);\n        uint32_t num_chunks = header->num_chunks;\n\n        if (CHUNK_SIZE_BYTES == 0 || num_chunks > (std::numeric_limits<uint32_t>::max() / CHUNK_SIZE_BYTES)) {\n            return false;\n        }\n\n        uint32_t total_payload_size = num_chunks * CHUNK_SIZE_BYTES;\n\n        if (data_len < sizeof(DataBlockHeader) + total_payload_size) {\n            return false;\n        }\n\n        if (firmware_buffer) {\n            free(firmware_buffer);\n            firmware_buffer = nullptr;\n        }\n\n        firmware_buffer = (uint8_t*)malloc(total_payload_size);\n        if (!firmware_buffer) {\n            return false;\n        }\n        current_buffer_size = total_payload_size;\n\n        const uint8_t* source_data_ptr = block_data + sizeof(DataBlockHeader);\n        for (uint32_t i = 0; i < total_payload_size; ++i) {\n            firmware_buffer[i] = source_data_ptr[i];\n        }\n\n        return true;\n    }\n\n    const uint8_t* getFirmwareBuffer() const { return firmware_buffer; }\n    size_t getBufferSize() const { return current_buffer_size; }\n\nprivate:\n    uint8_t* firmware_buffer;\n    size_t current_buffer_size;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <new>\n\nstruct DiagnosticLogEntry {\n    uint32_t timestamp;\n    uint16_t event_code;\n    char*    description;\n    size_t   description_buffer_capacity;\n};\n\nstruct LogBatchPacketHeader {\n    uint16_t num_messages;\n    uint16_t global_max_description_len;\n    uint32_t total_payload_bytes;\n};\n\nstruct IndividualMessageData {\n    uint32_t timestamp;\n    uint16_t event_code;\n    uint16_t actual_description_len;\n};\n\nclass DiagnosticLogger {\npublic:\n    DiagnosticLogger() = default;\n\n    ~DiagnosticLogger() {\n        clearLogEntries();\n    }\n\n    void clearLogEntries() {\n        for (auto& entry : m_log_entries) {\n            if (entry.description) {\n                delete[] entry.description;\n            }\n        }\n        m_log_entries.clear();\n    }\n\n    bool processLogBatchVulnerable(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(LogBatchPacketHeader)) {\n            return false;\n        }\n\n        const LogBatchPacketHeader* header = reinterpret_cast<const LogBatchPacketHeader*>(packet_data);\n\n        if (header->total_payload_bytes > (packet_length - sizeof(LogBatchPacketHeader))) {\n            return false;\n        }\n\n        clearLogEntries();\n\n        const uint8_t* current_payload_ptr = packet_data + sizeof(LogBatchPacketHeader);\n        size_t remaining_payload_data = header->total_payload_bytes;\n\n        for (uint16_t i = 0; i < header->num_messages; ++i) {\n            if (remaining_payload_data < sizeof(IndividualMessageData)) {\n                return false;\n            }\n\n            const IndividualMessageData* msg_header = reinterpret_cast<const IndividualMessageData*>(current_payload_ptr);\n            \n            size_t alloc_size_for_description = header->global_max_description_len + 1;\n            if (alloc_size_for_description == 0) {\n                 alloc_size_for_description = 1;\n            }\n            \n            DiagnosticLogEntry new_entry;\n            new_entry.timestamp = msg_header->timestamp;\n            new_entry.event_code = msg_header->event_code;\n            new_entry.description = new (std::nothrow) char[alloc_size_for_description];\n            new_entry.description_buffer_capacity = alloc_size_for_description;\n\n            if (!new_entry.description) {\n                clearLogEntries();\n                return false;\n            }\n\n            current_payload_ptr += sizeof(IndividualMessageData);\n            remaining_payload_data -= sizeof(IndividualMessageData);\n\n            if (remaining_payload_data < msg_header->actual_description_len) {\n                delete[] new_entry.description;\n                return false;\n            }\n            \n            for (uint16_t k = 0; k < msg_header->actual_description_len; ++k) {\n                new_entry.description[k] = static_cast<char>(current_payload_ptr[k]);\n            }\n            new_entry.description[msg_header->actual_description_len] = '\\0';\n\n            current_payload_ptr += msg_header->actual_description_len;\n            remaining_payload_data -= msg_header->actual_description_len;\n\n            m_log_entries.push_back(new_entry);\n        }\n\n        return true;\n    }\n\n    const std::vector<DiagnosticLogEntry>& getLogEntries() const {\n        return m_log_entries;\n    }\n\nprivate:\n    std::vector<DiagnosticLogEntry> m_log_entries;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <new>\n#include <algorithm>\n\nstruct DiagnosticLogEntry {\n    uint32_t timestamp;\n    uint16_t event_code;\n    char*    description;\n    size_t   description_buffer_capacity;\n};\n\nstruct LogBatchPacketHeader {\n    uint16_t num_messages;\n    uint16_t global_max_description_len;\n    uint32_t total_payload_bytes;\n};\n\nstruct IndividualMessageData {\n    uint32_t timestamp;\n    uint16_t event_code;\n    uint16_t actual_description_len;\n};\n\nclass DiagnosticLogger {\npublic:\n    DiagnosticLogger() = default;\n\n    ~DiagnosticLogger() {\n        clearLogEntries();\n    }\n\n    void clearLogEntries() {\n        for (auto& entry : m_log_entries) {\n            if (entry.description) {\n                delete[] entry.description;\n            }\n        }\n        m_log_entries.clear();\n    }\n\n    bool processLogBatchFixed(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(LogBatchPacketHeader)) {\n            return false;\n        }\n\n        const LogBatchPacketHeader* header = reinterpret_cast<const LogBatchPacketHeader*>(packet_data);\n\n        if (header->total_payload_bytes > (packet_length - sizeof(LogBatchPacketHeader))) {\n            return false;\n        }\n\n        static const uint16_t MAX_SINGLE_DESCRIPTION_HARD_LIMIT = 511;\n        if (header->global_max_description_len > MAX_SINGLE_DESCRIPTION_HARD_LIMIT) {\n            return false;\n        }\n        \n        clearLogEntries();\n\n        const uint8_t* current_payload_ptr = packet_data + sizeof(LogBatchPacketHeader);\n        size_t remaining_payload_data = header->total_payload_bytes;\n\n        for (uint16_t i = 0; i < header->num_messages; ++i) {\n            if (remaining_payload_data < sizeof(IndividualMessageData)) {\n                return false;\n            }\n\n            const IndividualMessageData* msg_header = reinterpret_cast<const IndividualMessageData*>(current_payload_ptr);\n\n            if (msg_header->actual_description_len > MAX_SINGLE_DESCRIPTION_HARD_LIMIT) {\n                return false;\n            }\n\n            if (remaining_payload_data - sizeof(IndividualMessageData) < msg_header->actual_description_len) {\n                return false;\n            }\n\n            size_t alloc_size_for_description = header->global_max_description_len + 1;\n            if (alloc_size_for_description == 0) {\n                 alloc_size_for_description = 1;\n            }\n\n            DiagnosticLogEntry new_entry;\n            new_entry.timestamp = msg_header->timestamp;\n            new_entry.event_code = msg_header->event_code;\n            new_entry.description = new (std::nothrow) char[alloc_size_for_description];\n            new_entry.description_buffer_capacity = alloc_size_for_description;\n\n            if (!new_entry.description) {\n                clearLogEntries();\n                return false;\n            }\n\n            current_payload_ptr += sizeof(IndividualMessageData);\n            remaining_payload_data -= sizeof(IndividualMessageData);\n\n            size_t bytes_to_copy = std::min({\n                static_cast<size_t>(msg_header->actual_description_len),\n                static_cast<size_t>(alloc_size_for_description - 1),\n                remaining_payload_data\n            });\n            \n            for (size_t k = 0; k < bytes_to_copy; ++k) {\n                new_entry.description[k] = static_cast<char>(current_payload_ptr[k]);\n            }\n            new_entry.description[bytes_to_copy] = '\\0';\n\n            current_payload_ptr += msg_header->actual_description_len;\n            remaining_payload_data -= msg_header->actual_description_len;\n\n            m_log_entries.push_back(new_entry);\n        }\n\n        return true;\n    }\n\n    const std::vector<DiagnosticLogEntry>& getLogEntries() const {\n        return m_log_entries;\n    }\n\nprivate:\n    std::vector<DiagnosticLogEntry> m_log_entries;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n\n#define MAX_CONFIG_PAYLOAD_SIZE 4096\n\ntypedef struct {\n    uint16_t total_payload_size;\n    uint16_t num_entries;\n} PacketHeaderVulnerable;\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t data_length;\n} ConfigEntryHeaderVulnerable;\n\nclass VehicleConfigProcessorVulnerable {\npublic:\n    VehicleConfigProcessorVulnerable() : processed_config_data(nullptr), current_data_offset(0) {}\n\n    ~VehicleConfigProcessorVulnerable() {\n        if (processed_config_data) {\n            free(processed_config_data);\n            processed_config_data = nullptr;\n        }\n    }\n\n    bool processConfigPacketVulnerable(const uint8_t* raw_packet, size_t raw_len) {\n        if (processed_config_data) {\n            free(processed_config_data);\n            processed_config_data = nullptr;\n        }\n\n        if (!raw_packet || raw_len < sizeof(PacketHeaderVulnerable)) {\n            return false;\n        }\n\n        const PacketHeaderVulnerable* pkt_header = reinterpret_cast<const PacketHeaderVulnerable*>(raw_packet);\n\n        if (pkt_header->total_payload_size > MAX_CONFIG_PAYLOAD_SIZE || pkt_header->total_payload_size == 0) {\n            return false;\n        }\n\n        size_t expected_min_raw_len = sizeof(PacketHeaderVulnerable) + (size_t)pkt_header->num_entries * sizeof(ConfigEntryHeaderVulnerable);\n        if (raw_len < expected_min_raw_len) {\n            return false;\n        }\n\n        processed_config_data = (uint8_t*)malloc(pkt_header->total_payload_size);\n        if (!processed_config_data) {\n            return false;\n        }\n        current_data_offset = 0;\n\n        size_t current_parse_offset = sizeof(PacketHeaderVulnerable);\n\n        for (uint16_t i = 0; i < pkt_header->num_entries; ++i) {\n            if (current_parse_offset + sizeof(ConfigEntryHeaderVulnerable) > raw_len) {\n                free(processed_config_data); processed_config_data = nullptr;\n                return false;\n            }\n\n            const ConfigEntryHeaderVulnerable* entry_header = \n                reinterpret_cast<const ConfigEntryHeaderVulnerable*>(raw_packet + current_parse_offset);\n            \n            if (current_parse_offset + sizeof(ConfigEntryHeaderVulnerable) + entry_header->data_length > raw_len) {\n                free(processed_config_data); processed_config_data = nullptr;\n                return false;\n            }\n\n            \n            for (uint16_t k = 0; k < entry_header->data_length; ++k) {\n                processed_config_data[current_data_offset + k] = \n                    raw_packet[current_parse_offset + sizeof(ConfigEntryHeaderVulnerable) + k];\n            }\n            current_data_offset += entry_header->data_length;\n            current_parse_offset += sizeof(ConfigEntryHeaderVulnerable) + entry_header->data_length;\n        }\n        \n        if (current_data_offset != pkt_header->total_payload_size) {\n            free(processed_config_data); processed_config_data = nullptr;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedConfigData() const { return processed_config_data; }\n    size_t getProcessedDataLength() const { return current_data_offset; }\n\nprivate:\n    uint8_t* processed_config_data;\n    size_t current_data_offset;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n\n#define MAX_CONFIG_PAYLOAD_SIZE 4096\n\ntypedef struct {\n    uint16_t total_payload_size;\n    uint16_t num_entries;\n} PacketHeaderFixed;\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t data_length;\n} ConfigEntryHeaderFixed;\n\nclass VehicleConfigProcessorFixed {\npublic:\n    VehicleConfigProcessorFixed() : processed_config_data(nullptr), current_data_offset(0), allocated_payload_size(0) {}\n\n    ~VehicleConfigProcessorFixed() {\n        if (processed_config_data) {\n            free(processed_config_data);\n            processed_config_data = nullptr;\n        }\n    }\n\n    bool processConfigPacketFixed(const uint8_t* raw_packet, size_t raw_len) {\n        if (processed_config_data) {\n            free(processed_config_data);\n            processed_config_data = nullptr;\n            allocated_payload_size = 0;\n        }\n\n        if (!raw_packet || raw_len < sizeof(PacketHeaderFixed)) {\n            return false;\n        }\n\n        const PacketHeaderFixed* pkt_header = reinterpret_cast<const PacketHeaderFixed*>(raw_packet);\n\n        if (pkt_header->total_payload_size > MAX_CONFIG_PAYLOAD_SIZE || pkt_header->total_payload_size == 0) {\n            return false;\n        }\n        \n        size_t expected_min_raw_len = sizeof(PacketHeaderFixed) + (size_t)pkt_header->num_entries * sizeof(ConfigEntryHeaderFixed);\n        if (raw_len < expected_min_raw_len) {\n            return false;\n        }\n\n        processed_config_data = (uint8_t*)malloc(pkt_header->total_payload_size);\n        if (!processed_config_data) {\n            allocated_payload_size = 0;\n            return false;\n        }\n        allocated_payload_size = pkt_header->total_payload_size;\n        current_data_offset = 0;\n\n        size_t current_parse_offset = sizeof(PacketHeaderFixed);\n\n        for (uint16_t i = 0; i < pkt_header->num_entries; ++i) {\n            if (current_parse_offset + sizeof(ConfigEntryHeaderFixed) > raw_len) {\n                free(processed_config_data); processed_config_data = nullptr; allocated_payload_size = 0;\n                return false;\n            }\n\n            const ConfigEntryHeaderFixed* entry_header = \n                reinterpret_cast<const ConfigEntryHeaderFixed*>(raw_packet + current_parse_offset);\n            \n            if (entry_header->data_length > allocated_payload_size - current_data_offset) {\n                free(processed_config_data); processed_config_data = nullptr; allocated_payload_size = 0;\n                return false;\n            }\n\n            if (current_parse_offset + sizeof(ConfigEntryHeaderFixed) + entry_header->data_length > raw_len) {\n                free(processed_config_data); processed_config_data = nullptr; allocated_payload_size = 0;\n                return false;\n            }\n            \n            for (uint16_t k = 0; k < entry_header->data_length; ++k) {\n                processed_config_data[current_data_offset + k] = \n                    raw_packet[current_parse_offset + sizeof(ConfigEntryHeaderFixed) + k];\n            }\n            current_data_offset += entry_header->data_length;\n            current_parse_offset += sizeof(ConfigEntryHeaderFixed) + entry_header->data_length;\n        }\n        \n        if (current_data_offset != pkt_header->total_payload_size) {\n            free(processed_config_data); processed_config_data = nullptr; allocated_payload_size = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedConfigData() const { return processed_config_data; }\n    size_t getProcessedDataLength() const { return current_data_offset; }\n\nprivate:\n    uint8_t* processed_config_data;\n    size_t current_data_offset;\n    size_t allocated_payload_size;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <string.h>\n\nstruct DiagnosticEvent {\n    uint32_t timestamp;\n    uint16_t event_code;\n    char*    details;\n};\n\nclass DiagnosticEventRecorderVulnerable {\nprivate:\n    DiagnosticEvent* m_events;\n    size_t m_event_count;\n    size_t m_capacity;\n\npublic:\n    DiagnosticEventRecorderVulnerable() : m_events(nullptr), m_event_count(0), m_capacity(0) {\n        m_capacity = 10; \n        m_events = (DiagnosticEvent*)malloc(m_capacity * sizeof(DiagnosticEvent));\n        if (!m_events) {\n            m_capacity = 0;\n        }\n    }\n\n    ~DiagnosticEventRecorderVulnerable() {\n        for (size_t i = 0; i < m_event_count; ++i) {\n            if (m_events[i].details) {\n                free(m_events[i].details);\n            }\n        }\n        if (m_events) {\n            free(m_events);\n        }\n    }\n\n    bool addEventVulnerable(uint32_t timestamp, uint16_t event_code, const char* details_str, uint16_t details_len_from_packet) {\n        if (!details_str || details_len_from_packet == 0) {\n            return false;\n        }\n        \n        if (details_len_from_packet > 255) { \n            return false;\n        }\n\n        if (m_event_count >= m_capacity) {\n            size_t new_capacity = m_capacity * 2;\n            if (new_capacity == 0) new_capacity = 1; \n            DiagnosticEvent* new_events = (DiagnosticEvent*)realloc(m_events, new_capacity * sizeof(DiagnosticEvent));\n            if (!new_events) {\n                return false;\n            }\n            m_events = new_events;\n            m_capacity = new_capacity;\n        }\n\n        DiagnosticEvent new_event;\n        new_event.timestamp = timestamp;\n        new_event.event_code = event_code;\n\n        new_event.details = (char*)malloc(details_len_from_packet);\n        if (!new_event.details) {\n            return false;\n        }\n\n        for (uint16_t i = 0; i < details_len_from_packet; ++i) {\n            new_event.details[i] = details_str[i];\n        }\n        new_event.details[details_len_from_packet] = '\\0';\n\n        m_events[m_event_count++] = new_event;\n        return true;\n    }\n\n    size_t getEventCount() const { return m_event_count; }\n    const DiagnosticEvent* getEvent(size_t index) const {\n        if (index < m_event_count) return &m_events[index];\n        return nullptr;\n    }\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <string.h>\n\nstruct DiagnosticEvent {\n    uint32_t timestamp;\n    uint16_t event_code;\n    char*    details;\n};\n\nclass DiagnosticEventRecorderFixed {\nprivate:\n    DiagnosticEvent* m_events;\n    size_t m_event_count;\n    size_t m_capacity;\n\npublic:\n    DiagnosticEventRecorderFixed() : m_events(nullptr), m_event_count(0), m_capacity(0) {\n        m_capacity = 10; \n        m_events = (DiagnosticEvent*)malloc(m_capacity * sizeof(DiagnosticEvent));\n        if (!m_events) {\n            m_capacity = 0;\n        }\n    }\n\n    ~DiagnosticEventRecorderFixed() {\n        for (size_t i = 0; i < m_event_count; ++i) {\n            if (m_events[i].details) {\n                free(m_events[i].details);\n            }\n        }\n        if (m_events) {\n            free(m_events);\n        }\n    }\n\n    bool addEventFixed(uint32_t timestamp, uint16_t event_code, const char* details_str, uint16_t details_len_from_packet) {\n        if (!details_str || details_len_from_packet == 0) {\n            return false;\n        }\n        \n        if (details_len_from_packet > 255) {\n            return false;\n        }\n\n        if (m_event_count >= m_capacity) {\n            size_t new_capacity = m_capacity * 2;\n            if (new_capacity == 0) new_capacity = 1;\n            DiagnosticEvent* new_events = (DiagnosticEvent*)realloc(m_events, new_capacity * sizeof(DiagnosticEvent));\n            if (!new_events) {\n                return false;\n            }\n            m_events = new_events;\n            m_capacity = new_capacity;\n        }\n\n        DiagnosticEvent new_event;\n        new_event.timestamp = timestamp;\n        new_event.event_code = event_code;\n\n        new_event.details = (char*)malloc(details_len_from_packet + 1);\n        if (!new_event.details) {\n            return false;\n        }\n        \n        for (uint16_t i = 0; i < details_len_from_packet; ++i) {\n            new_event.details[i] = details_str[i];\n        }\n        new_event.details[details_len_from_packet] = '\\0';\n\n        m_events[m_event_count++] = new_event;\n        return true;\n    }\n\n    size_t getEventCount() const { return m_event_count; }\n    const DiagnosticEvent* getEvent(size_t index) const {\n        if (index < m_event_count) return &m_events[index];\n        return nullptr;\n    }\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t details_length_bytes;\n} EventLogHeader;\n\nclass VehicleEventLogger {\npublic:\n    VehicleEventLogger() : m_log_buffer(nullptr), m_current_buffer_pos(0), m_allocated_capacity(0) {}\n\n    ~VehicleEventLogger() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n    }\n\n    void clearLogs() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n        m_log_buffer = nullptr;\n        m_current_buffer_pos = 0;\n        m_allocated_capacity = 0;\n    }\n\n    bool appendEventVulnerable(const uint8_t* raw_event_data, size_t data_packet_length) {\n        if (!raw_event_data || data_packet_length < sizeof(EventLogHeader)) {\n            return false;\n        }\n\n        const EventLogHeader* header = reinterpret_cast<const EventLogHeader*>(raw_event_data);\n        uint16_t details_len = header->details_length_bytes;\n\n        if (data_packet_length < sizeof(EventLogHeader) + details_len) {\n            return false;\n        }\n\n        size_t current_record_size_raw = sizeof(EventLogHeader) + details_len;\n        size_t padded_details_len = (details_len + 3) & ~3;\n        \n        size_t required_total_size = m_current_buffer_pos + current_record_size_raw;\n\n        if (required_total_size < m_current_buffer_pos) {\n            return false;\n        }\n        \n        if (required_total_size > m_allocated_capacity) {\n            size_t new_capacity = required_total_size;\n            if (new_capacity < 256) new_capacity = 256;\n            if (new_capacity < required_total_size) new_capacity = required_total_size;\n\n            uint8_t* temp_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n            if (!temp_buffer) {\n                if (m_log_buffer) {\n                    free(m_log_buffer);\n                    m_log_buffer = nullptr;\n                }\n                m_allocated_capacity = 0;\n                m_current_buffer_pos = 0;\n                return false;\n            }\n            m_log_buffer = temp_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        for (size_t i = 0; i < sizeof(EventLogHeader); ++i) {\n            m_log_buffer[m_current_buffer_pos + i] = raw_event_data[i];\n        }\n\n        const uint8_t* details_src_ptr = raw_event_data + sizeof(EventLogHeader);\n        uint8_t* details_dest_ptr = m_log_buffer + m_current_buffer_pos + sizeof(EventLogHeader);\n\n        for (uint16_t i = 0; i < details_len; ++i) {\n            details_dest_ptr[i] = details_src_ptr[i];\n        }\n\n        size_t padding_bytes = padded_details_len - details_len;\n        if (padding_bytes > 0) {\n            memset(details_dest_ptr + details_len, 0, padding_bytes);\n        }\n\n        m_current_buffer_pos += (sizeof(EventLogHeader) + padded_details_len);\n\n        return true;\n    }\n\n    size_t getTotalLoggedBytes() const {\n        return m_current_buffer_pos;\n    }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t   m_current_buffer_pos;\n    size_t   m_allocated_capacity;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t details_length_bytes;\n} EventLogHeader;\n\nclass VehicleEventLogger {\npublic:\n    VehicleEventLogger() : m_log_buffer(nullptr), m_current_buffer_pos(0), m_allocated_capacity(0) {}\n\n    ~VehicleEventLogger() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n    }\n\n    void clearLogs() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n        m_log_buffer = nullptr;\n        m_current_buffer_pos = 0;\n        m_allocated_capacity = 0;\n    }\n\n    bool appendEventFixed(const uint8_t* raw_event_data, size_t data_packet_length) {\n        if (!raw_event_data || data_packet_length < sizeof(EventLogHeader)) {\n            return false;\n        }\n\n        const EventLogHeader* header = reinterpret_cast<const EventLogHeader*>(raw_event_data);\n        uint16_t details_len = header->details_length_bytes;\n\n        static const uint16_t MAX_DETAILS_LENGTH = 4096;\n        if (details_len > MAX_DETAILS_LENGTH) {\n            return false;\n        }\n\n        if (data_packet_length < sizeof(EventLogHeader) + details_len) {\n            return false;\n        }\n\n        size_t padded_details_len = (details_len + 3) & ~3;\n        size_t current_record_size_padded = sizeof(EventLogHeader) + padded_details_len;\n        \n        size_t required_total_size;\n        if (m_current_buffer_pos > (SIZE_MAX - current_record_size_padded)) { \n            return false; \n        }\n        required_total_size = m_current_buffer_pos + current_record_size_padded;\n        \n        if (required_total_size > m_allocated_capacity) {\n            size_t new_capacity = required_total_size;\n            if (new_capacity < 256) new_capacity = 256;\n            if (new_capacity < required_total_size) new_capacity = required_total_size;\n\n            uint8_t* temp_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n            if (!temp_buffer) {\n                if (m_log_buffer) {\n                    free(m_log_buffer);\n                    m_log_buffer = nullptr;\n                }\n                m_allocated_capacity = 0;\n                m_current_buffer_pos = 0;\n                return false;\n            }\n            m_log_buffer = temp_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        for (size_t i = 0; i < sizeof(EventLogHeader); ++i) {\n            m_log_buffer[m_current_buffer_pos + i] = raw_event_data[i];\n        }\n\n        const uint8_t* details_src_ptr = raw_event_data + sizeof(EventLogHeader);\n        uint8_t* details_dest_ptr = m_log_buffer + m_current_buffer_pos + sizeof(EventLogHeader);\n\n        for (uint16_t i = 0; i < details_len; ++i) {\n            details_dest_ptr[i] = details_src_ptr[i];\n        }\n\n        size_t padding_bytes = padded_details_len - details_len;\n        if (padding_bytes > 0) {\n            memset(details_dest_ptr + details_len, 0, padding_bytes);\n        }\n\n        m_current_buffer_pos += current_record_size_padded;\n\n        return true;\n    }\n\n    size_t getTotalLoggedBytes() const {\n        return m_current_buffer_pos;\n    }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t   m_current_buffer_pos;\n    size_t   m_allocated_capacity;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n\n#pragma pack(push, 1)\n\nstruct VehicleCommandHeader {\n    uint16_t command_id;\n    uint16_t data_length;\n};\n\nstruct CommandBatchHeader {\n    uint32_t batch_id;\n    uint16_t num_commands;\n    uint32_t total_payload_bytes;\n};\n\n#pragma pack(pop)\n\nclass CommandBatchProcessor {\npublic:\n    CommandBatchProcessor() : m_processed_batch_data(nullptr), m_processed_data_size(0) {}\n\n    ~CommandBatchProcessor() {\n        if (m_processed_batch_data) {\n            delete[] m_processed_batch_data;\n            m_processed_batch_data = nullptr;\n        }\n    }\n\n    bool processCommandBatchVulnerable(const uint8_t* raw_batch_data, size_t raw_batch_data_len) {\n        if (!raw_batch_data || raw_batch_data_len < sizeof(CommandBatchHeader)) {\n            return false;\n        }\n\n        const CommandBatchHeader* batch_header = reinterpret_cast<const CommandBatchHeader*>(raw_batch_data);\n\n        if (batch_header->total_payload_bytes > (raw_batch_data_len - sizeof(CommandBatchHeader))) {\n            return false;\n        }\n\n        if (m_processed_batch_data) {\n            delete[] m_processed_batch_data;\n            m_processed_batch_data = nullptr;\n        }\n\n        m_processed_batch_data = new (std::nothrow) uint8_t[batch_header->total_payload_bytes];\n        if (!m_processed_batch_data) {\n            m_processed_data_size = 0;\n            return false;\n        }\n        m_processed_data_size = batch_header->total_payload_bytes;\n\n        size_t current_raw_offset = sizeof(CommandBatchHeader);\n        size_t current_processed_offset = 0;\n\n        for (uint16_t i = 0; i < batch_header->num_commands; ++i) {\n            if (current_raw_offset + sizeof(VehicleCommandHeader) > raw_batch_data_len) {\n                return false;\n            }\n\n            const VehicleCommandHeader* cmd_header = reinterpret_cast<const VehicleCommandHeader*>(raw_batch_data + current_raw_offset);\n            uint16_t current_cmd_data_len = cmd_header->data_length;\n\n            if (current_raw_offset + sizeof(VehicleCommandHeader) + current_cmd_data_len > raw_batch_data_len) {\n                return false;\n            }\n\n            memcpy(m_processed_batch_data + current_processed_offset, cmd_header, sizeof(VehicleCommandHeader));\n            current_processed_offset += sizeof(VehicleCommandHeader);\n\n            memcpy(m_processed_batch_data + current_processed_offset, raw_batch_data + current_raw_offset + sizeof(VehicleCommandHeader), current_cmd_data_len);\n            current_processed_offset += current_cmd_data_len;\n\n            current_raw_offset += sizeof(VehicleCommandHeader) + current_cmd_data_len;\n        }\n\n        if (current_processed_offset > m_processed_data_size) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedBatchData() const {\n        return m_processed_batch_data;\n    }\n\n    size_t getProcessedDataSize() const {\n        return m_processed_data_size;\n    }\n\nprivate:\n    uint8_t* m_processed_batch_data;\n    size_t m_processed_data_size;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n#include <limits>\n#include <algorithm>\n\n#pragma pack(push, 1)\n\nstruct VehicleCommandHeader {\n    uint16_t command_id;\n    uint16_t data_length;\n};\n\nstruct CommandBatchHeader {\n    uint32_t batch_id;\n    uint16_t num_commands;\n    uint32_t total_payload_bytes;\n};\n\n#pragma pack(pop)\n\nclass CommandBatchProcessorFixed {\npublic:\n    CommandBatchProcessorFixed() : m_processed_batch_data(nullptr), m_processed_data_size(0) {}\n\n    ~CommandBatchProcessorFixed() {\n        if (m_processed_batch_data) {\n            delete[] m_processed_batch_data;\n            m_processed_batch_data = nullptr;\n        }\n    }\n\n    bool processCommandBatchFixed(const uint8_t* raw_batch_data, size_t raw_batch_data_len) {\n        if (!raw_batch_data || raw_batch_data_len < sizeof(CommandBatchHeader)) {\n            return false;\n        }\n\n        const CommandBatchHeader* batch_header = reinterpret_cast<const CommandBatchHeader*>(raw_batch_data);\n\n        static const uint16_t MAX_COMMANDS_IN_BATCH = 100;\n        if (batch_header->num_commands == 0 || batch_header->num_commands > MAX_COMMANDS_IN_BATCH) {\n            return false;\n        }\n\n        uint32_t calculated_total_required_size = 0;\n        size_t temp_raw_offset = sizeof(CommandBatchHeader);\n\n        for (uint16_t i = 0; i < batch_header->num_commands; ++i) {\n            if (temp_raw_offset + sizeof(VehicleCommandHeader) > raw_batch_data_len) {\n                return false;\n            }\n\n            const VehicleCommandHeader* cmd_header = reinterpret_cast<const VehicleCommandHeader*>(raw_batch_data + temp_raw_offset);\n            uint16_t current_cmd_data_len = cmd_header->data_length;\n\n            if (current_cmd_data_len > (std::numeric_limits<uint32_t>::max() - sizeof(VehicleCommandHeader) - calculated_total_required_size)) {\n                return false;\n            }\n\n            calculated_total_required_size += sizeof(VehicleCommandHeader) + current_cmd_data_len;\n\n            temp_raw_offset += sizeof(VehicleCommandHeader) + current_cmd_data_len;\n\n            if (temp_raw_offset > raw_batch_data_len) {\n                return false;\n            }\n        }\n\n        if (batch_header->total_payload_bytes != calculated_total_required_size) {\n            return false;\n        }\n\n        static const uint32_t MAX_BATCH_DATA_SIZE = 64 * 1024;\n        if (calculated_total_required_size == 0 || calculated_total_required_size > MAX_BATCH_DATA_SIZE) {\n            return false;\n        }\n\n        if (m_processed_batch_data) {\n            delete[] m_processed_batch_data;\n            m_processed_batch_data = nullptr;\n        }\n\n        m_processed_batch_data = new (std::nothrow) uint8_t[calculated_total_required_size];\n        if (!m_processed_batch_data) {\n            m_processed_data_size = 0;\n            return false;\n        }\n        m_processed_data_size = calculated_total_required_size;\n\n        size_t current_raw_offset = sizeof(CommandBatchHeader);\n        size_t current_processed_offset = 0;\n\n        for (uint16_t i = 0; i < batch_header->num_commands; ++i) {\n            if (current_raw_offset + sizeof(VehicleCommandHeader) > raw_batch_data_len) {\n                return false;\n            }\n\n            const VehicleCommandHeader* cmd_header = reinterpret_cast<const VehicleCommandHeader*>(raw_batch_data + current_raw_offset);\n            uint16_t current_cmd_data_len = cmd_header->data_length;\n\n            if (current_raw_offset + sizeof(VehicleCommandHeader) + current_cmd_data_len > raw_batch_data_len) {\n                return false;\n            }\n\n            size_t bytes_to_copy_this_command = sizeof(VehicleCommandHeader) + current_cmd_data_len;\n            if (current_processed_offset > (std::numeric_limits<size_t>::max() - bytes_to_copy_this_command) ||\n                current_processed_offset + bytes_to_copy_this_command > m_processed_data_size) {\n                return false;\n            }\n\n            memcpy(m_processed_batch_data + current_processed_offset, cmd_header, sizeof(VehicleCommandHeader));\n            current_processed_offset += sizeof(VehicleCommandHeader);\n\n            memcpy(m_processed_batch_data + current_processed_offset, raw_batch_data + current_raw_offset + sizeof(VehicleCommandHeader), current_cmd_data_len);\n            current_processed_offset += current_cmd_data_len;\n\n            current_raw_offset += sizeof(VehicleCommandHeader) + current_cmd_data_len;\n        }\n\n        if (current_processed_offset != m_processed_data_size) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedBatchData() const {\n        return m_processed_batch_data;\n    }\n\n    size_t getProcessedDataSize() const {\n        return m_processed_data_size;\n    }\n\nprivate:\n    uint8_t* m_processed_batch_data;\n    size_t m_processed_data_size;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n// Represents a firmware update packet header\nstruct FirmwarePacketHeader {\n    uint32_t packet_magic;\n    uint32_t total_data_payload_size; \n    uint16_t num_modules;\n    uint8_t  _reserved[2];\n};\n\n// Represents a header for an individual firmware module within the payload\nstruct FirmwareModuleHeader {\n    uint16_t module_id;\n    uint16_t module_version;\n    uint32_t module_data_length;\n};\n\nclass FirmwareUpdater {\nprivate:\n    uint8_t* m_firmware_buffer;\n    size_t   m_allocated_size;\n\npublic:\n    FirmwareUpdater() : m_firmware_buffer(nullptr), m_allocated_size(0) {}\n\n    ~FirmwareUpdater() {\n        if (m_firmware_buffer) {\n            free(m_firmware_buffer);\n        }\n    }\n\n    void clearFirmwareBuffer() {\n        if (m_firmware_buffer) {\n            free(m_firmware_buffer);\n            m_firmware_buffer = nullptr;\n            m_allocated_size = 0;\n        }\n    }\n\n    bool processFirmwareUpdatePacketVulnerable(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(FirmwarePacketHeader)) {\n            return false;\n        }\n\n        const FirmwarePacketHeader* header = reinterpret_cast<const FirmwarePacketHeader*>(packet_data);\n\n        // Initial sanity check: Is the claimed total payload size within packet bounds?\n        // This check is insufficient for the heap overflow as the sum of module lengths might differ.\n        if (header->total_data_payload_size > (packet_length - sizeof(FirmwarePacketHeader))) {\n            return false;\n        }\n\n        clearFirmwareBuffer();\n\n        // Allocate buffer based on the total_data_payload_size from the packet header\n        m_firmware_buffer = (uint8_t*)malloc(header->total_data_payload_size);\n        if (!m_firmware_buffer) {\n            return false;\n        }\n        m_allocated_size = header->total_data_payload_size;\n\n        size_t current_packet_offset = sizeof(FirmwarePacketHeader);\n        size_t current_buffer_write_offset = 0;\n\n        for (uint16_t i = 0; i < header->num_modules; ++i) {\n            // Check if there's enough data in the raw packet for the module header\n            if (current_packet_offset + sizeof(FirmwareModuleHeader) > packet_length) {\n                clearFirmwareBuffer();\n                return false;\n            }\n\n            const FirmwareModuleHeader* module_hdr = reinterpret_cast<const FirmwareModuleHeader*>(packet_data + current_packet_offset);\n\n            // Advance packet offset past the module header\n            current_packet_offset += sizeof(FirmwareModuleHeader);\n            \n            // Check if there's enough data in the raw packet for the module's payload\n            if (current_packet_offset + module_hdr->module_data_length > packet_length) {\n                clearFirmwareBuffer();\n                return false;\n            }\n            \n            // Vulnerability: No check here that (current_buffer_write_offset + module_hdr->module_data_length)\n            // doesn't exceed m_allocated_size (which is header->total_data_payload_size).\n            // An attacker can craft a packet where the sum of module_hdr->module_data_length values\n            // for all modules exceeds header->total_data_payload_size, leading to a heap overflow\n            // during the memcpy, even if individual module_data_length values don't exceed\n            // the remaining packet length at that point.\n            memcpy(m_firmware_buffer + current_buffer_write_offset,\n                   packet_data + current_packet_offset,\n                   module_hdr->module_data_length);\n\n            current_packet_offset += module_hdr->module_data_length;\n            current_buffer_write_offset += module_hdr->module_data_length;\n        }\n        \n        // A check for current_buffer_write_offset > m_allocated_size here would be too late.\n\n        return true;\n    }\n\n    size_t getAllocatedFirmwareSize() const {\n        return m_allocated_size;\n    }\n\n    const uint8_t* getFirmwareBuffer() const {\n        return m_firmware_buffer;\n    }\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n// Represents a firmware update packet header\nstruct FirmwarePacketHeader {\n    uint32_t packet_magic;\n    uint32_t total_data_payload_size;\n    uint16_t num_modules;\n    uint8_t  _reserved[2];\n};\n\n// Represents a header for an individual firmware module within the payload\nstruct FirmwareModuleHeader {\n    uint16_t module_id;\n    uint16_t module_version;\n    uint32_t module_data_length;\n};\n\nclass FirmwareUpdater {\nprivate:\n    uint8_t* m_firmware_buffer;\n    size_t   m_allocated_size;\n\npublic:\n    FirmwareUpdater() : m_firmware_buffer(nullptr), m_allocated_size(0) {}\n\n    ~FirmwareUpdater() {\n        if (m_firmware_buffer) {\n            free(m_firmware_buffer);\n        }\n    }\n\n    void clearFirmwareBuffer() {\n        if (m_firmware_buffer) {\n            free(m_firmware_buffer);\n            m_firmware_buffer = nullptr;\n            m_allocated_size = 0;\n        }\n    }\n\n    bool processFirmwareUpdatePacketFixed(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(FirmwarePacketHeader)) {\n            return false;\n        }\n\n        const FirmwarePacketHeader* header = reinterpret_cast<const FirmwarePacketHeader*>(packet_data);\n\n        // Basic sanity check: Is the claimed total payload size within packet bounds?\n        if (header->total_data_payload_size > (packet_length - sizeof(FirmwarePacketHeader))) {\n            return false;\n        }\n        \n        // Add a sanity check for number of modules to prevent excessive loops or unrealistic values\n        static const uint16_t MAX_ALLOWED_MODULES = 100; \n        if (header->num_modules > MAX_ALLOWED_MODULES) {\n            return false;\n        }\n\n        clearFirmwareBuffer();\n\n        // Allocate buffer based on the total_data_payload_size from the packet header\n        // Ensure total_data_payload_size is not zero if modules are expected (or handle empty case).\n        if (header->total_data_payload_size == 0 && header->num_modules > 0) {\n            return false; \n        }\n\n        m_firmware_buffer = (uint8_t*)malloc(header->total_data_payload_size);\n        if (!m_firmware_buffer) {\n            return false;\n        }\n        m_allocated_size = header->total_data_payload_size;\n\n        size_t current_packet_offset = sizeof(FirmwarePacketHeader);\n        size_t current_buffer_write_offset = 0;\n\n        for (uint16_t i = 0; i < header->num_modules; ++i) {\n            // Check if there's enough data in the raw packet for the module header\n            if (current_packet_offset + sizeof(FirmwareModuleHeader) > packet_length) {\n                clearFirmwareBuffer();\n                return false;\n            }\n\n            const FirmwareModuleHeader* module_hdr = reinterpret_cast<const FirmwareModuleHeader*>(packet_data + current_packet_offset);\n\n            // Advance packet offset past the module header\n            current_packet_offset += sizeof(FirmwareModuleHeader);\n            \n            // Check if there's enough data in the raw packet for the module's payload\n            if (current_packet_offset + module_hdr->module_data_length > packet_length) {\n                clearFirmwareBuffer();\n                return false;\n            }\n\n            // FIX: Crucial check to prevent heap buffer overflow.\n            // Ensure the current write operation, including the data to be copied,\n            // does not exceed the bounds of the allocated buffer (m_allocated_size).\n            // Also check for potential integer overflow during the sum before comparison.\n            if (current_buffer_write_offset > SIZE_MAX - module_hdr->module_data_length ||\n                current_buffer_write_offset + module_hdr->module_data_length > m_allocated_size) {\n                clearFirmwareBuffer();\n                return false; \n            }\n            \n            memcpy(m_firmware_buffer + current_buffer_write_offset,\n                   packet_data + current_packet_offset,\n                   module_hdr->module_data_length);\n\n            current_packet_offset += module_hdr->module_data_length;\n            current_buffer_write_offset += module_hdr->module_data_length;\n        }\n        \n        // Final consistency check: Ensure the total data actually copied matches\n        // the total_data_payload_size from the packet header.\n        if (current_buffer_write_offset != header->total_data_payload_size) {\n            clearFirmwareBuffer();\n            return false;\n        }\n\n        return true;\n    }\n\n    size_t getAllocatedFirmwareSize() const {\n        return m_allocated_size;\n    }\n\n    const uint8_t* getFirmwareBuffer() const {\n        return m_firmware_buffer;\n    }\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\ntypedef struct {\n    uint16_t param_id;\n    uint16_t data_length;\n} ParameterEntryHeader;\n\nclass VehicleConfigurationManagerVulnerable {\npublic:\n    VehicleConfigurationManagerVulnerable() : m_config_buffer(nullptr), m_current_offset(0), m_allocated_capacity(0) {}\n\n    ~VehicleConfigurationManagerVulnerable() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n        }\n    }\n\n    bool addConfigurationParameterVulnerable(uint16_t param_id, const uint8_t* param_data, uint16_t data_len) {\n        if (!param_data || data_len == 0) {\n            return false;\n        }\n\n        size_t entry_total_size = sizeof(ParameterEntryHeader) + data_len;\n\n        size_t padded_data_len = (data_len + 3) & ~3;\n        size_t physical_entry_size = sizeof(ParameterEntryHeader) + padded_data_len;\n\n        if (m_current_offset > (SIZE_MAX - physical_entry_size)) {\n            return false;\n        }\n\n        if (m_config_buffer == nullptr) {\n            m_config_buffer = (uint8_t*)malloc(entry_total_size);\n            if (!m_config_buffer) return false;\n            m_allocated_capacity = entry_total_size;\n        } else if (m_current_offset + entry_total_size > m_allocated_capacity) {\n            uint8_t* temp_buffer = (uint8_t*)realloc(m_config_buffer, m_current_offset + entry_total_size);\n            if (!temp_buffer) {\n                free(m_config_buffer);\n                m_config_buffer = nullptr;\n                m_current_offset = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_config_buffer = temp_buffer;\n            m_allocated_capacity = m_current_offset + entry_total_size;\n        }\n\n        ParameterEntryHeader header_to_write = {param_id, data_len};\n        memcpy(m_config_buffer + m_current_offset, &header_to_write, sizeof(ParameterEntryHeader));\n        m_current_offset += sizeof(ParameterEntryHeader);\n\n        memcpy(m_config_buffer + m_current_offset, param_data, data_len);\n        m_current_offset += data_len;\n\n        size_t bytes_to_pad = padded_data_len - data_len;\n        if (bytes_to_pad > 0) {\n            memset(m_config_buffer + m_current_offset, 0, bytes_to_pad);\n            m_current_offset += bytes_to_pad;\n        }\n        \n        return true;\n    }\n\n    const uint8_t* getConfigurationBuffer() const { return m_config_buffer; }\n    size_t getCurrentOffset() const { return m_current_offset; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_config_buffer;\n    size_t   m_current_offset;\n    size_t   m_allocated_capacity;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\ntypedef struct {\n    uint16_t param_id;\n    uint16_t data_length;\n} ParameterEntryHeader;\n\nclass VehicleConfigurationManagerFixed {\npublic:\n    VehicleConfigurationManagerFixed() : m_config_buffer(nullptr), m_current_offset(0), m_allocated_capacity(0) {}\n\n    ~VehicleConfigurationManagerFixed() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n        }\n    }\n\n    bool addConfigurationParameterFixed(uint16_t param_id, const uint8_t* param_data, uint16_t data_len) {\n        if (!param_data || data_len == 0) {\n            return false;\n        }\n\n        size_t padded_data_len = (data_len + 3) & ~3;\n        size_t physical_entry_size = sizeof(ParameterEntryHeader) + padded_data_len;\n\n        if (physical_entry_size == 0 || m_current_offset > (SIZE_MAX - physical_entry_size)) {\n            return false;\n        }\n\n        size_t required_total_capacity = m_current_offset + physical_entry_size;\n\n        if (m_config_buffer == nullptr) {\n            m_config_buffer = (uint8_t*)malloc(required_total_capacity);\n            if (!m_config_buffer) return false;\n            m_allocated_capacity = required_total_capacity;\n        } else if (required_total_capacity > m_allocated_capacity) {\n            uint8_t* temp_buffer = (uint8_t*)realloc(m_config_buffer, required_total_capacity);\n            if (!temp_buffer) {\n                free(m_config_buffer);\n                m_config_buffer = nullptr;\n                m_current_offset = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_config_buffer = temp_buffer;\n            m_allocated_capacity = required_total_capacity;\n        }\n\n        ParameterEntryHeader header_to_write = {param_id, data_len};\n        memcpy(m_config_buffer + m_current_offset, &header_to_write, sizeof(ParameterEntryHeader));\n        \n        memcpy(m_config_buffer + m_current_offset + sizeof(ParameterEntryHeader), param_data, data_len);\n        \n        size_t bytes_to_pad = padded_data_len - data_len;\n        if (bytes_to_pad > 0) {\n            memset(m_config_buffer + m_current_offset + sizeof(ParameterEntryHeader) + data_len, 0, bytes_to_pad);\n        }\n        \n        m_current_offset += physical_entry_size;\n        \n        return true;\n    }\n\n    const uint8_t* getConfigurationBuffer() const { return m_config_buffer; }\n    size_t getCurrentOffset() const { return m_current_offset; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_config_buffer;\n    size_t   m_current_offset;\n    size_t   m_allocated_capacity;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n\n// Maximum allowed length for a sanitized string in the UI\n#define MAX_SANITIZED_STRING_LENGTH 2048\n\n// Represents a diagnostic log message structure received from a vehicle ECU\nstruct DiagnosticLogMessage {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t raw_string_length; // Length of the raw description string\n    // raw_description_data follows this struct in the packet\n};\n\n// Represents a processed, sanitized log entry\nstruct SanitizedLogEntry {\n    uint32_t timestamp;\n    uint16_t event_id;\n    char*    sanitized_description; // Heap-allocated, null-terminated\n};\n\nclass TelemetryLogProcessor {\npublic:\n    TelemetryLogProcessor() {}\n\n    ~TelemetryLogProcessor() {\n        clearProcessedLogs();\n    }\n\n    void clearProcessedLogs() {\n        for (auto& entry : m_processed_entries) {\n            if (entry.sanitized_description) {\n                free(entry.sanitized_description);\n            }\n        }\n        m_processed_entries.clear();\n    }\n\n    // Vulnerable function\n    // Parses a raw packet containing multiple diagnostic log messages\n    // and sanitizes their descriptions for display.\n    bool processRawTelemetryLogsVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticLogMessage)) {\n            return false;\n        }\n\n        clearProcessedLogs();\n\n        size_t current_offset = 0;\n\n        while (current_offset + sizeof(DiagnosticLogMessage) <= packet_len) {\n            const DiagnosticLogMessage* msg_header = reinterpret_cast<const DiagnosticLogMessage*>(raw_packet + current_offset);\n            \n            // Check if the claimed raw_string_length extends beyond the packet boundary\n            if (current_offset + sizeof(DiagnosticLogMessage) + msg_header->raw_string_length > packet_len) {\n                clearProcessedLogs();\n                return false;\n            }\n\n            // Vulnerability: Allocation based on raw_string_length + 1 (for null terminator).\n            // This does not account for character expansion during sanitization.\n            size_t allocated_desc_len = msg_header->raw_string_length + 1;\n            if (allocated_desc_len > MAX_SANITIZED_STRING_LENGTH) {\n                allocated_desc_len = MAX_SANITIZED_STRING_LENGTH;\n            }\n            if (allocated_desc_len == 0) allocated_desc_len = 1; // At least space for null terminator\n\n            char* sanitized_buffer = (char*)malloc(allocated_desc_len);\n            if (!sanitized_buffer) {\n                clearProcessedLogs();\n                return false;\n            }\n\n            SanitizedLogEntry new_entry;\n            new_entry.timestamp = msg_header->timestamp;\n            new_entry.event_id = msg_header->event_id;\n            new_entry.sanitized_description = sanitized_buffer;\n\n            const uint8_t* raw_desc_ptr = raw_packet + current_offset + sizeof(DiagnosticLogMessage);\n            size_t current_sanitized_pos = 0;\n\n            // Loop iterates 'raw_string_length' times.\n            // If a character expands (e.g., '\\n' -> '\\\\n' or 0x01 -> '[01]'), \n            // current_sanitized_pos increments by more than 1. This can exceed \n            // 'allocated_desc_len' before the loop finishes, leading to a heap overflow.\n            for (uint16_t i = 0; i < msg_header->raw_string_length; ++i) {\n                uint8_t char_code = raw_desc_ptr[i];\n\n                if (char_code >= 0x20 && char_code <= 0x7E) { // Printable ASCII\n                    sanitized_buffer[current_sanitized_pos++] = static_cast<char>(char_code);\n                } else {\n                    // Non-printable or control character. These expansions cause the overflow.\n                    if (char_code == '\\n') {\n                        sanitized_buffer[current_sanitized_pos++] = '\\\\';\n                        sanitized_buffer[current_sanitized_pos++] = 'n';\n                    } else if (char_code == '\\r') {\n                        sanitized_buffer[current_sanitized_pos++] = '\\\\';\n                        sanitized_buffer[current_sanitized_pos++] = 'r';\n                    } else if (char_code == '\\t') {\n                        sanitized_buffer[current_sanitized_pos++] = '\\\\';\n                        sanitized_buffer[current_sanitized_pos++] = 't';\n                    } else {\n                        // This specific expansion (e.g., 0x01 -> \"[01]\") leads to 4 characters.\n                        // If the raw string contains many such characters and allocated_desc_len\n                        // only accounts for 1:1 or 2:1 expansion, this will cause the heap overflow.\n                        sanitized_buffer[current_sanitized_pos++] = '[';\n                        sanitized_buffer[current_sanitized_pos++] = (char_code / 16 < 10 ? '0' + char_code / 16 : 'A' + char_code / 16 - 10);\n                        sanitized_buffer[current_sanitized_pos++] = (char_code % 16 < 10 ? '0' + char_code % 16 : 'A' + char_code % 16 - 10);\n                        sanitized_buffer[current_sanitized_pos++] = ']';\n                    }\n                }\n            }\n            sanitized_buffer[current_sanitized_pos] = '\\0'; // Null-terminate, potentially overflowing if loop already wrote past buffer\n\n            m_processed_entries.push_back(new_entry);\n\n            current_offset += sizeof(DiagnosticLogMessage) + msg_header->raw_string_length;\n        }\n\n        return true;\n    }\n\n    const std::vector<SanitizedLogEntry>& getProcessedEntries() const {\n        return m_processed_entries;\n    }\n\nprivate:\n    std::vector<SanitizedLogEntry> m_processed_entries;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\n// Maximum allowed length for a sanitized string in the UI\n#define MAX_SANITIZED_STRING_LENGTH 2048\n\n// Represents a diagnostic log message structure received from a vehicle ECU\nstruct DiagnosticLogMessage {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t raw_string_length; // Length of the raw description string\n    // raw_description_data follows this struct in the packet\n};\n\n// Represents a processed, sanitized log entry\nstruct SanitizedLogEntry {\n    uint32_t timestamp;\n    uint16_t event_id;\n    char*    sanitized_description; // Heap-allocated, null-terminated\n};\n\nclass TelemetryLogProcessor {\npublic:\n    TelemetryLogProcessor() {}\n\n    ~TelemetryLogProcessor() {\n        clearProcessedLogs();\n    }\n\n    void clearProcessedLogs() {\n        for (auto& entry : m_processed_entries) {\n            if (entry.sanitized_description) {\n                free(entry.sanitized_description);\n            }\n        }\n        m_processed_entries.clear();\n    }\n\n    // Fixed function\n    // Parses a raw packet containing multiple diagnostic log messages\n    // and sanitizes their descriptions for display.\n    bool processRawTelemetryLogsFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticLogMessage)) {\n            return false;\n        }\n\n        clearProcessedLogs();\n\n        size_t current_offset = 0;\n\n        while (current_offset + sizeof(DiagnosticLogMessage) <= packet_len) {\n            const DiagnosticLogMessage* msg_header = reinterpret_cast<const DiagnosticLogMessage*>(raw_packet + current_offset);\n            \n            // Check if the claimed raw_string_length extends beyond the packet boundary\n            if (current_offset + sizeof(DiagnosticLogMessage) + msg_header->raw_string_length > packet_len) {\n                clearProcessedLogs();\n                return false;\n            }\n\n            // FIX: Correctly calculate the maximum required size based on the largest expansion factor (4x for \"[XX]\").\n            // Also, ensure it does not exceed MAX_SANITIZED_STRING_LENGTH.\n            size_t max_expansion_factor = 4; // Max expansion for \"[XX]\" format (e.g., 0x01 becomes \"[01]\")\n            size_t required_chars_for_sanitized_string = msg_header->raw_string_length * max_expansion_factor;\n            \n            // Ensure space for null terminator and apply hard limit\n            size_t allocated_desc_len = std::min(required_chars_for_sanitized_string + 1, (size_t)MAX_SANITIZED_STRING_LENGTH);\n            if (allocated_desc_len == 0) allocated_desc_len = 1; // Always allocate at least 1 byte for null terminator\n\n            char* sanitized_buffer = (char*)malloc(allocated_desc_len);\n            if (!sanitized_buffer) {\n                clearProcessedLogs();\n                return false;\n            }\n\n            SanitizedLogEntry new_entry;\n            new_entry.timestamp = msg_header->timestamp;\n            new_entry.event_id = msg_header->event_id;\n            new_entry.sanitized_description = sanitized_buffer;\n\n            const uint8_t* raw_desc_ptr = raw_packet + current_offset + sizeof(DiagnosticLogMessage);\n            size_t current_sanitized_pos = 0;\n\n            for (uint16_t i = 0; i < msg_header->raw_string_length; ++i) {\n                uint8_t char_code = raw_desc_ptr[i];\n\n                if (char_code >= 0x20 && char_code <= 0x7E) { // Printable ASCII\n                    // FIX: Add bounds check before writing\n                    if (current_sanitized_pos + 1 > allocated_desc_len - 1) { // Check if space for 1 char + null terminator\n                        break; \n                    }\n                    sanitized_buffer[current_sanitized_pos++] = static_cast<char>(char_code);\n                } else {\n                    // Non-printable or control character\n                    if (char_code == '\\n') {\n                        // FIX: Add bounds check before writing\n                        if (current_sanitized_pos + 2 > allocated_desc_len - 1) { // Check space for 2 chars + null terminator\n                            break;\n                        }\n                        sanitized_buffer[current_sanitized_pos++] = '\\\\';\n                        sanitized_buffer[current_sanitized_pos++] = 'n';\n                    } else if (char_code == '\\r') {\n                        // FIX: Add bounds check before writing\n                        if (current_sanitized_pos + 2 > allocated_desc_len - 1) {\n                            break;\n                        }\n                        sanitized_buffer[current_sanitized_pos++] = '\\\\';\n                        sanitized_buffer[current_sanitized_pos++] = 'r';\n                    } else if (char_code == '\\t') {\n                        // FIX: Add bounds check before writing\n                        if (current_sanitized_pos + 2 > allocated_desc_len - 1) {\n                            break;\n                        }\n                        sanitized_buffer[current_sanitized_pos++] = '\\\\';\n                        sanitized_buffer[current_sanitized_pos++] = 't';\n                    } else {\n                        // For other control characters, represent as \"[XX]\" (4 chars)\n                        // FIX: Add bounds check before writing\n                        if (current_sanitized_pos + 4 > allocated_desc_len - 1) { // Check space for 4 chars + null terminator\n                            break;\n                        }\n                        sanitized_buffer[current_sanitized_pos++] = '[';\n                        sanitized_buffer[current_sanitized_pos++] = (char_code / 16 < 10 ? '0' + char_code / 16 : 'A' + char_code / 16 - 10);\n                        sanitized_buffer[current_sanitized_pos++] = (char_code % 16 < 10 ? '0' + char_code % 16 : 'A' + char_code % 16 - 10);\n                        sanitized_buffer[current_sanitized_pos++] = ']';\n                    }\n                }\n            }\n            sanitized_buffer[current_sanitized_pos] = '\\0'; // Always null-terminate safely\n\n            m_processed_entries.push_back(new_entry);\n\n            current_offset += sizeof(DiagnosticLogMessage) + msg_header->raw_string_length;\n        }\n\n        return true;\n    }\n\n    const std::vector<SanitizedLogEntry>& getProcessedEntries() const {\n        return m_processed_entries;\n    }\n\nprivate:\n    std::vector<SanitizedLogEntry> m_processed_entries;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t data_len;\n} LogEntryHeader;\n\nclass CircularLogBufferVulnerable {\npublic:\n    CircularLogBufferVulnerable(size_t capacity) :\n        m_buffer(nullptr),\n        m_capacity(capacity),\n        m_write_pos(0)\n    {\n        if (m_capacity > 0) {\n            m_buffer = (uint8_t*)malloc(m_capacity);\n        }\n    }\n\n    ~CircularLogBufferVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    bool appendEntryVulnerable(const uint8_t* entry_data, size_t data_packet_len) {\n        if (!entry_data || data_packet_len < sizeof(LogEntryHeader)) {\n            return false;\n        }\n\n        const LogEntryHeader* header = reinterpret_cast<const LogEntryHeader*>(entry_data);\n        uint16_t payload_len = header->data_len;\n\n        size_t total_entry_size = sizeof(LogEntryHeader) + payload_len;\n\n        if (data_packet_len < total_entry_size) {\n            return false;\n        }\n        \n        if (m_write_pos + total_entry_size > m_capacity) {\n            m_write_pos = 0;\n        }\n        \n        if (!m_buffer) {\n            return false;\n        }\n\n        for (size_t i = 0; i < total_entry_size; ++i) {\n            m_buffer[m_write_pos + i] = entry_data[i];\n        }\n\n        m_write_pos = (m_write_pos + total_entry_size) % m_capacity;\n\n        return true;\n    }\n\n    size_t getCurrentWritePosition() const {\n        return m_write_pos;\n    }\n\n    size_t getBufferCapacity() const {\n        return m_capacity;\n    }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_capacity;\n    size_t m_write_pos;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t data_len;\n} LogEntryHeader;\n\nclass CircularLogBufferFixed {\npublic:\n    CircularLogBufferFixed(size_t capacity) :\n        m_buffer(nullptr),\n        m_capacity(capacity),\n        m_write_pos(0)\n    {\n        if (m_capacity > 0) {\n            m_buffer = (uint8_t*)malloc(m_capacity);\n        }\n    }\n\n    ~CircularLogBufferFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    bool appendEntryFixed(const uint8_t* entry_data, size_t data_packet_len) {\n        if (!entry_data || data_packet_len < sizeof(LogEntryHeader)) {\n            return false;\n        }\n\n        const LogEntryHeader* header = reinterpret_cast<const LogEntryHeader*>(entry_data);\n        uint16_t payload_len = header->data_len;\n\n        static const uint16_t MAX_ALLOWED_PAYLOAD_LEN = 2048;\n        if (payload_len > MAX_ALLOWED_PAYLOAD_LEN) {\n            return false;\n        }\n        \n        size_t total_entry_size = sizeof(LogEntryHeader) + payload_len;\n\n        if (total_entry_size > m_capacity) {\n            return false;\n        }\n\n        if (data_packet_len < total_entry_size) {\n            return false;\n        }\n        \n        if (m_write_pos + total_entry_size > m_capacity) {\n            m_write_pos = 0;\n        }\n        \n        if (!m_buffer) {\n            return false;\n        }\n\n        for (size_t i = 0; i < total_entry_size; ++i) {\n            m_buffer[m_write_pos + i] = entry_data[i];\n        }\n\n        m_write_pos = (m_write_pos + total_entry_size) % m_capacity;\n\n        return true;\n    }\n\n    size_t getCurrentWritePosition() const {\n        return m_write_pos;\n    }\n\n    size_t getBufferCapacity() const {\n        return m_capacity;\n    }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_capacity;\n    size_t m_write_pos;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n// Represents a sub-message header within a larger diagnostic packet\nstruct DiagnosticSubMessageHeader {\n    uint16_t message_id;\n    uint16_t payload_length; // Actual length of payload for this sub-message\n};\n\n// Represents the overall diagnostic packet header\nstruct DiagnosticPacketHeader {\n    uint16_t packet_type;\n    uint16_t num_sub_messages;\n    uint32_t max_expected_sub_message_payload_len; // Max payload size for ANY sub-message in this packet\n};\n\nclass DiagnosticDataProcessorVulnerable {\npublic:\n    DiagnosticDataProcessorVulnerable() : m_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~DiagnosticDataProcessorVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool processPacketVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeader* header = reinterpret_cast<const DiagnosticPacketHeader*>(raw_packet);\n\n        // Calculate total space needed for all sub-messages' payloads based on the MAX expected length.\n        // This multiplication is vulnerable to integer overflow. If num_sub_messages and\n        // max_expected_sub_message_payload_len are large, their product can exceed UINT32_MAX.\n        // E.g., num_sub_messages = 2, max_expected_sub_message_payload_len = 0x80000000 (2GB).\n        // The product 2 * 0x80000000 = 0x100000000 (4GB) will wrap around to 0 in a uint32_t.\n        uint32_t total_payload_data_space = header->num_sub_messages * header->max_expected_sub_message_payload_len; // Vulnerable point\n\n        // Add space for all sub-message headers\n        size_t total_headers_space = (size_t)header->num_sub_messages * sizeof(DiagnosticSubMessageHeader);\n        \n        // Calculate the total allocation size for the internal buffer.\n        // If total_payload_data_space wrapped to 0 due to the overflow, this size will be very small.\n        size_t total_allocation_size = total_payload_data_space + total_headers_space;\n\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n        \n        // Allocate the buffer. If total_allocation_size was truncated, this allocation is too small.\n        m_buffer = (uint8_t*)malloc(total_allocation_size);\n        if (!m_buffer) {\n            m_buffer_capacity = 0;\n            return false;\n        }\n        m_buffer_capacity = total_allocation_size;\n\n        uint8_t* current_write_ptr = m_buffer;\n        const uint8_t* current_read_ptr = raw_packet + sizeof(DiagnosticPacketHeader);\n        size_t remaining_packet_data = packet_len - sizeof(DiagnosticPacketHeader);\n\n        for (uint16_t i = 0; i < header->num_sub_messages; ++i) {\n            // Basic validation for sub-message header presence in source packet\n            if (remaining_packet_data < sizeof(DiagnosticSubMessageHeader)) {\n                return false; // Malformed packet or truncated\n            }\n\n            const DiagnosticSubMessageHeader* sub_header = reinterpret_cast<const DiagnosticSubMessageHeader*>(current_read_ptr);\n            uint16_t actual_payload_len = sub_header->payload_length;\n\n            // Validate actual payload length against remaining source packet data\n            if (remaining_packet_data - sizeof(DiagnosticSubMessageHeader) < actual_payload_len) {\n                return false; // Not enough source data for declared payload\n            }\n            \n            // --- Heap-based Buffer Overflow happens here ---\n            // No check is performed to ensure that 'current_write_ptr + sizeof(DiagnosticSubMessageHeader) + actual_payload_len'\n            // does not exceed 'm_buffer + m_buffer_capacity'.\n            // If total_allocation_size was truncated due to the integer overflow mentioned above,\n            // and actual_payload_len is still large (even if it respects the max_expected_sub_message_payload_len from the header),\n            // this memcpy will write beyond the bounds of the undersized m_buffer.\n            \n            // Copy sub-message header\n            memcpy(current_write_ptr, sub_header, sizeof(DiagnosticSubMessageHeader));\n            current_write_ptr += sizeof(DiagnosticSubMessageHeader);\n\n            // Copy sub-message payload\n            memcpy(current_write_ptr, current_read_ptr + sizeof(DiagnosticSubMessageHeader), actual_payload_len); // Direct copy\n            current_write_ptr += actual_payload_len;\n\n            current_read_ptr += sizeof(DiagnosticSubMessageHeader) + actual_payload_len;\n            remaining_packet_data -= (sizeof(DiagnosticSubMessageHeader) + actual_payload_len);\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedData() const { return m_buffer; }\n    size_t getProcessedDataCapacity() const { return m_buffer_capacity; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_buffer_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits> // For std::numeric_limits\n\n// Represents a sub-message header within a larger diagnostic packet\nstruct DiagnosticSubMessageHeader {\n    uint16_t message_id;\n    uint16_t payload_length; // Actual length of payload for this sub-message\n};\n\n// Represents the overall diagnostic packet header\nstruct DiagnosticPacketHeader {\n    uint16_t packet_type;\n    uint16_t num_sub_messages;\n    uint32_t max_expected_sub_message_payload_len; // Max payload size for ANY sub-message in this packet\n};\n\nclass DiagnosticDataProcessorFixed {\npublic:\n    DiagnosticDataProcessorFixed() : m_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~DiagnosticDataProcessorFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool processPacketFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeader* header = reinterpret_cast<const DiagnosticPacketHeader*>(raw_packet);\n\n        // Calculate total space needed for all sub-messages' payloads based on the MAX expected length.\n        // Use size_t for calculations to prevent intermediate overflow of smaller types,\n        // and explicitly check for overflow against SIZE_MAX.\n        size_t total_payload_data_space;\n        if (header->num_sub_messages != 0 &&\n            header->max_expected_sub_message_payload_len > std::numeric_limits<size_t>::max() / header->num_sub_messages) {\n            return false; // Integer overflow detected for payload space during multiplication\n        }\n        total_payload_data_space = (size_t)header->num_sub_messages * header->max_expected_sub_message_payload_len;\n\n        // Add space for all sub-message headers\n        size_t total_headers_space = (size_t)header->num_sub_messages * sizeof(DiagnosticSubMessageHeader);\n        \n        // Check for integer overflow when adding total_headers_space\n        if (total_payload_data_space > std::numeric_limits<size_t>::max() - total_headers_space) {\n            return false; // Integer overflow detected for total size during addition\n        }\n\n        size_t total_allocation_size = total_payload_data_space + total_headers_space;\n\n        // Ensure total_allocation_size is not zero if there are messages expected\n        if (header->num_sub_messages > 0 && total_allocation_size == 0) {\n            return false; // Calculation resulted in zero size for a non-empty packet\n        }\n\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n        \n        // Allocate the buffer. This size is now correctly calculated and checked.\n        m_buffer = (uint8_t*)malloc(total_allocation_size);\n        if (!m_buffer) {\n            m_buffer_capacity = 0;\n            return false;\n        }\n        m_buffer_capacity = total_allocation_size;\n\n        uint8_t* current_write_ptr = m_buffer;\n        const uint8_t* current_read_ptr = raw_packet + sizeof(DiagnosticPacketHeader);\n        size_t remaining_packet_data = packet_len - sizeof(DiagnosticPacketHeader);\n\n        for (uint16_t i = 0; i < header->num_sub_messages; ++i) {\n            // Validate minimum required data for sub-message header in source packet\n            if (remaining_packet_data < sizeof(DiagnosticSubMessageHeader)) {\n                return false; // Malformed packet or truncated\n            }\n\n            const DiagnosticSubMessageHeader* sub_header = reinterpret_cast<const DiagnosticSubMessageHeader*>(current_read_ptr);\n            uint16_t actual_payload_len = sub_header->payload_length;\n\n            // Validate that an individual message's payload length does not exceed the globally advertised maximum\n            if (actual_payload_len > header->max_expected_sub_message_payload_len) {\n                return false; // Individual message payload exceeds global max declared in header\n            }\n\n            size_t current_sub_message_total_len = sizeof(DiagnosticSubMessageHeader) + actual_payload_len;\n\n            // Crucial: Check if there's enough space in the *destination* buffer for the current sub-message data.\n            // This prevents heap-based buffer overflow by ensuring the memcpy destination is within bounds.\n            // Also checks for pointer arithmetic wrap-around for current_write_ptr + current_sub_message_total_len.\n            if (current_write_ptr > m_buffer + m_buffer_capacity ||\n                current_sub_message_total_len > m_buffer_capacity - (current_write_ptr - m_buffer)) \n            {\n                return false; // Not enough allocated buffer space remaining for this entry\n            }\n            \n            // Check if there's enough data in the source packet for this complete sub-message (header + payload)\n            if (remaining_packet_data < current_sub_message_total_len) {\n                return false; // Not enough source data for declared payload\n            }\n            \n            // Copy sub-message header and payload in one contiguous block\n            memcpy(current_write_ptr, current_read_ptr, current_sub_message_total_len);\n            \n            current_write_ptr += current_sub_message_total_len;\n            current_read_ptr += current_sub_message_total_len;\n            remaining_packet_data -= current_sub_message_total_len;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedData() const { return m_buffer; }\n    size_t getProcessedDataCapacity() const { return m_buffer_capacity; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_buffer_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n\n// Represents a single firmware image entry within an update manifest\nstruct FirmwareImageEntry {\n    uint32_t image_id;\n    uint32_t image_size;\n    uint8_t  checksum[16];\n    char     version_string[32]; // Fixed-size string buffer for version\n};\n\n// Represents the header of a firmware update manifest packet\nstruct UpdateManifestHeader {\n    uint16_t manifest_version;\n    uint16_t num_firmware_images;   // Declared number of images - used for allocation\n    uint32_t total_payload_bytes;   // Total bytes of ALL image entries in the payload - used for loop bounds\n};\n\nclass FirmwareUpdaterVulnerable {\npublic:\n    FirmwareUpdaterVulnerable() : update_tasks(nullptr), num_tasks_allocated(0) {}\n\n    ~FirmwareUpdaterVulnerable() {\n        clearTasks();\n    }\n\n    void clearTasks() {\n        if (update_tasks) {\n            delete[] update_tasks;\n            update_tasks = nullptr;\n        }\n        num_tasks_allocated = 0;\n    }\n\n    // Processes a raw firmware update manifest packet\n    // Vulnerability: The allocation size (num_firmware_images) can be mismatched\n    // with the actual number of entries processed (derived from total_payload_bytes).\n    bool parseManifestVulnerable(const uint8_t* raw_manifest, size_t manifest_len) {\n        if (!raw_manifest || manifest_len < sizeof(UpdateManifestHeader)) {\n            return false;\n        }\n\n        const UpdateManifestHeader* header = reinterpret_cast<const UpdateManifestHeader*>(raw_manifest);\n\n        // Basic check: Ensure the reported total_payload_bytes does not exceed the actual packet length.\n        if (manifest_len < sizeof(UpdateManifestHeader) + header->total_payload_bytes) {\n            return false;\n        }\n\n        clearTasks(); // Clear any existing tasks before processing new manifest\n\n        // The heap allocation size is determined by 'num_firmware_images'.\n        // An attacker can set this to a small value (e.g., 1).\n        num_tasks_allocated = header->num_firmware_images;\n\n        // To avoid allocating 0 elements if num_firmware_images is 0, or excessive size.\n        static const uint16_t MAX_ALLOWED_IMAGES = 200;\n        if (num_tasks_allocated == 0 || num_tasks_allocated > MAX_ALLOWED_IMAGES) {\n            return false;\n        }\n\n        // Check for potential integer overflow in allocation size (though less likely with uint16_t and small struct size)\n        if ((size_t)num_tasks_allocated > (SIZE_MAX / sizeof(FirmwareImageEntry))) {\n            return false;\n        }\n\n        update_tasks = new (std::nothrow) FirmwareImageEntry[num_tasks_allocated];\n        if (!update_tasks) {\n            return false;\n        }\n\n        const uint8_t* current_payload_ptr = raw_manifest + sizeof(UpdateManifestHeader);\n        size_t bytes_processed_in_payload = 0;\n        uint16_t entry_count = 0;\n\n        // Vulnerability: The loop continues as long as there is enough data for another\n        // FirmwareImageEntry within the 'total_payload_bytes'.\n        // It DOES NOT check if 'entry_count' exceeds 'num_tasks_allocated'.\n        // An attacker can set header->num_firmware_images to a small number (e.g., 1) to get a small allocation,\n        // but craft header->total_payload_bytes to contain data for many more entries (e.g., 10 entries).\n        // This leads to 'update_tasks[entry_count]' writing past the allocated heap buffer.\n        while (bytes_processed_in_payload + sizeof(FirmwareImageEntry) <= header->total_payload_bytes) {\n\n            const FirmwareImageEntry* incoming_entry = reinterpret_cast<const FirmwareImageEntry*>(current_payload_ptr + bytes_processed_in_payload);\n            \n            // Heap-based Buffer Overflow occurs here if entry_count >= num_tasks_allocated\n            update_tasks[entry_count].image_id = incoming_entry->image_id;\n            update_tasks[entry_count].image_size = incoming_entry->image_size;\n            memcpy(update_tasks[entry_count].checksum, incoming_entry->checksum, sizeof(incoming_entry->checksum));\n            \n            // strncpy with null-termination is safe for individual string field, but the overall array access is vulnerable.\n            strncpy(update_tasks[entry_count].version_string, incoming_entry->version_string, sizeof(incoming_entry->version_string) - 1);\n            update_tasks[entry_count].version_string[sizeof(incoming_entry->version_string) - 1] = '\\0';\n\n            bytes_processed_in_payload += sizeof(FirmwareImageEntry);\n            entry_count++;\n        }\n\n        // Note: Even if total_payload_bytes is checked against manifest_len, and `num_firmware_images` is checked for max,\n        // the mismatch between `num_firmware_images` (allocation size) and `total_payload_bytes` (loop iteration count) remains.\n\n        return true;\n    }\n\n    const FirmwareImageEntry* getUpdateTasks() const { return update_tasks; }\n    uint16_t getNumTasksAllocated() const { return num_tasks_allocated; }\n\nprivate:\n    FirmwareImageEntry* update_tasks;\n    uint16_t            num_tasks_allocated;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n\n// Represents a single firmware image entry within an update manifest\nstruct FirmwareImageEntry {\n    uint32_t image_id;\n    uint32_t image_size;\n    uint8_t  checksum[16];\n    char     version_string[32]; // Fixed-size string buffer for version\n};\n\n// Represents the header of a firmware update manifest packet\nstruct UpdateManifestHeader {\n    uint16_t manifest_version;\n    uint16_t num_firmware_images;   // Declared number of images - used for allocation\n    uint32_t total_payload_bytes;   // Total bytes of ALL image entries in the payload - used for loop bounds\n};\n\nclass FirmwareUpdaterFixed {\npublic:\n    FirmwareUpdaterFixed() : update_tasks(nullptr), num_tasks_allocated(0) {}\n\n    ~FirmwareUpdaterFixed() {\n        clearTasks();\n    }\n\n    void clearTasks() {\n        if (update_tasks) {\n            delete[] update_tasks;\n            update_tasks = nullptr;\n        }\n        num_tasks_allocated = 0;\n    }\n\n    // Processes a raw firmware update manifest packet\n    // Fix: Ensures consistency between declared image count and total payload bytes,\n    // and strictly bounds the writing loop to the allocated array size.\n    bool parseManifestFixed(const uint8_t* raw_manifest, size_t manifest_len) {\n        if (!raw_manifest || manifest_len < sizeof(UpdateManifestHeader)) {\n            return false;\n        }\n\n        const UpdateManifestHeader* header = reinterpret_cast<const UpdateManifestHeader*>(raw_manifest);\n\n        // Fix 1: Add reasonable limits for num_firmware_images to prevent excessively large allocations.\n        static const uint16_t MAX_SUPPORTED_FIRMWARE_IMAGES = 200;\n        if (header->num_firmware_images > MAX_SUPPORTED_FIRMWARE_IMAGES) {\n            return false;\n        }\n\n        // Fix 2: Check for potential integer overflow during allocation size calculation.\n        if (header->num_firmware_images > (SIZE_MAX / sizeof(FirmwareImageEntry))) {\n            return false;\n        }\n\n        // Fix 3: Crucial consistency check: total_payload_bytes must precisely match\n        // the expected size based on num_firmware_images and entry size.\n        // This prevents an attacker from supplying a small num_firmware_images but a large total_payload_bytes.\n        if (header->num_firmware_images > 0 &&\n            header->total_payload_bytes != (size_t)header->num_firmware_images * sizeof(FirmwareImageEntry)) {\n            return false; // Malformed packet: declared count vs. total bytes mismatch\n        }\n\n        // Fix 4: Packet length check ensures enough data for the full declared payload.\n        if (manifest_len < sizeof(UpdateManifestHeader) + header->total_payload_bytes) {\n            return false;\n        }\n\n        clearTasks(); // Clear any existing tasks before processing new manifest\n\n        // Allocation size is correctly determined by 'num_firmware_images'.\n        num_tasks_allocated = header->num_firmware_images;\n\n        // If num_tasks_allocated is 0, we don't allocate or process anything.\n        if (num_tasks_allocated == 0) {\n            return true;\n        }\n\n        update_tasks = new (std::nothrow) FirmwareImageEntry[num_tasks_allocated];\n        if (!update_tasks) {\n            return false;\n        }\n\n        const uint8_t* current_payload_ptr = raw_manifest + sizeof(UpdateManifestHeader);\n\n        // Fix 5: The loop now explicitly iterates only up to 'num_tasks_allocated',\n        // which is the actual allocated size of the 'update_tasks' array.\n        // This prevents writing beyond the array bounds.\n        for (uint16_t i = 0; i < num_tasks_allocated; ++i) {\n            // Additional runtime check to ensure we don't read beyond the packet data (should be caught by Fix 4).\n            // This guards against highly malformed packets where actual data is less than declared `total_payload_bytes`.\n            if ((current_payload_ptr + (i * sizeof(FirmwareImageEntry)) + sizeof(FirmwareImageEntry)) > (raw_manifest + manifest_len)) {\n                clearTasks();\n                return false; // Malformed packet: not enough data for all declared entries\n            }\n\n            const FirmwareImageEntry* incoming_entry = reinterpret_cast<const FirmwareImageEntry*>(current_payload_ptr + (i * sizeof(FirmwareImageEntry)));\n            \n            update_tasks[i].image_id = incoming_entry->image_id;\n            update_tasks[i].image_size = incoming_entry->image_size;\n            memcpy(update_tasks[i].checksum, incoming_entry->checksum, sizeof(incoming_entry->checksum));\n            \n            // strncpy with null-termination is safe for individual string field.\n            strncpy(update_tasks[i].version_string, incoming_entry->version_string, sizeof(incoming_entry->version_string) - 1);\n            update_tasks[i].version_string[sizeof(incoming_entry->version_string) - 1] = '\\0';\n        }\n\n        return true;\n    }\n\n    const FirmwareImageEntry* getUpdateTasks() const { return update_tasks; }\n    uint16_t getNumTasksAllocated() const { return num_tasks_allocated; }\n\nprivate:\n    FirmwareImageEntry* update_tasks;\n    uint16_t            num_tasks_allocated;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\nstruct CalibrationPoint {\n    uint32_t timestamp;\n    int16_t value;\n};\n\nstruct CalibrationPacketHeader {\n    uint16_t packet_magic;\n    uint16_t num_calibration_points;\n    uint8_t  _reserved[4];\n};\n\nclass CalibrationManager {\nprivate:\n    CalibrationPoint* m_current_calibration_data;\n    size_t m_allocated_buffer_size_bytes;\n    size_t m_active_points_count;\n\npublic:\n    CalibrationManager() : m_current_calibration_data(nullptr), m_allocated_buffer_size_bytes(0), m_active_points_count(0) {}\n\n    ~CalibrationManager() {\n        if (m_current_calibration_data) {\n            free(m_current_calibration_data);\n            m_current_calibration_data = nullptr;\n        }\n    }\n\n    void clearCalibrationData() {\n        if (m_current_calibration_data) {\n            free(m_current_calibration_data);\n            m_current_calibration_data = nullptr;\n        }\n        m_allocated_buffer_size_bytes = 0;\n        m_active_points_count = 0;\n    }\n\n    bool processCalibrationPacketVulnerable(const uint8_t* packet_buffer, size_t buffer_length) {\n        if (!packet_buffer || buffer_length < sizeof(CalibrationPacketHeader)) {\n            return false;\n        }\n\n        const CalibrationPacketHeader* header = reinterpret_cast<const CalibrationPacketHeader*>(packet_buffer);\n\n        if (header->packet_magic != 0xABCD) {\n            return false;\n        }\n\n        uint16_t num_points = header->num_calibration_points;\n\n        // This calculation is for validating the *incoming packet's* stated length.\n        // It does not protect against a subsequent heap allocation error.\n        size_t expected_payload_bytes_from_packet = num_points * sizeof(CalibrationPoint);\n        size_t total_expected_packet_size = sizeof(CalibrationPacketHeader) + expected_payload_bytes_from_packet;\n\n        if (buffer_length < total_expected_packet_size) {\n            return false;\n        }\n\n        clearCalibrationData();\n\n        // VULNERABILITY: Incorrect size calculation for malloc.\n        // CalibrationPoint is 6 bytes (uint32_t + int16_t). sizeof(uint16_t) is 2 bytes.\n        // This allocates only 1/3 of the required memory, leading to a heap overflow\n        // when the data points are subsequently written to the undersized buffer.\n        m_current_calibration_data = (CalibrationPoint*)malloc(num_points * sizeof(uint16_t));\n\n        if (!m_current_calibration_data && num_points > 0) {\n            return false;\n        }\n        m_allocated_buffer_size_bytes = num_points * sizeof(uint16_t);\n\n        const uint8_t* data_ptr = packet_buffer + sizeof(CalibrationPacketHeader);\n        size_t current_data_offset = 0;\n\n        for (uint16_t i = 0; i < num_points; ++i) {\n            // The following assignments will write out of bounds because 'm_current_calibration_data'\n            // was allocated assuming each 'CalibrationPoint' is only 2 bytes large,\n            // but each actual 'CalibrationPoint' consumes 6 bytes.\n\n            // Read timestamp (uint32_t) from packet and write to heap buffer\n            m_current_calibration_data[i].timestamp = (uint32_t)data_ptr[current_data_offset] |\n                                                      ((uint32_t)data_ptr[current_data_offset + 1] << 8) |\n                                                      ((uint32_t)data_ptr[current_data_offset + 2] << 16) |\n                                                      ((uint32_t)data_ptr[current_data_offset + 3] << 24);\n            current_data_offset += sizeof(uint32_t);\n\n            // Read value (int16_t) from packet and write to heap buffer\n            m_current_calibration_data[i].value = (int16_t)data_ptr[current_data_offset] |\n                                                  ((int16_t)data_ptr[current_data_offset + 1] << 8);\n            current_data_offset += sizeof(int16_t);\n        }\n\n        m_active_points_count = num_points;\n        return true;\n    }\n\n    size_t getActivePointsCount() const {\n        return m_active_points_count;\n    }\n\n    const CalibrationPoint* getCalibrationData() const {\n        return m_current_calibration_data;\n    }\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\nstruct CalibrationPoint {\n    uint32_t timestamp;\n    int16_t value;\n};\n\nstruct CalibrationPacketHeader {\n    uint16_t packet_magic;\n    uint16_t num_calibration_points;\n    uint8_t  _reserved[4];\n};\n\nclass CalibrationManager {\nprivate:\n    CalibrationPoint* m_current_calibration_data;\n    size_t m_allocated_buffer_size_bytes;\n    size_t m_active_points_count;\n\npublic:\n    CalibrationManager() : m_current_calibration_data(nullptr), m_allocated_buffer_size_bytes(0), m_active_points_count(0) {}\n\n    ~CalibrationManager() {\n        if (m_current_calibration_data) {\n            free(m_current_calibration_data);\n            m_current_calibration_data = nullptr;\n        }\n    }\n\n    void clearCalibrationData() {\n        if (m_current_calibration_data) {\n            free(m_current_calibration_data);\n            m_current_calibration_data = nullptr;\n        }\n        m_allocated_buffer_size_bytes = 0;\n        m_active_points_count = 0;\n    }\n\n    bool processCalibrationPacketFixed(const uint8_t* packet_buffer, size_t buffer_length) {\n        if (!packet_buffer || buffer_length < sizeof(CalibrationPacketHeader)) {\n            return false;\n        }\n\n        const CalibrationPacketHeader* header = reinterpret_cast<const CalibrationPacketHeader*>(packet_buffer);\n\n        if (header->packet_magic != 0xABCD) {\n            return false;\n        }\n\n        uint16_t num_points = header->num_calibration_points;\n\n        // FIX: Add a reasonable maximum limit to prevent excessive memory allocation (DoS)\n        static const uint16_t MAX_POINTS_ALLOWED = 10000;\n        if (num_points > MAX_POINTS_ALLOWED) {\n            return false;\n        }\n\n        // Calculate expected total data size for the points payload.\n        // FIX: Add integer overflow checks for multiplication and addition.\n        size_t expected_payload_bytes;\n        if (num_points > 0 && SIZE_MAX / sizeof(CalibrationPoint) < num_points) {\n            return false; \n        }\n        expected_payload_bytes = num_points * sizeof(CalibrationPoint);\n        \n        size_t total_expected_packet_size;\n        if (SIZE_MAX - sizeof(CalibrationPacketHeader) < expected_payload_bytes) {\n            return false; \n        }\n        total_expected_packet_size = sizeof(CalibrationPacketHeader) + expected_payload_bytes;\n\n        if (buffer_length < total_expected_packet_size) {\n            return false;\n        }\n\n        clearCalibrationData();\n\n        // FIX: Correct size calculation for malloc by using the actual size of CalibrationPoint.\n        m_current_calibration_data = (CalibrationPoint*)malloc(expected_payload_bytes);\n\n        if (!m_current_calibration_data && num_points > 0) {\n            return false;\n        }\n        m_allocated_buffer_size_bytes = expected_payload_bytes;\n\n        const uint8_t* data_ptr = packet_buffer + sizeof(CalibrationPacketHeader);\n        size_t current_data_offset = 0;\n\n        for (uint16_t i = 0; i < num_points; ++i) {\n            // No explicit bounds checks needed here anymore for writing to 'm_current_calibration_data'\n            // because the buffer is now correctly sized and 'i' iterates up to 'num_points - 1'.\n\n            // Read timestamp (uint32_t) from packet and write to heap buffer\n            m_current_calibration_data[i].timestamp = (uint32_t)data_ptr[current_data_offset] |\n                                                      ((uint32_t)data_ptr[current_data_offset + 1] << 8) |\n                                                      ((uint32_t)data_ptr[current_data_offset + 2] << 16) |\n                                                      ((uint32_t)data_ptr[current_data_offset + 3] << 24);\n            current_data_offset += sizeof(uint32_t);\n\n            // Read value (int16_t) from packet and write to heap buffer\n            m_current_calibration_data[i].value = (int16_t)data_ptr[current_data_offset] |\n                                                  ((int16_t)data_ptr[current_data_offset + 1] << 8);\n            current_data_offset += sizeof(int16_t);\n        }\n\n        m_active_points_count = num_points;\n        return true;\n    }\n\n    size_t getActivePointsCount() const {\n        return m_active_points_count;\n    }\n\n    const CalibrationPoint* getCalibrationData() const {\n        return m_current_calibration_data;\n    }\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nstruct ConfigEntryHeader {\n    uint16_t key_hash;\n    uint16_t value_length; \n};\n\nclass VehicleConfigStoreVulnerable {\npublic:\n    VehicleConfigStoreVulnerable(size_t initial_capacity_bytes)\n        : m_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {\n        if (initial_capacity_bytes > 0) {\n            m_buffer = (uint8_t*)malloc(initial_capacity_bytes);\n            if (m_buffer) {\n                m_allocated_capacity = initial_capacity_bytes;\n            }\n        }\n    }\n\n    ~VehicleConfigStoreVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    bool addConfigEntryVulnerable(uint16_t key_hash, const uint8_t* value_data, uint16_t len) {\n        if (!value_data || len == 0) {\n            return false;\n        }\n\n        size_t entry_data_size_needed = sizeof(ConfigEntryHeader) + len; \n\n        if (m_current_size + entry_data_size_needed > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity == 0 ? entry_data_size_needed : m_allocated_capacity * 2;\n            if (new_capacity < m_current_size + entry_data_size_needed) {\n                new_capacity = m_current_size + entry_data_size_needed;\n            }\n            \n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_capacity);\n            if (!new_buffer) {\n                if (m_buffer) free(m_buffer);\n                m_buffer = nullptr;\n                m_current_size = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        if (!m_buffer) {\n            return false;\n        }\n\n        ConfigEntryHeader header = {key_hash, len};\n        memcpy(m_buffer + m_current_size, &header, sizeof(ConfigEntryHeader));\n        \n        memcpy(m_buffer + m_current_size + sizeof(ConfigEntryHeader), value_data, len);\n\n        m_buffer[m_current_size + sizeof(ConfigEntryHeader) + len] = '\\0';\n\n        m_current_size += entry_data_size_needed; \n\n        return true;\n    }\n\n    const uint8_t* getRawBuffer() const { return m_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <limits>\n\nstruct ConfigEntryHeader {\n    uint16_t key_hash;\n    uint16_t value_length; \n};\n\nclass VehicleConfigStoreFixed {\npublic:\n    VehicleConfigStoreFixed(size_t initial_capacity_bytes)\n        : m_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {\n        if (initial_capacity_bytes > 0) {\n            m_buffer = (uint8_t*)malloc(initial_capacity_bytes);\n            if (m_buffer) {\n                m_allocated_capacity = initial_capacity_bytes;\n            }\n        }\n    }\n\n    ~VehicleConfigStoreFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    bool addConfigEntryFixed(uint16_t key_hash, const uint8_t* value_data, uint16_t len) {\n        if (!value_data || len == 0) {\n            return false;\n        }\n\n        size_t entry_data_size_needed = sizeof(ConfigEntryHeader) + len + 1; \n\n        if (sizeof(ConfigEntryHeader) > std::numeric_limits<size_t>::max() - (len + 1)) {\n            return false;\n        }\n\n        if (m_current_size > std::numeric_limits<size_t>::max() - entry_data_size_needed) {\n            return false;\n        }\n        \n        if (m_current_size + entry_data_size_needed > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity == 0 ? entry_data_size_needed : m_allocated_capacity * 2;\n\n            if (m_allocated_capacity > (std::numeric_limits<size_t>::max() / 2) && m_allocated_capacity != 0) {\n                 new_capacity = std::numeric_limits<size_t>::max();\n            }\n            if (new_capacity < m_current_size + entry_data_size_needed) {\n                new_capacity = m_current_size + entry_data_size_needed;\n            }\n            \n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_capacity);\n            if (!new_buffer) {\n                if (m_buffer) free(m_buffer);\n                m_buffer = nullptr;\n                m_current_size = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        if (!m_buffer) {\n            return false;\n        }\n\n        ConfigEntryHeader header = {key_hash, len};\n        memcpy(m_buffer + m_current_size, &header, sizeof(ConfigEntryHeader));\n        \n        memcpy(m_buffer + m_current_size + sizeof(ConfigEntryHeader), value_data, len);\n\n        m_buffer[m_current_size + sizeof(ConfigEntryHeader) + len] = '\\0';\n\n        m_current_size += entry_data_size_needed; \n\n        return true;\n    }\n\n    const uint8_t* getRawBuffer() const { return m_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <new>\n#include <cstring>\n#include <cstdlib>\n\nstruct ConfigEntryMetadata {\n    uint32_t key_offset;\n    uint16_t key_len;\n    uint32_t value_offset;\n    uint16_t value_len;\n};\n\nclass VehicleConfigManagerVulnerable {\npublic:\n    VehicleConfigManagerVulnerable() : m_dataBuffer(nullptr), m_currentDataSize(0), m_allocatedCapacity(0) {\n        m_allocatedCapacity = 256;\n        m_dataBuffer = (uint8_t*)malloc(m_allocatedCapacity);\n        if (!m_dataBuffer) {\n            m_allocatedCapacity = 0;\n        }\n    }\n\n    ~VehicleConfigManagerVulnerable() {\n        if (m_dataBuffer) {\n            free(m_dataBuffer);\n            m_dataBuffer = nullptr;\n        }\n    }\n\n    bool addConfigEntryVulnerable(const char* key, uint16_t key_len, const char* value, uint16_t value_len) {\n        if (!key || !value) {\n            return false;\n        }\n\n        uint16_t entry_data_len = key_len + 1 + value_len + 1;\n\n        size_t required_total_size = m_currentDataSize + entry_data_len;\n\n        if (required_total_size > m_allocatedCapacity) {\n            uint8_t* new_buffer = (uint8_t*)realloc(m_dataBuffer, required_total_size);\n            if (!new_buffer) {\n                return false;\n            }\n            m_dataBuffer = new_buffer;\n            m_allocatedCapacity = required_total_size;\n        }\n\n        ConfigEntryMetadata new_metadata;\n        new_metadata.key_offset = m_currentDataSize;\n        new_metadata.key_len = key_len;\n        new_metadata.value_offset = m_currentDataSize + key_len + 1;\n        new_metadata.value_len = value_len;\n        m_configEntries.push_back(new_metadata);\n\n        memcpy(m_dataBuffer + m_currentDataSize, key, key_len);\n        m_dataBuffer[m_currentDataSize + key_len] = '\\0';\n\n        memcpy(m_dataBuffer + new_metadata.value_offset, value, value_len);\n        m_dataBuffer[new_metadata.value_offset + value_len] = '\\0';\n\n        m_currentDataSize += (key_len + 1 + value_len + 1);\n\n        return true;\n    }\n\n    const uint8_t* getDataBuffer() const { return m_dataBuffer; }\n    size_t getCurrentDataSize() const { return m_currentDataSize; }\n    size_t getAllocatedCapacity() const { return m_allocatedCapacity; }\n    const std::vector<ConfigEntryMetadata>& getConfigEntries() const { return m_configEntries; }\n\nprivate:\n    uint8_t* m_dataBuffer;\n    size_t m_currentDataSize;\n    size_t m_allocatedCapacity;\n    std::vector<ConfigEntryMetadata> m_configEntries;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <new>\n#include <cstring>\n#include <cstdlib>\n#include <limits>\n\nstruct ConfigEntryMetadata {\n    uint32_t key_offset;\n    uint16_t key_len;\n    uint32_t value_offset;\n    uint16_t value_len;\n};\n\nclass VehicleConfigManagerFixed {\npublic:\n    VehicleConfigManagerFixed() : m_dataBuffer(nullptr), m_currentDataSize(0), m_allocatedCapacity(0) {\n        m_allocatedCapacity = 256;\n        m_dataBuffer = (uint8_t*)malloc(m_allocatedCapacity);\n        if (!m_dataBuffer) {\n            m_allocatedCapacity = 0;\n        }\n    }\n\n    ~VehicleConfigManagerFixed() {\n        if (m_dataBuffer) {\n            free(m_dataBuffer);\n            m_dataBuffer = nullptr;\n        }\n    }\n\n    bool addConfigEntryFixed(const char* key, uint16_t key_len, const char* value, uint16_t value_len) {\n        if (!key || !value) {\n            return false;\n        }\n\n        static const uint16_t MAX_KEY_LEN = 2048; \n        static const uint16_t MAX_VALUE_LEN = 2048; \n\n        if (key_len > MAX_KEY_LEN || value_len > MAX_VALUE_LEN) {\n            return false;\n        }\n\n        if (key_len > (std::numeric_limits<size_t>::max() - 1 - value_len - 1)) {\n            return false;\n        }\n        size_t required_data_for_new_entry = (size_t)key_len + 1 + (size_t)value_len + 1;\n\n        if (m_currentDataSize > (std::numeric_limits<size_t>::max() - required_data_for_new_entry)) {\n            return false;\n        }\n        size_t required_total_size = m_currentDataSize + required_data_for_new_entry;\n\n        static const size_t MAX_TOTAL_CONFIG_SIZE = 64 * 1024; \n        if (required_total_size > MAX_TOTAL_CONFIG_SIZE) {\n            return false;\n        }\n\n        if (required_total_size > m_allocatedCapacity) {\n            uint8_t* new_buffer = (uint8_t*)realloc(m_dataBuffer, required_total_size);\n            if (!new_buffer) {\n                return false;\n            }\n            m_dataBuffer = new_buffer;\n            m_allocatedCapacity = required_total_size;\n        }\n\n        ConfigEntryMetadata new_metadata;\n        new_metadata.key_offset = static_cast<uint32_t>(m_currentDataSize);\n        new_metadata.key_len = key_len;\n        new_metadata.value_offset = static_cast<uint32_t>(m_currentDataSize + key_len + 1);\n        new_metadata.value_len = value_len;\n        m_configEntries.push_back(new_metadata);\n\n        memcpy(m_dataBuffer + m_currentDataSize, key, key_len);\n        m_dataBuffer[m_currentDataSize + key_len] = '\\0';\n\n        memcpy(m_dataBuffer + new_metadata.value_offset, value, value_len);\n        m_dataBuffer[new_metadata.value_offset + value_len] = '\\0';\n\n        m_currentDataSize += required_data_for_new_entry;\n\n        return true;\n    }\n\n    const uint8_t* getDataBuffer() const { return m_dataBuffer; }\n    size_t getCurrentDataSize() const { return m_currentDataSize; }\n    size_t getAllocatedCapacity() const { return m_allocatedCapacity; }\n    const std::vector<ConfigEntryMetadata>& getConfigEntries() const { return m_configEntries; }\n\nprivate:\n    uint8_t* m_dataBuffer;\n    size_t m_currentDataSize;\n    size_t m_allocatedCapacity;\n    std::vector<ConfigEntryMetadata> m_configEntries;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <new>\n\n// Represents the format of an incoming network/internal packet header for sensor data batches.\nstruct SensorBatchPacketHeader {\n    uint16_t packet_magic;\n    uint16_t num_readings;\n    uint32_t aggregate_data_payload_size; // Sum of all 'data_length' from individual readings in the packet\n};\n\n// Represents the format of an individual sensor reading entry as it appears in the raw packet\n// and how it's intended to be stored contiguously in the internal buffer.\nstruct RawSensorReadingEntry {\n    uint16_t sensor_id;\n    uint32_t timestamp;\n    uint16_t data_length; // The length of the actual data bytes for THIS reading (following this header)\n    // uint8_t data[]; // Variable length data conceptually follows this header\n};\n\nclass DynamicSensorDataLogger {\npublic:\n    DynamicSensorDataLogger() : m_storage_buffer(nullptr), m_allocated_capacity(0), m_current_size(0) {}\n\n    ~DynamicSensorDataLogger() {\n        if (m_storage_buffer) {\n            delete[] m_storage_buffer;\n        }\n    }\n\n    void clearBuffer() {\n        if (m_storage_buffer) {\n            delete[] m_storage_buffer;\n            m_storage_buffer = nullptr;\n        }\n        m_allocated_capacity = 0;\n        m_current_size = 0;\n    }\n\n    // Processes a raw packet containing a batch of sensor data readings.\n    // VULNERABILITY: Heap-based buffer overflow due to incorrect allocation size.\n    bool processSensorDataBatchVulnerable(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(SensorBatchPacketHeader)) {\n            return false;\n        }\n\n        const SensorBatchPacketHeader* batch_header = reinterpret_cast<const SensorBatchPacketHeader*>(raw_packet);\n\n        if (batch_header->packet_magic != 0xFEED) { // Validate magic number\n            return false;\n        }\n\n        // Check if the total payload size advertised in the header exceeds the provided packet length.\n        // This is a necessary boundary check for the incoming packet, but not sufficient for the heap allocation.\n        if (batch_header->aggregate_data_payload_size > (packet_length - sizeof(SensorBatchPacketHeader))) {\n            return false;\n        }\n\n        clearBuffer();\n\n        // VULNERABILITY:\n        // The internal storage buffer is allocated *only* based on 'aggregate_data_payload_size'\n        // from the batch header. This size is intended to cover only the variable-length data\n        // portions of all readings.\n        // However, each RawSensorReadingEntry also includes a fixed-size header (sensor_id, timestamp, data_length)\n        // which will also be copied into this buffer. This fixed-size header space is *not* accounted for in the allocation.\n        m_storage_buffer = new (std::nothrow) uint8_t[batch_header->aggregate_data_payload_size];\n        if (!m_storage_buffer && batch_header->aggregate_data_payload_size > 0) {\n            return false;\n        }\n        m_allocated_capacity = batch_header->aggregate_data_payload_size;\n        m_current_size = 0;\n\n        size_t current_packet_read_offset = sizeof(SensorBatchPacketHeader);\n\n        for (uint16_t i = 0; i < batch_header->num_readings; ++i) {\n            // Ensure there's enough packet data for at least an individual reading header.\n            if (current_packet_read_offset + sizeof(RawSensorReadingEntry) > packet_length) {\n                clearBuffer();\n                return false;\n            }\n\n            const RawSensorReadingEntry* reading_header = reinterpret_cast<const RawSensorReadingEntry*>(raw_packet + current_packet_read_offset);\n\n            // Calculate the total size of this single entry (fixed header + variable data payload).\n            size_t current_entry_total_size = sizeof(RawSensorReadingEntry) + reading_header->data_length;\n\n            // Check if the current entry's data extends beyond the remaining packet data.\n            if (current_packet_read_offset + current_entry_total_size > packet_length) {\n                clearBuffer();\n                return false;\n            }\n            \n            // Copy the entire RawSensorReadingEntry (its fixed header + its data payload)\n            // from the raw packet into the internal storage buffer.\n            // As 'm_current_size' accumulates 'current_entry_total_size' for each reading,\n            // it will quickly exceed 'm_allocated_capacity' because 'm_allocated_capacity'\n            // only accounts for the sum of 'data_length's, not also 'sizeof(RawSensorReadingEntry)' for each.\n            // This loop will write past the end of 'm_storage_buffer' if there are multiple readings.\n            for (size_t k = 0; k < current_entry_total_size; ++k) {\n                m_storage_buffer[m_current_size + k] = raw_packet[current_packet_read_offset + k];\n            }\n\n            // Advance offsets for the next reading.\n            m_current_size += current_entry_total_size; // Tracks bytes written to internal buffer\n            current_packet_read_offset += current_entry_total_size; // Tracks bytes consumed from source packet\n        }\n\n        return true;\n    }\n\n    const uint8_t* getStoredData() const { return m_storage_buffer; }\n    size_t getStoredDataSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_storage_buffer;\n    size_t   m_allocated_capacity;\n    size_t   m_current_size;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <new>\n#include <limits>\n#include <algorithm>\n\n// Represents the format of an incoming network/internal packet header for sensor data batches.\nstruct SensorBatchPacketHeader {\n    uint16_t packet_magic;\n    uint16_t num_readings;\n    uint32_t aggregate_data_payload_size; // Sum of all 'data_length' from individual readings in the packet\n};\n\n// Represents the format of an individual sensor reading entry as it appears in the raw packet\n// and how it's intended to be stored contiguously in the internal buffer.\nstruct RawSensorReadingEntry {\n    uint16_t sensor_id;\n    uint32_t timestamp;\n    uint16_t data_length; // The length of the actual data bytes for THIS reading (following this header)\n    // uint8_t data[]; // Variable length data conceptually follows this header\n};\n\nclass DynamicSensorDataLogger {\npublic:\n    DynamicSensorDataLogger() : m_storage_buffer(nullptr), m_allocated_capacity(0), m_current_size(0) {}\n\n    ~DynamicSensorDataLogger() {\n        if (m_storage_buffer) {\n            delete[] m_storage_buffer;\n        }\n    }\n\n    void clearBuffer() {\n        if (m_storage_buffer) {\n            delete[] m_storage_buffer;\n            m_storage_buffer = nullptr;\n        }\n        m_allocated_capacity = 0;\n        m_current_size = 0;\n    }\n\n    // Processes a raw packet containing a batch of sensor data readings (fixed version).\n    bool processSensorDataBatchFixed(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(SensorBatchPacketHeader)) {\n            return false;\n        }\n\n        const SensorBatchPacketHeader* batch_header = reinterpret_cast<const SensorBatchPacketHeader*>(raw_packet);\n\n        if (batch_header->packet_magic != 0xFEED) {\n            return false;\n        }\n\n        // Add reasonable limits to prevent excessive resource consumption (DoS).\n        static const uint16_t MAX_READINGS = 1000;\n        if (batch_header->num_readings > MAX_READINGS) {\n            return false;\n        }\n        static const uint16_t MAX_SINGLE_PAYLOAD_LEN = 1500; // E.g., based on MTU\n\n        // Check if the total payload size advertised in the header exceeds the provided packet length.\n        if (batch_header->aggregate_data_payload_size > (packet_length - sizeof(SensorBatchPacketHeader))) {\n            return false;\n        }\n\n        clearBuffer();\n\n        // FIX:\n        // Calculate the *correct* total required size for the internal buffer.\n        // This must include the size of each RawSensorReadingEntry header\n        // *plus* the aggregate data payload.\n        size_t headers_total_size;\n        // Prevent integer overflow for multiplication.\n        if (batch_header->num_readings > (std::numeric_limits<size_t>::max() / sizeof(RawSensorReadingEntry))) {\n            return false;\n        }\n        headers_total_size = batch_header->num_readings * sizeof(RawSensorReadingEntry);\n\n        size_t total_required_buffer_size;\n        // Prevent integer overflow for addition.\n        if (headers_total_size > (std::numeric_limits<size_t>::max() - batch_header->aggregate_data_payload_size)) {\n            return false;\n        }\n        total_required_buffer_size = headers_total_size + batch_header->aggregate_data_payload_size;\n\n        // Handle edge case of zero-sized allocation request for non-zero number of readings.\n        if (total_required_buffer_size == 0 && batch_header->num_readings > 0) {\n             return false;\n        }\n        // Handle graceful exit for empty batches.\n        if (total_required_buffer_size == 0 && batch_header->num_readings == 0) {\n            return true;\n        }\n\n        m_storage_buffer = new (std::nothrow) uint8_t[total_required_buffer_size];\n        if (!m_storage_buffer) {\n            return false;\n        }\n        m_allocated_capacity = total_required_buffer_size;\n        m_current_size = 0;\n\n        size_t current_packet_read_offset = sizeof(SensorBatchPacketHeader);\n        uint32_t accumulated_payload_length_from_entries = 0; // For final consistency check\n\n        for (uint16_t i = 0; i < batch_header->num_readings; ++i) {\n            // Ensure enough packet data for the current individual reading header.\n            if (current_packet_read_offset + sizeof(RawSensorReadingEntry) > packet_length) {\n                clearBuffer();\n                return false;\n            }\n\n            const RawSensorReadingEntry* reading_header = reinterpret_cast<const RawSensorReadingEntry*>(raw_packet + current_packet_read_offset);\n\n            size_t current_entry_payload_len = reading_header->data_length;\n            \n            // Enforce maximum individual payload length.\n            if (current_entry_payload_len > MAX_SINGLE_PAYLOAD_LEN) {\n                clearBuffer();\n                return false;\n            }\n\n            size_t current_entry_total_size = sizeof(RawSensorReadingEntry) + current_entry_payload_len;\n\n            // Check if the current entry's data extends beyond the remaining packet data.\n            if (current_packet_read_offset + current_entry_total_size > packet_length) {\n                clearBuffer();\n                return false;\n            }\n            \n            // FIX: Crucial check to prevent heap buffer overflow.\n            // Ensure there is enough space remaining in the allocated internal buffer\n            // before attempting to copy the current entry.\n            if (m_current_size > (m_allocated_capacity - current_entry_total_size)) {\n                clearBuffer();\n                return false; // Not enough space left in our allocated buffer\n            }\n\n            // Copy the entire RawSensorReadingEntry (its fixed header + its data payload).\n            for (size_t k = 0; k < current_entry_total_size; ++k) {\n                m_storage_buffer[m_current_size + k] = raw_packet[current_packet_read_offset + k];\n            }\n\n            // Advance offsets for the next reading.\n            m_current_size += current_entry_total_size;\n            current_packet_read_offset += current_entry_total_size;\n\n            // Accumulate payload length for final consistency check. Add overflow protection.\n            if (accumulated_payload_length_from_entries > (std::numeric_limits<uint32_t>::max() - current_entry_payload_len)) {\n                clearBuffer();\n                return false;\n            }\n            accumulated_payload_length_from_entries += current_entry_payload_len;\n        }\n\n        // Final consistency checks:\n        // 1. Ensure the sum of individual data_lengths matches the advertised aggregate_data_payload_size.\n        // 2. Ensure the total bytes written to the internal buffer matches the calculated total_required_buffer_size.\n        if (accumulated_payload_length_from_entries != batch_header->aggregate_data_payload_size ||\n            m_current_size != total_required_buffer_size) {\n            clearBuffer();\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getStoredData() const { return m_storage_buffer; }\n    size_t getStoredDataSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_storage_buffer;\n    size_t   m_allocated_capacity;\n    size_t   m_current_size;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n#include <limits>\n\n// Represents a raw sensor data packet header received over a bus.\nstruct RawSensorPacketHeader {\n    uint16_t packet_id;\n    uint16_t num_readings; // Number of uint16_t readings following the header\n    uint32_t checksum;     // Simple checksum for integrity\n};\n\n// Class to process raw sensor data into floating-point format for internal use.\nclass SensorDataProcessorVulnerable {\npublic:\n    SensorDataProcessorVulnerable() : m_processed_data(nullptr), m_num_elements(0), m_allocated_bytes(0) {}\n\n    ~SensorDataProcessorVulnerable() {\n        if (m_processed_data) {\n            free(m_processed_data);\n            m_processed_data = nullptr;\n        }\n    }\n\n    // Processes a raw sensor data packet, converting uint16_t readings to float.\n    // VULNERABILITY: Heap-based buffer overflow due to incorrect allocation size for type conversion.\n    bool processRawSensorDataVulnerable(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(RawSensorPacketHeader)) {\n            return false;\n        }\n\n        const RawSensorPacketHeader* header = reinterpret_cast<const RawSensorPacketHeader*>(raw_packet);\n\n        if (header->packet_id != 0xABCD) { // Simple magic check for realism\n            return false;\n        }\n\n        // Basic sanity check on packet length for the raw data payload\n        // This checks if the packet contains enough raw data based on 'num_readings' and 'uint16_t' size.\n        if (header->num_readings > (std::numeric_limits<size_t>::max() / sizeof(uint16_t))) {\n            return false; // Prevent integer overflow for this length calculation\n        }\n        size_t expected_raw_data_size = static_cast<size_t>(header->num_readings) * sizeof(uint16_t);\n        \n        if (packet_length < sizeof(RawSensorPacketHeader) + expected_raw_data_size) {\n            return false;\n        }\n\n        // Free existing buffer if any\n        if (m_processed_data) {\n            free(m_processed_data);\n            m_processed_data = nullptr;\n        }\n\n        // VULNERABILITY:\n        // The allocation size is calculated based on the *original* uint16_t size, not the target float size.\n        // If sizeof(float) > sizeof(uint16_t) (e.g., 4 bytes vs 2 bytes), this allocation is too small.\n        // For example, if num_readings is 100:\n        // Allocated: 100 * 2 = 200 bytes\n        // Needed:    100 * 4 = 400 bytes (for float)\n        // The loop iterating through 'i' will eventually write past the end of 'm_processed_data'.\n        m_allocated_bytes = static_cast<size_t>(header->num_readings) * sizeof(uint16_t);\n        \n        m_processed_data = (float*)malloc(m_allocated_bytes);\n        if (!m_processed_data && m_allocated_bytes > 0) {\n            return false;\n        }\n        \n        m_num_elements = header->num_readings;\n\n        const uint16_t* raw_readings_ptr = reinterpret_cast<const uint16_t*>(raw_packet + sizeof(RawSensorPacketHeader));\n\n        for (uint16_t i = 0; i < m_num_elements; ++i) {\n            // This write operation expects 'm_processed_data' to hold 'float' type elements.\n            // As 'i' increments, the access m_processed_data[i] will go out of bounds of the \n            // buffer allocated based on 'sizeof(uint16_t)'.\n            m_processed_data[i] = static_cast<float>(raw_readings_ptr[i]);\n        }\n\n        // Additional check for checksum (for realism, not directly related to the overflow)\n        uint32_t calculated_checksum = 0;\n        for (uint16_t i = 0; i < header->num_readings; ++i) {\n            calculated_checksum += raw_readings_ptr[i];\n        }\n        if (calculated_checksum != header->checksum) {\n            if (m_processed_data) {\n                free(m_processed_data);\n                m_processed_data = nullptr;\n            }\n            m_num_elements = 0;\n            m_allocated_bytes = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const float* getProcessedData() const { return m_processed_data; }\n    uint16_t getNumElements() const { return m_num_elements; }\n\nprivate:\n    float*   m_processed_data;\n    uint16_t m_num_elements;\n    size_t   m_allocated_bytes;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n#include <limits>\n\n// Represents a raw sensor data packet header received over a bus.\nstruct RawSensorPacketHeader {\n    uint16_t packet_id;\n    uint16_t num_readings; // Number of uint16_t readings following the header\n    uint32_t checksum;     // Simple checksum for integrity\n};\n\n// Class to process raw sensor data into floating-point format for internal use.\nclass SensorDataProcessorFixed {\npublic:\n    SensorDataProcessorFixed() : m_processed_data(nullptr), m_num_elements(0), m_allocated_bytes(0) {}\n\n    ~SensorDataProcessorFixed() {\n        if (m_processed_data) {\n            free(m_processed_data);\n            m_processed_data = nullptr;\n        }\n    }\n\n    // Processes a raw sensor data packet, converting uint16_t readings to float.\n    // FIX: Correctly allocates buffer based on target data type size (float).\n    bool processRawSensorDataFixed(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(RawSensorPacketHeader)) {\n            return false;\n        }\n\n        const RawSensorPacketHeader* header = reinterpret_cast<const RawSensorPacketHeader*>(raw_packet);\n\n        if (header->packet_id != 0xABCD) {\n            return false;\n        }\n\n        // Basic sanity check on packet length for the raw data payload\n        if (header->num_readings > (std::numeric_limits<size_t>::max() / sizeof(uint16_t))) {\n            return false; // Prevent integer overflow for this length calculation\n        }\n        size_t expected_raw_data_size = static_cast<size_t>(header->num_readings) * sizeof(uint16_t);\n\n        if (packet_length < sizeof(RawSensorPacketHeader) + expected_raw_data_size) {\n            return false;\n        }\n\n        // Free existing buffer if any\n        if (m_processed_data) {\n            free(m_processed_data);\n            m_processed_data = nullptr;\n        }\n\n        // FIX:\n        // The allocation size is now correctly calculated based on the *target* data type size (float).\n        // Also, add an integer overflow check for the multiplication.\n        if (header->num_readings > (std::numeric_limits<size_t>::max() / sizeof(float))) {\n            return false; // Prevent integer overflow during allocation size calculation\n        }\n        m_allocated_bytes = static_cast<size_t>(header->num_readings) * sizeof(float);\n        \n        m_processed_data = (float*)malloc(m_allocated_bytes);\n        if (!m_processed_data && m_allocated_bytes > 0) { // If allocation fails for non-zero size\n            return false;\n        }\n        \n        m_num_elements = header->num_readings;\n\n        const uint16_t* raw_readings_ptr = reinterpret_cast<const uint16_t*>(raw_packet + sizeof(RawSensorPacketHeader));\n\n        for (uint16_t i = 0; i < m_num_elements; ++i) {\n            // Now, m_processed_data is allocated with enough space for 'float' elements,\n            // so accessing m_processed_data[i] will be within bounds.\n            m_processed_data[i] = static_cast<float>(raw_readings_ptr[i]);\n        }\n\n        // Additional check for checksum\n        uint32_t calculated_checksum = 0;\n        for (uint16_t i = 0; i < header->num_readings; ++i) {\n            calculated_checksum += raw_readings_ptr[i];\n        }\n        if (calculated_checksum != header->checksum) {\n            if (m_processed_data) {\n                free(m_processed_data);\n                m_processed_data = nullptr;\n            }\n            m_num_elements = 0;\n            m_allocated_bytes = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const float* getProcessedData() const { return m_processed_data; }\n    uint16_t getNumElements() const { return m_num_elements; }\n\nprivate:\n    float*   m_processed_data;\n    uint16_t m_num_elements;\n    size_t   m_allocated_bytes;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <limits>\n\nstruct SensorSample {\n    uint32_t timestamp;\n    int16_t  value_x;\n    int16_t  value_y;\n    int16_t  value_z;\n    uint8_t  status;\n};\n\nstruct SensorPacketHeader {\n    uint16_t packet_id;\n    uint32_t offset_in_total_stream;\n    uint32_t num_samples_in_packet;\n};\n\nclass SensorDataRecorderVulnerable {\npublic:\n    SensorDataRecorderVulnerable(size_t max_recording_bytes)\n        : m_recording_buffer(nullptr), m_allocated_size(0) {\n        if (max_recording_bytes > 0) {\n            m_recording_buffer = (uint8_t*)malloc(max_recording_bytes);\n            if (m_recording_buffer) {\n                m_allocated_size = max_recording_bytes;\n            }\n        }\n    }\n\n    ~SensorDataRecorderVulnerable() {\n        if (m_recording_buffer) {\n            free(m_recording_buffer);\n            m_recording_buffer = nullptr;\n        }\n    }\n\n    bool processSensorDataPacketVulnerable(const uint8_t* packet_data, size_t packet_len) {\n        if (!packet_data || packet_len < sizeof(SensorPacketHeader)) {\n            return false;\n        }\n\n        const SensorPacketHeader* header = reinterpret_cast<const SensorPacketHeader*>(packet_data);\n\n        uint32_t expected_packet_data_length_bytes = header->num_samples_in_packet * sizeof(SensorSample);\n\n        uint32_t dest_offset = header->offset_in_total_stream;\n\n        if (dest_offset + expected_packet_data_length_bytes > m_allocated_size) {\n            return false;\n        }\n\n        if (packet_len < sizeof(SensorPacketHeader) + (size_t)header->num_samples_in_packet * sizeof(SensorSample)) {\n            return false;\n        }\n\n        size_t source_data_read_offset = sizeof(SensorPacketHeader);\n\n        for (uint32_t i = 0; i < header->num_samples_in_packet; ++i) {\n            size_t current_sample_size = sizeof(SensorSample);\n            \n            size_t current_source_pos = source_data_read_offset + (size_t)i * current_sample_size;\n            size_t current_dest_pos = dest_offset + (size_t)i * current_sample_size;\n\n            for (size_t k = 0; k < current_sample_size; ++k) {\n                m_recording_buffer[current_dest_pos + k] = packet_data[current_source_pos + k];\n            }\n        }\n\n        return true;\n    }\n\n    size_t getAllocatedSize() const {\n        return m_allocated_size;\n    }\n\n    const uint8_t* getRecordingBuffer() const {\n        return m_recording_buffer;\n    }\n\nprivate:\n    uint8_t* m_recording_buffer;\n    size_t m_allocated_size;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <limits>\n\nstruct SensorSample {\n    uint32_t timestamp;\n    int16_t  value_x;\n    int16_t  value_y;\n    int16_t  value_z;\n    uint8_t  status;\n};\n\nstruct SensorPacketHeader {\n    uint16_t packet_id;\n    uint32_t offset_in_total_stream;\n    uint32_t num_samples_in_packet;\n};\n\nclass SensorDataRecorderFixed {\npublic:\n    SensorDataRecorderFixed(size_t max_recording_bytes)\n        : m_recording_buffer(nullptr), m_allocated_size(0) {\n        if (max_recording_bytes > 0) {\n            m_recording_buffer = (uint8_t*)malloc(max_recording_bytes);\n            if (m_recording_buffer) {\n                m_allocated_size = max_recording_bytes;\n            }\n        }\n    }\n\n    ~SensorDataRecorderFixed() {\n        if (m_recording_buffer) {\n            free(m_recording_buffer);\n            m_recording_buffer = nullptr;\n        }\n    }\n\n    bool processSensorDataPacketFixed(const uint8_t* packet_data, size_t packet_len) {\n        if (!packet_data || packet_len < sizeof(SensorPacketHeader)) {\n            return false;\n        }\n\n        const SensorPacketHeader* header = reinterpret_cast<const SensorPacketHeader*>(packet_data);\n\n        size_t samples_data_length;\n        if (header->num_samples_in_packet > std::numeric_limits<size_t>::max() / sizeof(SensorSample)) {\n            return false;\n        }\n        samples_data_length = (size_t)header->num_samples_in_packet * sizeof(SensorSample);\n\n        size_t dest_offset = header->offset_in_total_stream;\n\n        if (dest_offset > std::numeric_limits<size_t>::max() - samples_data_length) {\n            return false;\n        }\n        size_t end_write_pos = dest_offset + samples_data_length;\n\n        if (end_write_pos > m_allocated_size) {\n            return false;\n        }\n\n        if (packet_len < sizeof(SensorPacketHeader) + samples_data_length) {\n            return false;\n        }\n\n        size_t source_data_read_offset = sizeof(SensorPacketHeader);\n\n        for (uint32_t i = 0; i < header->num_samples_in_packet; ++i) {\n            size_t current_sample_size = sizeof(SensorSample);\n            \n            size_t current_source_pos = source_data_read_offset + (size_t)i * current_sample_size;\n            size_t current_dest_pos = dest_offset + (size_t)i * current_sample_size;\n\n            for (size_t k = 0; k < current_sample_size; ++k) {\n                m_recording_buffer[current_dest_pos + k] = packet_data[current_source_pos + k];\n            }\n        }\n\n        return true;\n    }\n\n    size_t getAllocatedSize() const {\n        return m_allocated_size;\n    }\n\n    const uint8_t* getRecordingBuffer() const {\n        return m_recording_buffer;\n    }\n\nprivate:\n    uint8_t* m_recording_buffer;\n    size_t m_allocated_size;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n#pragma pack(push, 1)\nstruct ModuleConfigHeader {\n    uint16_t module_id;\n    uint16_t payload_length; \n};\n#pragma pack(pop)\n\nconst size_t MAX_STORED_CONFIG_ENTRIES = 5; \nconst size_t ALLOC_SLOT_PAYLOAD_SIZE = 64; \n\nclass FirmwareConfigStorageVulnerable {\nprivate:\n    uint8_t* m_config_buffer;\n    size_t m_current_data_offset; \n    size_t m_total_allocated_capacity; \n    size_t m_num_stored_entries; \n\npublic:\n    FirmwareConfigStorageVulnerable() :\n        m_config_buffer(nullptr),\n        m_current_data_offset(0),\n        m_total_allocated_capacity(0),\n        m_num_stored_entries(0)\n    {\n        m_total_allocated_capacity = MAX_STORED_CONFIG_ENTRIES * (sizeof(ModuleConfigHeader) + ALLOC_SLOT_PAYLOAD_SIZE);\n        m_config_buffer = (uint8_t*)malloc(m_total_allocated_capacity);\n        if (!m_config_buffer) {\n            m_total_allocated_capacity = 0;\n        }\n    }\n\n    ~FirmwareConfigStorageVulnerable() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n        }\n    }\n\n    bool addModuleConfigEntryVulnerable(const uint8_t* raw_entry_data, size_t raw_entry_data_len) {\n        if (!m_config_buffer || !raw_entry_data || raw_entry_data_len < sizeof(ModuleConfigHeader)) {\n            return false;\n        }\n\n        const ModuleConfigHeader* header = reinterpret_cast<const ModuleConfigHeader*>(raw_entry_data);\n        uint16_t actual_payload_len = header->payload_length;\n\n        size_t incoming_entry_full_size = sizeof(ModuleConfigHeader) + actual_payload_len;\n\n        if (incoming_entry_full_size != raw_entry_data_len) {\n            return false;\n        }\n\n        if (m_num_stored_entries >= MAX_STORED_CONFIG_ENTRIES) {\n            return false;\n        }\n\n        size_t write_position_for_entry = m_num_stored_entries * (sizeof(ModuleConfigHeader) + ALLOC_SLOT_PAYLOAD_SIZE);\n\n        memcpy(m_config_buffer + write_position_for_entry, raw_entry_data, incoming_entry_full_size);\n\n        m_num_stored_entries++;\n\n        return true;\n    }\n\n    size_t getNumStoredEntries() const {\n        return m_num_stored_entries;\n    }\n\n    size_t getTotalAllocatedCapacity() const {\n        return m_total_allocated_capacity;\n    }\n\n    const uint8_t* getConfigBuffer() const {\n        return m_config_buffer;\n    }\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n#pragma pack(push, 1)\nstruct ModuleConfigHeader {\n    uint16_t module_id;\n    uint16_t payload_length; \n};\n#pragma pack(pop)\n\nconst size_t MAX_STORED_CONFIG_ENTRIES = 5; \nconst size_t ALLOC_SLOT_PAYLOAD_SIZE = 64; \n\nclass FirmwareConfigStorageFixed {\nprivate:\n    uint8_t* m_config_buffer;\n    size_t m_current_data_offset; \n    size_t m_total_allocated_capacity; \n    size_t m_num_stored_entries; \n\npublic:\n    FirmwareConfigStorageFixed() :\n        m_config_buffer(nullptr),\n        m_current_data_offset(0),\n        m_total_allocated_capacity(0),\n        m_num_stored_entries(0)\n    {\n        m_total_allocated_capacity = MAX_STORED_CONFIG_ENTRIES * (sizeof(ModuleConfigHeader) + ALLOC_SLOT_PAYLOAD_SIZE);\n        m_config_buffer = (uint8_t*)malloc(m_total_allocated_capacity);\n        if (!m_config_buffer) {\n            m_total_allocated_capacity = 0;\n        }\n    }\n\n    ~FirmwareConfigStorageFixed() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n        }\n    }\n\n    bool addModuleConfigEntryFixed(const uint8_t* raw_entry_data, size_t raw_entry_data_len) {\n        if (!m_config_buffer || !raw_entry_data || raw_entry_data_len < sizeof(ModuleConfigHeader)) {\n            return false;\n        }\n\n        const ModuleConfigHeader* header = reinterpret_cast<const ModuleConfigHeader*>(raw_entry_data);\n        uint16_t actual_payload_len = header->payload_length;\n\n        if (actual_payload_len > ALLOC_SLOT_PAYLOAD_SIZE) {\n            return false; \n        }\n\n        size_t incoming_entry_full_size = sizeof(ModuleConfigHeader) + actual_payload_len;\n\n        if (incoming_entry_full_size != raw_entry_data_len) {\n            return false;\n        }\n\n        if (m_num_stored_entries >= MAX_STORED_CONFIG_ENTRIES) {\n            return false;\n        }\n\n        size_t write_position_for_entry = m_num_stored_entries * (sizeof(ModuleConfigHeader) + ALLOC_SLOT_PAYLOAD_SIZE);\n\n        if (write_position_for_entry + incoming_entry_full_size > m_total_allocated_capacity) {\n            return false; \n        }\n\n        memcpy(m_config_buffer + write_position_for_entry, raw_entry_data, incoming_entry_full_size);\n\n        m_num_stored_entries++;\n\n        return true;\n    }\n\n    size_t getNumStoredEntries() const {\n        return m_num_stored_entries;\n    }\n\n    size_t getTotalAllocatedCapacity() const {\n        return m_total_allocated_capacity;\n    }\n\n    const uint8_t* getConfigBuffer() const {\n        return m_config_buffer;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <cstring>\n#include <new>\n\n// Represents a packet containing multiple string-based configuration entries.\n// total_string_bytes_in_packet: The sum of lengths of all strings present in this packet, WITHOUT null terminators.\n// num_strings: The count of individual strings in this packet.\nstruct ConfigPacketHeader {\n    uint32_t total_string_bytes_in_packet;\n    uint16_t num_strings;\n};\n\n// Each string entry within the packet payload has its own length.\nstruct StringEntryHeader {\n    uint16_t string_len; // Length of the string data, WITHOUT null terminator.\n};\n\nclass VehicleConfigLoaderVulnerable {\npublic:\n    VehicleConfigLoaderVulnerable() : m_config_strings_buffer(nullptr), m_buffer_capacity(0), m_current_offset(0) {}\n\n    ~VehicleConfigLoaderVulnerable() {\n        if (m_config_strings_buffer) {\n            free(m_config_strings_buffer);\n            m_config_strings_buffer = nullptr;\n        }\n    }\n\n    // Loads configuration strings from a raw packet.\n    // The packet is assumed to contain a ConfigPacketHeader followed by\n    // 'num_strings' entries, where each entry is a StringEntryHeader\n    // followed by its 'string_len' bytes of data.\n    bool loadConfigurationVulnerable(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(ConfigPacketHeader)) {\n            return false;\n        }\n\n        const ConfigPacketHeader* header = reinterpret_cast<const ConfigPacketHeader*>(packet_data);\n\n        // Basic sanity check: ensure total payload bytes claimed by header fits in the actual packet.\n        if (header->total_string_bytes_in_packet > (packet_length - sizeof(ConfigPacketHeader))) {\n            return false;\n        }\n        \n        // Deallocate existing buffer if any.\n        if (m_config_strings_buffer) {\n            free(m_config_strings_buffer);\n            m_config_strings_buffer = nullptr;\n        }\n\n        // VULNERABILITY:\n        // The buffer is allocated exactly based on 'total_string_bytes_in_packet'.\n        // The definition of 'total_string_bytes_in_packet' explicitly states it's WITHOUT null terminators.\n        // However, the loop below explicitly adds a null terminator after each string (m_config_strings_buffer[...]=\\0).\n        // For each of the 'num_strings' present, an extra byte (the null terminator) will be written\n        // beyond the allocated size, leading to a heap-based buffer overflow.\n        m_buffer_capacity = header->total_string_bytes_in_packet;\n        \n        m_config_strings_buffer = (char*)malloc(m_buffer_capacity);\n        if (!m_config_strings_buffer && m_buffer_capacity > 0) {\n            return false; // Allocation failed for a non-zero sized buffer.\n        }\n        \n        m_current_offset = 0;\n\n        const uint8_t* current_payload_ptr = packet_data + sizeof(ConfigPacketHeader);\n        size_t remaining_payload_data = packet_length - sizeof(ConfigPacketHeader);\n\n        for (uint16_t i = 0; i < header->num_strings; ++i) {\n            if (remaining_payload_data < sizeof(StringEntryHeader)) {\n                if (m_config_strings_buffer) { free(m_config_strings_buffer); m_config_strings_buffer = nullptr; }\n                return false;\n            }\n\n            const StringEntryHeader* string_hdr = reinterpret_cast<const StringEntryHeader*>(current_payload_ptr);\n            uint16_t current_string_len = string_hdr->string_len;\n\n            // Advance past the StringEntryHeader\n            current_payload_ptr += sizeof(StringEntryHeader);\n            remaining_payload_data -= sizeof(StringEntryHeader);\n\n            // Check if enough payload data remains for the string content in the input packet.\n            if (remaining_payload_data < current_string_len) {\n                if (m_config_strings_buffer) { free(m_config_strings_buffer); m_config_strings_buffer = nullptr; }\n                return false;\n            }\n            \n            // Copy string data to the internal buffer.\n            memcpy(m_config_strings_buffer + m_current_offset, current_payload_ptr, current_string_len);\n            \n            // Add null terminator after the string data.\n            // This is the operation that causes the heap-based buffer overflow if\n            // m_buffer_capacity was only calculated from 'total_string_bytes_in_packet'.\n            m_config_strings_buffer[m_current_offset + current_string_len] = '\\0'; \n            \n            m_current_offset += current_string_len + 1; // Advance offset, accounting for null terminator\n\n            // Advance past the string data in the input packet.\n            current_payload_ptr += current_string_len;\n            remaining_payload_data -= current_string_len;\n        }\n\n        return true;\n    }\n\n    const char* getConfigStringsBuffer() const { return m_config_strings_buffer; }\n    size_t getBufferSize() const { return m_current_offset; } // Return actual used size (including nulls)\n\nprivate:\n    char*  m_config_strings_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_offset;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <cstring>\n#include <new>\n#include <limits> // For std::numeric_limits\n\n// Represents a packet containing multiple string-based configuration entries.\n// total_string_bytes_in_packet: The sum of lengths of all strings present in this packet, WITHOUT null terminators.\n// num_strings: The count of individual strings in this packet.\nstruct ConfigPacketHeader {\n    uint32_t total_string_bytes_in_packet;\n    uint16_t num_strings;\n};\n\n// Each string entry within the packet payload has its own length.\nstruct StringEntryHeader {\n    uint16_t string_len; // Length of the string data, WITHOUT null terminator.\n};\n\nclass VehicleConfigLoaderFixed {\npublic:\n    VehicleConfigLoaderFixed() : m_config_strings_buffer(nullptr), m_buffer_capacity(0), m_current_offset(0) {}\n\n    ~VehicleConfigLoaderFixed() {\n        if (m_config_strings_buffer) {\n            free(m_config_strings_buffer);\n            m_config_strings_buffer = nullptr;\n        }\n    }\n\n    // Loads configuration strings from a raw packet.\n    // The packet is assumed to contain a ConfigPacketHeader followed by\n    // 'num_strings' entries, where each entry is a StringEntryHeader\n    // followed by its 'string_len' bytes of data.\n    bool loadConfigurationFixed(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(ConfigPacketHeader)) {\n            return false;\n        }\n\n        const ConfigPacketHeader* header = reinterpret_cast<const ConfigPacketHeader*>(packet_data);\n\n        // FIX:\n        // 1. Calculate the required total buffer size, accounting for null terminators for each string.\n        // 2. Add an integer overflow check for this calculation.\n        if (header->num_strings > (std::numeric_limits<size_t>::max() - header->total_string_bytes_in_packet)) {\n            return false; // Integer overflow if num_strings + total_string_bytes_in_packet exceeds size_t max.\n        }\n        size_t required_total_buffer_size = static_cast<size_t>(header->total_string_bytes_in_packet) + header->num_strings;\n\n        // Check if the input packet length is sufficient for all expected string data + individual string headers.\n        if (header->num_strings > (std::numeric_limits<size_t>::max() / sizeof(StringEntryHeader))) {\n            return false; // Prevent integer overflow in string entry header size calculation\n        }\n        size_t expected_packet_payload_size = static_cast<size_t>(header->num_strings) * sizeof(StringEntryHeader) + header->total_string_bytes_in_packet;\n\n        if (packet_length < sizeof(ConfigPacketHeader) + expected_packet_payload_size) {\n            return false;\n        }\n        \n        // Deallocate existing buffer if any.\n        if (m_config_strings_buffer) {\n            free(m_config_strings_buffer);\n            m_config_strings_buffer = nullptr;\n        }\n\n        // FIX: Allocate buffer with enough space for strings AND their null terminators.\n        m_buffer_capacity = required_total_buffer_size;\n        \n        m_config_strings_buffer = (char*)malloc(m_buffer_capacity);\n        if (!m_config_strings_buffer && m_buffer_capacity > 0) { // Check if allocation failed for non-zero sized buffer.\n            return false;\n        }\n        \n        m_current_offset = 0;\n\n        const uint8_t* current_payload_ptr = packet_data + sizeof(ConfigPacketHeader);\n        size_t remaining_payload_data = packet_length - sizeof(ConfigPacketHeader);\n\n        for (uint16_t i = 0; i < header->num_strings; ++i) {\n            if (remaining_payload_data < sizeof(StringEntryHeader)) {\n                if (m_config_strings_buffer) { free(m_config_strings_buffer); m_config_strings_buffer = nullptr; }\n                return false;\n            }\n\n            const StringEntryHeader* string_hdr = reinterpret_cast<const StringEntryHeader*>(current_payload_ptr);\n            uint16_t current_string_len = string_hdr->string_len;\n\n            // Advance past the StringEntryHeader\n            current_payload_ptr += sizeof(StringEntryHeader);\n            remaining_payload_data -= sizeof(StringEntryHeader);\n\n            // Check if enough payload data remains for the string content in the input packet.\n            if (remaining_payload_data < current_string_len) {\n                if (m_config_strings_buffer) { free(m_config_strings_buffer); m_config_strings_buffer = nullptr; }\n                return false;\n            }\n\n            // Check if there is enough space in the destination buffer for the current string AND its null terminator.\n            // This guards against malicious inputs where individual string lengths might exceed what's implied by total_string_bytes_in_packet\n            // or general inconsistencies, even after the initial buffer size calculation.\n            if (m_current_offset > (m_buffer_capacity - (current_string_len + 1))) {\n                 if (m_config_strings_buffer) { free(m_config_strings_buffer); m_config_strings_buffer = nullptr; }\n                 return false;\n            }\n            \n            // Copy string data to the internal buffer.\n            memcpy(m_config_strings_buffer + m_current_offset, current_payload_ptr, current_string_len);\n            \n            // Add null terminator after the string data. This is now safe as space was explicitly allocated.\n            m_config_strings_buffer[m_current_offset + current_string_len] = '\\0'; \n            \n            m_current_offset += current_string_len + 1; // Advance offset, accounting for null terminator\n\n            // Advance past the string data in the input packet.\n            current_payload_ptr += current_string_len;\n            remaining_payload_data -= current_string_len;\n        }\n\n        return true;\n    }\n\n    const char* getConfigStringsBuffer() const { return m_config_strings_buffer; }\n    size_t getBufferSize() const { return m_current_offset; } // Return actual used size (including nulls)\n\nprivate:\n    char*  m_config_strings_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_offset;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <algorithm>\n\n// Define types for clarity\ntypedef uint8_t TelemetryBlockType;\n\n// Telemetry Block Types\nconst TelemetryBlockType TYPE_RAW_SENSOR_DATA = 0x01;\nconst TelemetryBlockType TYPE_TEXT_MESSAGE = 0x02;\nconst TelemetryBlockType TYPE_EVENT_CODE = 0x03;\n\nstruct TelemetryBlockHeader {\n    TelemetryBlockType block_type;\n    uint16_t block_id;\n    uint16_t data_length; // Length of the data payload following this header\n};\n\nclass TelemetryDataBufferVulnerable {\npublic:\n    TelemetryDataBufferVulnerable(size_t initial_capacity = 256)\n        : m_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {\n        if (initial_capacity > 0) {\n            m_buffer = (uint8_t*)malloc(initial_capacity);\n            if (m_buffer) {\n                m_allocated_capacity = initial_capacity;\n            }\n        }\n    }\n\n    ~TelemetryDataBufferVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    // Appends a telemetry block to the internal buffer.\n    // The vulnerability lies here: When TYPE_RAW_SENSOR_DATA is processed,\n    // data_length bytes are received, but they are converted to 2*data_length hex characters.\n    // The buffer resizing logic only accounts for data_length *in bytes* for the\n    // space needed for the raw sensor data, leading to an overflow when the hex characters are written.\n    bool appendTelemetryBlockVulnerable(const TelemetryBlockHeader* header, const uint8_t* payload) {\n        if (!header || !payload || header->data_length == 0) {\n            return false;\n        }\n\n        size_t block_header_size = sizeof(TelemetryBlockHeader);\n        size_t effective_payload_size = 0; // The actual size needed in the buffer for the payload\n\n        switch (header->block_type) {\n            case TYPE_RAW_SENSOR_DATA:\n                // Raw sensor data will be converted to hex string (2 chars per byte)\n                // VULNERABILITY: The realloc calculation below does NOT account for this expansion.\n                // It treats `header->data_length` as the size needed, not `2 * header->data_length`.\n                effective_payload_size = header->data_length; \n                break;\n            case TYPE_TEXT_MESSAGE:\n            case TYPE_EVENT_CODE:\n                // For text or event codes, it's a direct byte copy, plus null terminator\n                effective_payload_size = header->data_length + 1; // +1 for null terminator\n                break;\n            default:\n                return false; // Unknown type\n        }\n\n        size_t total_space_needed_for_this_block = block_header_size + effective_payload_size;\n\n        // Basic check for potential integer overflow in size calculation before addition\n        if (m_current_size > (~(size_t)0) - total_space_needed_for_this_block) {\n            return false;\n        }\n\n        // Check if current buffer has enough space. If not, reallocate.\n        if (m_current_size + total_space_needed_for_this_block > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity == 0 ? total_space_needed_for_this_block : m_allocated_capacity * 2;\n            // Ensure new_capacity is at least what's needed and doesn't overflow during doubling\n            if (m_allocated_capacity > (~(size_t)0) / 2 && m_allocated_capacity != 0) {\n                new_capacity = (~(size_t)0);\n            }\n            if (new_capacity < m_current_size + total_space_needed_for_this_block) {\n                new_capacity = m_current_size + total_space_needed_for_this_block;\n            }\n            \n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_capacity);\n            if (!new_buffer) {\n                if (m_buffer) {\n                    free(m_buffer);\n                    m_buffer = nullptr;\n                }\n                m_current_size = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        if (!m_buffer) {\n            return false;\n        }\n\n        // Copy header\n        memcpy(m_buffer + m_current_size, header, block_header_size);\n        m_current_size += block_header_size;\n\n        // Copy payload based on type\n        switch (header->block_type) {\n            case TYPE_RAW_SENSOR_DATA: {\n                // Convert each byte to two hex characters\n                // This is where the overflow happens: `m_current_size` has only been incremented\n                // by `header->data_length` in the effective_payload_size calculation, \n                // but we write `header->data_length * 2` characters.\n                for (uint16_t i = 0; i < header->data_length; ++i) {\n                    uint8_t byte_val = payload[i];\n                    // VULNERABLE WRITE: No bounds check here for the conversion output\n                    // The allocated space was only for `header->data_length` for this payload,\n                    // but we are writing 2 characters per byte.\n                    m_buffer[m_current_size++] = (byte_val >> 4) < 10 ? ('0' + (byte_val >> 4)) : ('A' + (byte_val >> 4) - 10);\n                    m_buffer[m_current_size++] = (byte_val & 0x0F) < 10 ? ('0' + (byte_val & 0x0F)) : ('A' + (byte_val & 0x0F) - 10);\n                }\n                break;\n            }\n            case TYPE_TEXT_MESSAGE:\n            case TYPE_EVENT_CODE: {\n                memcpy(m_buffer + m_current_size, payload, header->data_length);\n                m_current_size += header->data_length;\n                m_buffer[m_current_size++] = '\\0'; // Null terminate\n                break;\n            }\n            default:\n                return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getBuffer() const { return m_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n\n    // Helper to convert nibble to hex char (0-9, A-F)\n    char nibbleToHex(uint8_t nibble) {\n        if (nibble < 10) {\n            return '0' + nibble;\n        } else {\n            return 'A' + (nibble - 10);\n        }\n    }\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <algorithm>\n#include <limits>\n\n// Define types for clarity\ntypedef uint8_t TelemetryBlockType;\n\n// Telemetry Block Types\nconst TelemetryBlockType TYPE_RAW_SENSOR_DATA = 0x01;\nconst TelemetryBlockType TYPE_TEXT_MESSAGE = 0x02;\nconst TelemetryBlockType TYPE_EVENT_CODE = 0x03;\n\nstruct TelemetryBlockHeader {\n    TelemetryBlockType block_type;\n    uint16_t block_id;\n    uint16_t data_length; // Length of the data payload following this header\n};\n\nclass TelemetryDataBufferFixed {\npublic:\n    TelemetryDataBufferFixed(size_t initial_capacity = 256)\n        : m_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {\n        if (initial_capacity > 0) {\n            m_buffer = (uint8_t*)malloc(initial_capacity);\n            if (m_buffer) {\n                m_allocated_capacity = initial_capacity;\n            }\n        }\n    }\n\n    ~TelemetryDataBufferFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool appendTelemetryBlockFixed(const TelemetryBlockHeader* header, const uint8_t* payload) {\n        if (!header || !payload || header->data_length == 0) {\n            return false;\n        }\n\n        size_t block_header_size = sizeof(TelemetryBlockHeader);\n        size_t required_payload_storage_size = 0; // The actual size needed in the buffer for the payload\n\n        switch (header->block_type) {\n            case TYPE_RAW_SENSOR_DATA:\n                // FIX: Raw sensor data will be converted to hex string (2 chars per byte).\n                // Ensure data_length * 2 doesn't overflow.\n                if (header->data_length > (std::numeric_limits<uint16_t>::max() / 2)) {\n                    return false; // multiplication would overflow\n                }\n                required_payload_storage_size = static_cast<size_t>(header->data_length) * 2;\n                break;\n            case TYPE_TEXT_MESSAGE:\n            case TYPE_EVENT_CODE:\n                // For text or event codes, it's a direct byte copy, plus null terminator\n                // FIX: Ensure data_length + 1 doesn't overflow\n                if (header->data_length == std::numeric_limits<uint16_t>::max()) {\n                    return false; // addition would overflow\n                }\n                required_payload_storage_size = static_cast<size_t>(header->data_length) + 1; // +1 for null terminator\n                break;\n            default:\n                return false; // Unknown type\n        }\n\n        // FIX: Check for integer overflow before adding header size\n        if (block_header_size > std::numeric_limits<size_t>::max() - required_payload_storage_size) {\n            return false; // addition would overflow\n        }\n        size_t total_space_needed_for_this_block = block_header_size + required_payload_storage_size;\n\n        // Check for potential integer overflow in m_current_size + total_space_needed_for_this_block\n        if (m_current_size > std::numeric_limits<size_t>::max() - total_space_needed_for_this_block) {\n            return false; // Would overflow size_t\n        }\n\n        // Check if current buffer has enough space. If not, reallocate.\n        if (m_current_size + total_space_needed_for_this_block > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity == 0 ? total_space_needed_for_this_block : m_allocated_capacity * 2;\n            \n            // Handle overflow during doubling of capacity\n            if (m_allocated_capacity > std::numeric_limits<size_t>::max() / 2 && m_allocated_capacity != 0) {\n                 new_capacity = std::numeric_limits<size_t>::max();\n            }\n\n            // Ensure new_capacity is at least what's needed\n            if (new_capacity < m_current_size + total_space_needed_for_this_block) {\n                new_capacity = m_current_size + total_space_needed_for_this_block;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_capacity);\n            if (!new_buffer) {\n                if (m_buffer) {\n                    free(m_buffer);\n                    m_buffer = nullptr;\n                }\n                m_current_size = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        if (!m_buffer) {\n            return false;\n        }\n\n        // Copy header\n        memcpy(m_buffer + m_current_size, header, block_header_size);\n        m_current_size += block_header_size;\n\n        // Copy payload based on type\n        switch (header->block_type) {\n            case TYPE_RAW_SENSOR_DATA: {\n                // FIX: Loop bound and write now match the correctly calculated required_payload_storage_size\n                size_t bytes_to_write_char_count = static_cast<size_t>(header->data_length) * 2;\n                if (m_current_size > m_allocated_capacity - bytes_to_write_char_count) {\n                    return false;\n                }\n\n                for (uint16_t i = 0; i < header->data_length; ++i) {\n                    uint8_t byte_val = payload[i];\n                    m_buffer[m_current_size++] = nibbleToHex(byte_val >> 4);\n                    m_buffer[m_current_size++] = nibbleToHex(byte_val & 0x0F);\n                }\n                break;\n            }\n            case TYPE_TEXT_MESSAGE:\n            case TYPE_EVENT_CODE: {\n                // FIX: Ensure enough space for memcpy + null terminator\n                size_t copy_len = header->data_length;\n                if (m_current_size > m_allocated_capacity - (copy_len + 1)) {\n                     return false;\n                }\n                memcpy(m_buffer + m_current_size, payload, copy_len);\n                m_current_size += copy_len;\n                m_buffer[m_current_size++] = '\\0'; // Null terminate\n                break;\n            }\n            default:\n                return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getBuffer() const { return m_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n\n    // Helper to convert nibble to hex char (0-9, A-F)\n    char nibbleToHex(uint8_t nibble) {\n        if (nibble < 10) {\n            return '0' + nibble;\n        } else {\n            return 'A' + (nibble - 10);\n        }\n    }\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n\n#pragma pack(push, 1)\n\nstruct SensorRecordHeader {\n    uint16_t record_id;\n    uint32_t timestamp_ms;\n    uint16_t metadata_len; \n};\n\nstruct SensorDataBatchHeader {\n    uint16_t num_records;\n    uint32_t total_payload_bytes; \n};\n\n#pragma pack(pop)\n\nclass SensorDataProcessor {\npublic:\n    SensorDataProcessor() : m_processed_data_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~SensorDataProcessor() {\n        if (m_processed_data_buffer) {\n            delete[] m_processed_data_buffer;\n            m_processed_data_buffer = nullptr;\n        }\n    }\n\n    bool processSensorBatchVulnerable(const uint8_t* raw_batch_packet, size_t packet_length) {\n        if (!raw_batch_packet || packet_length < sizeof(SensorDataBatchHeader)) {\n            return false;\n        }\n\n        const SensorDataBatchHeader* batch_header = reinterpret_cast<const SensorDataBatchHeader*>(raw_batch_packet);\n\n        if (batch_header->total_payload_bytes > (packet_length - sizeof(SensorDataBatchHeader))) {\n            return false;\n        }\n\n        if (m_processed_data_buffer) {\n            delete[] m_processed_data_buffer;\n            m_processed_data_buffer = nullptr;\n        }\n\n        m_buffer_capacity = batch_header->total_payload_bytes;\n        \n        if (m_buffer_capacity == 0 && batch_header->num_records > 0) {\n             return false;\n        }\n        \n        m_processed_data_buffer = new (std::nothrow) uint8_t[m_buffer_capacity];\n        if (!m_processed_data_buffer && m_buffer_capacity > 0) {\n            return false;\n        }\n\n        size_t current_read_offset_in_packet = sizeof(SensorDataBatchHeader);\n        size_t current_write_offset_in_buffer = 0;\n\n        for (uint16_t i = 0; i < batch_header->num_records; ++i) {\n            if (current_read_offset_in_packet + sizeof(SensorRecordHeader) > packet_length) {\n                return false;\n            }\n\n            const SensorRecordHeader* record_header = reinterpret_cast<const SensorRecordHeader*>(raw_batch_packet + current_read_offset_in_packet);\n            uint16_t current_metadata_len = record_header->metadata_len;\n\n            if (current_read_offset_in_packet + sizeof(SensorRecordHeader) + current_metadata_len > packet_length) {\n                return false;\n            }\n\n            size_t bytes_to_copy_this_record = sizeof(SensorRecordHeader) + current_metadata_len;\n            \n            memcpy(m_processed_data_buffer + current_write_offset_in_buffer, record_header, bytes_to_copy_this_record);\n\n            current_read_offset_in_packet += bytes_to_copy_this_record;\n            current_write_offset_in_buffer += bytes_to_copy_this_record;\n        }\n        \n        if (current_write_offset_in_buffer > m_buffer_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedDataBuffer() const {\n        return m_processed_data_buffer;\n    }\n\n    size_t getBufferCapacity() const {\n        return m_buffer_capacity;\n    }\n\nprivate:\n    uint8_t* m_processed_data_buffer;\n    size_t m_buffer_capacity;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n#include <limits>\n\n#pragma pack(push, 1)\n\nstruct SensorRecordHeader {\n    uint16_t record_id;\n    uint32_t timestamp_ms;\n    uint16_t metadata_len; \n};\n\nstruct SensorDataBatchHeader {\n    uint16_t num_records;\n    uint32_t total_payload_bytes; \n};\n\n#pragma pack(pop)\n\nclass SensorDataProcessorFixed {\npublic:\n    SensorDataProcessorFixed() : m_processed_data_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~SensorDataProcessorFixed() {\n        if (m_processed_data_buffer) {\n            delete[] m_processed_data_buffer;\n            m_processed_data_buffer = nullptr;\n        }\n    }\n\n    bool processSensorBatchFixed(const uint8_t* raw_batch_packet, size_t packet_length) {\n        if (!raw_batch_packet || packet_length < sizeof(SensorDataBatchHeader)) {\n            return false;\n        }\n\n        const SensorDataBatchHeader* batch_header = reinterpret_cast<const SensorDataBatchHeader*>(raw_batch_packet);\n\n        if (batch_header->total_payload_bytes > (packet_length - sizeof(SensorDataBatchHeader))) {\n            return false;\n        }\n        \n        size_t calculated_payload_size = 0;\n        size_t current_packet_scan_offset = sizeof(SensorDataBatchHeader);\n\n        static const uint16_t MAX_NUM_RECORDS = 100;\n        if (batch_header->num_records > MAX_NUM_RECORDS) {\n            return false;\n        }\n\n        for (uint16_t i = 0; i < batch_header->num_records; ++i) {\n            if (current_packet_scan_offset > (packet_length - sizeof(SensorRecordHeader))) {\n                return false;\n            }\n\n            const SensorRecordHeader* record_header_scan = reinterpret_cast<const SensorRecordHeader*>(raw_batch_packet + current_packet_scan_offset);\n            uint16_t current_metadata_len = record_header_scan->metadata_len;\n            \n            if (sizeof(SensorRecordHeader) > (std::numeric_limits<size_t>::max() - calculated_payload_size) ||\n                current_metadata_len > (std::numeric_limits<size_t>::max() - calculated_payload_size - sizeof(SensorRecordHeader))) {\n                return false;\n            }\n            \n            calculated_payload_size += sizeof(SensorRecordHeader) + current_metadata_len;\n            current_packet_scan_offset += sizeof(SensorRecordHeader) + current_metadata_len;\n\n            if (current_packet_scan_offset > packet_length) {\n                return false;\n            }\n        }\n\n        if (calculated_payload_size != batch_header->total_payload_bytes) {\n            return false;\n        }\n\n        if (m_processed_data_buffer) {\n            delete[] m_processed_data_buffer;\n            m_processed_data_buffer = nullptr;\n        }\n\n        m_buffer_capacity = calculated_payload_size;\n        \n        if (m_buffer_capacity == 0 && batch_header->num_records > 0) {\n            return false;\n        }\n\n        m_processed_data_buffer = new (std::nothrow) uint8_t[m_buffer_capacity];\n        if (!m_processed_data_buffer && m_buffer_capacity > 0) {\n            return false;\n        }\n\n        size_t current_read_offset_in_packet = sizeof(SensorDataBatchHeader);\n        size_t current_write_offset_in_buffer = 0;\n\n        for (uint16_t i = 0; i < batch_header->num_records; ++i) {\n            if (current_read_offset_in_packet > (packet_length - sizeof(SensorRecordHeader))) {\n                return false;\n            }\n\n            const SensorRecordHeader* record_header = reinterpret_cast<const SensorRecordHeader*>(raw_batch_packet + current_read_offset_in_packet);\n            uint16_t current_metadata_len = record_header->metadata_len;\n\n            if (current_read_offset_in_packet > (packet_length - sizeof(SensorRecordHeader) - current_metadata_len)) {\n                return false;\n            }\n\n            size_t bytes_to_copy_this_record = sizeof(SensorRecordHeader) + current_metadata_len;\n            \n            if (current_write_offset_in_buffer > (m_buffer_capacity - bytes_to_copy_this_record)) {\n                return false; \n            }\n\n            memcpy(m_processed_data_buffer + current_write_offset_in_buffer, record_header, bytes_to_copy_this_record);\n\n            current_read_offset_in_packet += bytes_to_copy_this_record;\n            current_write_offset_in_buffer += bytes_to_copy_this_record;\n        }\n        \n        if (current_write_offset_in_buffer != m_buffer_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedDataBuffer() const {\n        return m_processed_data_buffer;\n    }\n\n    size_t getBufferCapacity() const {\n        return m_buffer_capacity;\n    }\n\nprivate:\n    uint8_t* m_processed_data_buffer;\n    size_t m_buffer_capacity;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <limits>\n\n// Represents a single sensor reading record.\n// The padding is added to ensure sizeof(SensorReading) is a value\n// that facilitates integer overflow demonstration with a large uint32_t count.\nstruct SensorReading {\n    uint32_t timestamp;\n    int16_t  value_x;\n    int16_t  value_y;\n    int16_t  value_z;\n    uint8_t  status_flags;\n    uint8_t  _padding[13]; // Padding to make total size 24 bytes\n};\n\n// Represents a packet received by the vehicle's telemetry system.\nstruct SensorDataPacketHeader {\n    uint16_t packet_id;\n    uint32_t num_readings;  // Number of SensorReading structures in this packet (can be maliciously large)\n    uint32_t total_payload_size_bytes; // Advertised total size of all readings combined\n};\n\nclass SensorDataCollection {\npublic:\n    SensorDataCollection() : m_readings_buffer(nullptr), m_current_num_readings(0), m_allocated_max_readings(0) {}\n\n    ~SensorDataCollection() {\n        clearData();\n    }\n\n    void clearData() {\n        if (m_readings_buffer) {\n            free(m_readings_buffer);\n            m_readings_buffer = nullptr;\n        }\n        m_current_num_readings = 0;\n        m_allocated_max_readings = 0;\n    }\n\n    bool processSensorDataPacketVulnerable(const uint8_t* raw_packet, size_t raw_len) {\n        clearData();\n\n        if (!raw_packet || raw_len < sizeof(SensorDataPacketHeader)) {\n            return false;\n        }\n\n        const SensorDataPacketHeader* header = reinterpret_cast<const SensorDataPacketHeader*>(raw_packet);\n\n        // Basic sanity checks for packet header values\n        if (header->packet_id != 0xABCD) {\n            return false;\n        }\n        if (header->num_readings == 0 && header->total_payload_size_bytes > 0) {\n            return false;\n        }\n\n        // VULNERABILITY: Integer overflow in allocation size calculation leading to heap overflow.\n        // If 'header->num_readings' is maliciously large (e.g., 200,000,000) and 'sizeof(SensorReading)' is 24 bytes,\n        // their product (200,000,000 * 24 = 4,800,000,000) will overflow a 32-bit unsigned integer\n        // (max value approx 4.29 billion). The result will wrap around (e.g., 505,032,704 bytes).\n        // This significantly smaller, wrapped-around value is then used for malloc.\n        uint32_t calculated_alloc_bytes_u32 = header->num_readings * sizeof(SensorReading);\n\n        m_readings_buffer = (SensorReading*)malloc(calculated_alloc_bytes_u32);\n        if (!m_readings_buffer && calculated_alloc_bytes_u32 > 0) {\n            return false; // Allocation failed or zero-size requested for non-zero data\n        }\n\n        // m_allocated_max_readings is set based on the potentially undersized allocated memory.\n        // If overflow occurred, this value will be smaller than the true 'header->num_readings'.\n        m_allocated_max_readings = calculated_alloc_bytes_u32 / sizeof(SensorReading);\n        m_current_num_readings = 0;\n\n        size_t current_packet_read_offset = sizeof(SensorDataPacketHeader);\n\n        // Loop iterates 'header->num_readings' times, which can be the malicious large value.\n        // The internal buffer 'm_readings_buffer' was allocated based on the potentially\n        // overflowed smaller size.\n        for (uint32_t i = 0; i < header->num_readings; ++i) {\n            // Source packet bounds check. This check prevents reading past raw_len,\n            // but does not prevent writing past the allocated heap buffer.\n            if (current_packet_read_offset + sizeof(SensorReading) > raw_len) {\n                clearData();\n                return false;\n            }\n\n            // Direct assignment of SensorReading structure into the heap buffer.\n            // This write operation will cause a heap-based buffer overflow\n            // when 'i' exceeds 'm_allocated_max_readings' due to the undersized allocation.\n            m_readings_buffer[i] = *reinterpret_cast<const SensorReading*>(raw_packet + current_packet_read_offset);\n\n            m_current_num_readings++;\n            current_packet_read_offset += sizeof(SensorReading);\n        }\n        \n        // This consistency check does not prevent the overflow, which already happened during the loop.\n        if (m_current_num_readings != header->num_readings) {\n            clearData();\n            return false;\n        }\n\n        return true;\n    }\n\nprivate:\n    SensorReading* m_readings_buffer;\n    size_t m_current_num_readings;\n    size_t m_allocated_max_readings;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <limits> // For std::numeric_limits\n\n// Represents a single sensor reading record.\nstruct SensorReading {\n    uint32_t timestamp;\n    int16_t  value_x;\n    int16_t  value_y;\n    int16_t  value_z;\n    uint8_t  status_flags;\n    uint8_t  _padding[13]; // Padding to make total size 24 bytes\n};\n\n// Represents a packet received by the vehicle's telemetry system.\nstruct SensorDataPacketHeader {\n    uint16_t packet_id;\n    uint32_t num_readings;\n    uint32_t total_payload_size_bytes;\n};\n\nclass SensorDataCollection {\npublic:\n    SensorDataCollection() : m_readings_buffer(nullptr), m_current_num_readings(0), m_allocated_max_readings(0) {}\n\n    ~SensorDataCollection() {\n        clearData();\n    }\n\n    void clearData() {\n        if (m_readings_buffer) {\n            free(m_readings_buffer);\n            m_readings_buffer = nullptr;\n        }\n        m_current_num_readings = 0;\n        m_allocated_max_readings = 0;\n    }\n\n    bool processSensorDataPacketFixed(const uint8_t* raw_packet, size_t raw_len) {\n        clearData();\n\n        if (!raw_packet || raw_len < sizeof(SensorDataPacketHeader)) {\n            return false;\n        }\n\n        const SensorDataPacketHeader* header = reinterpret_cast<const SensorDataPacketHeader*>(raw_packet);\n\n        // Basic sanity checks for packet header values\n        if (header->packet_id != 0xABCD) {\n            return false;\n        }\n        if (header->num_readings == 0 && header->total_payload_size_bytes > 0) {\n            return false;\n        }\n\n        // FIXED: Prevent integer overflow in allocation size calculation.\n        // Use 'size_t' for calculations to utilize the largest possible integer type for size.\n        // Explicitly check for potential overflow before multiplication.\n        size_t required_total_bytes_for_readings;\n        // Check if `num_readings * sizeof(SensorReading)` would overflow `size_t`.\n        // This indicates an excessive memory request that cannot be safely handled.\n        if (header->num_readings > (std::numeric_limits<size_t>::max() / sizeof(SensorReading))) {\n            return false;\n        }\n        required_total_bytes_for_readings = (size_t)header->num_readings * sizeof(SensorReading);\n        \n        // Additional consistency check: Ensure the advertised total_payload_size_bytes\n        // matches the calculated size based on 'num_readings' and 'sizeof(SensorReading)'.\n        // This catches malformed packets where these two fields are inconsistent.\n        if (required_total_bytes_for_readings != header->total_payload_size_bytes && header->num_readings > 0) {\n            return false;\n        }\n\n        // Critical check: Ensure the source packet actually contains enough data for all readings.\n        // This prevents reading out-of-bounds from the source 'raw_packet'.\n        if (raw_len < sizeof(SensorDataPacketHeader) + required_total_bytes_for_readings) {\n            return false;\n        }\n        \n        // Handle zero-allocation case explicitly.\n        if (required_total_bytes_for_readings == 0) {\n            // No readings, nothing to process/allocate. If num_readings > 0 but size is 0, it's an error.\n            return header->num_readings == 0;\n        }\n\n        m_readings_buffer = (SensorReading*)malloc(required_total_bytes_for_readings);\n        if (!m_readings_buffer) {\n            return false; // Allocation failed\n        }\n        // m_allocated_max_readings is now correctly set based on the truly allocated memory.\n        m_allocated_max_readings = required_total_bytes_for_readings / sizeof(SensorReading);\n        m_current_num_readings = 0;\n\n        size_t current_packet_read_offset = sizeof(SensorDataPacketHeader);\n\n        for (uint32_t i = 0; i < header->num_readings; ++i) {\n            // Explicit bounds check on the destination buffer.\n            // This check is now effective because 'm_allocated_max_readings' is correctly calculated,\n            // preventing writes beyond the allocated heap memory.\n            if (i >= m_allocated_max_readings) {\n                // This condition should ideally not be met if previous checks are sufficient.\n                // It acts as a robust final safeguard.\n                clearData();\n                return false;\n            }\n            \n            // Source buffer bounds check (redundant with earlier check, but good for robustness)\n            if (current_packet_read_offset > (std::numeric_limits<size_t>::max() - sizeof(SensorReading)) ||\n                current_packet_read_offset + sizeof(SensorReading) > raw_len) {\n                clearData();\n                return false;\n            }\n\n            m_readings_buffer[i] = *reinterpret_cast<const SensorReading*>(raw_packet + current_packet_read_offset);\n\n            m_current_num_readings++;\n            current_packet_read_offset += sizeof(SensorReading);\n        }\n        \n        // Final consistency check (ensures all advertised readings were processed and written).\n        if (m_current_num_readings != header->num_readings) {\n            clearData();\n            return false;\n        }\n\n        return true;\n    }\n\nprivate:\n    SensorReading* m_readings_buffer;\n    size_t m_current_num_readings;\n    size_t m_allocated_max_readings;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n\nstruct DTC_Entry {\n    uint32_t code;\n    uint16_t status_flags;\n    uint8_t  occurrence_count;\n    char     reserved[5];\n};\n\nstruct DiagnosticPacketHeader {\n    uint16_t packet_id;\n    uint16_t num_dtc_entries;\n    uint32_t payload_data_bytes;\n};\n\nclass VehicleDiagnosticLoggerVulnerable {\npublic:\n    VehicleDiagnosticLoggerVulnerable() : m_dtc_buffer(nullptr), m_buffer_capacity(0), m_actual_dtc_count(0) {}\n\n    ~VehicleDiagnosticLoggerVulnerable() {\n        if (m_dtc_buffer) {\n            delete[] m_dtc_buffer;\n            m_dtc_buffer = nullptr;\n        }\n    }\n\n    bool processDiagnosticPacketVulnerable(const uint8_t* raw_packet_data, size_t packet_data_len) {\n        if (!raw_packet_data || packet_data_len < sizeof(DiagnosticPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeader* header = reinterpret_cast<const DiagnosticPacketHeader*>(raw_packet_data);\n\n        if (packet_data_len < sizeof(DiagnosticPacketHeader) + header->payload_data_bytes) {\n            return false;\n        }\n\n        if (m_dtc_buffer) {\n            delete[] m_dtc_buffer;\n            m_dtc_buffer = nullptr;\n            m_buffer_capacity = 0;\n            m_actual_dtc_count = 0;\n        }\n\n        m_buffer_capacity = header->num_dtc_entries;\n        if (m_buffer_capacity == 0) {\n            return true;\n        }\n        \n        if (m_buffer_capacity > (SIZE_MAX / sizeof(DTC_Entry))) {\n            return false;\n        }\n\n        m_dtc_buffer = new (std::nothrow) DTC_Entry[m_buffer_capacity];\n        if (!m_dtc_buffer) {\n            return false;\n        }\n\n        const uint8_t* current_payload_ptr = raw_packet_data + sizeof(DiagnosticPacketHeader);\n        size_t current_payload_offset = 0;\n        uint16_t dtc_processed_count = 0;\n\n        while (current_payload_offset + sizeof(DTC_Entry) <= header->payload_data_bytes) {\n            \n            if (current_payload_ptr + current_payload_offset + sizeof(DTC_Entry) > raw_packet_data + packet_data_len) {\n                delete[] m_dtc_buffer;\n                m_dtc_buffer = nullptr;\n                m_buffer_capacity = 0;\n                m_actual_dtc_count = 0;\n                return false;\n            }\n\n            const DTC_Entry* incoming_dtc = reinterpret_cast<const DTC_Entry*>(current_payload_ptr + current_payload_offset);\n            \n            m_dtc_buffer[dtc_processed_count].code = incoming_dtc->code;\n            m_dtc_buffer[dtc_processed_count].status_flags = incoming_dtc->status_flags;\n            m_dtc_buffer[dtc_processed_count].occurrence_count = incoming_dtc->occurrence_count;\n            std::memcpy(m_dtc_buffer[dtc_processed_count].reserved, incoming_dtc->reserved, sizeof(incoming_dtc->reserved));\n\n            current_payload_offset += sizeof(DTC_Entry);\n            dtc_processed_count++;\n        }\n\n        m_actual_dtc_count = dtc_processed_count;\n\n        return true;\n    }\n\n    const DTC_Entry* getDTCBuffer() const { return m_dtc_buffer; }\n    uint16_t getBufferCapacity() const { return m_buffer_capacity; }\n    uint16_t getActualDTCCount() const { return m_actual_dtc_count; }\n\nprivate:\n    DTC_Entry* m_dtc_buffer;\n    uint16_t   m_buffer_capacity;\n    uint16_t   m_actual_dtc_count;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n#include <limits>\n\nstruct DTC_Entry {\n    uint32_t code;\n    uint16_t status_flags;\n    uint8_t  occurrence_count;\n    char     reserved[5];\n};\n\nstruct DiagnosticPacketHeader {\n    uint16_t packet_id;\n    uint16_t num_dtc_entries;\n    uint32_t payload_data_bytes;\n};\n\nclass VehicleDiagnosticLoggerFixed {\npublic:\n    VehicleDiagnosticLoggerFixed() : m_dtc_buffer(nullptr), m_buffer_capacity(0), m_actual_dtc_count(0) {}\n\n    ~VehicleDiagnosticLoggerFixed() {\n        if (m_dtc_buffer) {\n            delete[] m_dtc_buffer;\n            m_dtc_buffer = nullptr;\n        }\n    }\n\n    bool processDiagnosticPacketFixed(const uint8_t* raw_packet_data, size_t packet_data_len) {\n        if (!raw_packet_data || packet_data_len < sizeof(DiagnosticPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeader* header = reinterpret_cast<const DiagnosticPacketHeader*>(raw_packet_data);\n\n        size_t expected_payload_from_num_entries;\n        if (header->num_dtc_entries > (std::numeric_limits<size_t>::max() / sizeof(DTC_Entry))) {\n            return false;\n        }\n        expected_payload_from_num_entries = (size_t)header->num_dtc_entries * sizeof(DTC_Entry);\n\n        if (header->payload_data_bytes != expected_payload_from_num_entries ||\n            packet_data_len < sizeof(DiagnosticPacketHeader) + header->payload_data_bytes) {\n            return false;\n        }\n        \n        if (m_dtc_buffer) {\n            delete[] m_dtc_buffer;\n            m_dtc_buffer = nullptr;\n            m_buffer_capacity = 0;\n            m_actual_dtc_count = 0;\n        }\n\n        m_buffer_capacity = header->num_dtc_entries;\n        if (m_buffer_capacity == 0) {\n            return true;\n        }\n\n        m_dtc_buffer = new (std::nothrow) DTC_Entry[m_buffer_capacity];\n        if (!m_dtc_buffer) {\n            return false;\n        }\n\n        const uint8_t* current_payload_ptr = raw_packet_data + sizeof(DiagnosticPacketHeader);\n        \n        for (uint16_t i = 0; i < m_buffer_capacity; ++i) {\n            if ((size_t)i * sizeof(DTC_Entry) + sizeof(DTC_Entry) > header->payload_data_bytes) {\n                delete[] m_dtc_buffer;\n                m_dtc_buffer = nullptr;\n                m_buffer_capacity = 0;\n                m_actual_dtc_count = 0;\n                return false;\n            }\n\n            const DTC_Entry* incoming_dtc = reinterpret_cast<const DTC_Entry*>(current_payload_ptr + (size_t)i * sizeof(DTC_Entry));\n            \n            m_dtc_buffer[i].code = incoming_dtc->code;\n            m_dtc_buffer[i].status_flags = incoming_dtc->status_flags;\n            m_dtc_buffer[i].occurrence_count = incoming_dtc->occurrence_count;\n            std::memcpy(m_dtc_buffer[i].reserved, incoming_dtc->reserved, sizeof(incoming_dtc->reserved));\n        }\n\n        m_actual_dtc_count = m_buffer_capacity;\n        return true;\n    }\n\n    const DTC_Entry* getDTCBuffer() const { return m_dtc_buffer; }\n    uint16_t getBufferCapacity() const { return m_buffer_capacity; }\n    uint16_t getActualDTCCount() const { return m_actual_dtc_count; }\n\nprivate:\n    DTC_Entry* m_dtc_buffer;\n    uint16_t   m_buffer_capacity;\n    uint16_t   m_actual_dtc_count;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <cstdlib>\n#include <new>\n\nstruct DiagnosticEntryHeader {\n    uint32_t timestamp;\n    uint16_t event_code;\n    uint16_t data_payload_length;\n};\n\nstruct DiagnosticStreamPacket {\n    uint32_t  stream_id;\n    uint16_t  num_entries_in_packet;\n    uint32_t  total_packet_payload_bytes;\n};\n\nclass DiagnosticLogStreamVulnerable {\npublic:\n    DiagnosticLogStreamVulnerable() : m_log_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {}\n\n    ~DiagnosticLogStreamVulnerable() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n    }\n\n    void resetStream() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n        m_current_size = 0;\n        m_allocated_capacity = 0;\n    }\n\n    bool appendDiagnosticDataVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticStreamPacket)) {\n            return false;\n        }\n\n        const DiagnosticStreamPacket* packet_header = reinterpret_cast<const DiagnosticStreamPacket*>(raw_packet);\n        \n        if (packet_len < sizeof(DiagnosticStreamPacket) + packet_header->total_packet_payload_bytes) {\n            return false;\n        }\n\n        const uint8_t* current_data_ptr = raw_packet + sizeof(DiagnosticStreamPacket);\n        size_t bytes_remaining_in_packet = packet_header->total_packet_payload_bytes;\n\n        for (uint16_t i = 0; i < packet_header->num_entries_in_packet; ++i) {\n            if (bytes_remaining_in_packet < sizeof(DiagnosticEntryHeader)) {\n                return false;\n            }\n\n            const DiagnosticEntryHeader* entry_header = reinterpret_cast<const DiagnosticEntryHeader*>(current_data_ptr);\n\n            size_t entry_total_size = sizeof(DiagnosticEntryHeader) + entry_header->data_payload_length;\n\n            if (bytes_remaining_in_packet < entry_total_size) {\n                return false;\n            }\n\n            size_t required_capacity = m_current_size + entry_total_size;\n\n            if (required_capacity > m_allocated_capacity) {\n                size_t new_capacity = m_allocated_capacity * 2;\n\n                if (new_capacity < required_capacity) {\n                    new_capacity = required_capacity;\n                }\n                \n                uint8_t* temp_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n                if (!temp_buffer) {\n                    if (m_log_buffer) {\n                        free(m_log_buffer);\n                        m_log_buffer = nullptr;\n                    }\n                    m_current_size = 0;\n                    m_allocated_capacity = 0;\n                    return false;\n                }\n                m_log_buffer = temp_buffer;\n                m_allocated_capacity = new_capacity;\n            }\n\n            for (size_t k = 0; k < sizeof(DiagnosticEntryHeader); ++k) {\n                m_log_buffer[m_current_size + k] = current_data_ptr[k];\n            }\n            m_current_size += sizeof(DiagnosticEntryHeader);\n\n            for (size_t k = 0; k < entry_header->data_payload_length; ++k) {\n                m_log_buffer[m_current_size + k] = current_data_ptr[sizeof(DiagnosticEntryHeader) + k];\n            }\n            m_current_size += entry_header->data_payload_length;\n\n            current_data_ptr += entry_total_size;\n            bytes_remaining_in_packet -= entry_total_size;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getLogBuffer() const {\n        return m_log_buffer;\n    }\n\n    size_t getCurrentSize() const {\n        return m_current_size;\n    }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <cstdlib>\n#include <new>\n#include <limits>\n\nstruct DiagnosticEntryHeader {\n    uint32_t timestamp;\n    uint16_t event_code;\n    uint16_t data_payload_length;\n};\n\nstruct DiagnosticStreamPacket {\n    uint32_t  stream_id;\n    uint16_t  num_entries_in_packet;\n    uint32_t  total_packet_payload_bytes;\n};\n\nclass DiagnosticLogStreamFixed {\npublic:\n    DiagnosticLogStreamFixed() : m_log_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {}\n\n    ~DiagnosticLogStreamFixed() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n    }\n\n    void resetStream() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n        m_current_size = 0;\n        m_allocated_capacity = 0;\n    }\n\n    bool appendDiagnosticDataFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticStreamPacket)) {\n            return false;\n        }\n\n        const DiagnosticStreamPacket* packet_header = reinterpret_cast<const DiagnosticStreamPacket*>(raw_packet);\n        \n        if (packet_len < sizeof(DiagnosticStreamPacket) + packet_header->total_packet_payload_bytes) {\n            return false;\n        }\n\n        const uint8_t* current_data_ptr = raw_packet + sizeof(DiagnosticStreamPacket);\n        size_t bytes_remaining_in_packet = packet_header->total_packet_payload_bytes;\n\n        static const uint16_t MAX_SINGLE_PAYLOAD_LENGTH = 0xFFF0; \n\n        for (uint16_t i = 0; i < packet_header->num_entries_in_packet; ++i) {\n            if (bytes_remaining_in_packet < sizeof(DiagnosticEntryHeader)) {\n                return false;\n            }\n\n            const DiagnosticEntryHeader* entry_header = reinterpret_cast<const DiagnosticEntryHeader*>(current_data_ptr);\n\n            if (entry_header->data_payload_length > MAX_SINGLE_PAYLOAD_LENGTH) {\n                return false;\n            }\n\n            size_t entry_total_size = sizeof(DiagnosticEntryHeader) + entry_header->data_payload_length;\n\n            if (bytes_remaining_in_packet < entry_total_size) {\n                return false;\n            }\n\n            if (m_current_size > std::numeric_limits<size_t>::max() - entry_total_size) {\n                return false;\n            }\n            \n            size_t required_capacity = m_current_size + entry_total_size;\n\n            if (required_capacity > m_allocated_capacity) {\n                size_t new_capacity;\n\n                if (m_allocated_capacity > std::numeric_limits<size_t>::max() / 2) {\n                    new_capacity = std::numeric_limits<size_t>::max();\n                } else {\n                    new_capacity = m_allocated_capacity * 2;\n                }\n\n                if (new_capacity < required_capacity) {\n                    if (required_capacity > std::numeric_limits<size_t>::max()) {\n                        return false;\n                    }\n                    new_capacity = required_capacity;\n                }\n                \n                uint8_t* temp_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n                if (!temp_buffer) {\n                    if (m_log_buffer) {\n                        free(m_log_buffer);\n                        m_log_buffer = nullptr;\n                    }\n                    m_current_size = 0;\n                    m_allocated_capacity = 0;\n                    return false;\n                }\n                m_log_buffer = temp_buffer;\n                m_allocated_capacity = new_capacity;\n            }\n\n            for (size_t k = 0; k < sizeof(DiagnosticEntryHeader); ++k) {\n                m_log_buffer[m_current_size + k] = current_data_ptr[k];\n            }\n            m_current_size += sizeof(DiagnosticEntryHeader);\n\n            for (size_t k = 0; k < entry_header->data_payload_length; ++k) {\n                m_log_buffer[m_current_size + k] = current_data_ptr[sizeof(DiagnosticEntryHeader) + k];\n            }\n            m_current_size += entry_header->data_payload_length;\n\n            current_data_ptr += entry_total_size;\n            bytes_remaining_in_packet -= entry_total_size;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getLogBuffer() const {\n        return m_log_buffer;\n    }\n\n    size_t getCurrentSize() const {\n        return m_current_size;\n    }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <algorithm>\n#include <limits>\n\nstruct DiagnosticRecordHeader {\n    uint16_t record_id;\n    uint16_t data_length; \n};\n\nclass DiagnosticDataStoreVulnerable {\npublic:\n    DiagnosticDataStoreVulnerable() : m_buffer(nullptr), m_current_data_size(0), m_allocated_capacity(0) {}\n\n    ~DiagnosticDataStoreVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool appendDiagnosticRecordVulnerable(const uint8_t* raw_record_data, size_t raw_record_len) {\n        if (!raw_record_data || raw_record_len < sizeof(DiagnosticRecordHeader)) {\n            return false;\n        }\n\n        const DiagnosticRecordHeader* header = reinterpret_cast<const DiagnosticRecordHeader*>(raw_record_data);\n        uint16_t advertised_data_length = header->data_length;\n\n        if (raw_record_len != (sizeof(DiagnosticRecordHeader) + advertised_data_length)) {\n            return false;\n        }\n\n        size_t new_required_capacity = m_current_data_size + advertised_data_length;\n\n        const size_t MAX_TOTAL_BUFFER_SIZE = 16 * 1024 * 1024;\n        if (new_required_capacity > MAX_TOTAL_BUFFER_SIZE) {\n            return false;\n        }\n        \n        uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_required_capacity);\n\n        if (!new_buffer && new_required_capacity > 0) {\n            return false;\n        }\n        \n        m_buffer = new_buffer;\n        m_allocated_capacity = new_required_capacity;\n\n        std::memcpy(m_buffer + m_current_data_size, raw_record_data, raw_record_len);\n        \n        m_current_data_size += raw_record_len;\n\n        return true;\n    }\n\n    const uint8_t* getRawDataBuffer() const {\n        return m_buffer;\n    }\n\n    size_t getCurrentDataSize() const {\n        return m_current_data_size;\n    }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_current_data_size;\n    size_t m_allocated_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <algorithm>\n#include <limits>\n\nstruct DiagnosticRecordHeader {\n    uint16_t record_id;\n    uint16_t data_length; \n};\n\nclass DiagnosticDataStoreFixed {\npublic:\n    DiagnosticDataStoreFixed() : m_buffer(nullptr), m_current_data_size(0), m_allocated_capacity(0) {}\n\n    ~DiagnosticDataStoreFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool appendDiagnosticRecordFixed(const uint8_t* raw_record_data, size_t raw_record_len) {\n        if (!raw_record_data || raw_record_len < sizeof(DiagnosticRecordHeader)) {\n            return false;\n        }\n\n        const DiagnosticRecordHeader* header = reinterpret_cast<const DiagnosticRecordHeader*>(raw_record_data);\n        uint16_t advertised_data_length = header->data_length;\n\n        if (raw_record_len != (sizeof(DiagnosticRecordHeader) + advertised_data_length)) {\n            return false;\n        }\n\n        size_t new_required_capacity;\n        if (m_current_data_size > (std::numeric_limits<size_t>::max() - raw_record_len)) {\n            return false;\n        }\n        new_required_capacity = m_current_data_size + raw_record_len;\n\n        const size_t MAX_TOTAL_BUFFER_SIZE = 16 * 1024 * 1024;\n        if (new_required_capacity > MAX_TOTAL_BUFFER_SIZE) {\n            return false;\n        }\n        \n        uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_required_capacity);\n\n        if (!new_buffer && new_required_capacity > 0) {\n            return false;\n        }\n        \n        m_buffer = new_buffer;\n        m_allocated_capacity = new_required_capacity;\n\n        std::memcpy(m_buffer + m_current_data_size, raw_record_data, raw_record_len);\n        \n        m_current_data_size += raw_record_len;\n\n        return true;\n    }\n\n    const uint8_t* getRawDataBuffer() const {\n        return m_buffer;\n    }\n\n    size_t getCurrentDataSize() const {\n        return m_current_data_size;\n    }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_current_data_size;\n    size_t m_allocated_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <numeric>\n\nstruct CommandPacketHeader {\n    uint16_t command_id;\n    uint16_t payload_length;\n    uint8_t flags;\n};\n\nstruct ProcessedCommand {\n    uint16_t command_id;\n    size_t   data_size;\n    uint8_t* data;\n};\n\nclass CommandProcessorVulnerable {\npublic:\n    CommandProcessorVulnerable() : m_processed_cmd_data(nullptr), m_allocated_size(0) {}\n\n    ~CommandProcessorVulnerable() {\n        if (m_processed_cmd_data) {\n            delete[] m_processed_cmd_data;\n            m_processed_cmd_data = nullptr;\n        }\n    }\n\n    bool processCommandVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(CommandPacketHeader)) {\n            return false;\n        }\n\n        const CommandPacketHeader* header = reinterpret_cast<const CommandPacketHeader*>(raw_packet);\n\n        static const uint16_t MAX_ALLOWED_PAYLOAD = 1024;\n        if (header->payload_length == 0 || header->payload_length > MAX_ALLOWED_PAYLOAD) {\n            return false;\n        }\n\n        if (packet_len < (sizeof(CommandPacketHeader) + header->payload_length)) {\n            return false;\n        }\n\n        if (m_processed_cmd_data) {\n            delete[] m_processed_cmd_data;\n            m_processed_cmd_data = nullptr;\n            m_allocated_size = 0;\n        }\n\n        m_processed_cmd_data = new (std::nothrow) uint8_t[header->payload_length];\n        if (!m_processed_cmd_data) {\n            return false;\n        }\n        m_allocated_size = header->payload_length;\n\n        const uint8_t* payload_src = raw_packet + sizeof(CommandPacketHeader);\n        for (uint16_t i = 0; i < header->payload_length; ++i) {\n            m_processed_cmd_data[i] = payload_src[i];\n        }\n\n        if (header->command_id == 0x101 || header->command_id == 0x202) {\n            uint8_t checksum = 0;\n            for (uint16_t i = 0; i < header->payload_length; ++i) {\n                checksum ^= m_processed_cmd_data[i];\n            }\n            m_processed_cmd_data[header->payload_length] = checksum;\n        }\n\n        m_last_processed_cmd.command_id = header->command_id;\n        m_last_processed_cmd.data_size = header->payload_length;\n        m_last_processed_cmd.data = m_processed_cmd_data;\n\n        return true;\n    }\n\n    const ProcessedCommand& getLastProcessedCommand() const {\n        return m_last_processed_cmd;\n    }\n\nprivate:\n    uint8_t* m_processed_cmd_data;\n    size_t m_allocated_size;\n    ProcessedCommand m_last_processed_cmd;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <numeric>\n#include <limits>\n\nstruct CommandPacketHeader {\n    uint16_t command_id;\n    uint16_t payload_length;\n    uint8_t flags;\n};\n\nstruct ProcessedCommand {\n    uint16_t command_id;\n    size_t   data_size;\n    uint8_t* data;\n};\n\nclass CommandProcessorFixed {\npublic:\n    CommandProcessorFixed() : m_processed_cmd_data(nullptr), m_allocated_size(0) {}\n\n    ~CommandProcessorFixed() {\n        if (m_processed_cmd_data) {\n            delete[] m_processed_cmd_data;\n            m_processed_cmd_data = nullptr;\n        }\n    }\n\n    bool processCommandFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(CommandPacketHeader)) {\n            return false;\n        }\n\n        const CommandPacketHeader* header = reinterpret_cast<const CommandPacketHeader*>(raw_packet);\n\n        static const uint16_t MAX_ALLOWED_PAYLOAD = 1024;\n        if (header->payload_length == 0 || header->payload_length > MAX_ALLOWED_PAYLOAD) {\n            return false;\n        }\n\n        bool needs_checksum_byte = (header->command_id == 0x101 || header->command_id == 0x202);\n        size_t required_allocation_size = header->payload_length;\n        if (needs_checksum_byte) {\n            if (required_allocation_size >= std::numeric_limits<size_t>::max()) {\n                return false;\n            }\n            required_allocation_size += 1;\n        }\n        \n        if (packet_len < (sizeof(CommandPacketHeader) + header->payload_length)) {\n            return false;\n        }\n\n        if (m_processed_cmd_data) {\n            delete[] m_processed_cmd_data;\n            m_processed_cmd_data = nullptr;\n            m_allocated_size = 0;\n        }\n\n        m_processed_cmd_data = new (std::nothrow) uint8_t[required_allocation_size];\n        if (!m_processed_cmd_data) {\n            return false;\n        }\n        m_allocated_size = required_allocation_size;\n\n        const uint8_t* payload_src = raw_packet + sizeof(CommandPacketHeader);\n        for (uint16_t i = 0; i < header->payload_length; ++i) {\n            m_processed_cmd_data[i] = payload_src[i];\n        }\n\n        if (needs_checksum_byte) {\n            uint8_t checksum = 0;\n            for (uint16_t i = 0; i < header->payload_length; ++i) {\n                checksum ^= m_processed_cmd_data[i];\n            }\n            m_processed_cmd_data[header->payload_length] = checksum;\n        }\n\n        m_last_processed_cmd.command_id = header->command_id;\n        m_last_processed_cmd.data_size = header->payload_length;\n        m_last_processed_cmd.data = m_processed_cmd_data;\n\n        return true;\n    }\n\n    const ProcessedCommand& getLastProcessedCommand() const {\n        return m_last_processed_cmd;\n    }\n\nprivate:\n    uint8_t* m_processed_cmd_data;\n    size_t m_allocated_size;\n    ProcessedCommand m_last_processed_cmd;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n\n#pragma pack(push, 1)\nstruct SensorBatchHeader {\n    uint32_t timestamp;\n    uint16_t num_entries;\n};\n\nstruct SensorEntryHeader {\n    uint8_t  sensor_id;\n    uint16_t data_len; \n};\n#pragma pack(pop)\n\nclass VehicleSensorLoggerVulnerable {\npublic:\n    VehicleSensorLoggerVulnerable() :\n        m_log_buffer(nullptr),\n        m_current_buffer_size(0),\n        m_allocated_capacity(0)\n    {\n        m_allocated_capacity = 1024;\n        m_log_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_log_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~VehicleSensorLoggerVulnerable() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n    }\n\n    bool addSensorBatchVulnerable(const uint8_t* raw_data_packet, size_t packet_length) {\n        if (!raw_data_packet || packet_length < sizeof(SensorBatchHeader)) {\n            return false;\n        }\n\n        const SensorBatchHeader* batch_hdr = reinterpret_cast<const SensorBatchHeader*>(raw_data_packet);\n        size_t current_packet_offset = sizeof(SensorBatchHeader);\n        size_t total_new_data_size = 0;\n\n        for (uint16_t i = 0; i < batch_hdr->num_entries; ++i) {\n            if (current_packet_offset + sizeof(SensorEntryHeader) > packet_length) {\n                return false;\n            }\n            const SensorEntryHeader* entry_hdr = reinterpret_cast<const SensorEntryHeader*>(raw_data_packet + current_packet_offset);\n            uint16_t entry_data_len = entry_hdr->data_len;\n\n            size_t required_entry_size = sizeof(SensorEntryHeader) + entry_data_len;\n            total_new_data_size += required_entry_size;\n            \n            if (current_packet_offset + required_entry_size > packet_length) {\n                return false;\n            }\n            current_packet_offset += required_entry_size;\n        }\n\n        // VULNERABILITY: Integer overflow in required_total_space calculation.\n        // If m_current_buffer_size is already very large (e.g., near SIZE_MAX) and\n        // total_new_data_size is also large, their sum can wrap around, resulting\n        // in a significantly smaller 'required_total_space' than actually needed.\n        size_t required_total_space = m_current_buffer_size + total_new_data_size;\n        \n        if (required_total_space > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity * 2; \n            if (new_capacity < required_total_space) {\n                new_capacity = required_total_space + 256; \n            }\n            // If required_total_space wrapped around, new_capacity will also be small.\n            \n            uint8_t* new_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n            if (!new_buffer) {\n                return false;\n            }\n            m_log_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        current_packet_offset = sizeof(SensorBatchHeader);\n        \n        for (uint16_t i = 0; i < batch_hdr->num_entries; ++i) {\n            const SensorEntryHeader* entry_hdr = reinterpret_cast<const SensorEntryHeader*>(raw_data_packet + current_packet_offset);\n            uint16_t entry_data_len = entry_hdr->data_len;\n            size_t bytes_to_copy_for_entry = sizeof(SensorEntryHeader) + entry_data_len;\n\n            m_log_buffer[m_current_buffer_size] = entry_hdr->sensor_id;\n            m_log_buffer[m_current_buffer_size + 1] = (uint8_t)(entry_hdr->data_len & 0xFF);\n            m_log_buffer[m_current_buffer_size + 2] = (uint8_t)((entry_hdr->data_len >> 8) & 0xFF);\n            \n            const uint8_t* payload_src = raw_data_packet + current_packet_offset + sizeof(SensorEntryHeader);\n            // VULNERABILITY: If the buffer was undersized due to the integer overflow above,\n            // this loop will write past the end of the allocated 'm_log_buffer' in the heap.\n            for (uint16_t j = 0; j < entry_data_len; ++j) {\n                m_log_buffer[m_current_buffer_size + sizeof(SensorEntryHeader) + j] = payload_src[j];\n            }\n            \n            m_current_buffer_size += bytes_to_copy_for_entry;\n            current_packet_offset += bytes_to_copy_for_entry;\n        }\n\n        return true;\n    }\n\n    size_t getCurrentBufferSize() const { return m_current_buffer_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n    const uint8_t* getLogBuffer() const { return m_log_buffer; }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t m_current_buffer_size;\n    size_t m_allocated_capacity;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct SensorBatchHeader {\n    uint32_t timestamp;\n    uint16_t num_entries;\n};\n\nstruct SensorEntryHeader {\n    uint8_t  sensor_id;\n    uint16_t data_len;\n};\n#pragma pack(pop)\n\nclass VehicleSensorLoggerFixed {\npublic:\n    VehicleSensorLoggerFixed() :\n        m_log_buffer(nullptr),\n        m_current_buffer_size(0),\n        m_allocated_capacity(0)\n    {\n        m_allocated_capacity = 1024;\n        m_log_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_log_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~VehicleSensorLoggerFixed() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n    }\n\n    bool addSensorBatchFixed(const uint8_t* raw_data_packet, size_t packet_length) {\n        if (!raw_data_packet || packet_length < sizeof(SensorBatchHeader)) {\n            return false;\n        }\n\n        const SensorBatchHeader* batch_hdr = reinterpret_cast<const SensorBatchHeader*>(raw_data_packet);\n        size_t current_packet_offset_scan = sizeof(SensorBatchHeader);\n        size_t total_new_data_size = 0;\n\n        static const uint16_t MAX_BATCH_ENTRIES = 250;\n        if (batch_hdr->num_entries > MAX_BATCH_ENTRIES) {\n            return false;\n        }\n\n        for (uint16_t i = 0; i < batch_hdr->num_entries; ++i) {\n            if (current_packet_offset_scan > (packet_length - sizeof(SensorEntryHeader))) {\n                return false;\n            }\n            const SensorEntryHeader* entry_hdr = reinterpret_cast<const SensorEntryHeader*>(raw_data_packet + current_packet_offset_scan);\n            uint16_t entry_data_len = entry_hdr->data_len;\n\n            if (sizeof(SensorEntryHeader) > (std::numeric_limits<size_t>::max() - total_new_data_size) ||\n                entry_data_len > (std::numeric_limits<size_t>::max() - total_new_data_size - sizeof(SensorEntryHeader))) {\n                return false;\n            }\n            \n            size_t required_entry_size = sizeof(SensorEntryHeader) + entry_data_len;\n            total_new_data_size += required_entry_size;\n            \n            if (current_packet_offset_scan > (packet_length - required_entry_size)) {\n                return false;\n            }\n            current_packet_offset_scan += required_entry_size;\n        }\n\n        if (total_new_data_size > (std::numeric_limits<size_t>::max() - m_current_buffer_size)) {\n            return false;\n        }\n        size_t required_total_space = m_current_buffer_size + total_new_data_size;\n\n        if (required_total_space > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity * 2;\n            if (new_capacity < m_allocated_capacity) {\n                new_capacity = std::numeric_limits<size_t>::max();\n            }\n            \n            if (new_capacity < required_total_space) {\n                new_capacity = required_total_space;\n            }\n\n            static const size_t MAX_LOG_BUFFER_SIZE = 16 * 1024 * 1024;\n            if (new_capacity > MAX_LOG_BUFFER_SIZE) {\n                if (required_total_space > MAX_LOG_BUFFER_SIZE) {\n                    return false;\n                }\n                new_capacity = MAX_LOG_BUFFER_SIZE;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n            if (!new_buffer) {\n                return false;\n            }\n            m_log_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        size_t current_packet_offset_copy = sizeof(SensorBatchHeader);\n        \n        for (uint16_t i = 0; i < batch_hdr->num_entries; ++i) {\n            const SensorEntryHeader* entry_hdr = reinterpret_cast<const SensorEntryHeader*>(raw_data_packet + current_packet_offset_copy);\n            uint16_t entry_data_len = entry_hdr->data_len;\n            size_t bytes_to_copy_for_entry = sizeof(SensorEntryHeader) + entry_data_len;\n\n            if (m_current_buffer_size > (m_allocated_capacity - bytes_to_copy_for_entry)) {\n                return false;\n            }\n\n            m_log_buffer[m_current_buffer_size] = entry_hdr->sensor_id;\n            m_log_buffer[m_current_buffer_size + 1] = (uint8_t)(entry_hdr->data_len & 0xFF);\n            m_log_buffer[m_current_buffer_size + 2] = (uint8_t)((entry_hdr->data_len >> 8) & 0xFF);\n            \n            const uint8_t* payload_src = raw_data_packet + current_packet_offset_copy + sizeof(SensorEntryHeader);\n            for (uint16_t j = 0; j < entry_data_len; ++j) {\n                m_log_buffer[m_current_buffer_size + sizeof(SensorEntryHeader) + j] = payload_src[j];\n            }\n            \n            m_current_buffer_size += bytes_to_copy_for_entry;\n            current_packet_offset_copy += bytes_to_copy_for_entry;\n        }\n\n        return true;\n    }\n\n    size_t getCurrentBufferSize() const { return m_current_buffer_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n    const uint8_t* getLogBuffer() const { return m_log_buffer; }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t m_current_buffer_size;\n    size_t m_allocated_capacity;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n// Represents a single diagnostic event's metadata\nstruct EventMetadata {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t payload_length; // Actual length of this specific event's payload\n};\n\n// --- Vulnerable Class --- \n// Designed to store a stream of diagnostic events in a pre-allocated contiguous buffer.\nclass DiagnosticStorageVulnerable {\npublic:\n    // Constructor: Allocates a buffer based on an expected maximum number of events\n    // and a 'configured' maximum payload size per event. This 'configured' size\n    // is used to determine the fixed slot size for each event in the buffer.\n    DiagnosticStorageVulnerable(uint32_t max_total_events, uint16_t configured_max_payload_per_event)\n        : m_buffer(nullptr), m_buffer_capacity_bytes(0), m_current_event_count(0),\n          m_configured_max_payload_size(configured_max_payload_per_event) {\n\n        if (max_total_events == 0 || configured_max_payload_per_event == 0) {\n            return;\n        }\n\n        // Calculate the fixed size of each slot in the buffer.\n        // This size includes the EventMetadata and a fixed-size payload area\n        // based on 'configured_max_payload_per_event'.\n        size_t bytes_per_event_slot = sizeof(EventMetadata) + configured_max_payload_per_event;\n        \n        // Basic overflow check for the size_t calculation\n        if (max_total_events > SIZE_MAX / bytes_per_event_slot) {\n            // Prevent immediate integer overflow during allocation size calculation\n            return;\n        }\n\n        m_buffer_capacity_bytes = max_total_events * bytes_per_event_slot;\n        m_buffer = (uint8_t*)malloc(m_buffer_capacity_bytes);\n\n        if (m_buffer == nullptr && m_buffer_capacity_bytes > 0) {\n            m_buffer_capacity_bytes = 0; // Allocation failed\n        }\n    }\n\n    ~DiagnosticStorageVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    // Stores a single diagnostic event into the internal buffer.\n    // 'event_data' points to a byte stream containing EventMetadata followed by its payload.\n    // 'data_len' is the total length of 'event_data' (metadata + payload).\n    bool storeEventVulnerable(const uint8_t* event_data, size_t data_len) {\n        if (!event_data || data_len < sizeof(EventMetadata) || m_buffer == nullptr) {\n            return false;\n        }\n\n        const EventMetadata* incoming_meta = reinterpret_cast<const EventMetadata*>(event_data);\n        uint16_t actual_payload_len = incoming_meta->payload_length;\n        size_t total_incoming_event_size = sizeof(EventMetadata) + actual_payload_len;\n\n        // Ensure the incoming data itself is complete and not truncated\n        if (data_len < total_incoming_event_size) {\n            return false;\n        }\n\n        // Calculate the target offset in the internal buffer for the new event.\n        // This calculation relies on m_configured_max_payload_size for the slot size.\n        size_t bytes_per_event_slot = sizeof(EventMetadata) + m_configured_max_payload_size;\n        size_t write_offset = m_current_event_count * bytes_per_event_slot;\n\n        // This check validates if there's enough overall allocated space for the *next slot*\n        // based on the 'configured' size. It DOES NOT check if the *actual* incoming event's\n        // payload length exceeds the individual slot's configured size.\n        if (write_offset + bytes_per_event_slot > m_buffer_capacity_bytes) {\n            return false; // Not enough total capacity for another event slot at configured size\n        }\n\n        // VULNERABILITY:\n        // The 'memcpy' copies 'total_incoming_event_size' bytes. If 'actual_payload_len'\n        // (from the incoming data) is greater than 'm_configured_max_payload_size'\n        // (used for allocation and slot size calculation), then 'total_incoming_event_size'\n        // will be larger than 'bytes_per_event_slot'.\n        // This will cause 'memcpy' to write beyond the bounds of the current event's\n        // allocated slot in 'm_buffer', overflowing into the subsequent event's slot,\n        // or potentially past the end of 'm_buffer' if it's the last event.\n        // There is no check to ensure 'actual_payload_len <= m_configured_max_payload_size' here.\n        memcpy(m_buffer + write_offset, event_data, total_incoming_event_size);\n\n        m_current_event_count++;\n        return true;\n    }\n\n    size_t getStoredEventCount() const { return m_current_event_count; }\n    size_t getAllocatedCapacityBytes() const { return m_buffer_capacity_bytes; }\n    const uint8_t* getBuffer() const { return m_buffer; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_buffer_capacity_bytes;\n    uint32_t m_current_event_count;\n    uint16_t m_configured_max_payload_size; // Maximum payload size assumed for each slot during allocation\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits> // For SIZE_MAX\n\n// Represents a single diagnostic event's metadata\nstruct EventMetadata {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t payload_length; // Actual length of this specific event's payload\n};\n\n// --- Fixed Class ---\n// Designed to store a stream of diagnostic events in a pre-allocated contiguous buffer.\nclass DiagnosticStorageFixed {\npublic:\n    // Constructor: Allocates a buffer based on an expected maximum number of events\n    // and a 'configured' maximum payload size per event. This 'configured' size\n    // is used to determine the fixed slot size for each event in the buffer.\n    DiagnosticStorageFixed(uint32_t max_total_events, uint16_t configured_max_payload_per_event)\n        : m_buffer(nullptr), m_buffer_capacity_bytes(0), m_current_event_count(0),\n          m_configured_max_payload_size(configured_max_payload_per_event) {\n\n        if (max_total_events == 0 || configured_max_payload_per_event == 0) {\n            return;\n        }\n\n        // Calculate the fixed size of each slot in the buffer.\n        // This size includes the EventMetadata and a fixed-size payload area\n        // based on 'configured_max_payload_per_event'.\n        size_t bytes_per_event_slot = sizeof(EventMetadata) + configured_max_payload_per_event;\n        \n        // Basic overflow check for the size_t calculation\n        if (max_total_events > SIZE_MAX / bytes_per_event_slot) {\n            // Prevent immediate integer overflow during allocation size calculation\n            return;\n        }\n\n        m_buffer_capacity_bytes = max_total_events * bytes_per_event_slot;\n        m_buffer = (uint8_t*)malloc(m_buffer_capacity_bytes);\n\n        if (m_buffer == nullptr && m_buffer_capacity_bytes > 0) {\n            m_buffer_capacity_bytes = 0; // Allocation failed\n        }\n    }\n\n    ~DiagnosticStorageFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    // Stores a single diagnostic event into the internal buffer.\n    // 'event_data' points to a byte stream containing EventMetadata followed by its payload.\n    // 'data_len' is the total length of 'event_data' (metadata + payload).\n    bool storeEventFixed(const uint8_t* event_data, size_t data_len) {\n        if (!event_data || data_len < sizeof(EventMetadata) || m_buffer == nullptr) {\n            return false;\n        }\n\n        const EventMetadata* incoming_meta = reinterpret_cast<const EventMetadata*>(event_data);\n        uint16_t actual_payload_len = incoming_meta->payload_length;\n        \n        // FIX: Add a crucial check to ensure that the actual payload length of the\n        // incoming event does not exceed the 'configured_max_payload_size'.\n        // This prevents an individual event from overflowing its pre-allocated slot.\n        if (actual_payload_len > m_configured_max_payload_size) {\n            return false; // Reject event as its payload is too large for the configured slot size\n        }\n\n        size_t total_incoming_event_size = sizeof(EventMetadata) + actual_payload_len;\n\n        // Ensure the incoming data itself is complete and not truncated\n        if (data_len < total_incoming_event_size) {\n            return false;\n        }\n\n        // Calculate the target offset in the internal buffer for the new event.\n        // This calculation relies on m_configured_max_payload_size for the slot size.\n        size_t bytes_per_event_slot = sizeof(EventMetadata) + m_configured_max_payload_size;\n        size_t write_offset = m_current_event_count * bytes_per_event_slot;\n\n        // Ensure there is enough overall buffer capacity for the current event's slot.\n        // This check is now effective, as 'total_incoming_event_size' is guaranteed\n        // to be less than or equal to 'bytes_per_event_slot' after the fix.\n        if (write_offset > m_buffer_capacity_bytes ||\n            write_offset + bytes_per_event_slot > m_buffer_capacity_bytes) {\n            return false;\n        }\n        \n        // memcpy is now safe because total_incoming_event_size is guaranteed to fit within the slot.\n        memcpy(m_buffer + write_offset, event_data, total_incoming_event_size);\n\n        m_current_event_count++;\n        return true;\n    }\n\n    size_t getStoredEventCount() const { return m_current_event_count; }\n    size_t getAllocatedCapacityBytes() const { return m_buffer_capacity_bytes; }\n    const uint8_t* getBuffer() const { return m_buffer; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_buffer_capacity_bytes;\n    uint32_t m_current_event_count;\n    uint16_t m_configured_max_payload_size; // Maximum payload size assumed for each slot during allocation\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <new>\n\n#pragma pack(push, 1)\nstruct EventRecordHeaderVulnerable {\n    uint16_t event_type;\n    uint16_t data_size; \n};\n#pragma pack(pop)\n\nclass EventRecordVulnerable {\npublic:\n    EventRecordVulnerable() : m_event_data(nullptr), m_allocated_data_size(0) {}\n\n    ~EventRecordVulnerable() {\n        if (m_event_data) {\n            delete[] m_event_data;\n            m_event_data = nullptr;\n        }\n    }\n\n    bool populateFromRawDataVulnerable(const uint8_t* raw_input_block, size_t input_block_len) {\n        if (!raw_input_block || input_block_len < sizeof(EventRecordHeaderVulnerable)) {\n            return false;\n        }\n\n        const EventRecordHeaderVulnerable* header = reinterpret_cast<const EventRecordHeaderVulnerable*>(raw_input_block);\n        \n        uint16_t advertised_data_len = header->data_size;\n\n        if (m_event_data) {\n            delete[] m_event_data;\n            m_event_data = nullptr;\n        }\n\n        m_event_data = new (std::nothrow) uint8_t[advertised_data_len];\n        if (!m_event_data) {\n            m_allocated_data_size = 0;\n            return false;\n        }\n        m_allocated_data_size = advertised_data_len;\n\n        size_t bytes_to_copy = input_block_len - sizeof(EventRecordHeaderVulnerable);\n\n        for (size_t i = 0; i < bytes_to_copy; ++i) {\n            m_event_data[i] = raw_input_block[sizeof(EventRecordHeaderVulnerable) + i];\n        }\n\n        return true;\n    }\n\n    const uint8_t* getEventData() const {\n        return m_event_data;\n    }\n\n    uint16_t getAllocatedDataSize() const {\n        return m_allocated_data_size;\n    }\n\nprivate:\n    uint8_t* m_event_data;\n    uint16_t m_allocated_data_size;\n};\n\nclass VehicleEventDataManagerVulnerable {\npublic:\n    VehicleEventDataManagerVulnerable() {}\n    ~VehicleEventDataManagerVulnerable() {\n        for (auto* record : m_records) {\n            delete record;\n        }\n    }\n\n    bool addEventFromPacketVulnerable(const uint8_t* packet_data, size_t packet_len) {\n        EventRecordVulnerable* new_record = new (std::nothrow) EventRecordVulnerable();\n        if (!new_record) {\n            return false;\n        }\n\n        if (!new_record->populateFromRawDataVulnerable(packet_data, packet_len)) {\n            delete new_record;\n            return false;\n        }\n\n        m_records.push_back(new_record);\n        return true;\n    }\n\n    size_t getNumRecords() const {\n        return m_records.size();\n    }\n\n    const EventRecordVulnerable* getRecord(size_t index) const {\n        if (index < m_records.size()) {\n            return m_records[index];\n        }\n        return nullptr;\n    }\n\nprivate:\n    std::vector<EventRecordVulnerable*> m_records;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <new>\n#include <algorithm>\n\n#pragma pack(push, 1)\nstruct EventRecordHeaderFixed {\n    uint16_t event_type;\n    uint16_t data_size; \n};\n#pragma pack(pop)\n\nclass EventRecordFixed {\npublic:\n    EventRecordFixed() : m_event_data(nullptr), m_allocated_data_size(0) {}\n\n    ~EventRecordFixed() {\n        if (m_event_data) {\n            delete[] m_event_data;\n            m_event_data = nullptr;\n        }\n    }\n\n    bool populateFromRawDataFixed(const uint8_t* raw_input_block, size_t input_block_len) {\n        if (!raw_input_block || input_block_len < sizeof(EventRecordHeaderFixed)) {\n            return false;\n        }\n\n        const EventRecordHeaderFixed* header = reinterpret_cast<const EventRecordHeaderFixed*>(raw_input_block);\n        \n        uint16_t advertised_data_len = header->data_size;\n\n        if (m_event_data) {\n            delete[] m_event_data;\n            m_event_data = nullptr;\n        }\n\n        m_event_data = new (std::nothrow) uint8_t[advertised_data_len];\n        if (!m_event_data) {\n            m_allocated_data_size = 0;\n            return false;\n        }\n        m_allocated_data_size = advertised_data_len;\n\n        size_t actual_data_available_in_input = 0;\n        if (input_block_len > sizeof(EventRecordHeaderFixed)) {\n            actual_data_available_in_input = input_block_len - sizeof(EventRecordHeaderFixed);\n        } else {\n            return false;\n        }\n        \n        size_t bytes_to_copy = std::min((size_t)advertised_data_len, actual_data_available_in_input);\n\n        for (size_t i = 0; i < bytes_to_copy; ++i) {\n            m_event_data[i] = raw_input_block[sizeof(EventRecordHeaderFixed) + i];\n        }\n\n        return true;\n    }\n\n    const uint8_t* getEventData() const {\n        return m_event_data;\n    }\n\n    uint16_t getAllocatedDataSize() const {\n        return m_allocated_data_size;\n    }\n\nprivate:\n    uint8_t* m_event_data;\n    uint16_t m_allocated_data_size;\n};\n\nclass VehicleEventDataManagerFixed {\npublic:\n    VehicleEventDataManagerFixed() {}\n    ~VehicleEventDataManagerFixed() {\n        for (auto* record : m_records) {\n            delete record;\n        }\n    }\n\n    bool addEventFromPacketFixed(const uint8_t* packet_data, size_t packet_len) {\n        EventRecordFixed* new_record = new (std::nothrow) EventRecordFixed();\n        if (!new_record) {\n            return false;\n        }\n\n        if (!new_record->populateFromRawDataFixed(packet_data, packet_len)) {\n            delete new_record;\n            return false;\n        }\n\n        m_records.push_back(new_record);\n        return true;\n    }\n\n    size_t getNumRecords() const {\n        return m_records.size();\n    }\n\n    const EventRecordFixed* getRecord(size_t index) const {\n        if (index < m_records.size()) {\n            return m_records[index];\n        }\n        return nullptr;\n    }\n\nprivate:\n    std::vector<EventRecordFixed*> m_records;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n\nstruct TelemetryEntryHeader {\n    uint8_t  entry_type;\n    uint16_t entry_data_len;\n};\n\n#define CAN_MESSAGE_PAYLOAD_SIZE 8\n#define MAX_TELEMETRY_BUFFER_SIZE (1 * 1024 * 1024)\n\nclass TelemetryRecorderVulnerable {\nprivate:\n    uint8_t* m_buffer;\n    size_t m_current_offset;\n    size_t m_allocated_capacity;\n\npublic:\n    TelemetryRecorderVulnerable() : m_buffer(nullptr), m_current_offset(0), m_allocated_capacity(0) {\n        m_allocated_capacity = 4096;\n        m_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~TelemetryRecorderVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool recordTelemetryEntryVulnerable(const uint8_t* raw_entry, size_t raw_entry_len) {\n        if (!raw_entry || raw_entry_len < sizeof(TelemetryEntryHeader)) {\n            return false;\n        }\n\n        const TelemetryEntryHeader* header = reinterpret_cast<const TelemetryEntryHeader*>(raw_entry);\n        uint8_t entry_type = header->entry_type;\n        uint16_t advertised_data_len = header->entry_data_len;\n\n        size_t required_space_for_this_entry = sizeof(TelemetryEntryHeader) + advertised_data_len;\n\n        if (m_current_offset + required_space_for_this_entry > MAX_TELEMETRY_BUFFER_SIZE) {\n            return false;\n        }\n\n        if (m_current_offset + required_space_for_this_entry > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity * 2;\n            if (new_capacity < m_current_offset + required_space_for_this_entry) {\n                new_capacity = m_current_offset + required_space_for_this_entry + 4096;\n            }\n            if (new_capacity > MAX_TELEMETRY_BUFFER_SIZE) {\n                new_capacity = MAX_TELEMETRY_BUFFER_SIZE;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_capacity);\n            if (!new_buffer) {\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        for (size_t i = 0; i < sizeof(TelemetryEntryHeader); ++i) {\n            m_buffer[m_current_offset + i] = raw_entry[i];\n        }\n\n        const uint8_t* payload_src = raw_entry + sizeof(TelemetryEntryHeader);\n        size_t bytes_to_copy_payload;\n\n        if (entry_type == 0x03) {\n            bytes_to_copy_payload = (size_t)advertised_data_len * CAN_MESSAGE_PAYLOAD_SIZE;\n        } else {\n            bytes_to_copy_payload = advertised_data_len;\n        }\n\n        if (raw_entry_len < sizeof(TelemetryEntryHeader) + bytes_to_copy_payload) {\n            return false;\n        }\n        \n        for (size_t i = 0; i < bytes_to_copy_payload; ++i) {\n            m_buffer[m_current_offset + sizeof(TelemetryEntryHeader) + i] = payload_src[i];\n        }\n\n        m_current_offset += sizeof(TelemetryEntryHeader) + bytes_to_copy_payload;\n\n        return true;\n    }\n\n    const uint8_t* getTelemetryBuffer() const {\n        return m_buffer;\n    }\n\n    size_t getContainedDataSize() const {\n        return m_current_offset;\n    }\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\n\nstruct TelemetryEntryHeader {\n    uint8_t  entry_type;\n    uint16_t entry_data_len;\n};\n\n#define CAN_MESSAGE_PAYLOAD_SIZE 8\n#define MAX_TELEMETRY_BUFFER_SIZE (1 * 1024 * 1024)\n\nclass TelemetryRecorderFixed {\nprivate:\n    uint8_t* m_buffer;\n    size_t m_current_offset;\n    size_t m_allocated_capacity;\n\npublic:\n    TelemetryRecorderFixed() : m_buffer(nullptr), m_current_offset(0), m_allocated_capacity(0) {\n        m_allocated_capacity = 4096;\n        m_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~TelemetryRecorderFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool recordTelemetryEntryFixed(const uint8_t* raw_entry, size_t raw_entry_len) {\n        if (!raw_entry || raw_entry_len < sizeof(TelemetryEntryHeader)) {\n            return false;\n        }\n\n        const TelemetryEntryHeader* header = reinterpret_cast<const TelemetryEntryHeader*>(raw_entry);\n        uint8_t entry_type = header->entry_type;\n        uint16_t advertised_data_len_or_count = header->entry_data_len;\n\n        size_t actual_payload_size;\n        if (entry_type == 0x03) {\n            if (advertised_data_len_or_count > (std::numeric_limits<size_t>::max() / CAN_MESSAGE_PAYLOAD_SIZE)) {\n                 return false;\n            }\n            actual_payload_size = (size_t)advertised_data_len_or_count * CAN_MESSAGE_PAYLOAD_SIZE;\n        } else {\n            actual_payload_size = advertised_data_len_or_count;\n        }\n\n        if (actual_payload_size > (std::numeric_limits<size_t>::max() - sizeof(TelemetryEntryHeader))) {\n            return false;\n        }\n        size_t required_space_for_this_entry = sizeof(TelemetryEntryHeader) + actual_payload_size;\n\n        if (m_current_offset > (MAX_TELEMETRY_BUFFER_SIZE - required_space_for_this_entry)) {\n            return false;\n        }\n\n        if (m_current_offset + required_space_for_this_entry > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity;\n            if (new_capacity == 0) {\n                new_capacity = 4096;\n            }\n\n            while (new_capacity < m_current_offset + required_space_for_this_entry) {\n                if (new_capacity > (std::numeric_limits<size_t>::max() / 2)) {\n                    new_capacity = std::numeric_limits<size_t>::max();\n                    break;\n                }\n                new_capacity *= 2;\n            }\n            if (new_capacity > MAX_TELEMETRY_BUFFER_SIZE) {\n                new_capacity = MAX_TELEMETRY_BUFFER_SIZE;\n            }\n            if (new_capacity < m_current_offset + required_space_for_this_entry) {\n                return false;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_capacity);\n            if (!new_buffer && new_capacity > 0) {\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        if (raw_entry_len < sizeof(TelemetryEntryHeader) + actual_payload_size) {\n            return false;\n        }\n        \n        for (size_t i = 0; i < sizeof(TelemetryEntryHeader); ++i) {\n            m_buffer[m_current_offset + i] = raw_entry[i];\n        }\n\n        const uint8_t* payload_src = raw_entry + sizeof(TelemetryEntryHeader);\n        \n        for (size_t i = 0; i < actual_payload_size; ++i) {\n            m_buffer[m_current_offset + sizeof(TelemetryEntryHeader) + i] = payload_src[i];\n        }\n\n        m_current_offset += required_space_for_this_entry;\n\n        return true;\n    }\n\n    const uint8_t* getTelemetryBuffer() const {\n        return m_buffer;\n    }\n\n    size_t getContainedDataSize() const {\n        return m_current_offset;\n    }\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n\n// Max theoretical size for a decoded data block to prevent extreme allocation.\n// Even with this, an overflow can occur if the internal RLE logic expands beyond a malicious 'total_decoded_size' field.\n#define MAX_DECODED_BLOCK_SIZE 65536 // 64KB\n\n// Represents the header for an incoming telemetry data block\nstruct TelemetryBlockHeader {\n    uint16_t block_id;\n    uint16_t num_entries;\n    uint32_t total_decoded_size; // Advertised total size of ALL decoded data entries in this block\n};\n\n// Represents the header for an individual entry within the block\nstruct TelemetryEntryHeader {\n    uint8_t  entry_type; // 0x01 for raw, 0x02 for RLE\n    uint16_t encoded_data_length; // Length of the *encoded* data that follows this header\n};\n\nenum TelemetryEntryType : uint8_t {\n    RAW_DATA = 0x01,\n    RLE_DATA = 0x02\n};\n\nclass VehicleTelemetryProcessorVulnerable {\npublic:\n    VehicleTelemetryProcessorVulnerable() : m_decoded_buffer(nullptr), m_current_buffer_pos(0), m_allocated_capacity(0) {}\n\n    ~VehicleTelemetryProcessorVulnerable() {\n        if (m_decoded_buffer) {\n            free(m_decoded_buffer);\n        }\n    }\n\n    void resetBuffer() {\n        if (m_decoded_buffer) {\n            free(m_decoded_buffer);\n            m_decoded_buffer = nullptr;\n        }\n        m_current_buffer_pos = 0;\n        m_allocated_capacity = 0;\n    }\n\n    // Processes a raw telemetry data packet and appends decoded data to an internal buffer.\n    bool processTelemetryBlockVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(TelemetryBlockHeader)) {\n            return false;\n        }\n\n        const TelemetryBlockHeader* block_header = reinterpret_cast<const TelemetryBlockHeader*>(raw_packet);\n\n        // Preliminary check for packet size vs advertised total payload\n        // This check is insufficient, as total_decoded_size can be manipulated by attacker\n        // to be smaller than actual decoded size while still fitting in packet_len\n        if (packet_len < sizeof(TelemetryBlockHeader) + block_header->total_decoded_size) {\n            return false;\n        }\n\n        // Allocate buffer based on the *advertised* total_decoded_size.\n        // VULNERABILITY: This size might be undersized if RLE entries expand beyond what the attacker\n        // advertises as total_decoded_size, leading to a heap overflow during the copy loop.\n        size_t desired_alloc_size = block_header->total_decoded_size;\n        if (desired_alloc_size == 0) { // Handle empty block case\n             resetBuffer();\n             return true;\n        }\n\n        // Apply a hard limit to prevent excessively large legitimate allocations,\n        // but this doesn't prevent overflow for malicious inputs within this limit.\n        if (desired_alloc_size > MAX_DECODED_BLOCK_SIZE) {\n            return false;\n        }\n\n        // Reallocate/allocate the buffer\n        uint8_t* new_buffer = (uint8_t*)realloc(m_decoded_buffer, desired_alloc_size);\n        if (!new_buffer) {\n            // Realloc failed, clean up old buffer if it existed\n            if (m_decoded_buffer) free(m_decoded_buffer);\n            m_decoded_buffer = nullptr;\n            m_current_buffer_pos = 0;\n            m_allocated_capacity = 0;\n            return false;\n        }\n        m_decoded_buffer = new_buffer;\n        m_allocated_capacity = desired_alloc_size;\n        m_current_buffer_pos = 0; // Reset position for new block processing\n\n        size_t current_packet_offset = sizeof(TelemetryBlockHeader);\n\n        for (uint16_t i = 0; i < block_header->num_entries; ++i) {\n            if (current_packet_offset + sizeof(TelemetryEntryHeader) > packet_len) {\n                resetBuffer();\n                return false;\n            }\n\n            const TelemetryEntryHeader* entry_header = reinterpret_cast<const TelemetryEntryHeader*>(raw_packet + current_packet_offset);\n            \n            // Check if the encoded data fits within the packet\n            if (current_packet_offset + sizeof(TelemetryEntryHeader) + entry_header->encoded_data_length > packet_len) {\n                resetBuffer();\n                return false;\n            }\n\n            const uint8_t* entry_data_ptr = raw_packet + current_packet_offset + sizeof(TelemetryEntryHeader);\n            size_t bytes_to_read = entry_header->encoded_data_length;\n\n            switch (entry_header->entry_type) {\n                case RAW_DATA: {\n                    // Direct copy of raw data\n                    if (m_current_buffer_pos + bytes_to_read > m_allocated_capacity) {\n                        // This check exists, but for RLE data, bytes_to_read is encoded length, not decoded.\n                        // If total_decoded_size was manipulated, this may be too late or not applicable.\n                        resetBuffer();\n                        return false;\n                    }\n                    std::memcpy(m_decoded_buffer + m_current_buffer_pos, entry_data_ptr, bytes_to_read);\n                    m_current_buffer_pos += bytes_to_read;\n                    break;\n                }\n                case RLE_DATA: {\n                    // Process Run-Length Encoded data (format: [byte_to_repeat][repeat_count]...)\n                    size_t rle_current_read_offset = 0;\n                    while (rle_current_read_offset + 1 < bytes_to_read) { // Need at least 2 bytes (value, count)\n                        uint8_t value_to_repeat = entry_data_ptr[rle_current_read_offset];\n                        uint8_t repeat_count = entry_data_ptr[rle_current_read_offset + 1];\n\n                        // VULNERABILITY: No check here if 'm_current_buffer_pos + repeat_count' exceeds 'm_allocated_capacity'.\n                        // The 'm_allocated_capacity' is based on the potentially undersized 'total_decoded_size' field.\n                        // An attacker can craft a 'total_decoded_size' smaller than the actual\n                        // expanded size of RLE data, leading to a heap overflow.\n                        for (uint8_t k = 0; k < repeat_count; ++k) {\n                            m_decoded_buffer[m_current_buffer_pos + k] = value_to_repeat;\n                        }\n                        m_current_buffer_pos += repeat_count;\n\n                        rle_current_read_offset += 2; // Move to the next RLE pair\n                    }\n                    break;\n                }\n                default:\n                    // Unknown type, or other types would be handled here\n                    resetBuffer();\n                    return false;\n            }\n            current_packet_offset += sizeof(TelemetryEntryHeader) + bytes_to_read;\n        }\n\n        // Final check: ensure the total size written matches the advertised size.\n        // This check comes *after* the writes, so an overflow would have already occurred if triggered.\n        if (m_current_buffer_pos > block_header->total_decoded_size) {\n            resetBuffer(); \n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getDecodedBuffer() const { return m_decoded_buffer; }\n    size_t getCurrentDecodedSize() const { return m_current_buffer_pos; }\n\nprivate:\n    uint8_t* m_decoded_buffer;\n    size_t   m_current_buffer_pos;\n    size_t   m_allocated_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\n// Max theoretical size for a decoded data block to prevent extreme allocation.\n#define MAX_DECODED_BLOCK_SIZE 65536 // 64KB\n\n// Represents the header for an incoming telemetry data block\nstruct TelemetryBlockHeaderFixed {\n    uint16_t block_id;\n    uint16_t num_entries;\n    uint32_t total_decoded_size; // Advertised total size of ALL decoded data entries in this block\n};\n\n// Represents the header for an individual entry within the block\nstruct TelemetryEntryHeaderFixed {\n    uint8_t  entry_type;\n    uint16_t encoded_data_length; // Length of the *encoded* data that follows this header\n};\n\nenum TelemetryEntryTypeFixed : uint8_t {\n    RAW_DATA_FIXED = 0x01,\n    RLE_DATA_FIXED = 0x02\n};\n\nclass VehicleTelemetryProcessorFixed {\npublic:\n    VehicleTelemetryProcessorFixed() : m_decoded_buffer(nullptr), m_current_buffer_pos(0), m_allocated_capacity(0) {}\n\n    ~VehicleTelemetryProcessorFixed() {\n        if (m_decoded_buffer) {\n            free(m_decoded_buffer);\n        }\n    }\n\n    void resetBuffer() {\n        if (m_decoded_buffer) {\n            free(m_decoded_buffer);\n            m_decoded_buffer = nullptr;\n        }\n        m_current_buffer_pos = 0;\n        m_allocated_capacity = 0;\n    }\n\n    // Processes a raw telemetry data packet and appends decoded data to an internal buffer.\n    bool processTelemetryBlockFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(TelemetryBlockHeaderFixed)) {\n            return false;\n        }\n\n        const TelemetryBlockHeaderFixed* block_header = reinterpret_cast<const TelemetryBlockHeaderFixed*>(raw_packet);\n\n        // FIX: Calculate the *actual* maximum possible decoded size based on entries in a pre-pass.\n        size_t calculated_max_decoded_size = 0;\n        size_t current_packet_offset_for_calc = sizeof(TelemetryBlockHeaderFixed);\n\n        for (uint16_t i = 0; i < block_header->num_entries; ++i) {\n            // Ensure enough data for header itself in the packet\n            if (current_packet_offset_for_calc + sizeof(TelemetryEntryHeaderFixed) > packet_len) {\n                return false; \n            }\n            const TelemetryEntryHeaderFixed* entry_header_calc = reinterpret_cast<const TelemetryEntryHeaderFixed*>(raw_packet + current_packet_offset_for_calc);\n\n            // Ensure encoded data length does not exceed packet boundary\n            if (current_packet_offset_for_calc + sizeof(TelemetryEntryHeaderFixed) + entry_header_calc->encoded_data_length > packet_len) {\n                return false;\n            }\n            \n            size_t max_decoded_bytes_for_entry = 0;\n            if (entry_header_calc->entry_type == RAW_DATA_FIXED) {\n                max_decoded_bytes_for_entry = entry_header_calc->encoded_data_length;\n            } else if (entry_header_calc->entry_type == RLE_DATA_FIXED) {\n                // RLE: each 2 bytes (value, count) can expand to up to 255 bytes.\n                // So, encoded_data_length bytes can expand to (encoded_data_length / 2) * 255.\n                if (entry_header_calc->encoded_data_length % 2 != 0) {\n                    return false; // Malformed RLE data (odd number of bytes)\n                }\n                size_t num_rle_pairs = entry_header_calc->encoded_data_length / 2;\n                // Check for integer overflow before multiplication\n                if (num_rle_pairs > (std::numeric_limits<size_t>::max() / 255)) {\n                    return false; // Resulting size too large\n                }\n                max_decoded_bytes_for_entry = num_rle_pairs * 255;\n            } else {\n                return false; // Unknown or unsupported entry type\n            }\n\n            // Check for integer overflow when summing total calculated size\n            if (calculated_max_decoded_size > std::numeric_limits<size_t>::max() - max_decoded_bytes_for_entry) {\n                return false; // Total calculated size overflow\n            }\n            calculated_max_decoded_size += max_decoded_bytes_for_entry;\n\n            current_packet_offset_for_calc += sizeof(TelemetryEntryHeaderFixed) + entry_header_calc->encoded_data_length;\n        }\n\n        // FIX: Verify advertised total_decoded_size against the *calculated* max required size.\n        // If the advertised size is less than what's potentially needed, it's a malformed/malicious packet.\n        if (block_header->total_decoded_size < calculated_max_decoded_size) {\n            return false;\n        }\n        \n        // Final sanity check on calculated size against hard limit\n        if (calculated_max_decoded_size > MAX_DECODED_BLOCK_SIZE) {\n            return false;\n        }\n\n        // Ensure the entire packet is provided as expected (header + total encoded data bytes).\n        // `current_packet_offset_for_calc` now holds the total size of header + all encoded data.\n        if (packet_len < current_packet_offset_for_calc) {\n             return false;\n        }\n\n        // Allocate buffer based on the *calculated* maximum required size to ensure sufficient space.\n        size_t desired_alloc_size = calculated_max_decoded_size;\n        if (desired_alloc_size == 0) {\n             resetBuffer();\n             return true;\n        }\n        \n        uint8_t* new_buffer = (uint8_t*)realloc(m_decoded_buffer, desired_alloc_size);\n        if (!new_buffer) {\n            if (m_decoded_buffer) free(m_decoded_buffer);\n            m_decoded_buffer = nullptr;\n            m_current_buffer_pos = 0;\n            m_allocated_capacity = 0;\n            return false;\n        }\n        m_decoded_buffer = new_buffer;\n        m_allocated_capacity = desired_alloc_size;\n        m_current_buffer_pos = 0; // Reset position for new block processing\n\n        size_t current_packet_offset = sizeof(TelemetryBlockHeaderFixed);\n\n        for (uint16_t i = 0; i < block_header->num_entries; ++i) {\n            // These checks are implicitly handled by the initial `current_packet_offset_for_calc` checks,\n            // but are repeated here for robustness as `current_packet_offset` advances.\n            if (current_packet_offset + sizeof(TelemetryEntryHeaderFixed) > packet_len) { resetBuffer(); return false; }\n            const TelemetryEntryHeaderFixed* entry_header = reinterpret_cast<const TelemetryEntryHeaderFixed*>(raw_packet + current_packet_offset);\n            if (current_packet_offset + sizeof(TelemetryEntryHeaderFixed) + entry_header->encoded_data_length > packet_len) { resetBuffer(); return false; }\n\n            const uint8_t* entry_data_ptr = raw_packet + current_packet_offset + sizeof(TelemetryEntryHeaderFixed);\n            size_t bytes_to_read = entry_header->encoded_data_length;\n\n            switch (entry_header->entry_type) {\n                case RAW_DATA_FIXED: {\n                    // FIX: Ensure enough space before copying data.\n                    if (m_current_buffer_pos > m_allocated_capacity - bytes_to_read) {\n                        resetBuffer();\n                        return false;\n                    }\n                    std::memcpy(m_decoded_buffer + m_current_buffer_pos, entry_data_ptr, bytes_to_read);\n                    m_current_buffer_pos += bytes_to_read;\n                    break;\n                }\n                case RLE_DATA_FIXED: {\n                    size_t rle_current_read_offset = 0;\n                    while (rle_current_read_offset + 1 < bytes_to_read) { \n                        uint8_t value_to_repeat = entry_data_ptr[rle_current_read_offset];\n                        uint8_t repeat_count = entry_data_ptr[rle_current_read_offset + 1];\n\n                        // FIX: Explicitly check bounds before writing repeated bytes.\n                        // This is the critical fix for the RLE expansion vulnerability.\n                        if (m_current_buffer_pos > m_allocated_capacity - repeat_count) {\n                            resetBuffer();\n                            return false;\n                        }\n\n                        for (uint8_t k = 0; k < repeat_count; ++k) {\n                            m_decoded_buffer[m_current_buffer_pos + k] = value_to_repeat;\n                        }\n                        m_current_buffer_pos += repeat_count;\n\n                        rle_current_read_offset += 2;\n                    }\n                    break;\n                }\n                default:\n                    resetBuffer();\n                    return false;\n            }\n            current_packet_offset += sizeof(TelemetryEntryHeaderFixed) + bytes_to_read;\n        }\n\n        // Final check: ensure the total size written matches the advertised size from the header.\n        // This helps detect any inconsistencies or truncation.\n        if (m_current_buffer_pos != block_header->total_decoded_size) {\n            resetBuffer(); \n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getDecodedBuffer() const { return m_decoded_buffer; }\n    size_t getCurrentDecodedSize() const { return m_current_buffer_pos; }\n\nprivate:\n    uint8_t* m_decoded_buffer;\n    size_t   m_current_buffer_pos;\n    size_t   m_allocated_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n\n#define MAX_UINT32_DIGITS 10\n\nstruct LoggedEvent {\n    uint32_t event_id;\n    char*    parameter_str;\n    size_t   parameter_str_capacity;\n};\n\nsize_t uint32_to_string_vulnerable(uint32_t value, char* buffer) {\n    if (value == 0) {\n        buffer[0] = '0';\n        buffer[1] = '\\0';\n        return 1;\n    }\n\n    int i = 0;\n    char temp_buffer[MAX_UINT32_DIGITS + 1];\n    \n    uint32_t temp_val = value;\n    while (temp_val > 0) {\n        temp_buffer[i++] = (temp_val % 10) + '0';\n        temp_val /= 10;\n    }\n\n    size_t len = i;\n    for (int j = 0; j < len; j++) {\n        buffer[j] = temp_buffer[i - 1 - j];\n    }\n    buffer[len] = '\\0';\n    return len;\n}\n\nclass DiagnosticMessageProcessorVulnerable {\npublic:\n    DiagnosticMessageProcessorVulnerable() {}\n\n    ~DiagnosticMessageProcessorVulnerable() {\n        clearLoggedEvents();\n    }\n\n    void clearLoggedEvents() {\n        for (auto& event : m_logged_events) {\n            if (event.parameter_str) {\n                free(event.parameter_str);\n            }\n        }\n        m_logged_events.clear();\n    }\n\n    bool logNumericEventVulnerable(uint32_t event_id, uint32_t numeric_value) {\n        LoggedEvent new_event;\n        new_event.event_id = event_id;\n        \n        new_event.parameter_str_capacity = MAX_UINT32_DIGITS;\n        new_event.parameter_str = (char*)malloc(new_event.parameter_str_capacity);\n        if (!new_event.parameter_str && new_event.parameter_str_capacity > 0) {\n            return false;\n        }\n\n        size_t actual_len = uint32_to_string_vulnerable(numeric_value, new_event.parameter_str);\n        \n        if (actual_len >= new_event.parameter_str_capacity) {\n            if (new_event.parameter_str) {\n                free(new_event.parameter_str);\n            }\n            return false;\n        }\n\n        m_logged_events.push_back(new_event);\n        return true;\n    }\n\n    const std::vector<LoggedEvent>& getLoggedEvents() const {\n        return m_logged_events;\n    }\n\nprivate:\n    std::vector<LoggedEvent> m_logged_events;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n\n#define MAX_UINT32_STR_LEN (10 + 1)\n\nstruct LoggedEvent {\n    uint32_t event_id;\n    char*    parameter_str;\n    size_t   parameter_str_capacity;\n};\n\nsize_t uint32_to_string_fixed(uint32_t value, char* buffer, size_t buffer_capacity) {\n    if (!buffer || buffer_capacity == 0) {\n        return 0;\n    }\n\n    if (value == 0) {\n        if (buffer_capacity < 2) {\n            return 0;\n        }\n        buffer[0] = '0';\n        buffer[1] = '\\0';\n        return 1;\n    }\n\n    char temp_buffer[MAX_UINT32_STR_LEN];\n    int i = 0;\n    \n    uint32_t temp_val = value;\n    while (temp_val > 0) {\n        if (i >= MAX_UINT32_STR_LEN - 1) {\n            return 0;\n        }\n        temp_buffer[i++] = (temp_val % 10) + '0';\n        temp_val /= 10;\n    }\n\n    size_t len = i;\n    if (len >= buffer_capacity) {\n        return 0;\n    }\n\n    for (int j = 0; j < len; j++) {\n        buffer[j] = temp_buffer[i - 1 - j];\n    }\n    buffer[len] = '\\0';\n    return len;\n}\n\nclass DiagnosticMessageProcessorFixed {\npublic:\n    DiagnosticMessageProcessorFixed() {}\n\n    ~DiagnosticMessageProcessorFixed() {\n        clearLoggedEvents();\n    }\n\n    void clearLoggedEvents() {\n        for (auto& event : m_logged_events) {\n            if (event.parameter_str) {\n                free(event.parameter_str);\n            }\n        }\n        m_logged_events.clear();\n    }\n\n    bool logNumericEventFixed(uint32_t event_id, uint32_t numeric_value) {\n        LoggedEvent new_event;\n        new_event.event_id = event_id;\n        \n        new_event.parameter_str_capacity = MAX_UINT32_STR_LEN;\n        new_event.parameter_str = (char*)malloc(new_event.parameter_str_capacity);\n        if (!new_event.parameter_str && new_event.parameter_str_capacity > 0) {\n            return false;\n        }\n\n        size_t actual_len = uint32_to_string_fixed(numeric_value, new_event.parameter_str, new_event.parameter_str_capacity);\n        \n        if (actual_len == 0 && numeric_value != 0) {\n            if (new_event.parameter_str) {\n                free(new_event.parameter_str);\n            }\n            return false;\n        }\n        \n        m_logged_events.push_back(new_event);\n        return true;\n    }\n\n    const std::vector<LoggedEvent>& getLoggedEvents() const {\n        return m_logged_events;\n    }\n\nprivate:\n    std::vector<LoggedEvent> m_logged_events;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n\ntypedef struct {\n    uint32_t offset;\n    uint16_t length;\n    uint16_t chunk_id;\n} FirmwareChunkHeader;\n\nclass FirmwareUpdaterVulnerable {\nprivate:\n    uint8_t* m_firmware_image_buffer;\n    size_t   m_allocated_size;\n    uint32_t m_expected_total_firmware_size;\n    bool     m_is_initialized;\n\npublic:\n    FirmwareUpdaterVulnerable() : m_firmware_image_buffer(nullptr), m_allocated_size(0), m_expected_total_firmware_size(0), m_is_initialized(false) {}\n\n    ~FirmwareUpdaterVulnerable() {\n        if (m_firmware_image_buffer) {\n            free(m_firmware_image_buffer);\n            m_firmware_image_buffer = nullptr;\n        }\n    }\n\n    bool initializeUpdater(uint32_t total_firmware_size) {\n        if (total_firmware_size == 0 || total_firmware_size > (1024U * 1024U * 10U)) {\n            return false;\n        }\n        if (m_firmware_image_buffer) {\n            free(m_firmware_image_buffer);\n        }\n        m_firmware_image_buffer = (uint8_t*)malloc(total_firmware_size);\n        if (!m_firmware_image_buffer) {\n            m_allocated_size = 0;\n            m_expected_total_firmware_size = 0;\n            m_is_initialized = false;\n            return false;\n        }\n        m_allocated_size = total_firmware_size;\n        m_expected_total_firmware_size = total_firmware_size;\n        m_is_initialized = true;\n        return true;\n    }\n\n    bool applyFirmwareChunkVulnerable(const uint8_t* raw_chunk_data, size_t raw_chunk_data_len) {\n        if (!m_is_initialized || !m_firmware_image_buffer || raw_chunk_data_len < sizeof(FirmwareChunkHeader)) {\n            return false;\n        }\n\n        const FirmwareChunkHeader* header = reinterpret_cast<const FirmwareChunkHeader*>(raw_chunk_data);\n\n        if (raw_chunk_data_len < (sizeof(FirmwareChunkHeader) + header->length)) {\n            return false;\n        }\n        \n        if (header->offset >= m_expected_total_firmware_size) {\n            return false;\n        }\n\n        const uint8_t* chunk_payload_start = raw_chunk_data + sizeof(FirmwareChunkHeader);\n\n        for (uint16_t i = 0; i < header->length; ++i) {\n            m_firmware_image_buffer[header->offset + i] = chunk_payload_start[i];\n        }\n\n        return true;\n    }\n\n    const uint8_t* getFirmwareBuffer() const {\n        return m_firmware_image_buffer;\n    }\n\n    size_t getAllocatedSize() const {\n        return m_allocated_size;\n    }\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <algorithm>\n\ntypedef struct {\n    uint32_t offset;\n    uint16_t length;\n    uint16_t chunk_id;\n} FirmwareChunkHeader;\n\nclass FirmwareUpdaterFixed {\nprivate:\n    uint8_t* m_firmware_image_buffer;\n    size_t   m_allocated_size;\n    uint32_t m_expected_total_firmware_size;\n    bool     m_is_initialized;\n\npublic:\n    FirmwareUpdaterFixed() : m_firmware_image_buffer(nullptr), m_allocated_size(0), m_expected_total_firmware_size(0), m_is_initialized(false) {}\n\n    ~FirmwareUpdaterFixed() {\n        if (m_firmware_image_buffer) {\n            free(m_firmware_image_buffer);\n            m_firmware_image_buffer = nullptr;\n        }\n    }\n\n    bool initializeUpdater(uint32_t total_firmware_size) {\n        if (total_firmware_size == 0 || total_firmware_size > (1024U * 1024U * 10U)) {\n            return false;\n        }\n        if (m_firmware_image_buffer) {\n            free(m_firmware_image_buffer);\n        }\n        m_firmware_image_buffer = (uint8_t*)malloc(total_firmware_size);\n        if (!m_firmware_image_buffer) {\n            m_allocated_size = 0;\n            m_expected_total_firmware_size = 0;\n            m_is_initialized = false;\n            return false;\n        }\n        m_allocated_size = total_firmware_size;\n        m_expected_total_firmware_size = total_firmware_size;\n        m_is_initialized = true;\n        return true;\n    }\n\n    bool applyFirmwareChunkFixed(const uint8_t* raw_chunk_data, size_t raw_chunk_data_len) {\n        if (!m_is_initialized || !m_firmware_image_buffer || raw_chunk_data_len < sizeof(FirmwareChunkHeader)) {\n            return false;\n        }\n\n        const FirmwareChunkHeader* header = reinterpret_cast<const FirmwareChunkHeader*>(raw_chunk_data);\n\n        if (raw_chunk_data_len < (sizeof(FirmwareChunkHeader) + header->length)) {\n            return false;\n        }\n\n        if (static_cast<size_t>(header->offset) >= m_allocated_size) {\n            return false;\n        }\n        if (header->length > (m_allocated_size - static_cast<size_t>(header->offset))) {\n            return false;\n        }\n\n        const uint8_t* chunk_payload_start = raw_chunk_data + sizeof(FirmwareChunkHeader);\n\n        for (uint16_t i = 0; i < header->length; ++i) {\n            m_firmware_image_buffer[header->offset + i] = chunk_payload_start[i];\n        }\n\n        return true;\n    }\n\n    const uint8_t* getFirmwareBuffer() const {\n        return m_firmware_image_buffer;\n    }\n\n    size_t getAllocatedSize() const {\n        return m_allocated_size;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\nstruct DiagnosticMessageHeader {\n    uint16_t message_id;\n    uint16_t data_length; \n    uint32_t timestamp_ms;\n};\n\nstruct DiagnosticPacketHeader {\n    uint32_t packet_sequence_num;\n    uint16_t num_messages;\n    uint16_t reserved;\n};\n#pragma pack(pop)\n\nclass DiagnosticMessageAggregatorVulnerable {\npublic:\n    DiagnosticMessageAggregatorVulnerable()\n        : m_aggregated_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {\n        m_allocated_capacity = 4096;\n        m_aggregated_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (m_aggregated_buffer == nullptr) {\n            m_allocated_capacity = 0;\n        }\n        m_current_size = 0;\n    }\n\n    ~DiagnosticMessageAggregatorVulnerable() {\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n        }\n    }\n\n    bool appendDiagnosticPacketVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeader* packet_header = reinterpret_cast<const DiagnosticPacketHeader*>(raw_packet);\n        size_t current_raw_read_offset = sizeof(DiagnosticPacketHeader);\n\n        for (uint16_t i = 0; i < packet_header->num_messages; ++i) {\n            if (current_raw_read_offset + sizeof(DiagnosticMessageHeader) > packet_len) {\n                return false;\n            }\n\n            const DiagnosticMessageHeader* msg_header = reinterpret_cast<const DiagnosticMessageHeader*>(raw_packet + current_raw_read_offset);\n            uint16_t message_data_len = msg_header->data_length;\n\n            if (current_raw_read_offset + sizeof(DiagnosticMessageHeader) + message_data_len > packet_len) {\n                return false;\n            }\n\n            size_t total_message_storage_size = sizeof(DiagnosticMessageHeader) + message_data_len;\n\n            if (m_current_size > (SIZE_MAX - total_message_storage_size) || \n                m_current_size + total_message_storage_size > m_allocated_capacity) {\n\n                size_t new_capacity = m_allocated_capacity == 0 ? total_message_storage_size : m_allocated_capacity * 2;\n                if (new_capacity < m_current_size + total_message_storage_size) {\n                    new_capacity = m_current_size + total_message_storage_size;\n                }\n                \n                if (new_capacity > (16ULL * 1024 * 1024)) { \n                    if (total_message_storage_size > (16ULL * 1024 * 1024)) {\n                        return false;\n                    }\n                    new_capacity = (16ULL * 1024 * 1024);\n                }\n\n                uint8_t* new_buffer = (uint8_t*)realloc(m_aggregated_buffer, new_capacity);\n                if (!new_buffer) {\n                    if (m_aggregated_buffer) {\n                        free(m_aggregated_buffer);\n                        m_aggregated_buffer = nullptr;\n                    }\n                    m_current_size = 0;\n                    m_allocated_capacity = 0;\n                    return false;\n                }\n                m_aggregated_buffer = new_buffer;\n                m_allocated_capacity = new_capacity;\n            }\n\n            uint8_t* dest_ptr = m_aggregated_buffer + m_current_size;\n            const uint8_t* source_ptr = raw_packet + current_raw_read_offset;\n\n            for (size_t k = 0; k < sizeof(DiagnosticMessageHeader); ++k) {\n                dest_ptr[k] = source_ptr[k];\n            }\n\n            for (size_t k = 0; k < message_data_len; ++k) {\n                dest_ptr[sizeof(DiagnosticMessageHeader) + k] = source_ptr[sizeof(DiagnosticMessageHeader) + k];\n            }\n            \n            \n            m_aggregated_buffer[m_current_size + sizeof(DiagnosticMessageHeader) + message_data_len] = '\\0'; \n\n            m_current_size += total_message_storage_size; \n\n            current_raw_read_offset += sizeof(DiagnosticMessageHeader) + message_data_len;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedBuffer() const { return m_aggregated_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_aggregated_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <algorithm>\n\n#pragma pack(push, 1)\nstruct DiagnosticMessageHeader {\n    uint16_t message_id;\n    uint16_t data_length; \n    uint32_t timestamp_ms;\n};\n\nstruct DiagnosticPacketHeader {\n    uint32_t packet_sequence_num;\n    uint16_t num_messages;\n    uint16_t reserved;\n};\n#pragma pack(pop)\n\nclass DiagnosticMessageAggregatorFixed {\npublic:\n    DiagnosticMessageAggregatorFixed()\n        : m_aggregated_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {\n        m_allocated_capacity = 4096;\n        m_aggregated_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (m_aggregated_buffer == nullptr) {\n            m_allocated_capacity = 0;\n        }\n        m_current_size = 0;\n    }\n\n    ~DiagnosticMessageAggregatorFixed() {\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n        }\n    }\n\n    bool appendDiagnosticPacketFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeader* packet_header = reinterpret_cast<const DiagnosticPacketHeader*>(raw_packet);\n        size_t current_raw_read_offset = sizeof(DiagnosticPacketHeader);\n\n        for (uint16_t i = 0; i < packet_header->num_messages; ++i) {\n            if (current_raw_read_offset + sizeof(DiagnosticMessageHeader) > packet_len) {\n                return false;\n            }\n\n            const DiagnosticMessageHeader* msg_header = reinterpret_cast<const DiagnosticMessageHeader*>(raw_packet + current_raw_read_offset);\n            uint16_t message_data_len = msg_header->data_length;\n\n            if (current_raw_read_offset + sizeof(DiagnosticMessageHeader) + message_data_len > packet_len) {\n                return false;\n            }\n\n            size_t total_message_storage_size = sizeof(DiagnosticMessageHeader) + message_data_len;\n\n            if (m_current_size > (SIZE_MAX - total_message_storage_size) ||\n                m_current_size + total_message_storage_size > m_allocated_capacity) {\n\n                size_t new_capacity = m_allocated_capacity == 0 ? total_message_storage_size : m_allocated_capacity * 2;\n                if (new_capacity < m_current_size + total_message_storage_size) {\n                    new_capacity = m_current_size + total_message_storage_size;\n                }\n                \n                if (new_capacity > (16ULL * 1024 * 1024)) {\n                    if (total_message_storage_size > (16ULL * 1024 * 1024)) {\n                        return false; \n                    }\n                    new_capacity = (16ULL * 1024 * 1024);\n                }\n\n                uint8_t* new_buffer = (uint8_t*)realloc(m_aggregated_buffer, new_capacity);\n                if (!new_buffer) {\n                    if (m_aggregated_buffer) {\n                        free(m_aggregated_buffer);\n                        m_aggregated_buffer = nullptr;\n                    }\n                    m_current_size = 0;\n                    m_allocated_capacity = 0;\n                    return false;\n                }\n                m_aggregated_buffer = new_buffer;\n                m_allocated_capacity = new_capacity;\n            }\n\n            uint8_t* dest_ptr = m_aggregated_buffer + m_current_size;\n            const uint8_t* source_ptr = raw_packet + current_raw_read_offset;\n\n            for (size_t k = 0; k < sizeof(DiagnosticMessageHeader); ++k) {\n                dest_ptr[k] = source_ptr[k];\n            }\n\n            for (size_t k = 0; k < message_data_len; ++k) {\n                dest_ptr[sizeof(DiagnosticMessageHeader) + k] = source_ptr[sizeof(DiagnosticMessageHeader) + k];\n            }\n            \n            \n\n            m_current_size += total_message_storage_size;\n\n            current_raw_read_offset += sizeof(DiagnosticMessageHeader) + message_data_len;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedBuffer() const { return m_aggregated_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_aggregated_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n\n#pragma pack(push, 1)\n\nstruct ConfigPacketHeader {\n    uint32_t magic_id;\n    uint16_t num_entries;\n    uint32_t total_declared_size; \n};\n\nstruct ConfigEntryHeader {\n    uint16_t param_id;\n    uint16_t data_length; \n};\n\n#pragma pack(pop)\n\nclass VehicleConfigStoreVulnerable {\npublic:\n    VehicleConfigStoreVulnerable() : m_config_buffer(nullptr), m_current_buffer_size(0), m_allocated_capacity(0) {}\n\n    ~VehicleConfigStoreVulnerable() {\n        clearConfig();\n    }\n\n    void clearConfig() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n            m_config_buffer = nullptr;\n        }\n        m_current_buffer_size = 0;\n        m_allocated_capacity = 0;\n    }\n\n    bool processConfigPacketVulnerable(const uint8_t* raw_packet_data, size_t packet_length) {\n        if (!raw_packet_data || packet_length < sizeof(ConfigPacketHeader)) {\n            return false;\n        }\n\n        const ConfigPacketHeader* packet_hdr = reinterpret_cast<const ConfigPacketHeader*>(raw_packet_data);\n\n        if (packet_hdr->magic_id != 0xFEEDC0DE) {\n            return false;\n        }\n\n        if (packet_hdr->total_declared_size == 0) {\n            clearConfig();\n            return true; \n        }\n\n        uint8_t* new_buffer = (uint8_t*)realloc(m_config_buffer, packet_hdr->total_declared_size);\n        if (!new_buffer) {\n            clearConfig();\n            return false;\n        }\n        m_config_buffer = new_buffer;\n        m_allocated_capacity = packet_hdr->total_declared_size;\n        m_current_buffer_size = 0; \n\n        size_t current_read_offset = sizeof(ConfigPacketHeader);\n        size_t current_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_hdr->num_entries; ++i) {\n            if (current_read_offset + sizeof(ConfigEntryHeader) > packet_length) {\n                clearConfig();\n                return false;\n            }\n\n            const ConfigEntryHeader* entry_hdr = reinterpret_cast<const ConfigEntryHeader*>(raw_packet_data + current_read_offset);\n            uint16_t data_len = entry_hdr->data_length;\n\n            if (current_read_offset + sizeof(ConfigEntryHeader) + data_len > packet_length) {\n                clearConfig();\n                return false;\n            }\n\n            size_t entry_content_size_without_padding = sizeof(ConfigEntryHeader) + data_len;\n            size_t padding_bytes = (4 - (entry_content_size_without_padding % 4)) % 4;\n            if (entry_content_size_without_padding % 4 == 0) {\n                padding_bytes = 0;\n            }\n\n            size_t total_entry_storage_size = entry_content_size_without_padding + padding_bytes;\n            \n            memcpy(m_config_buffer + current_write_offset, entry_hdr, sizeof(ConfigEntryHeader));\n            current_write_offset += sizeof(ConfigEntryHeader);\n\n            memcpy(m_config_buffer + current_write_offset, raw_packet_data + current_read_offset + sizeof(ConfigEntryHeader), data_len);\n            current_write_offset += data_len;\n\n            if (padding_bytes > 0) {\n                memset(m_config_buffer + current_write_offset, 0, padding_bytes);\n                current_write_offset += padding_bytes;\n            }\n\n            current_read_offset += total_entry_storage_size;\n            m_current_buffer_size = current_write_offset; \n        }\n\n        return true;\n    }\n\n    const uint8_t* getConfigBuffer() const {\n        return m_config_buffer;\n    }\n\n    size_t getCurrentBufferSize() const {\n        return m_current_buffer_size;\n    }\n\n    size_t getAllocatedCapacity() const {\n        return m_allocated_capacity;\n    }\n\nprivate:\n    uint8_t* m_config_buffer;\n    size_t m_current_buffer_size;\n    size_t m_allocated_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <limits>\n\n#pragma pack(push, 1)\n\nstruct ConfigPacketHeader {\n    uint32_t magic_id;\n    uint16_t num_entries;\n    uint32_t total_declared_size; \n};\n\nstruct ConfigEntryHeader {\n    uint16_t param_id;\n    uint16_t data_length; \n};\n\n#pragma pack(pop)\n\nclass VehicleConfigStoreFixed {\npublic:\n    VehicleConfigStoreFixed() : m_config_buffer(nullptr), m_current_buffer_size(0), m_allocated_capacity(0) {}\n\n    ~VehicleConfigStoreFixed() {\n        clearConfig();\n    }\n\n    void clearConfig() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n            m_config_buffer = nullptr;\n        }\n        m_current_buffer_size = 0;\n        m_allocated_capacity = 0;\n    }\n\n    bool processConfigPacketFixed(const uint8_t* raw_packet_data, size_t packet_length) {\n        if (!raw_packet_data || packet_length < sizeof(ConfigPacketHeader)) {\n            return false;\n        }\n\n        const ConfigPacketHeader* packet_hdr = reinterpret_cast<const ConfigPacketHeader*>(raw_packet_data);\n\n        if (packet_hdr->magic_id != 0xFEEDC0DE) {\n            return false;\n        }\n        \n        if (packet_hdr->num_entries == 0) {\n            clearConfig();\n            return true; \n        }\n\n        size_t current_read_offset_scan = sizeof(ConfigPacketHeader);\n        size_t calculated_actual_payload_size = 0;\n\n        for (uint16_t i = 0; i < packet_hdr->num_entries; ++i) {\n            if (current_read_offset_scan > (packet_length - sizeof(ConfigEntryHeader))) {\n                return false;\n            }\n\n            const ConfigEntryHeader* entry_hdr = reinterpret_cast<const ConfigEntryHeader*>(raw_packet_data + current_read_offset_scan);\n            uint16_t data_len = entry_hdr->data_length;\n\n            if (data_len > (std::numeric_limits<size_t>::max() - sizeof(ConfigEntryHeader))) {\n                return false; \n            }\n            size_t entry_content_size_without_padding = sizeof(ConfigEntryHeader) + data_len;\n\n            size_t padding_bytes = (4 - (entry_content_size_without_padding % 4)) % 4;\n            if (entry_content_size_without_padding % 4 == 0) {\n                padding_bytes = 0;\n            }\n\n            if (entry_content_size_without_padding > (std::numeric_limits<size_t>::max() - padding_bytes)) {\n                return false; \n            }\n            size_t total_entry_storage_size = entry_content_size_without_padding + padding_bytes;\n\n            if (current_read_offset_scan > (packet_length - total_entry_storage_size)) {\n                return false;\n            }\n\n            if (calculated_actual_payload_size > (std::numeric_limits<size_t>::max() - total_entry_storage_size)) {\n                return false; \n            }\n            calculated_actual_payload_size += total_entry_storage_size;\n            \n            current_read_offset_scan += total_entry_storage_size;\n        }\n\n        if (calculated_actual_payload_size != packet_hdr->total_declared_size) {\n            return false; \n        }\n\n        uint8_t* new_buffer = (uint8_t*)realloc(m_config_buffer, calculated_actual_payload_size);\n        if (!new_buffer) {\n            clearConfig();\n            return false;\n        }\n        m_config_buffer = new_buffer;\n        m_allocated_capacity = calculated_actual_payload_size;\n        m_current_buffer_size = 0;\n\n        size_t current_read_offset_copy = sizeof(ConfigPacketHeader);\n        size_t current_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_hdr->num_entries; ++i) {\n            const ConfigEntryHeader* entry_hdr = reinterpret_cast<const ConfigEntryHeader*>(raw_packet_data + current_read_offset_copy);\n            uint16_t data_len = entry_hdr->data_length;\n\n            size_t entry_content_size_without_padding = sizeof(ConfigEntryHeader) + data_len;\n            size_t padding_bytes = (4 - (entry_content_size_without_padding % 4)) % 4;\n            if (entry_content_size_without_padding % 4 == 0) {\n                padding_bytes = 0;\n            }\n            size_t total_entry_storage_size = entry_content_size_without_padding + padding_bytes;\n\n            if (current_write_offset > (m_allocated_capacity - total_entry_storage_size)) {\n                clearConfig();\n                return false;\n            }\n            \n            memcpy(m_config_buffer + current_write_offset, entry_hdr, sizeof(ConfigEntryHeader));\n            current_write_offset += sizeof(ConfigEntryHeader);\n\n            memcpy(m_config_buffer + current_write_offset, raw_packet_data + current_read_offset_copy + sizeof(ConfigEntryHeader), data_len);\n            current_write_offset += data_len;\n\n            if (padding_bytes > 0) {\n                memset(m_config_buffer + current_write_offset, 0, padding_bytes);\n                current_write_offset += padding_bytes;\n            }\n            \n            current_read_offset_copy += total_entry_storage_size;\n            m_current_buffer_size = current_write_offset;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getConfigBuffer() const {\n        return m_config_buffer;\n    }\n\n    size_t getCurrentBufferSize() const {\n        return m_current_buffer_size;\n    }\n\n    size_t getAllocatedCapacity() const {\n        return m_allocated_capacity;\n    }\n\nprivate:\n    uint8_t* m_config_buffer;\n    size_t m_current_buffer_size;\n    size_t m_allocated_capacity;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\n\nstruct DiagnosticReportPacketHeader {\n    uint16_t report_id;\n    uint16_t num_data_elements; \n    uint32_t total_payload_bytes; \n};\n\nstruct DiagnosticDataElement {\n    uint16_t element_tag;\n    uint16_t data_length; \n};\n\nstruct AggregatedDataEntry {\n    uint16_t element_tag;\n    uint16_t actual_data_length; \n};\n\n#pragma pack(pop)\n\nclass DiagnosticDataAggregatorVulnerable {\npublic:\n    DiagnosticDataAggregatorVulnerable() : m_aggregated_buffer(nullptr), m_buffer_capacity(0), m_current_write_offset(0) {}\n\n    ~DiagnosticDataAggregatorVulnerable() {\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n        }\n    }\n\n    bool processDiagnosticReportVulnerable(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(DiagnosticReportPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticReportPacketHeader* packet_header = reinterpret_cast<const DiagnosticReportPacketHeader*>(raw_packet);\n\n        if (packet_length < (sizeof(DiagnosticReportPacketHeader) + packet_header->total_payload_bytes)) {\n            return false;\n        }\n\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n            m_current_write_offset = 0;\n            m_buffer_capacity = 0;\n        }\n\n        m_buffer_capacity = packet_header->total_payload_bytes; \n        \n        if (m_buffer_capacity == 0 && packet_header->num_data_elements > 0) {\n            return false; \n        }\n\n        m_aggregated_buffer = (uint8_t*)malloc(m_buffer_capacity);\n        if (!m_aggregated_buffer && m_buffer_capacity > 0) {\n            return false; \n        }\n        \n        size_t current_raw_read_offset = sizeof(DiagnosticReportPacketHeader);\n        m_current_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_header->num_data_elements; ++i) {\n            if (current_raw_read_offset + sizeof(DiagnosticDataElement) > packet_length) {\n                return false;\n            }\n\n            const DiagnosticDataElement* incoming_element_header = \n                reinterpret_cast<const DiagnosticDataElement*>(raw_packet + current_raw_read_offset);\n\n            uint16_t current_data_len = incoming_element_header->data_length;\n\n            if (current_raw_read_offset + sizeof(DiagnosticDataElement) + current_data_len > packet_length) {\n                return false;\n            }\n            \n            size_t space_needed_for_this_entry = sizeof(AggregatedDataEntry) + current_data_len;\n\n            if (m_current_write_offset + space_needed_for_this_entry > m_buffer_capacity) {\n                return false;\n            }\n\n            uint16_t tag_to_copy = incoming_element_header->element_tag;\n            memcpy(m_aggregated_buffer + m_current_write_offset, &tag_to_copy, sizeof(tag_to_copy));\n            m_current_write_offset += sizeof(tag_to_copy);\n\n            uint16_t len_to_copy = incoming_element_header->data_length;\n            memcpy(m_aggregated_buffer + m_current_write_offset, &len_to_copy, sizeof(len_to_copy));\n            m_current_write_offset += sizeof(len_to_copy);\n\n            memcpy(m_aggregated_buffer + m_current_write_offset, \n                   raw_packet + current_raw_read_offset + sizeof(DiagnosticDataElement), \n                   current_data_len);\n            m_current_write_offset += current_data_len;\n\n            current_raw_read_offset += sizeof(DiagnosticDataElement) + current_data_len;\n        }\n\n        if (m_current_write_offset != packet_header->total_payload_bytes + (packet_header->num_data_elements * sizeof(AggregatedDataEntry))) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedBuffer() const { return m_aggregated_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n    size_t getCurrentWriteOffset() const { return m_current_write_offset; }\n\nprivate:\n    uint8_t* m_aggregated_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_write_offset;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\n\nstruct DiagnosticReportPacketHeader {\n    uint16_t report_id;\n    uint16_t num_data_elements;\n    uint32_t total_payload_bytes;\n};\n\nstruct DiagnosticDataElement {\n    uint16_t element_tag;\n    uint16_t data_length;\n};\n\nstruct AggregatedDataEntry {\n    uint16_t element_tag;\n    uint16_t actual_data_length;\n};\n\n#pragma pack(pop)\n\nclass DiagnosticDataAggregatorFixed {\npublic:\n    DiagnosticDataAggregatorFixed() : m_aggregated_buffer(nullptr), m_buffer_capacity(0), m_current_write_offset(0) {}\n\n    ~DiagnosticDataAggregatorFixed() {\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n        }\n    }\n\n    bool processDiagnosticReportFixed(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(DiagnosticReportPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticReportPacketHeader* packet_header = reinterpret_cast<const DiagnosticReportPacketHeader*>(raw_packet);\n\n        static const uint16_t MAX_ALLOWED_DATA_ELEMENTS = 1000; \n        if (packet_header->num_data_elements > MAX_ALLOWED_DATA_ELEMENTS) {\n            return false;\n        }\n\n        size_t actual_parsed_payload_sum = 0;\n        size_t temp_read_offset = sizeof(DiagnosticReportPacketHeader);\n\n        for (uint16_t i = 0; i < packet_header->num_data_elements; ++i) {\n            if (temp_read_offset + sizeof(DiagnosticDataElement) > packet_length) {\n                return false;\n            }\n            const DiagnosticDataElement* temp_element_header = \n                reinterpret_cast<const DiagnosticDataElement*>(raw_packet + temp_read_offset);\n            \n            uint16_t element_data_len = temp_element_header->data_length;\n\n            if (temp_read_offset + sizeof(DiagnosticDataElement) + element_data_len > packet_length) {\n                return false;\n            }\n\n            if (element_data_len > (std::numeric_limits<size_t>::max() - actual_parsed_payload_sum)) {\n                 return false;\n            }\n            actual_parsed_payload_sum += element_data_len;\n            temp_read_offset += sizeof(DiagnosticDataElement) + element_data_len;\n        }\n\n        if (actual_parsed_payload_sum != packet_header->total_payload_bytes) {\n            return false;\n        }\n\n        size_t metadata_overhead_per_element = sizeof(AggregatedDataEntry);\n        \n        if (packet_header->num_data_elements > (std::numeric_limits<size_t>::max() / metadata_overhead_per_element)) {\n            return false;\n        }\n        size_t total_metadata_overhead = static_cast<size_t>(packet_header->num_data_elements) * metadata_overhead_per_element;\n\n        if (packet_header->total_payload_bytes > (std::numeric_limits<size_t>::max() - total_metadata_overhead)) {\n            return false;\n        }\n        size_t required_internal_buffer_size = packet_header->total_payload_bytes + total_metadata_overhead;\n\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n            m_current_write_offset = 0;\n            m_buffer_capacity = 0;\n        }\n\n        if (required_internal_buffer_size == 0) {\n            m_aggregated_buffer = nullptr;\n            m_buffer_capacity = 0;\n            return true;\n        }\n\n        m_aggregated_buffer = (uint8_t*)malloc(required_internal_buffer_size);\n        if (!m_aggregated_buffer) {\n            return false;\n        }\n        m_buffer_capacity = required_internal_buffer_size;\n        \n        size_t current_raw_read_offset = sizeof(DiagnosticReportPacketHeader);\n        m_current_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_header->num_data_elements; ++i) {\n            const DiagnosticDataElement* incoming_element_header = \n                reinterpret_cast<const DiagnosticDataElement*>(raw_packet + current_raw_read_offset);\n            uint16_t current_data_len = incoming_element_header->data_length;\n\n            size_t space_needed_for_this_entry = sizeof(AggregatedDataEntry) + current_data_len;\n            if (m_current_write_offset > m_buffer_capacity - space_needed_for_this_entry) {\n                return false; \n            }\n\n            uint16_t tag_to_copy = incoming_element_header->element_tag;\n            memcpy(m_aggregated_buffer + m_current_write_offset, &tag_to_copy, sizeof(tag_to_copy));\n            m_current_write_offset += sizeof(tag_to_copy);\n\n            uint16_t len_to_copy = incoming_element_header->data_length;\n            memcpy(m_aggregated_buffer + m_current_write_offset, &len_to_copy, sizeof(len_to_copy));\n            m_current_write_offset += sizeof(len_to_copy);\n\n            memcpy(m_aggregated_buffer + m_current_write_offset, \n                   raw_packet + current_raw_read_offset + sizeof(DiagnosticDataElement), \n                   current_data_len);\n            m_current_write_offset += current_data_len;\n\n            current_raw_read_offset += sizeof(DiagnosticDataElement) + current_data_len;\n        }\n\n        if (m_current_write_offset != m_buffer_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedBuffer() const { return m_aggregated_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n    size_t getCurrentWriteOffset() const { return m_current_write_offset; }\n\nprivate:\n    uint8_t* m_aggregated_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_write_offset;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <cstring> \n\nstruct TelemetryParameterVulnerable {\n    uint16_t id;\n    const char* value_str;\n};\n\nclass TelemetryMessageBuilderVulnerable {\npublic:\n    TelemetryMessageBuilderVulnerable() : m_message_buffer(nullptr), m_buffer_size(0) {}\n\n    ~TelemetryMessageBuilderVulnerable() {\n        if (m_message_buffer) {\n            free(m_message_buffer);\n        }\n    }\n\n    void addParameter(uint16_t id, const char* value) {\n        if (value) {\n            m_parameters.push_back({id, value});\n        }\n    }\n\n    bool buildMessageVulnerable() {\n        if (m_message_buffer) {\n            free(m_message_buffer);\n            m_message_buffer = nullptr;\n            m_buffer_size = 0;\n        }\n\n        size_t calculated_total_len = 0;\n        for (const auto& param : m_parameters) {\n            // VULNERABILITY: Calculated length does NOT account for the null terminator\n            // that will be written for each string parameter. strlen() returns the length\n            // WITHOUT the null terminator. Each string requires strlen() + 1 byte for null termination.\n            calculated_total_len += sizeof(param.id) + strlen(param.value_str);\n        }\n\n        if (m_parameters.empty()) {\n            return true;\n        }\n\n        if (calculated_total_len == 0) {\n            // This case might be an error if parameters exist but total length is 0.\n            // For example, if all strings are empty and only IDs are present.\n            return false;\n        }\n\n        m_message_buffer = (uint8_t*)malloc(calculated_total_len);\n        if (!m_message_buffer) {\n            return false;\n        }\n        m_buffer_size = calculated_total_len;\n\n        size_t current_offset = 0;\n        for (const auto& param : m_parameters) {\n            // Write parameter ID (manual byte copy)\n            uint16_t network_order_id = param.id; \n            for (size_t i = 0; i < sizeof(network_order_id); ++i) {\n                // Basic bounds check, but the main vulnerability is in calculation of m_buffer_size\n                if (current_offset + i >= m_buffer_size) {\n                    free(m_message_buffer);\n                    m_message_buffer = nullptr;\n                    m_buffer_size = 0;\n                    return false;\n                }\n                m_message_buffer[current_offset + i] = ((uint8_t*)&network_order_id)[i];\n            }\n            current_offset += sizeof(network_order_id);\n\n            // Write parameter value string (includes null terminator)\n            size_t value_len = strlen(param.value_str);\n            for (size_t i = 0; i <= value_len; ++i) { // Loop includes the null terminator (i <= value_len)\n                // VULNERABILITY HERE: If buffer is exactly sized for `value_len` and this is the last item,\n                // `current_offset + i` will access `m_buffer_size` (out-of-bounds) when `i == value_len`,\n                // causing a heap-based buffer overflow for each string's null terminator.\n                if (current_offset + i >= m_buffer_size) {\n                    free(m_message_buffer);\n                    m_message_buffer = nullptr;\n                    m_buffer_size = 0;\n                    return false;\n                }\n                m_message_buffer[current_offset + i] = param.value_str[i];\n            }\n            current_offset += (value_len + 1); // Advance offset including null terminator\n        }\n\n        // This check comes *after* the potential overflow has already occurred.\n        if (current_offset > m_buffer_size) {\n            free(m_message_buffer);\n            m_message_buffer = nullptr;\n            m_buffer_size = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getMessageBuffer() const {\n        return m_message_buffer;\n    }\n\n    size_t getBufferSize() const {\n        return m_buffer_size;\n    }\n\nprivate:\n    std::vector<TelemetryParameterVulnerable> m_parameters;\n    uint8_t* m_message_buffer;\n    size_t m_buffer_size;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <cstring> \n#include <limits>  \n\nstruct TelemetryParameterFixed {\n    uint16_t id;\n    const char* value_str;\n};\n\nclass TelemetryMessageBuilderFixed {\npublic:\n    TelemetryMessageBuilderFixed() : m_message_buffer(nullptr), m_buffer_size(0) {}\n\n    ~TelemetryMessageBuilderFixed() {\n        if (m_message_buffer) {\n            free(m_message_buffer);\n        }\n    }\n\n    void addParameter(uint16_t id, const char* value) {\n        if (value) {\n            m_parameters.push_back({id, value});\n        }\n    }\n\n    bool buildMessageFixed() {\n        if (m_message_buffer) {\n            free(m_message_buffer);\n            m_message_buffer = nullptr;\n            m_buffer_size = 0;\n        }\n\n        size_t calculated_total_len = 0;\n        for (const auto& param : m_parameters) {\n            size_t current_param_entry_size;\n            size_t string_len = strlen(param.value_str);\n\n            // FIX: Check for overflow before adding components to current_param_entry_size\n            if (string_len > std::numeric_limits<size_t>::max() - sizeof(param.id) - 1) {\n                return false; \n            }\n            // FIX: Account for the null terminator (+1) for each string.\n            current_param_entry_size = sizeof(param.id) + string_len + 1;\n\n            // FIX: Check for overflow when summing up total length\n            if (calculated_total_len > std::numeric_limits<size_t>::max() - current_param_entry_size) {\n                return false; \n            }\n            calculated_total_len += current_param_entry_size;\n        }\n\n        if (m_parameters.empty()) {\n            if (calculated_total_len != 0) {\n                return false;\n            }\n            return true;\n        }\n\n        if (calculated_total_len == 0) {\n            return false;\n        }\n\n        m_message_buffer = (uint8_t*)malloc(calculated_total_len);\n        if (!m_message_buffer) {\n            return false;\n        }\n        m_buffer_size = calculated_total_len;\n\n        size_t current_offset = 0;\n        for (const auto& param : m_parameters) {\n            // Write parameter ID (manual byte copy)\n            uint16_t network_order_id = param.id; \n            \n            // FIX: Bounds check before writing ID\n            if (current_offset > m_buffer_size - sizeof(network_order_id)) {\n                free(m_message_buffer); m_message_buffer = nullptr; m_buffer_size = 0;\n                return false;\n            }\n            for (size_t i = 0; i < sizeof(network_order_id); ++i) {\n                m_message_buffer[current_offset + i] = ((uint8_t*)&network_order_id)[i];\n            }\n            current_offset += sizeof(network_order_id);\n\n            // Write parameter value string (includes null terminator)\n            size_t value_len = strlen(param.value_str);\n            \n            // FIX: Explicit bounds check before writing string + null terminator\n            if (current_offset > m_buffer_size - (value_len + 1)) {\n                free(m_message_buffer); m_message_buffer = nullptr; m_buffer_size = 0;\n                return false;\n            }\n            for (size_t i = 0; i <= value_len; ++i) {\n                m_message_buffer[current_offset + i] = param.value_str[i];\n            }\n            current_offset += (value_len + 1);\n        }\n\n        if (current_offset != m_buffer_size) {\n            free(m_message_buffer);\n            m_message_buffer = nullptr;\n            m_buffer_size = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getMessageBuffer() const {\n        return m_message_buffer;\n    }\n\n    size_t getBufferSize() const {\n        return m_buffer_size;\n    }\n\nprivate:\n    std::vector<TelemetryParameterFixed> m_parameters;\n    uint8_t* m_message_buffer;\n    size_t m_buffer_size;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\nstruct CalibrationPointWireFormat {\n    uint16_t id;\n    uint32_t value;\n};\n#pragma pack(pop)\n\nstruct CalibrationPointStorage {\n    uint16_t id;\n    uint32_t value;\n};\n\nclass CalibrationManagerVulnerable {\npublic:\n    CalibrationManagerVulnerable() : m_calibration_data(nullptr), m_num_stored_points(0) {}\n\n    ~CalibrationManagerVulnerable() {\n        if (m_calibration_data) {\n            free(m_calibration_data);\n            m_calibration_data = nullptr;\n        }\n    }\n\n    bool processCalibrationPacketVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(uint16_t)) {\n            return false;\n        }\n\n        uint16_t num_points = *reinterpret_cast<const uint16_t*>(raw_packet);\n        size_t expected_packet_payload_len = (size_t)num_points * sizeof(CalibrationPointWireFormat);\n        size_t total_expected_packet_len = sizeof(uint16_t) + expected_packet_payload_len;\n\n        if (packet_len < total_expected_packet_len) {\n            return false;\n        }\n\n        if (m_calibration_data) {\n            free(m_calibration_data);\n            m_calibration_data = nullptr;\n        }\n\n        size_t allocation_size_bytes = (size_t)num_points * sizeof(CalibrationPointWireFormat);\n        \n        m_calibration_data = (CalibrationPointStorage*)malloc(allocation_size_bytes);\n        if (!m_calibration_data && allocation_size_bytes > 0) {\n            m_num_stored_points = 0;\n            return false;\n        }\n\n        const uint8_t* current_read_ptr = raw_packet + sizeof(uint16_t);\n        \n        for (uint16_t i = 0; i < num_points; ++i) {\n            memcpy(&m_calibration_data[i], current_read_ptr, sizeof(CalibrationPointWireFormat));\n            current_read_ptr += sizeof(CalibrationPointWireFormat);\n        }\n\n        m_num_stored_points = num_points;\n        return true;\n    }\n\n    const CalibrationPointStorage* getCalibrationData() const {\n        return m_calibration_data;\n    }\n\n    uint16_t getNumStoredPoints() const {\n        return m_num_stored_points;\n    }\n\nprivate:\n    CalibrationPointStorage* m_calibration_data;\n    uint16_t m_num_stored_points;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\nstruct CalibrationPointWireFormatFixed {\n    uint16_t id;\n    uint32_t value;\n};\n#pragma pack(pop)\n\nstruct CalibrationPointStorageFixed {\n    uint16_t id;\n    uint32_t value;\n};\n\nclass CalibrationManagerFixed {\npublic:\n    CalibrationManagerFixed() : m_calibration_data(nullptr), m_num_stored_points(0) {}\n\n    ~CalibrationManagerFixed() {\n        if (m_calibration_data) {\n            free(m_calibration_data);\n            m_calibration_data = nullptr;\n        }\n    }\n\n    bool processCalibrationPacketFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(uint16_t)) {\n            return false;\n        }\n\n        uint16_t num_points = *reinterpret_cast<const uint16_t*>(raw_packet);\n        size_t expected_packet_payload_len = (size_t)num_points * sizeof(CalibrationPointWireFormatFixed);\n        size_t total_expected_packet_len = sizeof(uint16_t) + expected_packet_payload_len;\n\n        if (packet_len < total_expected_packet_len) {\n            return false;\n        }\n\n        if (m_calibration_data) {\n            free(m_calibration_data);\n            m_calibration_data = nullptr;\n        }\n\n        size_t allocation_size_bytes = (size_t)num_points * sizeof(CalibrationPointStorageFixed);\n        \n        m_calibration_data = (CalibrationPointStorageFixed*)malloc(allocation_size_bytes);\n        if (!m_calibration_data && allocation_size_bytes > 0) {\n            m_num_stored_points = 0;\n            return false;\n        }\n\n        const uint8_t* current_read_ptr = raw_packet + sizeof(uint16_t);\n        \n        for (uint16_t i = 0; i < num_points; ++i) {\n            CalibrationPointWireFormatFixed temp_wire_point;\n            memcpy(&temp_wire_point, current_read_ptr, sizeof(CalibrationPointWireFormatFixed));\n\n            m_calibration_data[i].id = temp_wire_point.id;\n            m_calibration_data[i].value = temp_wire_point.value;\n            \n            current_read_ptr += sizeof(CalibrationPointWireFormatFixed);\n        }\n\n        m_num_stored_points = num_points;\n        return true;\n    }\n\n    const CalibrationPointStorageFixed* getCalibrationData() const {\n        return m_calibration_data;\n    }\n\n    uint16_t getNumStoredPoints() const {\n        return m_num_stored_points;\n}\n\nprivate:\n    CalibrationPointStorageFixed* m_calibration_data;\n    uint16_t m_num_stored_points;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\n#define DTC_ALIGNMENT_BYTES 4\n\n#pragma pack(push, 1)\nstruct DTCHeader {\n    uint16_t dtc_id;\n    uint16_t data_length; \n};\n\nstruct DTCBatchPacket {\n    uint32_t timestamp;\n    uint16_t num_dtc_entries;\n};\n#pragma pack(pop)\n\nclass DiagnosticBufferVulnerable {\nprivate:\n    uint8_t* m_consolidated_buffer;\n    size_t   m_current_write_offset;\n    size_t   m_allocated_capacity;\n\npublic:\n    DiagnosticBufferVulnerable() :\n        m_consolidated_buffer(nullptr),\n        m_current_write_offset(0),\n        m_allocated_capacity(0)\n    {\n        m_allocated_capacity = 1024; \n        m_consolidated_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_consolidated_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~DiagnosticBufferVulnerable() {\n        if (m_consolidated_buffer) {\n            free(m_consolidated_buffer);\n            m_consolidated_buffer = nullptr;\n        }\n    }\n\n    bool addDTCBatchVulnerable(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(DTCBatchPacket)) {\n            return false;\n        }\n\n        const DTCBatchPacket* batch_hdr = reinterpret_cast<const DTCBatchPacket*>(packet_data);\n        size_t current_packet_read_offset = sizeof(DTCBatchPacket);\n        \n        size_t total_payload_bytes_in_batch = 0;\n\n        for (uint16_t i = 0; i < batch_hdr->num_dtc_entries; ++i) {\n            if (current_packet_read_offset + sizeof(DTCHeader) > packet_length) {\n                return false;\n            }\n            const DTCHeader* dtc_hdr = reinterpret_cast<const DTCHeader*>(packet_data + current_packet_read_offset);\n            \n            uint16_t dtc_data_len = dtc_hdr->data_length;\n\n            size_t entry_total_raw_size = sizeof(DTCHeader) + dtc_data_len;\n\n            if (current_packet_read_offset + entry_total_raw_size > packet_length) {\n                return false;\n            }\n            \n            if (total_payload_bytes_in_batch > SIZE_MAX - entry_total_raw_size) {\n                return false;\n            }\n            // VULNERABILITY:\n            // The sum for allocation calculation 'total_payload_bytes_in_batch' only accounts for the raw data length\n            // (header + data_length), but not the necessary padding that will be added to each entry\n            // for alignment purposes in the consolidated buffer.\n            total_payload_bytes_in_batch += entry_total_raw_size;\n\n            current_packet_read_offset += entry_total_raw_size;\n        }\n\n        size_t required_total_space = m_current_write_offset + total_payload_bytes_in_batch;\n        \n        if (required_total_space > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity * 2;\n            if (new_capacity < required_total_space) {\n                new_capacity = required_total_space;\n            }\n            if (new_capacity > (10 * 1024 * 1024)) {\n                if (required_total_space > (10 * 1024 * 1024)) {\n                    return false;\n                }\n                new_capacity = (10 * 1024 * 1024);\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_consolidated_buffer, new_capacity);\n            if (!new_buffer) {\n                free(m_consolidated_buffer);\n                m_consolidated_buffer = nullptr;\n                m_current_write_offset = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_consolidated_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        current_packet_read_offset = sizeof(DTCBatchPacket);\n\n        for (uint16_t i = 0; i < batch_hdr->num_dtc_entries; ++i) {\n            const DTCHeader* dtc_hdr = reinterpret_cast<const DTCHeader*>(packet_data + current_packet_read_offset);\n            uint16_t dtc_data_len = dtc_hdr->data_length;\n\n            size_t entry_total_raw_size = sizeof(DTCHeader) + dtc_data_len;\n            // This is the actual size including padding that will be written\n            size_t entry_actual_storage_size = (entry_total_raw_size + DTC_ALIGNMENT_BYTES - 1) & ~(DTC_ALIGNMENT_BYTES - 1);\n            \n            // VULNERABILITY: If the buffer was undersized due to the previous calculation, \n            // the following byte-by-byte copies and padding write operations will go out of bounds.\n            // Copy header bytes manually\n            m_consolidated_buffer[m_current_write_offset] = (uint8_t)(dtc_hdr->dtc_id & 0xFF);\n            m_consolidated_buffer[m_current_write_offset + 1] = (uint8_t)((dtc_hdr->dtc_id >> 8) & 0xFF);\n            m_consolidated_buffer[m_current_write_offset + 2] = (uint8_t)(dtc_hdr->data_length & 0xFF);\n            m_consolidated_buffer[m_current_write_offset + 3] = (uint8_t)((dtc_hdr->data_length >> 8) & 0xFF);\n            \n            // Copy data payload bytes manually\n            const uint8_t* payload_src = packet_data + current_packet_read_offset + sizeof(DTCHeader);\n            for (uint16_t j = 0; j < dtc_data_len; ++j) {\n                m_consolidated_buffer[m_current_write_offset + sizeof(DTCHeader) + j] = payload_src[j];\n            }\n\n            // Fill padding bytes with zeros manually\n            size_t bytes_to_pad = entry_actual_storage_size - entry_total_raw_size;\n            if (bytes_to_pad > 0) {\n                for (size_t k = 0; k < bytes_to_pad; ++k) {\n                    m_consolidated_buffer[m_current_write_offset + entry_total_raw_size + k] = 0;\n                }\n            }\n            \n            m_current_write_offset += entry_actual_storage_size;\n            current_packet_read_offset += entry_total_raw_size;\n        }\n\n        return true;\n    }\n\n    size_t getCurrentBufferSize() const { return m_current_write_offset; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n    const uint8_t* getConsolidatedBuffer() const { return m_consolidated_buffer; }\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\n#define DTC_ALIGNMENT_BYTES 4\n\n#pragma pack(push, 1)\nstruct DTCHeader {\n    uint16_t dtc_id;\n    uint16_t data_length;\n};\n\nstruct DTCBatchPacket {\n    uint32_t timestamp;\n    uint16_t num_dtc_entries;\n};\n#pragma pack(pop)\n\nclass DiagnosticBufferFixed {\nprivate:\n    uint8_t* m_consolidated_buffer;\n    size_t   m_current_write_offset;\n    size_t   m_allocated_capacity;\n\npublic:\n    DiagnosticBufferFixed() :\n        m_consolidated_buffer(nullptr),\n        m_current_write_offset(0),\n        m_allocated_capacity(0)\n    {\n        m_allocated_capacity = 1024;\n        m_consolidated_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_consolidated_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~DiagnosticBufferFixed() {\n        if (m_consolidated_buffer) {\n            free(m_consolidated_buffer);\n            m_consolidated_buffer = nullptr;\n        }\n    }\n\n    bool addDTCBatchFixed(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(DTCBatchPacket)) {\n            return false;\n        }\n\n        const DTCBatchPacket* batch_hdr = reinterpret_cast<const DTCBatchPacket*>(packet_data);\n        size_t current_packet_read_offset = sizeof(DTCBatchPacket);\n        \n        size_t total_required_storage_for_batch = 0;\n        \n        static const uint16_t MAX_DTC_ENTRIES = 200; \n        if (batch_hdr->num_dtc_entries > MAX_DTC_ENTRIES) {\n            return false;\n        }\n\n        for (uint16_t i = 0; i < batch_hdr->num_dtc_entries; ++i) {\n            if (current_packet_read_offset > packet_length - sizeof(DTCHeader)) {\n                return false;\n            }\n            const DTCHeader* dtc_hdr = reinterpret_cast<const DTCHeader*>(packet_data + current_packet_read_offset);\n            \n            uint16_t dtc_data_len = dtc_hdr->data_length;\n            \n            if (sizeof(DTCHeader) > std::numeric_limits<size_t>::max() - dtc_data_len) {\n                return false;\n            }\n            size_t entry_total_raw_size = sizeof(DTCHeader) + dtc_data_len;\n\n            if (current_packet_read_offset > packet_length - entry_total_raw_size) {\n                return false;\n            }\n\n            // FIX: Correctly calculate the actual padded size needed for each entry\n            size_t entry_actual_storage_size = (entry_total_raw_size + DTC_ALIGNMENT_BYTES - 1) & ~(DTC_ALIGNMENT_BYTES - 1);\n            \n            // Check for integer overflow before accumulating to total_required_storage_for_batch\n            if (total_required_storage_for_batch > std::numeric_limits<size_t>::max() - entry_actual_storage_size) {\n                return false;\n            }\n            total_required_storage_for_batch += entry_actual_storage_size;\n\n            current_packet_read_offset += entry_total_raw_size;\n        }\n\n        // FIX: Use the correctly calculated 'total_required_storage_for_batch' for buffer sizing.\n        if (m_current_write_offset > std::numeric_limits<size_t>::max() - total_required_storage_for_batch) {\n            return false;\n        }\n        size_t required_total_space = m_current_write_offset + total_required_storage_for_batch;\n        \n        if (required_total_space > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity * 2;\n            if (new_capacity < m_allocated_capacity) { \n                new_capacity = std::numeric_limits<size_t>::max();\n            }\n            if (new_capacity < required_total_space) {\n                new_capacity = required_total_space;\n            }\n            \n            static const size_t MAX_CONSOLIDATED_BUFFER_SIZE = 10 * 1024 * 1024; \n            if (new_capacity > MAX_CONSOLIDATED_BUFFER_SIZE) {\n                if (required_total_space > MAX_CONSOLIDATED_BUFFER_SIZE) {\n                    return false;\n                }\n                new_capacity = MAX_CONSOLIDATED_BUFFER_SIZE;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_consolidated_buffer, new_capacity);\n            if (!new_buffer) {\n                free(m_consolidated_buffer);\n                m_consolidated_buffer = nullptr;\n                m_current_write_offset = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_consolidated_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        current_packet_read_offset = sizeof(DTCBatchPacket);\n\n        for (uint16_t i = 0; i < batch_hdr->num_dtc_entries; ++i) {\n            const DTCHeader* dtc_hdr = reinterpret_cast<const DTCHeader*>(packet_data + current_packet_read_offset);\n            uint16_t dtc_data_len = dtc_hdr->data_length;\n\n            size_t entry_total_raw_size = sizeof(DTCHeader) + dtc_data_len;\n            size_t entry_actual_storage_size = (entry_total_raw_size + DTC_ALIGNMENT_BYTES - 1) & ~(DTC_ALIGNMENT_BYTES - 1);\n            \n            // Final check just before writing to ensure we don't exceed buffer bounds\n            if (m_current_write_offset > m_allocated_capacity - entry_actual_storage_size) {\n                return false;\n            }\n\n            // Copy header bytes manually\n            m_consolidated_buffer[m_current_write_offset] = (uint8_t)(dtc_hdr->dtc_id & 0xFF);\n            m_consolidated_buffer[m_current_write_offset + 1] = (uint8_t)((dtc_hdr->dtc_id >> 8) & 0xFF);\n            m_consolidated_buffer[m_current_write_offset + 2] = (uint8_t)(dtc_hdr->data_length & 0xFF);\n            m_consolidated_buffer[m_current_write_offset + 3] = (uint8_t)((dtc_hdr->data_length >> 8) & 0xFF);\n            \n            // Copy data payload bytes manually\n            const uint8_t* payload_src = packet_data + current_packet_read_offset + sizeof(DTCHeader);\n            for (uint16_t j = 0; j < dtc_data_len; ++j) {\n                m_consolidated_buffer[m_current_write_offset + sizeof(DTCHeader) + j] = payload_src[j];\n            }\n\n            // Fill padding bytes with zeros manually\n            size_t bytes_to_pad = entry_actual_storage_size - entry_total_raw_size;\n            if (bytes_to_pad > 0) {\n                for (size_t k = 0; k < bytes_to_pad; ++k) {\n                    m_consolidated_buffer[m_current_write_offset + entry_total_raw_size + k] = 0;\n                }\n            }\n            \n            m_current_write_offset += entry_actual_storage_size;\n            current_packet_read_offset += entry_total_raw_size;\n        }\n\n        if (m_current_write_offset > m_allocated_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    size_t getCurrentBufferSize() const { return m_current_write_offset; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n    const uint8_t* getConsolidatedBuffer() const { return m_consolidated_buffer; }\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n\n#pragma pack(push, 1)\nstruct DiagnosticChunkHeaderVulnerable {\n    uint16_t chunk_id;\n    uint16_t chunk_data_length;\n};\n\nstruct DiagnosticPacketHeaderVulnerable {\n    uint32_t packet_sequence_num;\n    uint16_t num_chunks;\n    uint32_t total_expected_chunk_data_bytes;\n};\n#pragma pack(pop)\n\nclass DiagnosticAggregatorVulnerable {\npublic:\n    DiagnosticAggregatorVulnerable() : m_aggregated_data(nullptr), m_allocated_size(0), m_current_write_offset(0) {}\n\n    ~DiagnosticAggregatorVulnerable() {\n        if (m_aggregated_data) {\n            free(m_aggregated_data);\n            m_aggregated_data = nullptr;\n        }\n    }\n\n    bool processDiagnosticPacketVulnerable(const uint8_t* raw_packet_data, size_t packet_len) {\n        if (!raw_packet_data || packet_len < sizeof(DiagnosticPacketHeaderVulnerable)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeaderVulnerable* packet_header = reinterpret_cast<const DiagnosticPacketHeaderVulnerable*>(raw_packet_data);\n\n        if (packet_len < (sizeof(DiagnosticPacketHeaderVulnerable) + packet_header->total_expected_chunk_data_bytes)) {\n            return false;\n        }\n\n        size_t proposed_allocation_size = packet_header->total_expected_chunk_data_bytes;\n        \n        if (m_aggregated_data) {\n            free(m_aggregated_data);\n            m_aggregated_data = nullptr;\n        }\n        m_allocated_size = 0;\n        m_current_write_offset = 0;\n\n        m_aggregated_data = (uint8_t*)malloc(proposed_allocation_size);\n        if (!m_aggregated_data && proposed_allocation_size > 0) {\n            return false;\n        }\n        m_allocated_size = proposed_allocation_size;\n\n        const uint8_t* current_read_ptr = raw_packet_data + sizeof(DiagnosticPacketHeaderVulnerable);\n        size_t remaining_packet_bytes = packet_len - sizeof(DiagnosticPacketHeaderVulnerable);\n\n        for (uint16_t i = 0; i < packet_header->num_chunks; ++i) {\n            if (remaining_packet_bytes < sizeof(DiagnosticChunkHeaderVulnerable)) {\n                if (m_aggregated_data) { free(m_aggregated_data); m_aggregated_data = nullptr; }\n                m_allocated_size = 0;\n                return false;\n            }\n\n            const DiagnosticChunkHeaderVulnerable* chunk_header = reinterpret_cast<const DiagnosticChunkHeaderVulnerable*>(current_read_ptr);\n            uint16_t current_chunk_data_len = chunk_header->chunk_data_length;\n\n            size_t total_chunk_len_in_packet = sizeof(DiagnosticChunkHeaderVulnerable) + current_chunk_data_len;\n\n            if (remaining_packet_bytes < total_chunk_len_in_packet) {\n                if (m_aggregated_data) { free(m_aggregated_data); m_aggregated_data = nullptr; }\n                m_allocated_size = 0;\n                return false;\n            }\n            \n            for (size_t j = 0; j < total_chunk_len_in_packet; ++j) {\n                m_aggregated_data[m_current_write_offset + j] = current_read_ptr[j];\n            }\n            m_current_write_offset += total_chunk_len_in_packet;\n\n            current_read_ptr += total_chunk_len_in_packet;\n            remaining_packet_bytes -= total_chunk_len_in_packet;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedData() const {\n        return m_aggregated_data;\n    }\n\n    size_t getAllocatedSize() const {\n        return m_allocated_size;\n    }\n    \n    size_t getCurrentWriteOffset() const {\n        return m_current_write_offset;\n    }\n\nprivate:\n    uint8_t* m_aggregated_data;\n    size_t m_allocated_size;\n    size_t m_current_write_offset;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct DiagnosticChunkHeaderFixed {\n    uint16_t chunk_id;\n    uint16_t chunk_data_length;\n};\n\nstruct DiagnosticPacketHeaderFixed {\n    uint32_t packet_sequence_num;\n    uint16_t num_chunks;\n    uint32_t total_expected_chunk_data_bytes;\n};\n#pragma pack(pop)\n\nclass DiagnosticAggregatorFixed {\npublic:\n    DiagnosticAggregatorFixed() : m_aggregated_data(nullptr), m_allocated_size(0), m_current_write_offset(0) {}\n\n    ~DiagnosticAggregatorFixed() {\n        if (m_aggregated_data) {\n            free(m_aggregated_data);\n            m_aggregated_data = nullptr;\n        }\n    }\n\n    bool processDiagnosticPacketFixed(const uint8_t* raw_packet_data, size_t packet_len) {\n        if (!raw_packet_data || packet_len < sizeof(DiagnosticPacketHeaderFixed)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeaderFixed* packet_header = reinterpret_cast<const DiagnosticPacketHeaderFixed*>(raw_packet_data);\n\n        size_t total_required_aggregated_size = 0;\n        static const uint32_t MAX_AGGREGATED_DATA_SIZE = 128 * 1024;\n\n        if (packet_header->num_chunks > (std::numeric_limits<size_t>::max() / sizeof(DiagnosticChunkHeaderFixed))) {\n            return false;\n        }\n        total_required_aggregated_size = (size_t)packet_header->num_chunks * sizeof(DiagnosticChunkHeaderFixed);\n\n        if (packet_header->total_expected_chunk_data_bytes > (std::numeric_limits<size_t>::max() - total_required_aggregated_size)) {\n            return false;\n        }\n        total_required_aggregated_size += packet_header->total_expected_chunk_data_bytes;\n\n        if (total_required_aggregated_size > MAX_AGGREGATED_DATA_SIZE) {\n            return false;\n        }\n\n        size_t expected_packet_payload_size = 0;\n        if (packet_header->num_chunks > (std::numeric_limits<size_t>::max() / sizeof(DiagnosticChunkHeaderFixed))) {\n            return false;\n        }\n        expected_packet_payload_size = (size_t)packet_header->num_chunks * sizeof(DiagnosticChunkHeaderFixed);\n        if (packet_header->total_expected_chunk_data_bytes > (std::numeric_limits<size_t>::max() - expected_packet_payload_size)) {\n            return false;\n        }\n        expected_packet_payload_size += packet_header->total_expected_chunk_data_bytes;\n\n        if (packet_len < (sizeof(DiagnosticPacketHeaderFixed) + expected_packet_payload_size)) {\n             return false;\n        }\n\n        if (m_aggregated_data) {\n            free(m_aggregated_data);\n            m_aggregated_data = nullptr;\n        }\n        m_allocated_size = 0;\n        m_current_write_offset = 0;\n        \n        m_aggregated_data = (uint8_t*)malloc(total_required_aggregated_size);\n        if (!m_aggregated_data && total_required_aggregated_size > 0) {\n            return false;\n        }\n        m_allocated_size = total_required_aggregated_size;\n\n        const uint8_t* current_read_ptr = raw_packet_data + sizeof(DiagnosticPacketHeaderFixed);\n        size_t remaining_packet_bytes = packet_len - sizeof(DiagnosticPacketHeaderFixed);\n\n        for (uint16_t i = 0; i < packet_header->num_chunks; ++i) {\n            if (remaining_packet_bytes < sizeof(DiagnosticChunkHeaderFixed)) {\n                if (m_aggregated_data) { free(m_aggregated_data); m_aggregated_data = nullptr; }\n                m_allocated_size = 0;\n                return false;\n            }\n\n            const DiagnosticChunkHeaderFixed* chunk_header = reinterpret_cast<const DiagnosticChunkHeaderFixed*>(current_read_ptr);\n            uint16_t current_chunk_data_len = chunk_header->chunk_data_length;\n\n            size_t total_chunk_len_in_packet = sizeof(DiagnosticChunkHeaderFixed) + current_chunk_data_len;\n\n            if (remaining_packet_bytes < total_chunk_len_in_packet) {\n                if (m_aggregated_data) { free(m_aggregated_data); m_aggregated_data = nullptr; }\n                m_allocated_size = 0;\n                return false;\n            }\n\n            if (m_current_write_offset > (std::numeric_limits<size_t>::max() - total_chunk_len_in_packet) ||\n                m_current_write_offset + total_chunk_len_in_packet > m_allocated_size) {\n                if (m_aggregated_data) { free(m_aggregated_data); m_aggregated_data = nullptr; }\n                m_allocated_size = 0;\n                return false;\n            }\n            \n            for (size_t j = 0; j < total_chunk_len_in_packet; ++j) {\n                m_aggregated_data[m_current_write_offset + j] = current_read_ptr[j];\n            }\n            m_current_write_offset += total_chunk_len_in_packet;\n\n            current_read_ptr += total_chunk_len_in_packet;\n            remaining_packet_bytes -= total_chunk_len_in_packet;\n        }\n        \n        if (m_current_write_offset != m_allocated_size && total_required_aggregated_size > 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedData() const {\n        return m_aggregated_data;\n    }\n\n    size_t getAllocatedSize() const {\n        return m_allocated_size;\n    }\n\n    size_t getCurrentWriteOffset() const {\n        return m_current_write_offset;\n    }\n\nprivate:\n    uint8_t* m_aggregated_data;\n    size_t m_allocated_size;\n    size_t m_current_write_offset;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n#pragma pack(push, 1)\nstruct UpdateChunkHeader {\n    uint32_t chunk_id;\n    uint32_t offset;    \n    uint32_t length;    \n    uint32_t crc;\n};\n#pragma pack(pop)\n\nclass ECUFlashUpdaterVulnerable {\npublic:\n    ECUFlashUpdaterVulnerable(size_t staging_buffer_capacity) {\n        if (staging_buffer_capacity > 0) {\n            m_staging_buffer = (uint8_t*)malloc(staging_buffer_capacity);\n            if (m_staging_buffer) {\n                m_capacity = staging_buffer_capacity;\n            } else {\n                m_capacity = 0;\n            }\n        } else {\n            m_capacity = 0;\n            m_staging_buffer = nullptr;\n        }\n    }\n\n    ~ECUFlashUpdaterVulnerable() {\n        if (m_staging_buffer) {\n            free(m_staging_buffer);\n        }\n    }\n\n    bool processUpdateChunkVulnerable(const uint8_t* raw_chunk_packet, size_t packet_len) {\n        if (!m_staging_buffer || !raw_chunk_packet || packet_len < sizeof(UpdateChunkHeader)) {\n            return false;\n        }\n\n        const UpdateChunkHeader* header = reinterpret_cast<const UpdateChunkHeader*>(raw_chunk_packet);\n\n        const uint8_t* chunk_data_payload = raw_chunk_packet + sizeof(UpdateChunkHeader);\n        size_t actual_chunk_data_len = packet_len - sizeof(UpdateChunkHeader);\n\n        if (actual_chunk_data_len != header->length) {\n            return false;\n        }\n\n        uint32_t end_address = header->offset + header->length; \n\n        if (end_address > m_capacity) {\n            return false;\n        }\n\n        uint8_t* dest_ptr = m_staging_buffer + header->offset;\n\n        memcpy(dest_ptr, chunk_data_payload, header->length);\n\n        return true;\n    }\n\n    size_t getCapacity() const { return m_capacity; }\n    const uint8_t* getStagingBuffer() const { return m_staging_buffer; }\n\nprivate:\n    uint8_t* m_staging_buffer;\n    size_t m_capacity;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct UpdateChunkHeader {\n    uint32_t chunk_id;\n    uint32_t offset;    \n    uint32_t length;    \n    uint32_t crc;\n};\n#pragma pack(pop)\n\nclass ECUFlashUpdaterFixed {\npublic:\n    ECUFlashUpdaterFixed(size_t staging_buffer_capacity) {\n        if (staging_buffer_capacity > 0) {\n            m_staging_buffer = (uint8_t*)malloc(staging_buffer_capacity);\n            if (m_staging_buffer) {\n                m_capacity = staging_buffer_capacity;\n            } else {\n                m_capacity = 0;\n            }\n        } else {\n            m_capacity = 0;\n            m_staging_buffer = nullptr;\n        }\n    }\n\n    ~ECUFlashUpdaterFixed() {\n        if (m_staging_buffer) {\n            free(m_staging_buffer);\n        }\n    }\n\n    bool processUpdateChunkFixed(const uint8_t* raw_chunk_packet, size_t packet_len) {\n        if (!m_staging_buffer || !raw_chunk_packet || packet_len < sizeof(UpdateChunkHeader)) {\n            return false;\n        }\n\n        const UpdateChunkHeader* header = reinterpret_cast<const UpdateChunkHeader*>(raw_chunk_packet);\n\n        const uint8_t* chunk_data_payload = raw_chunk_packet + sizeof(UpdateChunkHeader);\n        size_t actual_chunk_data_len = packet_len - sizeof(UpdateChunkHeader);\n\n        if (actual_chunk_data_len != static_cast<size_t>(header->length)) {\n            return false;\n        }\n\n        size_t start_pos = static_cast<size_t>(header->offset);\n        size_t write_length = static_cast<size_t>(header->length);\n\n        if (start_pos > std::numeric_limits<size_t>::max() - write_length) {\n            return false; \n        }\n\n        size_t end_pos = start_pos + write_length;\n\n        if (end_pos > m_capacity) {\n            return false;\n        }\n\n        uint8_t* dest_ptr = m_staging_buffer + start_pos;\n\n        memcpy(dest_ptr, chunk_data_payload, write_length);\n\n        return true;\n    }\n\n    size_t getCapacity() const { return m_capacity; }\n    const uint8_t* getStagingBuffer() const { return m_staging_buffer; }\n\nprivate:\n    uint8_t* m_staging_buffer;\n    size_t m_capacity;\n}",
    "analysis": ""
  }
]