[
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#define MAX_SENSORS 10#define CAN_MESSAGE_ID_CALIBRATION_UPDATE 0x18F00100#define CAN_MESSAGE_DLC_CALIBRATION 3typedef struct {unsigned int id; unsigned char data[8]; unsigned char dlc;} CanMessage;static int g_sensorCalibrationData[MAX_SENSORS];void logError(const char* msg) {}CanMessage receiveCANMessage_simulated() {CanMessage msg; msg.id = CAN_MESSAGE_ID_CALIBRATION_UPDATE; msg.dlc = CAN_MESSAGE_DLC_CALIBRATION; msg.data[0] = 15; msg.data[1] = 0x01; msg.data[2] = 0x23; for (int i = msg.dlc; i < 8; ++i) {msg.data[i] = 0;} return msg;}void systemInit() {for (int i = 0; i < MAX_SENSORS; ++i) {g_sensorCalibrationData[i] = 0;}}void processCanCommand_vulnerable(const CanMessage* msg) {if (msg->id == CAN_MESSAGE_ID_CALIBRATION_UPDATE && msg->dlc >= CAN_MESSAGE_DLC_CALIBRATION) {unsigned char sensorId = msg->data[0]; int calibrationValue = (msg->data[1] << 8) | msg->data[2]; g_sensorCalibrationData[sensorId] = calibrationValue;}}void vehicleECUMainLoop_vulnerable() {systemInit(); CanMessage receivedMsg = receiveCANMessage_simulated(); processCanCommand_vulnerable(&receivedMsg);}",
    "fixed_code": "#define MAX_SENSORS 10#define CAN_MESSAGE_ID_CALIBRATION_UPDATE 0x18F00100#define CAN_MESSAGE_DLC_CALIBRATION 3typedef struct {unsigned int id; unsigned char data[8]; unsigned char dlc;} CanMessage;static int g_sensorCalibrationData[MAX_SENSORS];void logError(const char* msg) {}CanMessage receiveCANMessage_simulated() {CanMessage msg; msg.id = CAN_MESSAGE_ID_CALIBRATION_UPDATE; msg.dlc = CAN_MESSAGE_DLC_CALIBRATION; msg.data[0] = 15; msg.data[1] = 0x01; msg.data[2] = 0x23; for (int i = msg.dlc; i < 8; ++i) {msg.data[i] = 0;} return msg;}void systemInit() {for (int i = 0; i < MAX_SENSORS; ++i) {g_sensorCalibrationData[i] = 0;}}void processCanCommand_fixed(const CanMessage* msg) {if (msg->id == CAN_MESSAGE_ID_CALIBRATION_UPDATE && msg->dlc >= CAN_MESSAGE_DLC_CALIBRATION) {unsigned char sensorId = msg->data[0]; int calibrationValue = (msg->data[1] << 8) | msg->data[2]; if (sensorId < MAX_SENSORS) {g_sensorCalibrationData[sensorId] = calibrationValue;} else {logError(\"Received out-of-bounds sensor ID for calibration update. Ignoring command.\");}}}void vehicleECUMainLoop_fixed() {systemInit(); CanMessage receivedMsg = receiveCANMessage_simulated(); processCanCommand_fixed(&receivedMsg);}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#define CONFIG_TYPE_A_COUNT 10\n#define CONFIG_TYPE_B_COUNT 15\n#define CONFIG_TYPE_C_COUNT 8\n#define MAX_CONFIG_TYPES 3\n\ntypedef struct {\n    unsigned int param1;\n    unsigned short param2;\n} ConfigItemA;\n\ntypedef struct {\n    unsigned char status;\n    unsigned int data;\n    unsigned short checksum;\n} ConfigItemB;\n\ntypedef struct {\n    float value;\n} ConfigItemC;\n\nstatic ConfigItemA g_configA[CONFIG_TYPE_A_COUNT];\nstatic ConfigItemB g_configB[CONFIG_TYPE_B_COUNT];\nstatic ConfigItemC g_configC[CONFIG_TYPE_C_COUNT];\n\nstatic unsigned short g_configSizes[MAX_CONFIG_TYPES] = {\n    CONFIG_TYPE_A_COUNT,\n    CONFIG_TYPE_B_COUNT,\n    CONFIG_TYPE_C_COUNT\n};\n\ntypedef struct {\n    unsigned char config_type_id;\n    unsigned char sub_index;\n    unsigned int value;\n} DiagnosticCommand;\n\nDiagnosticCommand receiveDiagnosticCommand_vulnerable() {\n    DiagnosticCommand cmd;\n    cmd.config_type_id = 0; \n    cmd.sub_index = 10; \n    cmd.value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid logDiagnosticError(const char* msg) {\n}\n\nvoid processDiagnosticCommand_vulnerable() {\n    DiagnosticCommand cmd = receiveDiagnosticCommand_vulnerable();\n\n    if (cmd.config_type_id < MAX_CONFIG_TYPES) {\n        switch (cmd.config_type_id) {\n            case 0:\n                g_configA[cmd.sub_index].param1 = cmd.value;\n                break;\n            case 1:\n                g_configB[cmd.sub_index].data = cmd.value;\n                break;\n            case 2:\n                g_configC[cmd.sub_index].value = (float)cmd.value;\n                break;\n            default:\n                logDiagnosticError(\"Unknown config type ID received.\");\n                break;\n        }\n    } else {\n        logDiagnosticError(\"Invalid config type ID received.\");\n    }\n}\n\nvoid diagnosticModuleMain_vulnerable() {\n    for (int i = 0; i < CONFIG_TYPE_A_COUNT; ++i) g_configA[i] = (ConfigItemA){0,0};\n    for (int i = 0; i < CONFIG_TYPE_B_COUNT; ++i) g_configB[i] = (ConfigItemB){0,0,0};\n    for (int i = 0; i < CONFIG_TYPE_C_COUNT; ++i) g_configC[i] = (ConfigItemC){0.0f};\n\n    processDiagnosticCommand_vulnerable();\n}",
    "fixed_code": "#define CONFIG_TYPE_A_COUNT 10\n#define CONFIG_TYPE_B_COUNT 15\n#define CONFIG_TYPE_C_COUNT 8\n#define MAX_CONFIG_TYPES 3\n\ntypedef struct {\n    unsigned int param1;\n    unsigned short param2;\n} ConfigItemA;\n\ntypedef struct {\n    unsigned char status;\n    unsigned int data;\n    unsigned short checksum;\n} ConfigItemB;\n\ntypedef struct {\n    float value;\n} ConfigItemC;\n\nstatic ConfigItemA g_configA[CONFIG_TYPE_A_COUNT];\nstatic ConfigItemB g_configB[CONFIG_TYPE_B_COUNT];\nstatic ConfigItemC g_configC[CONFIG_TYPE_C_COUNT];\n\nstatic unsigned short g_configSizes[MAX_CONFIG_TYPES] = {\n    CONFIG_TYPE_A_COUNT,\n    CONFIG_TYPE_B_COUNT,\n    CONFIG_TYPE_C_COUNT\n};\n\ntypedef struct {\n    unsigned char config_type_id;\n    unsigned char sub_index;\n    unsigned int value;\n} DiagnosticCommand;\n\nDiagnosticCommand receiveDiagnosticCommand_fixed() {\n    DiagnosticCommand cmd;\n    cmd.config_type_id = 0;\n    cmd.sub_index = 10; \n    cmd.value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid logDiagnosticError(const char* msg) {\n}\n\nvoid processDiagnosticCommand_fixed() {\n    DiagnosticCommand cmd = receiveDiagnosticCommand_fixed();\n\n    if (cmd.config_type_id < MAX_CONFIG_TYPES) {\n        unsigned short max_index = g_configSizes[cmd.config_type_id];\n        \n        if (cmd.sub_index < max_index) {\n            switch (cmd.config_type_id) {\n                case 0:\n                    g_configA[cmd.sub_index].param1 = cmd.value;\n                    break;\n                case 1:\n                    g_configB[cmd.sub_index].data = cmd.value;\n                    break;\n                case 2:\n                    g_configC[cmd.sub_index].value = (float)cmd.value;\n                    break;\n                default:\n                    logDiagnosticError(\"Internal error: Reached default case in config type switch.\");\n                    break;\n            }\n        } else {\n            logDiagnosticError(\"Out-of-bounds sub-index for configuration update. Ignoring command.\");\n        }\n    } else {\n        logDiagnosticError(\"Invalid config type ID received.\");\n    }\n}\n\nvoid diagnosticModuleMain_fixed() {\n    for (int i = 0; i < CONFIG_TYPE_A_COUNT; ++i) g_configA[i] = (ConfigItemA){0,0};\n    for (int i = 0; i < CONFIG_TYPE_B_COUNT; ++i) g_configB[i] = (ConfigItemB){0,0,0};\n    for (int i = 0; i < CONFIG_TYPE_C_COUNT; ++i) g_configC[i] = (ConfigItemC){0.0f};\n\n    processDiagnosticCommand_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#define DTC_MAX_COUNT 100\n#define DIAG_CMD_GET_DTC_STATUS 0x01\n#define DTC_STATUS_INACTIVE 0x00\n#define DTC_STATUS_ACTIVE 0x01\n#define DTC_STATUS_CONFIRMED 0x03\ntypedef struct {\n    unsigned short command_id;\n    unsigned short dtc_index;\n    unsigned char  padding[4];\n} DiagnosticRequest;\ntypedef struct {\n    unsigned short command_id;\n    unsigned char  dtc_status;\n    unsigned char  response_code;\n    unsigned char  padding[3];\n} DiagnosticResponse;\nstatic unsigned char g_dtcStatus[DTC_MAX_COUNT];\nDiagnosticRequest getSimulatedDiagnosticRequest() {\n    DiagnosticRequest req;\n    req.command_id = DIAG_CMD_GET_DTC_STATUS;\n    req.dtc_index = 101;\n    req.padding[0] = req.padding[1] = req.padding[2] = req.padding[3] = 0;\n    return req;\n}\nvoid sendDiagnosticResponse(const DiagnosticResponse* res) {}\nvoid logSecurityEvent(const char* event) {}\nvoid initializeDTCStates() {\n    for (int i = 0; i < DTC_MAX_COUNT; ++i) {\n        g_dtcStatus[i] = DTC_STATUS_INACTIVE;\n    }\n    g_dtcStatus[0] = DTC_STATUS_ACTIVE;\n    g_dtcStatus[50] = DTC_STATUS_CONFIRMED;\n}\nvoid handleDiagnosticRequest() {\n    DiagnosticRequest request = getSimulatedDiagnosticRequest();\n    DiagnosticResponse response;\n    response.command_id = request.command_id;\n    response.response_code = 0x00;\n    if (request.command_id == DIAG_CMD_GET_DTC_STATUS) {\n        response.dtc_status = g_dtcStatus[request.dtc_index];\n    } else {\n        response.response_code = 0x01;\n        response.dtc_status = 0x00;\n    }\n    sendDiagnosticResponse(&response);\n}\nvoid diagnosticModuleLoop() {\n    initializeDTCStates();\n    handleDiagnosticRequest();\n}",
    "fixed_code": "#define DTC_MAX_COUNT 100\n#define DIAG_CMD_GET_DTC_STATUS 0x01\n#define DTC_STATUS_INACTIVE 0x00\n#define DTC_STATUS_ACTIVE 0x01\n#define DTC_STATUS_CONFIRMED 0x03\ntypedef struct {\n    unsigned short command_id;\n    unsigned short dtc_index;\n    unsigned char  padding[4];\n} DiagnosticRequest;\ntypedef struct {\n    unsigned short command_id;\n    unsigned char  dtc_status;\n    unsigned char  response_code;\n    unsigned char  padding[3];\n} DiagnosticResponse;\nstatic unsigned char g_dtcStatus[DTC_MAX_COUNT];\nDiagnosticRequest getSimulatedDiagnosticRequest() {\n    DiagnosticRequest req;\n    req.command_id = DIAG_CMD_GET_DTC_STATUS;\n    req.dtc_index = 101;\n    req.padding[0] = req.padding[1] = req.padding[2] = req.padding[3] = 0;\n    return req;\n}\nvoid sendDiagnosticResponse(const DiagnosticResponse* res) {}\nvoid logSecurityEvent(const char* event) {}\nvoid initializeDTCStates() {\n    for (int i = 0; i < DTC_MAX_COUNT; ++i) {\n        g_dtcStatus[i] = DTC_STATUS_INACTIVE;\n    }\n    g_dtcStatus[0] = DTC_STATUS_ACTIVE;\n    g_dtcStatus[50] = DTC_STATUS_CONFIRMED;\n}\nvoid handleDiagnosticRequest() {\n    DiagnosticRequest request = getSimulatedDiagnosticRequest();\n    DiagnosticResponse response;\n    response.command_id = request.command_id;\n    response.response_code = 0x00;\n    if (request.command_id == DIAG_CMD_GET_DTC_STATUS) {\n        if (request.dtc_index < DTC_MAX_COUNT) {\n            response.dtc_status = g_dtcStatus[request.dtc_index];\n        } else {\n            response.response_code = 0x02;\n            response.dtc_status = 0x00;\n            logSecurityEvent(\"DIAG: Out-of-bounds DTC index request received. Ignoring.\");\n        }\n    } else {\n        response.response_code = 0x01;\n        response.dtc_status = 0x00;\n    }\n    sendDiagnosticResponse(&response);\n}\nvoid diagnosticModuleLoop() {\n    initializeDTCStates();\n    handleDiagnosticRequest();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#define MAX_SUBSYSTEMS 5\n#define MAX_DATA_POINTS_PER_SUBSYSTEM 10\n\ntypedef enum {\n    SUBSYSTEM_ENGINE = 0,\n    SUBSYSTEM_TRANSMISSION,\n    SUBSYSTEM_BRAKES,\n    SUBSYSTEM_HVAC,\n    SUBSYSTEM_INFOTAINMENT,\n    SUBSYSTEM_COUNT\n} SubsystemType;\n\ntypedef struct {\n    SubsystemType type;\n    int data_index;\n    long value;\n} VehicleMetricPacket;\n\nstatic long g_subsystemMetrics[MAX_SUBSYSTEMS][MAX_DATA_POINTS_PER_SUBSYSTEM];\n\nVehicleMetricPacket receiveMetricPacket_vulnerable() {\n    VehicleMetricPacket packet;\n    packet.type = SUBSYSTEM_ENGINE;\n    packet.data_index = 10;\n    packet.value = 12345L;\n    return packet;\n}\n\nvoid logSystemError(const char* msg) {\n}\n\nvoid processVehicleMetric_vulnerable() {\n    VehicleMetricPacket packet = receiveMetricPacket_vulnerable();\n\n    if (packet.type < SUBSYSTEM_COUNT) {\n        g_subsystemMetrics[packet.type][packet.data_index] = packet.value;\n    } else {\n        logSystemError(\"Received metric for unknown subsystem type.\");\n    }\n}\n\nvoid metricProcessorInit_vulnerable() {\n    for (int i = 0; i < MAX_SUBSYSTEMS; ++i) {\n        for (int j = 0; j < MAX_DATA_POINTS_PER_SUBSYSTEM; ++j) {\n            g_subsystemMetrics[i][j] = 0;\n        }\n    }\n}\n\nvoid simulateMetricProcessing_vulnerable() {\n    metricProcessorInit_vulnerable();\n    processVehicleMetric_vulnerable();\n}",
    "fixed_code": "#define MAX_SUBSYSTEMS 5\n#define MAX_DATA_POINTS_PER_SUBSYSTEM 10\n\ntypedef enum {\n    SUBSYSTEM_ENGINE = 0,\n    SUBSYSTEM_TRANSMISSION,\n    SUBSYSTEM_BRAKES,\n    SUBSYSTEM_HVAC,\n    SUBSYSTEM_INFOTAINMENT,\n    SUBSYSTEM_COUNT\n} SubsystemType;\n\ntypedef struct {\n    SubsystemType type;\n    int data_index;\n    long value;\n} VehicleMetricPacket;\n\nstatic long g_subsystemMetrics[MAX_SUBSYSTEMS][MAX_DATA_POINTS_PER_SUBSYSTEM];\n\nVehicleMetricPacket receiveMetricPacket_fixed() {\n    VehicleMetricPacket packet;\n    packet.type = SUBSYSTEM_ENGINE;\n    packet.data_index = 10;\n    packet.value = 12345L;\n    return packet;\n}\n\nvoid logSystemError(const char* msg) {\n}\n\nvoid processVehicleMetric_fixed() {\n    VehicleMetricPacket packet = receiveMetricPacket_fixed();\n\n    if (packet.type < SUBSYSTEM_COUNT) {\n        if (packet.data_index >= 0 && packet.data_index < MAX_DATA_POINTS_PER_SUBSYSTEM) {\n            g_subsystemMetrics[packet.type][packet.data_index] = packet.value;\n        } else {\n            logSystemError(\"Received metric with out-of-bounds data index. Ignoring packet.\");\n        }\n    } else {\n        logSystemError(\"Received metric for unknown subsystem type.\");\n    }\n}\n\nvoid metricProcessorInit_fixed() {\n    for (int i = 0; i < MAX_SUBSYSTEMS; ++i) {\n        for (int j = 0; j < MAX_DATA_POINTS_PER_SUBSYSTEM; ++j) {\n            g_subsystemMetrics[i][j] = 0;\n        }\n    }\n}\n\nvoid simulateMetricProcessing_fixed() {\n    metricProcessorInit_fixed();\n    processVehicleMetric_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#define MAX_BATTERY_CELLS 96\n#define BMS_CMD_UPDATE_VOLTAGE 0x01\n#define BMS_CMD_UPDATE_TEMP    0x02\n\ntypedef struct {\n    unsigned short voltage_mV;\n    short temperature_C;\n    unsigned char state_of_charge_percent;\n} BatteryCellInfo;\n\nstatic BatteryCellInfo g_batteryCellInfo[MAX_BATTERY_CELLS];\n\ntypedef struct {\n    unsigned char commandType;\n    unsigned char cellId;\n    unsigned short dataValue;\n} BMS_Command;\n\nvoid logBMSWarning(const char* msg) {\n}\n\nBMS_Command receiveBMSCommand_simulated_vulnerable() {\n    BMS_Command cmd;\n    cmd.commandType = BMS_CMD_UPDATE_VOLTAGE;\n    cmd.cellId = 100;\n    cmd.dataValue = 3800;\n    return cmd;\n}\n\nvoid initializeBMSData() {\n    for (unsigned int i = 0; i < MAX_BATTERY_CELLS; ++i) {\n        g_batteryCellInfo[i].voltage_mV = 0;\n        g_batteryCellInfo[i].temperature_C = 0;\n        g_batteryCellInfo[i].state_of_charge_percent = 0;\n    }\n}\n\nvoid processBMSCommand_vulnerable() {\n    BMS_Command cmd = receiveBMSCommand_simulated_vulnerable();\n\n    if (cmd.commandType == BMS_CMD_UPDATE_VOLTAGE) {\n        g_batteryCellInfo[cmd.cellId].voltage_mV = cmd.dataValue;\n    } else if (cmd.commandType == BMS_CMD_UPDATE_TEMP) {\n        g_batteryCellInfo[cmd.cellId].temperature_C = (short)cmd.dataValue;\n    } else {\n        logBMSWarning(\"Unknown BMS command received.\");\n    }\n}\n\nvoid bmsModuleMain_vulnerable() {\n    initializeBMSData();\n    processBMSCommand_vulnerable();\n}",
    "fixed_code": "#define MAX_BATTERY_CELLS 96\n#define BMS_CMD_UPDATE_VOLTAGE 0x01\n#define BMS_CMD_UPDATE_TEMP    0x02\n\ntypedef struct {\n    unsigned short voltage_mV;\n    short temperature_C;\n    unsigned char state_of_charge_percent;\n} BatteryCellInfo;\n\nstatic BatteryCellInfo g_batteryCellInfo[MAX_BATTERY_CELLS];\n\ntypedef struct {\n    unsigned char commandType;\n    unsigned char cellId;\n    unsigned short dataValue;\n} BMS_Command;\n\nvoid logBMSWarning(const char* msg) {\n}\n\nBMS_Command receiveBMSCommand_simulated_fixed() {\n    BMS_Command cmd;\n    cmd.commandType = BMS_CMD_UPDATE_VOLTAGE;\n    cmd.cellId = 100;\n    cmd.dataValue = 3800;\n    return cmd;\n}\n\nvoid initializeBMSData() {\n    for (unsigned int i = 0; i < MAX_BATTERY_CELLS; ++i) {\n        g_batteryCellInfo[i].voltage_mV = 0;\n        g_batteryCellInfo[i].temperature_C = 0;\n        g_batteryCellInfo[i].state_of_charge_percent = 0;\n    }\n}\n\nvoid processBMSCommand_fixed() {\n    BMS_Command cmd = receiveBMSCommand_simulated_fixed();\n\n    if (cmd.cellId >= MAX_BATTERY_CELLS) {\n        logBMSWarning(\"Received BMS command with out-of-bounds cell ID. Ignoring.\");\n        return;\n    }\n\n    if (cmd.commandType == BMS_CMD_UPDATE_VOLTAGE) {\n        g_batteryCellInfo[cmd.cellId].voltage_mV = cmd.dataValue;\n    } else if (cmd.commandType == BMS_CMD_UPDATE_TEMP) {\n        g_batteryCellInfo[cmd.cellId].temperature_C = (short)cmd.dataValue;\n    } else {\n        logBMSWarning(\"Unknown BMS command received.\");\n    }\n}\n\nvoid bmsModuleMain_fixed() {\n    initializeBMSData();\n    processBMSCommand_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stddef.h>\n\n#define MAX_CONFIG_PARAMETERS 15\n\nstatic long g_engineRPMTarget = 0;\nstatic long g_gearShiftThreshold = 0;\nstatic long g_suspensionHeightOffset = 0;\n\ntypedef struct {\n    long* valuePtr;\n    long  minValue;\n    long  maxValue;\n} ConfigParameterInfo;\n\nstatic ConfigParameterInfo g_configParameterMap[MAX_CONFIG_PARAMETERS];\n\nvoid initializeParameterMap() {\n    g_configParameterMap[0].valuePtr = &g_engineRPMTarget;\n    g_configParameterMap[0].minValue = 500;\n    g_configParameterMap[0].maxValue = 7000;\n\n    g_configParameterMap[1].valuePtr = &g_gearShiftThreshold;\n    g_configParameterMap[1].minValue = 1000;\n    g_configParameterMap[1].maxValue = 6000;\n\n    g_configParameterMap[2].valuePtr = &g_suspensionHeightOffset;\n    g_configParameterMap[2].minValue = -50;\n    g_configParameterMap[2].maxValue = 50;\n\n    for (int i = 3; i < MAX_CONFIG_PARAMETERS; ++i) {\n        g_configParameterMap[i].valuePtr = NULL;\n        g_configParameterMap[i].minValue = 0;\n        g_configParameterMap[i].maxValue = 0;\n    }\n}\n\ntypedef struct {\n    unsigned char commandID;\n    unsigned char parameterIndex;\n    long          newValue;\n} ParameterUpdateCommand;\n\nParameterUpdateCommand receiveParameterUpdateCommand_vulnerable() {\n    ParameterUpdateCommand cmd;\n    cmd.commandID = 0x05;\n    cmd.parameterIndex = 20;\n    cmd.newValue = 9999;\n    return cmd;\n}\n\nvoid logVehicleWarning(const char* msg) {\n}\n\nvoid processParameterUpdate_vulnerable() {\n    ParameterUpdateCommand command = receiveParameterUpdateCommand_vulnerable();\n\n    if (command.commandID == 0x05) {\n        ConfigParameterInfo paramInfo = g_configParameterMap[command.parameterIndex];\n\n        if (paramInfo.valuePtr != NULL) {\n            *(paramInfo.valuePtr) = command.newValue;\n        } else {\n            logVehicleWarning(\"Attempted to update unregistered parameter.\");\n        }\n    } else {\n        logVehicleWarning(\"Received unsupported parameter command ID.\");\n    }\n}\n\nvoid ecuMainLoop_vulnerable() {\n    initializeParameterMap();\n    processParameterUpdate_vulnerable();\n}",
    "fixed_code": "#include <stddef.h>\n\n#define MAX_CONFIG_PARAMETERS 15\n\nstatic long g_engineRPMTarget = 0;\nstatic long g_gearShiftThreshold = 0;\nstatic long g_suspensionHeightOffset = 0;\n\ntypedef struct {\n    long* valuePtr;\n    long  minValue;\n    long  maxValue;\n} ConfigParameterInfo;\n\nstatic ConfigParameterInfo g_configParameterMap[MAX_CONFIG_PARAMETERS];\n\nvoid initializeParameterMap() {\n    g_configParameterMap[0].valuePtr = &g_engineRPMTarget;\n    g_configParameterMap[0].minValue = 500;\n    g_configParameterMap[0].maxValue = 7000;\n\n    g_configParameterMap[1].valuePtr = &g_gearShiftThreshold;\n    g_configParameterMap[1].minValue = 1000;\n    g_configParameterMap[1].maxValue = 6000;\n\n    g_configParameterMap[2].valuePtr = &g_suspensionHeightOffset;\n    g_configParameterMap[2].minValue = -50;\n    g_configParameterMap[2].maxValue = 50;\n\n    for (int i = 3; i < MAX_CONFIG_PARAMETERS; ++i) {\n        g_configParameterMap[i].valuePtr = NULL;\n        g_configParameterMap[i].minValue = 0;\n        g_configParameterMap[i].maxValue = 0;\n    }\n}\n\ntypedef struct {\n    unsigned char commandID;\n    unsigned char parameterIndex;\n    long          newValue;\n} ParameterUpdateCommand;\n\nParameterUpdateCommand receiveParameterUpdateCommand_fixed() {\n    ParameterUpdateCommand cmd;\n    cmd.commandID = 0x05;\n    cmd.parameterIndex = 20;\n    cmd.newValue = 9999;\n    return cmd;\n}\n\nvoid logVehicleWarning(const char* msg) {\n}\n\nvoid processParameterUpdate_fixed() {\n    ParameterUpdateCommand command = receiveParameterUpdateCommand_fixed();\n\n    if (command.commandID == 0x05) {\n        if (command.parameterIndex < MAX_CONFIG_PARAMETERS) {\n            ConfigParameterInfo paramInfo = g_configParameterMap[command.parameterIndex];\n\n            if (paramInfo.valuePtr != NULL) {\n                if (command.newValue >= paramInfo.minValue && command.newValue <= paramInfo.maxValue) {\n                    *(paramInfo.valuePtr) = command.newValue;\n                } else {\n                    logVehicleWarning(\"Parameter update value out of allowed range.\");\n                }\n            } else {\n                logVehicleWarning(\"Attempted to update unregistered parameter.\");\n            }\n        } else {\n            logVehicleWarning(\"Received parameter update with out-of-bounds index.\");\n        }\n    } else {\n        logVehicleWarning(\"Received unsupported parameter command ID.\");\n    }\n}\n\nvoid ecuMainLoop_fixed() {\n    initializeParameterMap();\n    processParameterUpdate_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#define MAX_SENSORS 128\n\ntypedef struct {\n    unsigned int timestamp;\n    int value;\n    unsigned char status;\n} SensorReading;\n\ntypedef struct {\n    unsigned int sensor_id;\n    unsigned int new_timestamp;\n    int new_value;\n    unsigned char new_status;\n} SensorUpdateCommand;\n\nstatic SensorReading g_sensorReadings[MAX_SENSORS];\n\nSensorUpdateCommand receiveSensorUpdateCommand_vulnerable() {\n    SensorUpdateCommand cmd;\n    cmd.sensor_id = 128;\n    cmd.new_timestamp = 1678886400;\n    cmd.new_value = 2500;\n    cmd.new_status = 0x01;\n    return cmd;\n}\n\nvoid processSensorUpdate_vulnerable() {\n    SensorUpdateCommand cmd = receiveSensorUpdateCommand_vulnerable();\n\n    g_sensorReadings[cmd.sensor_id].timestamp = cmd.new_timestamp;\n    g_sensorReadings[cmd.sensor_id].value = cmd.new_value;\n    g_sensorReadings[cmd.sensor_id].status = cmd.new_status;\n}\n\nvoid initializeSensorData_vulnerable() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        g_sensorReadings[i].timestamp = 0;\n        g_sensorReadings[i].value = 0;\n        g_sensorReadings[i].status = 0;\n    }\n}\n\nvoid sensorDataHandlerMain_vulnerable() {\n    initializeSensorData_vulnerable();\n    processSensorUpdate_vulnerable();\n}",
    "fixed_code": "#define MAX_SENSORS 128\n\ntypedef struct {\n    unsigned int timestamp;\n    int value;\n    unsigned char status;\n} SensorReading;\n\ntypedef struct {\n    unsigned int sensor_id;\n    unsigned int new_timestamp;\n    int new_value;\n    unsigned char new_status;\n} SensorUpdateCommand;\n\nstatic SensorReading g_sensorReadings[MAX_SENSORS];\n\nSensorUpdateCommand receiveSensorUpdateCommand_fixed() {\n    SensorUpdateCommand cmd;\n    cmd.sensor_id = 128;\n    cmd.new_timestamp = 1678886400;\n    cmd.new_value = 2500;\n    cmd.new_status = 0x01;\n    return cmd;\n}\n\nvoid logErrorEvent(const char* msg) {\n}\n\nvoid processSensorUpdate_fixed() {\n    SensorUpdateCommand cmd = receiveSensorUpdateCommand_fixed();\n\n    if (cmd.sensor_id < MAX_SENSORS) {\n        g_sensorReadings[cmd.sensor_id].timestamp = cmd.new_timestamp;\n        g_sensorReadings[cmd.sensor_id].value = cmd.new_value;\n        g_sensorReadings[cmd.sensor_id].status = cmd.new_status;\n    } else {\n        logErrorEvent(\"Received sensor update with out-of-bounds sensor ID. Ignoring command.\");\n    }\n}\n\nvoid initializeSensorData_fixed() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        g_sensorReadings[i].timestamp = 0;\n        g_sensorReadings[i].value = 0;\n        g_sensorReadings[i].status = 0;\n    }\n}\n\nvoid sensorDataHandlerMain_fixed() {\n    initializeSensorData_fixed();\n    processSensorUpdate_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#define BCU_COUNT 8\n#define STATUS_PARAM_COUNT 16\n\ntypedef enum {\n    TEMP_SENSOR_1 = 0,\n    VOLTAGE_CELL_1,\n    CURRENT_MEASUREMENT,\n    FAN_SPEED,\n    STATUS_PARAM_MAX\n} BcuStatusParameter;\n\nstatic int g_bcuStatus[BCU_COUNT][STATUS_PARAM_COUNT];\n\ntypedef struct {\n    unsigned char bcu_id;\n    unsigned char param_index;\n    int           value;\n    unsigned char write_operation;\n} DiagnosticRequest;\n\nvoid logDiagnosticAlert(const char* msg) {\n}\n\nDiagnosticRequest receiveDiagnosticRequest_vulnerable() {\n    DiagnosticRequest req;\n    req.bcu_id = 0;\n    req.param_index = STATUS_PARAM_COUNT; \n    req.value = 0xABCD;\n    req.write_operation = 1;\n    return req;\n}\n\nvoid processBcuDiagnostic_vulnerable() {\n    DiagnosticRequest req = receiveDiagnosticRequest_vulnerable();\n\n    if (req.bcu_id < BCU_COUNT) {\n        g_bcuStatus[req.bcu_id][req.param_index] = req.value;\n    } else {\n        logDiagnosticAlert(\"Invalid BCU ID in diagnostic request.\");\n    }\n}\n\nvoid bmsInit_vulnerable() {\n    for (int i = 0; i < BCU_COUNT; ++i) {\n        for (int j = 0; j < STATUS_PARAM_COUNT; ++j) {\n            g_bcuStatus[i][j] = 0;\n        }\n    }\n}\n\nvoid bmsMainLoop_vulnerable() {\n    bmsInit_vulnerable();\n    processBcuDiagnostic_vulnerable();\n}",
    "fixed_code": "#define BCU_COUNT 8\n#define STATUS_PARAM_COUNT 16\n\ntypedef enum {\n    TEMP_SENSOR_1 = 0,\n    VOLTAGE_CELL_1,\n    CURRENT_MEASUREMENT,\n    FAN_SPEED,\n    STATUS_PARAM_MAX\n} BcuStatusParameter;\n\nstatic int g_bcuStatus[BCU_COUNT][STATUS_PARAM_COUNT];\n\ntypedef struct {\n    unsigned char bcu_id;\n    unsigned char param_index;\n    int           value;\n    unsigned char write_operation;\n} DiagnosticRequest;\n\nvoid logDiagnosticAlert(const char* msg) {\n}\n\nDiagnosticRequest receiveDiagnosticRequest_fixed() {\n    DiagnosticRequest req;\n    req.bcu_id = 0;\n    req.param_index = STATUS_PARAM_COUNT; \n    req.value = 0xABCD;\n    req.write_operation = 1;\n    return req;\n}\n\nvoid processBcuDiagnostic_fixed() {\n    DiagnosticRequest req = receiveDiagnosticRequest_fixed();\n\n    if (req.bcu_id < BCU_COUNT) {\n        if (req.param_index < STATUS_PARAM_COUNT) {\n            g_bcuStatus[req.bcu_id][req.param_index] = req.value;\n        } else {\n            logDiagnosticAlert(\"Invalid parameter index in diagnostic request.\");\n        }\n    } else {\n        logDiagnosticAlert(\"Invalid BCU ID in diagnostic request.\");\n    }\n}\n\nvoid bmsInit_fixed() {\n    for (int i = 0; i < BCU_COUNT; ++i) {\n        for (int j = 0; j < STATUS_PARAM_COUNT; ++j) {\n            g_bcuStatus[i][j] = 0;\n        }\n    }\n}\n\nvoid bmsMainLoop_fixed() {\n    bmsInit_fixed();\n    processBcuDiagnostic_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#define MAX_DRIVING_MODES 4\ntypedef struct {\n    float throttle_response_factor;\n    unsigned char transmission_shift_aggressiveness;\n    unsigned char suspension_damping_level;\n    unsigned short steering_assist_level;\n} DrivingProfile;\nstatic DrivingProfile g_drivingProfiles[MAX_DRIVING_MODES] = {\n    {0.5f, 20, 0, 800},\n    {0.7f, 50, 1, 500},\n    {0.9f, 80, 2, 200},\n    {0.6f, 40, 3, 900}\n};\ntypedef struct {\n    unsigned char command_id;\n    unsigned char mode_index;\n    unsigned short reserved;\n} VehicleControlCommand;\nvoid log_vehicle_event(const char* event_msg) {}\nVehicleControlCommand receive_vehicle_command_vulnerable() {\n    VehicleControlCommand cmd;\n    cmd.command_id = 0x01;\n    cmd.mode_index = 5;\n    cmd.reserved = 0;\n    return cmd;\n}\nvoid apply_driving_mode_vulnerable(unsigned char mode_id) {\n    DrivingProfile selected_profile = g_drivingProfiles[mode_id];\n    log_vehicle_event(\"Applied driving mode profile.\");\n}\nvoid vehicle_control_loop_vulnerable() {\n    VehicleControlCommand command = receive_vehicle_command_vulnerable();\n    if (command.command_id == 0x01) {\n        apply_driving_mode_vulnerable(command.mode_index);\n    } else {\n        log_vehicle_event(\"Unknown vehicle control command received.\");\n    }\n}",
    "fixed_code": "#define MAX_DRIVING_MODES 4\ntypedef struct {\n    float throttle_response_factor;\n    unsigned char transmission_shift_aggressiveness;\n    unsigned char suspension_damping_level;\n    unsigned short steering_assist_level;\n} DrivingProfile;\nstatic DrivingProfile g_drivingProfiles[MAX_DRIVING_MODES] = {\n    {0.5f, 20, 0, 800},\n    {0.7f, 50, 1, 500},\n    {0.9f, 80, 2, 200},\n    {0.6f, 40, 3, 900}\n};\ntypedef struct {\n    unsigned char command_id;\n    unsigned char mode_index;\n    unsigned short reserved;\n} VehicleControlCommand;\nvoid log_vehicle_event(const char* event_msg) {}\nVehicleControlCommand receive_vehicle_command_fixed() {\n    VehicleControlCommand cmd;\n    cmd.command_id = 0x01;\n    cmd.mode_index = 5;\n    cmd.reserved = 0;\n    return cmd;\n}\nvoid apply_driving_mode_fixed(unsigned char mode_id) {\n    DrivingProfile selected_profile = g_drivingProfiles[mode_id];\n    log_vehicle_event(\"Applied driving mode profile.\");\n}\nvoid vehicle_control_loop_fixed() {\n    VehicleControlCommand command = receive_vehicle_command_fixed();\n    if (command.command_id == 0x01) {\n        if (command.mode_index < MAX_DRIVING_MODES) {\n            apply_driving_mode_fixed(command.mode_index);\n        } else {\n            log_vehicle_event(\"Received invalid driving mode index. Ignoring command.\");\n        }\n    } else {\n        log_vehicle_event(\"Unknown vehicle control command received.\");\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#define MAX_SUBSYSTEMS 3\n#define MAX_PARAMS_PER_SUBSYSTEM 10\n\ntypedef struct {\n    unsigned int param_value;\n    unsigned char param_status;\n} ConfigParam;\n\nstatic ConfigParam g_subsystemConfigs[MAX_SUBSYSTEMS][MAX_PARAMS_PER_SUBSYSTEM];\n\nstatic unsigned char g_subsystemActualParamCounts[MAX_SUBSYSTEMS] = {\n    5, \n    8, \n    3  \n};\n\ntypedef struct {\n    unsigned char subsystem_id;\n    unsigned char parameter_offset;\n    unsigned int new_value;\n} ConfigUpdateCommand;\n\nvoid logError(const char* msg) {\n}\n\nConfigUpdateCommand receiveConfigUpdateCommand_vulnerable() {\n    ConfigUpdateCommand cmd;\n    cmd.subsystem_id = 0;\n    cmd.parameter_offset = 5;\n    cmd.new_value = 0xAAAA;\n    return cmd;\n}\n\nvoid initializeSubsystemConfigs_vulnerable() {\n    for (int i = 0; i < MAX_SUBSYSTEMS; ++i) {\n        for (int j = 0; j < MAX_PARAMS_PER_SUBSYSTEM; ++j) {\n            g_subsystemConfigs[i][j] = (ConfigParam){0, 0};\n        }\n    }\n}\n\nvoid processConfigUpdate_vulnerable() {\n    ConfigUpdateCommand cmd = receiveConfigUpdateCommand_vulnerable();\n\n    if (cmd.subsystem_id < MAX_SUBSYSTEMS) {\n        g_subsystemConfigs[cmd.subsystem_id][cmd.parameter_offset].param_value = cmd.new_value;\n    } else {\n        logError(\"Invalid subsystem ID received.\");\n    }\n}\n\nvoid systemMain_vulnerable() {\n    initializeSubsystemConfigs_vulnerable();\n    processConfigUpdate_vulnerable();\n}",
    "fixed_code": "#define MAX_SUBSYSTEMS 3\n#define MAX_PARAMS_PER_SUBSYSTEM 10\n\ntypedef struct {\n    unsigned int param_value;\n    unsigned char param_status;\n} ConfigParam;\n\nstatic ConfigParam g_subsystemConfigs[MAX_SUBSYSTEMS][MAX_PARAMS_PER_SUBSYSTEM];\n\nstatic unsigned char g_subsystemActualParamCounts[MAX_SUBSYSTEMS] = {\n    5, \n    8, \n    3  \n};\n\ntypedef struct {\n    unsigned char subsystem_id;\n    unsigned char parameter_offset;\n    unsigned int new_value;\n} ConfigUpdateCommand;\n\nvoid logError(const char* msg) {\n}\n\nConfigUpdateCommand receiveConfigUpdateCommand_fixed() {\n    ConfigUpdateCommand cmd;\n    cmd.subsystem_id = 0;\n    cmd.parameter_offset = 5;\n    cmd.new_value = 0xAAAA;\n    return cmd;\n}\n\nvoid initializeSubsystemConfigs_fixed() {\n    for (int i = 0; i < MAX_SUBSYSTEMS; ++i) {\n        for (int j = 0; j < MAX_PARAMS_PER_SUBSYSTEM; ++j) {\n            g_subsystemConfigs[i][j] = (ConfigParam){0, 0};\n        }\n    }\n}\n\nvoid processConfigUpdate_fixed() {\n    ConfigUpdateCommand cmd = receiveConfigUpdateCommand_fixed();\n\n    if (cmd.subsystem_id < MAX_SUBSYSTEMS) {\n        if (cmd.parameter_offset < g_subsystemActualParamCounts[cmd.subsystem_id]) {\n            g_subsystemConfigs[cmd.subsystem_id][cmd.parameter_offset].param_value = cmd.new_value;\n        } else {\n            logError(\"Parameter offset out of bounds for specified subsystem.\");\n        }\n    } else {\n        logError(\"Invalid subsystem ID received.\");\n    }\n}\n\nvoid systemMain_fixed() {\n    initializeSubsystemConfigs_fixed();\n    processConfigUpdate_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#define NUM_VEHICLE_MODES 4\n#define NUM_MODE_PARAMS 3\n\ntypedef enum {\n    MODE_PARAM_THROTTLE = 0,\n    MODE_PARAM_SUSPENSION,\n    MODE_PARAM_STEERING\n} ModeParameterIndex;\n\ntypedef struct {\n    int parameters[NUM_MODE_PARAMS];\n} VehicleModeConfig;\n\nstatic VehicleModeConfig g_vehicleModeConfigurations[NUM_VEHICLE_MODES];\n\ntypedef struct {\n    unsigned char mode_id;\n    unsigned char parameter_idx;\n    int new_value;\n} ConfigurationUpdateCommand;\n\nConfigurationUpdateCommand receiveConfigUpdateCommand_vulnerable() {\n    ConfigurationUpdateCommand cmd;\n    cmd.mode_id = 0;\n    cmd.parameter_idx = 3;\n    cmd.new_value = 123;\n    return cmd;\n}\n\nvoid logSystemDiagnostic(const char* msg) {\n}\n\nvoid initializeVehicleConfigs_vulnerable() {\n    for (unsigned char i = 0; i < NUM_VEHICLE_MODES; ++i) {\n        for (unsigned char j = 0; j < NUM_MODE_PARAMS; ++j) {\n            g_vehicleModeConfigurations[i].parameters[j] = 50;\n        }\n    }\n}\n\nvoid applyVehicleConfigUpdate_vulnerable() {\n    ConfigurationUpdateCommand cmd = receiveConfigUpdateCommand_vulnerable();\n\n    if (cmd.mode_id < NUM_VEHICLE_MODES) {\n        g_vehicleModeConfigurations[cmd.mode_id].parameters[cmd.parameter_idx] = cmd.new_value;\n    } else {\n        logSystemDiagnostic(\"ERROR: Invalid mode ID received for configuration update.\");\n    }\n}\n\nvoid vehicleControlMain_vulnerable() {\n    initializeVehicleConfigs_vulnerable();\n    applyVehicleConfigUpdate_vulnerable();\n}",
    "fixed_code": "#define NUM_VEHICLE_MODES 4\n#define NUM_MODE_PARAMS 3\n\ntypedef enum {\n    MODE_PARAM_THROTTLE = 0,\n    MODE_PARAM_SUSPENSION,\n    MODE_PARAM_STEERING\n} ModeParameterIndex;\n\ntypedef struct {\n    int parameters[NUM_MODE_PARAMS];\n} VehicleModeConfig;\n\nstatic VehicleModeConfig g_vehicleModeConfigurations[NUM_VEHICLE_MODES];\n\ntypedef struct {\n    unsigned char mode_id;\n    unsigned char parameter_idx;\n    int new_value;\n} ConfigurationUpdateCommand;\n\nConfigurationUpdateCommand receiveConfigUpdateCommand_fixed() {\n    ConfigurationUpdateCommand cmd;\n    cmd.mode_id = 0;\n    cmd.parameter_idx = 3;\n    cmd.new_value = 123;\n    return cmd;\n}\n\nvoid logSystemDiagnostic(const char* msg) {\n}\n\nvoid initializeVehicleConfigs_fixed() {\n    for (unsigned char i = 0; i < NUM_VEHICLE_MODES; ++i) {\n        for (unsigned char j = 0; j < NUM_MODE_PARAMS; ++j) {\n            g_vehicleModeConfigurations[i].parameters[j] = 50;\n        }\n    }\n}\n\nvoid applyVehicleConfigUpdate_fixed() {\n    ConfigurationUpdateCommand cmd = receiveConfigUpdateCommand_fixed();\n\n    if (cmd.mode_id < NUM_VEHICLE_MODES) {\n        if (cmd.parameter_idx < NUM_MODE_PARAMS) {\n            g_vehicleModeConfigurations[cmd.mode_id].parameters[cmd.parameter_idx] = cmd.new_value;\n        } else {\n            logSystemDiagnostic(\"WARNING: Attempted to update out-of-bounds mode parameter index.\");\n        }\n    } else {\n        logSystemDiagnostic(\"ERROR: Invalid mode ID received for configuration update.\");\n    }\n}\n\nvoid vehicleControlMain_fixed() {\n    initializeVehicleConfigs_fixed();\n    applyVehicleConfigUpdate_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct {\n    uint32_t id;\n    uint8_t data[8];\n    uint8_t dlc;\n} CanMessage;\n\ntypedef void (*RoutineHandler)(CanMessage* msg);\n\n#define MAX_DIAG_ROUTINES 10\n\nstatic RoutineHandler g_diagRoutineHandlers[MAX_DIAG_ROUTINES];\n\nvoid handleRoutineA(CanMessage* msg) {\n}\n\nvoid handleRoutineB(CanMessage* msg) {\n}\n\nvoid handleRoutineC(CanMessage* msg) {\n}\n\nvoid logDiagnosticEvent(const char* event) {\n}\n\nvoid initializeRoutineHandlers_vulnerable() {\n    g_diagRoutineHandlers[0] = handleRoutineA;\n    g_diagRoutineHandlers[1] = handleRoutineB;\n    g_diagRoutineHandlers[2] = handleRoutineC;\n    for (int i = 3; i < MAX_DIAG_ROUTINES; ++i) {\n        g_diagRoutineHandlers[i] = NULL;\n    }\n}\n\nCanMessage receiveDiagnosticCANMessage_vulnerable() {\n    CanMessage msg;\n    msg.id = 0x7E0;\n    msg.dlc = 8;\n    msg.data[0] = 10;\n    msg.data[1] = 0;\n    msg.data[2] = 0;\n    msg.data[3] = 0;\n    msg.data[4] = 0;\n    msg.data[5] = 0;\n    msg.data[6] = 0;\n    msg.data[7] = 0;\n    return msg;\n}\n\nvoid processDiagnosticCANMessage_vulnerable() {\n    CanMessage rx_msg = receiveDiagnosticCANMessage_vulnerable();\n\n    if (rx_msg.id == 0x7E0 && rx_msg.dlc >= 2) {\n        uint16_t routine_id = (uint16_t)rx_msg.data[0] | ((uint16_t)rx_msg.data[1] << 8);\n\n        if (g_diagRoutineHandlers[routine_id] != NULL) {\n            g_diagRoutineHandlers[routine_id](&rx_msg);\n        } else {\n            logDiagnosticEvent(\"Unknown or uninitialized diagnostic routine requested.\");\n        }\n    }\n}\n\nvoid diagnosticServiceMain_vulnerable() {\n    initializeRoutineHandlers_vulnerable();\n    processDiagnosticCANMessage_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct {\n    uint32_t id;\n    uint8_t data[8];\n    uint8_t dlc;\n} CanMessage;\n\ntypedef void (*RoutineHandler)(CanMessage* msg);\n\n#define MAX_DIAG_ROUTINES 10\n\nstatic RoutineHandler g_diagRoutineHandlers[MAX_DIAG_ROUTINES];\n\nvoid handleRoutineA(CanMessage* msg) {\n}\n\nvoid handleRoutineB(CanMessage* msg) {\n}\n\nvoid handleRoutineC(CanMessage* msg) {\n}\n\nvoid logDiagnosticEvent(const char* event) {\n}\n\nvoid initializeRoutineHandlers_fixed() {\n    g_diagRoutineHandlers[0] = handleRoutineA;\n    g_diagRoutineHandlers[1] = handleRoutineB;\n    g_diagRoutineHandlers[2] = handleRoutineC;\n    for (int i = 3; i < MAX_DIAG_ROUTINES; ++i) {\n        g_diagRoutineHandlers[i] = NULL;\n    }\n}\n\nCanMessage receiveDiagnosticCANMessage_fixed() {\n    CanMessage msg;\n    msg.id = 0x7E0;\n    msg.dlc = 8;\n    msg.data[0] = 10;\n    msg.data[1] = 0;\n    msg.data[2] = 0;\n    msg.data[3] = 0;\n    msg.data[4] = 0;\n    msg.data[5] = 0;\n    msg.data[6] = 0;\n    msg.data[7] = 0;\n    return msg;\n}\n\nvoid processDiagnosticCANMessage_fixed() {\n    CanMessage rx_msg = receiveDiagnosticCANMessage_fixed();\n\n    if (rx_msg.id == 0x7E0 && rx_msg.dlc >= 2) {\n        uint16_t routine_id = (uint16_t)rx_msg.data[0] | ((uint16_t)rx_msg.data[1] << 8);\n\n        if (routine_id < MAX_DIAG_ROUTINES) {\n            if (g_diagRoutineHandlers[routine_id] != NULL) {\n                g_diagRoutineHandlers[routine_id](&rx_msg);\n            } else {\n                logDiagnosticEvent(\"Requested diagnostic routine is uninitialized or not supported.\");\n            }\n        } else {\n            logDiagnosticEvent(\"Received diagnostic request with out-of-bounds Routine ID.\");\n        }\n    }\n}\n\nvoid diagnosticServiceMain_fixed() {\n    initializeRoutineHandlers_fixed();\n    processDiagnosticCANMessage_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdio.h>\n#include <stdint.h>\n\n#define MAX_STORED_DTCS 5\n\ntypedef struct {\n    uint16_t dtcCode;\n    uint8_t  statusByte;\n    uint32_t eventCount;\n} DTC_Entry;\n\nstatic DTC_Entry g_storedDTCs[MAX_STORED_DTCS];\nstatic uint8_t g_currentDTC_count = 3;\n\nvoid logDiagnosticError(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t queryType;\n    uint8_t dtcIndex;\n} DiagnosticQuery;\n\nDiagnosticQuery receiveDiagnosticQuery_vulnerable() {\n    DiagnosticQuery query;\n    query.queryType = 0x01;\n    query.dtcIndex = 5;\n    return query;\n}\n\nvoid initializeDTCs_vulnerable() {\n    g_storedDTCs[0] = (DTC_Entry){0xC010, 0x01, 5};\n    g_storedDTCs[1] = (DTC_Entry){0xC021, 0x0A, 2};\n    g_storedDTCs[2] = (DTC_Entry){0xC035, 0x40, 1};\n}\n\nvoid processDTCQuery_vulnerable() {\n    DiagnosticQuery query = receiveDiagnosticQuery_vulnerable();\n\n    if (query.queryType == 0x01) {\n        DTC_Entry requestedDTC = g_storedDTCs[query.dtcIndex];\n    } else {\n        logDiagnosticError(\"Unsupported diagnostic query type.\");\n    }\n}\n\nvoid main_vulnerable() {\n    initializeDTCs_vulnerable();\n    processDTCQuery_vulnerable();\n}",
    "fixed_code": "#include <stdio.h>\n#include <stdint.h>\n\n#define MAX_STORED_DTCS 5\n\ntypedef struct {\n    uint16_t dtcCode;\n    uint8_t  statusByte;\n    uint32_t eventCount;\n} DTC_Entry;\n\nstatic DTC_Entry g_storedDTCs[MAX_STORED_DTCS];\nstatic uint8_t g_currentDTC_count = 3;\n\nvoid logDiagnosticError(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t queryType;\n    uint8_t dtcIndex;\n} DiagnosticQuery;\n\nDiagnosticQuery receiveDiagnosticQuery_fixed() {\n    DiagnosticQuery query;\n    query.queryType = 0x01;\n    query.dtcIndex = 5;\n    return query;\n}\n\nvoid initializeDTCs_fixed() {\n    g_storedDTCs[0] = (DTC_Entry){0xC010, 0x01, 5};\n    g_storedDTCs[1] = (DTC_Entry){0xC021, 0x0A, 2};\n    g_storedDTCs[2] = (DTC_Entry){0xC035, 0x40, 1};\n}\n\nvoid processDTCQuery_fixed() {\n    DiagnosticQuery query = receiveDiagnosticQuery_fixed();\n\n    if (query.queryType == 0x01) {\n        if (query.dtcIndex < MAX_STORED_DTCS) {\n            DTC_Entry requestedDTC = g_storedDTCs[query.dtcIndex];\n        } else {\n            logDiagnosticError(\"Diagnostic DTC index out of bounds.\");\n        }\n    } else {\n        logDiagnosticError(\"Unsupported diagnostic query type.\");\n    n}\n}\n\nvoid main_fixed() {\n    initializeDTCs_fixed();\n    processDTCQuery_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>#define MAX_LIGHT_ZONES 5typedef struct {uint8_t brightness;uint8_t red;uint8_t green;uint8_t blue;uint16_t fade_rate_ms;} LightConfig;static LightConfig g_zoneConfigs[MAX_LIGHT_ZONES];typedef struct {uint8_t command_type;uint8_t zone_id;LightConfig new_config;} LightingCommand;void logLightingError(const char* msg) {}void initializeLightingSystem() {for (int i = 0; i < MAX_LIGHT_ZONES; ++i) {g_zoneConfigs[i].brightness = 50;g_zoneConfigs[i].red = 255;g_zoneConfigs[i].green = 255;g_zoneConfigs[i].blue = 255;g_zoneConfigs[i].fade_rate_ms = 100;}}LightingCommand getSimulatedLightingCommand_vulnerable() {LightingCommand cmd;cmd.command_type = 0x01;cmd.zone_id = 7;cmd.new_config.brightness = 100;cmd.new_config.red = 0;cmd.new_config.green = 255;cmd.new_config.blue = 0;cmd.new_config.fade_rate_ms = 500;return cmd;}void processLightingCommand_vulnerable(const LightingCommand* cmd) {if (cmd->command_type == 0x01) {g_zoneConfigs[cmd->zone_id] = cmd->new_config;} else {logLightingError(\"Unknown lighting command type.\");}}void lightingControlUnitMain_vulnerable() {initializeLightingSystem();LightingCommand cmd = getSimulatedLightingCommand_vulnerable();processLightingCommand_vulnerable(&cmd);}",
    "fixed_code": "#include <stdint.h>#define MAX_LIGHT_ZONES 5typedef struct {uint8_t brightness;uint8_t red;uint8_t green;uint8_t blue;uint16_t fade_rate_ms;} LightConfig;static LightConfig g_zoneConfigs[MAX_LIGHT_ZONES];typedef struct {uint8_t command_type;uint8_t zone_id;LightConfig new_config;} LightingCommand;void logLightingError(const char* msg) {}void initializeLightingSystem() {for (int i = 0; i < MAX_LIGHT_ZONES; ++i) {g_zoneConfigs[i].brightness = 50;g_zoneConfigs[i].red = 255;g_zoneConfigs[i].green = 255;g_zoneConfigs[i].blue = 255;g_zoneConfigs[i].fade_rate_ms = 100;}}LightingCommand getSimulatedLightingCommand_fixed() {LightingCommand cmd;cmd.command_type = 0x01;cmd.zone_id = 7;cmd.new_config.brightness = 100;cmd.new_config.red = 0;cmd.new_config.green = 255;cmd.new_config.blue = 0;cmd.new_config.fade_rate_ms = 500;return cmd;}void processLightingCommand_fixed(const LightingCommand* cmd) {if (cmd->command_type == 0x01) {if (cmd->zone_id < MAX_LIGHT_ZONES) {g_zoneConfigs[cmd->zone_id] = cmd->new_config;} else {logLightingError(\"Received out-of-bounds light zone ID. Ignoring command.\");}} else {logLightingError(\"Unknown lighting command type.\");}}void lightingControlUnitMain_fixed() {initializeLightingSystem();LightingCommand cmd = getSimulatedLightingCommand_fixed();processLightingCommand_fixed(&cmd);}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>#include <stddef.h>typedef struct {uint32_t id;uint8_t data[8];uint8_t dlc;} CanMessage;#define MAX_SUB_COMMANDS 5#define MAIN_CMD_DIAGNOSTIC_QUERY 0x10typedef void (*DiagnosticHandler)(uint16_t param1, uint16_t param2);static DiagnosticHandler g_diagnosticHandlers_vulnerable[MAX_SUB_COMMANDS];void logSecurityViolation(const char* msg) {}void diagHandler_ReadSensor_vulnerable(uint16_t sensorId, uint16_t unused) {}void diagHandler_ResetModule_vulnerable(uint16_t moduleId, uint16_t unused) {}void diagHandler_GetStatus_vulnerable(uint16_t statusType, uint16_t unused) {}void diagHandler_ClearDTC_vulnerable(uint16_t dtcCode, uint16_t unused) {}void diagHandler_PerformSelfTest_vulnerable(uint16_t testId, uint16_t unused) {}CanMessage receiveCanMessage_Vulnerable() {CanMessage msg;msg.id = 0x7E1;msg.dlc = 8;msg.data[0] = MAIN_CMD_DIAGNOSTIC_QUERY;msg.data[1] = 5;msg.data[2] = 0x01;msg.data[3] = 0x02;msg.data[4] = 0x00;msg.data[5] = 0x00;msg.data[6] = 0x00;msg.data[7] = 0x00;return msg;}void initDiagnosticHandlers_Vulnerable() {g_diagnosticHandlers_vulnerable[0] = diagHandler_ReadSensor_vulnerable;g_diagnosticHandlers_vulnerable[1] = diagHandler_ResetModule_vulnerable;g_diagnosticHandlers_vulnerable[2] = diagHandler_GetStatus_vulnerable;g_diagnosticHandlers_vulnerable[3] = diagHandler_ClearDTC_vulnerable;g_diagnosticHandlers_vulnerable[4] = diagHandler_PerformSelfTest_vulnerable;}void processDiagnosticCommand_Vulnerable() {CanMessage msg = receiveCanMessage_Vulnerable();if (msg.id == 0x7E1 && msg.dlc >= 4) {uint8_t mainCommandId = msg.data[0];uint8_t subCommandId = msg.data[1];uint16_t param1 = (uint16_t)msg.data[2];uint16_t param2 = (uint16_t)msg.data[3];if (mainCommandId == MAIN_CMD_DIAGNOSTIC_QUERY) {if (g_diagnosticHandlers_vulnerable[subCommandId] != NULL) {g_diagnosticHandlers_vulnerable[subCommandId](param1, param2);} else {logSecurityViolation(\"Diagnostic: Unregistered sub-command handler called (possibly invalid index).\");}} else {logSecurityViolation(\"Diagnostic: Unsupported main command ID received.\");}} else {logSecurityViolation(\"Diagnostic: Invalid CAN message format or ID.\");}}void vehicleDiagnosticModule_Vulnerable() {initDiagnosticHandlers_Vulnerable();processDiagnosticCommand_Vulnerable();}",
    "fixed_code": "#include <stdint.h>#include <stddef.h>typedef struct {uint32_t id;uint8_t data[8];uint8_t dlc;} CanMessage;#define MAX_SUB_COMMANDS 5#define MAIN_CMD_DIAGNOSTIC_QUERY 0x10typedef void (*DiagnosticHandler)(uint16_t param1, uint16_t param2);static DiagnosticHandler g_diagnosticHandlers_fixed[MAX_SUB_COMMANDS];void logSecurityViolation(const char* msg) {}void diagHandler_ReadSensor_fixed(uint16_t sensorId, uint16_t unused) {}void diagHandler_ResetModule_fixed(uint16_t moduleId, uint16_t unused) {}void diagHandler_GetStatus_fixed(uint16_t statusType, uint16_t unused) {}void diagHandler_ClearDTC_fixed(uint16_t dtcCode, uint16_t unused) {}void diagHandler_PerformSelfTest_fixed(uint16_t testId, uint16_t unused) {}CanMessage receiveCanMessage_Fixed() {CanMessage msg;msg.id = 0x7E1;msg.dlc = 8;msg.data[0] = MAIN_CMD_DIAGNOSTIC_QUERY;msg.data[1] = 5;msg.data[2] = 0x01;msg.data[3] = 0x02;msg.data[4] = 0x00;msg.data[5] = 0x00;msg.data[6] = 0x00;msg.data[7] = 0x00;return msg;}void initDiagnosticHandlers_Fixed() {g_diagnosticHandlers_fixed[0] = diagHandler_ReadSensor_fixed;g_diagnosticHandlers_fixed[1] = diagHandler_ResetModule_fixed;g_diagnosticHandlers_fixed[2] = diagHandler_GetStatus_fixed;g_diagnosticHandlers_fixed[3] = diagHandler_ClearDTC_fixed;g_diagnosticHandlers_fixed[4] = diagHandler_PerformSelfTest_fixed;}void processDiagnosticCommand_Fixed() {CanMessage msg = receiveCanMessage_Fixed();if (msg.id == 0x7E1 && msg.dlc >= 4) {uint8_t mainCommandId = msg.data[0];uint8_t subCommandId = msg.data[1];uint16_t param1 = (uint16_t)msg.data[2];uint16_t param2 = (uint16_t)msg.data[3];if (mainCommandId == MAIN_CMD_DIAGNOSTIC_QUERY) {if (subCommandId < MAX_SUB_COMMANDS) {if (g_diagnosticHandlers_fixed[subCommandId] != NULL) {g_diagnosticHandlers_fixed[subCommandId](param1, param2);} else {logSecurityViolation(\"Diagnostic: Requested sub-command handler is uninitialized for a valid index.\");}} else {logSecurityViolation(\"Diagnostic: Received out-of-bounds sub-command ID. Ignoring command.\");}} else {logSecurityViolation(\"Diagnostic: Unsupported main command ID received.\");}} else {logSecurityViolation(\"Diagnostic: Invalid CAN message format or ID.\");}}void vehicleDiagnosticModule_Fixed() {initDiagnosticHandlers_Fixed();processDiagnosticCommand_Fixed();}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_VEHICLE_EVENT_TYPES 5\n#define EVENT_PAYLOAD_SIZE 8\n\nvoid logSystemError(const char* msg) {\n}\n\ntypedef enum {\n    EVENT_TYPE_IGNITION_ON = 0,\n    EVENT_TYPE_GEAR_CHANGE,\n    EVENT_TYPE_DOOR_OPEN,\n    EVENT_TYPE_BRAKE_PEDAL,\n    EVENT_TYPE_ACCELERATOR_PEDAL\n} VehicleEventType;\n\ntypedef struct {\n    uint8_t eventType;\n    uint8_t payload[EVENT_PAYLOAD_SIZE];\n} VehicleEvent;\n\nvoid handleIgnitionOn(const uint8_t* payload) {\n}\n\nvoid handleGearChange(const uint8_t* payload) {\n}\n\nvoid handleDoorOpen(const uint8_t* payload) {\n}\n\nvoid handleBrakePedal(const uint8_t* payload) {\n}\n\nvoid handleAcceleratorPedal(const uint8_t* payload) {\n}\n\nvoid (*g_vulnerableEventHandlers[MAX_VEHICLE_EVENT_TYPES])(const uint8_t* payload) = {\n    handleIgnitionOn,\n    handleGearChange,\n    handleDoorOpen,\n    handleBrakePedal,\n    handleAcceleratorPedal\n};\n\nVehicleEvent getNextVehicleEvent_vulnerable() {\n    VehicleEvent event;\n    event.eventType = MAX_VEHICLE_EVENT_TYPES; \n    event.payload[0] = 0xFF;\n    for (int i = 1; i < EVENT_PAYLOAD_SIZE; ++i) {\n        event.payload[i] = 0;\n    }\n    return event;\n}\n\nvoid processVehicleEvent_vulnerable() {\n    VehicleEvent currentEvent = getNextVehicleEvent_vulnerable();\n\n    g_vulnerableEventHandlers[currentEvent.eventType](currentEvent.payload);\n}\n\nvoid automotiveECU_vulnerable_main() {\n    processVehicleEvent_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_VEHICLE_EVENT_TYPES 5\n#define EVENT_PAYLOAD_SIZE 8\n\nvoid logSystemError(const char* msg) {\n}\n\ntypedef enum {\n    EVENT_TYPE_IGNITION_ON = 0,\n    EVENT_TYPE_GEAR_CHANGE,\n    EVENT_TYPE_DOOR_OPEN,\n    EVENT_TYPE_BRAKE_PEDAL,\n    EVENT_TYPE_ACCELERATOR_PEDAL\n} VehicleEventType;\n\ntypedef struct {\n    uint8_t eventType;\n    uint8_t payload[EVENT_PAYLOAD_SIZE];\n} VehicleEvent;\n\nvoid handleIgnitionOn(const uint8_t* payload) {\n}\n\nvoid handleGearChange(const uint8_t* payload) {\n}\n\nvoid handleDoorOpen(const uint8_t* payload) {\n}\n\nvoid handleBrakePedal(const uint8_t* payload) {\n}\n\nvoid handleAcceleratorPedal(const uint8_t* payload) {\n}\n\nvoid (*g_fixedEventHandlers[MAX_VEHICLE_EVENT_TYPES])(const uint8_t* payload) = {\n    handleIgnitionOn,\n    handleGearChange,\n    handleDoorOpen,\n    handleBrakePedal,\n    handleAcceleratorPedal\n};\n\nVehicleEvent getNextVehicleEvent_fixed() {\n    VehicleEvent event;\n    event.eventType = MAX_VEHICLE_EVENT_TYPES; \n    event.payload[0] = 0xFF;\n    for (int i = 1; i < EVENT_PAYLOAD_SIZE; ++i) {\n        event.payload[i] = 0;\n    }\n    return event;\n}\n\nvoid processVehicleEvent_fixed() {\n    VehicleEvent currentEvent = getNextVehicleEvent_fixed();\n\n    if (currentEvent.eventType < MAX_VEHICLE_EVENT_TYPES) {\n        g_fixedEventHandlers[currentEvent.eventType](currentEvent.payload);\n    } else {\n        logSystemError(\"Received invalid vehicle event type. Index out of bounds.\");\n    }\n}\n\nvoid automotiveECU_fixed_main() {\n    processVehicleEvent_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_CONFIG_HISTORY 10\n\ntypedef struct {\n    uint32_t configId;\n    int32_t  paramA;\n    uint16_t paramB;\n} SensorConfiguration;\n\nstatic SensorConfiguration g_activeConfig;\nstatic SensorConfiguration g_configHistory[MAX_CONFIG_HISTORY];\nstatic int16_t g_latestConfigIdx = -1;\nstatic uint16_t g_numStoredConfigs = 0;\n\nvoid logSystemEvent(const char* msg) {\n    (void)msg;\n}\n\nvoid initializeConfigurationSystem() {\n    g_activeConfig = (SensorConfiguration){1001, 500, 100};\n    g_latestConfigIdx = 0;\n    g_configHistory[g_latestConfigIdx] = g_activeConfig;\n    g_numStoredConfigs = 1;\n    logSystemEvent(\"Configuration system initialized with default settings.\");\n}\n\nvoid applyAndStoreNewConfiguration(uint32_t newConfigId, int32_t newParamA, uint16_t newParamB) {\n    g_activeConfig = (SensorConfiguration){newConfigId, newParamA, newParamB};\n\n    g_latestConfigIdx = (g_latestConfigIdx + 1);\n    if (g_latestConfigIdx >= MAX_CONFIG_HISTORY) {\n        g_latestConfigIdx = 0;\n    }\n    g_configHistory[g_latestConfigIdx] = g_activeConfig;\n\n    if (g_numStoredConfigs < MAX_CONFIG_HISTORY) {\n        g_numStoredConfigs++;\n    }\n    logSystemEvent(\"New configuration applied and stored in history.\");\n}\n\nvoid revertConfigurationFromHistory_Vulnerable(int16_t steps_back) {\n    if (g_numStoredConfigs == 0) {\n        logSystemEvent(\"Cannot revert: Configuration history is empty.\");\n        return;\n    }\n\n    int16_t raw_target_idx = g_latestConfigIdx - steps_back;\n\n    g_activeConfig = g_configHistory[raw_target_idx];\n    logSystemEvent(\"Configuration reverted from history.\");\n}\n\nvoid vehicleConfigManager_Vulnerable() {\n    initializeConfigurationSystem();\n\n    applyAndStoreNewConfiguration(1002, 600, 110);\n\n    revertConfigurationFromHistory_Vulnerable(2);\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_CONFIG_HISTORY 10\n\ntypedef struct {\n    uint32_t configId;\n    int32_t  paramA;\n    uint16_t paramB;\n} SensorConfiguration;\n\nstatic SensorConfiguration g_activeConfig;\nstatic SensorConfiguration g_configHistory[MAX_CONFIG_HISTORY];\nstatic int16_t g_latestConfigIdx = -1;\nstatic uint16_t g_numStoredConfigs = 0;\n\nvoid logSystemEvent(const char* msg) {\n    (void)msg;\n}\n\nvoid initializeConfigurationSystem() {\n    g_activeConfig = (SensorConfiguration){1001, 500, 100};\n    g_latestConfigIdx = 0;\n    g_configHistory[g_latestConfigIdx] = g_activeConfig;\n    g_numStoredConfigs = 1;\n    logSystemEvent(\"Configuration system initialized with default settings.\");\n}\n\nvoid applyAndStoreNewConfiguration(uint32_t newConfigId, int32_t newParamA, uint16_t newParamB) {\n    g_activeConfig = (SensorConfiguration){newConfigId, newParamA, newParamB};\n\n    g_latestConfigIdx = (g_latestConfigIdx + 1);\n    if (g_latestConfigIdx >= MAX_CONFIG_HISTORY) {\n        g_latestConfigIdx = 0;\n    }\n    g_configHistory[g_latestConfigIdx] = g_activeConfig;\n\n    if (g_numStoredConfigs < MAX_CONFIG_HISTORY) {\n        g_numStoredConfigs++;\n    }\n    logSystemEvent(\"New configuration applied and stored in history.\");\n}\n\nvoid revertConfigurationFromHistory_Fixed(int16_t steps_back) {\n    if (g_numStoredConfigs == 0) {\n        logSystemEvent(\"Cannot revert: Configuration history is empty.\");\n        return;\n    }\n\n    if (steps_back < 0 || steps_back >= g_numStoredConfigs) {\n        logSystemEvent(\"Revert failed: Invalid number of steps back requested.\");\n        return;\n    }\n\n    int16_t target_history_idx = (g_latestConfigIdx - steps_back + MAX_CONFIG_HISTORY) % MAX_CONFIG_HISTORY;\n    \n    g_activeConfig = g_configHistory[target_history_idx];\n    logSystemEvent(\"Configuration reverted from history.\");\n}\n\nvoid vehicleConfigManager_Fixed() {\n    initializeConfigurationSystem();\n\n    applyAndStoreNewConfiguration(1002, 600, 110);\n\n    revertConfigurationFromHistory_Fixed(2);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n\n#define NUM_SENSOR_GROUPS 5\n#define MAX_PARAMETERS_PER_GROUP 10\n\ntypedef struct {\n    uint16_t parameter_values[MAX_PARAMETERS_PER_GROUP];\n    uint32_t last_update_timestamp;\n    uint8_t  status_flags;\n} SensorGroupData;\n\nstatic SensorGroupData g_sensorData_vulnerable[NUM_SENSOR_GROUPS];\n\ntypedef struct {\n    uint8_t  sensor_group_id;\n    uint8_t  parameter_index;\n    uint16_t new_value;\n} TelemetryUpdateCommand_vulnerable;\n\nvoid logTelemetryError_vulnerable(const char* msg) {\n}\n\nvoid initializeTelemetrySystem_vulnerable() {\n    for (int i = 0; i < NUM_SENSOR_GROUPS; ++i) {\n        for (int j = 0; j < MAX_PARAMETERS_PER_GROUP; ++j) {\n            g_sensorData_vulnerable[i].parameter_values[j] = 0;\n        }\n        g_sensorData_vulnerable[i].last_update_timestamp = 0;\n        g_sensorData_vulnerable[i].status_flags = 0;\n    }\n}\n\nTelemetryUpdateCommand_vulnerable receiveTelemetryCommand_vulnerable() {\n    TelemetryUpdateCommand_vulnerable cmd;\n    cmd.sensor_group_id = 0;\n    cmd.parameter_index = MAX_PARAMETERS_PER_GROUP; \n    cmd.new_value = 0xDEAD;\n    return cmd;\n}\n\nvoid processTelemetryUpdate_vulnerable() {\n    TelemetryUpdateCommand_vulnerable cmd = receiveTelemetryCommand_vulnerable();\n\n    if (cmd.sensor_group_id < NUM_SENSOR_GROUPS) {\n        g_sensorData_vulnerable[cmd.sensor_group_id].parameter_values[cmd.parameter_index] = cmd.new_value;\n        g_sensorData_vulnerable[cmd.sensor_group_id].last_update_timestamp = 12345; \n        logTelemetryError_vulnerable(\"Telemetry parameter updated.\");\n    } else {\n        logTelemetryError_vulnerable(\"Invalid sensor group ID received for telemetry update.\");\n    }\n}\n\nvoid telemetrySystemMain_vulnerable() {\n    initializeTelemetrySystem_vulnerable();\n    processTelemetryUpdate_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n\n#define NUM_SENSOR_GROUPS 5\n#define MAX_PARAMETERS_PER_GROUP 10\n\ntypedef struct {\n    uint16_t parameter_values[MAX_PARAMETERS_PER_GROUP];\n    uint32_t last_update_timestamp;\n    uint8_t  status_flags;\n} SensorGroupData;\n\nstatic SensorGroupData g_sensorData_fixed[NUM_SENSOR_GROUPS];\n\ntypedef struct {\n    uint8_t  sensor_group_id;\n    uint8_t  parameter_index;\n    uint16_t new_value;\n} TelemetryUpdateCommand_fixed;\n\nvoid logTelemetryError_fixed(const char* msg) {\n}\n\nvoid initializeTelemetrySystem_fixed() {\n    for (int i = 0; i < NUM_SENSOR_GROUPS; ++i) {\n        for (int j = 0; j < MAX_PARAMETERS_PER_GROUP; ++j) {\n            g_sensorData_fixed[i].parameter_values[j] = 0;\n        }\n        g_sensorData_fixed[i].last_update_timestamp = 0;\n        g_sensorData_fixed[i].status_flags = 0;\n    }\n}\n\nTelemetryUpdateCommand_fixed receiveTelemetryCommand_fixed() {\n    TelemetryUpdateCommand_fixed cmd;\n    cmd.sensor_group_id = 0;\n    cmd.parameter_index = MAX_PARAMETERS_PER_GROUP; \n    cmd.new_value = 0xDEAD;\n    return cmd;\n}\n\nvoid processTelemetryUpdate_fixed() {\n    TelemetryUpdateCommand_fixed cmd = receiveTelemetryCommand_fixed();\n\n    if (cmd.sensor_group_id < NUM_SENSOR_GROUPS) {\n        if (cmd.parameter_index < MAX_PARAMETERS_PER_GROUP) {\n            g_sensorData_fixed[cmd.sensor_group_id].parameter_values[cmd.parameter_index] = cmd.new_value;\n            g_sensorData_fixed[cmd.sensor_group_id].last_update_timestamp = 12345;\n            logTelemetryError_fixed(\"Telemetry parameter updated.\");\n        } else {\n            logTelemetryError_fixed(\"Invalid parameter index received for telemetry update. Ignoring.\");\n        }\n    } else {\n        logTelemetryError_fixed(\"Invalid sensor group ID received for telemetry update. Ignoring.\");\n    }\n}\n\nvoid telemetrySystemMain_fixed() {\n    initializeTelemetrySystem_fixed();\n    processTelemetryUpdate_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_SEATS 4\n#define MAX_SEAT_FEATURES 3\n\ntypedef enum {\n    SEAT_FEATURE_HEATING = 0,\n    SEAT_FEATURE_VENTILATION,\n    SEAT_FEATURE_MASSAGE,\n    SEAT_FEATURE_COUNT\n} SeatFeatureType;\n\ntypedef struct {\n    uint8_t current_level[MAX_SEAT_FEATURES];\n    bool    feature_enabled[MAX_SEAT_FEATURES];\n    uint16_t temperature_setting;\n} SeatControlUnit;\n\nstatic SeatControlUnit g_seatUnits[MAX_VEHICLE_SEATS];\n\nvoid logSeatControlError(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t seat_id;\n    uint8_t feature_id;\n    uint8_t new_level;\n    uint8_t command_type;\n} SeatCommand;\n\nSeatCommand receiveSeatCommand_vulnerable() {\n    SeatCommand cmd;\n    cmd.seat_id = 0;\n    cmd.feature_id = SEAT_FEATURE_COUNT; \n    cmd.new_level = 5;\n    cmd.command_type = 0x01;\n    return cmd;\n}\n\nvoid initializeSeatControl_vulnerable() {\n    for (int i = 0; i < MAX_VEHICLE_SEATS; ++i) {\n        for (int j = 0; j < MAX_SEAT_FEATURES; ++j) {\n            g_seatUnits[i].current_level[j] = 0;\n            g_seatUnits[i].feature_enabled[j] = false;\n        }\n        g_seatUnits[i].temperature_setting = 20;\n    }\n}\n\nvoid processSeatCommand_vulnerable() {\n    SeatCommand cmd = receiveSeatCommand_vulnerable();\n\n    if (cmd.seat_id < MAX_VEHICLE_SEATS) {\n        g_seatUnits[cmd.seat_id].current_level[cmd.feature_id] = cmd.new_level;\n    } else {\n        logSeatControlError(\"Invalid seat ID received. Command ignored.\");\n    }\n}\n\nvoid seatControlMain_vulnerable() {\n    initializeSeatControl_vulnerable();\n    processSeatCommand_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_SEATS 4\n#define MAX_SEAT_FEATURES 3\n\ntypedef enum {\n    SEAT_FEATURE_HEATING = 0,\n    SEAT_FEATURE_VENTILATION,\n    SEAT_FEATURE_MASSAGE,\n    SEAT_FEATURE_COUNT\n} SeatFeatureType;\n\ntypedef struct {\n    uint8_t current_level[MAX_SEAT_FEATURES];\n    bool    feature_enabled[MAX_SEAT_FEATURES];\n    uint16_t temperature_setting;\n} SeatControlUnit;\n\nstatic SeatControlUnit g_seatUnits_fixed[MAX_VEHICLE_SEATS];\n\nvoid logSeatControlError_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t seat_id;\n    uint8_t feature_id;\n    uint8_t new_level;\n    uint8_t command_type;\n} SeatCommand;\n\nSeatCommand receiveSeatCommand_fixed() {\n    SeatCommand cmd;\n    cmd.seat_id = 0;\n    cmd.feature_id = SEAT_FEATURE_COUNT;\n    cmd.new_level = 5;\n    cmd.command_type = 0x01;\n    return cmd;\n}\n\nvoid initializeSeatControl_fixed() {\n    for (int i = 0; i < MAX_VEHICLE_SEATS; ++i) {\n        for (int j = 0; j < MAX_SEAT_FEATURES; ++j) {\n            g_seatUnits_fixed[i].current_level[j] = 0;\n            g_seatUnits_fixed[i].feature_enabled[j] = false;\n        }\n        g_seatUnits_fixed[i].temperature_setting = 20;\n    }\n}\n\nvoid processSeatCommand_fixed() {\n    SeatCommand cmd = receiveSeatCommand_fixed();\n\n    if (cmd.seat_id < MAX_VEHICLE_SEATS) {\n        if (cmd.feature_id < SEAT_FEATURE_COUNT) {\n            g_seatUnits_fixed[cmd.seat_id].current_level[cmd.feature_id] = cmd.new_level;\n        } else {\n            logSeatControlError_fixed(\"Invalid feature ID received. Command ignored.\");\n        }\n    } else {\n        logSeatControlError_fixed(\"Invalid seat ID received. Command ignored.\");\n    }\n}\n\nvoid seatControlMain_fixed() {\n    initializeSeatControl_fixed();\n    processSeatCommand_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_SENSOR_DATA_ENTRIES 20\n#define MAX_CALIBRATION_CURVE_POINTS 15\n#define MAX_EVENT_LOG_ENTRIES 10\n\ntypedef struct {\n    uint16_t value_raw;\n    int16_t  value_processed;\n    uint8_t  sensor_status;\n} SensorDataType;\n\ntypedef struct {\n    float    coeff_a;\n    float    coeff_b;\n    uint32_t revision_id;\n} CalibrationCurvePointType;\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp;\n    uint8_t  severity_level;\n} EventLogEntryType;\n\nstatic SensorDataType g_sensorDataTable_vulnerable[MAX_SENSOR_DATA_ENTRIES];\nstatic CalibrationCurvePointType g_calibrationCurveTable_vulnerable[MAX_CALIBRATION_CURVE_POINTS];\nstatic EventLogEntryType g_eventLogTable_vulnerable[MAX_EVENT_LOG_ENTRIES];\n\ntypedef enum {\n    DATA_TYPE_SENSOR = 0,\n    DATA_TYPE_CALIBRATION,\n    DATA_TYPE_EVENT_LOG,\n    DATA_TYPE_COUNT\n} DataTypeId;\n\ntypedef struct {\n    DataTypeId data_type_id;\n    uint8_t    index;\n    uint32_t   update_value;\n} DataUpdateCommand;\n\nvoid automotiveSystemLog_vulnerable(const char* message) {\n}\n\nDataUpdateCommand receiveDataUpdateCommand_vulnerable() {\n    DataUpdateCommand cmd;\n    cmd.data_type_id = DATA_TYPE_CALIBRATION;\n    cmd.index = MAX_CALIBRATION_CURVE_POINTS; \n    cmd.update_value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeDataTables_vulnerable() {\n    for (int i = 0; i < MAX_SENSOR_DATA_ENTRIES; ++i) {\n        g_sensorDataTable_vulnerable[i] = (SensorDataType){0, 0, 0};\n    }\n    for (int i = 0; i < MAX_CALIBRATION_CURVE_POINTS; ++i) {\n        g_calibrationCurveTable_vulnerable[i] = (CalibrationCurvePointType){0.0f, 0.0f, 0};\n    }\n    for (int i = 0; i < MAX_EVENT_LOG_ENTRIES; ++i) {\n        g_eventLogTable_vulnerable[i] = (EventLogEntryType){0, 0, 0};\n    }\n}\n\nvoid processDataUpdateCommand_vulnerable() {\n    DataUpdateCommand cmd = receiveDataUpdateCommand_vulnerable();\n\n    switch (cmd.data_type_id) {\n        case DATA_TYPE_SENSOR:\n            g_sensorDataTable_vulnerable[cmd.index].sensor_status = (uint8_t)cmd.update_value;\n            automotiveSystemLog_vulnerable(\"Sensor data update attempted.\");\n            break;\n        case DATA_TYPE_CALIBRATION:\n            g_calibrationCurveTable_vulnerable[cmd.index].coeff_a = *(float*)&cmd.update_value;\n            automotiveSystemLog_vulnerable(\"Calibration curve point update attempted.\");\n            break;\n        case DATA_TYPE_EVENT_LOG:\n            g_eventLogTable_vulnerable[cmd.index].event_id = (uint16_t)cmd.update_value;\n            automotiveSystemLog_vulnerable(\"Event log entry update attempted.\");\n            break;\n        default:\n            automotiveSystemLog_vulnerable(\"Received command with invalid data type ID.\");\n            break;\n    }\n}\n\nvoid vehicleControlUnitMain_vulnerable() {\n    initializeDataTables_vulnerable();\n    processDataUpdateCommand_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_SENSOR_DATA_ENTRIES 20\n#define MAX_CALIBRATION_CURVE_POINTS 15\n#define MAX_EVENT_LOG_ENTRIES 10\n\ntypedef struct {\n    uint16_t value_raw;\n    int16_t  value_processed;\n    uint8_t  sensor_status;\n} SensorDataType;\n\ntypedef struct {\n    float    coeff_a;\n    float    coeff_b;\n    uint32_t revision_id;\n} CalibrationCurvePointType;\n\ntypedef struct {\n    uint16_t event_id;\n    uint32_t timestamp;\n    uint8_t  severity_level;\n} EventLogEntryType;\n\nstatic SensorDataType g_sensorDataTable_fixed[MAX_SENSOR_DATA_ENTRIES];\nstatic CalibrationCurvePointType g_calibrationCurveTable_fixed[MAX_CALIBRATION_CURVE_POINTS];\nstatic EventLogEntryType g_eventLogTable_fixed[MAX_EVENT_LOG_ENTRIES];\n\ntypedef enum {\n    DATA_TYPE_SENSOR = 0,\n    DATA_TYPE_CALIBRATION,\n    DATA_TYPE_EVENT_LOG,\n    DATA_TYPE_COUNT\n} DataTypeId;\n\ntypedef struct {\n    DataTypeId data_type_id;\n    uint8_t    index;\n    uint32_t   update_value;\n} DataUpdateCommand;\n\nvoid automotiveSystemLog_fixed(const char* message) {\n}\n\nDataUpdateCommand receiveDataUpdateCommand_fixed() {\n    DataUpdateCommand cmd;\n    cmd.data_type_id = DATA_TYPE_CALIBRATION;\n    cmd.index = MAX_CALIBRATION_CURVE_POINTS; \n    cmd.update_value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeDataTables_fixed() {\n    for (int i = 0; i < MAX_SENSOR_DATA_ENTRIES; ++i) {\n        g_sensorDataTable_fixed[i] = (SensorDataType){0, 0, 0};\n    }\n    for (int i = 0; i < MAX_CALIBRATION_CURVE_POINTS; ++i) {\n        g_calibrationCurveTable_fixed[i] = (CalibrationCurvePointType){0.0f, 0.0f, 0};\n    }\n    for (int i = 0; i < MAX_EVENT_LOG_ENTRIES; ++i) {\n        g_eventLogTable_fixed[i] = (EventLogEntryType){0, 0, 0};\n    }\n}\n\nvoid processDataUpdateCommand_fixed() {\n    DataUpdateCommand cmd = receiveDataUpdateCommand_fixed();\n\n    if (cmd.data_type_id < DATA_TYPE_COUNT) {\n        switch (cmd.data_type_id) {\n            case DATA_TYPE_SENSOR:\n                if (cmd.index < MAX_SENSOR_DATA_ENTRIES) {\n                    g_sensorDataTable_fixed[cmd.index].sensor_status = (uint8_t)cmd.update_value;\n                    automotiveSystemLog_fixed(\"Sensor data updated successfully.\");\n                } else {\n                    automotiveSystemLog_fixed(\"Out-of-bounds index for sensor data. Command ignored.\");\n                }\n                break;\n            case DATA_TYPE_CALIBRATION:\n                if (cmd.index < MAX_CALIBRATION_CURVE_POINTS) {\n                    g_calibrationCurveTable_fixed[cmd.index].coeff_a = *(float*)&cmd.update_value;\n                    automotiveSystemLog_fixed(\"Calibration curve point updated successfully.\");\n                } else {\n                    automotiveSystemLog_fixed(\"Out-of-bounds index for calibration data. Command ignored.\");\n                }\n                break;\n            case DATA_TYPE_EVENT_LOG:\n                if (cmd.index < MAX_EVENT_LOG_ENTRIES) {\n                    g_eventLogTable_fixed[cmd.index].event_id = (uint16_t)cmd.update_value;\n                    automotiveSystemLog_fixed(\"Event log entry updated successfully.\");\n                } else {\n                    automotiveSystemLog_fixed(\"Out-of-bounds index for event log. Command ignored.\");\n                }\n                break;\n            default:\n                automotiveSystemLog_fixed(\"Internal error: Unhandled data type ID in switch.\");\n                break;\n        }\n    } else {\n        automotiveSystemLog_fixed(\"Received command with invalid data type ID.\");\n    }\n}\n\nvoid vehicleControlUnitMain_fixed() {\n    initializeDataTables_fixed();\n    processDataUpdateCommand_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n\ntypedef enum {\n    MODE_PARK = 0,\n    MODE_DRIVE,\n    MODE_REVERSE,\n    MODE_NEUTRAL,\n    NUM_VEHICLE_MODES\n} VehicleMode;\n\ntypedef enum {\n    INPUT_SHIFT_P = 0,\n    INPUT_SHIFT_D,\n    INPUT_SHIFT_R,\n    INPUT_SHIFT_N,\n    INPUT_ACCEL,\n    INPUT_BRAKE,\n    INPUT_CRUISE_ON,\n    INPUT_CRUISE_OFF,\n    NUM_VEHICLE_INPUTS\n} VehicleInput;\n\nvoid logSystemError(const char* msg) {\n}\n\nstatic VehicleMode g_currentVehicleMode = MODE_PARK;\n\nstatic const VehicleMode g_transition_table[NUM_VEHICLE_MODES][NUM_VEHICLE_INPUTS] = {\n    { MODE_PARK, MODE_DRIVE, MODE_REVERSE, MODE_NEUTRAL, MODE_PARK, MODE_PARK, MODE_PARK, MODE_PARK },\n    { MODE_PARK, MODE_DRIVE, MODE_DRIVE,   MODE_NEUTRAL, MODE_DRIVE,MODE_DRIVE,MODE_DRIVE,MODE_DRIVE },\n    { MODE_PARK, MODE_REVERSE, MODE_REVERSE, MODE_NEUTRAL, MODE_REVERSE,MODE_REVERSE,MODE_REVERSE,MODE_REVERSE },\n    { MODE_PARK, MODE_DRIVE, MODE_REVERSE, MODE_NEUTRAL, MODE_NEUTRAL,MODE_NEUTRAL,MODE_NEUTRAL,MODE_NEUTRAL }\n};\n\nVehicleInput receiveSimulatedInputEvent_vulnerable() {\n    return (VehicleInput)NUM_VEHICLE_INPUTS;\n}\n\nvoid processVehicleInput_vulnerable() {\n    VehicleInput inputEvent = receiveSimulatedInputEvent_vulnerable();\n    VehicleMode newMode = g_currentVehicleMode;\n\n    newMode = g_transition_table[g_currentVehicleMode][inputEvent];\n\n    g_currentVehicleMode = newMode;\n}\n\nvoid vehicleStateManager_vulnerable_main() {\n    g_currentVehicleMode = MODE_PARK;\n    processVehicleInput_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n\ntypedef enum {\n    MODE_PARK = 0,\n    MODE_DRIVE,\n    MODE_REVERSE,\n    MODE_NEUTRAL,\n    NUM_VEHICLE_MODES\n} VehicleMode;\n\ntypedef enum {\n    INPUT_SHIFT_P = 0,\n    INPUT_SHIFT_D,\n    INPUT_SHIFT_R,\n    INPUT_SHIFT_N,\n    INPUT_ACCEL,\n    INPUT_BRAKE,\n    INPUT_CRUISE_ON,\n    INPUT_CRUISE_OFF,\n    NUM_VEHICLE_INPUTS\n} VehicleInput;\n\nvoid logSystemError(const char* msg) {\n}\n\nstatic VehicleMode g_currentVehicleMode = MODE_PARK;\n\nstatic const VehicleMode g_transition_table[NUM_VEHICLE_MODES][NUM_VEHICLE_INPUTS] = {\n    { MODE_PARK, MODE_DRIVE, MODE_REVERSE, MODE_NEUTRAL, MODE_PARK, MODE_PARK, MODE_PARK, MODE_PARK },\n    { MODE_PARK, MODE_DRIVE, MODE_DRIVE,   MODE_NEUTRAL, MODE_DRIVE,MODE_DRIVE,MODE_DRIVE,MODE_DRIVE },\n    { MODE_PARK, MODE_REVERSE, MODE_REVERSE, MODE_NEUTRAL, MODE_REVERSE,MODE_REVERSE,MODE_REVERSE,MODE_REVERSE },\n    { MODE_PARK, MODE_DRIVE, MODE_REVERSE, MODE_NEUTRAL, MODE_NEUTRAL,MODE_NEUTRAL,MODE_NEUTRAL,MODE_NEUTRAL }\n};\n\nVehicleInput receiveSimulatedInputEvent_fixed() {\n    return (VehicleInput)NUM_VEHICLE_INPUTS;\n}\n\nvoid processVehicleInput_fixed() {\n    VehicleInput inputEvent = receiveSimulatedInputEvent_fixed();\n    VehicleMode newMode = g_currentVehicleMode;\n\n    if (inputEvent >= 0 && inputEvent < NUM_VEHICLE_INPUTS) {\n        newMode = g_transition_table[g_currentVehicleMode][inputEvent];\n    } else {\n        logSystemError(\"Invalid vehicle input event received. Ignoring transition.\");\n        newMode = g_currentVehicleMode;\n    }\n\n    g_currentVehicleMode = newMode;\n}\n\nvoid vehicleStateManager_fixed_main() {\n    g_currentVehicleMode = MODE_PARK;\n    processVehicleInput_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_DIAGNOSTIC_DOMAINS 3\n#define MAX_DTCS_PER_DOMAIN_GLOBAL 20\n\ntypedef enum {\n    DOMAIN_POWERTRAIN = 0,\n    DOMAIN_CHASSIS,\n    DOMAIN_INFOTAINMENT,\n    DOMAIN_COUNT\n} DiagnosticDomainId;\n\ntypedef struct {\n    bool active;\n    bool pending;\n    bool history;\n    uint8_t failure_count;\n} DtcStatus;\n\nstatic DtcStatus g_domainDtcStatuses[MAX_DIAGNOSTIC_DOMAINS][MAX_DTCS_PER_DOMAIN_GLOBAL];\n\nstatic const uint8_t g_actualDtcCountsPerDomain[MAX_DIAGNOSTIC_DOMAINS] = {\n    10,\n    15,\n    5\n};\n\ntypedef struct {\n    DiagnosticDomainId domain_id;\n    uint8_t dtc_index;\n    uint8_t command_type;\n} DiagnosticCommand;\n\nvoid logDiagnosticEvent(const char* msg) {\n}\n\nDiagnosticCommand receiveDiagnosticCommand_vulnerable() {\n    DiagnosticCommand cmd;\n    cmd.domain_id = DOMAIN_POWERTRAIN;\n    cmd.dtc_index = 12;\n    cmd.command_type = 0x01;\n    return cmd;\n}\n\nvoid initializeDtcStatuses_vulnerable() {\n    for (uint8_t i = 0; i < MAX_DIAGNOSTIC_DOMAINS; ++i) {\n        for (uint8_t j = 0; j < MAX_DTCS_PER_DOMAIN_GLOBAL; ++j) {\n            g_domainDtcStatuses[i][j] = (DtcStatus){false, false, false, 0};\n        }\n    }\n}\n\nvoid processDiagnosticCommand_vulnerable() {\n    DiagnosticCommand cmd = receiveDiagnosticCommand_vulnerable();\n\n    if (cmd.domain_id < DOMAIN_COUNT) {\n        if (cmd.dtc_index < MAX_DTCS_PER_DOMAIN_GLOBAL) {\n            switch (cmd.command_type) {\n                case 0x01:\n                    g_domainDtcStatuses[cmd.domain_id][cmd.dtc_index].active = false;\n                    logDiagnosticEvent(\"DTC active flag cleared.\");\n                    break;\n                case 0x02:\n                    g_domainDtcStatuses[cmd.domain_id][cmd.dtc_index].pending = false;\n                    logDiagnosticEvent(\"DTC pending flag cleared.\");\n                    break;\n                default:\n                    logDiagnosticEvent(\"Unknown diagnostic command type received.\");\n                    break;\n            }\n        } else {\n            logDiagnosticEvent(\"Diagnostic command with out-of-bounds DTC index (global max) received. Ignoring.\");\n        }\n    } else {\n        logDiagnosticEvent(\"Diagnostic command with invalid domain ID received. Ignoring.\");\n    }\n}\n\nvoid ecuDiagnosticManager_vulnerable() {\n    initializeDtcStatuses_vulnerable();\n    processDiagnosticCommand_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_DIAGNOSTIC_DOMAINS 3\n#define MAX_DTCS_PER_DOMAIN_GLOBAL 20\n\ntypedef enum {\n    DOMAIN_POWERTRAIN = 0,\n    DOMAIN_CHASSIS,\n    DOMAIN_INFOTAINMENT,\n    DOMAIN_COUNT\n} DiagnosticDomainId;\n\ntypedef struct {\n    bool active;\n    bool pending;\n    bool history;\n    uint8_t failure_count;\n} DtcStatus;\n\nstatic DtcStatus g_domainDtcStatuses[MAX_DIAGNOSTIC_DOMAINS][MAX_DTCS_PER_DOMAIN_GLOBAL];\n\nstatic const uint8_t g_actualDtcCountsPerDomain[MAX_DIAGNOSTIC_DOMAINS] = {\n    10,\n    15,\n    5\n};\n\ntypedef struct {\n    DiagnosticDomainId domain_id;\n    uint8_t dtc_index;\n    uint8_t command_type;\n} DiagnosticCommand;\n\nvoid logDiagnosticEvent(const char* msg) {\n}\n\nDiagnosticCommand receiveDiagnosticCommand_fixed() {\n    DiagnosticCommand cmd;\n    cmd.domain_id = DOMAIN_POWERTRAIN;\n    cmd.dtc_index = 12;\n    cmd.command_type = 0x01;\n    return cmd;\n}\n\nvoid initializeDtcStatuses_fixed() {\n    for (uint8_t i = 0; i < MAX_DIAGNOSTIC_DOMAINS; ++i) {\n        for (uint8_t j = 0; j < MAX_DTCS_PER_DOMAIN_GLOBAL; ++j) {\n            g_domainDtcStatuses[i][j] = (DtcStatus){false, false, false, 0};\n        }\n    }\n}\n\nvoid processDiagnosticCommand_fixed() {\n    DiagnosticCommand cmd = receiveDiagnosticCommand_fixed();\n\n    if (cmd.domain_id < DOMAIN_COUNT) {\n        if (cmd.dtc_index < g_actualDtcCountsPerDomain[cmd.domain_id]) {\n            switch (cmd.command_type) {\n                case 0x01:\n                    g_domainDtcStatuses[cmd.domain_id][cmd.dtc_index].active = false;\n                    logDiagnosticEvent(\"DTC active flag cleared.\");\n                    break;\n                case 0x02:\n                    g_domainDtcStatuses[cmd.domain_id][cmd.dtc_index].pending = false;\n                    logDiagnosticEvent(\"DTC pending flag cleared.\");\n                    break;\n                default:\n                    logDiagnosticEvent(\"Unknown diagnostic command type received.\");\n                    break;\n            }\n        } else {\n            logDiagnosticEvent(\"Diagnostic command with out-of-bounds DTC index for specific domain. Ignoring.\");\n        }\n    } else {\n        logDiagnosticEvent(\"Diagnostic command with invalid domain ID received. Ignoring.\");\n    }\n}\n\nvoid ecuDiagnosticManager_fixed() {\n    initializeDtcStatuses_fixed();\n    processDiagnosticCommand_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_STORED_DTCS 50\n\ntypedef enum {\n    DTC_STATUS_INACTIVE = 0,\n    DTC_STATUS_ACTIVE,\n    DTC_STATUS_CONFIRMED,\n    DTC_STATUS_PENDING\n} DtcStatus;\n\ntypedef struct {\n    uint16_t  dtc_code;\n    DtcStatus status;\n    uint8_t   occurrence_count;\n    uint32_t  first_occurrence_timestamp;\n} DtcEntry;\n\nstatic DtcEntry g_dtcStatusTable_vulnerable[MAX_STORED_DTCS];\n\nvoid logDTCSystemError_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t dtc_logical_index;\n    uint8_t new_status_value;\n    uint16_t reserved;\n} DiagnosticRequestFrame;\n\nDiagnosticRequestFrame receiveDiagnosticRequest_vulnerable() {\n    DiagnosticRequestFrame req;\n    req.command_id = 0x01;\n    req.dtc_logical_index = MAX_STORED_DTCS;\n    req.new_status_value = DTC_STATUS_CONFIRMED;\n    req.reserved = 0;\n    return req;\n}\n\nvoid initializeDTCSystem_vulnerable() {\n    for (int i = 0; i < MAX_STORED_DTCS; ++i) {\n        g_dtcStatusTable_vulnerable[i].dtc_code = 0x0000;\n        g_dtcStatusTable_vulnerable[i].status = DTC_STATUS_INACTIVE;\n        g_dtcStatusTable_vulnerable[i].occurrence_count = 0;\n        g_dtcStatusTable_vulnerable[i].first_occurrence_timestamp = 0;\n    }\n    g_dtcStatusTable_vulnerable[0].dtc_code = 0x1234;\n    g_dtcStatusTable_vulnerable[1].dtc_code = 0x5678;\n    g_dtcStatusTable_vulnerable[2].dtc_code = 0x9ABC;\n}\n\nvoid processDiagnosticRequest_vulnerable() {\n    DiagnosticRequestFrame request = receiveDiagnosticRequest_vulnerable();\n\n    if (request.command_id == 0x01) {\n        g_dtcStatusTable_vulnerable[request.dtc_logical_index].status = (DtcStatus)request.new_status_value;\n        g_dtcStatusTable_vulnerable[request.dtc_logical_index].occurrence_count++;\n        logDTCSystemError_vulnerable(\"DTC status update processed (vulnerable).\");\n    } else {\n        logDTCSystemError_vulnerable(\"Unknown diagnostic command received (vulnerable).\");\n    }\n}\n\nvoid dtcManagerMain_vulnerable() {\n    initializeDTCSystem_vulnerable();\n    processDiagnosticRequest_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_STORED_DTCS 50\n\ntypedef enum {\n    DTC_STATUS_INACTIVE = 0,\n    DTC_STATUS_ACTIVE,\n    DTC_STATUS_CONFIRMED,\n    DTC_STATUS_PENDING,\n    DTC_STATUS_COUNT\n} DtcStatus;\n\ntypedef struct {\n    uint16_t  dtc_code;\n    DtcStatus status;\n    uint8_t   occurrence_count;\n    uint32_t  first_occurrence_timestamp;\n} DtcEntry;\n\nstatic DtcEntry g_dtcStatusTable_fixed[MAX_STORED_DTCS];\n\nvoid logDTCSystemError_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t dtc_logical_index;\n    uint8_t new_status_value;\n    uint16_t reserved;\n} DiagnosticRequestFrame;\n\nDiagnosticRequestFrame receiveDiagnosticRequest_fixed() {\n    DiagnosticRequestFrame req;\n    req.command_id = 0x01;\n    req.dtc_logical_index = MAX_STORED_DTCS;\n    req.new_status_value = DTC_STATUS_CONFIRMED;\n    req.reserved = 0;\n    return req;\n}\n\nvoid initializeDTCSystem_fixed() {\n    for (int i = 0; i < MAX_STORED_DTCS; ++i) {\n        g_dtcStatusTable_fixed[i].dtc_code = 0x0000;\n        g_dtcStatusTable_fixed[i].status = DTC_STATUS_INACTIVE;\n        g_dtcStatusTable_fixed[i].occurrence_count = 0;\n        g_dtcStatusTable_fixed[i].first_occurrence_timestamp = 0;\n    }\n    g_dtcStatusTable_fixed[0].dtc_code = 0x1234;\n    g_dtcStatusTable_fixed[1].dtc_code = 0x5678;\n    g_dtcStatusTable_fixed[2].dtc_code = 0x9ABC;\n}\n\nvoid processDiagnosticRequest_fixed() {\n    DiagnosticRequestFrame request = receiveDiagnosticRequest_fixed();\n\n    if (request.command_id == 0x01) {\n        if (request.dtc_logical_index < MAX_STORED_DTCS) {\n            if (request.new_status_value < DTC_STATUS_COUNT) {\n                g_dtcStatusTable_fixed[request.dtc_logical_index].status = (DtcStatus)request.new_status_value;\n                g_dtcStatusTable_fixed[request.dtc_logical_index].occurrence_count++;\n                logDTCSystemError_fixed(\"DTC status update processed successfully.\");\n            } else {\n                logDTCSystemError_fixed(\"Invalid new DTC status value received (fixed).\");\n            }\n        } else {\n            logDTCSystemError_fixed(\"DTC logical index out of bounds. Command ignored (fixed).\");\n        }\n    } else {\n        logDTCSystemError_fixed(\"Unknown diagnostic command received (fixed).\");\n    }\n}\n\nvoid dtcManagerMain_fixed() {\n    initializeDTCSystem_fixed();\n    processDiagnosticRequest_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_MESSAGE_TYPE_HANDLERS 10\n#define MESSAGE_DATA_SIZE 64\n\nvoid log_warning(const char* msg) {}\nvoid log_error(const char* msg) {}\n\ntypedef struct {\n    uint16_t message_id;\n    uint8_t  message_type;\n    uint8_t  sequence_num;\n    uint32_t timestamp;\n    uint8_t  data[MESSAGE_DATA_SIZE];\n    uint16_t data_len;\n} VehicleMessage;\n\ntypedef void (*MessageHandler)(const VehicleMessage*);\nstatic MessageHandler g_message_handlers_vulnerable[MAX_MESSAGE_TYPE_HANDLERS];\n\nvoid handle_engine_status(const VehicleMessage* msg) {\n    log_warning(\"Processing Engine Status message.\");\n}\n\nvoid handle_brake_status(const VehicleMessage* msg) {\n    log_warning(\"Processing Brake Status message.\");\n}\n\nvoid handle_door_status(const VehicleMessage* msg) {\n    log_warning(\"Processing Door Status message.\");\n}\n\nvoid handle_tire_pressure(const VehicleMessage* msg) {\n    log_warning(\"Processing Tire Pressure message.\");\n}\n\nvoid handle_undefined_message(const VehicleMessage* msg) {\n    log_warning(\"Processing Undefined/Reserved Message Type.\");\n}\n\nVehicleMessage receive_vehicle_message_vulnerable() {\n    VehicleMessage msg;\n    msg.message_type = MAX_MESSAGE_TYPE_HANDLERS; \n    msg.message_id = 0x1234;\n    msg.sequence_num = 1;\n    msg.timestamp = 0;\n    msg.data_len = 0;\n    return msg;\n}\n\nvoid init_message_handlers_vulnerable() {\n    g_message_handlers_vulnerable[0] = handle_engine_status;\n    g_message_handlers_vulnerable[1] = handle_brake_status;\n    g_message_handlers_vulnerable[2] = handle_door_status;\n    g_message_handlers_vulnerable[3] = handle_tire_pressure;\n    for (int i = 4; i < MAX_MESSAGE_TYPE_HANDLERS; ++i) {\n        g_message_handlers_vulnerable[i] = handle_undefined_message;\n    }\n}\n\nvoid process_incoming_vehicle_messages_vulnerable() {\n    VehicleMessage msg = receive_vehicle_message_vulnerable();\n    g_message_handlers_vulnerable[msg.message_type](&msg);\n}\n\nvoid vehicle_gateway_main_vulnerable() {\n    init_message_handlers_vulnerable();\n    process_incoming_vehicle_messages_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_MESSAGE_TYPE_HANDLERS 10\n#define MESSAGE_DATA_SIZE 64\n\nvoid log_warning(const char* msg) {}\nvoid log_error(const char* msg) {}\n\ntypedef struct {\n    uint16_t message_id;\n    uint8_t  message_type;\n    uint8_t  sequence_num;\n    uint32_t timestamp;\n    uint8_t  data[MESSAGE_DATA_SIZE];\n    uint16_t data_len;\n} VehicleMessage;\n\ntypedef void (*MessageHandler)(const VehicleMessage*);\nstatic MessageHandler g_message_handlers_fixed[MAX_MESSAGE_TYPE_HANDLERS];\n\nvoid handle_engine_status(const VehicleMessage* msg) {\n    log_warning(\"Processing Engine Status message.\");\n}\n\nvoid handle_brake_status(const VehicleMessage* msg) {\n    log_warning(\"Processing Brake Status message.\");\n}\n\nvoid handle_door_status(const VehicleMessage* msg) {\n    log_warning(\"Processing Door Status message.\");\n}\n\nvoid handle_tire_pressure(const VehicleMessage* msg) {\n    log_warning(\"Processing Tire Pressure message.\");\n}\n\nvoid handle_undefined_message(const VehicleMessage* msg) {\n    log_warning(\"Processing Undefined/Reserved Message Type.\");\n}\n\nvoid handle_invalid_message_type(const VehicleMessage* msg) {\n    log_error(\"Received message with invalid type. Index out of bounds.\");\n}\n\nVehicleMessage receive_vehicle_message_fixed() {\n    VehicleMessage msg;\n    msg.message_type = MAX_MESSAGE_TYPE_HANDLERS; \n    msg.message_id = 0x1234;\n    msg.sequence_num = 1;\n    msg.timestamp = 0;\n    msg.data_len = 0;\n    return msg;\n}\n\nvoid init_message_handlers_fixed() {\n    g_message_handlers_fixed[0] = handle_engine_status;\n    g_message_handlers_fixed[1] = handle_brake_status;\n    g_message_handlers_fixed[2] = handle_door_status;\n    g_message_handlers_fixed[3] = handle_tire_pressure;\n    for (int i = 4; i < MAX_MESSAGE_TYPE_HANDLERS; ++i) {\n        g_message_handlers_fixed[i] = handle_undefined_message;\n    }\n}\n\nvoid process_incoming_vehicle_messages_fixed() {\n    VehicleMessage msg = receive_vehicle_message_fixed();\n\n    if (msg.message_type < MAX_MESSAGE_TYPE_HANDLERS) {\n        g_message_handlers_fixed[msg.message_type](&msg);\n    } else {\n        handle_invalid_message_type(&msg);\n    }\n}\n\nvoid vehicle_gateway_main_fixed() {\n    init_message_handlers_fixed();\n    process_incoming_vehicle_messages_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#define MAX_DRIVER_PROFILES 3\n\ntypedef struct {\n    uint16_t throttle_response_map_id;\n    uint8_t  regen_braking_level;\n} PowertrainSettings;\n\ntypedef struct {\n    uint16_t damping_force_preset_id;\n    uint16_t ride_height_offset_mm;\n} SuspensionSettings;\n\ntypedef struct {\n    uint8_t  steering_assist_level;\n    bool     lane_keeping_active;\n} SteeringSettings;\n\ntypedef struct {\n    PowertrainSettings* powertrain_config;\n    SuspensionSettings* suspension_config;\n    SteeringSettings*   steering_config;\n} DriverProfileConfig;\n\nstatic PowertrainSettings g_powertrainProfiles_vulnerable[MAX_DRIVER_PROFILES];\nstatic SuspensionSettings g_suspensionProfiles_vulnerable[MAX_DRIVER_PROFILES];\nstatic SteeringSettings   g_steeringProfiles_vulnerable[MAX_DRIVER_PROFILES];\n\nstatic DriverProfileConfig g_driverProfileConfigs_vulnerable[MAX_DRIVER_PROFILES];\n\nstatic uint8_t g_activeProfileIndex_vulnerable;\n\nvoid automotiveLog_vulnerable(const char* message) {}\n\nuint8_t receiveProfileSelectionCommand_vulnerable() {\n    return MAX_DRIVER_PROFILES;\n}\n\nvoid initializeVehicleProfiles_vulnerable() {\n    g_powertrainProfiles_vulnerable[0] = (PowertrainSettings){100, 3};\n    g_powertrainProfiles_vulnerable[1] = (PowertrainSettings){200, 1};\n    g_powertrainProfiles_vulnerable[2] = (PowertrainSettings){150, 2};\n\n    g_suspensionProfiles_vulnerable[0] = (SuspensionSettings){1, 0};\n    g_suspensionProfiles_vulnerable[1] = (SuspensionSettings){3, -10};\n    g_suspensionProfiles_vulnerable[2] = (SuspensionSettings){2, 5};\n\n    g_steeringProfiles_vulnerable[0] = (SteeringSettings){1, true};\n    g_steeringProfiles_vulnerable[1] = (SteeringSettings){3, false};\n    g_steeringProfiles_vulnerable[2] = (SteeringSettings){2, true};\n\n    for (uint8_t i = 0; i < MAX_DRIVER_PROFILES; ++i) {\n        g_driverProfileConfigs_vulnerable[i].powertrain_config = &g_powertrainProfiles_vulnerable[i];\n        g_driverProfileConfigs_vulnerable[i].suspension_config = &g_suspensionProfiles_vulnerable[i];\n        g_driverProfileConfigs_vulnerable[i].steering_config = &g_steeringProfiles_vulnerable[i];\n    }\n\n    g_activeProfileIndex_vulnerable = 0;\n}\n\nvoid setActiveDriverProfile_vulnerable(uint8_t profile_id) {\n    g_activeProfileIndex_vulnerable = profile_id;\n    automotiveLog_vulnerable(\"Driver profile selection attempted (vulnerable).\");\n}\n\nvoid applyActiveProfileToECUs_vulnerable() {\n    PowertrainSettings* current_pt_config = g_driverProfileConfigs_vulnerable[g_activeProfileIndex_vulnerable].powertrain_config;\n    SuspensionSettings* current_susp_config = g_driverProfileConfigs_vulnerable[g_activeProfileIndex_vulnerable].suspension_config;\n    SteeringSettings*   current_steer_config = g_driverProfileConfigs_vulnerable[g_activeProfileIndex_vulnerable].steering_config;\n\n    if (current_pt_config != NULL) {\n        automotiveLog_vulnerable(\"Powertrain settings applied.\");\n    }\n    if (current_susp_config != NULL) {\n        automotiveLog_vulnerable(\"Suspension settings applied.\");\n    }\n    if (current_steer_config != NULL) {\n        automotiveLog_vulnerable(\"Steering settings applied.\");\n    }\n    automotiveLog_vulnerable(\"Active profile settings applied to ECUs (vulnerable).\");\n}\n\nvoid vehicleMainLoop_vulnerable() {\n    initializeVehicleProfiles_vulnerable();\n\n    uint8_t cmd_profile_id = receiveProfileSelectionCommand_vulnerable();\n    setActiveDriverProfile_vulnerable(cmd_profile_id);\n\n    applyActiveProfileToECUs_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#define MAX_DRIVER_PROFILES 3\n\ntypedef struct {\n    uint16_t throttle_response_map_id;\n    uint8_t  regen_braking_level;\n} PowertrainSettings;\n\ntypedef struct {\n    uint16_t damping_force_preset_id;\n    uint16_t ride_height_offset_mm;\n} SuspensionSettings;\n\ntypedef struct {\n    uint8_t  steering_assist_level;\n    bool     lane_keeping_active;\n} SteeringSettings;\n\ntypedef struct {\n    PowertrainSettings* powertrain_config;\n    SuspensionSettings* suspension_config;\n    SteeringSettings*   steering_config;\n} DriverProfileConfig;\n\nstatic PowertrainSettings g_powertrainProfiles_fixed[MAX_DRIVER_PROFILES];\nstatic SuspensionSettings g_suspensionProfiles_fixed[MAX_DRIVER_PROFILES];\nstatic SteeringSettings   g_steeringProfiles_fixed[MAX_DRIVER_PROFILES];\n\nstatic DriverProfileConfig g_driverProfileConfigs_fixed[MAX_DRIVER_PROFILES];\n\nstatic uint8_t g_activeProfileIndex_fixed;\n\nvoid automotiveLog_fixed(const char* message) {}\n\nuint8_t receiveProfileSelectionCommand_fixed() {\n    return MAX_DRIVER_PROFILES;\n}\n\nvoid initializeVehicleProfiles_fixed() {\n    g_powertrainProfiles_fixed[0] = (PowertrainSettings){100, 3};\n    g_powertrainProfiles_fixed[1] = (PowertrainSettings){200, 1};\n    g_powertrainProfiles_fixed[2] = (PowertrainSettings){150, 2};\n\n    g_suspensionProfiles_fixed[0] = (SuspensionSettings){1, 0};\n    g_suspensionProfiles_fixed[1] = (SuspensionSettings){3, -10};\n    g_suspensionProfiles_fixed[2] = (SuspensionSettings){2, 5};\n\n    g_steeringProfiles_fixed[0] = (SteeringSettings){1, true};\n    g_steeringProfiles_fixed[1] = (SteeringSettings){3, false};\n    g_steeringProfiles_fixed[2] = (SteeringSettings){2, true};\n\n    for (uint8_t i = 0; i < MAX_DRIVER_PROFILES; ++i) {\n        g_driverProfileConfigs_fixed[i].powertrain_config = &g_powertrainProfiles_fixed[i];\n        g_driverProfileConfigs_fixed[i].suspension_config = &g_suspensionProfiles_fixed[i];\n        g_driverProfileConfigs_fixed[i].steering_config = &g_steeringProfiles_fixed[i];\n    }\n\n    g_activeProfileIndex_fixed = 0;\n}\n\nvoid setActiveDriverProfile_fixed(uint8_t profile_id) {\n    if (profile_id < MAX_DRIVER_PROFILES) {\n        g_activeProfileIndex_fixed = profile_id;\n        automotiveLog_fixed(\"Driver profile selected successfully.\");\n    } else {\n        automotiveLog_fixed(\"Invalid driver profile ID received. Keeping current profile.\");\n    }\n}\n\nvoid applyActiveProfileToECUs_fixed() {\n    PowertrainSettings* current_pt_config = g_driverProfileConfigs_fixed[g_activeProfileIndex_fixed].powertrain_config;\n    SuspensionSettings* current_susp_config = g_driverProfileConfigs_fixed[g_activeProfileIndex_fixed].suspension_config;\n    SteeringSettings*   current_steer_config = g_driverProfileConfigs_fixed[g_activeProfileIndex_fixed].steering_config;\n\n    if (current_pt_config != NULL) {\n        automotiveLog_fixed(\"Powertrain settings applied.\");\n    }\n    if (current_susp_config != NULL) {\n        automotiveLog_fixed(\"Suspension settings applied.\");\n    }\n    if (current_steer_config != NULL) {\n        automotiveLog_fixed(\"Steering settings applied.\");\n    }\n    automotiveLog_fixed(\"Active profile settings applied to ECUs (fixed).\");\n}\n\nvoid vehicleMainLoop_fixed() {\n    initializeVehicleProfiles_fixed();\n\n    uint8_t cmd_profile_id = receiveProfileSelectionCommand_fixed();\n    setActiveDriverProfile_fixed(cmd_profile_id);\n\n    applyActiveProfileToECUs_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_DIAG_MESSAGE_TYPES 10\n#define DIAG_DATA_BUFFER_SIZE 32\n\ntypedef struct {\n    uint8_t messageType;\n    uint8_t payload[DIAG_DATA_BUFFER_SIZE];\n    uint8_t payload_len;\n} DiagnosticMessage;\n\nstatic uint32_t g_diagCounters[MAX_DIAG_MESSAGE_TYPES];\nstatic uint16_t g_diagData[MAX_DIAG_MESSAGE_TYPES][DIAG_DATA_BUFFER_SIZE];\n\nvoid logDiagnosticError(const char* msg) {\n}\n\nDiagnosticMessage receiveDiagnosticMessage_vulnerable() {\n    DiagnosticMessage msg;\n    msg.messageType = MAX_DIAG_MESSAGE_TYPES;\n    msg.payload_len = 4;\n    msg.payload[0] = 0xAA;\n    msg.payload[1] = 0xBB;\n    msg.payload[2] = 0xCC;\n    msg.payload[3] = 0xDD;\n    return msg;\n}\n\nvoid processDiagnosticMessage_vulnerable() {\n    DiagnosticMessage msg = receiveDiagnosticMessage_vulnerable();\n\n    g_diagCounters[msg.messageType]++;\n\n    for (uint8_t i = 0; i < msg.payload_len; ++i) {\n        if (i < DIAG_DATA_BUFFER_SIZE) {\n            g_diagData[msg.messageType][i] = msg.payload[i];\n        }\n    }\n}\n\nvoid initializeDiagnosticSystem_vulnerable() {\n    for (uint8_t i = 0; i < MAX_DIAG_MESSAGE_TYPES; ++i) {\n        g_diagCounters[i] = 0;\n        for (uint8_t j = 0; j < DIAG_DATA_BUFFER_SIZE; ++j) {\n            g_diagData[i][j] = 0;\n        }\n    }\n}\n\nvoid diagnosticSystem_vulnerable_main() {\n    initializeDiagnosticSystem_vulnerable();\n    processDiagnosticMessage_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_DIAG_MESSAGE_TYPES 10\n#define DIAG_DATA_BUFFER_SIZE 32\n\ntypedef struct {\n    uint8_t messageType;\n    uint8_t payload[DIAG_DATA_BUFFER_SIZE];\n    uint8_t payload_len;\n} DiagnosticMessage;\n\nstatic uint32_t g_diagCounters_fixed[MAX_DIAG_MESSAGE_TYPES];\nstatic uint16_t g_diagData_fixed[MAX_DIAG_MESSAGE_TYPES][DIAG_DATA_BUFFER_SIZE];\n\nvoid logDiagnosticError_fixed(const char* msg) {\n}\n\nDiagnosticMessage receiveDiagnosticMessage_fixed() {\n    DiagnosticMessage msg;\n    msg.messageType = MAX_DIAG_MESSAGE_TYPES;\n    msg.payload_len = 4;\n    msg.payload[0] = 0xAA;\n    msg.payload[1] = 0xBB;\n    msg.payload[2] = 0xCC;\n    msg.payload[3] = 0xDD;\n    return msg;\n}\n\nvoid processDiagnosticMessage_fixed() {\n    DiagnosticMessage msg = receiveDiagnosticMessage_fixed();\n\n    if (msg.messageType < MAX_DIAG_MESSAGE_TYPES) {\n        g_diagCounters_fixed[msg.messageType]++;\n\n        for (uint8_t i = 0; i < msg.payload_len; ++i) {\n            if (i < DIAG_DATA_BUFFER_SIZE) {\n                g_diagData_fixed[msg.messageType][i] = msg.payload[i];\n            }\n        }\n    } else {\n        logDiagnosticError_fixed(\"Invalid diagnostic message type received. Ignoring message.\");\n    }\n}\n\nvoid initializeDiagnosticSystem_fixed() {\n    for (uint8_t i = 0; i < MAX_DIAG_MESSAGE_TYPES; ++i) {\n        g_diagCounters_fixed[i] = 0;\n        for (uint8_t j = 0; j < DIAG_DATA_BUFFER_SIZE; ++j) {\n            g_diagData_fixed[i][j] = 0;\n        }\n    }\n}\n\nvoid diagnosticSystem_fixed_main() {\n    initializeDiagnosticSystem_fixed();\n    processDiagnosticMessage_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_SENSORS 5\n\ntypedef enum {\n    SENSOR_TYPE_PRESSURE = 0,\n    SENSOR_TYPE_TEMPERATURE,\n    SENSOR_TYPE_ACCELEROMETER,\n    SENSOR_TYPE_GYROSCOPE,\n    SENSOR_TYPE_VOLTAGE\n} SensorType;\n\ntypedef struct {\n    float offset;\n    float gain;\n} SensorCalibrationParams;\n\nstatic SensorCalibrationParams g_sensorCalibrationData[MAX_SENSORS];\n\nvoid logError(const char* msg) {\n}\n\nvoid initializeSensorCalibrations_vulnerable() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        g_sensorCalibrationData[i].offset = 0.0f;\n        g_sensorCalibrationData[i].gain = 1.0f;\n    }\n}\n\ntypedef struct {\n    uint8_t sensor_type_id;\n    float new_offset;\n    float new_gain;\n} SensorCalibrationCommand;\n\nSensorCalibrationCommand receiveCalibrationCommand_vulnerable() {\n    SensorCalibrationCommand cmd;\n    cmd.sensor_type_id = MAX_SENSORS;\n    cmd.new_offset = 12.34f;\n    cmd.new_gain = 5.67f;\n    return cmd;\n}\n\nvoid processSensorCalibrationCommand_vulnerable() {\n    SensorCalibrationCommand cmd = receiveCalibrationCommand_vulnerable();\n\n    g_sensorCalibrationData[cmd.sensor_type_id].offset = cmd.new_offset;\n    g_sensorCalibrationData[cmd.sensor_type_id].gain = cmd.new_gain;\n    \n    logError(\"Sensor calibration attempted (vulnerable).\");\n}\n\nvoid automotiveCalibrationService_vulnerable() {\n    initializeSensorCalibrations_vulnerable();\n    processSensorCalibrationCommand_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_SENSORS 5\n\ntypedef enum {\n    SENSOR_TYPE_PRESSURE = 0,\n    SENSOR_TYPE_TEMPERATURE,\n    SENSOR_TYPE_ACCELEROMETER,\n    SENSOR_TYPE_GYROSCOPE,\n    SENSOR_TYPE_VOLTAGE\n} SensorType;\n\ntypedef struct {\n    float offset;\n    float gain;\n} SensorCalibrationParams;\n\nstatic SensorCalibrationParams g_sensorCalibrationData[MAX_SENSORS];\n\nvoid logError(const char* msg) {\n}\n\nvoid initializeSensorCalibrations_fixed() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        g_sensorCalibrationData[i].offset = 0.0f;\n        g_sensorCalibrationData[i].gain = 1.0f;\n    }\n}\n\ntypedef struct {\n    uint8_t sensor_type_id;\n    float new_offset;\n    float new_gain;\n} SensorCalibrationCommand;\n\nSensorCalibrationCommand receiveCalibrationCommand_fixed() {\n    SensorCalibrationCommand cmd;\n    cmd.sensor_type_id = MAX_SENSORS;\n    cmd.new_offset = 12.34f;\n    cmd.new_gain = 5.67f;\n    return cmd;\n}\n\nvoid processSensorCalibrationCommand_fixed() {\n    SensorCalibrationCommand cmd = receiveCalibrationCommand_fixed();\n\n    if (cmd.sensor_type_id < MAX_SENSORS) {\n        g_sensorCalibrationData[cmd.sensor_type_id].offset = cmd.new_offset;\n        g_sensorCalibrationData[cmd.sensor_type_id].gain = cmd.new_gain;\n        logError(\"Sensor calibration updated (fixed).\");\n    } else {\n        logError(\"Invalid sensor type ID received for calibration. Ignoring command.\");\n    }\n}\n\nvoid automotiveCalibrationService_fixed() {\n    initializeSensorCalibrations_fixed();\n    processSensorCalibrationCommand_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define NUM_SUBSYSTEM_LOGGERS 3\n#define MAX_EVENTS_ENGINE 10\n#define MAX_EVENTS_TRANSMISSION 5\n#define MAX_EVENTS_ABS 8\n\ntypedef struct {\n    uint32_t event_id;\n    uint32_t timestamp;\n    uint8_t  severity;\n} DiagnosticEvent;\n\ntypedef enum {\n    SUBSYSTEM_ENGINE = 0,\n    SUBSYSTEM_TRANSMISSION,\n    SUBSYSTEM_ABS,\n    SUBSYSTEM_COUNT\n} SubsystemType;\n\nstatic DiagnosticEvent g_engineEvents[MAX_EVENTS_ENGINE];\nstatic DiagnosticEvent g_transmissionEvents[MAX_EVENTS_TRANSMISSION];\nstatic DiagnosticEvent g_absEvents[MAX_EVENTS_ABS];\n\ntypedef struct {\n    DiagnosticEvent* buffer;\n    uint8_t  current_count;\n    uint8_t  max_size;\n} SubsystemLoggerConfig;\n\nstatic SubsystemLoggerConfig g_subsystemLoggers[SUBSYSTEM_COUNT];\n\nvoid logSystemNotification(const char* msg) {\n}\n\nvoid initializeLoggers_vulnerable() {\n    g_subsystemLoggers[SUBSYSTEM_ENGINE].buffer = g_engineEvents;\n    g_subsystemLoggers[SUBSYSTEM_ENGINE].max_size = MAX_EVENTS_ENGINE;\n    g_subsystemLoggers[SUBSYSTEM_ENGINE].current_count = 0;\n\n    g_subsystemLoggers[SUBSYSTEM_TRANSMISSION].buffer = g_transmissionEvents;\n    g_subsystemLoggers[SUBSYSTEM_TRANSMISSION].max_size = MAX_EVENTS_TRANSMISSION;\n    g_subsystemLoggers[SUBSYSTEM_TRANSMISSION].current_count = 0;\n\n    g_subsystemLoggers[SUBSYSTEM_ABS].buffer = g_absEvents;\n    g_subsystemLoggers[SUBSYSTEM_ABS].max_size = MAX_EVENTS_ABS;\n    g_subsystemLoggers[SUBSYSTEM_ABS].current_count = 0;\n}\n\ntypedef struct {\n    SubsystemType subsystem;\n    DiagnosticEvent event_data;\n} NewDiagnosticEvent_vulnerable;\n\nvoid processAndLogDiagnosticEvent_vulnerable(NewDiagnosticEvent_vulnerable received_event) {\n    if (received_event.subsystem < SUBSYSTEM_COUNT) {\n        SubsystemLoggerConfig* logger = &g_subsystemLoggers[received_event.subsystem];\n\n        logger->buffer[logger->current_count] = received_event.event_data;\n        logger->current_count++;\n        logSystemNotification(\"Diagnostic event added to log.\");\n    } else {\n        logSystemNotification(\"Received event for invalid subsystem type.\");\n    n}\n}\n\nvoid diagnosticMonitorLoop_vulnerable() {\n    initializeLoggers_vulnerable();\n\n    for (int i = 0; i <= MAX_EVENTS_TRANSMISSION; ++i) {\n        NewDiagnosticEvent_vulnerable event_to_process;\n        event_to_process.subsystem = SUBSYSTEM_TRANSMISSION;\n        event_to_process.event_data.event_id = 0xA000 + i;\n        event_to_process.event_data.timestamp = 1000 + i;\n        event_to_process.event_data.severity = (uint8_t)(i % 4 + 1);\n        processAndLogDiagnosticEvent_vulnerable(event_to_process);\n    }\n\n    NewDiagnosticEvent_vulnerable engine_event;\n    engine_event.subsystem = SUBSYSTEM_ENGINE;\n    engine_event.event_data.event_id = 0xB001;\n    engine_event.event_data.timestamp = 2000;\n    engine_event.event_data.severity = 3;\n    processAndLogDiagnosticEvent_vulnerable(engine_event);\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define NUM_SUBSYSTEM_LOGGERS 3\n#define MAX_EVENTS_ENGINE 10\n#define MAX_EVENTS_TRANSMISSION 5\n#define MAX_EVENTS_ABS 8\n\ntypedef struct {\n    uint32_t event_id;\n    uint32_t timestamp;\n    uint8_t  severity;\n} DiagnosticEvent;\n\ntypedef enum {\n    SUBSYSTEM_ENGINE = 0,\n    SUBSYSTEM_TRANSMISSION,\n    SUBSYSTEM_ABS,\n    SUBSYSTEM_COUNT\n} SubsystemType;\n\nstatic DiagnosticEvent g_engineEvents[MAX_EVENTS_ENGINE];\nstatic DiagnosticEvent g_transmissionEvents[MAX_EVENTS_TRANSMISSION];\nstatic DiagnosticEvent g_absEvents[MAX_EVENTS_ABS];\n\ntypedef struct {\n    DiagnosticEvent* buffer;\n    uint8_t  current_count;\n    uint8_t  max_size;\n} SubsystemLoggerConfig;\n\nstatic SubsystemLoggerConfig g_subsystemLoggers[SUBSYSTEM_COUNT];\n\nvoid logSystemNotification(const char* msg) {\n}\n\nvoid initializeLoggers_fixed() {\n    g_subsystemLoggers[SUBSYSTEM_ENGINE].buffer = g_engineEvents;\n    g_subsystemLoggers[SUBSYSTEM_ENGINE].max_size = MAX_EVENTS_ENGINE;\n    g_subsystemLoggers[SUBSYSTEM_ENGINE].current_count = 0;\n\n    g_subsystemLoggers[SUBSYSTEM_TRANSMISSION].buffer = g_transmissionEvents;\n    g_subsystemLoggers[SUBSYSTEM_TRANSMISSION].max_size = MAX_EVENTS_TRANSMISSION;\n    g_subsystemLoggers[SUBSYSTEM_TRANSMISSION].current_count = 0;\n\n    g_subsystemLoggers[SUBSYSTEM_ABS].buffer = g_absEvents;\n    g_subsystemLoggers[SUBSYSTEM_ABS].max_size = MAX_EVENTS_ABS;\n    g_subsystemLoggers[SUBSYSTEM_ABS].current_count = 0;\n}\n\ntypedef struct {\n    SubsystemType subsystem;\n    DiagnosticEvent event_data;\n} NewDiagnosticEvent_fixed;\n\nvoid processAndLogDiagnosticEvent_fixed(NewDiagnosticEvent_fixed received_event) {\n    if (received_event.subsystem < SUBSYSTEM_COUNT) {\n        SubsystemLoggerConfig* logger = &g_subsystemLoggers[received_event.subsystem];\n\n        if (logger->current_count < logger->max_size) {\n            logger->buffer[logger->current_count] = received_event.event_data;\n            logger->current_count++;\n            logSystemNotification(\"Diagnostic event added to log.\");\n        } else {\n            logSystemNotification(\"Diagnostic event logger full for subsystem. Event dropped.\");\n        }\n    } else {\n        logSystemNotification(\"Received event for invalid subsystem type.\");\n    }\n}\n\nvoid diagnosticMonitorLoop_fixed() {\n    initializeLoggers_fixed();\n\n    for (int i = 0; i <= MAX_EVENTS_TRANSMISSION; ++i) {\n        NewDiagnosticEvent_fixed event_to_process;\n        event_to_process.subsystem = SUBSYSTEM_TRANSMISSION;\n        event_to_process.event_data.event_id = 0xA000 + i;\n        event_to_process.event_data.timestamp = 1000 + i;\n        event_to_process.event_data.severity = (uint8_t)(i % 4 + 1);\n        processAndLogDiagnosticEvent_fixed(event_to_process);\n    }\n\n    NewDiagnosticEvent_fixed engine_event;\n    engine_event.subsystem = SUBSYSTEM_ENGINE;\n    engine_event.event_data.event_id = 0xB001;\n    engine_event.event_data.timestamp = 2000;\n    engine_event.event_data.severity = 3;\n    processAndLogDiagnosticEvent_fixed(engine_event);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_MSG_TYPES 3\n#define MAX_SUB_TYPES_PER_MSG 5\n#define PAYLOAD_MAX_SIZE 16\n\nvoid handleMsgType0Sub0_vulnerable(const uint8_t* payload) {}\nvoid handleMsgType0Sub1_vulnerable(const uint8_t* payload) {}\nvoid handleMsgType1Sub0_vulnerable(const uint8_t* payload) {}\nvoid handleMsgType1Sub1_vulnerable(const uint8_t* payload) {}\nvoid handleMsgType2Sub0_vulnerable(const uint8_t* payload) {}\n\ntypedef struct {\n    uint8_t msg_id;\n    uint8_t sub_id;\n    uint8_t payload[PAYLOAD_MAX_SIZE];\n    uint8_t payload_len;\n} DiagnosticMessage;\n\nstatic void (*g_diagMsgHandlers_vulnerable[MAX_MSG_TYPES][MAX_SUB_TYPES_PER_MSG])(const uint8_t* payload);\n\nvoid logECUError_vulnerable(const char* msg) {}\n\nvoid initializeDiagHandlers_vulnerable() {\n    for (int i = 0; i < MAX_MSG_TYPES; ++i) {\n        for (int j = 0; j < MAX_SUB_TYPES_PER_MSG; ++j) {\n            g_diagMsgHandlers_vulnerable[i][j] = NULL;\n        }\n    }\n    g_diagMsgHandlers_vulnerable[0][0] = handleMsgType0Sub0_vulnerable;\n    g_diagMsgHandlers_vulnerable[0][1] = handleMsgType0Sub1_vulnerable;\n    g_diagMsgHandlers_vulnerable[1][0] = handleMsgType1Sub0_vulnerable;\n    g_diagMsgHandlers_vulnerable[1][1] = handleMsgType1Sub1_vulnerable;\n    g_diagMsgHandlers_vulnerable[2][0] = handleMsgType2Sub0_vulnerable;\n}\n\nDiagnosticMessage receiveDiagnosticMessage_vulnerable() {\n    DiagnosticMessage msg;\n    msg.msg_id = 1;\n    msg.sub_id = MAX_SUB_TYPES_PER_MSG;\n    msg.payload[0] = 0xAA;\n    msg.payload_len = 1;\n    return msg;\n}\n\nvoid processDiagnosticMessage_vulnerable() {\n    DiagnosticMessage received_msg = receiveDiagnosticMessage_vulnerable();\n\n    if (received_msg.msg_id < MAX_MSG_TYPES) {\n        if (g_diagMsgHandlers_vulnerable[received_msg.msg_id][received_msg.sub_id] != NULL) {\n            g_diagMsgHandlers_vulnerable[received_msg.msg_id][received_msg.sub_id](received_msg.payload);\n        } else {\n            logECUError_vulnerable(\"Handler not registered for the given sub_id.\");\n        }\n    } else {\n        logECUError_vulnerable(\"Invalid message ID received.\");\n    }\n}\n\nvoid main_ecu_loop_vulnerable() {\n    initializeDiagHandlers_vulnerable();\n    processDiagnosticMessage_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_MSG_TYPES 3\n#define MAX_SUB_TYPES_PER_MSG 5\n#define PAYLOAD_MAX_SIZE 16\n\nvoid handleMsgType0Sub0_fixed(const uint8_t* payload) {}\nvoid handleMsgType0Sub1_fixed(const uint8_t* payload) {}\nvoid handleMsgType1Sub0_fixed(const uint8_t* payload) {}\nvoid handleMsgType1Sub1_fixed(const uint8_t* payload) {}\nvoid handleMsgType2Sub0_fixed(const uint8_t* payload) {}\n\ntypedef struct {\n    uint8_t msg_id;\n    uint8_t sub_id;\n    uint8_t payload[PAYLOAD_MAX_SIZE];\n    uint8_t payload_len;\n} DiagnosticMessage;\n\nstatic void (*g_diagMsgHandlers_fixed[MAX_MSG_TYPES][MAX_SUB_TYPES_PER_MSG])(const uint8_t* payload);\n\nvoid logECUError_fixed(const char* msg) {}\n\nvoid initializeDiagHandlers_fixed() {\n    for (int i = 0; i < MAX_MSG_TYPES; ++i) {\n        for (int j = 0; j < MAX_SUB_TYPES_PER_MSG; ++j) {\n            g_diagMsgHandlers_fixed[i][j] = NULL;\n        }\n    }\n    g_diagMsgHandlers_fixed[0][0] = handleMsgType0Sub0_fixed;\n    g_diagMsgHandlers_fixed[0][1] = handleMsgType0Sub1_fixed;\n    g_diagMsgHandlers_fixed[1][0] = handleMsgType1Sub0_fixed;\n    g_diagMsgHandlers_fixed[1][1] = handleMsgType1Sub1_fixed;\n    g_diagMsgHandlers_fixed[2][0] = handleMsgType2Sub0_fixed;\n}\n\nDiagnosticMessage receiveDiagnosticMessage_fixed() {\n    DiagnosticMessage msg;\n    msg.msg_id = 1;\n    msg.sub_id = MAX_SUB_TYPES_PER_MSG;\n    msg.payload[0] = 0xAA;\n    msg.payload_len = 1;\n    return msg;\n}\n\nvoid processDiagnosticMessage_fixed() {\n    DiagnosticMessage received_msg = receiveDiagnosticMessage_fixed();\n\n    if (received_msg.msg_id < MAX_MSG_TYPES) {\n        if (received_msg.sub_id < MAX_SUB_TYPES_PER_MSG) { \n            if (g_diagMsgHandlers_fixed[received_msg.msg_id][received_msg.sub_id] != NULL) {\n                g_diagMsgHandlers_fixed[received_msg.msg_id][received_msg.sub_id](received_msg.payload);\n            } else {\n                logECUError_fixed(\"Handler not registered for the given sub_id.\");\n            }\n        } else {\n            logECUError_fixed(\"Sub-ID out of bounds for diagnostic message. Ignoring.\");\n        }\n    } else {\n        logECUError_fixed(\"Invalid message ID received.\");\n    }\n}\n\nvoid main_ecu_loop_fixed() {\n    initializeDiagHandlers_fixed();\n    processDiagnosticMessage_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_HISTORICAL_PARAMS 5\n#define MAX_RECORDS_PER_PARAM 10\n\ntypedef struct {\n    uint16_t value;\n    uint32_t timestamp;\n} ParameterDataEntry;\n\n// Stored historical data for each parameter\nstatic ParameterDataEntry g_historicalData_vulnerable[MAX_HISTORICAL_PARAMS][MAX_RECORDS_PER_PARAM];\n// Current actual count of records for each parameter (can be less than MAX_RECORDS_PER_PARAM)\nstatic uint8_t g_currentRecordCount_vulnerable[MAX_HISTORICAL_PARAMS];\n\ntypedef struct {\n    uint8_t paramId;\n    uint8_t recordIndex;\n} DiagnosticQuery;\n\nvoid automotiveLog_vulnerable(const char* msg) {\n}\n\n// Simulates receiving a diagnostic query from an external source (e.g., CAN bus)\nDiagnosticQuery receiveDiagnosticQuery_vulnerable() {\n    DiagnosticQuery query;\n    query.paramId = 1; \n    query.recordIndex = 7; \n    return query;\n}\n\n// Initializes historical data and actual record counts\nvoid initializeHistoricalData_vulnerable() {\n    for (uint8_t i = 0; i < MAX_HISTORICAL_PARAMS; ++i) {\n        g_currentRecordCount_vulnerable[i] = 0;\n        for (uint8_t j = 0; j < MAX_RECORDS_PER_PARAM; ++j) {\n            g_historicalData_vulnerable[i][j] = (ParameterDataEntry){0, 0};\n        }\n    }\n\n    // Populate some data for paramId 1 with 5 actual records\n    g_currentRecordCount_vulnerable[1] = 5;\n    for (uint8_t j = 0; j < g_currentRecordCount_vulnerable[1]; ++j) {\n        g_historicalData_vulnerable[1][j] = (ParameterDataEntry){100 + j, 0x12345678 + j};\n    }\n\n    // Populate some data for paramId 0 with MAX_RECORDS_PER_PARAM records\n    g_currentRecordCount_vulnerable[0] = MAX_RECORDS_PER_PARAM;\n    for (uint8_t j = 0; j < g_currentRecordCount_vulnerable[0]; ++j) {\n        g_historicalData_vulnerable[0][j] = (ParameterDataEntry){200 + j, 0xAABBCCDD + j};\n    }\n}\n\n// Processes a diagnostic query to retrieve historical data\nvoid processDiagnosticQuery_vulnerable() {\n    DiagnosticQuery query = receiveDiagnosticQuery_vulnerable();\n\n    if (query.paramId < MAX_HISTORICAL_PARAMS) { // Check if parameter ID is within bounds\n        // Vulnerability: recordIndex is NOT checked against g_currentRecordCount_vulnerable[query.paramId].\n        // An attacker can request a recordIndex that is within MAX_RECORDS_PER_PARAM \n        // but beyond the actual number of records stored for this specific paramId,\n        // leading to an out-of-bounds read within the g_historicalData_vulnerable[query.paramId] row.\n        ParameterDataEntry requestedData = g_historicalData_vulnerable[query.paramId][query.recordIndex];\n        automotiveLog_vulnerable(\"Historical data retrieved (vulnerable).\");\n        // In a real system, requestedData would be sent back or processed, potentially exposing stale/uninitialized memory.\n    } else {\n        automotiveLog_vulnerable(\"Invalid parameter ID received (vulnerable).\");\n    }\n}\n\nvoid automotiveMain_vulnerable() {\n    initializeHistoricalData_vulnerable();\n    processDiagnosticQuery_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_HISTORICAL_PARAMS 5\n#define MAX_RECORDS_PER_PARAM 10\n\ntypedef struct {\n    uint16_t value;\n    uint32_t timestamp;\n} ParameterDataEntry;\n\n// Stored historical data for each parameter\nstatic ParameterDataEntry g_historicalData_fixed[MAX_HISTORICAL_PARAMS][MAX_RECORDS_PER_PARAM];\n// Current actual count of records for each parameter (can be less than MAX_RECORDS_PER_PARAM)\nstatic uint8_t g_currentRecordCount_fixed[MAX_HISTORICAL_PARAMS];\n\ntypedef struct {\n    uint8_t paramId;\n    uint8_t recordIndex;\n} DiagnosticQuery;\n\nvoid automotiveLog_fixed(const char* msg) {\n}\n\n// Simulates receiving a diagnostic query from an external source (e.g., CAN bus)\nDiagnosticQuery receiveDiagnosticQuery_fixed() {\n    DiagnosticQuery query;\n    query.paramId = 1;\n    query.recordIndex = 7;\n    return query;\n}\n\n// Initializes historical data and actual record counts\nvoid initializeHistoricalData_fixed() {\n    for (uint8_t i = 0; i < MAX_HISTORICAL_PARAMS; ++i) {\n        g_currentRecordCount_fixed[i] = 0;\n        for (uint8_t j = 0; j < MAX_RECORDS_PER_PARAM; ++j) {\n            g_historicalData_fixed[i][j] = (ParameterDataEntry){0, 0};\n        }\n    }\n\n    // Populate some data for paramId 1 with 5 actual records\n    g_currentRecordCount_fixed[1] = 5;\n    for (uint8_t j = 0; j < g_currentRecordCount_fixed[1]; ++j) {\n        g_historicalData_fixed[1][j] = (ParameterDataEntry){100 + j, 0x12345678 + j};\n    }\n\n    // Populate some data for paramId 0 with MAX_RECORDS_PER_PARAM records\n    g_currentRecordCount_fixed[0] = MAX_RECORDS_PER_PARAM;\n    for (uint8_t j = 0; j < g_currentRecordCount_fixed[0]; ++j) {\n        g_historicalData_fixed[0][j] = (ParameterDataEntry){200 + j, 0xAABBCCDD + j};\n    }\n}\n\n// Processes a diagnostic query to retrieve historical data\nvoid processDiagnosticQuery_fixed() {\n    DiagnosticQuery query = receiveDiagnosticQuery_fixed();\n\n    if (query.paramId < MAX_HISTORICAL_PARAMS) {\n        // Fix: Validate recordIndex against the actual number of records for this parameter.\n        if (query.recordIndex < g_currentRecordCount_fixed[query.paramId]) {\n            ParameterDataEntry requestedData = g_historicalData_fixed[query.paramId][query.recordIndex];\n            automotiveLog_fixed(\"Historical data retrieved (fixed).\");\n            // In a real system, requestedData would be sent back or processed.\n        } else {\n            automotiveLog_fixed(\"Requested record index out of bounds for this parameter (fixed).\");\n        }\n    } else {\n        automotiveLog_fixed(\"Invalid parameter ID received (fixed).\");\n    }\n}\n\nvoid automotiveMain_fixed() {\n    initializeHistoricalData_fixed();\n    processDiagnosticQuery_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_FEATURES 5\n#define MAX_PARAMS_PER_FEATURE_SLOT 10 \n\ntypedef struct {\n    uint32_t value;\n    bool     active;\n    uint8_t  access_level;\n} FeatureParameter;\n\nstatic FeatureParameter g_featureConfigurations_vulnerable[MAX_VEHICLE_FEATURES][MAX_PARAMS_PER_FEATURE_SLOT];\n\nstatic const uint8_t g_actualFeatureParameterCounts_vulnerable[MAX_VEHICLE_FEATURES] = {\n    7, \n    3, \n    9, \n    2, \n    5  \n};\n\ntypedef struct {\n    uint8_t feature_id;\n    uint8_t param_index;\n    uint32_t new_value;\n} FeatureUpdateCommand_vulnerable;\n\nvoid logVehicleConfigError_vulnerable(const char* msg) {\n}\n\nFeatureUpdateCommand_vulnerable receiveFeatureUpdateCommand_vulnerable() {\n    FeatureUpdateCommand_vulnerable cmd;\n    cmd.feature_id = 0; \n    cmd.param_index = 8; \n    cmd.new_value = 0xABCDEF00;\n    return cmd;\n}\n\nvoid initializeFeatureConfigs_vulnerable() {\n    for (uint8_t i = 0; i < MAX_VEHICLE_FEATURES; ++i) {\n        for (uint8_t j = 0; j < MAX_PARAMS_PER_FEATURE_SLOT; ++j) {\n            g_featureConfigurations_vulnerable[i][j] = (FeatureParameter){0, false, 0};\n        }\n    }\n    for (uint8_t i = 0; i < MAX_VEHICLE_FEATURES; ++i) {\n        for (uint8_t j = 0; j < g_actualFeatureParameterCounts_vulnerable[i]; ++j) {\n            g_featureConfigurations_vulnerable[i][j].active = true;\n            g_featureConfigurations_vulnerable[i][j].access_level = 1;\n        }\n    }\n}\n\nvoid processFeatureUpdate_vulnerable() {\n    FeatureUpdateCommand_vulnerable cmd = receiveFeatureUpdateCommand_vulnerable();\n\n    if (cmd.feature_id < MAX_VEHICLE_FEATURES) {\n        if (cmd.param_index < MAX_PARAMS_PER_FEATURE_SLOT) { \n            g_featureConfigurations_vulnerable[cmd.feature_id][cmd.param_index].value = cmd.new_value;\n            logVehicleConfigError_vulnerable(\"Feature configuration update processed.\");\n        } else {\n            logVehicleConfigError_vulnerable(\"Parameter index out of global bounds.\");\n        }\n    } else {\n        logVehicleConfigError_vulnerable(\"Invalid feature ID received.\");\n    }\n}\n\nvoid vehicleConfigSystemMain_vulnerable() {\n    initializeFeatureConfigs_vulnerable();\n    processFeatureUpdate_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_FEATURES 5\n#define MAX_PARAMS_PER_FEATURE_SLOT 10 \n\ntypedef struct {\n    uint32_t value;\n    bool     active;\n    uint8_t  access_level;\n} FeatureParameter;\n\nstatic FeatureParameter g_featureConfigurations_fixed[MAX_VEHICLE_FEATURES][MAX_PARAMS_PER_FEATURE_SLOT];\n\nstatic const uint8_t g_actualFeatureParameterCounts_fixed[MAX_VEHICLE_FEATURES] = {\n    7, \n    3, \n    9, \n    2, \n    5  \n};\n\ntypedef struct {\n    uint8_t feature_id;\n    uint8_t param_index;\n    uint32_t new_value;\n} FeatureUpdateCommand_fixed;\n\nvoid logVehicleConfigError_fixed(const char* msg) {\n}\n\nFeatureUpdateCommand_fixed receiveFeatureUpdateCommand_fixed() {\n    FeatureUpdateCommand_fixed cmd;\n    cmd.feature_id = 0; \n    cmd.param_index = 8; \n    cmd.new_value = 0xABCDEF00;\n    return cmd;\n}\n\nvoid initializeFeatureConfigs_fixed() {\n    for (uint8_t i = 0; i < MAX_VEHICLE_FEATURES; ++i) {\n        for (uint8_t j = 0; j < MAX_PARAMS_PER_FEATURE_SLOT; ++j) {\n            g_featureConfigurations_fixed[i][j] = (FeatureParameter){0, false, 0};\n        }\n    }\n    for (uint8_t i = 0; i < MAX_VEHICLE_FEATURES; ++i) {\n        for (uint8_t j = 0; j < g_actualFeatureParameterCounts_fixed[i]; ++j) {\n            g_featureConfigurations_fixed[i][j].active = true;\n            g_featureConfigurations_fixed[i][j].access_level = 1;\n        }\n    }\n}\n\nvoid processFeatureUpdate_fixed() {\n    FeatureUpdateCommand_fixed cmd = receiveFeatureUpdateCommand_fixed();\n\n    if (cmd.feature_id < MAX_VEHICLE_FEATURES) {\n        if (cmd.param_index < g_actualFeatureParameterCounts_fixed[cmd.feature_id]) { \n            g_featureConfigurations_fixed[cmd.feature_id][cmd.param_index].value = cmd.new_value;\n            logVehicleConfigError_fixed(\"Feature configuration updated successfully.\");\n        } else {\n            logVehicleConfigError_fixed(\"Parameter index out of bounds for specified feature.\");\n        }\n    } else {\n        logVehicleConfigError_fixed(\"Invalid feature ID received.\");\n    }\n}\n\nvoid vehicleConfigSystemMain_fixed() {\n    initializeFeatureConfigs_fixed();\n    processFeatureUpdate_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n\ntypedef enum {\n    EVENT_TYPE_IGNITION = 0,\n    EVENT_TYPE_GEARBOX,\n    EVENT_TYPE_WHEEL_SPEED,\n    EVENT_TYPE_BATTERY,\n    EVENT_TYPE_DIAGNOSTIC,\n    EVENT_TYPE_COUNT\n} EventType;\n\ntypedef struct {\n    EventType type;\n    uint8_t   subtype_idx;\n    uint16_t  data_payload;\n} VehicleEvent_Vulnerable;\n\nvoid handleIgnitionEvent(uint8_t subtype_idx, uint16_t data) { }\nvoid handleGearboxEvent(uint8_t subtype_idx, uint16_t data) { }\nvoid handleWheelSpeedEvent(uint8_t subtype_idx, uint16_t data) { }\nvoid handleBatteryEvent(uint8_t subtype_idx, uint16_t data) { }\nvoid handleDiagnosticEvent(uint8_t subtype_idx, uint16_t data) { }\n\nstatic const char* ignition_subtypes[] = {\n    \"Ignition On\", \"Ignition Off\", \"Engine Start Attempt\"\n};\n#define IGNITION_SUBTYPE_COUNT (sizeof(ignition_subtypes) / sizeof(ignition_subtypes[0]))\n\nstatic const char* gearbox_subtypes[] = {\n    \"Gear Shift Up\", \"Gear Shift Down\", \"Neutral Engaged\", \"Gearbox Fault\"\n};\n#define GEARBOX_SUBTYPE_COUNT (sizeof(gearbox_subtypes) / sizeof(gearbox_subtypes[0]))\n\nstatic const char* wheel_speed_subtypes[] = {\n    \"Wheel Speed FL\", \"Wheel Speed FR\", \"Wheel Speed RL\", \"Wheel Speed RR\", \"All Sensors Valid\"\n};\n#define WHEEL_SPEED_SUBTYPE_COUNT (sizeof(wheel_speed_subtypes) / sizeof(wheel_speed_subtypes[0]))\n\nstatic const char* battery_subtypes[] = {\n    \"Low Battery Voltage\", \"High Battery Voltage\", \"Overcharge Detected\"\n};\n#define BATTERY_SUBTYPE_COUNT (sizeof(battery_subtypes) / sizeof(battery_subtypes[0]))\n\nstatic const char* diagnostic_subtypes[] = {\n    \"Read DTCs\", \"Clear DTCs\", \"Perform Self-Test\", \"Diagnostic Reset\"\n};\n#define DIAGNOSTIC_SUBTYPE_COUNT (sizeof(diagnostic_subtypes) / sizeof(diagnostic_subtypes[0]))\n\nstatic const char** g_vulnerable_subTypeDescriptions[EVENT_TYPE_COUNT] = {\n    ignition_subtypes,\n    gearbox_subtypes,\n    wheel_speed_subtypes,\n    battery_subtypes,\n    diagnostic_subtypes\n};\n\nstatic const uint8_t g_vulnerable_subTypeCounts[EVENT_TYPE_COUNT] = {\n    IGNITION_SUBTYPE_COUNT,\n    GEARBOX_SUBTYPE_COUNT,\n    WHEEL_SPEED_SUBTYPE_COUNT,\n    BATTERY_SUBTYPE_COUNT,\n    DIAGNOSTIC_SUBTYPE_COUNT\n};\n\nvoid systemLog_vulnerable(const char* msg) {\n    printf(\"SYS_LOG: %s\\n\", msg);\n}\n\nVehicleEvent_Vulnerable receiveVehicleEvent_vulnerable() {\n    VehicleEvent_Vulnerable event;\n    event.type = EVENT_TYPE_GEARBOX;\n    event.subtype_idx = GEARBOX_SUBTYPE_COUNT;\n    event.data_payload = 0xABCD;\n    return event;\n}\n\nvoid processVehicleEvent_vulnerable() {\n    VehicleEvent_Vulnerable event = receiveVehicleEvent_vulnerable();\n\n    if (event.type < EVENT_TYPE_COUNT) {\n        const char* subtype_desc = g_vulnerable_subTypeDescriptions[event.type][event.subtype_idx];\n        systemLog_vulnerable(subtype_desc);\n    } else {\n        systemLog_vulnerable(\"Received event with invalid main type.\");\n    }\n}\n\nvoid automotiveApplicationMain_vulnerable() {\n    processVehicleEvent_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n\ntypedef enum {\n    EVENT_TYPE_IGNITION = 0,\n    EVENT_TYPE_GEARBOX,\n    EVENT_TYPE_WHEEL_SPEED,\n    EVENT_TYPE_BATTERY,\n    EVENT_TYPE_DIAGNOSTIC,\n    EVENT_TYPE_COUNT\n} EventType;\n\ntypedef struct {\n    EventType type;\n    uint8_t   subtype_idx;\n    uint16_t  data_payload;\n} VehicleEvent_Fixed;\n\nvoid handleIgnitionEvent_fixed(uint8_t subtype_idx, uint16_t data) { }\nvoid handleGearboxEvent_fixed(uint8_t subtype_idx, uint16_t data) { }\nvoid handleWheelSpeedEvent_fixed(uint8_t subtype_idx, uint16_t data) { }\nvoid handleBatteryEvent_fixed(uint8_t subtype_idx, uint16_t data) { }\nvoid handleDiagnosticEvent_fixed(uint8_t subtype_idx, uint16_t data) { }\n\nstatic const char* ignition_subtypes_fixed[] = {\n    \"Ignition On\", \"Ignition Off\", \"Engine Start Attempt\"\n};\n#define IGNITION_SUBTYPE_COUNT_FIXED (sizeof(ignition_subtypes_fixed) / sizeof(ignition_subtypes_fixed[0]))\n\nstatic const char* gearbox_subtypes_fixed[] = {\n    \"Gear Shift Up\", \"Gear Shift Down\", \"Neutral Engaged\", \"Gearbox Fault\"\n};\n#define GEARBOX_SUBTYPE_COUNT_FIXED (sizeof(gearbox_subtypes_fixed) / sizeof(gearbox_subtypes_fixed[0]))\n\nstatic const char* wheel_speed_subtypes_fixed[] = {\n    \"Wheel Speed FL\", \"Wheel Speed FR\", \"Wheel Speed RL\", \"Wheel Speed RR\", \"All Sensors Valid\"\n};\n#define WHEEL_SPEED_SUBTYPE_COUNT_FIXED (sizeof(wheel_speed_subtypes_fixed) / sizeof(wheel_speed_subtypes_fixed[0]))\n\nstatic const char* battery_subtypes_fixed[] = {\n    \"Low Battery Voltage\", \"High Battery Voltage\", \"Overcharge Detected\"\n};\n#define BATTERY_SUBTYPE_COUNT_FIXED (sizeof(battery_subtypes_fixed) / sizeof(battery_subtypes_fixed[0]))\n\nstatic const char* diagnostic_subtypes_fixed[] = {\n    \"Read DTCs\", \"Clear DTCs\", \"Perform Self-Test\", \"Diagnostic Reset\"\n};\n#define DIAGNOSTIC_SUBTYPE_COUNT_FIXED (sizeof(diagnostic_subtypes_fixed) / sizeof(diagnostic_subtypes_fixed[0]))\n\nstatic const char** g_fixed_subTypeDescriptions[EVENT_TYPE_COUNT] = {\n    ignition_subtypes_fixed,\n    gearbox_subtypes_fixed,\n    wheel_speed_subtypes_fixed,\n    battery_subtypes_fixed,\n    diagnostic_subtypes_fixed\n};\n\nstatic const uint8_t g_fixed_subTypeCounts[EVENT_TYPE_COUNT] = {\n    IGNITION_SUBTYPE_COUNT_FIXED,\n    GEARBOX_SUBTYPE_COUNT_FIXED,\n    WHEEL_SPEED_SUBTYPE_COUNT_FIXED,\n    BATTERY_SUBTYPE_COUNT_FIXED,\n    DIAGNOSTIC_SUBTYPE_COUNT_FIXED\n};\n\nvoid systemLog_fixed(const char* msg) {\n    printf(\"SYS_LOG: %s\\n\", msg);\n}\n\nVehicleEvent_Fixed receiveVehicleEvent_fixed() {\n    VehicleEvent_Fixed event;\n    event.type = EVENT_TYPE_GEARBOX;\n    event.subtype_idx = GEARBOX_SUBTYPE_COUNT_FIXED;\n    event.data_payload = 0xABCD;\n    return event;\n}\n\nvoid processVehicleEvent_fixed() {\n    VehicleEvent_Fixed event = receiveVehicleEvent_fixed();\n\n    if (event.type < EVENT_TYPE_COUNT) {\n        if (event.subtype_idx < g_fixed_subTypeCounts[event.type]) {\n            const char* subtype_desc = g_fixed_subTypeDescriptions[event.type][event.subtype_idx];\n            systemLog_fixed(subtype_desc);\n        } else {\n            systemLog_fixed(\"Received event with out-of-bounds subtype index for specific type.\");\n        }\n    } else {\n        systemLog_fixed(\"Received event with invalid main type.\");\n    }\n}\n\nvoid automotiveApplicationMain_fixed() {\n    processVehicleEvent_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_DRIVING_PROFILES 10\n#define NUM_PROFILE_PARAMS 4\n\ntypedef struct {\n    uint16_t speed_limit;\n    uint8_t  throttle_response;\n    uint8_t  suspension_mode;\n    bool     traction_control_active;\n} DrivingProfile;\n\nstatic DrivingProfile g_drivingProfiles[MAX_DRIVING_PROFILES];\n\nstatic uint8_t g_currentActiveProfiles = 5;\n\ntypedef struct {\n    uint8_t command_type;\n    uint8_t profile_id;\n    DrivingProfile new_config;\n} DrivingModeCommand;\n\nvoid logVehicleError(const char* msg) {\n}\n\nDrivingModeCommand receiveDrivingModeCommand_vulnerable() {\n    DrivingModeCommand cmd;\n    cmd.command_type = 0x01;\n    cmd.profile_id = 7;\n    cmd.new_config.speed_limit = 180;\n    cmd.new_config.throttle_response = 0xFF;\n    cmd.new_config.suspension_mode = 0x02;\n    cmd.new_config.traction_control_active = false;\n    return cmd;\n}\n\nvoid initializeDrivingProfiles_vulnerable() {\n    for (uint8_t i = 0; i < MAX_DRIVING_PROFILES; ++i) {\n        g_drivingProfiles[i] = (DrivingProfile){0, 0, 0, false};\n    }\n    for (uint8_t i = 0; i < g_currentActiveProfiles; ++i) {\n        g_drivingProfiles[i].speed_limit = 120 + (i * 10);\n        g_drivingProfiles[i].throttle_response = 0x50 + (i * 0x10);\n        g_drivingProfiles[i].suspension_mode = i % 3;\n        g_drivingProfiles[i].traction_control_active = true;\n    }\n}\n\nvoid processDrivingModeCommand_vulnerable() {\n    DrivingModeCommand cmd = receiveDrivingModeCommand_vulnerable();\n\n    if (cmd.command_type == 0x01) {\n        if (cmd.profile_id < MAX_DRIVING_PROFILES) {\n            g_drivingProfiles[cmd.profile_id] = cmd.new_config;\n            logVehicleError(\"Driving profile updated.\");\n        } else {\n            logVehicleError(\"Profile ID out of array bounds.\");\n        }\n    } else if (cmd.command_type == 0x02) {\n        if (cmd.profile_id < MAX_DRIVING_PROFILES) {\n            DrivingProfile queriedProfile = g_drivingProfiles[cmd.profile_id];\n            logVehicleError(\"Driving profile queried.\");\n        } else {\n            logVehicleError(\"Profile ID out of array bounds for query.\");\n        }\n    } else {\n        logVehicleError(\"Unknown driving mode command type.\");\n    }\n}\n\nvoid vehicleControlMain_vulnerable() {\n    initializeDrivingProfiles_vulnerable();\n    processDrivingModeCommand_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_DRIVING_PROFILES 10\n#define NUM_PROFILE_PARAMS 4\n\ntypedef struct {\n    uint16_t speed_limit;\n    uint8_t  throttle_response;\n    uint8_t  suspension_mode;\n    bool     traction_control_active;\n} DrivingProfile;\n\nstatic DrivingProfile g_drivingProfiles_fixed[MAX_DRIVING_PROFILES];\n\nstatic uint8_t g_currentActiveProfiles_fixed = 5;\n\ntypedef struct {\n    uint8_t command_type;\n    uint8_t profile_id;\n    DrivingProfile new_config;\n} DrivingModeCommand;\n\nvoid logVehicleError_fixed(const char* msg) {\n}\n\nDrivingModeCommand receiveDrivingModeCommand_fixed() {\n    DrivingModeCommand cmd;\n    cmd.command_type = 0x01;\n    cmd.profile_id = 7;\n    cmd.new_config.speed_limit = 180;\n    cmd.new_config.throttle_response = 0xFF;\n    cmd.new_config.suspension_mode = 0x02;\n    cmd.new_config.traction_control_active = false;\n    return cmd;\n}\n\nvoid initializeDrivingProfiles_fixed() {\n    for (uint8_t i = 0; i < MAX_DRIVING_PROFILES; ++i) {\n        g_drivingProfiles_fixed[i] = (DrivingProfile){0, 0, 0, false};\n    }\n    for (uint8_t i = 0; i < g_currentActiveProfiles_fixed; ++i) {\n        g_drivingProfiles_fixed[i].speed_limit = 120 + (i * 10);\n        g_drivingProfiles_fixed[i].throttle_response = 0x50 + (i * 0x10);\n        g_drivingProfiles_fixed[i].suspension_mode = i % 3;\n        g_drivingProfiles_fixed[i].traction_control_active = true;\n    }\n}\n\nvoid processDrivingModeCommand_fixed() {\n    DrivingModeCommand cmd = receiveDrivingModeCommand_fixed();\n\n    if (cmd.command_type == 0x01) {\n        if (cmd.profile_id < g_currentActiveProfiles_fixed) {\n            g_drivingProfiles_fixed[cmd.profile_id] = cmd.new_config;\n            logVehicleError_fixed(\"Driving profile updated successfully.\");\n        } else {\n            logVehicleError_fixed(\"Profile ID out of active profile bounds.\");\n        }\n    } else if (cmd.command_type == 0x02) {\n        if (cmd.profile_id < g_currentActiveProfiles_fixed) {\n            DrivingProfile queriedProfile = g_drivingProfiles_fixed[cmd.profile_id];\n            logVehicleError_fixed(\"Driving profile queried.\");\n        } else {\n            logVehicleError_fixed(\"Profile ID out of active profile bounds for query.\");\n        }\n    } else {\n        logVehicleError_fixed(\"Unknown driving mode command type.\");\n    }\n}\n\nvoid vehicleControlMain_fixed() {\n    initializeDrivingProfiles_fixed();\n    processDrivingModeCommand_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_FAULT_CATEGORIES        4\n#define MAX_FAULTS_PER_CATEGORY_GLOBAL 30\n\ntypedef uint8_t FaultStatus;\n#define FAULT_STATUS_ACTIVE    0x01\n#define FAULT_STATUS_INACTIVE  0x00\n\nstatic FaultStatus g_faultStatusData[MAX_FAULT_CATEGORIES][MAX_FAULTS_PER_CATEGORY_GLOBAL];\n\nstatic const uint8_t g_actualFaultCountPerCategory[MAX_FAULT_CATEGORIES] = {\n    10,\n    25,\n    5,\n    15\n};\n\nvoid logEvent(const char* msg) {\n}\n\nuint16_t receiveDiagnosticFaultReport_vulnerable() {\n    return 0x020A;\n}\n\nvoid initializeFaultSystem_vulnerable() {\n    for (uint8_t i = 0; i < MAX_FAULT_CATEGORIES; ++i) {\n        for (uint8_t j = 0; j < MAX_FAULTS_PER_CATEGORY_GLOBAL; ++j) {\n            g_faultStatusData[i][j] = FAULT_STATUS_INACTIVE;\n        }\n    }\n    logEvent(\"Fault system initialized.\");\n}\n\nvoid updateFaultStatus_vulnerable() {\n    uint16_t reportedFaultId = receiveDiagnosticFaultReport_vulnerable();\n\n    uint8_t categoryIdx = (uint8_t)((reportedFaultId >> 8) & 0xFF);\n    uint8_t faultIdxWithinCategory = (uint8_t)(reportedFaultId & 0xFF);\n\n    if (categoryIdx < MAX_FAULT_CATEGORIES) {\n        if (faultIdxWithinCategory < MAX_FAULTS_PER_CATEGORY_GLOBAL) {\n            g_faultStatusData[categoryIdx][faultIdxWithinCategory] = FAULT_STATUS_ACTIVE;\n            logEvent(\"Fault status updated.\");\n        } else {\n            logEvent(\"Attempt to update fault with global out-of-bounds index. Ignored.\");\n        }\n    } else {\n        logEvent(\"Attempt to update fault with invalid category ID. Ignored.\");\n    }\n}\n\nvoid faultManagementModule_vulnerable() {\n    initializeFaultSystem_vulnerable();\n    updateFaultStatus_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_FAULT_CATEGORIES        4\n#define MAX_FAULTS_PER_CATEGORY_GLOBAL 30\n\ntypedef uint8_t FaultStatus;\n#define FAULT_STATUS_ACTIVE    0x01\n#define FAULT_STATUS_INACTIVE  0x00\n\nstatic FaultStatus g_faultStatusData[MAX_FAULT_CATEGORIES][MAX_FAULTS_PER_CATEGORY_GLOBAL];\n\nstatic const uint8_t g_actualFaultCountPerCategory[MAX_FAULT_CATEGORIES] = {\n    10,\n    25,\n    5,\n    15\n};\n\nvoid logEvent(const char* msg) {\n}\n\nuint16_t receiveDiagnosticFaultReport_fixed() {\n    return 0x020A;\n}\n\nvoid initializeFaultSystem_fixed() {\n    for (uint8_t i = 0; i < MAX_FAULT_CATEGORIES; ++i) {\n        for (uint8_t j = 0; j < MAX_FAULTS_PER_CATEGORY_GLOBAL; ++j) {\n            g_faultStatusData[i][j] = FAULT_STATUS_INACTIVE;\n        }\n    }\n    logEvent(\"Fault system initialized.\");\n}\n\nvoid updateFaultStatus_fixed() {\n    uint16_t reportedFaultId = receiveDiagnosticFaultReport_fixed();\n\n    uint8_t categoryIdx = (uint8_t)((reportedFaultId >> 8) & 0xFF);\n    uint8_t faultIdxWithinCategory = (uint8_t)(reportedFaultId & 0xFF);\n\n    if (categoryIdx < MAX_FAULT_CATEGORIES) {\n        if (faultIdxWithinCategory < g_actualFaultCountPerCategory[categoryIdx]) {\n            g_faultStatusData[categoryIdx][faultIdxWithinCategory] = FAULT_STATUS_ACTIVE;\n            logEvent(\"Fault status updated.\");\n        } else {\n            logEvent(\"Attempt to update fault with category-specific out-of-bounds index. Ignored.\");\n        }\n    } else {\n        logEvent(\"Attempt to update fault with invalid category ID. Ignored.\");\n    }\n}\n\nvoid faultManagementModule_fixed() {\n    initializeFaultSystem_fixed();\n    updateFaultStatus_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_DRIVING_PROFILES 3\n#define MAX_PARAMS_PER_PROFILE 10\n\ntypedef struct {\n    uint16_t value;\n    uint8_t type;\n} ProfileParameter;\n\ntypedef struct {\n    ProfileParameter params[MAX_PARAMS_PER_PROFILE];\n    uint8_t active_param_count;\n} DrivingProfile;\n\nstatic DrivingProfile g_drivingProfiles[MAX_DRIVING_PROFILES];\n\nvoid logSystemEvent(const char* message) {\n}\n\ntypedef struct {\n    uint8_t profile_idx;\n    uint8_t parameter_idx;\n    uint16_t new_param_value;\n} DiagnosticMessage;\n\nvoid initializeDrivingProfiles_vulnerable() {\n    g_drivingProfiles[0].active_param_count = 5;\n    for (int i = 0; i < g_drivingProfiles[0].active_param_count; ++i) {\n        g_drivingProfiles[0].params[i].value = 100 + i;\n        g_drivingProfiles[0].params[i].type = i % 2;\n    }\n\n    g_drivingProfiles[1].active_param_count = 8;\n    for (int i = 0; i < g_drivingProfiles[1].active_param_count; ++i) {\n        g_drivingProfiles[1].params[i].value = 200 + i;\n        g_drivingProfiles[1].params[i].type = i % 2;\n    }\n\n    g_drivingProfiles[2].active_param_count = 3;\n    for (int i = 0; i < g_drivingProfiles[2].active_param_count; ++i) {\n        g_drivingProfiles[2].params[i].value = 300 + i;\n        g_drivingProfiles[2].params[i].type = i % 2;\n    }\n\n    for (int p = 0; p < MAX_DRIVING_PROFILES; ++p) {\n        for (int i = g_drivingProfiles[p].active_param_count; i < MAX_PARAMS_PER_PROFILE; ++i) {\n            g_drivingProfiles[p].params[i].value = 0;\n            g_drivingProfiles[p].params[i].type = 0;\n        }\n    }\n    logSystemEvent(\"Driving profiles initialized (vulnerable).\");\n}\n\nDiagnosticMessage receiveDiagnosticMessage_vulnerable() {\n    DiagnosticMessage msg;\n    msg.profile_idx = 1;\n    msg.parameter_idx = 8;\n    msg.new_param_value = 0xABCD;\n    return msg;\n}\n\nvoid updateProfileParameter_vulnerable() {\n    DiagnosticMessage msg = receiveDiagnosticMessage_vulnerable();\n\n    if (msg.profile_idx < MAX_DRIVING_PROFILES) {\n        if (msg.parameter_idx < MAX_PARAMS_PER_PROFILE) {\n            g_drivingProfiles[msg.profile_idx].params[msg.parameter_idx].value = msg.new_param_value;\n            logSystemEvent(\"Profile parameter updated (vulnerable).\");\n        } else {\n            logSystemEvent(\"Invalid parameter index received (vulnerable).\");\n        }\n    } else {\n        logSystemEvent(\"Invalid profile index received (vulnerable).\");\n    }\n}\n\nvoid automotiveProfileManager_vulnerable_main() {\n    initializeDrivingProfiles_vulnerable();\n    updateProfileParameter_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_DRIVING_PROFILES 3\n#define MAX_PARAMS_PER_PROFILE 10\n\ntypedef struct {\n    uint16_t value;\n    uint8_t type;\n} ProfileParameter;\n\ntypedef struct {\n    ProfileParameter params[MAX_PARAMS_PER_PROFILE];\n    uint8_t active_param_count;\n} DrivingProfile;\n\nstatic DrivingProfile g_drivingProfiles[MAX_DRIVING_PROFILES];\n\nvoid logSystemEvent(const char* message) {\n}\n\ntypedef struct {\n    uint8_t profile_idx;\n    uint8_t parameter_idx;\n    uint16_t new_param_value;\n} DiagnosticMessage;\n\nvoid initializeDrivingProfiles_fixed() {\n    g_drivingProfiles[0].active_param_count = 5;\n    for (int i = 0; i < g_drivingProfiles[0].active_param_count; ++i) {\n        g_drivingProfiles[0].params[i].value = 100 + i;\n        g_drivingProfiles[0].params[i].type = i % 2;\n    }\n\n    g_drivingProfiles[1].active_param_count = 8;\n    for (int i = 0; i < g_drivingProfiles[1].active_param_count; ++i) {\n        g_drivingProfiles[1].params[i].value = 200 + i;\n        g_drivingProfiles[1].params[i].type = i % 2;\n    }\n\n    g_drivingProfiles[2].active_param_count = 3;\n    for (int i = 0; i < g_drivingProfiles[2].active_param_count; ++i) {\n        g_drivingProfiles[2].params[i].value = 300 + i;\n        g_drivingProfiles[2].params[i].type = i % 2;\n    }\n\n    for (int p = 0; p < MAX_DRIVING_PROFILES; ++p) {\n        for (int i = g_drivingProfiles[p].active_param_count; i < MAX_PARAMS_PER_PROFILE; ++i) {\n            g_drivingProfiles[p].params[i].value = 0;\n            g_drivingProfiles[p].params[i].type = 0;\n        }\n    }\n    logSystemEvent(\"Driving profiles initialized (fixed).\");\n}\n\nDiagnosticMessage receiveDiagnosticMessage_fixed() {\n    DiagnosticMessage msg;\n    msg.profile_idx = 1;\n    msg.parameter_idx = 8;\n    msg.new_param_value = 0xABCD;\n    return msg;\n}\n\nvoid updateProfileParameter_fixed() {\n    DiagnosticMessage msg = receiveDiagnosticMessage_fixed();\n\n    if (msg.profile_idx < MAX_DRIVING_PROFILES) {\n        if (msg.parameter_idx < g_drivingProfiles[msg.profile_idx].active_param_count) {\n            g_drivingProfiles[msg.profile_idx].params[msg.parameter_idx].value = msg.new_param_value;\n            logSystemEvent(\"Profile parameter updated (fixed).\");\n        } else {\n            logSystemEvent(\"Parameter index out of actual bounds for selected profile (fixed).\");\n        }\n    } else {\n        logSystemEvent(\"Invalid profile index received (fixed).\");\n    }\n}\n\nvoid automotiveProfileManager_fixed_main() {\n    initializeDrivingProfiles_fixed();\n    updateProfileParameter_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define VEHICLE_EVENT_LOG_BUFFER_SIZE 1024 \n#define FIXED_RECORD_PAYLOAD_SIZE 32 \n#define LOG_RECORD_TOTAL_SIZE (sizeof(uint16_t) + FIXED_RECORD_PAYLOAD_SIZE) \n#define NUM_EVENT_LOG_TYPES 5 \n\nstatic uint8_t g_eventLogBuffer_vulnerable[VEHICLE_EVENT_LOG_BUFFER_SIZE];\n\ntypedef struct {\n    uint16_t start_byte_offset;   \n    uint16_t max_records;         \n    uint16_t current_record_idx;  \n} EventLogSegmentInfo_vulnerable;\n\nstatic EventLogSegmentInfo_vulnerable g_logSegmentTable_vulnerable[NUM_EVENT_LOG_TYPES];\n\nvoid vehicleSystemLog_vulnerable(const char* message) {\n}\n\ntypedef struct {\n    uint8_t  eventTypeID;\n    uint16_t timestamp;\n    uint8_t  payload[FIXED_RECORD_PAYLOAD_SIZE];\n} IncomingLogRequest_vulnerable;\n\nIncomingLogRequest_vulnerable simulateIncomingLogRequest_vulnerable() {\n    IncomingLogRequest_vulnerable req;\n    req.eventTypeID = 3; \n    req.timestamp = 0xABCD;\n    for (int i = 0; i < FIXED_RECORD_PAYLOAD_SIZE; ++i) {\n        req.payload[i] = (uint8_t)(0xAA + i);\n    }\n    return req;\n}\n\nvoid initializeEventLogSystem_vulnerable() {\n    g_logSegmentTable_vulnerable[0] = (EventLogSegmentInfo_vulnerable){0, 5, 0};\n    g_logSegmentTable_vulnerable[1] = (EventLogSegmentInfo_vulnerable){170, 10, 0};\n    g_logSegmentTable_vulnerable[2] = (EventLogSegmentInfo_vulnerable){510, 8, 0};\n    g_logSegmentTable_vulnerable[3] = (EventLogSegmentInfo_vulnerable){782, 3, 0};\n    g_logSegmentTable_vulnerable[4] = (EventLogSegmentInfo_vulnerable){884, 4, 0};\n\n    for (int i = 0; i < VEHICLE_EVENT_LOG_BUFFER_SIZE; ++i) {\n        g_eventLogBuffer_vulnerable[i] = 0;\n    }\n    vehicleSystemLog_vulnerable(\"Event log system initialized.\");\n}\n\nvoid processAndStoreEvent_vulnerable() {\n    IncomingLogRequest_vulnerable req = simulateIncomingLogRequest_vulnerable();\n\n    if (req.eventTypeID >= NUM_EVENT_LOG_TYPES) {\n        vehicleSystemLog_vulnerable(\"Received log request with invalid event type ID.\");\n        return;\n    }\n\n    EventLogSegmentInfo_vulnerable* segment = &g_logSegmentTable_vulnerable[req.eventTypeID];\n\n    uint16_t target_physical_offset = segment->start_byte_offset +\n                                     (segment->current_record_idx * LOG_RECORD_TOTAL_SIZE);\n\n    if ((target_physical_offset + LOG_RECORD_TOTAL_SIZE) <= VEHICLE_EVENT_LOG_BUFFER_SIZE) {\n        *(uint16_t*)(g_eventLogBuffer_vulnerable + target_physical_offset) = req.timestamp;\n        for (int i = 0; i < FIXED_RECORD_PAYLOAD_SIZE; ++i) {\n            g_eventLogBuffer_vulnerable[target_physical_offset + sizeof(uint16_t) + i] = req.payload[i];\n        }\n        segment->current_record_idx++; \n        vehicleSystemLog_vulnerable(\"Event log entry stored.\");\n    } else {\n        vehicleSystemLog_vulnerable(\"Error: Event log buffer exhausted or physical address invalid.\");\n    }\n}\n\nvoid vehicleMainLoop_vulnerable() {\n    initializeEventLogSystem_vulnerable();\n\n    processAndStoreEvent_vulnerable(); \n    processAndStoreEvent_vulnerable(); \n    processAndStoreEvent_vulnerable(); \n    processAndStoreEvent_vulnerable(); \n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define VEHICLE_EVENT_LOG_BUFFER_SIZE 1024 \n#define FIXED_RECORD_PAYLOAD_SIZE 32 \n#define LOG_RECORD_TOTAL_SIZE (sizeof(uint16_t) + FIXED_RECORD_PAYLOAD_SIZE) \n#define NUM_EVENT_LOG_TYPES 5 \n\nstatic uint8_t g_eventLogBuffer_fixed[VEHICLE_EVENT_LOG_BUFFER_SIZE];\n\ntypedef struct {\n    uint16_t start_byte_offset;   \n    uint16_t max_records;         \n    uint16_t current_record_idx;  \n} EventLogSegmentInfo_fixed;\n\nstatic EventLogSegmentInfo_fixed g_logSegmentTable_fixed[NUM_EVENT_LOG_TYPES];\n\nvoid vehicleSystemLog_fixed(const char* message) {\n}\n\ntypedef struct {\n    uint8_t  eventTypeID;\n    uint16_t timestamp;\n    uint8_t  payload[FIXED_RECORD_PAYLOAD_SIZE];\n} IncomingLogRequest_fixed;\n\nIncomingLogRequest_fixed simulateIncomingLogRequest_fixed() {\n    IncomingLogRequest_fixed req;\n    req.eventTypeID = 3; \n    req.timestamp = 0xABCD;\n    for (int i = 0; i < FIXED_RECORD_PAYLOAD_SIZE; ++i) {\n        req.payload[i] = (uint8_t)(0xAA + i);\n    }\n    return req;\n}\n\nvoid initializeEventLogSystem_fixed() {\n    g_logSegmentTable_fixed[0] = (EventLogSegmentInfo_fixed){0, 5, 0};\n    g_logSegmentTable_fixed[1] = (EventLogSegmentInfo_fixed){170, 10, 0};\n    g_logSegmentTable_fixed[2] = (EventLogSegmentInfo_fixed){510, 8, 0};\n    g_logSegmentTable_fixed[3] = (EventLogSegmentInfo_fixed){782, 3, 0};\n    g_logSegmentTable_fixed[4] = (EventLogSegmentInfo_fixed){884, 4, 0};\n\n    for (int i = 0; i < VEHICLE_EVENT_LOG_BUFFER_SIZE; ++i) {\n        g_eventLogBuffer_fixed[i] = 0;\n    }\n    vehicleSystemLog_fixed(\"Event log system initialized.\");\n}\n\nvoid processAndStoreEvent_fixed() {\n    IncomingLogRequest_fixed req = simulateIncomingLogRequest_fixed();\n\n    if (req.eventTypeID >= NUM_EVENT_LOG_TYPES) {\n        vehicleSystemLog_fixed(\"Received log request with invalid event type ID.\");\n        return;\n    }\n\n    EventLogSegmentInfo_fixed* segment = &g_logSegmentTable_fixed[req.eventTypeID];\n\n    if (segment->current_record_idx >= segment->max_records) {\n        vehicleSystemLog_fixed(\"Error: Event log segment for this type is full.\");\n        return;\n    }\n\n    uint16_t target_physical_offset = segment->start_byte_offset +\n                                     (segment->current_record_idx * LOG_RECORD_TOTAL_SIZE);\n\n    if ((target_physical_offset + LOG_RECORD_TOTAL_SIZE) <= VEHICLE_EVENT_LOG_BUFFER_SIZE) {\n        *(uint16_t*)(g_eventLogBuffer_fixed + target_physical_offset) = req.timestamp;\n        for (int i = 0; i < FIXED_RECORD_PAYLOAD_SIZE; ++i) {\n            g_eventLogBuffer_fixed[target_physical_offset + sizeof(uint16_t) + i] = req.payload[i];\n        }\n        segment->current_record_idx++;\n        vehicleSystemLog_fixed(\"Event log entry stored.\");\n    } else {\n        vehicleSystemLog_fixed(\"Internal Error: Calculated physical offset exceeds total buffer size.\");\n    }\n}\n\nvoid vehicleMainLoop_fixed() {\n    initializeEventLogSystem_fixed();\n\n    processAndStoreEvent_fixed();\n    processAndStoreEvent_fixed();\n    processAndStoreEvent_fixed();\n    processAndStoreEvent_fixed(); \n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define TOTAL_SENSOR_DATA_POOL_SIZE 256\n#define SENSOR_TYPE_COUNT 3\n#define READING_SIZE sizeof(int16_t)\n\ntypedef enum {\n    SENSOR_TYPE_TEMPERATURE = 0,\n    SENSOR_TYPE_PRESSURE,\n    SENSOR_TYPE_HUMIDITY\n} SensorType;\n\nstatic uint8_t g_sensorDataPool_vulnerable[TOTAL_SENSOR_DATA_POOL_SIZE];\n\nstatic uint16_t g_sensorTypeDataStartOffset_vulnerable[SENSOR_TYPE_COUNT];\n\nstatic uint16_t g_sensorTypeDataCapacity_vulnerable[SENSOR_TYPE_COUNT];\n\nvoid logSystemAlert(const char* msg) {\n}\n\ntypedef struct {\n    SensorType type;\n    uint16_t   reading_index;\n    int16_t    value;\n} SensorUpdateCommand_vulnerable;\n\nSensorUpdateCommand_vulnerable getIncomingSensorUpdate_vulnerable() {\n    SensorUpdateCommand_vulnerable cmd;\n    cmd.type = SENSOR_TYPE_TEMPERATURE;\n    cmd.reading_index = 40;\n    cmd.value = 0xAAAA;\n    return cmd;\n}\n\nvoid initializeSensorDataManager_vulnerable() {\n    g_sensorTypeDataStartOffset_vulnerable[SENSOR_TYPE_TEMPERATURE] = 0;\n    g_sensorTypeDataCapacity_vulnerable[SENSOR_TYPE_TEMPERATURE] = 30;\n\n    g_sensorTypeDataStartOffset_vulnerable[SENSOR_TYPE_PRESSURE] = 60;\n    g_sensorTypeDataCapacity_vulnerable[SENSOR_TYPE_PRESSURE] = 50;\n\n    g_sensorTypeDataStartOffset_vulnerable[SENSOR_TYPE_HUMIDITY] = 160;\n    g_sensorTypeDataCapacity_vulnerable[SENSOR_TYPE_HUMIDITY] = 40;\n\n    for (uint16_t i = 0; i < TOTAL_SENSOR_DATA_POOL_SIZE; ++i) {\n        g_sensorDataPool_vulnerable[i] = 0;\n    }\n\n    logSystemAlert(\"Sensor data manager initialized (vulnerable).\");\n}\n\nvoid processSensorUpdateCommand_vulnerable() {\n    SensorUpdateCommand_vulnerable cmd = getIncomingSensorUpdate_vulnerable();\n\n    if (cmd.type >= SENSOR_TYPE_COUNT) {\n        logSystemAlert(\"Error: Invalid sensor type in update command.\");\n        return;\n    }\n\n    uint16_t base_offset = g_sensorTypeDataStartOffset_vulnerable[cmd.type];\n    uint16_t target_byte_offset = base_offset + (cmd.reading_index * READING_SIZE);\n\n    if (target_byte_offset + READING_SIZE <= TOTAL_SENSOR_DATA_POOL_SIZE) {\n        *(int16_t*)(g_sensorDataPool_vulnerable + target_byte_offset) = cmd.value;\n        logSystemAlert(\"Sensor reading updated (vulnerable).\");\n    } else {\n        logSystemAlert(\"Error: Calculated offset out of global sensor data pool bounds.\");\n    }\n}\n\nvoid main_vehicle_sensor_system_vulnerable() {\n    initializeSensorDataManager_vulnerable();\n    processSensorUpdateCommand_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define TOTAL_SENSOR_DATA_POOL_SIZE 256\n#define SENSOR_TYPE_COUNT 3\n#define READING_SIZE sizeof(int16_t)\n\ntypedef enum {\n    SENSOR_TYPE_TEMPERATURE = 0,\n    SENSOR_TYPE_PRESSURE,\n    SENSOR_TYPE_HUMIDITY\n} SensorType;\n\nstatic uint8_t g_sensorDataPool_fixed[TOTAL_SENSOR_DATA_POOL_SIZE];\n\nstatic uint16_t g_sensorTypeDataStartOffset_fixed[SENSOR_TYPE_COUNT];\n\nstatic uint16_t g_sensorTypeDataCapacity_fixed[SENSOR_TYPE_COUNT];\n\nvoid logSystemAlert_fixed(const char* msg) {\n}\n\ntypedef struct {\n    SensorType type;\n    uint16_t   reading_index;\n    int16_t    value;\n} SensorUpdateCommand_fixed;\n\nSensorUpdateCommand_fixed getIncomingSensorUpdate_fixed() {\n    SensorUpdateCommand_fixed cmd;\n    cmd.type = SENSOR_TYPE_TEMPERATURE;\n    cmd.reading_index = 40;\n    cmd.value = 0xAAAA;\n    return cmd;\n}\n\nvoid initializeSensorDataManager_fixed() {\n    g_sensorTypeDataStartOffset_fixed[SENSOR_TYPE_TEMPERATURE] = 0;\n    g_sensorTypeDataCapacity_fixed[SENSOR_TYPE_TEMPERATURE] = 30;\n\n    g_sensorTypeDataStartOffset_fixed[SENSOR_TYPE_PRESSURE] = 60;\n    g_sensorTypeDataCapacity_fixed[SENSOR_TYPE_PRESSURE] = 50;\n\n    g_sensorTypeDataStartOffset_fixed[SENSOR_TYPE_HUMIDITY] = 160;\n    g_sensorTypeDataCapacity_fixed[SENSOR_TYPE_HUMIDITY] = 40;\n\n    for (uint16_t i = 0; i < TOTAL_SENSOR_DATA_POOL_SIZE; ++i) {\n        g_sensorDataPool_fixed[i] = 0;\n    }\n\n    logSystemAlert_fixed(\"Sensor data manager initialized (fixed).\");\n}\n\nvoid processSensorUpdateCommand_fixed() {\n    SensorUpdateCommand_fixed cmd = getIncomingSensorUpdate_fixed();\n\n    if (cmd.type >= SENSOR_TYPE_COUNT) {\n        logSystemAlert_fixed(\"Error: Invalid sensor type in update command.\");\n        return;\n    }\n\n    if (cmd.reading_index >= g_sensorTypeDataCapacity_fixed[cmd.type]) {\n        logSystemAlert_fixed(\"Error: Reading index out of bounds for specified sensor type.\");\n        return;\n    }\n\n    uint16_t base_offset = g_sensorTypeDataStartOffset_fixed[cmd.type];\n    uint16_t target_byte_offset = base_offset + (cmd.reading_index * READING_SIZE);\n\n    if (target_byte_offset + READING_SIZE <= TOTAL_SENSOR_DATA_POOL_SIZE) {\n        *(int16_t*)(g_sensorDataPool_fixed + target_byte_offset) = cmd.value;\n        logSystemAlert_fixed(\"Sensor reading updated (fixed).\");\n    } else {\n        logSystemAlert_fixed(\"Internal error: Calculated offset exceeds total sensor data pool size.\");\n    }\n}\n\nvoid main_vehicle_sensor_system_fixed() {\n    initializeSensorDataManager_fixed();\n    processSensorUpdateCommand_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define DTC_TYPE_ENGINE 0\n#define DTC_TYPE_TRANSMISSION 1\n#define DTC_TYPE_BRAKE 2\n#define MAX_DTC_TYPES 3\n\n#define GLOBAL_MAX_INSTANCES_PER_DTC 5\n\ntypedef struct {\n    uint16_t code;\n    uint8_t  instance_id;\n    uint32_t timestamp;\n    uint8_t  status;\n} DTC_Entry;\n\nstatic DTC_Entry g_dtcHistory_vulnerable[MAX_DTC_TYPES][GLOBAL_MAX_INSTANCES_PER_DTC];\n\nstatic const uint8_t g_dtcCapacities[MAX_DTC_TYPES] = {\n    3, \n    2, \n    4  \n};\n\nvoid logECUError_vulnerable(const char* msg) {\n    fprintf(stderr, \"ECU_LOG_VULN: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t dtc_type_id;\n    uint8_t instance_idx;\n    uint16_t dtc_code;\n    uint8_t dtc_status;\n} IncomingDTC_Message_Vulnerable;\n\nIncomingDTC_Message_Vulnerable receiveDiagnosticMessage_vulnerable() {\n    IncomingDTC_Message_Vulnerable msg;\n    msg.dtc_type_id = DTC_TYPE_TRANSMISSION;\n    msg.instance_idx = 2;\n    msg.dtc_code = 0xDEAD;\n    msg.dtc_status = 0x01;\n    return msg;\n}\n\nvoid initializeDTCStorage_vulnerable() {\n    for (uint8_t i = 0; i < MAX_DTC_TYPES; ++i) {\n        for (uint8_t j = 0; j < GLOBAL_MAX_INSTANCES_PER_DTC; ++j) {\n            g_dtcHistory_vulnerable[i][j] = (DTC_Entry){0, 0, 0, 0};\n        }\n    }\n    logECUError_vulnerable(\"DTC history storage initialized.\");\n}\n\nvoid processDiagnosticMessage_vulnerable() {\n    IncomingDTC_Message_Vulnerable msg = receiveDiagnosticMessage_vulnerable();\n    uint32_t current_timestamp = 12345;\n\n    if (msg.dtc_type_id < MAX_DTC_TYPES) {\n        if (msg.instance_idx < GLOBAL_MAX_INSTANCES_PER_DTC) {\n            g_dtcHistory_vulnerable[msg.dtc_type_id][msg.instance_idx].code = msg.dtc_code;\n            g_dtcHistory_vulnerable[msg.dtc_type_id][msg.instance_idx].instance_id = msg.instance_idx;\n            g_dtcHistory_vulnerable[msg.dtc_type_id][msg.instance_idx].timestamp = current_timestamp;\n            g_dtcHistory_vulnerable[msg.dtc_type_id][msg.instance_idx].status = msg.dtc_status;\n            logECUError_vulnerable(\"DTC entry processed (vulnerable).\");\n        } else {\n            logECUError_vulnerable(\"DTC instance index exceeds global maximum instances.\");\n        }\n    } else {\n        logECUError_vulnerable(\"Invalid DTC type ID received.\");\n    }\n}\n\nvoid automotiveDiagnosticModule_vulnerable_main() {\n    initializeDTCStorage_vulnerable();\n    processDiagnosticMessage_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define DTC_TYPE_ENGINE 0\n#define DTC_TYPE_TRANSMISSION 1\n#define DTC_TYPE_BRAKE 2\n#define MAX_DTC_TYPES 3\n\n#define GLOBAL_MAX_INSTANCES_PER_DTC 5\n\ntypedef struct {\n    uint16_t code;\n    uint8_t  instance_id;\n    uint32_t timestamp;\n    uint8_t  status;\n} DTC_Entry;\n\nstatic DTC_Entry g_dtcHistory_fixed[MAX_DTC_TYPES][GLOBAL_MAX_INSTANCES_PER_DTC];\n\nstatic const uint8_t g_dtcCapacities_fixed[MAX_DTC_TYPES] = {\n    3, \n    2, \n    4  \n};\n\nvoid logECUError_fixed(const char* msg) {\n    fprintf(stderr, \"ECU_LOG_FIXED: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t dtc_type_id;\n    uint8_t instance_idx;\n    uint16_t dtc_code;\n    uint8_t dtc_status;\n} IncomingDTC_Message_Fixed;\n\nIncomingDTC_Message_Fixed receiveDiagnosticMessage_fixed() {\n    IncomingDTC_Message_Fixed msg;\n    msg.dtc_type_id = DTC_TYPE_TRANSMISSION;\n    msg.instance_idx = 2;\n    msg.dtc_code = 0xDEAD;\n    msg.dtc_status = 0x01;\n    return msg;\n}\n\nvoid initializeDTCStorage_fixed() {\n    for (uint8_t i = 0; i < MAX_DTC_TYPES; ++i) {\n        for (uint8_t j = 0; j < GLOBAL_MAX_INSTANCES_PER_DTC; ++j) {\n            g_dtcHistory_fixed[i][j] = (DTC_Entry){0, 0, 0, 0};\n        }\n    }\n    logECUError_fixed(\"DTC history storage initialized.\");\n}\n\nvoid processDiagnosticMessage_fixed() {\n    IncomingDTC_Message_Fixed msg = receiveDiagnosticMessage_fixed();\n    uint32_t current_timestamp = 12345;\n\n    if (msg.dtc_type_id < MAX_DTC_TYPES) {\n        if (msg.instance_idx < g_dtcCapacities_fixed[msg.dtc_type_id]) {\n            g_dtcHistory_fixed[msg.dtc_type_id][msg.instance_idx].code = msg.dtc_code;\n            g_dtcHistory_fixed[msg.dtc_type_id][msg.instance_idx].instance_id = msg.instance_idx;\n            g_dtcHistory_fixed[msg.dtc_type_id][msg.instance_idx].timestamp = current_timestamp;\n            g_dtcHistory_fixed[msg.dtc_type_id][msg.instance_idx].status = msg.dtc_status;\n            logECUError_fixed(\"DTC entry processed (fixed).\");\n        } else {\n            logECUError_fixed(\"DTC instance index out of bounds for specified DTC type. Ignoring message.\");\n        }\n    } else {\n        logECUError_fixed(\"Invalid DTC type ID received.\");\n    }\n}\n\nvoid automotiveDiagnosticModule_fixed_main() {\n    initializeDTCStorage_fixed();\n    processDiagnosticMessage_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_FEATURE_GROUPS 8\n#define MAX_FEATURES_PER_GROUP 16\n#define CAN_PAYLOAD_SIZE 8\n\ntypedef struct {\n    uint8_t feature_status_byte;\n    uint16_t feature_config_value;\n} FeatureConfig;\n\nstatic FeatureConfig g_featureConfigurations_vulnerable[MAX_FEATURE_GROUPS][MAX_FEATURES_PER_GROUP];\n\nvoid logVehicleEvent_vulnerable(const char* event_msg) {\n}\n\ntypedef struct {\n    uint16_t message_id;\n    uint8_t data[CAN_PAYLOAD_SIZE];\n    uint8_t data_len;\n} CanMessage;\n\nCanMessage receiveCanMessage_vulnerable() {\n    CanMessage msg;\n    msg.message_id = 0x100;\n    msg.data[0] = 0;\n    msg.data[1] = 20;\n    msg.data[2] = 0xDE;\n    msg.data[3] = 0xAD;\n    msg.data_len = 4;\n    return msg;\n}\n\nvoid initializeFeatureConfigs_vulnerable() {\n    for (uint8_t i = 0; i < MAX_FEATURE_GROUPS; ++i) {\n        for (uint8_t j = 0; j < MAX_FEATURES_PER_GROUP; ++j) {\n            g_featureConfigurations_vulnerable[i][j].feature_status_byte = 0;\n            g_featureConfigurations_vulnerable[i][j].feature_config_value = 0;\n        }\n    }\n    g_featureConfigurations_vulnerable[0][0].feature_config_value = 100;\n    g_featureConfigurations_vulnerable[0][1].feature_config_value = 200;\n}\n\nvoid processCanMessage_vulnerable() {\n    CanMessage msg = receiveCanMessage_vulnerable();\n\n    if (msg.message_id == 0x100) {\n        if (msg.data_len >= 4) {\n            uint8_t group_idx = msg.data[0];\n            uint8_t feature_idx = msg.data[1];\n            uint16_t config_value = (msg.data[2] << 8) | msg.data[3];\n\n            if (group_idx < MAX_FEATURE_GROUPS) {\n                g_featureConfigurations_vulnerable[group_idx][feature_idx].feature_config_value = config_value;\n                g_featureConfigurations_vulnerable[group_idx][feature_idx].feature_status_byte = 0x01;\n                logVehicleEvent_vulnerable(\"Feature configuration updated (vulnerable).\");\n            } else {\n                logVehicleEvent_vulnerable(\"Invalid feature group index in configuration message (vulnerable).\");\n            }\n        } else {\n            logVehicleEvent_vulnerable(\"Insufficient data for feature config update (vulnerable).\");\n        }\n    } else if (msg.message_id == 0x101) {\n        if (msg.data_len >= 2) {\n            uint8_t group_idx = msg.data[0];\n            uint8_t feature_idx = msg.data[1];\n\n            if (group_idx < MAX_FEATURE_GROUPS) {\n                uint8_t current_status = g_featureConfigurations_vulnerable[group_idx][feature_idx].feature_status_byte;\n                logVehicleEvent_vulnerable(\"Feature status queried (vulnerable).\");\n            } else {\n                logVehicleEvent_vulnerable(\"Invalid feature group index in status request (vulnerable).\");\n            }\n        } else {\n            logVehicleEvent_vulnerable(\"Insufficient data for feature status request (vulnerable).\");\n        }\n    } else {\n        logVehicleEvent_vulnerable(\"Unknown CAN message ID received (vulnerable).\");\n    }\n}\n\nvoid main_ecu_loop_vulnerable() {\n    initializeFeatureConfigs_vulnerable();\n    processCanMessage_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_FEATURE_GROUPS 8\n#define MAX_FEATURES_PER_GROUP 16\n#define CAN_PAYLOAD_SIZE 8\n\ntypedef struct {\n    uint8_t feature_status_byte;\n    uint16_t feature_config_value;\n} FeatureConfig;\n\nstatic FeatureConfig g_featureConfigurations_fixed[MAX_FEATURE_GROUPS][MAX_FEATURES_PER_GROUP];\n\nvoid logVehicleEvent_fixed(const char* event_msg) {\n}\n\ntypedef struct {\n    uint16_t message_id;\n    uint8_t data[CAN_PAYLOAD_SIZE];\n    uint8_t data_len;\n} CanMessage;\n\nCanMessage receiveCanMessage_fixed() {\n    CanMessage msg;\n    msg.message_id = 0x100;\n    msg.data[0] = 0;\n    msg.data[1] = 20;\n    msg.data[2] = 0xDE;\n    msg.data[3] = 0xAD;\n    msg.data_len = 4;\n    return msg;\n}\n\nvoid initializeFeatureConfigs_fixed() {\n    for (uint8_t i = 0; i < MAX_FEATURE_GROUPS; ++i) {\n        for (uint8_t j = 0; j < MAX_FEATURES_PER_GROUP; ++j) {\n            g_featureConfigurations_fixed[i][j].feature_status_byte = 0;\n            g_featureConfigurations_fixed[i][j].feature_config_value = 0;\n        }\n    }\n    g_featureConfigurations_fixed[0][0].feature_config_value = 100;\n    g_featureConfigurations_fixed[0][1].feature_config_value = 200;\n}\n\nvoid processCanMessage_fixed() {\n    CanMessage msg = receiveCanMessage_fixed();\n\n    if (msg.message_id == 0x100) {\n        if (msg.data_len >= 4) {\n            uint8_t group_idx = msg.data[0];\n            uint8_t feature_idx = msg.data[1];\n            uint16_t config_value = (msg.data[2] << 8) | msg.data[3];\n\n            if (group_idx < MAX_FEATURE_GROUPS) {\n                if (feature_idx < MAX_FEATURES_PER_GROUP) {\n                    g_featureConfigurations_fixed[group_idx][feature_idx].feature_config_value = config_value;\n                    g_featureConfigurations_fixed[group_idx][feature_idx].feature_status_byte = 0x01;\n                    logVehicleEvent_fixed(\"Feature configuration updated successfully (fixed).\");\n                } else {\n                    logVehicleEvent_fixed(\"Invalid feature index in configuration message. Command ignored (fixed).\");\n                }\n            } else {\n                logVehicleEvent_fixed(\"Invalid feature group index in configuration message. Command ignored (fixed).\");\n            }\n        } else {\n            logVehicleEvent_fixed(\"Insufficient data for feature config update (fixed).\");\n        }\n    } else if (msg.message_id == 0x101) {\n        if (msg.data_len >= 2) {\n            uint8_t group_idx = msg.data[0];\n            uint8_t feature_idx = msg.data[1];\n\n            if (group_idx < MAX_FEATURE_GROUPS) {\n                if (feature_idx < MAX_FEATURES_PER_GROUP) {\n                    uint8_t current_status = g_featureConfigurations_fixed[group_idx][feature_idx].feature_status_byte;\n                    logVehicleEvent_fixed(\"Feature status queried successfully (fixed).\");\n                } else {\n                    logVehicleEvent_fixed(\"Invalid feature index in status request. Command ignored (fixed).\");\n                }\n            } else {\n                logVehicleEvent_fixed(\"Invalid feature group index in status request. Command ignored (fixed).\");\n            }\n        } else {\n            logVehicleEvent_fixed(\"Insufficient data for feature status request (fixed).\");\n        }\n    } else {\n        logVehicleEvent_fixed(\"Unknown CAN message ID received (fixed).\");\n    }\n}\n\nvoid main_ecu_loop_fixed() {\n    initializeFeatureConfigs_fixed();\n    processCanMessage_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_TOTAL_LOG_ENTRIES 200\n\ntypedef struct {\n    uint8_t event_id;\n    uint16_t data_value;\n    uint32_t timestamp;\n} LogEntry;\n\nstatic LogEntry g_vehicleEventLog[MAX_TOTAL_LOG_ENTRIES];\n\ntypedef enum {\n    DOMAIN_POWERTRAIN = 0,\n    DOMAIN_CHASSIS,\n    DOMAIN_BODY,\n    DOMAIN_INFOTAINMENT,\n    DOMAIN_COUNT\n} VehicleDomainType;\n\nstatic const size_t g_domainOffsets[DOMAIN_COUNT] = {\n    0,\n    50,\n    100,\n    150\n};\n\nstatic const size_t g_domainMaxEntries[DOMAIN_COUNT] = {\n    50, 50, 50, 50\n};\n\nstatic size_t g_domainCurrentRelativeIndex[DOMAIN_COUNT];\n\nvoid logSystemCriticalEvent(const char* msg) {\n}\n\nvoid initVehicleLogSystem_vulnerable() {\n    for (int i = 0; i < DOMAIN_COUNT; ++i) {\n        g_domainCurrentRelativeIndex[i] = 0;\n    }\n    for (int i = 0; i < MAX_TOTAL_LOG_ENTRIES; ++i) {\n        g_vehicleEventLog[i] = (LogEntry){0, 0, 0};\n    }\n    logSystemCriticalEvent(\"Vehicle log system initialized.\");\n}\n\nvoid logVehicleDomainEvent_vulnerable(VehicleDomainType domain, uint8_t event_id, uint16_t data_value, uint32_t timestamp) {\n    if (domain >= DOMAIN_COUNT) {\n        logSystemCriticalEvent(\"Attempted to log event for invalid domain.\");\n        return;\n    }\n\n    size_t current_relative_idx = g_domainCurrentRelativeIndex[domain];\n    size_t global_target_idx = g_domainOffsets[domain] + current_relative_idx;\n\n    g_vehicleEventLog[global_target_idx] = (LogEntry){event_id, data_value, timestamp};\n    \n    g_domainCurrentRelativeIndex[domain]++;\n}\n\nvoid simulatePowertrainFaults_vulnerable() {\n    for (int i = 0; i < 60; ++i) {\n        logVehicleDomainEvent_vulnerable(DOMAIN_POWERTRAIN, 0x10 + i, 100 + i, 0x12345000 + i);\n    }\n}\n\nvoid runVulnerableLogSystem() {\n    initVehicleLogSystem_vulnerable();\n    simulatePowertrainFaults_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_TOTAL_LOG_ENTRIES 200\n\ntypedef struct {\n    uint8_t event_id;\n    uint16_t data_value;\n    uint32_t timestamp;\n} LogEntry;\n\nstatic LogEntry g_vehicleEventLog_fixed[MAX_TOTAL_LOG_ENTRIES];\n\ntypedef enum {\n    DOMAIN_POWERTRAIN_FIXED = 0,\n    DOMAIN_CHASSIS_FIXED,\n    DOMAIN_BODY_FIXED,\n    DOMAIN_INFOTAINMENT_FIXED,\n    DOMAIN_COUNT_FIXED\n} VehicleDomainType_Fixed;\n\nstatic const size_t g_domainOffsets_fixed[DOMAIN_COUNT_FIXED] = {\n    0,\n    50,\n    100,\n    150\n};\n\nstatic const size_t g_domainMaxEntries_fixed[DOMAIN_COUNT_FIXED] = {\n    50, 50, 50, 50\n};\n\nstatic size_t g_domainCurrentRelativeIndex_fixed[DOMAIN_COUNT_FIXED];\n\nvoid logSystemCriticalEvent_fixed(const char* msg) {\n}\n\nvoid initVehicleLogSystem_fixed() {\n    for (int i = 0; i < DOMAIN_COUNT_FIXED; ++i) {\n        g_domainCurrentRelativeIndex_fixed[i] = 0;\n    }\n    for (int i = 0; i < MAX_TOTAL_LOG_ENTRIES; ++i) {\n        g_vehicleEventLog_fixed[i] = (LogEntry){0, 0, 0};\n    }\n    logSystemCriticalEvent_fixed(\"Vehicle log system initialized (fixed).\");\n}\n\nvoid logVehicleDomainEvent_fixed(VehicleDomainType_Fixed domain, uint8_t event_id, uint16_t data_value, uint32_t timestamp) {\n    if (domain >= DOMAIN_COUNT_FIXED) {\n        logSystemCriticalEvent_fixed(\"Attempted to log event for invalid domain (fixed).\");\n        return;\n    }\n\n    size_t target_relative_idx = g_domainCurrentRelativeIndex_fixed[domain];\n\n    g_domainCurrentRelativeIndex_fixed[domain] = (g_domainCurrentRelativeIndex_fixed[domain] + 1) % g_domainMaxEntries_fixed[domain];\n\n    size_t global_target_idx = g_domainOffsets_fixed[domain] + target_relative_idx;\n\n    if (global_target_idx >= MAX_TOTAL_LOG_ENTRIES) {\n        logSystemCriticalEvent_fixed(\"Internal error: Calculated global index out of total bounds. Report this bug.\");\n        return;\n    }\n\n    g_vehicleEventLog_fixed[global_target_idx] = (LogEntry){event_id, data_value, timestamp};\n}\n\nvoid simulatePowertrainFaults_fixed() {\n    for (int i = 0; i < 60; ++i) {\n        logVehicleDomainEvent_fixed(DOMAIN_POWERTRAIN_FIXED, 0x10 + i, 100 + i, 0x12345000 + i);\n    }\n}\n\nvoid runFixedLogSystem() {\n    initVehicleLogSystem_fixed();\n    simulatePowertrainFaults_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_ENGINE_MAPS 5\n\ntypedef struct {\n    uint16_t fuel_injection_timing;\n    uint16_t ignition_advance;\n    uint16_t throttle_response_curve_id;\n    uint8_t  turbo_boost_pressure_level;\n} EnginePerformanceMap;\n\nstatic EnginePerformanceMap g_engineMaps_vulnerable[MAX_ENGINE_MAPS];\nstatic uint8_t g_currentEngineMapIndex_vulnerable;\n\nvoid automotiveLog_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    uint32_t can_id;\n    uint8_t  data[8];\n    uint8_t  dlc;\n} CANMessage_vulnerable;\n\nCANMessage_vulnerable receiveCANMessage_vulnerable() {\n    CANMessage_vulnerable msg;\n    msg.can_id = 0x123;\n    msg.data[0] = MAX_ENGINE_MAPS; \n    msg.dlc = 1;\n    return msg;\n}\n\nvoid initializeEngineMaps_vulnerable() {\n    for (uint8_t i = 0; i < MAX_ENGINE_MAPS; ++i) {\n        g_engineMaps_vulnerable[i] = (EnginePerformanceMap){150 + i*10, 20 + i*2, i, (uint8_t)(i % 5)};\n    }\n    g_currentEngineMapIndex_vulnerable = 0;\n    automotiveLog_vulnerable(\"Engine maps initialized.\");\n}\n\nvoid setEngineMode_vulnerable(uint8_t mode_id) {\n    g_currentEngineMapIndex_vulnerable = mode_id;\n    EnginePerformanceMap selectedMap = g_engineMaps_vulnerable[g_currentEngineMapIndex_vulnerable];\n    automotiveLog_vulnerable(\"Engine mode attempted to be set (vulnerable).\");\n}\n\nvoid engineControlUnit_vulnerable_main() {\n    initializeEngineMaps_vulnerable();\n\n    CANMessage_vulnerable command_msg = receiveCANMessage_vulnerable();\n    uint8_t requested_mode_id = command_msg.data[0];\n\n    setEngineMode_vulnerable(requested_mode_id);\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_ENGINE_MAPS 5\n\ntypedef struct {\n    uint16_t fuel_injection_timing;\n    uint16_t ignition_advance;\n    uint16_t throttle_response_curve_id;\n    uint8_t  turbo_boost_pressure_level;\n} EnginePerformanceMap;\n\nstatic EnginePerformanceMap g_engineMaps_fixed[MAX_ENGINE_MAPS];\nstatic uint8_t g_currentEngineMapIndex_fixed;\n\nvoid automotiveLog_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint32_t can_id;\n    uint8_t  data[8];\n    uint8_t  dlc;\n} CANMessage_fixed;\n\nCANMessage_fixed receiveCANMessage_fixed() {\n    CANMessage_fixed msg;\n    msg.can_id = 0x123;\n    msg.data[0] = MAX_ENGINE_MAPS; \n    msg.dlc = 1;\n    return msg;\n}\n\nvoid initializeEngineMaps_fixed() {\n    for (uint8_t i = 0; i < MAX_ENGINE_MAPS; ++i) {\n        g_engineMaps_fixed[i] = (EnginePerformanceMap){150 + i*10, 20 + i*2, i, (uint8_t)(i % 5)};\n    }\n    g_currentEngineMapIndex_fixed = 0;\n    automotiveLog_fixed(\"Engine maps initialized (fixed).\");\n}\n\nvoid setEngineMode_fixed(uint8_t mode_id) {\n    if (mode_id < MAX_ENGINE_MAPS) {\n        g_currentEngineMapIndex_fixed = mode_id;\n        EnginePerformanceMap selectedMap = g_engineMaps_fixed[g_currentEngineMapIndex_fixed];\n        automotiveLog_fixed(\"Engine mode successfully set (fixed).\");\n    } else {\n        automotiveLog_fixed(\"Attempted to set engine mode with an invalid ID. Ignoring command (fixed).\");\n    }\n}\n\nvoid engineControlUnit_fixed_main() {\n    initializeEngineMaps_fixed();\n\n    CANMessage_fixed command_msg = receiveCANMessage_fixed();\n    uint8_t requested_mode_id = command_msg.data[0];\n\n    setEngineMode_fixed(requested_mode_id);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n#define MAX_GEAR_RATIOS 6\n#define MAX_SUSPENSION_SETTINGS 4\n#define MAX_DIAG_THRESHOLDS 8\n\ntypedef enum {\n    VEHICLE_ATTRIBUTE_GEAR_RATIOS = 0,\n    VEHICLE_ATTRIBUTE_SUSPENSION_SETTINGS,\n    VEHICLE_ATTRIBUTE_DIAGNOSTIC_THRESHOLDS,\n    VEHICLE_ATTRIBUTE_COUNT\n} VehicleAttributeType;\n\nstatic float g_gearRatios_vulnerable[MAX_GEAR_RATIOS];\nstatic float g_suspensionSettings_vulnerable[MAX_SUSPENSION_SETTINGS];\nstatic uint16_t g_diagThresholds_vulnerable[MAX_DIAG_THRESHOLDS];\n\ntypedef struct {\n    void*  buffer_ptr;\n    size_t element_size;\n    size_t max_elements;\n} AttributeInfo_vulnerable;\n\nstatic AttributeInfo_vulnerable g_attributeMap_vulnerable[VEHICLE_ATTRIBUTE_COUNT];\n\nvoid logVehicleError(const char* msg) {\n}\n\nvoid logVehicleEvent(const char* msg) {\n}\n\ntypedef struct {\n    VehicleAttributeType type;\n    uint16_t index;\n    uint32_t raw_value;\n} AttributeUpdateCommand_vulnerable;\n\nAttributeUpdateCommand_vulnerable receiveAttributeUpdateCommand_vulnerable() {\n    AttributeUpdateCommand_vulnerable cmd;\n    cmd.type = VEHICLE_ATTRIBUTE_GEAR_RATIOS;\n    cmd.index = MAX_GEAR_RATIOS;\n    cmd.raw_value = (uint32_t)(*(uint32_t*)(&(float){99.9f}));\n    return cmd;\n}\n\nvoid initializeVehicleAttributeSystem_vulnerable() {\n    g_attributeMap_vulnerable[VEHICLE_ATTRIBUTE_GEAR_RATIOS] = (AttributeInfo_vulnerable){\n        .buffer_ptr = g_gearRatios_vulnerable,\n        .element_size = sizeof(float),\n        .max_elements = MAX_GEAR_RATIOS\n    };\n    g_attributeMap_vulnerable[VEHICLE_ATTRIBUTE_SUSPENSION_SETTINGS] = (AttributeInfo_vulnerable){\n        .buffer_ptr = g_suspensionSettings_vulnerable,\n        .element_size = sizeof(float),\n        .max_elements = MAX_SUSPENSION_SETTINGS\n    };\n    g_attributeMap_vulnerable[VEHICLE_ATTRIBUTE_DIAGNOSTIC_THRESHOLDS] = (AttributeInfo_vulnerable){\n        .buffer_ptr = g_diagThresholds_vulnerable,\n        .element_size = sizeof(uint16_t),\n        .max_elements = MAX_DIAG_THRESHOLDS\n    };\n\n    for (int i = 0; i < MAX_GEAR_RATIOS; ++i) g_gearRatios_vulnerable[i] = 1.0f + i * 0.5f;\n    for (int i = 0; i < MAX_SUSPENSION_SETTINGS; ++i) g_suspensionSettings_vulnerable[i] = 10.0f + i * 1.0f;\n    for (int i = 0; i < MAX_DIAG_THRESHOLDS; ++i) g_diagThresholds_vulnerable[i] = 100 + i * 10;\n\n    logVehicleEvent(\"Vehicle attribute system initialized (vulnerable).\");\n}\n\nvoid updateVehicleAttribute_vulnerable(AttributeUpdateCommand_vulnerable cmd) {\n    if (cmd.type < VEHICLE_ATTRIBUTE_COUNT) {\n        AttributeInfo_vulnerable info = g_attributeMap_vulnerable[cmd.type];\n\n        if (info.buffer_ptr != NULL) {\n            if (info.element_size == sizeof(float)) {\n                ((float*)info.buffer_ptr)[cmd.index] = *(float*)&cmd.raw_value;\n                logVehicleEvent(\"Float attribute updated.\");\n            } else if (info.element_size == sizeof(uint16_t)) {\n                ((uint16_t*)info.buffer_ptr)[cmd.index] = (uint16_t)cmd.raw_value;\n                logVehicleEvent(\"Uint16 attribute updated.\");\n            } else {\n                logVehicleError(\"Unsupported element size for attribute buffer.\");\n            }\n        } else {\n            logVehicleError(\"Attribute map entry buffer_ptr is null for valid type.\");\n        }\n    } else {\n        logVehicleError(\"Invalid vehicle attribute type received.\");\n    }\n}\n\nvoid vehicleConfigManager_vulnerable_main() {\n    initializeVehicleAttributeSystem_vulnerable();\n    AttributeUpdateCommand_vulnerable cmd = receiveAttributeUpdateCommand_vulnerable();\n    updateVehicleAttribute_vulnerable(cmd);\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n#define MAX_GEAR_RATIOS 6\n#define MAX_SUSPENSION_SETTINGS 4\n#define MAX_DIAG_THRESHOLDS 8\n\ntypedef enum {\n    VEHICLE_ATTRIBUTE_GEAR_RATIOS = 0,\n    VEHICLE_ATTRIBUTE_SUSPENSION_SETTINGS,\n    VEHICLE_ATTRIBUTE_DIAGNOSTIC_THRESHOLDS,\n    VEHICLE_ATTRIBUTE_COUNT\n} VehicleAttributeType;\n\nstatic float g_gearRatios_fixed[MAX_GEAR_RATIOS];\nstatic float g_suspensionSettings_fixed[MAX_SUSPENSION_SETTINGS];\nstatic uint16_t g_diagThresholds_fixed[MAX_DIAG_THRESHOLDS];\n\ntypedef struct {\n    void*  buffer_ptr;\n    size_t element_size;\n    size_t max_elements;\n} AttributeInfo_fixed;\n\nstatic AttributeInfo_fixed g_attributeMap_fixed[VEHICLE_ATTRIBUTE_COUNT];\n\nvoid logVehicleError(const char* msg) {\n}\n\nvoid logVehicleEvent(const char* msg) {\n}\n\ntypedef struct {\n    VehicleAttributeType type;\n    uint16_t index;\n    uint32_t raw_value;\n} AttributeUpdateCommand_fixed;\n\nAttributeUpdateCommand_fixed receiveAttributeUpdateCommand_fixed() {\n    AttributeUpdateCommand_fixed cmd;\n    cmd.type = VEHICLE_ATTRIBUTE_GEAR_RATIOS;\n    cmd.index = MAX_GEAR_RATIOS;\n    cmd.raw_value = (uint32_t)(*(uint32_t*)(&(float){99.9f}));\n    return cmd;\n}\n\nvoid initializeVehicleAttributeSystem_fixed() {\n    g_attributeMap_fixed[VEHICLE_ATTRIBUTE_GEAR_RATIOS] = (AttributeInfo_fixed){\n        .buffer_ptr = g_gearRatios_fixed,\n        .element_size = sizeof(float),\n        .max_elements = MAX_GEAR_RATIOS\n    };\n    g_attributeMap_fixed[VEHICLE_ATTRIBUTE_SUSPENSION_SETTINGS] = (AttributeInfo_fixed){\n        .buffer_ptr = g_suspensionSettings_fixed,\n        .element_size = sizeof(float),\n        .max_elements = MAX_SUSPENSION_SETTINGS\n    };\n    g_attributeMap_fixed[VEHICLE_ATTRIBUTE_DIAGNOSTIC_THRESHOLDS] = (AttributeInfo_fixed){\n        .buffer_ptr = g_diagThresholds_fixed,\n        .element_size = sizeof(uint16_t),\n        .max_elements = MAX_DIAG_THRESHOLDS\n    };\n\n    for (int i = 0; i < MAX_GEAR_RATIOS; ++i) g_gearRatios_fixed[i] = 1.0f + i * 0.5f;\n    for (int i = 0; i < MAX_SUSPENSION_SETTINGS; ++i) g_suspensionSettings_fixed[i] = 10.0f + i * 1.0f;\n    for (int i = 0; i < MAX_DIAG_THRESHOLDS; ++i) g_diagThresholds_fixed[i] = 100 + i * 10;\n\n    logVehicleEvent(\"Vehicle attribute system initialized (fixed).\");\n}\n\nvoid updateVehicleAttribute_fixed(AttributeUpdateCommand_fixed cmd) {\n    if (cmd.type < VEHICLE_ATTRIBUTE_COUNT) {\n        AttributeInfo_fixed info = g_attributeMap_fixed[cmd.type];\n\n        if (info.buffer_ptr != NULL) {\n            if (cmd.index < info.max_elements) {\n                if (info.element_size == sizeof(float)) {\n                    ((float*)info.buffer_ptr)[cmd.index] = *(float*)&cmd.raw_value;\n                    logVehicleEvent(\"Float attribute updated (fixed).\");\n                } else if (info.element_size == sizeof(uint16_t)) {\n                    ((uint16_t*)info.buffer_ptr)[cmd.index] = (uint16_t)cmd.raw_value;\n                    logVehicleEvent(\"Uint16 attribute updated (fixed).\");\n                } else {\n                    logVehicleError(\"Unsupported element size for attribute buffer (fixed).\");\n                }\n            } else {\n                logVehicleError(\"Attribute update index out of bounds for its type (fixed).\");\n            }\n        } else {\n            logVehicleError(\"Attribute map entry buffer_ptr is null for valid type (fixed).\");\n        }\n    } else {\n        logVehicleError(\"Invalid vehicle attribute type received (fixed).\");\n    }\n}\n\nvoid vehicleConfigManager_fixed_main() {\n    initializeVehicleAttributeSystem_fixed();\n    AttributeUpdateCommand_fixed cmd = receiveAttributeUpdateCommand_fixed();\n    updateVehicleAttribute_fixed(cmd);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define NUM_SUB_MODULES 3\n#define MAX_ENGINE_PARAMS 20\n#define MAX_TRANSMISSION_PARAMS 10\n#define MAX_INFOTAINMENT_PARAMS 5\n\ntypedef enum {\n    SUB_MODULE_ENGINE = 0,\n    SUB_MODULE_TRANSMISSION,\n    SUB_MODULE_INFOTAINMENT,\n    SUB_MODULE_INVALID\n} SubModuleID;\n\ntypedef struct {\n    SubModuleID module_id;\n    uint8_t     parameter_index;\n    uint32_t    new_value;\n    uint8_t     command_type;\n} DiagnosticCommand_Vulnerable;\n\nstatic uint32_t g_engineParameters[MAX_ENGINE_PARAMS];\nstatic uint32_t g_transmissionParameters[MAX_TRANSMISSION_PARAMS];\nstatic uint32_t g_infotainmentParameters[MAX_INFOTAINMENT_PARAMS];\n\nstatic uint32_t* g_moduleParameterArrays_vulnerable[NUM_SUB_MODULES] = {\n    g_engineParameters,\n    g_transmissionParameters,\n    g_infotainmentParameters\n};\n\nvoid logDiagnosticError_vulnerable(const char* msg) {\n}\n\nDiagnosticCommand_Vulnerable receiveDiagnosticCommand_vulnerable() {\n    DiagnosticCommand_Vulnerable cmd;\n    cmd.module_id = SUB_MODULE_TRANSMISSION; \n    cmd.parameter_index = 15; \n    cmd.new_value = 0xDEADBEEF;\n    cmd.command_type = 0x02;\n    return cmd;\n}\n\nvoid initializeSystemParameters_vulnerable() {\n    for (int i = 0; i < MAX_ENGINE_PARAMS; ++i) g_engineParameters[i] = i;\n    for (int i = 0; i < MAX_TRANSMISSION_PARAMS; ++i) g_transmissionParameters[i] = i + 100;\n    for (int i = 0; i < MAX_INFOTAINMENT_PARAMS; ++i) g_infotainmentParameters[i] = i + 200;\n}\n\nvoid processDiagnosticCommand_vulnerable() {\n    DiagnosticCommand_Vulnerable cmd = receiveDiagnosticCommand_vulnerable();\n\n    if (cmd.module_id < NUM_SUB_MODULES) {\n        uint32_t* target_array = g_moduleParameterArrays_vulnerable[cmd.module_id];\n\n        if (cmd.command_type == 0x02) {\n            target_array[cmd.parameter_index] = cmd.new_value;\n            logDiagnosticError_vulnerable(\"Parameter update processed.\");\n        } else if (cmd.command_type == 0x01) {\n            uint32_t value = target_array[cmd.parameter_index];\n            logDiagnosticError_vulnerable(\"Parameter read processed.\");\n        } else {\n            logDiagnosticError_vulnerable(\"Unknown command type.\");\n        }\n    } else {\n        logDiagnosticError_vulnerable(\"Invalid sub-module ID received.\");\n    }\n}\n\nvoid main_vulnerable() {\n    initializeSystemParameters_vulnerable();\n    processDiagnosticCommand_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define NUM_SUB_MODULES 3\n#define MAX_ENGINE_PARAMS 20\n#define MAX_TRANSMISSION_PARAMS 10\n#define MAX_INFOTAINMENT_PARAMS 5\n\ntypedef enum {\n    SUB_MODULE_ENGINE = 0,\n    SUB_MODULE_TRANSMISSION,\n    SUB_MODULE_INFOTAINMENT,\n    SUB_MODULE_INVALID\n} SubModuleID;\n\ntypedef struct {\n    SubModuleID module_id;\n    uint8_t     parameter_index;\n    uint32_t    new_value;\n    uint8_t     command_type;\n} DiagnosticCommand_Fixed;\n\nstatic uint32_t g_engineParameters_fixed[MAX_ENGINE_PARAMS];\nstatic uint32_t g_transmissionParameters_fixed[MAX_TRANSMISSION_PARAMS];\nstatic uint32_t g_infotainmentParameters_fixed[MAX_INFOTAINMENT_PARAMS];\n\nstatic uint32_t* g_moduleParameterArrays_fixed[NUM_SUB_MODULES] = {\n    g_engineParameters_fixed,\n    g_transmissionParameters_fixed,\n    g_infotainmentParameters_fixed\n};\n\nstatic const uint8_t g_moduleParameterSizes_fixed[NUM_SUB_MODULES] = {\n    MAX_ENGINE_PARAMS,\n    MAX_TRANSMISSION_PARAMS,\n    MAX_INFOTAINMENT_PARAMS\n};\n\nvoid logDiagnosticError_fixed(const char* msg) {\n}\n\nDiagnosticCommand_Fixed receiveDiagnosticCommand_fixed() {\n    DiagnosticCommand_Fixed cmd;\n    cmd.module_id = SUB_MODULE_TRANSMISSION; \n    cmd.parameter_index = 15; \n    cmd.new_value = 0xDEADBEEF;\n    cmd.command_type = 0x02;\n    return cmd;\n}\n\nvoid initializeSystemParameters_fixed() {\n    for (int i = 0; i < MAX_ENGINE_PARAMS; ++i) g_engineParameters_fixed[i] = i;\n    for (int i = 0; i < MAX_TRANSMISSION_PARAMS; ++i) g_transmissionParameters_fixed[i] = i + 100;\n    for (int i = 0; i < MAX_INFOTAINMENT_PARAMS; ++i) g_infotainmentParameters_fixed[i] = i + 200;\n}\n\nvoid processDiagnosticCommand_fixed() {\n    DiagnosticCommand_Fixed cmd = receiveDiagnosticCommand_fixed();\n\n    if (cmd.module_id < NUM_SUB_MODULES) {\n        uint32_t* target_array = g_moduleParameterArrays_fixed[cmd.module_id];\n        uint8_t max_index = g_moduleParameterSizes_fixed[cmd.module_id]; \n\n        if (cmd.parameter_index < max_index) { \n            if (cmd.command_type == 0x02) {\n                target_array[cmd.parameter_index] = cmd.new_value;\n                logDiagnosticError_fixed(\"Parameter update processed successfully.\");\n            } else if (cmd.command_type == 0x01) {\n                uint32_t value = target_array[cmd.parameter_index];\n                logDiagnosticError_fixed(\"Parameter read processed successfully.\");\n            } else {\n                logDiagnosticError_fixed(\"Unknown command type.\");\n            }\n        } else {\n            logDiagnosticError_fixed(\"Parameter index out of bounds for selected sub-module. Command ignored.\");\n        }\n    } else {\n        logDiagnosticError_fixed(\"Invalid sub-module ID received.\");\n    }\n}\n\nvoid main_fixed() {\n    initializeSystemParameters_fixed();\n    processDiagnosticCommand_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_SUB_COMPONENTS_ENGINE         8\n#define MAX_SUB_COMPONENTS_TRANSMISSION   4\n#define MAX_SUB_COMPONENTS_BRAKE          6\n#define MAX_SUB_COMPONENTS_INFOTAINMENT   10\n\ntypedef enum {\n    VEHICLE_COMPONENT_ENGINE = 0,\n    VEHICLE_COMPONENT_TRANSMISSION,\n    VEHICLE_COMPONENT_BRAKE,\n    VEHICLE_COMPONENT_INFOTAINMENT,\n    NUM_VEHICLE_COMPONENTS\n} VehicleComponentType;\n\ntypedef struct {\n    uint8_t  status_code;\n    uint32_t last_update_timestamp;\n    bool     is_active;\n} SubComponentStatus;\n\ntypedef struct {\n    SubComponentStatus* status_array_ptr;\n    uint8_t             max_size;\n} ComponentDataStorage;\n\nstatic SubComponentStatus g_engineSubComponentStatuses[MAX_SUB_COMPONENTS_ENGINE];\nstatic SubComponentStatus g_transmissionSubComponentStatuses[MAX_SUB_COMPONENTS_TRANSMISSION];\nstatic SubComponentStatus g_brakeSubComponentStatuses[MAX_SUB_COMPONENTS_BRAKE];\nstatic SubComponentStatus g_infotainmentSubComponentStatuses[MAX_SUB_COMPONENTS_INFOTAINMENT];\n\nstatic ComponentDataStorage g_componentDataRegistry[NUM_VEHICLE_COMPONENTS];\n\ntypedef struct {\n    VehicleComponentType component_type;\n    uint8_t              sub_component_id;\n    uint8_t              new_status_code;\n    uint32_t             timestamp;\n} ComponentStatusMessage;\n\nvoid logAutomotiveEvent(const char* msg) {\n}\n\nvoid initializeComponentStatusSystem_vulnerable() {\n    g_componentDataRegistry[VEHICLE_COMPONENT_ENGINE].status_array_ptr = g_engineSubComponentStatuses;\n    g_componentDataRegistry[VEHICLE_COMPONENT_ENGINE].max_size = MAX_SUB_COMPONENTS_ENGINE;\n\n    g_componentDataRegistry[VEHICLE_COMPONENT_TRANSMISSION].status_array_ptr = g_transmissionSubComponentStatuses;\n    g_componentDataRegistry[VEHICLE_COMPONENT_TRANSMISSION].max_size = MAX_SUB_COMPONENTS_TRANSMISSION;\n\n    g_componentDataRegistry[VEHICLE_COMPONENT_BRAKE].status_array_ptr = g_brakeSubComponentStatuses;\n    g_componentDataRegistry[VEHICLE_COMPONENT_BRAKE].max_size = MAX_SUB_COMPONENTS_BRAKE;\n\n    g_componentDataRegistry[VEHICLE_COMPONENT_INFOTAINMENT].status_array_ptr = g_infotainmentSubComponentStatuses;\n    g_componentDataRegistry[VEHICLE_COMPONENT_INFOTAINMENT].max_size = MAX_SUB_COMPONENTS_INFOTAINMENT;\n\n    for (int i = 0; i < MAX_SUB_COMPONENTS_ENGINE; ++i) g_engineSubComponentStatuses[i] = (SubComponentStatus){0, 0, false};\n    for (int i = 0; i < MAX_SUB_COMPONENTS_TRANSMISSION; ++i) g_transmissionSubComponentStatuses[i] = (SubComponentStatus){0, 0, false};\n    for (int i = 0; i < MAX_SUB_COMPONENTS_BRAKE; ++i) g_brakeSubComponentStatuses[i] = (SubComponentStatus){0, 0, false};\n    for (int i = 0; i < MAX_SUB_COMPONENTS_INFOTAINMENT; ++i) g_infotainmentSubComponentStatuses[i] = (SubComponentStatus){0, 0, false};\n\n    logAutomotiveEvent(\"Component status system initialized (vulnerable).\");\n}\n\nComponentStatusMessage simulateIncomingStatusMessage_vulnerable() {\n    ComponentStatusMessage msg;\n    msg.component_type = VEHICLE_COMPONENT_TRANSMISSION;\n    msg.sub_component_id = 4;\n    msg.new_status_code = 0xAA;\n    msg.timestamp = 0x12345678;\n    return msg;\n}\n\nvoid processComponentStatusUpdate_vulnerable(ComponentStatusMessage msg) {\n    if (msg.component_type < NUM_VEHICLE_COMPONENTS) {\n        ComponentDataStorage* target_storage = &g_componentDataRegistry[msg.component_type];\n        target_storage->status_array_ptr[msg.sub_component_id].status_code = msg.new_status_code;\n        target_storage->status_array_ptr[msg.sub_component_id].last_update_timestamp = msg.timestamp;\n        target_storage->status_array_ptr[msg.sub_component_id].is_active = true;\n        logAutomotiveEvent(\"Component status update processed (vulnerable).\");\n    } else {\n        logAutomotiveEvent(\"Received status update for invalid component type (vulnerable).\");\n    }\n}\n\nvoid vehicleStatusMonitor_vulnerable_main() {\n    initializeComponentStatusSystem_vulnerable();\n    ComponentStatusMessage update_msg = simulateIncomingStatusMessage_vulnerable();\n    processComponentStatusUpdate_vulnerable(update_msg);\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_SUB_COMPONENTS_ENGINE         8\n#define MAX_SUB_COMPONENTS_TRANSMISSION   4\n#define MAX_SUB_COMPONENTS_BRAKE          6\n#define MAX_SUB_COMPONENTS_INFOTAINMENT   10\n\ntypedef enum {\n    VEHICLE_COMPONENT_ENGINE = 0,\n    VEHICLE_COMPONENT_TRANSMISSION,\n    VEHICLE_COMPONENT_BRAKE,\n    VEHICLE_COMPONENT_INFOTAINMENT,\n    NUM_VEHICLE_COMPONENTS\n} VehicleComponentType;\n\ntypedef struct {\n    uint8_t  status_code;\n    uint32_t last_update_timestamp;\n    bool     is_active;\n} SubComponentStatus;\n\ntypedef struct {\n    SubComponentStatus* status_array_ptr;\n    uint8_t             max_size;\n} ComponentDataStorage;\n\nstatic SubComponentStatus g_engineSubComponentStatuses[MAX_SUB_COMPONENTS_ENGINE];\nstatic SubComponentStatus g_transmissionSubComponentStatuses[MAX_SUB_COMPONENTS_TRANSMISSION];\nstatic SubComponentStatus g_brakeSubComponentStatuses[MAX_SUB_COMPONENTS_BRAKE];\nstatic SubComponentStatus g_infotainmentSubComponentStatuses[MAX_SUB_COMPONENTS_INFOTAINMENT];\n\nstatic ComponentDataStorage g_componentDataRegistry[NUM_VEHICLE_COMPONENTS];\n\ntypedef struct {\n    VehicleComponentType component_type;\n    uint8_t              sub_component_id;\n    uint8_t              new_status_code;\n    uint32_t             timestamp;\n} ComponentStatusMessage;\n\nvoid logAutomotiveEvent(const char* msg) {\n}\n\nvoid initializeComponentStatusSystem_fixed() {\n    g_componentDataRegistry[VEHICLE_COMPONENT_ENGINE].status_array_ptr = g_engineSubComponentStatuses;\n    g_componentDataRegistry[VEHICLE_COMPONENT_ENGINE].max_size = MAX_SUB_COMPONENTS_ENGINE;\n\n    g_componentDataRegistry[VEHICLE_COMPONENT_TRANSMISSION].status_array_ptr = g_transmissionSubComponentStatuses;\n    g_componentDataRegistry[VEHICLE_COMPONENT_TRANSMISSION].max_size = MAX_SUB_COMPONENTS_TRANSMISSION;\n\n    g_componentDataRegistry[VEHICLE_COMPONENT_BRAKE].status_array_ptr = g_brakeSubComponentStatuses;\n    g_componentDataRegistry[VEHICLE_COMPONENT_BRAKE].max_size = MAX_SUB_COMPONENTS_BRAKE;\n\n    g_componentDataRegistry[VEHICLE_COMPONENT_INFOTAINMENT].status_array_ptr = g_infotainmentSubComponentStatuses;\n    g_componentDataRegistry[VEHICLE_COMPONENT_INFOTAINMENT].max_size = MAX_SUB_COMPONENTS_INFOTAINMENT;\n\n    for (int i = 0; i < MAX_SUB_COMPONENTS_ENGINE; ++i) g_engineSubComponentStatuses[i] = (SubComponentStatus){0, 0, false};\n    for (int i = 0; i < MAX_SUB_COMPONENTS_TRANSMISSION; ++i) g_transmissionSubComponentStatuses[i] = (SubComponentStatus){0, 0, false};\n    for (int i = 0; i < MAX_SUB_COMPONENTS_BRAKE; ++i) g_brakeSubComponentStatuses[i] = (SubComponentStatus){0, 0, false};\n    for (int i = 0; i < MAX_SUB_COMPONENTS_INFOTAINMENT; ++i) g_infotainmentSubComponentStatuses[i] = (SubComponentStatus){0, 0, false};\n\n    logAutomotiveEvent(\"Component status system initialized (fixed).\");\n}\n\nComponentStatusMessage simulateIncomingStatusMessage_fixed() {\n    ComponentStatusMessage msg;\n    msg.component_type = VEHICLE_COMPONENT_TRANSMISSION;\n    msg.sub_component_id = 4;\n    msg.new_status_code = 0xAA;\n    msg.timestamp = 0x12345678;\n    return msg;\n}\n\nvoid processComponentStatusUpdate_fixed(ComponentStatusMessage msg) {\n    if (msg.component_type < NUM_VEHICLE_COMPONENTS) {\n        ComponentDataStorage* target_storage = &g_componentDataRegistry[msg.component_type];\n        if (msg.sub_component_id < target_storage->max_size) {\n            target_storage->status_array_ptr[msg.sub_component_id].status_code = msg.new_status_code;\n            target_storage->status_array_ptr[msg.sub_component_id].last_update_timestamp = msg.timestamp;\n            target_storage->status_array_ptr[msg.sub_component_id].is_active = true;\n            logAutomotiveEvent(\"Component status update processed successfully (fixed).\");\n        } else {\n            logAutomotiveEvent(\"Sub-component ID out of bounds for specified component. Update ignored (fixed).\");\n        }\n    } else {\n        logAutomotiveEvent(\"Received status update for invalid component type (fixed).\");\n    }\n}\n\nvoid vehicleStatusMonitor_fixed_main() {\n    initializeComponentStatusSystem_fixed();\n    ComponentStatusMessage update_msg = simulateIncomingStatusMessage_fixed();\n    processComponentStatusUpdate_fixed(update_msg);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_LANE_SEGMENTS 5\n#define MAX_OBJECTS_PER_SEGMENT 10\n\ntypedef struct {\n    uint16_t object_id;\n    float position_x;\n    float position_y;\n    float velocity_x;\n    float velocity_y;\n    uint8_t confidence;\n} DetectedObject_Vulnerable;\n\ntypedef struct {\n    uint8_t active_objects_count;\n    DetectedObject_Vulnerable objects[MAX_OBJECTS_PER_SEGMENT];\n} LaneSegmentData_Vulnerable;\n\nstatic LaneSegmentData_Vulnerable g_laneData_vulnerable[MAX_LANE_SEGMENTS];\n\nvoid logPerceptionError_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t lane_idx;\n    uint8_t object_slot_idx;\n    DetectedObject_Vulnerable obj_data;\n} SensorFusionUpdatePacket_Vulnerable;\n\nSensorFusionUpdatePacket_Vulnerable receiveFusionUpdate_vulnerable() {\n    SensorFusionUpdatePacket_Vulnerable packet;\n    packet.lane_idx = MAX_LANE_SEGMENTS; \n    packet.object_slot_idx = 0;\n    packet.obj_data = (DetectedObject_Vulnerable){.object_id = 123, .position_x = 10.5f, .position_y = 5.2f, .velocity_x = 1.0f, .velocity_y = 0.5f, .confidence = 95};\n    return packet;\n}\n\nvoid initializeLaneData_vulnerable() {\n    for (uint8_t i = 0; i < MAX_LANE_SEGMENTS; ++i) {\n        g_laneData_vulnerable[i].active_objects_count = 0;\n        for (uint8_t j = 0; j < MAX_OBJECTS_PER_SEGMENT; ++j) {\n            g_laneData_vulnerable[i].objects[j] = (DetectedObject_Vulnerable){0};\n        }\n    }\n}\n\nvoid updateLaneObject_vulnerable() {\n    SensorFusionUpdatePacket_Vulnerable update = receiveFusionUpdate_vulnerable();\n\n    g_laneData_vulnerable[update.lane_idx].objects[update.object_slot_idx] = update.obj_data;\n    if (update.object_slot_idx >= g_laneData_vulnerable[update.lane_idx].active_objects_count) {\n        g_laneData_vulnerable[update.lane_idx].active_objects_count = update.object_slot_idx + 1;\n    }\n}\n\nvoid perceptionModuleMain_vulnerable() {\n    initializeLaneData_vulnerable();\n    updateLaneObject_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_LANE_SEGMENTS 5\n#define MAX_OBJECTS_PER_SEGMENT 10\n\ntypedef struct {\n    uint16_t object_id;\n    float position_x;\n    float position_y;\n    float velocity_x;\n    float velocity_y;\n    uint8_t confidence;\n} DetectedObject_Fixed;\n\ntypedef struct {\n    uint8_t active_objects_count;\n    DetectedObject_Fixed objects[MAX_OBJECTS_PER_SEGMENT];\n} LaneSegmentData_Fixed;\n\nstatic LaneSegmentData_Fixed g_laneData_fixed[MAX_LANE_SEGMENTS];\n\nvoid logPerceptionError_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t lane_idx;\n    uint8_t object_slot_idx;\n    DetectedObject_Fixed obj_data;\n} SensorFusionUpdatePacket_Fixed;\n\nSensorFusionUpdatePacket_Fixed receiveFusionUpdate_fixed() {\n    SensorFusionUpdatePacket_Fixed packet;\n    packet.lane_idx = MAX_LANE_SEGMENTS; \n    packet.object_slot_idx = 0;\n    packet.obj_data = (DetectedObject_Fixed){.object_id = 123, .position_x = 10.5f, .position_y = 5.2f, .velocity_x = 1.0f, .velocity_y = 0.5f, .confidence = 95};\n    return packet;\n}\n\nvoid initializeLaneData_fixed() {\n    for (uint8_t i = 0; i < MAX_LANE_SEGMENTS; ++i) {\n        g_laneData_fixed[i].active_objects_count = 0;\n        for (uint8_t j = 0; j < MAX_OBJECTS_PER_SEGMENT; ++j) {\n            g_laneData_fixed[i].objects[j] = (DetectedObject_Fixed){0};\n        }\n    }\n}\n\nvoid updateLaneObject_fixed() {\n    SensorFusionUpdatePacket_Fixed update = receiveFusionUpdate_fixed();\n\n    if (update.lane_idx < MAX_LANE_SEGMENTS) {\n        if (update.object_slot_idx < MAX_OBJECTS_PER_SEGMENT) {\n            g_laneData_fixed[update.lane_idx].objects[update.object_slot_idx] = update.obj_data;\n            if (update.object_slot_idx >= g_laneData_fixed[update.lane_idx].active_objects_count) {\n                g_laneData_fixed[update.lane_idx].active_objects_count = update.object_slot_idx + 1;\n            }\n        } else {\n            logPerceptionError_fixed(\"Received sensor fusion update with out-of-bounds object slot index.\");\n        }\n    } else {\n        logPerceptionError_fixed(\"Received sensor fusion update with out-of-bounds lane index.\");\n    }\n}\n\nvoid perceptionModuleMain_fixed() {\n    initializeLaneData_fixed();\n    updateLaneObject_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_TIRE_SENSORS 8\n#define SENSOR_DATA_HISTORY_SIZE 10\n\ntypedef struct {\n    uint16_t pressure_kPa;\n    int8_t   temperature_celsius;\n    uint8_t  battery_status;\n    bool     alarm_active;\n} TPMS_SensorData;\n\nstatic TPMS_SensorData g_tpms_sensor_data_vulnerable[MAX_TIRE_SENSORS];\n\nstatic uint8_t g_active_tire_sensors_count_vulnerable = 4;\n\nvoid log_tpms_error_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t  sensor_id;\n    uint16_t pressure;\n    int8_t   temperature;\n    uint8_t  battery;\n} TPMS_IncomingMessage_Vulnerable;\n\nTPMS_IncomingMessage_Vulnerable receive_tpms_message_vulnerable() {\n    TPMS_IncomingMessage_Vulnerable msg;\n    msg.sensor_id = 4;\n    msg.pressure = 250;\n    msg.temperature = 25;\n    msg.battery = 90;\n    return msg;\n}\n\nvoid initialize_tpms_data_vulnerable() {\n    for (uint8_t i = 0; i < MAX_TIRE_SENSORS; ++i) {\n        g_tpms_sensor_data_vulnerable[i] = (TPMS_SensorData){0, 0, 0, false};\n    }\n    for (uint8_t i = 0; i < g_active_tire_sensors_count_vulnerable; ++i) {\n        g_tpms_sensor_data_vulnerable[i].pressure_kPa = 220;\n        g_tpms_sensor_data_vulnerable[i].temperature_celsius = 20;\n        g_tpms_sensor_data_vulnerable[i].battery_status = 100;\n    }\n}\n\nvoid process_tpms_reading_vulnerable() {\n    TPMS_IncomingMessage_Vulnerable msg = receive_tpms_message_vulnerable();\n\n    if (msg.sensor_id < MAX_TIRE_SENSORS) {\n        g_tpms_sensor_data_vulnerable[msg.sensor_id].pressure_kPa = msg.pressure;\n        g_tpms_sensor_data_vulnerable[msg.sensor_id].temperature_celsius = msg.temperature;\n        g_tpms_sensor_data_vulnerable[msg.sensor_id].battery_status = msg.battery;\n        g_tpms_sensor_data_vulnerable[msg.sensor_id].alarm_active = (msg.pressure < 150 || msg.pressure > 300);\n        log_tpms_error_vulnerable(\"TPMS data updated (vulnerable).\");\n    } else {\n        log_tpms_error_vulnerable(\"Received TPMS message with out-of-bounds sensor ID. Ignoring.\");\n    }\n}\n\nvoid tpms_module_main_vulnerable() {\n    initialize_tpms_data_vulnerable();\n    process_tpms_reading_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_TIRE_SENSORS 8\n#define SENSOR_DATA_HISTORY_SIZE 10\n\ntypedef struct {\n    uint16_t pressure_kPa;\n    int8_t   temperature_celsius;\n    uint8_t  battery_status;\n    bool     alarm_active;\n} TPMS_SensorData;\n\nstatic TPMS_SensorData g_tpms_sensor_data_fixed[MAX_TIRE_SENSORS];\n\nstatic uint8_t g_active_tire_sensors_count_fixed = 4;\n\nvoid log_tpms_error_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t  sensor_id;\n    uint16_t pressure;\n    int8_t   temperature;\n    uint8_t  battery;\n} TPMS_IncomingMessage_Fixed;\n\nTPMS_IncomingMessage_Fixed receive_tpms_message_fixed() {\n    TPMS_IncomingMessage_Fixed msg;\n    msg.sensor_id = 4;\n    msg.pressure = 250;\n    msg.temperature = 25;\n    msg.battery = 90;\n    return msg;\n}\n\nvoid initialize_tpms_data_fixed() {\n    for (uint8_t i = 0; i < MAX_TIRE_SENSORS; ++i) {\n        g_tpms_sensor_data_fixed[i] = (TPMS_SensorData){0, 0, 0, false};\n    }\n    for (uint8_t i = 0; i < g_active_tire_sensors_count_fixed; ++i) {\n        g_tpms_sensor_data_fixed[i].pressure_kPa = 220;\n        g_tpms_sensor_data_fixed[i].temperature_celsius = 20;\n        g_tpms_sensor_data_fixed[i].battery_status = 100;\n    }\n}\n\nvoid process_tpms_reading_fixed() {\n    TPMS_IncomingMessage_Fixed msg = receive_tpms_message_fixed();\n\n    if (msg.sensor_id < g_active_tire_sensors_count_fixed) {\n        g_tpms_sensor_data_fixed[msg.sensor_id].pressure_kPa = msg.pressure;\n        g_tpms_sensor_data_fixed[msg.sensor_id].temperature_celsius = msg.temperature;\n        g_tpms_sensor_data_fixed[msg.sensor_id].battery_status = msg.battery;\n        g_tpms_sensor_data_fixed[msg.sensor_id].alarm_active = (msg.pressure < 150 || msg.pressure > 300);\n        log_tpms_error_fixed(\"TPMS data updated successfully (fixed).\");\n    } else {\n        log_tpms_error_fixed(\"Received TPMS message with sensor ID out of active bounds. Ignoring.\");\n    }\n}\n\nvoid tpms_module_main_fixed() {\n    initialize_tpms_data_fixed();\n    process_tpms_reading_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_TELEMATICS_PROFILES 5\n#define MAX_PROFILE_PARAMS_PER_TYPE 8\n#define CONFIG_DATA_SIZE 16\n\ntypedef struct {\n    uint16_t param_id;\n    uint8_t  data[CONFIG_DATA_SIZE];\n    uint32_t checksum;\n} TelematicsConfigParam;\n\ntypedef struct {\n    uint8_t profile_type_id;\n    uint8_t active_param_count;\n    TelematicsConfigParam params[MAX_PROFILE_PARAMS_PER_TYPE];\n} TelematicsProfile;\n\nstatic TelematicsProfile g_telematicsProfiles[MAX_TELEMATICS_PROFILES];\n\nvoid telematicsLogError_vulnerable(const char* message) {\n}\n\ntypedef struct {\n    uint8_t target_profile_idx;\n    uint8_t num_params_to_update;\n    TelematicsConfigParam param_updates[MAX_PROFILE_PARAMS_PER_TYPE + 1];\n} TelematicsConfigCommand_vulnerable;\n\nTelematicsConfigCommand_vulnerable receiveConfigCommand_vulnerable() {\n    TelematicsConfigCommand_vulnerable cmd;\n    cmd.target_profile_idx = 0;\n    cmd.num_params_to_update = MAX_PROFILE_PARAMS_PER_TYPE + 1;\n    \n    for (int i = 0; i < MAX_PROFILE_PARAMS_PER_TYPE + 1; ++i) {\n        cmd.param_updates[i].param_id = 0x1000 + i;\n        memset(cmd.param_updates[i].data, (uint8_t)i, CONFIG_DATA_SIZE);\n        cmd.param_updates[i].checksum = 0xDEADBEEF;\n    }\n    return cmd;\n}\n\nvoid initializeTelematicsProfiles_vulnerable() {\n    g_telematicsProfiles[0].profile_type_id = 0x01;\n    g_telematicsProfiles[0].active_param_count = 3;\n    for(int i = 0; i < 3; ++i) {\n        g_telematicsProfiles[0].params[i].param_id = 0x100 + i;\n        memset(g_telematicsProfiles[0].params[i].data, (uint8_t)(0xA0 + i), CONFIG_DATA_SIZE);\n        g_telematicsProfiles[0].params[i].checksum = 0xCCCCCCCC;\n    }\n    g_telematicsProfiles[1].profile_type_id = 0x02;\n    g_telematicsProfiles[1].active_param_count = 5;\n}\n\nvoid processTelematicsConfig_vulnerable() {\n    TelematicsConfigCommand_vulnerable cmd = receiveConfigCommand_vulnerable();\n\n    if (cmd.target_profile_idx < MAX_TELEMATICS_PROFILES) {\n        TelematicsProfile* profile = &g_telematicsProfiles[cmd.target_profile_idx];\n        \n        for (int i = 0; i < cmd.num_params_to_update; ++i) {\n            profile->params[i] = cmd.param_updates[i];\n        }\n        telematicsLogError_vulnerable(\"Telematics profile updated (vulnerable).\");\n    } else {\n        telematicsLogError_vulnerable(\"Invalid telematics profile index received (vulnerable).\");\n    }\n}\n\nvoid telematicsManagerMain_vulnerable() {\n    initializeTelematicsProfiles_vulnerable();\n    processTelematicsConfig_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_TELEMATICS_PROFILES 5\n#define MAX_PROFILE_PARAMS_PER_TYPE 8\n#define CONFIG_DATA_SIZE 16\n\ntypedef struct {\n    uint16_t param_id;\n    uint8_t  data[CONFIG_DATA_SIZE];\n    uint32_t checksum;\n} TelematicsConfigParam;\n\ntypedef struct {\n    uint8_t profile_type_id;\n    uint8_t active_param_count;\n    TelematicsConfigParam params[MAX_PROFILE_PARAMS_PER_TYPE];\n} TelematicsProfile;\n\nstatic TelematicsProfile g_telematicsProfiles[MAX_TELEMATICS_PROFILES];\n\nvoid telematicsLogError_fixed(const char* message) {\n}\n\ntypedef struct {\n    uint8_t target_profile_idx;\n    uint8_t num_params_to_update;\n    TelematicsConfigParam param_updates[MAX_PROFILE_PARAMS_PER_TYPE + 1];\n} TelematicsConfigCommand_fixed;\n\nTelematicsConfigCommand_fixed receiveConfigCommand_fixed() {\n    TelematicsConfigCommand_fixed cmd;\n    cmd.target_profile_idx = 0;\n    cmd.num_params_to_update = MAX_PROFILE_PARAMS_PER_TYPE + 1;\n    \n    for (int i = 0; i < MAX_PROFILE_PARAMS_PER_TYPE + 1; ++i) {\n        cmd.param_updates[i].param_id = 0x1000 + i;\n        memset(cmd.param_updates[i].data, (uint8_t)i, CONFIG_DATA_SIZE);\n        cmd.param_updates[i].checksum = 0xDEADBEEF;\n    }\n    return cmd;\n}\n\nvoid initializeTelematicsProfiles_fixed() {\n    g_telematicsProfiles[0].profile_type_id = 0x01;\n    g_telematicsProfiles[0].active_param_count = 3;\n    for(int i = 0; i < 3; ++i) {\n        g_telematicsProfiles[0].params[i].param_id = 0x100 + i;\n        memset(g_telematicsProfiles[0].params[i].data, (uint8_t)(0xA0 + i), CONFIG_DATA_SIZE);\n        g_telematicsProfiles[0].params[i].checksum = 0xCCCCCCCC;\n    }\n    g_telematicsProfiles[1].profile_type_id = 0x02;\n    g_telematicsProfiles[1].active_param_count = 5;\n}\n\nvoid processTelematicsConfig_fixed() {\n    TelematicsConfigCommand_fixed cmd = receiveConfigCommand_fixed();\n\n    if (cmd.target_profile_idx < MAX_TELEMATICS_PROFILES) {\n        TelematicsProfile* profile = &g_telematicsProfiles[cmd.target_profile_idx];\n        \n        uint8_t actual_params_to_process = cmd.num_params_to_update;\n        if (actual_params_to_process > MAX_PROFILE_PARAMS_PER_TYPE) {\n            actual_params_to_process = MAX_PROFILE_PARAMS_PER_TYPE;\n            telematicsLogError_fixed(\"Attempted to update too many parameters. Truncating (fixed).\");\n        }\n\n        for (int i = 0; i < actual_params_to_process; ++i) {\n            profile->params[i] = cmd.param_updates[i];\n        }\n        telematicsLogError_fixed(\"Telematics profile updated (fixed).\");\n    } else {\n        telematicsLogError_fixed(\"Invalid telematics profile index received (fixed).\");\n    }\n}\n\nvoid telematicsManagerMain_fixed() {\n    initializeTelematicsProfiles_fixed();\n    processTelematicsConfig_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>#include <stddef.h>typedef struct {uint32_t code;uint16_t timestamp;uint8_t severity;uint8_t _padding;} DtcEntry;#define MAX_DTC_TYPES 5#define TOTAL_DTC_HISTORY_BUFFER_SIZE 256static uint8_t g_dtcHistoryBuffer_vulnerable[TOTAL_DTC_HISTORY_BUFFER_SIZE];typedef struct {uint16_t start_offset_bytes;uint16_t max_entries;} DtcHistorySegmentConfig;static DtcHistorySegmentConfig g_dtcSegmentConfigs_vulnerable[MAX_DTC_TYPES] = {{0, 7},{56, 8},{120, 8},{184, 8},{248, 1}};#ifndef DUMMY_LOG_ERROR_VULNERABLE_DEFINED#define DUMMY_LOG_ERROR_VULNERABLE_DEFINEDvoid logError_vulnerable(const char* msg) {}#endifstatic uint16_t g_currentDtcEntryCount_vulnerable[MAX_DTC_TYPES];typedef struct {uint8_t dtc_type_id;uint32_t dtc_code;uint16_t timestamp;uint8_t severity;} IncomingDtcLogRequest_vulnerable;IncomingDtcLogRequest_vulnerable receiveDtcLogRequest_vulnerable() {IncomingDtcLogRequest_vulnerable req;req.dtc_type_id = 3;req.dtc_code = 0xDEADBEEF;req.timestamp = 12345;req.severity = 2;return req;}void initializeDtcHistory_vulnerable() {for (int i = 0; i < TOTAL_DTC_HISTORY_BUFFER_SIZE; ++i) {g_dtcHistoryBuffer_vulnerable[i] = 0;}for (int i = 0; i < MAX_DTC_TYPES; ++i) {g_currentDtcEntryCount_vulnerable[i] = 0;}}void logDtcEntry_vulnerable() {IncomingDtcLogRequest_vulnerable request = receiveDtcLogRequest_vulnerable();if (request.dtc_type_id >= MAX_DTC_TYPES) {logError_vulnerable(",
    "fixed_code": "#include <stdint.h>#include <stddef.h>typedef struct {uint32_t code;uint16_t timestamp;uint8_t severity;uint8_t _padding;} DtcEntry_Fixed;#define MAX_DTC_TYPES 5#define TOTAL_DTC_HISTORY_BUFFER_SIZE 256static uint8_t g_dtcHistoryBuffer_fixed[TOTAL_DTC_HISTORY_BUFFER_SIZE];typedef struct {uint16_t start_offset_bytes;uint16_t max_entries;} DtcHistorySegmentConfig_Fixed;static DtcHistorySegmentConfig_Fixed g_dtcSegmentConfigs_fixed[MAX_DTC_TYPES] = {{0, 7},{56, 8},{120, 8},{184, 8},{248, 1}};#ifndef DUMMY_LOG_ERROR_FIXED_DEFINED#define DUMMY_LOG_ERROR_FIXED_DEFINEDvoid logError_fixed(const char* msg) {}#endifstatic uint16_t g_currentDtcEntryCount_fixed[MAX_DTC_TYPES];typedef struct {uint8_t dtc_type_id;uint32_t dtc_code;uint16_t timestamp;uint8_t severity;} IncomingDtcLogRequest_Fixed;IncomingDtcLogRequest_Fixed receiveDtcLogRequest_fixed() {IncomingDtcLogRequest_Fixed req;req.dtc_type_id = 3;req.dtc_code = 0xDEADBEEF;req.timestamp = 12345;req.severity = 2;return req;}void initializeDtcHistory_fixed() {for (int i = 0; i < TOTAL_DTC_HISTORY_BUFFER_SIZE; ++i) {g_dtcHistoryBuffer_fixed[i] = 0;}for (int i = 0; i < MAX_DTC_TYPES; ++i) {g_currentDtcEntryCount_fixed[i] = 0;}}void logDtcEntry_fixed() {IncomingDtcLogRequest_Fixed request = receiveDtcLogRequest_fixed();if (request.dtc_type_id >= MAX_DTC_TYPES) {logError_fixed(",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_DTC_ENTRIES_PER_PRIORITY_LEVEL 10\n\ntypedef enum {\n    DIAG_SEVERITY_UNKNOWN = 0,\n    DIAG_SEVERITY_LOW = 1,\n    DIAG_SEVERITY_MEDIUM = 2,\n    DIAG_SEVERITY_HIGH = 3,\n    _DIAG_SEVERITY_COUNT \n} DiagnosticSeverity_Vulnerable;\n\n#define NUM_PRIORITY_LEVELS_VULNERABLE 4\n\ntypedef struct {\n    uint16_t dtc_code;\n    uint32_t timestamp;\n    uint8_t current_status;\n} DTC_Record_Vulnerable;\n\nstatic DTC_Record_Vulnerable g_dtcRecords_vulnerable[NUM_PRIORITY_LEVELS_VULNERABLE][MAX_DTC_ENTRIES_PER_PRIORITY_LEVEL];\nstatic uint8_t g_dtcCounts_vulnerable[NUM_PRIORITY_LEVELS_VULNERABLE];\n\nvoid logECU_vulnerable(const char* msg) {\n    fprintf(stderr, \"VULNERABLE_LOG: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint16_t id;\n    DiagnosticSeverity_Vulnerable severity_raw;\n    uint32_t data;\n} IncomingDiagnosticMessage_Vulnerable;\n\nIncomingDiagnosticMessage_Vulnerable receiveDiagnosticMessage_vulnerable() {\n    IncomingDiagnosticMessage_Vulnerable msg;\n    msg.id = 0xDEAD;\n    msg.severity_raw = (DiagnosticSeverity_Vulnerable)_DIAG_SEVERITY_COUNT; \n    msg.data = 0xCAFEBABE;\n    return msg;\n}\n\nvoid processDiagnosticMessage_vulnerable() {\n    IncomingDiagnosticMessage_Vulnerable msg = receiveDiagnosticMessage_vulnerable();\n\n    DiagnosticSeverity_Vulnerable effective_severity_idx = msg.severity_raw;\n\n    if (g_dtcCounts_vulnerable[effective_severity_idx] < MAX_DTC_ENTRIES_PER_PRIORITY_LEVEL) {\n        DTC_Record_Vulnerable new_record;\n        new_record.dtc_code = msg.id;\n        new_record.timestamp = msg.data;\n        new_record.current_status = 1;\n\n        g_dtcRecords_vulnerable[effective_severity_idx][g_dtcCounts_vulnerable[effective_severity_idx]] = new_record;\n        g_dtcCounts_vulnerable[effective_severity_idx]++;\n        logECU_vulnerable(\"DTC record added based on severity.\");\n    } else {\n        logECU_vulnerable(\"DTC storage full for this severity level.\");\n    }\n}\n\nvoid diagnosticSubsystemInit_vulnerable() {\n    for (int i = 0; i < NUM_PRIORITY_LEVELS_VULNERABLE; ++i) {\n        g_dtcCounts_vulnerable[i] = 0;\n        for (int j = 0; j < MAX_DTC_ENTRIES_PER_PRIORITY_LEVEL; ++j) {\n            g_dtcRecords_vulnerable[i][j] = (DTC_Record_Vulnerable){0, 0, 0};\n        }\n    }\n    logECU_vulnerable(\"Diagnostic subsystem initialized (vulnerable).\");\n}\n\nvoid runECUDiagnostics_vulnerable() {\n    diagnosticSubsystemInit_vulnerable();\n    processDiagnosticMessage_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_DTC_ENTRIES_PER_PRIORITY_LEVEL 10\n\ntypedef enum {\n    DIAG_SEVERITY_UNKNOWN = 0,\n    DIAG_SEVERITY_LOW = 1,\n    DIAG_SEVERITY_MEDIUM = 2,\n    DIAG_SEVERITY_HIGH = 3,\n    _DIAG_SEVERITY_COUNT_FIXED \n} DiagnosticSeverity_Fixed;\n\n#define NUM_PRIORITY_LEVELS_FIXED 4\n\ntypedef struct {\n    uint16_t dtc_code;\n    uint32_t timestamp;\n    uint8_t current_status;\n} DTC_Record_Fixed;\n\nstatic DTC_Record_Fixed g_dtcRecords_fixed[NUM_PRIORITY_LEVELS_FIXED][MAX_DTC_ENTRIES_PER_PRIORITY_LEVEL];\nstatic uint8_t g_dtcCounts_fixed[NUM_PRIORITY_LEVELS_FIXED];\n\nvoid logECU_fixed(const char* msg) {\n    fprintf(stderr, \"FIXED_LOG: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint16_t id;\n    DiagnosticSeverity_Fixed severity_raw;\n    uint32_t data;\n} IncomingDiagnosticMessage_Fixed;\n\nIncomingDiagnosticMessage_Fixed receiveDiagnosticMessage_fixed() {\n    IncomingDiagnosticMessage_Fixed msg;\n    msg.id = 0xDEAD;\n    msg.severity_raw = (DiagnosticSeverity_Fixed)_DIAG_SEVERITY_COUNT_FIXED;\n    msg.data = 0xCAFEBABE;\n    return msg;\n}\n\nvoid processDiagnosticMessage_fixed() {\n    IncomingDiagnosticMessage_Fixed msg = receiveDiagnosticMessage_fixed();\n\n    if (msg.severity_raw >= DIAG_SEVERITY_UNKNOWN && msg.severity_raw < NUM_PRIORITY_LEVELS_FIXED) {\n        DiagnosticSeverity_Fixed effective_severity_idx = msg.severity_raw;\n\n        if (g_dtcCounts_fixed[effective_severity_idx] < MAX_DTC_ENTRIES_PER_PRIORITY_LEVEL) {\n            DTC_Record_Fixed new_record;\n            new_record.dtc_code = msg.id;\n            new_record.timestamp = msg.data;\n            new_record.current_status = 1;\n\n            g_dtcRecords_fixed[effective_severity_idx][g_dtcCounts_fixed[effective_severity_idx]] = new_record;\n            g_dtcCounts_fixed[effective_severity_idx]++;\n            logECU_fixed(\"DTC record added based on severity.\");\n        } else {\n            logECU_fixed(\"DTC storage full for this severity level.\");\n        }\n    } else {\n        logECU_fixed(\"Invalid diagnostic severity value received. Ignoring message.\");\n    }\n}\n\nvoid diagnosticSubsystemInit_fixed() {\n    for (int i = 0; i < NUM_PRIORITY_LEVELS_FIXED; ++i) {\n        g_dtcCounts_fixed[i] = 0;\n        for (int j = 0; j < MAX_DTC_ENTRIES_PER_PRIORITY_LEVEL; ++j) {\n            g_dtcRecords_fixed[i][j] = (DTC_Record_Fixed){0, 0, 0};\n        }\n    }\n    logECU_fixed(\"Diagnostic subsystem initialized (fixed).\");\n}\n\nvoid runECUDiagnostics_fixed() {\n    diagnosticSubsystemInit_fixed();\n    processDiagnosticMessage_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_SUBSYSTEMS 5\n#define MAX_COMMANDS_PER_SUBSYSTEM 10\n#define MAX_PAYLOAD_SIZE 8\n\nvoid logSystemEvent(const char* event_msg) {\n}\n\nvoid logSecurityAlert(const char* alert_msg) {\n}\n\nvoid handleEngineCommand1(const uint8_t* data, uint32_t len) {\n    logSystemEvent(\"EngineCmd1: Processing engine status request.\");\n}\n\nvoid handleEngineCommand2(const uint8_t* data, uint32_t len) {\n    logSystemEvent(\"EngineCmd2: Adjusting ignition timing.\");\n}\n\nvoid handleBrakeCommand1(const uint8_t* data, uint32_t len) {\n    logSystemEvent(\"BrakeCmd1: Calibrating ABS sensors.\");\n}\n\nvoid handleBrakeCommand2(const uint8_t* data, uint32_t len) {\n    logSystemEvent(\"BrakeCmd2: Activating emergency braking.\");\n}\n\nvoid handleInvalidCommand(const uint8_t* data, uint32_t len) {\n    logSecurityAlert(\"Invalid/Unsupported command handler invoked.\");\n}\n\ntypedef void (*CommandHandler)(const uint8_t*, uint32_t);\n\nstatic CommandHandler g_subsystemCommandHandlers_vulnerable[MAX_SUBSYSTEMS][MAX_COMMANDS_PER_SUBSYSTEM];\nstatic uint8_t g_actualCommandsPerSubsystem_vulnerable[MAX_SUBSYSTEMS];\n\ntypedef struct {\n    uint8_t subsystem_id;\n    uint8_t command_id;\n    uint32_t data_len;\n    uint8_t payload[MAX_PAYLOAD_SIZE];\n} IncomingVehicleCommand;\n\nIncomingVehicleCommand receiveIncomingCommand_Vulnerable() {\n    IncomingVehicleCommand cmd;\n    cmd.subsystem_id = 0; \n    cmd.command_id = 5;  \n    cmd.data_len = 2;\n    cmd.payload[0] = 0xAA;\n    cmd.payload[1] = 0xBB;\n    return cmd;\n}\n\nvoid initializeCommandHandlers_Vulnerable() {\n    for (uint8_t i = 0; i < MAX_SUBSYSTEMS; ++i) {\n        g_actualCommandsPerSubsystem_vulnerable[i] = 0;\n        for (uint8_t j = 0; j < MAX_COMMANDS_PER_SUBSYSTEM; ++j) {\n            g_subsystemCommandHandlers_vulnerable[i][j] = handleInvalidCommand;\n        }\n    }\n\n    g_subsystemCommandHandlers_vulnerable[0][0] = handleEngineCommand1;\n    g_subsystemCommandHandlers_vulnerable[0][1] = handleEngineCommand2;\n    g_actualCommandsPerSubsystem_vulnerable[0] = 2;\n\n    g_subsystemCommandHandlers_vulnerable[1][0] = handleBrakeCommand1;\n    g_subsystemCommandHandlers_vulnerable[1][1] = handleBrakeCommand2;\n    g_actualCommandsPerSubsystem_vulnerable[1] = 2;\n}\n\nvoid processVehicleCommand_Vulnerable() {\n    IncomingVehicleCommand cmd = receiveIncomingCommand_Vulnerable();\n\n    if (cmd.subsystem_id < MAX_SUBSYSTEMS) {\n        if (cmd.command_id < MAX_COMMANDS_PER_SUBSYSTEM) {\n            CommandHandler handler = g_subsystemCommandHandlers_vulnerable[cmd.subsystem_id][cmd.command_id];\n            handler(cmd.payload, cmd.data_len);\n        } else {\n            logSystemEvent(\"Command ID exceeds global max for any subsystem.\");\n            handleInvalidCommand(cmd.payload, cmd.data_len);\n        }\n    } else {\n        logSystemEvent(\"Subsystem ID out of bounds.\");\n        handleInvalidCommand(cmd.payload, cmd.data_len);\n    }\n}\n\nvoid automotiveECULoop_Vulnerable() {\n    initializeCommandHandlers_Vulnerable();\n    logSystemEvent(\"Vulnerable ECU started.\");\n    processVehicleCommand_Vulnerable();\n    logSystemEvent(\"Vulnerable ECU finished processing command.\");\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_SUBSYSTEMS 5\n#define MAX_COMMANDS_PER_SUBSYSTEM 10\n#define MAX_PAYLOAD_SIZE 8\n\nvoid logSystemEvent(const char* event_msg) {\n}\n\nvoid logSecurityAlert(const char* alert_msg) {\n}\n\nvoid handleEngineCommand1(const uint8_t* data, uint32_t len) {\n    logSystemEvent(\"EngineCmd1: Processing engine status request.\");\n}\n\nvoid handleEngineCommand2(const uint8_t* data, uint32_t len) {\n    logSystemEvent(\"EngineCmd2: Adjusting ignition timing.\");\n}\n\nvoid handleBrakeCommand1(const uint8_t* data, uint32_t len) {\n    logSystemEvent(\"BrakeCmd1: Calibrating ABS sensors.\");\n}\n\nvoid handleBrakeCommand2(const uint8_t* data, uint32_t len) {\n    logSystemEvent(\"BrakeCmd2: Activating emergency braking.\");\n}\n\nvoid handleInvalidCommand(const uint8_t* data, uint32_t len) {\n    logSecurityAlert(\"Invalid/Unsupported command handler invoked.\");\n}\n\ntypedef void (*CommandHandler)(const uint8_t*, uint32_t);\n\nstatic CommandHandler g_subsystemCommandHandlers_fixed[MAX_SUBSYSTEMS][MAX_COMMANDS_PER_SUBSYSTEM];\nstatic uint8_t g_actualCommandsPerSubsystem_fixed[MAX_SUBSYSTEMS];\n\ntypedef struct {\n    uint8_t subsystem_id;\n    uint8_t command_id;\n    uint32_t data_len;\n    uint8_t payload[MAX_PAYLOAD_SIZE];\n} IncomingVehicleCommand;\n\nIncomingVehicleCommand receiveIncomingCommand_Fixed() {\n    IncomingVehicleCommand cmd;\n    cmd.subsystem_id = 0;\n    cmd.command_id = 5;\n    cmd.data_len = 2;\n    cmd.payload[0] = 0xAA;\n    cmd.payload[1] = 0xBB;\n    return cmd;\n}\n\nvoid initializeCommandHandlers_Fixed() {\n    for (uint8_t i = 0; i < MAX_SUBSYSTEMS; ++i) {\n        g_actualCommandsPerSubsystem_fixed[i] = 0;\n        for (uint8_t j = 0; j < MAX_COMMANDS_PER_SUBSYSTEM; ++j) {\n            g_subsystemCommandHandlers_fixed[i][j] = handleInvalidCommand;\n        }\n    }\n\n    g_subsystemCommandHandlers_fixed[0][0] = handleEngineCommand1;\n    g_subsystemCommandHandlers_fixed[0][1] = handleEngineCommand2;\n    g_actualCommandsPerSubsystem_fixed[0] = 2;\n\n    g_subsystemCommandHandlers_fixed[1][0] = handleBrakeCommand1;\n    g_subsystemCommandHandlers_fixed[1][1] = handleBrakeCommand2;\n    g_actualCommandsPerSubsystem_fixed[1] = 2;\n}\n\nvoid processVehicleCommand_Fixed() {\n    IncomingVehicleCommand cmd = receiveIncomingCommand_Fixed();\n\n    if (cmd.subsystem_id < MAX_SUBSYSTEMS) {\n        if (cmd.command_id < g_actualCommandsPerSubsystem_fixed[cmd.subsystem_id]) {\n            CommandHandler handler = g_subsystemCommandHandlers_fixed[cmd.subsystem_id][cmd.command_id];\n            handler(cmd.payload, cmd.data_len);\n        } else {\n            logSecurityAlert(\"Attempted to invoke unregistered command for subsystem.\");\n            handleInvalidCommand(cmd.payload, cmd.data_len);\n        }\n    } else {\n        logSystemEvent(\"Subsystem ID out of bounds.\");\n        handleInvalidCommand(cmd.payload, cmd.data_len);\n    }\n}\n\nvoid automotiveECULoop_Fixed() {\n    initializeCommandHandlers_Fixed();\n    logSystemEvent(\"Fixed ECU started.\");\n    processVehicleCommand_Fixed();\n    logSystemEvent(\"Fixed ECU finished processing command.\");\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_BATTERY_MODULES 4\n#define CELLS_PER_MODULE 12\n#define TOTAL_BATTERY_CELLS (MAX_BATTERY_MODULES * CELLS_PER_MODULE)\n\n#define BMS_CMD_UPDATE_CELL_DATA 0x01\n\ntypedef struct {\n    uint16_t voltage_mV;\n    int8_t   temperature_C;\n    uint8_t  charge_status_percent;\n    bool     fault_active;\n} BatteryCell_Vulnerable;\n\nstatic BatteryCell_Vulnerable g_batteryCells_vulnerable[TOTAL_BATTERY_CELLS];\n\ntypedef struct {\n    uint8_t command_type;\n    uint8_t module_id;\n    uint8_t cell_in_module_id;\n    uint16_t voltage_mV;\n    int8_t   temperature_C;\n    uint8_t  charge_status_percent;\n} CellUpdateCommand_Vulnerable;\n\nvoid logBMS_vulnerable(const char* msg) {\n}\n\nCellUpdateCommand_Vulnerable receiveCellUpdateCommand_vulnerable() {\n    CellUpdateCommand_Vulnerable cmd;\n    cmd.command_type = BMS_CMD_UPDATE_CELL_DATA;\n    cmd.module_id = MAX_BATTERY_MODULES; \n    cmd.cell_in_module_id = 0; \n    cmd.voltage_mV = 3800;\n    cmd.temperature_C = 25;\n    cmd.charge_status_percent = 85;\n    return cmd;\n}\n\nvoid initializeBMS_vulnerable() {\n    for (int i = 0; i < TOTAL_BATTERY_CELLS; ++i) {\n        g_batteryCells_vulnerable[i] = (BatteryCell_Vulnerable){3700, 20, 70, false};\n    }\n}\n\nvoid processCellUpdate_vulnerable() {\n    CellUpdateCommand_Vulnerable cmd = receiveCellUpdateCommand_vulnerable();\n\n    if (cmd.command_type == BMS_CMD_UPDATE_CELL_DATA) {\n        int absolute_cell_idx = cmd.module_id * CELLS_PER_MODULE + cmd.cell_in_module_id;\n\n        g_batteryCells_vulnerable[absolute_cell_idx].voltage_mV = cmd.voltage_mV;\n        g_batteryCells_vulnerable[absolute_cell_idx].temperature_C = cmd.temperature_C;\n        g_batteryCells_vulnerable[absolute_cell_idx].charge_status_percent = cmd.charge_status_percent;\n        \n        logBMS_vulnerable(\"Battery cell data updated.\");\n    } else {\n        logBMS_vulnerable(\"Unknown BMS command received.\");\n    }\n}\n\nvoid bmsMainLoop_vulnerable() {\n    initializeBMS_vulnerable();\n    processCellUpdate_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_BATTERY_MODULES 4\n#define CELLS_PER_MODULE 12\n#define TOTAL_BATTERY_CELLS (MAX_BATTERY_MODULES * CELLS_PER_MODULE)\n\n#define BMS_CMD_UPDATE_CELL_DATA 0x01\n\ntypedef struct {\n    uint16_t voltage_mV;\n    int8_t   temperature_C;\n    uint8_t  charge_status_percent;\n    bool     fault_active;\n} BatteryCell_Fixed;\n\nstatic BatteryCell_Fixed g_batteryCells_fixed[TOTAL_BATTERY_CELLS];\n\ntypedef struct {\n    uint8_t command_type;\n    uint8_t module_id;\n    uint8_t cell_in_module_id;\n    uint16_t voltage_mV;\n    int8_t   temperature_C;\n    uint8_t  charge_status_percent;\n} CellUpdateCommand_Fixed;\n\nvoid logBMS_fixed(const char* msg) {\n}\n\nCellUpdateCommand_Fixed receiveCellUpdateCommand_fixed() {\n    CellUpdateCommand_Fixed cmd;\n    cmd.command_type = BMS_CMD_UPDATE_CELL_DATA;\n    cmd.module_id = MAX_BATTERY_MODULES; \n    cmd.cell_in_module_id = 0;\n    cmd.voltage_mV = 3800;\n    cmd.temperature_C = 25;\n    cmd.charge_status_percent = 85;\n    return cmd;\n}\n\nvoid initializeBMS_fixed() {\n    for (int i = 0; i < TOTAL_BATTERY_CELLS; ++i) {\n        g_batteryCells_fixed[i] = (BatteryCell_Fixed){3700, 20, 70, false};\n    }\n}\n\nvoid processCellUpdate_fixed() {\n    CellUpdateCommand_Fixed cmd = receiveCellUpdateCommand_fixed();\n\n    if (cmd.command_type == BMS_CMD_UPDATE_CELL_DATA) {\n        if (cmd.module_id < MAX_BATTERY_MODULES && cmd.cell_in_module_id < CELLS_PER_MODULE) {\n            int absolute_cell_idx = cmd.module_id * CELLS_PER_MODULE + cmd.cell_in_module_id;\n\n            g_batteryCells_fixed[absolute_cell_idx].voltage_mV = cmd.voltage_mV;\n            g_batteryCells_fixed[absolute_cell_idx].temperature_C = cmd.temperature_C;\n            g_batteryCells_fixed[absolute_cell_idx].charge_status_percent = cmd.charge_status_percent;\n            logBMS_fixed(\"Battery cell data updated successfully.\");\n        } else {\n            logBMS_fixed(\"Invalid module ID or cell ID in command. Ignoring update.\");\n        }\n    } else {\n        logBMS_fixed(\"Unknown BMS command received.\");\n    }\n}\n\nvoid bmsMainLoop_fixed() {\n    initializeBMS_fixed();\n    processCellUpdate_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define NUM_VIRTUAL_ECUS 5\n#define MAX_PARAMS_PER_ECU_TYPE 100\n#define MAX_TOTAL_PARAMETERS 150\n\ntypedef struct {\n    uint32_t value;\n    uint8_t  status_flags;\n} FirmwareParameter;\n\nstatic FirmwareParameter g_firmwareParameterStorage_vulnerable[MAX_TOTAL_PARAMETERS];\nstatic uint16_t g_ecuStartOffset_vulnerable[NUM_VIRTUAL_ECUS];\nstatic uint16_t g_ecuParamCounts_vulnerable[NUM_VIRTUAL_ECUS];\n\nvoid diagnosticLog_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t  ecu_id;\n    uint16_t param_index;\n    uint32_t new_value;\n} ParameterUpdateCommand;\n\nParameterUpdateCommand receiveParameterUpdateCommand_vulnerable() {\n    ParameterUpdateCommand cmd;\n    cmd.ecu_id = 1;\n    cmd.param_index = 80;\n    cmd.new_value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeEcuParameters_vulnerable() {\n    g_ecuStartOffset_vulnerable[0] = 0;\n    g_ecuParamCounts_vulnerable[0] = 70;\n\n    g_ecuStartOffset_vulnerable[1] = 70;\n    g_ecuParamCounts_vulnerable[1] = 90;\n\n    g_ecuStartOffset_vulnerable[2] = 160;\n    g_ecuParamCounts_vulnerable[2] = 50;\n\n    g_ecuStartOffset_vulnerable[3] = 210;\n    g_ecuParamCounts_vulnerable[3] = 40;\n    \n    g_ecuStartOffset_vulnerable[4] = 250;\n    g_ecuParamCounts_vulnerable[4] = 30;\n\n    for (uint16_t i = 0; i < MAX_TOTAL_PARAMETERS; ++i) {\n        g_firmwareParameterStorage_vulnerable[i] = (FirmwareParameter){0, 0};\n    }\n    diagnosticLog_vulnerable(\"ECU parameters initialized (vulnerable).\");\n}\n\nvoid processParameterUpdate_vulnerable() {\n    ParameterUpdateCommand cmd = receiveParameterUpdateCommand_vulnerable();\n\n    if (cmd.ecu_id >= NUM_VIRTUAL_ECUS) {\n        diagnosticLog_vulnerable(\"Error: Invalid ECU ID in parameter update command.\");\n        return;\n    }\n\n    if (cmd.param_index >= g_ecuParamCounts_vulnerable[cmd.ecu_id]) {\n        diagnosticLog_vulnerable(\"Error: Parameter index out of bounds for specified ECU type (local range).\");\n        return;\n    }\n\n    uint16_t base_offset = g_ecuStartOffset_vulnerable[cmd.ecu_id];\n    uint16_t absolute_param_index = base_offset + cmd.param_index;\n\n    g_firmwareParameterStorage_vulnerable[absolute_param_index].value = cmd.new_value;\n    g_firmwareParameterStorage_vulnerable[absolute_param_index].status_flags = 0x01;\n    diagnosticLog_vulnerable(\"Firmware parameter update attempted (vulnerable).\");\n}\n\nvoid main_ecu_firmware_manager_vulnerable() {\n    initializeEcuParameters_vulnerable();\n    processParameterUpdate_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define NUM_VIRTUAL_ECUS 5\n#define MAX_PARAMS_PER_ECU_TYPE 100\n#define MAX_TOTAL_PARAMETERS 150\n\ntypedef struct {\n    uint32_t value;\n    uint8_t  status_flags;\n} FirmwareParameter;\n\nstatic FirmwareParameter g_firmwareParameterStorage_fixed[MAX_TOTAL_PARAMETERS];\nstatic uint16_t g_ecuStartOffset_fixed[NUM_VIRTUAL_ECUS];\nstatic uint16_t g_ecuParamCounts_fixed[NUM_VIRTUAL_ECUS];\n\nvoid diagnosticLog_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t  ecu_id;\n    uint16_t param_index;\n    uint32_t new_value;\n} ParameterUpdateCommand;\n\nParameterUpdateCommand receiveParameterUpdateCommand_fixed() {\n    ParameterUpdateCommand cmd;\n    cmd.ecu_id = 1;\n    cmd.param_index = 80;\n    cmd.new_value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeEcuParameters_fixed() {\n    g_ecuStartOffset_fixed[0] = 0;\n    g_ecuParamCounts_fixed[0] = 70;\n\n    g_ecuStartOffset_fixed[1] = 70;\n    g_ecuParamCounts_fixed[1] = 90;\n\n    g_ecuStartOffset_fixed[2] = 160;\n    g_ecuParamCounts_fixed[2] = 50;\n\n    g_ecuStartOffset_fixed[3] = 210;\n    g_ecuParamCounts_fixed[3] = 40;\n    \n    g_ecuStartOffset_fixed[4] = 250;\n    g_ecuParamCounts_fixed[4] = 30;\n\n    for (uint16_t i = 0; i < MAX_TOTAL_PARAMETERS; ++i) {\n        g_firmwareParameterStorage_fixed[i] = (FirmwareParameter){0, 0};\n    }\n    diagnosticLog_fixed(\"ECU parameters initialized (fixed).\");\n}\n\nvoid processParameterUpdate_fixed() {\n    ParameterUpdateCommand cmd = receiveParameterUpdateCommand_fixed();\n\n    if (cmd.ecu_id >= NUM_VIRTUAL_ECUS) {\n        diagnosticLog_fixed(\"Error: Invalid ECU ID in parameter update command.\");\n        return;\n    }\n\n    if (cmd.param_index >= g_ecuParamCounts_fixed[cmd.ecu_id]) {\n        diagnosticLog_fixed(\"Error: Parameter index out of bounds for specified ECU type (local range).\");\n        return;\n    }\n\n    uint16_t base_offset = g_ecuStartOffset_fixed[cmd.ecu_id];\n    uint16_t absolute_param_index = base_offset + cmd.param_index;\n\n    if (absolute_param_index < MAX_TOTAL_PARAMETERS) {\n        g_firmwareParameterStorage_fixed[absolute_param_index].value = cmd.new_value;\n        g_firmwareParameterStorage_fixed[absolute_param_index].status_flags = 0x01;\n        diagnosticLog_fixed(\"Firmware parameter updated successfully (fixed).\");\n    } else {\n        diagnosticLog_fixed(\"Error: Calculated parameter index exceeds total storage capacity.\");\n    }\n}\n\nvoid main_ecu_firmware_manager_fixed() {\n    initializeEcuParameters_fixed();\n    processParameterUpdate_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define GLOBAL_DATA_BUFFER_SIZE_VULNERABLE 180\n#define PARAM_TYPE_COUNT_VULNERABLE 3\n\ntypedef enum {\n    PARAM_ENGINE_TEMP_HISTORY_VULNERABLE = 0,\n    PARAM_BATTERY_VOLTAGE_HISTORY_VULNERABLE,\n    PARAM_TRANSMISSION_SLIP_HISTORY_VULNERABLE,\n    PARAM_TYPE_MAX_VULNERABLE\n} VehicleParameterType_Vulnerable;\n\ntypedef struct {\n    uint16_t value;\n    uint32_t timestamp;\n} ParameterEntry_Vulnerable;\n\nstatic uint8_t g_globalParamDataBuffer_vulnerable[GLOBAL_DATA_BUFFER_SIZE_VULNERABLE];\n\ntypedef struct {\n    uint16_t start_offset_bytes;\n    uint16_t max_entries;\n    uint16_t current_entry_idx;\n} ParameterTypeConfig_Vulnerable;\n\nstatic ParameterTypeConfig_Vulnerable g_paramTypeConfigs_vulnerable[PARAM_TYPE_COUNT_VULNERABLE];\n\nvoid logVehicleInfo_vulnerable(const char* msg) {\n}\n\nvoid logVehicleError_vulnerable(const char* msg) {\n}\n\nvoid initParamLogger_vulnerable() {\n    g_paramTypeConfigs_vulnerable[PARAM_ENGINE_TEMP_HISTORY_VULNERABLE] = (ParameterTypeConfig_Vulnerable){\n        .start_offset_bytes = 0,\n        .max_entries = 5,\n        .current_entry_idx = 0\n    };\n\n    g_paramTypeConfigs_vulnerable[PARAM_BATTERY_VOLTAGE_HISTORY_VULNERABLE] = (ParameterTypeConfig_Vulnerable){\n        .start_offset_bytes = g_paramTypeConfigs_vulnerable[PARAM_ENGINE_TEMP_HISTORY_VULNERABLE].max_entries * sizeof(ParameterEntry_Vulnerable),\n        .max_entries = 5,\n        .current_entry_idx = 0\n    };\n\n    g_paramTypeConfigs_vulnerable[PARAM_TRANSMISSION_SLIP_HISTORY_VULNERABLE] = (ParameterTypeConfig_Vulnerable){\n        .start_offset_bytes = g_paramTypeConfigs_vulnerable[PARAM_ENGINE_TEMP_HISTORY_VULNERABLE].max_entries * sizeof(ParameterEntry_Vulnerable) +\n                              g_paramTypeConfigs_vulnerable[PARAM_BATTERY_VOLTAGE_HISTORY_VULNERABLE].max_entries * sizeof(ParameterEntry_Vulnerable),\n        .max_entries = 5,\n        .current_entry_idx = 0\n    };\n\n    for (uint16_t i = 0; i < GLOBAL_DATA_BUFFER_SIZE_VULNERABLE; ++i) {\n        g_globalParamDataBuffer_vulnerable[i] = 0;\n    }\n\n    logVehicleInfo_vulnerable(\"Parameter logger initialized (vulnerable).\");\n}\n\nvoid logParameterEntry_vulnerable(VehicleParameterType_Vulnerable type, uint16_t value, uint32_t timestamp) {\n    if (type >= PARAM_TYPE_MAX_VULNERABLE) {\n        logVehicleError_vulnerable(\"Invalid parameter type for logging.\");\n        return;\n    }\n\n    ParameterTypeConfig_Vulnerable* config = &g_paramTypeConfigs_vulnerable[type];\n    ParameterEntry_Vulnerable new_entry = { .value = value, .timestamp = timestamp };\n\n    uint16_t relative_offset_bytes = config->current_entry_idx * sizeof(ParameterEntry_Vulnerable);\n    uint16_t absolute_byte_offset = config->start_offset_bytes + relative_offset_bytes;\n\n    if (absolute_byte_offset + sizeof(ParameterEntry_Vulnerable) <= GLOBAL_DATA_BUFFER_SIZE_VULNERABLE) {\n        *(ParameterEntry_Vulnerable*)(g_globalParamDataBuffer_vulnerable + absolute_byte_offset) = new_entry;\n        logVehicleInfo_vulnerable(\"Parameter entry logged.\");\n        config->current_entry_idx++;\n    } else {\n        logVehicleError_vulnerable(\"Global parameter buffer limit reached, entry dropped.\");\n    }\n}\n\nvoid automotiveParameterLogging_vulnerable_main() {\n    initParamLogger_vulnerable();\n\n    logVehicleInfo_vulnerable(\"Simulating excessive ENGINE_TEMP_HISTORY logging...\");\n    for (int i = 0; i < 7; ++i) {\n        logParameterEntry_vulnerable(PARAM_ENGINE_TEMP_HISTORY_VULNERABLE, 80 + i, 0x1000 + i);\n    }\n\n    logVehicleInfo_vulnerable(\"Logging a BATTERY_VOLTAGE_HISTORY entry...\");\n    logParameterEntry_vulnerable(PARAM_BATTERY_VOLTAGE_HISTORY_VULNERABLE, 125, 0x2001);\n\n    logParameterEntry_vulnerable(PARAM_TRANSMISSION_SLIP_HISTORY_VULNERABLE, 10, 0x3001);\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define GLOBAL_DATA_BUFFER_SIZE_FIXED 180\n#define PARAM_TYPE_COUNT_FIXED 3\n\ntypedef enum {\n    PARAM_ENGINE_TEMP_HISTORY_FIXED = 0,\n    PARAM_BATTERY_VOLTAGE_HISTORY_FIXED,\n    PARAM_TRANSMISSION_SLIP_HISTORY_FIXED,\n    PARAM_TYPE_MAX_FIXED\n} VehicleParameterType_Fixed;\n\ntypedef struct {\n    uint16_t value;\n    uint32_t timestamp;\n} ParameterEntry_Fixed;\n\nstatic uint8_t g_globalParamDataBuffer_fixed[GLOBAL_DATA_BUFFER_SIZE_FIXED];\n\ntypedef struct {\n    uint16_t start_offset_bytes;\n    uint16_t max_entries;\n    uint16_t current_entry_idx;\n} ParameterTypeConfig_Fixed;\n\nstatic ParameterTypeConfig_Fixed g_paramTypeConfigs_fixed[PARAM_TYPE_COUNT_FIXED];\n\nvoid logVehicleInfo_fixed(const char* msg) {\n}\n\nvoid logVehicleError_fixed(const char* msg) {\n}\n\nvoid initParamLogger_fixed() {\n    g_paramTypeConfigs_fixed[PARAM_ENGINE_TEMP_HISTORY_FIXED] = (ParameterTypeConfig_Fixed){\n        .start_offset_bytes = 0,\n        .max_entries = 5,\n        .current_entry_idx = 0\n    };\n\n    g_paramTypeConfigs_fixed[PARAM_BATTERY_VOLTAGE_HISTORY_FIXED] = (ParameterTypeConfig_Fixed){\n        .start_offset_bytes = g_paramTypeConfigs_fixed[PARAM_ENGINE_TEMP_HISTORY_FIXED].max_entries * sizeof(ParameterEntry_Fixed),\n        .max_entries = 5,\n        .current_entry_idx = 0\n    };\n\n    g_paramTypeConfigs_fixed[PARAM_TRANSMISSION_SLIP_HISTORY_FIXED] = (ParameterTypeConfig_Fixed){\n        .start_offset_bytes = g_paramTypeConfigs_fixed[PARAM_ENGINE_TEMP_HISTORY_FIXED].max_entries * sizeof(ParameterEntry_Fixed) +\n                              g_paramTypeConfigs_fixed[PARAM_BATTERY_VOLTAGE_HISTORY_FIXED].max_entries * sizeof(ParameterEntry_Fixed),\n        .max_entries = 5,\n        .current_entry_idx = 0\n    };\n\n    for (uint16_t i = 0; i < GLOBAL_DATA_BUFFER_SIZE_FIXED; ++i) {\n        g_globalParamDataBuffer_fixed[i] = 0;\n    }\n\n    logVehicleInfo_fixed(\"Parameter logger initialized (fixed).\");\n}\n\nvoid logParameterEntry_fixed(VehicleParameterType_Fixed type, uint16_t value, uint32_t timestamp) {\n    if (type >= PARAM_TYPE_MAX_FIXED) {\n        logVehicleError_fixed(\"Invalid parameter type for logging (fixed).\");\n        return;\n    }\n\n    ParameterTypeConfig_Fixed* config = &g_paramTypeConfigs_fixed[type];\n    ParameterEntry_Fixed new_entry = { .value = value, .timestamp = timestamp };\n\n    if (config->current_entry_idx >= config->max_entries) {\n        logVehicleError_fixed(\"Parameter history buffer full for this type. Entry dropped (fixed).\");\n        return;\n    }\n\n    uint16_t relative_offset_bytes = config->current_entry_idx * sizeof(ParameterEntry_Fixed);\n    uint16_t absolute_byte_offset = config->start_offset_bytes + relative_offset_bytes;\n\n    if (absolute_byte_offset + sizeof(ParameterEntry_Fixed) <= GLOBAL_DATA_BUFFER_SIZE_FIXED) {\n        *(ParameterEntry_Fixed*)(g_globalParamDataBuffer_fixed + absolute_byte_offset) = new_entry;\n        logVehicleInfo_fixed(\"Parameter entry logged (fixed).\");\n        config->current_entry_idx++;\n    } else {\n        logVehicleError_fixed(\"Fatal: Calculated absolute offset exceeds global buffer size (fixed).\");\n    }\n}\n\nvoid automotiveParameterLogging_fixed_main() {\n    initParamLogger_fixed();\n\n    logVehicleInfo_fixed(\"Simulating excessive ENGINE_TEMP_HISTORY logging (fixed)...\");\n    for (int i = 0; i < 7; ++i) {\n        logParameterEntry_fixed(PARAM_ENGINE_TEMP_HISTORY_FIXED, 80 + i, 0x1000 + i);\n    }\n\n    logVehicleInfo_fixed(\"Logging a BATTERY_VOLTAGE_HISTORY entry (fixed)...\");\n    logParameterEntry_fixed(PARAM_BATTERY_VOLTAGE_HISTORY_FIXED, 125, 0x2001);\n\n    logParameterEntry_fixed(PARAM_TRANSMISSION_SLIP_HISTORY_FIXED, 10, 0x3001);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_FAULT_TYPES 3\n#define MAX_LOG_ENTRIES_PER_TYPE 5\n\ntypedef struct {\n    uint16_t code;\n    uint32_t timestamp;\n} FaultLogEntry;\n\nstatic FaultLogEntry g_faultLog_vulnerable[MAX_FAULT_TYPES][MAX_LOG_ENTRIES_PER_TYPE];\nstatic uint8_t g_currentLogCount_vulnerable[MAX_FAULT_TYPES];\n\nvoid logSystemActivity_Vulnerable(const char* msg) {\n    fprintf(stderr, \"VULN_LOG: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t fault_type_id;\n    uint16_t fault_code;\n    uint32_t event_timestamp;\n} IncomingFaultReport_Vulnerable;\n\nstatic uint8_t s_simulated_fault_count_vulnerable = 0;\nIncomingFaultReport_Vulnerable simulateIncomingFault_Vulnerable() {\n    IncomingFaultReport_Vulnerable report;\n    report.fault_type_id = 0;\n    report.fault_code = 0x1234 + s_simulated_fault_count_vulnerable;\n    report.event_timestamp = 0xABCDEF00 + s_simulated_fault_count_vulnerable;\n    s_simulated_fault_count_vulnerable++;\n    return report;\n}\n\nvoid initializeFaultLoggingSystem_Vulnerable() {\n    for (uint8_t i = 0; i < MAX_FAULT_TYPES; ++i) {\n        g_currentLogCount_vulnerable[i] = 0;\n        for (uint8_t j = 0; j < MAX_LOG_ENTRIES_PER_TYPE; ++j) {\n            g_faultLog_vulnerable[i][j] = (FaultLogEntry){0, 0};\n        }\n    }\n    s_simulated_fault_count_vulnerable = 0;\n    logSystemActivity_Vulnerable(\"Fault logging system initialized (vulnerable).\");\n}\n\nvoid recordFault_Vulnerable(IncomingFaultReport_Vulnerable report) {\n    if (report.fault_type_id < MAX_FAULT_TYPES) {\n        FaultLogEntry new_entry;\n        new_entry.code = report.fault_code;\n        new_entry.timestamp = report.event_timestamp;\n\n        g_faultLog_vulnerable[report.fault_type_id][g_currentLogCount_vulnerable[report.fault_type_id]] = new_entry;\n        g_currentLogCount_vulnerable[report.fault_type_id]++;\n        logSystemActivity_Vulnerable(\"Fault recorded (vulnerable).\");\n    } else {\n        logSystemActivity_Vulnerable(\"Invalid fault type ID received. Ignoring report.\");\n    }\n}\n\nvoid automotiveFaultManager_Vulnerable() {\n    initializeFaultLoggingSystem_Vulnerable();\n\n    for (int i = 0; i < MAX_LOG_ENTRIES_PER_TYPE + 1; ++i) {\n        IncomingFaultReport_Vulnerable fault = simulateIncomingFault_Vulnerable();\n        recordFault_Vulnerable(fault);\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_FAULT_TYPES 3\n#define MAX_LOG_ENTRIES_PER_TYPE 5\n\ntypedef struct {\n    uint16_t code;\n    uint32_t timestamp;\n} FaultLogEntry;\n\nstatic FaultLogEntry g_faultLog_Fixed[MAX_FAULT_TYPES][MAX_LOG_ENTRIES_PER_TYPE];\nstatic uint8_t g_currentLogCount_Fixed[MAX_FAULT_TYPES];\n\nvoid logSystemActivity_Fixed(const char* msg) {\n    fprintf(stderr, \"FIXED_LOG: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t fault_type_id;\n    uint16_t fault_code;\n    uint32_t event_timestamp;\n} IncomingFaultReport_Fixed;\n\nstatic uint8_t s_simulated_fault_count_fixed = 0;\nIncomingFaultReport_Fixed simulateIncomingFault_Fixed() {\n    IncomingFaultReport_Fixed report;\n    report.fault_type_id = 0;\n    report.fault_code = 0x1234 + s_simulated_fault_count_fixed;\n    report.event_timestamp = 0xABCDEF00 + s_simulated_fault_count_fixed;\n    s_simulated_fault_count_fixed++;\n    return report;\n}\n\nvoid initializeFaultLoggingSystem_Fixed() {\n    for (uint8_t i = 0; i < MAX_FAULT_TYPES; ++i) {\n        g_currentLogCount_Fixed[i] = 0;\n        for (uint8_t j = 0; j < MAX_LOG_ENTRIES_PER_TYPE; ++j) {\n            g_faultLog_Fixed[i][j] = (FaultLogEntry){0, 0};\n        }\n    }\n    s_simulated_fault_count_fixed = 0;\n    logSystemActivity_Fixed(\"Fault logging system initialized (fixed).\");\n}\n\nvoid recordFault_Fixed(IncomingFaultReport_Fixed report) {\n    if (report.fault_type_id < MAX_FAULT_TYPES) {\n        if (g_currentLogCount_Fixed[report.fault_type_id] < MAX_LOG_ENTRIES_PER_TYPE) {\n            FaultLogEntry new_entry;\n            new_entry.code = report.fault_code;\n            new_entry.timestamp = report.event_timestamp;\n\n            g_faultLog_Fixed[report.fault_type_id][g_currentLogCount_Fixed[report.fault_type_id]] = new_entry;\n            g_currentLogCount_Fixed[report.fault_type_id]++;\n            logSystemActivity_Fixed(\"Fault recorded (fixed).\");\n        } else {\n            logSystemActivity_Fixed(\"Fault log for this type is full. Ignoring new entry.\");\n        }\n    } else {\n        logSystemActivity_Fixed(\"Invalid fault type ID received. Ignoring report.\");\n    }\n}\n\nvoid automotiveFaultManager_Fixed() {\n    initializeFaultLoggingSystem_Fixed();\n\n    for (int i = 0; i < MAX_LOG_ENTRIES_PER_TYPE + 1; ++i) {\n        IncomingFaultReport_Fixed fault = simulateIncomingFault_Fixed();\n        recordFault_Fixed(fault);\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_FEATURES_VULNERABLE 5\n\ntypedef struct {\n    uint16_t feature_id;\n    bool is_active;\n    uint8_t current_level;\n    uint8_t reserved_status;\n} VehicleFeature_Vulnerable;\n\nstatic VehicleFeature_Vulnerable g_vehicleFeatures_vulnerable[MAX_VEHICLE_FEATURES_VULNERABLE];\n\ntypedef struct {\n    uint16_t command_code;\n    uint8_t target_feature_idx;\n    uint8_t requested_level;\n    uint8_t padding[4];\n} DiagnosticCommand_Vulnerable;\n\nvoid vehicleSystemLog_vulnerable(const char* message) {\n}\n\nDiagnosticCommand_Vulnerable receiveDiagnosticCommand_vulnerable() {\n    DiagnosticCommand_Vulnerable cmd;\n    cmd.command_code = 0x10;\n    cmd.target_feature_idx = MAX_VEHICLE_FEATURES_VULNERABLE; \n    cmd.requested_level = 2;\n    cmd.padding[0] = 0; cmd.padding[1] = 0; cmd.padding[2] = 0; cmd.padding[3] = 0;\n    return cmd;\n}\n\nvoid initializeVehicleFeatures_vulnerable() {\n    for (int i = 0; i < MAX_VEHICLE_FEATURES_VULNERABLE; ++i) {\n        g_vehicleFeatures_vulnerable[i].feature_id = 1000 + i;\n        g_vehicleFeatures_vulnerable[i].is_active = false;\n        g_vehicleFeatures_vulnerable[i].current_level = 0;\n        g_vehicleFeatures_vulnerable[i].reserved_status = 0;\n    }\n    g_vehicleFeatures_vulnerable[0].is_active = true;\n    g_vehicleFeatures_vulnerable[0].current_level = 1;\n    g_vehicleFeatures_vulnerable[2].is_active = true;\n    g_vehicleFeatures_vulnerable[2].current_level = 0;\n    vehicleSystemLog_vulnerable(\"Vehicle features initialized.\");\n}\n\nvoid processVehicleControlCommand_vulnerable() {\n    DiagnosticCommand_Vulnerable cmd = receiveDiagnosticCommand_vulnerable();\n\n    switch (cmd.command_code) {\n        case 0x10:\n            g_vehicleFeatures_vulnerable[cmd.target_feature_idx].current_level = cmd.requested_level;\n            g_vehicleFeatures_vulnerable[cmd.target_feature_idx].is_active = (cmd.requested_level > 0);\n            vehicleSystemLog_vulnerable(\"Feature state update processed.\");\n            break;\n        case 0x11:\n            vehicleSystemLog_vulnerable(\"Query feature state command received.\");\n            break;\n        default:\n            vehicleSystemLog_vulnerable(\"Unsupported diagnostic command received.\");\n            break;\n    }\n}\n\nvoid vehicleMainControlLoop_vulnerable() {\n    initializeVehicleFeatures_vulnerable();\n    processVehicleControlCommand_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_FEATURES_FIXED 5\n\ntypedef struct {\n    uint16_t feature_id;\n    bool is_active;\n    uint8_t current_level;\n    uint8_t reserved_status;\n} VehicleFeature_Fixed;\n\nstatic VehicleFeature_Fixed g_vehicleFeatures_fixed[MAX_VEHICLE_FEATURES_FIXED];\n\ntypedef struct {\n    uint16_t command_code;\n    uint8_t target_feature_idx;\n    uint8_t requested_level;\n    uint8_t padding[4];\n} DiagnosticCommand_Fixed;\n\nvoid vehicleSystemLog_fixed(const char* message) {\n}\n\nDiagnosticCommand_Fixed receiveDiagnosticCommand_fixed() {\n    DiagnosticCommand_Fixed cmd;\n    cmd.command_code = 0x10;\n    cmd.target_feature_idx = MAX_VEHICLE_FEATURES_FIXED; \n    cmd.requested_level = 2;\n    cmd.padding[0] = 0; cmd.padding[1] = 0; cmd.padding[2] = 0; cmd.padding[3] = 0;\n    return cmd;\n}\n\nvoid initializeVehicleFeatures_fixed() {\n    for (int i = 0; i < MAX_VEHICLE_FEATURES_FIXED; ++i) {\n        g_vehicleFeatures_fixed[i].feature_id = 1000 + i;\n        g_vehicleFeatures_fixed[i].is_active = false;\n        g_vehicleFeatures_fixed[i].current_level = 0;\n        g_vehicleFeatures_fixed[i].reserved_status = 0;\n    }\n    g_vehicleFeatures_fixed[0].is_active = true;\n    g_vehicleFeatures_fixed[0].current_level = 1;\n    g_vehicleFeatures_fixed[2].is_active = true;\n    g_vehicleFeatures_fixed[2].current_level = 0;\n    vehicleSystemLog_fixed(\"Vehicle features initialized (fixed).\");\n}\n\nvoid processVehicleControlCommand_fixed() {\n    DiagnosticCommand_Fixed cmd = receiveDiagnosticCommand_fixed();\n\n    switch (cmd.command_code) {\n        case 0x10:\n            if (cmd.target_feature_idx < MAX_VEHICLE_FEATURES_FIXED) {\n                g_vehicleFeatures_fixed[cmd.target_feature_idx].current_level = cmd.requested_level;\n                g_vehicleFeatures_fixed[cmd.target_feature_idx].is_active = (cmd.requested_level > 0);\n                vehicleSystemLog_fixed(\"Feature state update processed successfully (fixed).\");\n            } else {\n                vehicleSystemLog_fixed(\"Error: Invalid feature index received in diagnostic command (fixed).\");\n            }\n            break;\n        case 0x11:\n            vehicleSystemLog_fixed(\"Query feature state command received (fixed).\");\n            break;\n        default:\n            vehicleSystemLog_fixed(\"Unsupported diagnostic command received (fixed).\");\n            break;\n    }\n}\n\nvoid vehicleMainControlLoop_fixed() {\n    initializeVehicleFeatures_fixed();\n    processVehicleControlCommand_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_TEMPERATURE_SENSORS 10\n#define MAX_PRESSURE_SENSORS 5\n#define MAX_FUEL_LEVEL_SENSORS 2\n\ntypedef struct {\n    int16_t offset;\n    float gain;\n    uint8_t status_flags;\n} TemperatureCalibration;\n\ntypedef struct {\n    int16_t offset_low;\n    int16_t offset_high;\n    float gain;\n    uint8_t checksum;\n} PressureCalibration;\n\ntypedef struct {\n    uint16_t empty_resistance_ohm;\n    uint16_t full_resistance_ohm;\n} FuelLevelCalibration;\n\nstatic TemperatureCalibration g_tempCalibData[MAX_TEMPERATURE_SENSORS];\nstatic PressureCalibration g_pressureCalibData[MAX_PRESSURE_SENSORS];\nstatic FuelLevelCalibration g_fuelLevelCalibData[MAX_FUEL_LEVEL_SENSORS];\n\ntypedef enum {\n    SENSOR_TYPE_TEMP = 0,\n    SENSOR_TYPE_PRESSURE,\n    SENSOR_TYPE_FUEL_LEVEL,\n    NUM_SENSOR_TYPES_CALIB\n} SensorCalibrationType;\n\ntypedef struct {\n    uint8_t command_type;\n    uint8_t sensor_type_id;\n    uint8_t sensor_instance_id;\n    union {\n        TemperatureCalibration temp_cal;\n        PressureCalibration pres_cal;\n        FuelLevelCalibration fuel_cal;\n    } cal_data;\n} CalibrationCommand;\n\nvoid systemLog(const char* msg) {\n}\n\nCalibrationCommand receiveCalibrationCommand_vulnerable() {\n    CalibrationCommand cmd;\n    cmd.command_type = 0x01;\n    cmd.sensor_type_id = SENSOR_TYPE_TEMP;\n    cmd.sensor_instance_id = MAX_TEMPERATURE_SENSORS;\n    cmd.cal_data.temp_cal = (TemperatureCalibration){-5, 1.05f, 0x0F};\n    return cmd;\n}\n\nvoid initializeCalibrationData_vulnerable() {\n    for (uint8_t i = 0; i < MAX_TEMPERATURE_SENSORS; ++i) {\n        g_tempCalibData[i] = (TemperatureCalibration){0, 1.0f, 0};\n    }\n    for (uint8_t i = 0; i < MAX_PRESSURE_SENSORS; ++i) {\n        g_pressureCalibData[i] = (PressureCalibration){0, 0, 1.0f, 0};\n    }\n    for (uint8_t i = 0; i < MAX_FUEL_LEVEL_SENSORS; ++i) {\n        g_fuelLevelCalibData[i] = (FuelLevelCalibration){0, 0};\n    }\n    systemLog(\"Calibration data initialized (vulnerable).\");\n}\n\nvoid processCalibrationCommand_vulnerable() {\n    CalibrationCommand cmd = receiveCalibrationCommand_vulnerable();\n\n    if (cmd.command_type == 0x01) {\n        switch (cmd.sensor_type_id) {\n            case SENSOR_TYPE_TEMP:\n                g_tempCalibData[cmd.sensor_instance_id] = cmd.cal_data.temp_cal;\n                systemLog(\"Temperature sensor calibration update attempted (vulnerable).\");\n                break;\n            case SENSOR_TYPE_PRESSURE:\n                g_pressureCalibData[cmd.sensor_instance_id] = cmd.cal_data.pres_cal;\n                systemLog(\"Pressure sensor calibration update attempted (vulnerable).\");\n                break;\n            case SENSOR_TYPE_FUEL_LEVEL:\n                g_fuelLevelCalibData[cmd.sensor_instance_id] = cmd.cal_data.fuel_cal;\n                systemLog(\"Fuel level sensor calibration update attempted (vulnerable).\");\n                break;\n            default:\n                systemLog(\"Unknown sensor type ID in calibration command (vulnerable).\");\n                break;\n        }\n    } else {\n        systemLog(\"Unsupported calibration command type (vulnerable).\");\n    }\n}\n\nvoid sensorCalibrationManager_vulnerable_main() {\n    initializeCalibrationData_vulnerable();\n    processCalibrationCommand_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_TEMPERATURE_SENSORS 10\n#define MAX_PRESSURE_SENSORS 5\n#define MAX_FUEL_LEVEL_SENSORS 2\n\ntypedef struct {\n    int16_t offset;\n    float gain;\n    uint8_t status_flags;\n} TemperatureCalibration;\n\ntypedef struct {\n    int16_t offset_low;\n    int16_t offset_high;\n    float gain;\n    uint8_t checksum;\n} PressureCalibration;\n\ntypedef struct {\n    uint16_t empty_resistance_ohm;\n    uint16_t full_resistance_ohm;\n} FuelLevelCalibration;\n\nstatic TemperatureCalibration g_tempCalibData_fixed[MAX_TEMPERATURE_SENSORS];\nstatic PressureCalibration g_pressureCalibData_fixed[MAX_PRESSURE_SENSORS];\nstatic FuelLevelCalibration g_fuelLevelCalibData_fixed[MAX_FUEL_LEVEL_SENSORS];\n\ntypedef enum {\n    SENSOR_TYPE_TEMP = 0,\n    SENSOR_TYPE_PRESSURE,\n    SENSOR_TYPE_FUEL_LEVEL,\n    NUM_SENSOR_TYPES_CALIB\n} SensorCalibrationType;\n\ntypedef struct {\n    uint8_t command_type;\n    uint8_t sensor_type_id;\n    uint8_t sensor_instance_id;\n    union {\n        TemperatureCalibration temp_cal;\n        PressureCalibration pres_cal;\n        FuelLevelCalibration fuel_cal;\n    } cal_data;\n} CalibrationCommand;\n\nvoid systemLog(const char* msg) {\n}\n\nCalibrationCommand receiveCalibrationCommand_fixed() {\n    CalibrationCommand cmd;\n    cmd.command_type = 0x01;\n    cmd.sensor_type_id = SENSOR_TYPE_TEMP;\n    cmd.sensor_instance_id = MAX_TEMPERATURE_SENSORS;\n    cmd.cal_data.temp_cal = (TemperatureCalibration){-5, 1.05f, 0x0F};\n    return cmd;\n}\n\nvoid initializeCalibrationData_fixed() {\n    for (uint8_t i = 0; i < MAX_TEMPERATURE_SENSORS; ++i) {\n        g_tempCalibData_fixed[i] = (TemperatureCalibration){0, 1.0f, 0};\n    }\n    for (uint8_t i = 0; i < MAX_PRESSURE_SENSORS; ++i) {\n        g_pressureCalibData_fixed[i] = (PressureCalibration){0, 0, 1.0f, 0};\n    }\n    for (uint8_t i = 0; i < MAX_FUEL_LEVEL_SENSORS; ++i) {\n        g_fuelLevelCalibData_fixed[i] = (FuelLevelCalibration){0, 0};\n    }\n    systemLog(\"Calibration data initialized (fixed).\");\n}\n\nvoid processCalibrationCommand_fixed() {\n    CalibrationCommand cmd = receiveCalibrationCommand_fixed();\n\n    if (cmd.command_type == 0x01) {\n        switch (cmd.sensor_type_id) {\n            case SENSOR_TYPE_TEMP:\n                if (cmd.sensor_instance_id < MAX_TEMPERATURE_SENSORS) {\n                    g_tempCalibData_fixed[cmd.sensor_instance_id] = cmd.cal_data.temp_cal;\n                    systemLog(\"Temperature sensor calibration updated successfully (fixed).\");\n                } else {\n                    systemLog(\"Temperature sensor instance ID out of bounds. Update ignored (fixed).\");\n                }\n                break;\n            case SENSOR_TYPE_PRESSURE:\n                if (cmd.sensor_instance_id < MAX_PRESSURE_SENSORS) {\n                    g_pressureCalibData_fixed[cmd.sensor_instance_id] = cmd.cal_data.pres_cal;\n                    systemLog(\"Pressure sensor calibration updated successfully (fixed).\");\n                } else {\n                    systemLog(\"Pressure sensor instance ID out of bounds. Update ignored (fixed).\");\n                }\n                break;\n            case SENSOR_TYPE_FUEL_LEVEL:\n                if (cmd.sensor_instance_id < MAX_FUEL_LEVEL_SENSORS) {\n                    g_fuelLevelCalibData_fixed[cmd.sensor_instance_id] = cmd.cal_data.fuel_cal;\n                    systemLog(\"Fuel level sensor calibration updated successfully (fixed).\");\n                } else {\n                    systemLog(\"Fuel level sensor instance ID out of bounds. Update ignored (fixed).\");\n                }\n                break;\n            default:\n                systemLog(\"Unknown sensor type ID in calibration command. Command ignored (fixed).\");\n                break;\n        }\n    } else {\n        systemLog(\"Unsupported calibration command type. Command ignored (fixed).\");\n    }\n}\n\nvoid sensorCalibrationManager_fixed_main() {\n    initializeCalibrationData_fixed();\n    processCalibrationCommand_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_ENGINE_PARAMS 10\n#define MAX_CHASSIS_PARAMS 15\n#define MAX_INFOTAINMENT_PARAMS 5\n\n#define GLOBAL_MAX_PARAMETER_INDEX 100\n\ntypedef enum {\n    MODULE_ENGINE = 0,\n    MODULE_CHASSIS,\n    MODULE_INFOTAINMENT,\n    NUM_VEHICLE_MODULES_VULNERABLE\n} VehicleModuleType_Vulnerable;\n\ntypedef struct {\n    uint16_t id;\n    int32_t  value;\n    bool     is_calibrated;\n} ParameterData_Vulnerable;\n\nstatic ParameterData_Vulnerable g_engineParameters_Vulnerable[MAX_ENGINE_PARAMS];\nstatic ParameterData_Vulnerable g_chassisParameters_Vulnerable[MAX_CHASSIS_PARAMS];\nstatic ParameterData_Vulnerable g_infotainmentParameters_Vulnerable[MAX_INFOTAINMENT_PARAMS];\n\nstatic ParameterData_Vulnerable* g_moduleParameterArrays_Vulnerable[NUM_VEHICLE_MODULES_VULNERABLE];\nstatic uint16_t g_moduleCapacities_Vulnerable[NUM_VEHICLE_MODULES_VULNERABLE];\n\nvoid logVehicleState_Vulnerable(const char* msg) {\n    printf(\"VULN_LOG: %s\\n\", msg);\n}\n\ntypedef struct {\n    VehicleModuleType_Vulnerable module_id;\n    uint16_t parameter_index;\n    int32_t new_value;\n} ParameterUpdateCommand_Vulnerable;\n\nParameterUpdateCommand_Vulnerable getIncomingParameterUpdate_Vulnerable() {\n    ParameterUpdateCommand_Vulnerable cmd;\n    cmd.module_id = MODULE_INFOTAINMENT;\n    cmd.parameter_index = 5; \n    cmd.new_value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeVehicleParameters_Vulnerable() {\n    g_moduleParameterArrays_Vulnerable[MODULE_ENGINE] = g_engineParameters_Vulnerable;\n    g_moduleCapacities_Vulnerable[MODULE_ENGINE] = MAX_ENGINE_PARAMS;\n\n    g_moduleParameterArrays_Vulnerable[MODULE_CHASSIS] = g_chassisParameters_Vulnerable;\n    g_moduleCapacities_Vulnerable[MODULE_CHASSIS] = MAX_CHASSIS_PARAMS;\n\n    g_moduleParameterArrays_Vulnerable[MODULE_INFOTAINMENT] = g_infotainmentParameters_Vulnerable;\n    g_moduleCapacities_Vulnerable[MODULE_INFOTAINMENT] = MAX_INFOTAINMENT_PARAMS;\n\n    for (int i = 0; i < NUM_VEHICLE_MODULES_VULNERABLE; ++i) {\n        for (uint16_t j = 0; j < g_moduleCapacities_Vulnerable[i]; ++j) {\n            g_moduleParameterArrays_Vulnerable[i][j] = (ParameterData_Vulnerable){0, 0, false};\n        }\n    }\n    logVehicleState_Vulnerable(\"Vehicle parameters initialized.\");\n}\n\nvoid processParameterUpdate_Vulnerable() {\n    ParameterUpdateCommand_Vulnerable cmd = getIncomingParameterUpdate_Vulnerable();\n\n    if (cmd.module_id >= NUM_VEHICLE_MODULES_VULNERABLE) {\n        logVehicleState_Vulnerable(\"Error: Invalid module ID received.\");\n        return;\n    }\n\n    if (cmd.parameter_index < GLOBAL_MAX_PARAMETER_INDEX) {\n        ParameterData_Vulnerable* target_array = g_moduleParameterArrays_Vulnerable[cmd.module_id];\n        \n        target_array[cmd.parameter_index].value = cmd.new_value;\n        target_array[cmd.parameter_index].is_calibrated = true;\n        logVehicleState_Vulnerable(\"Parameter updated successfully.\");\n    } else {\n        logVehicleState_Vulnerable(\"Error: Invalid parameter index received (general check failed).\");\n    }\n}\n\nvoid vehicleControlUnitMain_Vulnerable() {\n    initializeVehicleParameters_Vulnerable();\n    processParameterUpdate_Vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_ENGINE_PARAMS 10\n#define MAX_CHASSIS_PARAMS 15\n#define MAX_INFOTAINMENT_PARAMS 5\n\n#define GLOBAL_MAX_PARAMETER_INDEX 100 \n\ntypedef enum {\n    MODULE_ENGINE = 0,\n    MODULE_CHASSIS,\n    MODULE_INFOTAINMENT,\n    NUM_VEHICLE_MODULES_FIXED\n} VehicleModuleType_Fixed;\n\ntypedef struct {\n    uint16_t id;\n    int32_t  value;\n    bool     is_calibrated;\n} ParameterData_Fixed;\n\nstatic ParameterData_Fixed g_engineParameters_Fixed[MAX_ENGINE_PARAMS];\nstatic ParameterData_Fixed g_chassisParameters_Fixed[MAX_CHASSIS_PARAMS];\nstatic ParameterData_Fixed g_infotainmentParameters_Fixed[MAX_INFOTAINMENT_PARAMS];\n\nstatic ParameterData_Fixed* g_moduleParameterArrays_Fixed[NUM_VEHICLE_MODULES_FIXED];\nstatic uint16_t g_moduleCapacities_Fixed[NUM_VEHICLE_MODULES_FIXED];\n\nvoid logVehicleState_Fixed(const char* msg) {\n    printf(\"FIXED_LOG: %s\\n\", msg);\n}\n\ntypedef struct {\n    VehicleModuleType_Fixed module_id;\n    uint16_t parameter_index;\n    int32_t new_value;\n} ParameterUpdateCommand_Fixed;\n\nParameterUpdateCommand_Fixed getIncomingParameterUpdate_Fixed() {\n    ParameterUpdateCommand_Fixed cmd;\n    cmd.module_id = MODULE_INFOTAINMENT;\n    cmd.parameter_index = 5;\n    cmd.new_value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeVehicleParameters_Fixed() {\n    g_moduleParameterArrays_Fixed[MODULE_ENGINE] = g_engineParameters_Fixed;\n    g_moduleCapacities_Fixed[MODULE_ENGINE] = MAX_ENGINE_PARAMS;\n\n    g_moduleParameterArrays_Fixed[MODULE_CHASSIS] = g_chassisParameters_Fixed;\n    g_moduleCapacities_Fixed[MODULE_CHASSIS] = MAX_CHASSIS_PARAMS;\n\n    g_moduleParameterArrays_Fixed[MODULE_INFOTAINMENT] = g_infotainmentParameters_Fixed;\n    g_moduleCapacities_Fixed[MODULE_INFOTAINMENT] = MAX_INFOTAINMENT_PARAMS;\n\n    for (int i = 0; i < NUM_VEHICLE_MODULES_FIXED; ++i) {\n        for (uint16_t j = 0; j < g_moduleCapacities_Fixed[i]; ++j) {\n            g_moduleParameterArrays_Fixed[i][j] = (ParameterData_Fixed){0, 0, false};\n        }\n    }\n    logVehicleState_Fixed(\"Vehicle parameters initialized.\");\n}\n\nvoid processParameterUpdate_Fixed() {\n    ParameterUpdateCommand_Fixed cmd = getIncomingParameterUpdate_Fixed();\n\n    if (cmd.module_id >= NUM_VEHICLE_MODULES_FIXED) {\n        logVehicleState_Fixed(\"Error: Invalid module ID received.\");\n        return;\n    }\n\n    if (cmd.parameter_index < g_moduleCapacities_Fixed[cmd.module_id]) {\n        ParameterData_Fixed* target_array = g_moduleParameterArrays_Fixed[cmd.module_id];\n        \n        target_array[cmd.parameter_index].value = cmd.new_value;\n        target_array[cmd.parameter_index].is_calibrated = true;\n        logVehicleState_Fixed(\"Parameter updated successfully.\");\n    } else {\n        logVehicleState_Fixed(\"Error: Parameter index out of bounds for the selected module.\");\n    }\n}\n\nvoid vehicleControlUnitMain_Fixed() {\n    initializeVehicleParameters_Fixed();\n    processParameterUpdate_Fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define TOTAL_FIRMWARE_MEMORY_BYTES_VULNERABLE 2048\n#define PAGE_SIZE_BYTES_VULNERABLE 64\n#define MAX_COMPONENTS_VULNERABLE 3\n\nstatic uint8_t g_firmwareMemory_vulnerable[TOTAL_FIRMWARE_MEMORY_BYTES_VULNERABLE];\n\ntypedef enum {\n    COMPONENT_ENGINE_CONTROL_VULNERABLE = 0,\n    COMPONENT_TRANSMISSION_CONTROL_VULNERABLE,\n    COMPONENT_BRAKE_SYSTEM_VULNERABLE,\n    COMPONENT_INVALID_VULNERABLE\n} ComponentID_Vulnerable;\n\ntypedef struct {\n    size_t start_offset_bytes;\n    size_t bank_size_pages;\n} ComponentFirmwareBankConfig_Vulnerable;\n\nstatic ComponentFirmwareBankConfig_Vulnerable g_componentBankConfigs_vulnerable[MAX_COMPONENTS_VULNERABLE];\n\nvoid logFirmwareUpdateEvent_vulnerable(const char* msg) {\n}\n\nvoid logFirmwareUpdateError_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    ComponentID_Vulnerable component_id;\n    uint16_t page_index;\n    uint8_t data[PAGE_SIZE_BYTES_VULNERABLE];\n} FirmwareUpdatePacket_Vulnerable;\n\nFirmwareUpdatePacket_Vulnerable receiveFirmwareUpdatePacket_vulnerable() {\n    FirmwareUpdatePacket_Vulnerable packet;\n    packet.component_id = COMPONENT_ENGINE_CONTROL_VULNERABLE;\n    packet.page_index = 20;\n    for (int i = 0; i < PAGE_SIZE_BYTES_VULNERABLE; ++i) {\n        packet.data[i] = (uint8_t)i;\n    }\n    return packet;\n}\n\nvoid initializeFirmwareBanks_vulnerable() {\n    g_componentBankConfigs_vulnerable[COMPONENT_ENGINE_CONTROL_VULNERABLE] = (ComponentFirmwareBankConfig_Vulnerable){\n        .start_offset_bytes = 0,\n        .bank_size_pages = 10\n    };\n    g_componentBankConfigs_vulnerable[COMPONENT_TRANSMISSION_CONTROL_VULNERABLE] = (ComponentFirmwareBankConfig_Vulnerable){\n        .start_offset_bytes = g_componentBankConfigs_vulnerable[COMPONENT_ENGINE_CONTROL_VULNERABLE].start_offset_bytes +\n                              g_componentBankConfigs_vulnerable[COMPONENT_ENGINE_CONTROL_VULNERABLE].bank_size_pages * PAGE_SIZE_BYTES_VULNERABLE,\n        .bank_size_pages = 15\n    };\n    g_componentBankConfigs_vulnerable[COMPONENT_BRAKE_SYSTEM_VULNERABLE] = (ComponentFirmwareBankConfig_Vulnerable){\n        .start_offset_bytes = g_componentBankConfigs_vulnerable[COMPONENT_TRANSMISSION_CONTROL_VULNERABLE].start_offset_bytes +\n                              g_componentBankConfigs_vulnerable[COMPONENT_TRANSMISSION_CONTROL_VULNERABLE].bank_size_pages * PAGE_SIZE_BYTES_VULNERABLE,\n        .bank_size_pages = 8\n    };\n\n    for (size_t i = 0; i < TOTAL_FIRMWARE_MEMORY_BYTES_VULNERABLE; ++i) {\n        g_firmwareMemory_vulnerable[i] = 0;\n    }\n\n    logFirmwareUpdateEvent_vulnerable(\"Firmware banks initialized (vulnerable).\");\n}\n\nvoid applyFirmwareUpdate_vulnerable(FirmwareUpdatePacket_Vulnerable update_packet) {\n    if (update_packet.component_id >= COMPONENT_INVALID_VULNERABLE) {\n        logFirmwareUpdateError_vulnerable(\"Invalid component ID in firmware update.\");\n        return;\n    }\n\n    ComponentFirmwareBankConfig_Vulnerable config = g_componentBankConfigs_vulnerable[update_packet.component_id];\n\n    size_t target_byte_offset = config.start_offset_bytes + (size_t)update_packet.page_index * PAGE_SIZE_BYTES_VULNERABLE;\n\n    if (target_byte_offset + PAGE_SIZE_BYTES_VULNERABLE <= TOTAL_FIRMWARE_MEMORY_BYTES_VULNERABLE) {\n        for (size_t i = 0; i < PAGE_SIZE_BYTES_VULNERABLE; ++i) {\n            g_firmwareMemory_vulnerable[target_byte_offset + i] = update_packet.data[i];\n        }\n        logFirmwareUpdateEvent_vulnerable(\"Firmware page updated.\");\n    } else {\n        logFirmwareUpdateError_vulnerable(\"Firmware update would write out of total memory bounds.\");\n    }\n}\n\nvoid firmwareUpdateManager_vulnerable_main() {\n    initializeFirmwareBanks_vulnerable();\n    FirmwareUpdatePacket_Vulnerable cmd = receiveFirmwareUpdatePacket_vulnerable();\n    applyFirmwareUpdate_vulnerable(cmd);\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define TOTAL_FIRMWARE_MEMORY_BYTES_FIXED 2048\n#define PAGE_SIZE_BYTES_FIXED 64\n#define MAX_COMPONENTS_FIXED 3\n\nstatic uint8_t g_firmwareMemory_fixed[TOTAL_FIRMWARE_MEMORY_BYTES_FIXED];\n\ntypedef enum {\n    COMPONENT_ENGINE_CONTROL_FIXED = 0,\n    COMPONENT_TRANSMISSION_CONTROL_FIXED,\n    COMPONENT_BRAKE_SYSTEM_FIXED,\n    COMPONENT_INVALID_FIXED\n} ComponentID_Fixed;\n\ntypedef struct {\n    size_t start_offset_bytes;\n    size_t bank_size_pages;\n} ComponentFirmwareBankConfig_Fixed;\n\nstatic ComponentFirmwareBankConfig_Fixed g_componentBankConfigs_fixed[MAX_COMPONENTS_FIXED];\n\nvoid logFirmwareUpdateEvent_fixed(const char* msg) {\n}\n\nvoid logFirmwareUpdateError_fixed(const char* msg) {\n}\n\ntypedef struct {\n    ComponentID_Fixed component_id;\n    uint16_t page_index;\n    uint8_t data[PAGE_SIZE_BYTES_FIXED];\n} FirmwareUpdatePacket_Fixed;\n\nFirmwareUpdatePacket_Fixed receiveFirmwareUpdatePacket_fixed() {\n    FirmwareUpdatePacket_Fixed packet;\n    packet.component_id = COMPONENT_ENGINE_CONTROL_FIXED;\n    packet.page_index = 20;\n    for (int i = 0; i < PAGE_SIZE_BYTES_FIXED; ++i) {\n        packet.data[i] = (uint8_t)i;\n    }\n    return packet;\n}\n\nvoid initializeFirmwareBanks_fixed() {\n    g_componentBankConfigs_fixed[COMPONENT_ENGINE_CONTROL_FIXED] = (ComponentFirmwareBankConfig_Fixed){\n        .start_offset_bytes = 0,\n        .bank_size_pages = 10\n    };\n    g_componentBankConfigs_fixed[COMPONENT_TRANSMISSION_CONTROL_FIXED] = (ComponentFirmwareBankConfig_Fixed){\n        .start_offset_bytes = g_componentBankConfigs_fixed[COMPONENT_ENGINE_CONTROL_FIXED].start_offset_bytes +\n                              g_componentBankConfigs_fixed[COMPONENT_ENGINE_CONTROL_FIXED].bank_size_pages * PAGE_SIZE_BYTES_FIXED,\n        .bank_size_pages = 15\n    };\n    g_componentBankConfigs_fixed[COMPONENT_BRAKE_SYSTEM_FIXED] = (ComponentFirmwareBankConfig_Fixed){\n        .start_offset_bytes = g_componentBankConfigs_fixed[COMPONENT_TRANSMISSION_CONTROL_FIXED].start_offset_bytes +\n                              g_componentBankConfigs_fixed[COMPONENT_TRANSMISSION_CONTROL_FIXED].bank_size_pages * PAGE_SIZE_BYTES_FIXED,\n        .bank_size_pages = 8\n    };\n\n    for (size_t i = 0; i < TOTAL_FIRMWARE_MEMORY_BYTES_FIXED; ++i) {\n        g_firmwareMemory_fixed[i] = 0;\n    }\n\n    logFirmwareUpdateEvent_fixed(\"Firmware banks initialized (fixed).\");\n}\n\nvoid applyFirmwareUpdate_fixed(FirmwareUpdatePacket_Fixed update_packet) {\n    if (update_packet.component_id >= COMPONENT_INVALID_FIXED) {\n        logFirmwareUpdateError_fixed(\"Invalid component ID in firmware update (fixed).\");\n        return;\n    }\n\n    ComponentFirmwareBankConfig_Fixed config = g_componentBankConfigs_fixed[update_packet.component_id];\n\n    if (update_packet.page_index >= config.bank_size_pages) {\n        logFirmwareUpdateError_fixed(\"Page index out of bounds for selected component bank (fixed).\");\n        return;\n    }\n\n    size_t target_byte_offset = config.start_offset_bytes + (size_t)update_packet.page_index * PAGE_SIZE_BYTES_FIXED;\n\n    if (target_byte_offset + PAGE_SIZE_BYTES_FIXED <= TOTAL_FIRMWARE_MEMORY_BYTES_FIXED) {\n        for (size_t i = 0; i < PAGE_SIZE_BYTES_FIXED; ++i) {\n            g_firmwareMemory_fixed[target_byte_offset + i] = update_packet.data[i];\n        }\n        logFirmwareUpdateEvent_fixed(\"Firmware page updated successfully (fixed).\");\n    } else {\n        logFirmwareUpdateError_fixed(\"Firmware update would write out of total memory bounds (fixed). This should not happen with proper page index validation.\");\n    }\n}\n\nvoid firmwareUpdateManager_fixed_main() {\n    initializeFirmwareBanks_fixed();\n    FirmwareUpdatePacket_Fixed cmd = receiveFirmwareUpdatePacket_fixed();\n    applyFirmwareUpdate_fixed(cmd);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_VEHICLE_LIGHT_TYPES 5\n\ntypedef enum {\n    LIGHT_TYPE_HEADLIGHTS = 0,\n    LIGHT_TYPE_TAILLIGHTS = 1,\n    LIGHT_TYPE_FOGLIGHTS = 2,\n    LIGHT_TYPE_INTERIOR = 3,\n    LIGHT_TYPE_INDICATORS = 4,\n    LIGHT_TYPE_COUNT = 5\n} VehicleLightType;\n\ntypedef enum {\n    LIGHT_ACTION_OFF = 0,\n    LIGHT_ACTION_ON = 1,\n    LIGHT_ACTION_HIGH_BEAM = 2,\n    LIGHT_ACTION_LOW_BEAM = 3,\n    LIGHT_ACTION_DIM = 4,\n    LIGHT_ACTION_FLASH = 5,\n    LIGHT_ACTION_MAX_VALUE = 5\n} LightActionState;\n\nvoid performHeadlightAction(LightActionState action) {\n    printf(\"Headlight action: %d\\n\", action);\n}\nvoid performTaillightAction(LightActionState action) {\n    printf(\"Taillight action: %d\\n\", action);\n}\nvoid performFoglightAction(LightActionState action) {\n    printf(\"Foglight action: %d\\n\", action);\n}\nvoid performInteriorLightAction(LightActionState action) {\n    printf(\"Interior Light action: %d\\n\", action);\n}\nvoid performIndicatorAction(LightActionState action) {\n    printf(\"Indicator action: %d\\n\", action);\n}\n\ntypedef void (*LightSpecificActionFunction)(LightActionState action);\n\nstatic LightSpecificActionFunction g_lightTypeActionDispatch_vulnerable[MAX_VEHICLE_LIGHT_TYPES];\n\nstatic const LightActionState g_validHeadlightActions[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON, LIGHT_ACTION_HIGH_BEAM, LIGHT_ACTION_LOW_BEAM};\nstatic const LightActionState g_validTaillightActions[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON, LIGHT_ACTION_FLASH};\nstatic const LightActionState g_validFoglightActions[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON};\nstatic const LightActionState g_validInteriorLightActions[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON, LIGHT_ACTION_DIM};\nstatic const LightActionState g_validIndicatorActions[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON, LIGHT_ACTION_FLASH};\n\ntypedef struct {\n    const LightActionState* actions;\n    uint8_t count;\n} LightActionSetInfo;\n\nstatic LightActionSetInfo g_lightActionSets_vulnerable[MAX_VEHICLE_LIGHT_TYPES];\n\nvoid initializeLightManagement_vulnerable() {\n    g_lightTypeActionDispatch_vulnerable[LIGHT_TYPE_HEADLIGHTS] = performHeadlightAction;\n    g_lightTypeActionDispatch_vulnerable[LIGHT_TYPE_TAILLIGHTS] = performTaillightAction;\n    g_lightTypeActionDispatch_vulnerable[LIGHT_TYPE_FOGLIGHTS] = performFoglightAction;\n    g_lightTypeActionDispatch_vulnerable[LIGHT_TYPE_INTERIOR] = performInteriorLightAction;\n    g_lightTypeActionDispatch_vulnerable[LIGHT_TYPE_INDICATORS] = performIndicatorAction;\n\n    g_lightActionSets_vulnerable[LIGHT_TYPE_HEADLIGHTS] = (LightActionSetInfo){g_validHeadlightActions, sizeof(g_validHeadlightActions) / sizeof(g_validHeadlightActions[0])};\n    g_lightActionSets_vulnerable[LIGHT_TYPE_TAILLIGHTS] = (LightActionSetInfo){g_validTaillightActions, sizeof(g_validTaillightActions) / sizeof(g_validTaillightActions[0])};\n    g_lightActionSets_vulnerable[LIGHT_TYPE_FOGLIGHTS] = (LightActionSetInfo){g_validFoglightActions, sizeof(g_validFoglightActions) / sizeof(g_validFoglightActions[0])};\n    g_lightActionSets_vulnerable[LIGHT_TYPE_INTERIOR] = (LightActionSetInfo){g_validInteriorLightActions, sizeof(g_validInteriorLightActions) / sizeof(g_validInteriorLightActions[0])};\n    g_lightActionSets_vulnerable[LIGHT_TYPE_INDICATORS] = (LightActionSetInfo){g_validIndicatorActions, sizeof(g_validIndicatorActions) / sizeof(g_validIndicatorActions[0])};\n}\n\ntypedef struct {\n    uint8_t light_type_id;\n    uint8_t action_list_idx;\n} LightControlCommand_vulnerable;\n\nLightControlCommand_vulnerable receiveLightCommand_vulnerable() {\n    LightControlCommand_vulnerable cmd;\n    cmd.light_type_id = LIGHT_TYPE_FOGLIGHTS;\n    cmd.action_list_idx = 2;\n    return cmd;\n}\n\nvoid logVehicleLightError_vulnerable(const char* msg) {\n    printf(\"LIGHT_ERR_VULN: %s\\n\", msg);\n}\n\nvoid processLightCommand_vulnerable() {\n    LightControlCommand_vulnerable cmd = receiveLightCommand_vulnerable();\n\n    if (cmd.light_type_id < LIGHT_TYPE_COUNT) {\n        if (cmd.action_list_idx <= LIGHT_ACTION_MAX_VALUE) {\n            LightActionState action_to_perform = g_lightActionSets_vulnerable[cmd.light_type_id].actions[cmd.action_list_idx];\n            g_lightTypeActionDispatch_vulnerable[cmd.light_type_id](action_to_perform);\n            printf(\"Light command processed (vulnerable).\\n\");\n        } else {\n            logVehicleLightError_vulnerable(\"Requested action value out of global enum range.\");\n        }\n    } else {\n        logVehicleLightError_vulnerable(\"Invalid light type ID received.\");\n    }\n}\n\nvoid vehicleLightManagerMain_vulnerable() {\n    initializeLightManagement_vulnerable();\n    processLightCommand_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_VEHICLE_LIGHT_TYPES 5\n\ntypedef enum {\n    LIGHT_TYPE_HEADLIGHTS = 0,\n    LIGHT_TYPE_TAILLIGHTS = 1,\n    LIGHT_TYPE_FOGLIGHTS = 2,\n    LIGHT_TYPE_INTERIOR = 3,\n    LIGHT_TYPE_INDICATORS = 4,\n    LIGHT_TYPE_COUNT = 5\n} VehicleLightType;\n\ntypedef enum {\n    LIGHT_ACTION_OFF = 0,\n    LIGHT_ACTION_ON = 1,\n    LIGHT_ACTION_HIGH_BEAM = 2,\n    LIGHT_ACTION_LOW_BEAM = 3,\n    LIGHT_ACTION_DIM = 4,\n    LIGHT_ACTION_FLASH = 5,\n    LIGHT_ACTION_MAX_VALUE = 5\n} LightActionState;\n\nvoid performHeadlightAction_fixed(LightActionState action) {\n    printf(\"Headlight action: %d\\n\", action);\n}\nvoid performTaillightAction_fixed(LightActionState action) {\n    printf(\"Taillight action: %d\\n\", action);\n}\nvoid performFoglightAction_fixed(LightActionState action) {\n    printf(\"Foglight action: %d\\n\", action);\n}\nvoid performInteriorLightAction_fixed(LightActionState action) {\n    printf(\"Interior Light action: %d\\n\", action);\n}\nvoid performIndicatorAction_fixed(LightActionState action) {\n    printf(\"Indicator action: %d\\n\", action);\n}\n\ntypedef void (*LightSpecificActionFunction_fixed)(LightActionState action);\n\nstatic LightSpecificActionFunction_fixed g_lightTypeActionDispatch_fixed[MAX_VEHICLE_LIGHT_TYPES];\n\nstatic const LightActionState g_validHeadlightActions_fixed[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON, LIGHT_ACTION_HIGH_BEAM, LIGHT_ACTION_LOW_BEAM};\nstatic const LightActionState g_validTaillightActions_fixed[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON, LIGHT_ACTION_FLASH};\nstatic const LightActionState g_validFoglightActions_fixed[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON};\nstatic const LightActionState g_validInteriorLightActions_fixed[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON, LIGHT_ACTION_DIM};\nstatic const LightActionState g_validIndicatorActions_fixed[] = {LIGHT_ACTION_OFF, LIGHT_ACTION_ON, LIGHT_ACTION_FLASH};\n\ntypedef struct {\n    const LightActionState* actions;\n    uint8_t count;\n} LightActionSetInfo_fixed;\n\nstatic LightActionSetInfo_fixed g_lightActionSets_fixed[MAX_VEHICLE_LIGHT_TYPES];\n\nvoid initializeLightManagement_fixed() {\n    g_lightTypeActionDispatch_fixed[LIGHT_TYPE_HEADLIGHTS] = performHeadlightAction_fixed;\n    g_lightTypeActionDispatch_fixed[LIGHT_TYPE_TAILLIGHTS] = performTaillightAction_fixed;\n    g_lightTypeActionDispatch_fixed[LIGHT_TYPE_FOGLIGHTS] = performFoglightAction_fixed;\n    g_lightTypeActionDispatch_fixed[LIGHT_TYPE_INTERIOR] = performInteriorLightAction_fixed;\n    g_lightTypeActionDispatch_fixed[LIGHT_TYPE_INDICATORS] = performIndicatorAction_fixed;\n\n    g_lightActionSets_fixed[LIGHT_TYPE_HEADLIGHTS] = (LightActionSetInfo_fixed){g_validHeadlightActions_fixed, sizeof(g_validHeadlightActions_fixed) / sizeof(g_validHeadlightActions_fixed[0])};\n    g_lightActionSets_fixed[LIGHT_TYPE_TAILLIGHTS] = (LightActionSetInfo_fixed){g_validTaillightActions_fixed, sizeof(g_validTaillightActions_fixed) / sizeof(g_validTaillightActions_fixed[0])};\n    g_lightActionSets_fixed[LIGHT_TYPE_FOGLIGHTS] = (LightActionSetInfo_fixed){g_validFoglightActions_fixed, sizeof(g_validFoglightActions_fixed) / sizeof(g_validFoglightActions_fixed[0])};\n    g_lightActionSets_fixed[LIGHT_TYPE_INTERIOR] = (LightActionSetInfo_fixed){g_validInteriorLightActions_fixed, sizeof(g_validInteriorLightActions_fixed) / sizeof(g_validInteriorLightActions_fixed[0])};\n    g_lightActionSets_fixed[LIGHT_TYPE_INDICATORS] = (LightActionSetInfo_fixed){g_validIndicatorActions_fixed, sizeof(g_validIndicatorActions_fixed) / sizeof(g_validIndicatorActions_fixed[0])};\n}\n\ntypedef struct {\n    uint8_t light_type_id;\n    uint8_t action_list_idx;\n} LightControlCommand_fixed;\n\nLightControlCommand_fixed receiveLightCommand_fixed() {\n    LightControlCommand_fixed cmd;\n    cmd.light_type_id = LIGHT_TYPE_FOGLIGHTS;\n    cmd.action_list_idx = 2;\n    return cmd;\n}\n\nvoid logVehicleLightError_fixed(const char* msg) {\n    printf(\"LIGHT_ERR_FIXED: %s\\n\", msg);\n}\n\nvoid processLightCommand_fixed() {\n    LightControlCommand_fixed cmd = receiveLightCommand_fixed();\n\n    if (cmd.light_type_id < LIGHT_TYPE_COUNT) {\n        if (cmd.action_list_idx < g_lightActionSets_fixed[cmd.light_type_id].count) {\n            LightActionState action_to_perform = g_lightActionSets_fixed[cmd.light_type_id].actions[cmd.action_list_idx];\n            g_lightTypeActionDispatch_fixed[cmd.light_type_id](action_to_perform);\n            printf(\"Light command processed (fixed).\\n\");\n        } else {\n            logVehicleLightError_fixed(\"Requested action index out of bounds for specified light type.\");\n        }\n    } else {\n        logVehicleLightError_fixed(\"Invalid light type ID received.\");\n    }\n}\n\nvoid vehicleLightManagerMain_fixed() {\n    initializeLightManagement_fixed();\n    processLightCommand_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_BATTERY_PROFILES 4\n#define PMU_HARDWARE_REG_COUNT 8\n\nvoid logPMUError_vulnerable(const char* msg) {\n}\n\nuint32_t g_pmuHardwareRegisters_vulnerable[PMU_HARDWARE_REG_COUNT];\n\nvoid writePMURegister_vulnerable(uint8_t reg_idx, uint32_t value) {\n    if (reg_idx < PMU_HARDWARE_REG_COUNT) {\n        g_pmuHardwareRegisters_vulnerable[reg_idx] = value;\n    } else {\n        logPMUError_vulnerable(\"Attempted to write to out-of-bounds PMU register.\");\n    }\n}\n\ntypedef struct {\n    float charging_voltage_mV;\n    float discharge_cut_off_voltage_mV;\n    uint16_t max_charge_current_mA;\n    uint16_t max_discharge_current_mA;\n    uint8_t  temperature_threshold_C;\n} BatteryProfile_vulnerable;\n\ntypedef enum {\n    BATTERY_TYPE_LEAD_ACID = 0,\n    BATTERY_TYPE_LI_ION = 1,\n    BATTERY_TYPE_NICKEL_METAL_HYDRIDE = 2,\n    BATTERY_TYPE_CUSTOM_PERFORMANCE = 3,\n    BATTERY_TYPE_DIAGNOSTIC_MODE = 4 \n} BatteryProfileIdentifier_vulnerable;\n\nstatic BatteryProfile_vulnerable g_batteryProfiles_vulnerable[MAX_BATTERY_PROFILES];\n\nvoid initializeBatteryProfiles_vulnerable() {\n    g_batteryProfiles_vulnerable[BATTERY_TYPE_LEAD_ACID] = (BatteryProfile_vulnerable){14200.0f, 10500.0f, 5000, 10000, 45};\n    g_batteryProfiles_vulnerable[BATTERY_TYPE_LI_ION] = (BatteryProfile_vulnerable){16800.0f, 12000.0f, 8000, 15000, 55};\n    g_batteryProfiles_vulnerable[BATTERY_TYPE_NICKEL_METAL_HYDRIDE] = (BatteryProfile_vulnerable){15000.0f, 9500.0f, 6000, 12000, 50};\n    g_batteryProfiles_vulnerable[BATTERY_TYPE_CUSTOM_PERFORMANCE] = (BatteryProfile_vulnerable){17000.0f, 11500.0f, 10000, 20000, 60};\n}\n\nBatteryProfileIdentifier_vulnerable getExternalBatteryConfig_vulnerable() {\n    return BATTERY_TYPE_DIAGNOSTIC_MODE;\n}\n\nvoid applyVoltageRegulationProfile_vulnerable() {\n    BatteryProfileIdentifier_vulnerable current_profile_id = getExternalBatteryConfig_vulnerable();\n\n    BatteryProfile_vulnerable profile_to_apply = g_batteryProfiles_vulnerable[current_profile_id];\n\n    writePMURegister_vulnerable(0, (uint32_t)profile_to_apply.charging_voltage_mV);\n    writePMURegister_vulnerable(1, (uint32_t)profile_to_apply.discharge_cut_off_voltage_mV);\n    writePMURegister_vulnerable(2, profile_to_apply.max_charge_current_mA);\n    writePMURegister_vulnerable(3, profile_to_apply.max_discharge_current_mA);\n    writePMURegister_vulnerable(4, profile_to_apply.temperature_threshold_C);\n}\n\nvoid powerManagementUnitMain_vulnerable() {\n    initializeBatteryProfiles_vulnerable();\n    applyVoltageRegulationProfile_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_BATTERY_PROFILES 4\n#define PMU_HARDWARE_REG_COUNT 8\n\nvoid logPMUError_fixed(const char* msg) {\n}\n\nuint32_t g_pmuHardwareRegisters_fixed[PMU_HARDWARE_REG_COUNT];\n\nvoid writePMURegister_fixed(uint8_t reg_idx, uint32_t value) {\n    if (reg_idx < PMU_HARDWARE_REG_COUNT) {\n        g_pmuHardwareRegisters_fixed[reg_idx] = value;\n    } else {\n        logPMUError_fixed(\"Attempted to write to out-of-bounds PMU register.\");\n    }\n}\n\ntypedef struct {\n    float charging_voltage_mV;\n    float discharge_cut_off_voltage_mV;\n    uint16_t max_charge_current_mA;\n    uint16_t max_discharge_current_mA;\n    uint8_t  temperature_threshold_C;\n} BatteryProfile_fixed;\n\ntypedef enum {\n    BATTERY_TYPE_LEAD_ACID = 0,\n    BATTERY_TYPE_LI_ION = 1,\n    BATTERY_TYPE_NICKEL_METAL_HYDRIDE = 2,\n    BATTERY_TYPE_CUSTOM_PERFORMANCE = 3,\n    BATTERY_TYPE_DIAGNOSTIC_MODE = 4 \n} BatteryProfileIdentifier_fixed;\n\nstatic BatteryProfile_fixed g_batteryProfiles_fixed[MAX_BATTERY_PROFILES];\n\nvoid initializeBatteryProfiles_fixed() {\n    g_batteryProfiles_fixed[BATTERY_TYPE_LEAD_ACID] = (BatteryProfile_fixed){14200.0f, 10500.0f, 5000, 10000, 45};\n    g_batteryProfiles_fixed[BATTERY_TYPE_LI_ION] = (BatteryProfile_fixed){16800.0f, 12000.0f, 8000, 15000, 55};\n    g_batteryProfiles_fixed[BATTERY_TYPE_NICKEL_METAL_HYDRIDE] = (BatteryProfile_fixed){15000.0f, 9500.0f, 6000, 12000, 50};\n    g_batteryProfiles_fixed[BATTERY_TYPE_CUSTOM_PERFORMANCE] = (BatteryProfile_fixed){17000.0f, 11500.0f, 10000, 20000, 60};\n}\n\nBatteryProfileIdentifier_fixed getExternalBatteryConfig_fixed() {\n    return BATTERY_TYPE_DIAGNOSTIC_MODE;\n}\n\nvoid applyVoltageRegulationProfile_fixed() {\n    BatteryProfileIdentifier_fixed current_profile_id = getExternalBatteryConfig_fixed();\n    BatteryProfile_fixed profile_to_apply;\n\n    if (current_profile_id < MAX_BATTERY_PROFILES) {\n        profile_to_apply = g_batteryProfiles_fixed[current_profile_id];\n    } else {\n        logPMUError_fixed(\"Attempted to apply invalid battery profile ID. Using default profile.\");\n        profile_to_apply = g_batteryProfiles_fixed[BATTERY_TYPE_LEAD_ACID]; \n    }\n\n    writePMURegister_fixed(0, (uint32_t)profile_to_apply.charging_voltage_mV);\n    writePMURegister_fixed(1, (uint32_t)profile_to_apply.discharge_cut_off_voltage_mV);\n    writePMURegister_fixed(2, profile_to_apply.max_charge_current_mA);\n    writePMURegister_fixed(3, profile_to_apply.max_discharge_current_mA);\n    writePMURegister_fixed(4, profile_to_apply.temperature_threshold_C);\n}\n\nvoid powerManagementUnitMain_fixed() {\n    initializeBatteryProfiles_fixed();\n    applyVoltageRegulationProfile_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_COMMAND_POOL_SIZE 256 \n\ntypedef struct {\n    uint8_t command_id;\n    uint16_t param_a;\n    uint16_t param_b;\n} VehicleCommand;\n\nstatic VehicleCommand g_commandPool_vulnerable[MAX_COMMAND_POOL_SIZE];\n\nvoid logECUEvent_vulnerable(const char* msg) {\n    fprintf(stderr, \"ECU_VULN_LOG: %s\\n\", msg);\n}\n\nvoid executeVehicleCommand_vulnerable(VehicleCommand cmd) {\n    logECUEvent_vulnerable(\"Executing vehicle command.\");\n}\n\ntypedef struct {\n    uint16_t start_idx;\n    uint16_t length;\n} SequenceConfigMsg_Vulnerable;\n\n// Simulates receiving a diagnostic command to configure a command sequence\n// This function provides untrusted input that can lead to an out-of-bounds access.\nSequenceConfigMsg_Vulnerable receiveSequenceConfig_vulnerable() {\n    SequenceConfigMsg_Vulnerable config;\n    config.start_idx = 200; // A seemingly valid start index (200 < 256)\n    config.length = 60;     // A seemingly valid length (60 < 256)\n                            // However, start_idx + length = 200 + 60 = 260, which is > 256.\n    return config;\n}\n\nvoid processActiveCommandSequence_vulnerable() {\n    SequenceConfigMsg_Vulnerable config = receiveSequenceConfig_vulnerable();\n    \n    uint16_t sequence_start_idx = config.start_idx;\n    uint16_t sequence_length = config.length;\n\n    logECUEvent_vulnerable(\"Processing active command sequence (vulnerable).\");\n\n    // Vulnerability: The individual checks for start_idx and length are insufficient.\n    // There is no check to ensure that the sum (start_idx + i) remains within bounds\n    // of MAX_COMMAND_POOL_SIZE for the entire loop iteration.\n    if (sequence_start_idx < MAX_COMMAND_POOL_SIZE && sequence_length > 0) {\n        for (uint16_t i = 0; i < sequence_length; ++i) {\n            // The index calculation (sequence_start_idx + i) can result in an out-of-bounds access.\n            // For the example input: when i = 56, the index becomes 200 + 56 = 256, which is OOB.\n            VehicleCommand cmd = g_commandPool_vulnerable[sequence_start_idx + i];\n            executeVehicleCommand_vulnerable(cmd);\n        }\n    } else {\n        logECUEvent_vulnerable(\"Invalid sequence configuration received (vulnerable).\");\n    }\n}\n\nvoid automotiveECU_CommandProcessor_vulnerable_main() {\n    // Initialize the command pool with dummy data\n    for (uint16_t i = 0; i < MAX_COMMAND_POOL_SIZE; ++i) {\n        g_commandPool_vulnerable[i] = (VehicleCommand){(uint8_t)i, i, (uint16_t)(i * 2)};\n    }\n    logECUEvent_vulnerable(\"Command pool initialized.\");\n    \n    // Process a potentially malicious command sequence configuration\n    processActiveCommandSequence_vulnerable();\n}\n",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_COMMAND_POOL_SIZE 256 \n\ntypedef struct {\n    uint8_t command_id;\n    uint16_t param_a;\n    uint16_t param_b;\n} VehicleCommand;\n\nstatic VehicleCommand g_commandPool_fixed[MAX_COMMAND_POOL_SIZE];\n\nvoid logECUEvent_fixed(const char* msg) {\n    fprintf(stderr, \"ECU_FIXED_LOG: %s\\n\", msg);\n}\n\nvoid executeVehicleCommand_fixed(VehicleCommand cmd) {\n    logECUEvent_fixed(\"Executing vehicle command.\");\n}\n\ntypedef struct {\n    uint16_t start_idx;\n    uint16_t length;\n} SequenceConfigMsg_Fixed;\n\nSequenceConfigMsg_Fixed receiveSequenceConfig_fixed() {\n    SequenceConfigMsg_Fixed config;\n    config.start_idx = 200;\n    config.length = 60;\n    return config;\n}\n\nvoid processActiveCommandSequence_fixed() {\n    SequenceConfigMsg_Fixed config = receiveSequenceConfig_fixed();\n    \n    uint16_t sequence_start_idx = config.start_idx;\n    uint16_t sequence_length = config.length;\n\n    logECUEvent_fixed(\"Processing active command sequence (fixed).\");\n\n    // Fixed: Validate the entire range (start_idx + length) against the pool size\n    // Use uint32_t for the sum to prevent potential integer overflow during the check itself\n    // before comparing with MAX_COMMAND_POOL_SIZE.\n    if (sequence_length == 0) {\n        logECUEvent_fixed(\"Zero-length sequence received. Nothing to process.\");\n        return;\n    }\n    \n    if (sequence_start_idx < MAX_COMMAND_POOL_SIZE && \n        (uint32_t)sequence_start_idx + sequence_length <= MAX_COMMAND_POOL_SIZE) {\n        \n        for (uint16_t i = 0; i < sequence_length; ++i) {\n            // The individual index access is now guaranteed to be within bounds\n            VehicleCommand cmd = g_commandPool_fixed[sequence_start_idx + i];\n            executeVehicleCommand_fixed(cmd);\n        }\n    } else {\n        logECUEvent_fixed(\"Invalid sequence configuration received: range out of bounds or arithmetic overflow. Ignoring sequence.\");\n    }\n}\n\nvoid automotiveECU_CommandProcessor_fixed_main() {\n    // Initialize the command pool with dummy data\n    for (uint16_t i = 0; i < MAX_COMMAND_POOL_SIZE; ++i) {\n        g_commandPool_fixed[i] = (VehicleCommand){(uint8_t)i, i, (uint16_t)(i * 2)};\n    }\n    logECUEvent_fixed(\"Command pool initialized.\");\n    \n    // Process a command sequence configuration with robust validation\n    processActiveCommandSequence_fixed();\n}\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_VEHICLE_SYSTEMS 3\n#define MAX_CALIBRATION_POINTS_ENGINE 10\n#define MAX_CALIBRATION_POINTS_TRANSMISSION 8\n#define MAX_CALIBRATION_POINTS_BRAKES 5\n\ntypedef union {\n    float float_val;\n    int32_t int_val;\n    uint16_t short_val;\n} CalibrationValue_vulnerable;\n\nstatic CalibrationValue_vulnerable g_engineCalibrations_vulnerable[MAX_CALIBRATION_POINTS_ENGINE];\nstatic CalibrationValue_vulnerable g_transmissionCalibrations_vulnerable[MAX_CALIBRATION_POINTS_TRANSMISSION];\nstatic CalibrationValue_vulnerable g_brakeCalibrations_vulnerable[MAX_CALIBRATION_POINTS_BRAKES];\n\ntypedef enum {\n    VEHICLE_SYSTEM_ENGINE_VULNERABLE = 0,\n    VEHICLE_SYSTEM_TRANSMISSION_VULNERABLE = 1,\n    VEHICLE_SYSTEM_BRAKES_VULNERABLE = 2,\n    VEHICLE_SYSTEM_INVALID_VULNERABLE = 3\n} VehicleSystemID_vulnerable;\n\nvoid logVehicleError_vulnerable(const char* msg) {}\n\ntypedef struct {\n    VehicleSystemID_vulnerable system_id;\n    uint8_t calibration_index;\n    uint8_t requested_type;\n} CalibrationReadRequest_vulnerable;\n\nCalibrationReadRequest_vulnerable getSimulatedCalibrationReadRequest_vulnerable() {\n    CalibrationReadRequest_vulnerable req;\n    req.system_id = VEHICLE_SYSTEM_ENGINE_VULNERABLE;\n    req.calibration_index = 12;\n    req.requested_type = 0;\n    return req;\n}\n\nvoid initializeCalibrationData_vulnerable() {\n    for (uint8_t i = 0; i < MAX_CALIBRATION_POINTS_ENGINE; ++i) {\n        g_engineCalibrations_vulnerable[i].float_val = (float)i * 1.5f;\n    }\n    for (uint8_t i = 0; i < MAX_CALIBRATION_POINTS_TRANSMISSION; ++i) {\n        g_transmissionCalibrations_vulnerable[i].int_val = (int32_t)(i * 100);\n    }\n    for (uint8_t i = 0; i < MAX_CALIBRATION_POINTS_BRAKES; ++i) {\n        g_brakeCalibrations_vulnerable[i].short_val = (uint16_t)(i * 5);\n    }\n}\n\nvoid handleCalibrationReadRequest_vulnerable(CalibrationReadRequest_vulnerable request) {\n    CalibrationValue_vulnerable retrieved_value;\n\n    if (request.system_id >= VEHICLE_SYSTEM_INVALID_VULNERABLE) {\n        logVehicleError_vulnerable(\"Invalid Vehicle System ID received.\");\n        return;\n    }\n\n    switch (request.system_id) {\n        case VEHICLE_SYSTEM_ENGINE_VULNERABLE:\n            retrieved_value = g_engineCalibrations_vulnerable[request.calibration_index];\n            break;\n        case VEHICLE_SYSTEM_TRANSMISSION_VULNERABLE:\n            retrieved_value = g_transmissionCalibrations_vulnerable[request.calibration_index];\n            break;\n        case VEHICLE_SYSTEM_BRAKES_VULNERABLE:\n            retrieved_value = g_brakeCalibrations_vulnerable[request.calibration_index];\n            break;\n        default:\n            logVehicleError_vulnerable(\"Unknown vehicle system ID. Should not happen.\");\n            return;\n    }\n\n    if (request.requested_type == 0) { /* use retrieved_value.float_val */ }\n    else if (request.requested_type == 1) { /* use retrieved_value.int_val */ }\n    else if (request.requested_type == 2) { /* use retrieved_value.short_val */ }\n    else { logVehicleError_vulnerable(\"Unknown requested type for calibration value.\"); }\n}\n\nvoid main_vulnerable() {\n    initializeCalibrationData_vulnerable();\n    CalibrationReadRequest_vulnerable req = getSimulatedCalibrationReadRequest_vulnerable();\n    handleCalibrationReadRequest_vulnerable(req);\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_VEHICLE_SYSTEMS 3\n#define MAX_CALIBRATION_POINTS_ENGINE 10\n#define MAX_CALIBRATION_POINTS_TRANSMISSION 8\n#define MAX_CALIBRATION_POINTS_BRAKES 5\n\ntypedef union {\n    float float_val;\n    int32_t int_val;\n    uint16_t short_val;\n} CalibrationValue_fixed;\n\nstatic CalibrationValue_fixed g_engineCalibrations_fixed[MAX_CALIBRATION_POINTS_ENGINE];\nstatic CalibrationValue_fixed g_transmissionCalibrations_fixed[MAX_CALIBRATION_POINTS_TRANSMISSION];\nstatic CalibrationValue_fixed g_brakeCalibrations_fixed[MAX_CALIBRATION_POINTS_BRAKES];\n\ntypedef enum {\n    VEHICLE_SYSTEM_ENGINE_FIXED = 0,\n    VEHICLE_SYSTEM_TRANSMISSION_FIXED = 1,\n    VEHICLE_SYSTEM_BRAKES_FIXED = 2,\n    VEHICLE_SYSTEM_INVALID_FIXED = 3\n} VehicleSystemID_fixed;\n\nvoid logVehicleError_fixed(const char* msg) {}\n\ntypedef struct {\n    VehicleSystemID_fixed system_id;\n    uint8_t calibration_index;\n    uint8_t requested_type;\n} CalibrationReadRequest_fixed;\n\nCalibrationReadRequest_fixed getSimulatedCalibrationReadRequest_fixed() {\n    CalibrationReadRequest_fixed req;\n    req.system_id = VEHICLE_SYSTEM_ENGINE_FIXED;\n    req.calibration_index = 12;\n    req.requested_type = 0;\n    return req;\n}\n\nvoid initializeCalibrationData_fixed() {\n    for (uint8_t i = 0; i < MAX_CALIBRATION_POINTS_ENGINE; ++i) {\n        g_engineCalibrations_fixed[i].float_val = (float)i * 1.5f;\n    }\n    for (uint8_t i = 0; i < MAX_CALIBRATION_POINTS_TRANSMISSION; ++i) {\n        g_transmissionCalibrations_fixed[i].int_val = (int32_t)(i * 100);\n    }\n    for (uint8_t i = 0; i < MAX_CALIBRATION_POINTS_BRAKES; ++i) {\n        g_brakeCalibrations_fixed[i].short_val = (uint16_t)(i * 5);\n    }\n}\n\nvoid handleCalibrationReadRequest_fixed(CalibrationReadRequest_fixed request) {\n    CalibrationValue_fixed retrieved_value;\n\n    if (request.system_id >= VEHICLE_SYSTEM_INVALID_FIXED) {\n        logVehicleError_fixed(\"Invalid Vehicle System ID received.\");\n        return;\n    }\n\n    switch (request.system_id) {\n        case VEHICLE_SYSTEM_ENGINE_FIXED:\n            if (request.calibration_index >= MAX_CALIBRATION_POINTS_ENGINE) {\n                logVehicleError_fixed(\"Calibration index out of bounds for Engine system.\");\n                return;\n            }\n            retrieved_value = g_engineCalibrations_fixed[request.calibration_index];\n            break;\n        case VEHICLE_SYSTEM_TRANSMISSION_FIXED:\n            if (request.calibration_index >= MAX_CALIBRATION_POINTS_TRANSMISSION) {\n                logVehicleError_fixed(\"Calibration index out of bounds for Transmission system.\");\n                return;\n            }\n            retrieved_value = g_transmissionCalibrations_fixed[request.calibration_index];\n            break;\n        case VEHICLE_SYSTEM_BRAKES_FIXED:\n            if (request.calibration_index >= MAX_CALIBRATION_POINTS_BRAKES) {\n                logVehicleError_fixed(\"Calibration index out of bounds for Brake system.\");\n                return;\n            }\n            retrieved_value = g_brakeCalibrations_fixed[request.calibration_index];\n            break;\n        default:\n            logVehicleError_fixed(\"Unknown vehicle system ID. Should not happen.\");\n            return;\n    }\n\n    if (request.requested_type == 0) { /* use retrieved_value.float_val */ }\n    else if (request.requested_type == 1) { /* use retrieved_value.int_val */ }\n    else if (request.requested_type == 2) { /* use retrieved_value.short_val */ }\n    else { logVehicleError_fixed(\"Unknown requested type for calibration value.\"); }\n}\n\nvoid main_fixed() {\n    initializeCalibrationData_fixed();\n    CalibrationReadRequest_fixed req = getSimulatedCalibrationReadRequest_fixed();\n    handleCalibrationReadRequest_fixed(req);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_SYSTEM_COMPONENTS 3\n#define TOTAL_CONFIG_SLOTS 20\n\ntypedef struct {\n    uint8_t start_index;\n    uint8_t size;\n} ComponentMapEntry;\n\nstatic const ComponentMapEntry g_componentMap_vulnerable[MAX_SYSTEM_COMPONENTS] = {\n    {0, 10},   \n    {10, 5},   \n    {15, 5}    \n};\n\nstatic uint16_t g_componentConfigData_vulnerable[TOTAL_CONFIG_SLOTS];\n\ntypedef struct {\n    uint8_t component_id;\n    uint8_t parameter_offset;\n    uint16_t new_value;\n} ConfigUpdateCommand_Vulnerable;\n\nvoid logConfigError_vulnerable(const char* msg) {\n}\n\nConfigUpdateCommand_Vulnerable receiveConfigUpdate_vulnerable() {\n    ConfigUpdateCommand_Vulnerable cmd;\n    cmd.component_id = 1; \n    cmd.parameter_offset = 5; \n    cmd.new_value = 0xAA55;\n    return cmd;\n}\n\nvoid initializeComponentConfig_vulnerable() {\n    for (int i = 0; i < TOTAL_CONFIG_SLOTS; ++i) {\n        g_componentConfigData_vulnerable[i] = 0;\n    }\n}\n\nvoid processConfigurationUpdate_vulnerable() {\n    ConfigUpdateCommand_Vulnerable cmd = receiveConfigUpdate_vulnerable();\n\n    if (cmd.component_id < MAX_SYSTEM_COMPONENTS) {\n        uint8_t base_index = g_componentMap_vulnerable[cmd.component_id].start_index;\n        uint8_t absolute_index = base_index + cmd.parameter_offset;\n\n        if (absolute_index < TOTAL_CONFIG_SLOTS) { \n            g_componentConfigData_vulnerable[absolute_index] = cmd.new_value;\n            logConfigError_vulnerable(\"Component configuration updated.\");\n        } else {\n            logConfigError_vulnerable(\"Configuration update failed: Absolute index out of global bounds.\");\n        }\n    } else {\n        logConfigError_vulnerable(\"Configuration update failed: Invalid component ID.\");\n    }\n}\n\nvoid configManagerMain_vulnerable() {\n    initializeComponentConfig_vulnerable();\n    processConfigurationUpdate_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_SYSTEM_COMPONENTS 3\n#define TOTAL_CONFIG_SLOTS_FIXED 20\n\ntypedef struct {\n    uint8_t start_index;\n    uint8_t size;\n} ComponentMapEntry_Fixed;\n\nstatic const ComponentMapEntry_Fixed g_componentMap_fixed[MAX_SYSTEM_COMPONENTS] = {\n    {0, 10},   \n    {10, 5},   \n    {15, 5}    \n};\n\nstatic uint16_t g_componentConfigData_fixed[TOTAL_CONFIG_SLOTS_FIXED];\n\ntypedef struct {\n    uint8_t component_id;\n    uint8_t parameter_offset;\n    uint16_t new_value;\n} ConfigUpdateCommand_Fixed;\n\nvoid logConfigError_fixed(const char* msg) {\n}\n\nConfigUpdateCommand_Fixed receiveConfigUpdate_fixed() {\n    ConfigUpdateCommand_Fixed cmd;\n    cmd.component_id = 1; \n    cmd.parameter_offset = 5; \n    cmd.new_value = 0xAA55;\n    return cmd;\n}\n\nvoid initializeComponentConfig_fixed() {\n    for (int i = 0; i < TOTAL_CONFIG_SLOTS_FIXED; ++i) {\n        g_componentConfigData_fixed[i] = 0;\n    }\n}\n\nvoid processConfigurationUpdate_fixed() {\n    ConfigUpdateCommand_Fixed cmd = receiveConfigUpdate_fixed();\n\n    if (cmd.component_id < MAX_SYSTEM_COMPONENTS) {\n        uint8_t component_logical_size = g_componentMap_fixed[cmd.component_id].size;\n\n        if (cmd.parameter_offset < component_logical_size) {\n            uint8_t base_index = g_componentMap_fixed[cmd.component_id].start_index;\n            uint8_t absolute_index = base_index + cmd.parameter_offset;\n\n            if (absolute_index < TOTAL_CONFIG_SLOTS_FIXED) {\n                g_componentConfigData_fixed[absolute_index] = cmd.new_value;\n                logConfigError_fixed(\"Component configuration updated successfully.\");\n            } else {\n                logConfigError_fixed(\"Configuration update failed: Internal error, absolute index out of global bounds.\");\n            }\n        } else {\n            logConfigError_fixed(\"Configuration update failed: Parameter offset out of component-specific bounds.\");\n        }\n    } else {\n        logConfigError_fixed(\"Configuration update failed: Invalid component ID.\");\n    }\n}\n\nvoid configManagerMain_fixed() {\n    initializeComponentConfig_fixed();\n    processConfigurationUpdate_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_MESSAGE_TYPES 5\n#define MAX_FIELDS_PER_MESSAGE_TYPE 8 \n#define PAYLOAD_MAX_SIZE 8\n\nvoid automotiveLog(const char* msg) {\n    printf(\"LOG_VULN: %s\\n\", msg);\n}\n\ntypedef enum {\n    FIELD_TYPE_UINT8 = 0,\n    FIELD_TYPE_UINT16 = 1,\n    FIELD_TYPE_UINT32 = 2,\n    FIELD_TYPE_FLOAT = 3\n} FieldDataType;\n\ntypedef struct {\n    uint8_t offset;    \n    uint8_t size;      \n    FieldDataType type;\n} FieldInfo;\n\ntypedef struct {\n    uint8_t message_id;\n    uint8_t num_defined_fields; \n    FieldInfo fields[MAX_FIELDS_PER_MESSAGE_TYPE]; \n} MessageDescriptor;\n\nstatic MessageDescriptor g_messageDescriptors_vulnerable[MAX_MESSAGE_TYPES];\n\ntypedef struct {\n    uint8_t  message_id;\n    uint8_t  payload[PAYLOAD_MAX_SIZE];\n    uint8_t  requested_field_index; \n} NetworkMessage_vulnerable;\n\nvoid initializeMessageDescriptors_vulnerable() {\n    g_messageDescriptors_vulnerable[0].message_id = 0x10;\n    g_messageDescriptors_vulnerable[0].num_defined_fields = 2;\n    g_messageDescriptors_vulnerable[0].fields[0] = (FieldInfo){0, 2, FIELD_TYPE_UINT16};\n    g_messageDescriptors_vulnerable[0].fields[1] = (FieldInfo){2, 1, FIELD_TYPE_UINT8};\n\n    g_messageDescriptors_vulnerable[1].message_id = 0x20;\n    g_messageDescriptors_vulnerable[1].num_defined_fields = 1;\n    g_messageDescriptors_vulnerable[1].fields[0] = (FieldInfo){0, 2, FIELD_TYPE_UINT16};\n\n    g_messageDescriptors_vulnerable[2].message_id = 0x30;\n    g_messageDescriptors_vulnerable[2].num_defined_fields = 2;\n    g_messageDescriptors_vulnerable[2].fields[0] = (FieldInfo){0, 4, FIELD_TYPE_FLOAT};\n    g_messageDescriptors_vulnerable[2].fields[1] = (FieldInfo){4, 4, FIELD_TYPE_FLOAT};\n\n    for(int i = 3; i < MAX_MESSAGE_TYPES; ++i) {\n        g_messageDescriptors_vulnerable[i].message_id = 0xFF;\n        g_messageDescriptors_vulnerable[i].num_defined_fields = 0;\n    }\n}\n\nNetworkMessage_vulnerable receiveNetworkMessage_vulnerable() {\n    NetworkMessage_vulnerable msg;\n    msg.message_id = 0x10;\n    msg.requested_field_index = 3;\n    msg.payload[0] = 0xCD; msg.payload[1] = 0xAB;\n    msg.payload[2] = 0x50;\n    memset(msg.payload + 3, 0x00, PAYLOAD_MAX_SIZE - 3);\n    return msg;\n}\n\nvoid processNetworkMessage_vulnerable() {\n    NetworkMessage_vulnerable msg = receiveNetworkMessage_vulnerable();\n    uint8_t descriptor_idx = 0xFF;\n\n    for (uint8_t i = 0; i < MAX_MESSAGE_TYPES; ++i) {\n        if (g_messageDescriptors_vulnerable[i].message_id == msg.message_id) {\n            descriptor_idx = i;\n            break;\n        }\n    }\n\n    if (descriptor_idx != 0xFF) {\n        MessageDescriptor* descriptor = &g_messageDescriptors_vulnerable[descriptor_idx];\n\n        FieldInfo field_to_extract = descriptor->fields[msg.requested_field_index];\n\n        automotiveLog(\"Attempting to extract data from payload (vulnerable).\");\n\n        if (field_to_extract.offset < PAYLOAD_MAX_SIZE && (field_to_extract.offset + field_to_extract.size) <= PAYLOAD_MAX_SIZE) {\n            uint32_t extracted_val = 0;\n            switch (field_to_extract.type) {\n                case FIELD_TYPE_UINT8:\n                    extracted_val = msg.payload[field_to_extract.offset];\n                    break;\n                case FIELD_TYPE_UINT16:\n                    memcpy(&extracted_val, msg.payload + field_to_extract.offset, 2);\n                    break;\n                case FIELD_TYPE_UINT32:\n                    memcpy(&extracted_val, msg.payload + field_to_extract.offset, 4);\n                    break;\n                case FIELD_TYPE_FLOAT:\n                    memcpy(&extracted_val, msg.payload + field_to_extract.offset, 4);\n                    break;\n                default:\n                    automotiveLog(\"Unknown field type detected from descriptor.\");\n                    break;\n            }\n        } else {\n            automotiveLog(\"Field offset or size out of payload bounds (likely due to bad index).\");\n        }\n    } else {\n        automotiveLog(\"Received message with unknown ID.\");\n    }\n}\n\nvoid automotiveMain_vulnerable() {\n    initializeMessageDescriptors_vulnerable();\n    processNetworkMessage_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_MESSAGE_TYPES 5\n#define MAX_FIELDS_PER_MESSAGE_TYPE 8 \n#define PAYLOAD_MAX_SIZE 8\n\nvoid automotiveLog_fixed(const char* msg) {\n    printf(\"LOG_FIXED: %s\\n\", msg);\n}\n\ntypedef enum {\n    FIELD_TYPE_UINT8_FIXED = 0,\n    FIELD_TYPE_UINT16_FIXED = 1,\n    FIELD_TYPE_UINT32_FIXED = 2,\n    FIELD_TYPE_FLOAT_FIXED = 3\n} FieldDataType_Fixed;\n\ntypedef struct {\n    uint8_t offset;    \n    uint8_t size;      \n    FieldDataType_Fixed type;\n} FieldInfo_Fixed;\n\ntypedef struct {\n    uint8_t message_id;\n    uint8_t num_defined_fields; \n    FieldInfo_Fixed fields[MAX_FIELDS_PER_MESSAGE_TYPE]; \n} MessageDescriptor_Fixed;\n\nstatic MessageDescriptor_Fixed g_messageDescriptors_fixed[MAX_MESSAGE_TYPES];\n\ntypedef struct {\n    uint8_t  message_id;\n    uint8_t  payload[PAYLOAD_MAX_SIZE];\n    uint8_t  requested_field_index; \n} NetworkMessage_fixed;\n\nvoid initializeMessageDescriptors_fixed() {\n    g_messageDescriptors_fixed[0].message_id = 0x10;\n    g_messageDescriptors_fixed[0].num_defined_fields = 2;\n    g_messageDescriptors_fixed[0].fields[0] = (FieldInfo_Fixed){0, 2, FIELD_TYPE_UINT16_FIXED};\n    g_messageDescriptors_fixed[0].fields[1] = (FieldInfo_Fixed){2, 1, FIELD_TYPE_UINT8_FIXED};\n\n    g_messageDescriptors_fixed[1].message_id = 0x20;\n    g_messageDescriptors_fixed[1].num_defined_fields = 1;\n    g_messageDescriptors_fixed[1].fields[0] = (FieldInfo_Fixed){0, 2, FIELD_TYPE_UINT16_FIXED};\n\n    g_messageDescriptors_fixed[2].message_id = 0x30;\n    g_messageDescriptors_fixed[2].num_defined_fields = 2;\n    g_messageDescriptors_fixed[2].fields[0] = (FieldInfo_Fixed){0, 4, FIELD_TYPE_FLOAT_FIXED};\n    g_messageDescriptors_fixed[2].fields[1] = (FieldInfo_Fixed){4, 4, FIELD_TYPE_FLOAT_FIXED};\n\n    for(int i = 3; i < MAX_MESSAGE_TYPES; ++i) {\n        g_messageDescriptors_fixed[i].message_id = 0xFF;\n        g_messageDescriptors_fixed[i].num_defined_fields = 0;\n    }\n}\n\nNetworkMessage_fixed receiveNetworkMessage_fixed() {\n    NetworkMessage_fixed msg;\n    msg.message_id = 0x10;\n    msg.requested_field_index = 3;\n    msg.payload[0] = 0xCD; msg.payload[1] = 0xAB;\n    msg.payload[2] = 0x50;\n    memset(msg.payload + 3, 0x00, PAYLOAD_MAX_SIZE - 3);\n    return msg;\n}\n\nvoid processNetworkMessage_fixed() {\n    NetworkMessage_fixed msg = receiveNetworkMessage_fixed();\n    uint8_t descriptor_idx = 0xFF;\n\n    for (uint8_t i = 0; i < MAX_MESSAGE_TYPES; ++i) {\n        if (g_messageDescriptors_fixed[i].message_id == msg.message_id) {\n            descriptor_idx = i;\n            break;\n        }\n    }\n\n    if (descriptor_idx != 0xFF) {\n        MessageDescriptor_Fixed* descriptor = &g_messageDescriptors_fixed[descriptor_idx];\n\n        if (msg.requested_field_index < descriptor->num_defined_fields) {\n            FieldInfo_Fixed field_to_extract = descriptor->fields[msg.requested_field_index];\n            automotiveLog_fixed(\"Attempting to extract data from payload (fixed).\");\n\n            if (field_to_extract.offset < PAYLOAD_MAX_SIZE && (field_to_extract.offset + field_to_extract.size) <= PAYLOAD_MAX_SIZE) {\n                uint32_t extracted_val = 0;\n                switch (field_to_extract.type) {\n                    case FIELD_TYPE_UINT8_FIXED:\n                        extracted_val = msg.payload[field_to_extract.offset];\n                        break;\n                    case FIELD_TYPE_UINT16_FIXED:\n                        memcpy(&extracted_val, msg.payload + field_to_extract.offset, 2);\n                        break;\n                    case FIELD_TYPE_UINT32_FIXED:\n                        memcpy(&extracted_val, msg.payload + field_to_extract.offset, 4);\n                        break;\n                    case FIELD_TYPE_FLOAT_FIXED:\n                        memcpy(&extracted_val, msg.payload + field_to_extract.offset, 4);\n                        break;\n                    default:\n                        automotiveLog_fixed(\"Unknown field type detected from descriptor (fixed).\");\n                        break;\n                }\n            } else {\n                automotiveLog_fixed(\"Field offset or size out of payload bounds (fixed - likely due to valid but invalid FieldInfo).\");\n            }\n        } else {\n            automotiveLog_fixed(\"Requested field index is out of bounds for this message type (fixed).\");\n        }\n    } else {\n        automotiveLog_fixed(\"Received message with unknown ID (fixed).\");\n    }\n}\n\nvoid automotiveMain_fixed() {\n    initializeMessageDescriptors_fixed();\n    processNetworkMessage_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VLAN_PROFILES 16 \n#define BITMAP_SIZE_BITS 32 \n\ntypedef struct {\n    uint16_t vlan_id;\n    uint8_t priority_tag;\n    bool enable_filtering;\n    uint32_t reserved_flags;\n} VlanProfile;\n\nstatic VlanProfile g_vlanProfiles_vulnerable[MAX_VLAN_PROFILES];\n\nstatic uint32_t g_activeVlanProfileBitmap_vulnerable;\n\nvoid log_ethernet_event_vulnerable(const char* event_msg) {\n}\n\nvoid simulate_config_reception_vulnerable() {\n    g_activeVlanProfileBitmap_vulnerable = (1U << 0) | (1U << 5) | (1U << 20); \n}\n\nvoid initialize_vlan_profiles_vulnerable() {\n    for (uint8_t i = 0; i < MAX_VLAN_PROFILES; ++i) {\n        g_vlanProfiles_vulnerable[i].vlan_id = 0;\n        g_vlanProfiles_vulnerable[i].priority_tag = 0;\n        g_vlanProfiles_vulnerable[i].enable_filtering = false;\n        g_vlanProfiles_vulnerable[i].reserved_flags = 0;\n    }\n    log_ethernet_event_vulnerable(\"VLAN profiles initialized.\");\n}\n\nvoid apply_vlan_profile_to_hardware_vulnerable(uint8_t profile_index) {\n    VlanProfile current_profile = g_vlanProfiles_vulnerable[profile_index];\n    log_ethernet_event_vulnerable(\"Applying VLAN profile to hardware.\");\n}\n\nvoid process_active_vlan_configurations_vulnerable() {\n    log_ethernet_event_vulnerable(\"Processing active VLAN configurations.\");\n\n    for (uint8_t i = 0; i < BITMAP_SIZE_BITS; ++i) {\n        if ((g_activeVlanProfileBitmap_vulnerable >> i) & 1) {\n            apply_vlan_profile_to_hardware_vulnerable(i);\n        }\n    }\n    log_ethernet_event_vulnerable(\"Finished processing VLAN configurations.\");\n}\n\nvoid ethernet_switch_manager_main_vulnerable() {\n    initialize_vlan_profiles_vulnerable();\n    simulate_config_reception_vulnerable();\n    process_active_vlan_configurations_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VLAN_PROFILES 16 \n#define BITMAP_SIZE_BITS 32 \n\ntypedef struct {\n    uint16_t vlan_id;\n    uint8_t priority_tag;\n    bool enable_filtering;\n    uint32_t reserved_flags;\n} VlanProfile;\n\nstatic VlanProfile g_vlanProfiles_fixed[MAX_VLAN_PROFILES];\n\nstatic uint32_t g_activeVlanProfileBitmap_fixed;\n\nvoid log_ethernet_event_fixed(const char* event_msg) {\n}\n\nvoid simulate_config_reception_fixed() {\n    g_activeVlanProfileBitmap_fixed = (1U << 0) | (1U << 5) | (1U << 20); \n}\n\nvoid initialize_vlan_profiles_fixed() {\n    for (uint8_t i = 0; i < MAX_VLAN_PROFILES; ++i) {\n        g_vlanProfiles_fixed[i].vlan_id = 0;\n        g_vlanProfiles_fixed[i].priority_tag = 0;\n        g_vlanProfiles_fixed[i].enable_filtering = false;\n        g_vlanProfiles_fixed[i].reserved_flags = 0;\n    }\n    log_ethernet_event_fixed(\"VLAN profiles initialized.\");\n}\n\nvoid apply_vlan_profile_to_hardware_fixed(uint8_t profile_index) {\n    VlanProfile current_profile = g_vlanProfiles_fixed[profile_index];\n    log_ethernet_event_fixed(\"Applying VLAN profile to hardware.\");\n}\n\nvoid process_active_vlan_configurations_fixed() {\n    log_ethernet_event_fixed(\"Processing active VLAN configurations.\");\n\n    for (uint8_t i = 0; i < BITMAP_SIZE_BITS; ++i) {\n        if ((g_activeVlanProfileBitmap_fixed >> i) & 1) {\n            if (i < MAX_VLAN_PROFILES) { \n                apply_vlan_profile_to_hardware_fixed(i);\n            } else {\n                log_ethernet_event_fixed(\"Attempted to apply VLAN profile with out-of-bounds index. Ignoring.\");\n            }\n        }\n    }\n    log_ethernet_event_fixed(\"Finished processing VLAN configurations.\");\n}\n\nvoid ethernet_switch_manager_main_fixed() {\n    initialize_vlan_profiles_fixed();\n    simulate_config_reception_fixed();\n    process_active_vlan_configurations_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_FEATURES 10\n\ntypedef enum {\n    FEATURE_CRUISE_CONTROL = 0,\n    FEATURE_LANE_KEEP_ASSIST,\n    FEATURE_AEB,\n    FEATURE_PARKING_ASSIST,\n    FEATURE_INFOTAINMENT_MODE,\n    FEATURE_DRIVING_MODE,\n    FEATURE_HEADLIGHT_SENSITIVITY,\n    FEATURE_RAIN_SENSOR_ACTIVE,\n    FEATURE_TIRE_PRESSURE_MONITOR,\n    FEATURE_VEHICLE_DIAG_MODE,\n    FEATURE_COUNT\n} VehicleFeatureID;\n\ntypedef struct {\n    VehicleFeatureID id;\n    int32_t config_value;\n    bool is_active;\n} FeatureConfig;\n\nstatic FeatureConfig g_featureConfigurations[MAX_FEATURES];\n\nvoid systemLog(const char* message) {\n}\n\nvoid initializeFeatureSystem() {\n    for (uint16_t i = 0; i < MAX_FEATURES; ++i) {\n        g_featureConfigurations[i].id = (VehicleFeatureID)i;\n        g_featureConfigurations[i].config_value = 0;\n        g_featureConfigurations[i].is_active = false;\n    }\n    g_featureConfigurations[FEATURE_CRUISE_CONTROL].config_value = 100;\n    g_featureConfigurations[FEATURE_CRUISE_CONTROL].is_active = true;\n    g_featureConfigurations[FEATURE_DRIVING_MODE].config_value = 0;\n}\n\ntypedef struct {\n    uint16_t feature_id_raw;\n    int32_t value;\n    bool active_state;\n} FeatureUpdateCommand;\n\nFeatureUpdateCommand getSimulatedFeatureUpdateCommand_vulnerable() {\n    FeatureUpdateCommand cmd;\n    cmd.feature_id_raw = 10;\n    cmd.value = 500;\n    cmd.active_state = true;\n    return cmd;\n}\n\nvoid applyFeatureUpdate_vulnerable() {\n    FeatureUpdateCommand command = getSimulatedFeatureUpdateCommand_vulnerable();\n\n    g_featureConfigurations[command.feature_id_raw].config_value = command.value;\n    g_featureConfigurations[command.feature_id_raw].is_active = command.active_state;\n\n    systemLog(\"Feature update applied (vulnerable).\");\n}\n\nvoid featureManagerMain_vulnerable() {\n    initializeFeatureSystem();\n    applyFeatureUpdate_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_FEATURES 10\n\ntypedef enum {\n    FEATURE_CRUISE_CONTROL = 0,\n    FEATURE_LANE_KEEP_ASSIST,\n    FEATURE_AEB,\n    FEATURE_PARKING_ASSIST,\n    FEATURE_INFOTAINMENT_MODE,\n    FEATURE_DRIVING_MODE,\n    FEATURE_HEADLIGHT_SENSITIVITY,\n    FEATURE_RAIN_SENSOR_ACTIVE,\n    FEATURE_TIRE_PRESSURE_MONITOR,\n    FEATURE_VEHICLE_DIAG_MODE,\n    FEATURE_COUNT\n} VehicleFeatureID_fixed;\n\ntypedef struct {\n    VehicleFeatureID_fixed id;\n    int32_t config_value;\n    bool is_active;\n} FeatureConfig_fixed;\n\nstatic FeatureConfig_fixed g_featureConfigurations_fixed[MAX_FEATURES];\n\nvoid systemLog_fixed(const char* message) {\n}\n\nvoid initializeFeatureSystem_fixed() {\n    for (uint16_t i = 0; i < MAX_FEATURES; ++i) {\n        g_featureConfigurations_fixed[i].id = (VehicleFeatureID_fixed)i;\n        g_featureConfigurations_fixed[i].config_value = 0;\n        g_featureConfigurations_fixed[i].is_active = false;\n    }\n    g_featureConfigurations_fixed[FEATURE_CRUISE_CONTROL].config_value = 100;\n    g_featureConfigurations_fixed[FEATURE_CRUISE_CONTROL].is_active = true;\n    g_featureConfigurations_fixed[FEATURE_DRIVING_MODE].config_value = 0;\n}\n\ntypedef struct {\n    uint16_t feature_id_raw;\n    int32_t value;\n    bool active_state;\n} FeatureUpdateCommand_fixed;\n\nFeatureUpdateCommand_fixed getSimulatedFeatureUpdateCommand_fixed() {\n    FeatureUpdateCommand_fixed cmd;\n    cmd.feature_id_raw = 10;\n    cmd.value = 500;\n    cmd.active_state = true;\n    return cmd;\n}\n\nvoid applyFeatureUpdate_fixed() {\n    FeatureUpdateCommand_fixed command = getSimulatedFeatureUpdateCommand_fixed();\n\n    if (command.feature_id_raw < MAX_FEATURES) {\n        g_featureConfigurations_fixed[command.feature_id_raw].config_value = command.value;\n        g_featureConfigurations_fixed[command.feature_id_raw].is_active = command.active_state;\n        systemLog_fixed(\"Feature update applied (fixed).\");\n    } else {\n        systemLog_fixed(\"Error: Received out-of-bounds feature ID for update. Ignoring command.\");\n    }\n}\n\nvoid featureManagerMain_fixed() {\n    initializeFeatureSystem_fixed();\n    applyFeatureUpdate_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_DRIVER_PROFILES 5\n\ntypedef struct {\n    int seat_position;\n    int mirror_angle;\n    int climate_temp_celsius;\n    bool preferred_lighting;\n} DriverProfile;\n\nstatic DriverProfile g_driverProfiles[MAX_DRIVER_PROFILES];\n\nvoid logSystemEvent(const char* event) {\n    printf(\"LOG: %s\\n\", event);\n}\n\nvoid logSystemError(const char* error) {\n    fprintf(stderr, \"ERROR: %s\\n\", error);\n}\n\ntypedef struct {\n    uint8_t profileId;\n    int16_t newSeatPosition;\n    int16_t newMirrorAngle;\n    int8_t newClimateTempCelsius;\n    bool newPreferredLighting;\n} ProfileUpdateCommand;\n\nProfileUpdateCommand receiveProfileUpdateCommand_vulnerable() {\n    ProfileUpdateCommand cmd;\n    cmd.profileId = 5; \n    cmd.newSeatPosition = 150; \n    cmd.newMirrorAngle = 30; \n    cmd.newClimateTempCelsius = 22; \n    cmd.newPreferredLighting = true; \n    logSystemEvent(\"Simulating reception of profile update command (vulnerable).\");\n    return cmd;\n}\n\nvoid initializeDriverProfiles_vulnerable() {\n    for (uint8_t i = 0; i < MAX_DRIVER_PROFILES; ++i) {\n        g_driverProfiles[i].seat_position = 0;\n        g_driverProfiles[i].mirror_angle = 0;\n        g_driverProfiles[i].climate_temp_celsius = 20;\n        g_driverProfiles[i].preferred_lighting = false;\n    }\n    logSystemEvent(\"Driver profiles initialized (vulnerable).\");\n}\n\nvoid updateDriverProfile_vulnerable() {\n    ProfileUpdateCommand command = receiveProfileUpdateCommand_vulnerable();\n\n    g_driverProfiles[command.profileId].seat_position = command.newSeatPosition;\n    g_driverProfiles[command.profileId].mirror_angle = command.newMirrorAngle;\n    g_driverProfiles[command.profileId].climate_temp_celsius = command.newClimateTempCelsius;\n    g_driverProfiles[command.profileId].preferred_lighting = command.newPreferredLighting;\n\n    logSystemEvent(\"Driver profile updated (vulnerable).\");\n}\n\nvoid driverProfileManager_vulnerable_main() {\n    initializeDriverProfiles_vulnerable();\n    updateDriverProfile_vulnerable();\n}\n",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_DRIVER_PROFILES 5\n\ntypedef struct {\n    int seat_position;\n    int mirror_angle;\n    int climate_temp_celsius;\n    bool preferred_lighting;\n} DriverProfile;\n\nstatic DriverProfile g_driverProfiles_fixed[MAX_DRIVER_PROFILES];\n\nvoid logSystemEvent_fixed(const char* event) {\n    printf(\"LOG: %s\\n\", event);\n}\n\nvoid logSystemError_fixed(const char* error) {\n    fprintf(stderr, \"ERROR: %s\\n\", error);\n}\n\ntypedef struct {\n    uint8_t profileId;\n    int16_t newSeatPosition;\n    int16_t newMirrorAngle;\n    int8_t newClimateTempCelsius;\n    bool newPreferredLighting;\n} ProfileUpdateCommand;\n\nProfileUpdateCommand receiveProfileUpdateCommand_fixed() {\n    ProfileUpdateCommand cmd;\n    cmd.profileId = 5; \n    cmd.newSeatPosition = 150; \n    cmd.newMirrorAngle = 30; \n    cmd.newClimateTempCelsius = 22; \n    cmd.newPreferredLighting = true; \n    logSystemEvent_fixed(\"Simulating reception of profile update command (fixed).\");\n    return cmd;\n}\n\nvoid initializeDriverProfiles_fixed() {\n    for (uint8_t i = 0; i < MAX_DRIVER_PROFILES; ++i) {\n        g_driverProfiles_fixed[i].seat_position = 0;\n        g_driverProfiles_fixed[i].mirror_angle = 0;\n        g_driverProfiles_fixed[i].climate_temp_celsius = 20;\n        g_driverProfiles_fixed[i].preferred_lighting = false;\n    }\n    logSystemEvent_fixed(\"Driver profiles initialized (fixed).\");\n}\n\nvoid updateDriverProfile_fixed() {\n    ProfileUpdateCommand command = receiveProfileUpdateCommand_fixed();\n\n    if (command.profileId < MAX_DRIVER_PROFILES) {\n        g_driverProfiles_fixed[command.profileId].seat_position = command.newSeatPosition;\n        g_driverProfiles_fixed[command.profileId].mirror_angle = command.newMirrorAngle;\n        g_driverProfiles_fixed[command.profileId].climate_temp_celsius = command.newClimateTempCelsius;\n        g_driverProfiles_fixed[command.profileId].preferred_lighting = command.newPreferredLighting;\n        logSystemEvent_fixed(\"Driver profile updated (fixed).\");\n    } else {\n        logSystemError_fixed(\"Invalid profile ID received for update. Index out of bounds.\");\n    }\n}\n\nvoid driverProfileManager_fixed_main() {\n    initializeDriverProfiles_fixed();\n    updateDriverProfile_fixed();\n}\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_ROUTABLE_NODES 10\n#define MESSAGE_PAYLOAD_SIZE 8\n\ntypedef struct {\n    uint8_t destination_node_id;\n    uint8_t source_node_id;\n    uint8_t payload[MESSAGE_PAYLOAD_SIZE];\n    uint8_t payload_len;\n} NetworkMessage;\n\nvoid handleNode0Message(const uint8_t* data, uint8_t len) {}\nvoid handleNode1Message(const uint8_t* data, uint8_t len) {}\nvoid handleNode2Message(const uint8_t* data, uint8_t len) {}\nvoid handleDefaultMessage(const uint8_t* data, uint8_t len) {}\n\ntypedef void (*NodeMessageHandler)(const uint8_t* data, uint8_t len);\n\nvoid logGatewayEvent(const char* msg) {}\nvoid logGatewayError(const char* msg) {}\n\nstatic NodeMessageHandler g_nodeHandlers_vulnerable[MAX_ROUTABLE_NODES];\n\nNetworkMessage receiveNetworkMessage_vulnerable() {\n    NetworkMessage msg;\n    msg.destination_node_id = MAX_ROUTABLE_NODES;\n    msg.source_node_id = 0x01;\n    msg.payload[0] = 0xDE;\n    msg.payload_len = 1;\n    return msg;\n}\n\nvoid initializeGatewayHandlers_vulnerable() {\n    for (int i = 0; i < MAX_ROUTABLE_NODES; ++i) {\n        g_nodeHandlers_vulnerable[i] = handleDefaultMessage;\n    }\n    g_nodeHandlers_vulnerable[0] = handleNode0Message;\n    g_nodeHandlers_vulnerable[1] = handleNode1Message;\n    g_nodeHandlers_vulnerable[2] = handleNode2Message;\n    logGatewayEvent(\"Gateway handlers initialized (vulnerable).\");\n}\n\nvoid processIncomingNetworkMessage_vulnerable() {\n    NetworkMessage incoming_msg = receiveNetworkMessage_vulnerable();\n\n    NodeMessageHandler handler = g_nodeHandlers_vulnerable[incoming_msg.destination_node_id];\n    \n    if (handler != NULL) {\n        handler(incoming_msg.payload, incoming_msg.payload_len);\n        logGatewayEvent(\"Message processed by handler.\");\n    } else {\n        logGatewayError(\"Handler is NULL, potential configuration error or invalid index.\");\n    }\n}\n\nvoid gatewayApplicationLoop_vulnerable() {\n    initializeGatewayHandlers_vulnerable();\n    processIncomingNetworkMessage_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_ROUTABLE_NODES 10\n#define MESSAGE_PAYLOAD_SIZE 8\n\ntypedef struct {\n    uint8_t destination_node_id;\n    uint8_t source_node_id;\n    uint8_t payload[MESSAGE_PAYLOAD_SIZE];\n    uint8_t payload_len;\n} NetworkMessage;\n\nvoid handleNode0Message(const uint8_t* data, uint8_t len) {}\nvoid handleNode1Message(const uint8_t* data, uint8_t len) {}\nvoid handleNode2Message(const uint8_t* data, uint8_t len) {}\nvoid handleDefaultMessage(const uint8_t* data, uint8_t len) {}\n\ntypedef void (*NodeMessageHandler)(const uint8_t* data, uint8_t len);\n\nvoid logGatewayEvent(const char* msg) {}\nvoid logGatewayError(const char* msg) {}\n\nstatic NodeMessageHandler g_nodeHandlers_fixed[MAX_ROUTABLE_NODES];\n\nNetworkMessage receiveNetworkMessage_fixed() {\n    NetworkMessage msg;\n    msg.destination_node_id = MAX_ROUTABLE_NODES;\n    msg.source_node_id = 0x01;\n    msg.payload[0] = 0xDE;\n    msg.payload_len = 1;\n    return msg;\n}\n\nvoid initializeGatewayHandlers_fixed() {\n    for (int i = 0; i < MAX_ROUTABLE_NODES; ++i) {\n        g_nodeHandlers_fixed[i] = handleDefaultMessage;\n    }\n    g_nodeHandlers_fixed[0] = handleNode0Message;\n    g_nodeHandlers_fixed[1] = handleNode1Message;\n    g_nodeHandlers_fixed[2] = handleNode2Message;\n    logGatewayEvent(\"Gateway handlers initialized (fixed).\");\n}\n\nvoid processIncomingNetworkMessage_fixed() {\n    NetworkMessage incoming_msg = receiveNetworkMessage_fixed();\n\n    NodeMessageHandler handler = NULL;\n\n    if (incoming_msg.destination_node_id < MAX_ROUTABLE_NODES) {\n        handler = g_nodeHandlers_fixed[incoming_msg.destination_node_id];\n    } else {\n        logGatewayError(\"Invalid destination node ID received. Index out of bounds.\");\n        handler = handleDefaultMessage;\n    }\n    \n    if (handler != NULL) {\n        handler(incoming_msg.payload, incoming_msg.payload_len);\n        logGatewayEvent(\"Message processed by handler (fixed).\");\n    } else {\n        logGatewayError(\"Handler is NULL (fixed), potential configuration error or invalid index.\");\n    }\n}\n\nvoid gatewayApplicationLoop_fixed() {\n    initializeGatewayHandlers_fixed();\n    processIncomingNetworkMessage_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLES_VULNERABLE 100\n\ntypedef struct {\n    uint32_t firmware_version;\n    uint8_t  diagnostic_mode;\n    bool     feature_X_enabled;\n    uint16_t checksum;\n} VehicleECUConfig_Vulnerable;\n\nstatic VehicleECUConfig_Vulnerable g_fleetECUConfigs_vulnerable[MAX_VEHICLES_VULNERABLE];\n\nvoid ecuLog_vulnerable(const char* message) {\n}\n\ntypedef struct {\n    uint16_t command_id;\n    uint16_t start_vehicle_idx;\n    uint16_t num_vehicles_to_update;\n    VehicleECUConfig_Vulnerable config_data;\n} BatchUpdateCommand_Vulnerable;\n\nBatchUpdateCommand_Vulnerable receiveBatchUpdateCommand_vulnerable() {\n    BatchUpdateCommand_Vulnerable cmd;\n    cmd.command_id = 0x5001;\n    cmd.start_vehicle_idx = 90;\n    cmd.num_vehicles_to_update = 15;\n    cmd.config_data = (VehicleECUConfig_Vulnerable){\n        .firmware_version = 0x01020304,\n        .diagnostic_mode = 1,\n        .feature_X_enabled = true,\n        .checksum = 0xABCD\n    };\n    return cmd;\n}\n\nvoid initializeFleetConfigs_vulnerable() {\n    for (int i = 0; i < MAX_VEHICLES_VULNERABLE; ++i) {\n        g_fleetECUConfigs_vulnerable[i] = (VehicleECUConfig_Vulnerable){\n            .firmware_version = 0x00000000,\n            .diagnostic_mode = 0,\n            .feature_X_enabled = false,\n            .checksum = 0x0000\n        };\n    }\n    ecuLog_vulnerable(\"Fleet ECU configurations initialized.\");\n}\n\nvoid processBatchECUConfigUpdate_vulnerable() {\n    BatchUpdateCommand_Vulnerable cmd = receiveBatchUpdateCommand_vulnerable();\n\n    if (cmd.command_id == 0x5001) {\n        for (uint16_t i = 0; i < cmd.num_vehicles_to_update; ++i) {\n            g_fleetECUConfigs_vulnerable[cmd.start_vehicle_idx + i] = cmd.config_data;\n        }\n        ecuLog_vulnerable(\"Batch ECU configuration update processed (vulnerable).\");\n    } else {\n        ecuLog_vulnerable(\"Unknown batch update command ID (vulnerable).\");\n    }\n}\n\nvoid mainECUController_vulnerable() {\n    initializeFleetConfigs_vulnerable();\n    processBatchECUConfigUpdate_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLES_FIXED 100\n\ntypedef struct {\n    uint32_t firmware_version;\n    uint8_t  diagnostic_mode;\n    bool     feature_X_enabled;\n    uint16_t checksum;\n} VehicleECUConfig_Fixed;\n\nstatic VehicleECUConfig_Fixed g_fleetECUConfigs_fixed[MAX_VEHICLES_FIXED];\n\nvoid ecuLog_fixed(const char* message) {\n}\n\ntypedef struct {\n    uint16_t command_id;\n    uint16_t start_vehicle_idx;\n    uint16_t num_vehicles_to_update;\n    VehicleECUConfig_Fixed config_data;\n} BatchUpdateCommand_Fixed;\n\nBatchUpdateCommand_Fixed receiveBatchUpdateCommand_fixed() {\n    BatchUpdateCommand_Fixed cmd;\n    cmd.command_id = 0x5001;\n    cmd.start_vehicle_idx = 90;\n    cmd.num_vehicles_to_update = 15;\n    cmd.config_data = (VehicleECUConfig_Fixed){\n        .firmware_version = 0x01020304,\n        .diagnostic_mode = 1,\n        .feature_X_enabled = true,\n        .checksum = 0xABCD\n    };\n    return cmd;\n}\n\nvoid initializeFleetConfigs_fixed() {\n    for (int i = 0; i < MAX_VEHICLES_FIXED; ++i) {\n        g_fleetECUConfigs_fixed[i] = (VehicleECUConfig_Fixed){\n            .firmware_version = 0x00000000,\n            .diagnostic_mode = 0,\n            .feature_X_enabled = false,\n            .checksum = 0x0000\n        };\n    }\n    ecuLog_fixed(\"Fleet ECU configurations initialized (fixed).\");\n}\n\nvoid processBatchECUConfigUpdate_fixed() {\n    BatchUpdateCommand_Fixed cmd = receiveBatchUpdateCommand_fixed();\n\n    if (cmd.command_id == 0x5001) {\n        uint16_t end_idx_exclusive = cmd.start_vehicle_idx + cmd.num_vehicles_to_update;\n\n        if (cmd.start_vehicle_idx < MAX_VEHICLES_FIXED && end_idx_exclusive <= MAX_VEHICLES_FIXED) {\n            for (uint16_t i = 0; i < cmd.num_vehicles_to_update; ++i) {\n                g_fleetECUConfigs_fixed[cmd.start_vehicle_idx + i] = cmd.config_data;\n            }\n            ecuLog_fixed(\"Batch ECU configuration update processed successfully (fixed).\");\n        } else {\n            ecuLog_fixed(\"Invalid range for batch ECU configuration update. Command ignored (fixed).\");\n        }\n    } else {\n        ecuLog_fixed(\"Unknown batch update command ID (fixed).\");\n    }\n}\n\nvoid mainECUController_fixed() {\n    initializeFleetConfigs_fixed();\n    processBatchECUConfigUpdate_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_SENSOR_TYPES 5\n\ntypedef enum {\n    SENSOR_TYPE_RADAR = 0,\n    SENSOR_TYPE_LIDAR,\n    SENSOR_TYPE_CAMERA,\n    SENSOR_TYPE_ULTRASONIC,\n    SENSOR_TYPE_IMU,\n    SENSOR_TYPE_COUNT\n} SensorTypeID;\n\ntypedef struct {\n    float gain_factor;\n    int32_t offset_value;\n    uint16_t processing_flags;\n    char description[32];\n} SensorCalibrationProfile;\n\nstatic SensorCalibrationProfile g_sensorCalibrationProfiles[MAX_SENSOR_TYPES];\n\nvoid logSensorProcessingEvent(const char* msg) {\n    fprintf(stderr, \"SENSOR_PROC_LOG: %s\\n\", msg);\n}\n\nvoid applySensorCalibration(float* raw_value, SensorCalibrationProfile profile) {\n    *raw_value = (*raw_value * profile.gain_factor) + profile.offset_value;\n    logSensorProcessingEvent(\"Applied calibration.\");\n}\n\ntypedef struct {\n    uint8_t sensor_type_id;\n    uint32_t timestamp_ms;\n    float raw_measurement;\n    uint8_t data_integrity_checksum;\n} SensorDataPacket;\n\nSensorDataPacket receiveSensorDataPacket_Vulnerable() {\n    SensorDataPacket packet;\n    packet.sensor_type_id = SENSOR_TYPE_COUNT;\n    packet.timestamp_ms = 1678886400;\n    packet.raw_measurement = 25.5f;\n    packet.data_integrity_checksum = 0xAF;\n    return packet;\n}\n\nvoid initializeSensorCalibrationProfiles_Vulnerable() {\n    g_sensorCalibrationProfiles[SENSOR_TYPE_RADAR] = (SensorCalibrationProfile){1.0f, 0, 0x01, \"Radar Cal\"};\n    g_sensorCalibrationProfiles[SENSOR_TYPE_LIDAR] = (SensorCalibrationProfile){0.95f, 5, 0x02, \"Lidar Cal\"};\n    g_sensorCalibrationProfiles[SENSOR_TYPE_CAMERA] = (SensorCalibrationProfile){1.05f, -2, 0x04, \"Camera Cal\"};\n    g_sensorCalibrationProfiles[SENSOR_TYPE_ULTRASONIC] = (SensorCalibrationProfile){1.1f, 10, 0x08, \"Ultrasonic Cal\"};\n    g_sensorCalibrationProfiles[SENSOR_TYPE_IMU] = (SensorCalibrationProfile){0.9f, -1, 0x10, \"IMU Cal\"};\n    logSensorProcessingEvent(\"Sensor calibration profiles initialized (Vulnerable).\");\n}\n\nvoid processIncomingSensorData_Vulnerable() {\n    SensorDataPacket packet = receiveSensorDataPacket_Vulnerable();\n\n    SensorCalibrationProfile current_profile = g_sensorCalibrationProfiles[packet.sensor_type_id];\n\n    float processed_value = packet.raw_measurement;\n    applySensorCalibration(&processed_value, current_profile);\n\n    logSensorProcessingEvent(\"Sensor data processed (Vulnerable).\");\n}\n\nvoid sensorModuleMain_Vulnerable() {\n    initializeSensorCalibrationProfiles_Vulnerable();\n    processIncomingSensorData_Vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_SENSOR_TYPES 5\n\ntypedef enum {\n    SENSOR_TYPE_RADAR = 0,\n    SENSOR_TYPE_LIDAR,\n    SENSOR_TYPE_CAMERA,\n    SENSOR_TYPE_ULTRASONIC,\n    SENSOR_TYPE_IMU,\n    SENSOR_TYPE_COUNT\n} SensorTypeID;\n\ntypedef struct {\n    float gain_factor;\n    int32_t offset_value;\n    uint16_t processing_flags;\n    char description[32];\n} SensorCalibrationProfile;\n\nstatic SensorCalibrationProfile g_sensorCalibrationProfiles[MAX_SENSOR_TYPES];\n\nvoid logSensorProcessingEvent(const char* msg) {\n    fprintf(stderr, \"SENSOR_PROC_LOG: %s\\n\", msg);\n}\n\nvoid applySensorCalibration(float* raw_value, SensorCalibrationProfile profile) {\n    *raw_value = (*raw_value * profile.gain_factor) + profile.offset_value;\n    logSensorProcessingEvent(\"Applied calibration.\");\n}\n\ntypedef struct {\n    uint8_t sensor_type_id;\n    uint32_t timestamp_ms;\n    float raw_measurement;\n    uint8_t data_integrity_checksum;\n} SensorDataPacket;\n\nSensorDataPacket receiveSensorDataPacket_Fixed() {\n    SensorDataPacket packet;\n    packet.sensor_type_id = SENSOR_TYPE_COUNT;\n    packet.timestamp_ms = 1678886400;\n    packet.raw_measurement = 25.5f;\n    packet.data_integrity_checksum = 0xAF;\n    return packet;\n}\n\nvoid initializeSensorCalibrationProfiles_Fixed() {\n    g_sensorCalibrationProfiles[SENSOR_TYPE_RADAR] = (SensorCalibrationProfile){1.0f, 0, 0x01, \"Radar Cal\"};\n    g_sensorCalibrationProfiles[SENSOR_TYPE_LIDAR] = (SensorCalibrationProfile){0.95f, 5, 0x02, \"Lidar Cal\"};\n    g_sensorCalibrationProfiles[SENSOR_TYPE_CAMERA] = (SensorCalibrationProfile){1.05f, -2, 0x04, \"Camera Cal\"};\n    g_sensorCalibrationProfiles[SENSOR_TYPE_ULTRASONIC] = (SensorCalibrationProfile){1.1f, 10, 0x08, \"Ultrasonic Cal\"};\n    g_sensorCalibrationProfiles[SENSOR_TYPE_IMU] = (SensorCalibrationProfile){0.9f, -1, 0x10, \"IMU Cal\"};\n    logSensorProcessingEvent(\"Sensor calibration profiles initialized (Fixed).\");\n}\n\nvoid processIncomingSensorData_Fixed() {\n    SensorDataPacket packet = receiveSensorDataPacket_Fixed();\n\n    if (packet.sensor_type_id < SENSOR_TYPE_COUNT) {\n        SensorCalibrationProfile current_profile = g_sensorCalibrationProfiles[packet.sensor_type_id];\n\n        float processed_value = packet.raw_measurement;\n        applySensorCalibration(&processed_value, current_profile);\n        logSensorProcessingEvent(\"Sensor data processed successfully (Fixed).\");\n    } else {\n        logSensorProcessingEvent(\"Invalid sensor type ID received. Ignoring data packet (Fixed).\");\n    }\n}\n\nvoid sensorModuleMain_Fixed() {\n    initializeSensorCalibrationProfiles_Fixed();\n    processIncomingSensorData_Fixed();\n}\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_SENSOR_TYPES_VULNERABLE 3\n#define CALIBRATION_POINTS_PER_SENSOR_VULNERABLE 10\n\ntypedef struct {\n    int16_t value;\n    uint32_t timestamp;\n} CalibrationPoint_Vulnerable;\n\nstatic CalibrationPoint_Vulnerable g_sensorCalibrationData_vulnerable[MAX_SENSOR_TYPES_VULNERABLE][CALIBRATION_POINTS_PER_SENSOR_VULNERABLE];\n\nvoid logSystemError_vulnerable(const char* msg) {\n    fprintf(stderr, \"VULN_LOG_ERROR: %s\\n\", msg);\n}\n\nvoid logSystemInfo_vulnerable(const char* msg) {\n    fprintf(stdout, \"VULN_LOG_INFO: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t sensor_type_id;\n    uint8_t start_offset_in_segment;\n    uint8_t num_points_to_update;\n    CalibrationPoint_Vulnerable data_payload[CALIBRATION_POINTS_PER_SENSOR_VULNERABLE]; \n} SensorCalCommand_Vulnerable;\n\nSensorCalCommand_Vulnerable getIncomingSensorCalCommand_vulnerable() {\n    SensorCalCommand_Vulnerable cmd;\n    cmd.sensor_type_id = 1; \n    cmd.start_offset_in_segment = CALIBRATION_POINTS_PER_SENSOR_VULNERABLE - 2; \n    cmd.num_points_to_update = 3; \n\n    for (int i = 0; i < cmd.num_points_to_update; ++i) {\n        cmd.data_payload[i].value = 1000 + i;\n        cmd.data_payload[i].timestamp = 0x5000 + i;\n    }\n    logSystemInfo_vulnerable(\"Simulated incoming sensor calibration command with potential OOB write.\");\n    return cmd;\n}\n\nvoid initializeCalibrationData_vulnerable() {\n    for (uint8_t i = 0; i < MAX_SENSOR_TYPES_VULNERABLE; ++i) {\n        for (uint8_t j = 0; j < CALIBRATION_POINTS_PER_SENSOR_VULNERABLE; ++j) {\n            g_sensorCalibrationData_vulnerable[i][j].value = 0;\n            g_sensorCalibrationData_vulnerable[i][j].timestamp = 0;\n        }\n    }\n    logSystemInfo_vulnerable(\"Sensor calibration data initialized.\");\n}\n\nvoid processSensorCalibrationUpdate_vulnerable() {\n    SensorCalCommand_Vulnerable cmd = getIncomingSensorCalCommand_vulnerable();\n\n    if (cmd.sensor_type_id >= MAX_SENSOR_TYPES_VULNERABLE) {\n        logSystemError_vulnerable(\"Invalid sensor type ID received.\");\n        return;\n    }\n\n    if (cmd.start_offset_in_segment < CALIBRATION_POINTS_PER_SENSOR_VULNERABLE) {\n        logSystemInfo_vulnerable(\"Processing sensor calibration update.\");\n        for (uint8_t i = 0; i < cmd.num_points_to_update; ++i) {\n            g_sensorCalibrationData_vulnerable[cmd.sensor_type_id][cmd.start_offset_in_segment + i] = cmd.data_payload[i];\n        }\n    } else {\n        logSystemError_vulnerable(\"Invalid starting offset for calibration update.\");\n    }\n}\n\nvoid automotiveSensorModule_vulnerable_main() {\n    initializeCalibrationData_vulnerable();\n    processSensorCalibrationUpdate_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_SENSOR_TYPES_FIXED 3\n#define CALIBRATION_POINTS_PER_SENSOR_FIXED 10\n\ntypedef struct {\n    int16_t value;\n    uint32_t timestamp;\n} CalibrationPoint_Fixed;\n\nstatic CalibrationPoint_Fixed g_sensorCalibrationData_fixed[MAX_SENSOR_TYPES_FIXED][CALIBRATION_POINTS_PER_SENSOR_FIXED];\n\nvoid logSystemError_fixed(const char* msg) {\n    fprintf(stderr, \"FIXED_LOG_ERROR: %s\\n\", msg);\n}\n\nvoid logSystemInfo_fixed(const char* msg) {\n    fprintf(stdout, \"FIXED_LOG_INFO: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t sensor_type_id;\n    uint8_t start_offset_in_segment;\n    uint8_t num_points_to_update;\n    CalibrationPoint_Fixed data_payload[CALIBRATION_POINTS_PER_SENSOR_FIXED]; \n} SensorCalCommand_Fixed;\n\nSensorCalCommand_Fixed getIncomingSensorCalCommand_fixed() {\n    SensorCalCommand_Fixed cmd;\n    cmd.sensor_type_id = 1; \n    cmd.start_offset_in_segment = CALIBRATION_POINTS_PER_SENSOR_FIXED - 2; \n    cmd.num_points_to_update = 3; \n\n    for (int i = 0; i < cmd.num_points_to_update; ++i) {\n        cmd.data_payload[i].value = 1000 + i;\n        cmd.data_payload[i].timestamp = 0x5000 + i;\n    }\n    logSystemInfo_fixed(\"Simulated incoming sensor calibration command with potential OOB write.\");\n    return cmd;\n}\n\nvoid initializeCalibrationData_fixed() {\n    for (uint8_t i = 0; i < MAX_SENSOR_TYPES_FIXED; ++i) {\n        for (uint8_t j = 0; j < CALIBRATION_POINTS_PER_SENSOR_FIXED; ++j) {\n            g_sensorCalibrationData_fixed[i][j].value = 0;\n            g_sensorCalibrationData_fixed[i][j].timestamp = 0;\n        }\n    }\n    logSystemInfo_fixed(\"Sensor calibration data initialized.\");\n}\n\nvoid processSensorCalibrationUpdate_fixed() {\n    SensorCalCommand_Fixed cmd = getIncomingSensorCalCommand_fixed();\n\n    if (cmd.sensor_type_id >= MAX_SENSOR_TYPES_FIXED) {\n        logSystemError_fixed(\"Invalid sensor type ID received (fixed).\");\n        return;\n    }\n\n    if (cmd.start_offset_in_segment < CALIBRATION_POINTS_PER_SENSOR_FIXED &&\n        (uint16_t)cmd.start_offset_in_segment + cmd.num_points_to_update <= CALIBRATION_POINTS_PER_SENSOR_FIXED) {\n        \n        logSystemInfo_fixed(\"Processing sensor calibration update (fixed).\");\n        for (uint8_t i = 0; i < cmd.num_points_to_update; ++i) {\n            g_sensorCalibrationData_fixed[cmd.sensor_type_id][cmd.start_offset_in_segment + i] = cmd.data_payload[i];\n        }\n    } else {\n        logSystemError_fixed(\"Calibration update range out of bounds for sensor type. Ignoring update (fixed).\");\n    }\n}\n\nvoid automotiveSensorModule_fixed_main() {\n    initializeCalibrationData_fixed();\n    processSensorCalibrationUpdate_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_CAN_DATA_ELEMENTS 100\n#define MAX_ITEM_TYPES 5\n\ntypedef struct {\n    uint32_t value;\n    uint8_t status;\n} DataElement;\n\nstatic DataElement g_configDataElements_vulnerable[MAX_CAN_DATA_ELEMENTS];\n\ntypedef struct {\n    uint8_t start_idx;\n    uint8_t num_elements;\n} ItemMapping;\n\nstatic const ItemMapping g_itemMaps_vulnerable[MAX_ITEM_TYPES] = {\n    {0, 10}, \n    {10, 20}, \n    {30, 5},  \n    {35, 15}, \n    {50, 50}  \n};\n\ntypedef struct {\n    uint8_t item_type_id;  \n    uint8_t item_offset;   \n    uint32_t new_value;\n} CANConfigCommand_vulnerable;\n\nvoid log_automotive_security_event_vulnerable(const char* msg) {\n}\n\nCANConfigCommand_vulnerable receive_can_config_command_vulnerable() {\n    CANConfigCommand_vulnerable cmd;\n    cmd.item_type_id = 1; \n    cmd.item_offset = 20; \n    cmd.new_value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initialize_config_data_vulnerable() {\n    for (uint16_t i = 0; i < MAX_CAN_DATA_ELEMENTS; ++i) {\n        g_configDataElements_vulnerable[i] = (DataElement){0, 0};\n    }\n    \n    g_configDataElements_vulnerable[30].value = 0x11223344;\n    g_configDataElements_vulnerable[30].status = 0xA5;\n}\n\nvoid process_can_config_update_vulnerable() {\n    CANConfigCommand_vulnerable cmd = receive_can_config_command_vulnerable();\n\n    if (cmd.item_type_id < MAX_ITEM_TYPES) {\n        uint8_t base_index = g_itemMaps_vulnerable[cmd.item_type_id].start_idx;\n        uint8_t global_index = base_index + cmd.item_offset;\n\n        if (global_index < MAX_CAN_DATA_ELEMENTS) {\n            g_configDataElements_vulnerable[global_index].value = cmd.new_value;\n            g_configDataElements_vulnerable[global_index].status = 1;\n        } else {\n            log_automotive_security_event_vulnerable(\"CAN config update: Calculated global index out of overall array bounds.\");\n        }\n    } else {\n        log_automotive_security_event_vulnerable(\"CAN config update: Invalid item type ID received.\");\n    }\n}\n\nvoid automotive_system_main_vulnerable() {\n    initialize_config_data_vulnerable();\n    process_can_config_update_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define MAX_CAN_DATA_ELEMENTS 100\n#define MAX_ITEM_TYPES 5\n\ntypedef struct {\n    uint32_t value;\n    uint8_t status;\n} DataElement;\n\nstatic DataElement g_configDataElements_fixed[MAX_CAN_DATA_ELEMENTS];\n\ntypedef struct {\n    uint8_t start_idx;\n    uint8_t num_elements;\n} ItemMapping;\n\nstatic const ItemMapping g_itemMaps_fixed[MAX_ITEM_TYPES] = {\n    {0, 10}, \n    {10, 20}, \n    {30, 5},  \n    {35, 15}, \n    {50, 50}  \n};\n\ntypedef struct {\n    uint8_t item_type_id;  \n    uint8_t item_offset;   \n    uint32_t new_value;\n} CANConfigCommand_fixed;\n\nvoid log_automotive_security_event_fixed(const char* msg) {\n}\n\nCANConfigCommand_fixed receive_can_config_command_fixed() {\n    CANConfigCommand_fixed cmd;\n    cmd.item_type_id = 1; \n    cmd.item_offset = 20; \n    cmd.new_value = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initialize_config_data_fixed() {\n    for (uint16_t i = 0; i < MAX_CAN_DATA_ELEMENTS; ++i) {\n        g_configDataElements_fixed[i] = (DataElement){0, 0};\n    }\n    \n    g_configDataElements_fixed[30].value = 0x11223344;\n    g_configDataElements_fixed[30].status = 0xA5;\n}\n\nvoid process_can_config_update_fixed() {\n    CANConfigCommand_fixed cmd = receive_can_config_command_fixed();\n\n    if (cmd.item_type_id < MAX_ITEM_TYPES) {\n        if (cmd.item_offset < g_itemMaps_fixed[cmd.item_type_id].num_elements) {\n            uint8_t base_index = g_itemMaps_fixed[cmd.item_type_id].start_idx;\n            uint8_t global_index = base_index + cmd.item_offset;\n\n            if (global_index < MAX_CAN_DATA_ELEMENTS) {\n                g_configDataElements_fixed[global_index].value = cmd.new_value;\n                g_configDataElements_fixed[global_index].status = 1;\n            } else {\n                log_automotive_security_event_fixed(\"CAN config update: Internal error - calculated global index out of overall array bounds despite local validation.\");\n            }\n        } else {\n            log_automotive_security_event_fixed(\"CAN config update: Item offset out of bounds for specified item type.\");\n        }\n    } else {\n        log_automotive_security_event_fixed(\"CAN config update: Invalid item type ID received.\");\n    }\n}\n\nvoid automotive_system_main_fixed() {\n    initialize_config_data_fixed();\n    process_can_config_update_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\ntypedef enum {\n    DIAG_GROUP_ENGINE = 0,\n    DIAG_GROUP_TRANSMISSION,\n    DIAG_GROUP_SAFETY,\n    DIAG_GROUP_INFOTAINMENT,\n    NUM_DIAG_GROUPS\n} DiagnosticEventGroup;\n\ntypedef struct {\n    uint16_t event_code;\n    const char* description;\n    bool is_critical;\n} EventDefinition;\n\nstatic EventDefinition engineEventDefinitions_vulnerable[] = {\n    {0x1001, \"Engine Overheat\", true},\n    {0x1002, \"Misfire Cylinder 1\", true},\n    {0x1003, \"Low Oil Pressure\", true},\n    {0x1004, \"High Exhaust Temp\", false},\n    {0x1005, \"Idle Speed Deviation\", false}\n};\n#define ACTUAL_ENGINE_EVENTS (sizeof(engineEventDefinitions_vulnerable) / sizeof(EventDefinition))\n\nstatic EventDefinition transmissionEventDefinitions_vulnerable[] = {\n    {0x2001, \"Transmission Overload\", true},\n    {0x2002, \"Gear Shift Malfunction\", true},\n    {0x2003, \"Clutch Slip Detected\", false}\n};\n#define ACTUAL_TRANSMISSION_EVENTS (sizeof(transmissionEventDefinitions_vulnerable) / sizeof(EventDefinition))\n\nstatic EventDefinition safetyEventDefinitions_vulnerable[] = {\n    {0x3001, \"ABS Sensor Fault FL\", true},\n    {0x3002, \"Airbag Deployment Trigger\", true},\n    {0x3003, \"Seatbelt Pretensioner Fault\", false},\n    {0x3004, \"ESC System Error\", true},\n    {0x3005, \"Blind Spot Monitor Malf.\", false}\n};\n#define ACTUAL_SAFETY_EVENTS (sizeof(safetyEventDefinitions_vulnerable) / sizeof(EventDefinition))\n\nstatic EventDefinition infotainmentEventDefinitions_vulnerable[] = {\n    {0x4001, \"Navigation System Error\", false},\n    {0x4002, \"Audio System Fault\", false}\n};\n#define ACTUAL_INFOTAINMENT_EVENTS (sizeof(infotainmentEventDefinitions_vulnerable) / sizeof(EventDefinition))\n\ntypedef struct {\n    EventDefinition* events_ptr;\n    uint8_t count;\n} EventGroupRegistryEntry;\n\nstatic EventGroupRegistryEntry g_eventGroupRegistry_vulnerable[NUM_DIAG_GROUPS];\n\nvoid diagnosticLog_vulnerable(const char* msg) {\n}\n\nvoid initializeDiagnosticSystem_vulnerable() {\n    g_eventGroupRegistry_vulnerable[DIAG_GROUP_ENGINE] = (EventGroupRegistryEntry){engineEventDefinitions_vulnerable, ACTUAL_ENGINE_EVENTS};\n    g_eventGroupRegistry_vulnerable[DIAG_GROUP_TRANSMISSION] = (EventGroupRegistryEntry){transmissionEventDefinitions_vulnerable, ACTUAL_TRANSMISSION_EVENTS};\n    g_eventGroupRegistry_vulnerable[DIAG_GROUP_SAFETY] = (EventGroupRegistryEntry){safetyEventDefinitions_vulnerable, ACTUAL_SAFETY_EVENTS};\n    g_eventGroupRegistry_vulnerable[DIAG_GROUP_INFOTAINMENT] = (EventGroupRegistryEntry){infotainmentEventDefinitions_vulnerable, ACTUAL_INFOTAINMENT_EVENTS};\n    diagnosticLog_vulnerable(\"Diagnostic system initialized (vulnerable).\");\n}\n\ntypedef struct {\n    DiagnosticEventGroup group_id;\n    uint8_t event_type_idx;\n} EventLookupRequest_Vulnerable;\n\nEventLookupRequest_Vulnerable receiveEventLookupRequest_vulnerable() {\n    EventLookupRequest_Vulnerable req;\n    req.group_id = DIAG_GROUP_TRANSMISSION;\n    req.event_type_idx = 4;\n    return req;\n}\n\nvoid getEventDetails_vulnerable() {\n    EventLookupRequest_Vulnerable req = receiveEventLookupRequest_vulnerable();\n\n    if (req.group_id >= NUM_DIAG_GROUPS) {\n        diagnosticLog_vulnerable(\"Error: Invalid event group ID.\");\n        return;\n    }\n\n    EventDefinition selected_event = g_eventGroupRegistry_vulnerable[req.group_id].events_ptr[req.event_type_idx];\n    diagnosticLog_vulnerable(\"Attempted to retrieve event details (vulnerable).\");\n}\n\nvoid main_diagnostic_module_vulnerable() {\n    initializeDiagnosticSystem_vulnerable();\n    getEventDetails_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\ntypedef enum {\n    DIAG_GROUP_ENGINE_FIXED = 0,\n    DIAG_GROUP_TRANSMISSION_FIXED,\n    DIAG_GROUP_SAFETY_FIXED,\n    DIAG_GROUP_INFOTAINMENT_FIXED,\n    NUM_DIAG_GROUPS_FIXED\n} DiagnosticEventGroup_Fixed;\n\ntypedef struct {\n    uint16_t event_code;\n    const char* description;\n    bool is_critical;\n} EventDefinition_Fixed;\n\nstatic EventDefinition_Fixed engineEventDefinitions_fixed[] = {\n    {0x1001, \"Engine Overheat\", true},\n    {0x1002, \"Misfire Cylinder 1\", true},\n    {0x1003, \"Low Oil Pressure\", true},\n    {0x1004, \"High Exhaust Temp\", false},\n    {0x1005, \"Idle Speed Deviation\", false}\n};\n#define ACTUAL_ENGINE_EVENTS_FIXED (sizeof(engineEventDefinitions_fixed) / sizeof(EventDefinition_Fixed))\n\nstatic EventDefinition_Fixed transmissionEventDefinitions_fixed[] = {\n    {0x2001, \"Transmission Overload\", true},\n    {0x2002, \"Gear Shift Malfunction\", true},\n    {0x2003, \"Clutch Slip Detected\", false}\n};\n#define ACTUAL_TRANSMISSION_EVENTS_FIXED (sizeof(transmissionEventDefinitions_fixed) / sizeof(EventDefinition_Fixed))\n\nstatic EventDefinition_Fixed safetyEventDefinitions_fixed[] = {\n    {0x3001, \"ABS Sensor Fault FL\", true},\n    {0x3002, \"Airbag Deployment Trigger\", true},\n    {0x3003, \"Seatbelt Pretensioner Fault\", false},\n    {0x3004, \"ESC System Error\", true},\n    {0x3005, \"Blind Spot Monitor Malf.\", false}\n};\n#define ACTUAL_SAFETY_EVENTS_FIXED (sizeof(safetyEventDefinitions_fixed) / sizeof(EventDefinition_Fixed))\n\nstatic EventDefinition_Fixed infotainmentEventDefinitions_fixed[] = {\n    {0x4001, \"Navigation System Error\", false},\n    {0x4002, \"Audio System Fault\", false}\n};\n#define ACTUAL_INFOTAINMENT_EVENTS_FIXED (sizeof(infotainmentEventDefinitions_fixed) / sizeof(EventDefinition_Fixed))\n\ntypedef struct {\n    EventDefinition_Fixed* events_ptr;\n    uint8_t count;\n} EventGroupRegistryEntry_Fixed;\n\nstatic EventGroupRegistryEntry_Fixed g_eventGroupRegistry_fixed[NUM_DIAG_GROUPS_FIXED];\n\nvoid diagnosticLog_fixed(const char* msg) {\n}\n\nvoid initializeDiagnosticSystem_fixed() {\n    g_eventGroupRegistry_fixed[DIAG_GROUP_ENGINE_FIXED] = (EventGroupRegistryEntry_Fixed){engineEventDefinitions_fixed, ACTUAL_ENGINE_EVENTS_FIXED};\n    g_eventGroupRegistry_fixed[DIAG_GROUP_TRANSMISSION_FIXED] = (EventGroupRegistryEntry_Fixed){transmissionEventDefinitions_fixed, ACTUAL_TRANSMISSION_EVENTS_FIXED};\n    g_eventGroupRegistry_fixed[DIAG_GROUP_SAFETY_FIXED] = (EventGroupRegistryEntry_Fixed){safetyEventDefinitions_fixed, ACTUAL_SAFETY_EVENTS_FIXED};\n    g_eventGroupRegistry_fixed[DIAG_GROUP_INFOTAINMENT_FIXED] = (EventGroupRegistryEntry_Fixed){infotainmentEventDefinitions_fixed, ACTUAL_INFOTAINMENT_EVENTS_FIXED};\n    diagnosticLog_fixed(\"Diagnostic system initialized (fixed).\");\n}\n\ntypedef struct {\n    DiagnosticEventGroup_Fixed group_id;\n    uint8_t event_type_idx;\n} EventLookupRequest_Fixed;\n\nEventLookupRequest_Fixed receiveEventLookupRequest_fixed() {\n    EventLookupRequest_Fixed req;\n    req.group_id = DIAG_GROUP_TRANSMISSION_FIXED;\n    req.event_type_idx = 4;\n    return req;\n}\n\nvoid getEventDetails_fixed() {\n    EventLookupRequest_Fixed req = receiveEventLookupRequest_fixed();\n\n    if (req.group_id >= NUM_DIAG_GROUPS_FIXED) {\n        diagnosticLog_fixed(\"Error: Invalid event group ID.\");\n        return;\n    }\n\n    if (req.event_type_idx >= g_eventGroupRegistry_fixed[req.group_id].count) {\n        diagnosticLog_fixed(\"Error: Event type index out of bounds for the selected group.\");\n        return;\n    }\n    \n    EventDefinition_Fixed selected_event = g_eventGroupRegistry_fixed[req.group_id].events_ptr[req.event_type_idx];\n    diagnosticLog_fixed(\"Attempted to retrieve event details (fixed).\");\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_LIVE_DATA_GROUPS 5\n#define MAX_PARAMS_PER_GROUP 10\n#define DATA_VALUE_SIZE      2\n\ntypedef struct {\n    uint16_t param_id;\n    const char* name;\n    uint16_t min_val;\n    uint16_t max_val;\n} LiveDataParamDef;\n\ntypedef struct {\n    uint8_t group_id;\n    LiveDataParamDef* params_list;\n    uint8_t num_params;\n} LiveDataGroup;\n\nstatic LiveDataParamDef g_engineParams[5] = {\n    {0x0100, \"Engine RPM\", 0, 8000},\n    {0x0101, \"Vehicle Speed\", 0, 250},\n    {0x0102, \"Coolant Temp\", -40, 150},\n    {0x0103, \"Throttle Pos\", 0, 100},\n    {0x0104, \"Fuel Pressure\", 0, 1000}\n};\n\nstatic LiveDataParamDef g_brakesParams[3] = {\n    {0x0200, \"ABS Status\", 0, 1},\n    {0x0201, \"Brake Temp FL\", -20, 300},\n    {0x0202, \"Wheel Speed RL\", 0, 250}\n};\n\nstatic LiveDataParamDef g_transmissionParams[4] = {\n    {0x0300, \"Gear Pos\", 0, 6},\n    {0x0301, \"Trans Temp\", -30, 120},\n    {0x0302, \"Clutch Slip\", 0, 100},\n    {0x0303, \"Torque Conv Lock\", 0, 1}\n};\n\nstatic LiveDataGroup g_liveDataGroups_vulnerable[MAX_LIVE_DATA_GROUPS];\n\ntypedef struct {\n    uint8_t requested_group_id;\n    uint8_t requested_param_index;\n} DiagnosticLiveDataReaderRequest;\n\nDiagnosticLiveDataReaderRequest receiveDiagnosticLiveDataReaderRequest_vulnerable() {\n    DiagnosticLiveDataReaderRequest req;\n    req.requested_group_id = 0;\n    req.requested_param_index = 5;\n    return req;\n}\n\nvoid automotiveDiagLog_vulnerable(const char* msg) {\n}\n\nvoid initializeLiveDataSystem_vulnerable() {\n    for (uint8_t i = 0; i < MAX_LIVE_DATA_GROUPS; ++i) {\n        g_liveDataGroups_vulnerable[i].group_id = 0xFF;\n        g_liveDataGroups_vulnerable[i].params_list = NULL;\n        g_liveDataGroups_vulnerable[i].num_params = 0;\n    }\n\n    g_liveDataGroups_vulnerable[0].group_id = 0;\n    g_liveDataGroups_vulnerable[0].params_list = g_engineParams;\n    g_liveDataGroups_vulnerable[0].num_params = sizeof(g_engineParams) / sizeof(LiveDataParamDef);\n\n    g_liveDataGroups_vulnerable[1].group_id = 1;\n    g_liveDataGroups_vulnerable[1].params_list = g_brakesParams;\n    g_liveDataGroups_vulnerable[1].num_params = sizeof(g_brakesParams) / sizeof(LiveDataParamDef);\n\n    g_liveDataGroups_vulnerable[2].group_id = 2;\n    g_liveDataGroups_vulnerable[2].params_list = g_transmissionParams;\n    g_liveDataGroups_vulnerable[2].num_params = sizeof(g_transmissionParams) / sizeof(LiveDataParamDef);\n\n    automotiveDiagLog_vulnerable(\"Live Data System Initialized (Vulnerable).\");\n}\n\nvoid retrieveLiveDataParamDef_vulnerable() {\n    DiagnosticLiveDataReaderRequest req = receiveDiagnosticLiveDataReaderRequest_vulnerable();\n\n    if (req.requested_group_id < MAX_LIVE_DATA_GROUPS) {\n        LiveDataGroup* target_group = &g_liveDataGroups_vulnerable[req.requested_group_id];\n        LiveDataParamDef retrieved_def = target_group->params_list[req.requested_param_index];\n        automotiveDiagLog_vulnerable(\"Live data parameter definition retrieved (vulnerable).\");\n    } else {\n        automotiveDiagLog_vulnerable(\"Invalid live data group ID (vulnerable).\");\n    }\n}\n\nvoid diagnosticModuleMain_vulnerable() {\n    initializeLiveDataSystem_vulnerable();\n    retrieveLiveDataParamDef_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_LIVE_DATA_GROUPS 5\n#define MAX_PARAMS_PER_GROUP 10\n#define DATA_VALUE_SIZE      2\n\ntypedef struct {\n    uint16_t param_id;\n    const char* name;\n    uint16_t min_val;\n    uint16_t max_val;\n} LiveDataParamDef;\n\ntypedef struct {\n    uint8_t group_id;\n    LiveDataParamDef* params_list;\n    uint8_t num_params;\n} LiveDataGroup;\n\nstatic LiveDataParamDef g_engineParams_fixed[5] = {\n    {0x0100, \"Engine RPM\", 0, 8000},\n    {0x0101, \"Vehicle Speed\", 0, 250},\n    {0x0102, \"Coolant Temp\", -40, 150},\n    {0x0103, \"Throttle Pos\", 0, 100},\n    {0x0104, \"Fuel Pressure\", 0, 1000}\n};\n\nstatic LiveDataParamDef g_brakesParams_fixed[3] = {\n    {0x0200, \"ABS Status\", 0, 1},\n    {0x0201, \"Brake Temp FL\", -20, 300},\n    {0x0202, \"Wheel Speed RL\", 0, 250}\n};\n\nstatic LiveDataParamDef g_transmissionParams_fixed[4] = {\n    {0x0300, \"Gear Pos\", 0, 6},\n    {0x0301, \"Trans Temp\", -30, 120},\n    {0x0302, \"Clutch Slip\", 0, 100},\n    {0x0303, \"Torque Conv Lock\", 0, 1}\n};\n\nstatic LiveDataGroup g_liveDataGroups_fixed[MAX_LIVE_DATA_GROUPS];\n\ntypedef struct {\n    uint8_t requested_group_id;\n    uint8_t requested_param_index;\n} DiagnosticLiveDataReaderRequest;\n\nDiagnosticLiveDataReaderRequest receiveDiagnosticLiveDataReaderRequest_fixed() {\n    DiagnosticLiveDataReaderRequest req;\n    req.requested_group_id = 0;\n    req.requested_param_index = 5;\n    return req;\n}\n\nvoid automotiveDiagLog_fixed(const char* msg) {\n}\n\nvoid initializeLiveDataSystem_fixed() {\n    for (uint8_t i = 0; i < MAX_LIVE_DATA_GROUPS; ++i) {\n        g_liveDataGroups_fixed[i].group_id = 0xFF;\n        g_liveDataGroups_fixed[i].params_list = NULL;\n        g_liveDataGroups_fixed[i].num_params = 0;\n    }\n\n    g_liveDataGroups_fixed[0].group_id = 0;\n    g_liveDataGroups_fixed[0].params_list = g_engineParams_fixed;\n    g_liveDataGroups_fixed[0].num_params = sizeof(g_engineParams_fixed) / sizeof(LiveDataParamDef);\n\n    g_liveDataGroups_fixed[1].group_id = 1;\n    g_liveDataGroups_fixed[1].params_list = g_brakesParams_fixed;\n    g_liveDataGroups_fixed[1].num_params = sizeof(g_brakesParams_fixed) / sizeof(LiveDataParamDef);\n\n    g_liveDataGroups_fixed[2].group_id = 2;\n    g_liveDataGroups_fixed[2].params_list = g_transmissionParams_fixed;\n    g_liveDataGroups_fixed[2].num_params = sizeof(g_transmissionParams_fixed) / sizeof(LiveDataParamDef);\n\n    automotiveDiagLog_fixed(\"Live Data System Initialized (Fixed).\");\n}\n\nvoid retrieveLiveDataParamDef_fixed() {\n    DiagnosticLiveDataReaderRequest req = receiveDiagnosticLiveDataReaderRequest_fixed();\n\n    if (req.requested_group_id < MAX_LIVE_DATA_GROUPS) {\n        LiveDataGroup* target_group = &g_liveDataGroups_fixed[req.requested_group_id];\n        if (req.requested_param_index < target_group->num_params) {\n            LiveDataParamDef retrieved_def = target_group->params_list[req.requested_param_index];\n            automotiveDiagLog_fixed(\"Live data parameter definition retrieved (fixed).\");\n        } else {\n            automotiveDiagLog_fixed(\"Requested parameter index out of bounds for the selected group (fixed).\");\n        }\n    } else {\n        automotiveDiagLog_fixed(\"Invalid live data group ID (fixed).\");\n    }\n}\n\nvoid diagnosticModuleMain_fixed() {\n    initializeLiveDataSystem_fixed();\n    retrieveLiveDataParamDef_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_ECU_MODULES 8\n#define MAX_ERRORS_PER_MODULE 20\n\ntypedef struct {\n    uint16_t code;\n    uint32_t timestamp;\n} ErrorEntry;\n\ntypedef struct {\n    ErrorEntry errors[MAX_ERRORS_PER_MODULE];\n    uint8_t current_error_count;\n    uint8_t next_write_index;\n} ModuleErrorLog;\n\nstatic ModuleErrorLog g_ecu_error_logs_vulnerable[MAX_ECU_MODULES];\n\nvoid system_log_vulnerable(const char* message) {\n}\n\nuint32_t receive_diagnostic_event_vulnerable() {\n    return (0x0 << 28) | 0x19; \n}\n\nvoid initialize_error_logs_vulnerable() {\n    for (uint8_t i = 0; i < MAX_ECU_MODULES; ++i) {\n        g_ecu_error_logs_vulnerable[i].current_error_count = 0;\n        g_ecu_error_logs_vulnerable[i].next_write_index = 0;\n        for (uint8_t j = 0; j < MAX_ERRORS_PER_MODULE; ++j) {\n            g_ecu_error_logs_vulnerable[i].errors[j].code = 0;\n            g_ecu_error_logs_vulnerable[i].errors[j].timestamp = 0;\n        }\n    }\n    system_log_vulnerable(\"Error logs initialized (vulnerable).\");\n}\n\nvoid process_diagnostic_event_vulnerable() {\n    uint32_t event_id_raw = receive_diagnostic_event_vulnerable();\n\n    uint8_t module_id = (uint8_t)((event_id_raw >> 28) & 0xF); \n    uint8_t error_idx = (uint8_t)(event_id_raw & 0xFF);         \n\n    if (module_id < MAX_ECU_MODULES) {\n        g_ecu_error_logs_vulnerable[module_id].errors[error_idx].code = (uint16_t)(event_id_raw >> 8); \n        g_ecu_error_logs_vulnerable[module_id].errors[error_idx].timestamp = 0xABCD; \n        system_log_vulnerable(\"Diagnostic event processed (vulnerable).\");\n    } else {\n        system_log_vulnerable(\"Invalid module ID received (vulnerable).\");\n    }\n}\n\nvoid diagnostic_monitor_main_vulnerable() {\n    initialize_error_logs_vulnerable();\n    process_diagnostic_event_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_ECU_MODULES_FIXED 8\n#define MAX_ERRORS_PER_MODULE_FIXED 20\n\ntypedef struct {\n    uint16_t code;\n    uint32_t timestamp;\n} ErrorEntry_Fixed;\n\ntypedef struct {\n    ErrorEntry_Fixed errors[MAX_ERRORS_PER_MODULE_FIXED];\n    uint8_t current_error_count;\n    uint8_t next_write_index;\n} ModuleErrorLog_Fixed;\n\nstatic ModuleErrorLog_Fixed g_ecu_error_logs_fixed[MAX_ECU_MODULES_FIXED];\n\nvoid system_log_fixed(const char* message) {\n}\n\nuint32_t receive_diagnostic_event_fixed() {\n    return (0x0 << 28) | 0x19;\n}\n\nvoid initialize_error_logs_fixed() {\n    for (uint8_t i = 0; i < MAX_ECU_MODULES_FIXED; ++i) {\n        g_ecu_error_logs_fixed[i].current_error_count = 0;\n        g_ecu_error_logs_fixed[i].next_write_index = 0;\n        for (uint8_t j = 0; j < MAX_ERRORS_PER_MODULE_FIXED; ++j) {\n            g_ecu_error_logs_fixed[i].errors[j].code = 0;\n            g_ecu_error_logs_fixed[i].errors[j].timestamp = 0;\n        }\n    }\n    system_log_fixed(\"Error logs initialized (fixed).\");\n}\n\nvoid process_diagnostic_event_fixed() {\n    uint32_t event_id_raw = receive_diagnostic_event_fixed();\n\n    uint8_t module_id = (uint8_t)((event_id_raw >> 28) & 0xF);\n    uint8_t error_idx = (uint8_t)(event_id_raw & 0xFF);\n\n    if (module_id < MAX_ECU_MODULES_FIXED) {\n        if (error_idx < MAX_ERRORS_PER_MODULE_FIXED) {\n            g_ecu_error_logs_fixed[module_id].errors[error_idx].code = (uint16_t)(event_id_raw >> 8);\n            g_ecu_error_logs_fixed[module_id].errors[error_idx].timestamp = 0xABCD;\n            system_log_fixed(\"Diagnostic event processed (fixed).\");\n        } else {\n            system_log_fixed(\"Error index out of bounds for module log (fixed).\");\n        }\n    } else {\n        system_log_fixed(\"Invalid module ID received (fixed).\");\n    }\n}\n\nvoid diagnostic_monitor_main_fixed() {\n    initialize_error_logs_fixed();\n    process_diagnostic_event_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_CHASSIS_PROFILES 5\n\ntypedef struct {\n    float damping_ratio;\n    float steering_response;\n    uint16_t throttle_map_id;\n    bool traction_control_active;\n} ChassisProfile_vulnerable;\n\ntypedef struct {\n    uint8_t slipperiness_index; \n    uint8_t roughness_index;    \n} SensorInput_vulnerable;\n\ntypedef struct {\n    int8_t profile_adjustment_offset;\n} DriverPreferenceInput_vulnerable;\n\nstatic ChassisProfile_vulnerable g_chassisProfiles_vulnerable[MAX_CHASSIS_PROFILES];\n\nvoid logChassisControlError_vulnerable(const char* msg) {\n}\n\nSensorInput_vulnerable getSimulatedSensorInput_vulnerable() {\n    SensorInput_vulnerable input;\n    input.slipperiness_index = 30;\n    input.roughness_index = 20;\n    return input;\n}\n\nDriverPreferenceInput_vulnerable getSimulatedDriverPreference_vulnerable() {\n    DriverPreferenceInput_vulnerable pref;\n    pref.profile_adjustment_offset = 5; \n    return pref;\n}\n\nvoid initializeChassisProfiles_vulnerable() {\n    for (int i = 0; i < MAX_CHASSIS_PROFILES; ++i) {\n        g_chassisProfiles_vulnerable[i].damping_ratio = 0.5f + (float)i * 0.1f;\n        g_chassisProfiles_vulnerable[i].steering_response = 0.3f + (float)i * 0.05f;\n        g_chassisProfiles_vulnerable[i].throttle_map_id = 100 + i;\n        g_chassisProfiles_vulnerable[i].traction_control_active = true;\n    }\n}\n\nvoid applyChassisSettings_vulnerable(const ChassisProfile_vulnerable* profile) {\n}\n\nvoid updateChassisControl_vulnerable() {\n    SensorInput_vulnerable sensor_data = getSimulatedSensorInput_vulnerable();\n    DriverPreferenceInput_vulnerable driver_data = getSimulatedDriverPreference_vulnerable();\n\n    int base_mode_index;\n    int averaged_sensor_value = (sensor_data.slipperiness_index + sensor_data.roughness_index) / 2;\n\n    if (averaged_sensor_value < 33) {\n        base_mode_index = 0;\n    } else if (averaged_sensor_value < 67) {\n        base_mode_index = 1;\n    } else {\n        base_mode_index = 2;\n    }\n\n    int final_profile_index = base_mode_index + driver_data.profile_adjustment_offset;\n\n    if (final_profile_index >= 0) {\n        applyChassisSettings_vulnerable(&g_chassisProfiles_vulnerable[final_profile_index]);\n    } else {\n        logChassisControlError_vulnerable(\"Calculated profile index is negative. Using default.\");\n        applyChassisSettings_vulnerable(&g_chassisProfiles_vulnerable[0]);\n    }\n}\n\nvoid chassisControlMain_vulnerable() {\n    initializeChassisProfiles_vulnerable();\n    updateChassisControl_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_CHASSIS_PROFILES 5\n\ntypedef struct {\n    float damping_ratio;\n    float steering_response;\n    uint16_t throttle_map_id;\n    bool traction_control_active;\n} ChassisProfile_fixed;\n\ntypedef struct {\n    uint8_t slipperiness_index;\n    uint8_t roughness_index;\n} SensorInput_fixed;\n\ntypedef struct {\n    int8_t profile_adjustment_offset;\n} DriverPreferenceInput_fixed;\n\nstatic ChassisProfile_fixed g_chassisProfiles_fixed[MAX_CHASSIS_PROFILES];\n\nvoid logChassisControlError_fixed(const char* msg) {\n}\n\nSensorInput_fixed getSimulatedSensorInput_fixed() {\n    SensorInput_fixed input;\n    input.slipperiness_index = 30;\n    input.roughness_index = 20;\n    return input;\n}\n\nDriverPreferenceInput_fixed getSimulatedDriverPreference_fixed() {\n    DriverPreferenceInput_fixed pref;\n    pref.profile_adjustment_offset = 5;\n    return pref;\n}\n\nvoid initializeChassisProfiles_fixed() {\n    for (int i = 0; i < MAX_CHASSIS_PROFILES; ++i) {\n        g_chassisProfiles_fixed[i].damping_ratio = 0.5f + (float)i * 0.1f;\n        g_chassisProfiles_fixed[i].steering_response = 0.3f + (float)i * 0.05f;\n        g_chassisProfiles_fixed[i].throttle_map_id = 100 + i;\n        g_chassisProfiles_fixed[i].traction_control_active = true;\n    }\n}\n\nvoid applyChassisSettings_fixed(const ChassisProfile_fixed* profile) {\n}\n\nvoid updateChassisControl_fixed() {\n    SensorInput_fixed sensor_data = getSimulatedSensorInput_fixed();\n    DriverPreferenceInput_fixed driver_data = getSimulatedDriverPreference_fixed();\n\n    int base_mode_index;\n    int averaged_sensor_value = (sensor_data.slipperiness_index + sensor_data.roughness_index) / 2;\n\n    if (averaged_sensor_value < 33) {\n        base_mode_index = 0;\n    } else if (averaged_sensor_value < 67) {\n        base_mode_index = 1;\n    } else {\n        base_mode_index = 2;\n    }\n\n    int final_profile_index = base_mode_index + driver_data.profile_adjustment_offset;\n\n    if (final_profile_index >= 0 && final_profile_index < MAX_CHASSIS_PROFILES) {\n        applyChassisSettings_fixed(&g_chassisProfiles_fixed[final_profile_index]);\n    } else {\n        logChassisControlError_fixed(\"Calculated profile index is out of bounds. Using default profile.\");\n        applyChassisSettings_fixed(&g_chassisProfiles_fixed[0]);\n    }\n}\n\nvoid chassisControlMain_fixed() {\n    initializeChassisProfiles_fixed();\n    updateChassisControl_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_DIAG_HANDLERS 16\n\ntypedef struct {\n    uint32_t raw_event_code;\n} DiagnosticEvent;\n\ntypedef void (*DiagnosticHandler)(uint16_t error_code, uint8_t module_id);\n\nvoid handleSubComponent0(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent1(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent2(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent3(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent4(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent5(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent6(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent7(uint16_t error_code, uint8_t module_id) {}\n\nstatic DiagnosticHandler g_diagHandlers_vulnerable[MAX_DIAG_HANDLERS];\nstatic const uint8_t actual_num_diag_handlers = 8;\n\nvoid automotive_system_log_vulnerable(const char* msg) {\n}\n\nDiagnosticEvent receiveDiagnosticEvent_vulnerable() {\n    DiagnosticEvent event;\n    event.raw_event_code = 0x01234508;\n    return event;\n}\n\nvoid initializeDiagnosticSystem_vulnerable() {\n    g_diagHandlers_vulnerable[0] = handleSubComponent0;\n    g_diagHandlers_vulnerable[1] = handleSubComponent1;\n    g_diagHandlers_vulnerable[2] = handleSubComponent2;\n    g_diagHandlers_vulnerable[3] = handleSubComponent3;\n    g_diagHandlers_vulnerable[4] = handleSubComponent4;\n    g_diagHandlers_vulnerable[5] = handleSubComponent5;\n    g_diagHandlers_vulnerable[6] = handleSubComponent6;\n    g_diagHandlers_vulnerable[7] = handleSubComponent7;\n\n    automotive_system_log_vulnerable(\"Diagnostic system initialized (vulnerable).\");\n}\n\nvoid processDiagnosticEvent_vulnerable() {\n    DiagnosticEvent event = receiveDiagnosticEvent_vulnerable();\n\n    uint8_t component_index = (uint8_t)(event.raw_event_code & 0xFF);\n    uint16_t error_code = (uint16_t)((event.raw_event_code >> 8) & 0xFFFF);\n    uint8_t module_id = (uint8_t)((event.raw_event_code >> 24) & 0xFF);\n\n    if (component_index < MAX_DIAG_HANDLERS) {\n        DiagnosticHandler handler = g_diagHandlers_vulnerable[component_index];\n        if (handler != NULL) {\n            handler(error_code, module_id);\n            automotive_system_log_vulnerable(\"Diagnostic event dispatched (vulnerable).\");\n        } else {\n            automotive_system_log_vulnerable(\"No handler found for component index (vulnerable).\");\n        }\n    } else {\n        automotive_system_log_vulnerable(\"Invalid component index out of declared bounds (vulnerable).\");\n    }\n}\n\nvoid main_diag_vulnerable() {\n    initializeDiagnosticSystem_vulnerable();\n    processDiagnosticEvent_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_DIAG_HANDLERS_FIXED 16\n\ntypedef struct {\n    uint32_t raw_event_code;\n} DiagnosticEvent_Fixed;\n\ntypedef void (*DiagnosticHandler_Fixed)(uint16_t error_code, uint8_t module_id);\n\nvoid handleSubComponent0_fixed(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent1_fixed(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent2_fixed(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent3_fixed(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent4_fixed(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent5_fixed(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent6_fixed(uint16_t error_code, uint8_t module_id) {}\nvoid handleSubComponent7_fixed(uint16_t error_code, uint8_t module_id) {}\n\nstatic DiagnosticHandler_Fixed g_diagHandlers_fixed[MAX_DIAG_HANDLERS_FIXED];\nstatic const uint8_t actual_num_diag_handlers_fixed = 8;\n\nvoid automotive_system_log_fixed(const char* msg) {\n}\n\nDiagnosticEvent_Fixed receiveDiagnosticEvent_fixed() {\n    DiagnosticEvent_Fixed event;\n    event.raw_event_code = 0x01234508;\n    return event;\n}\n\nvoid initializeDiagnosticSystem_fixed() {\n    g_diagHandlers_fixed[0] = handleSubComponent0_fixed;\n    g_diagHandlers_fixed[1] = handleSubComponent1_fixed;\n    g_diagHandlers_fixed[2] = handleSubComponent2_fixed;\n    g_diagHandlers_fixed[3] = handleSubComponent3_fixed;\n    g_diagHandlers_fixed[4] = handleSubComponent4_fixed;\n    g_diagHandlers_fixed[5] = handleSubComponent5_fixed;\n    g_diagHandlers_fixed[6] = handleSubComponent6_fixed;\n    g_diagHandlers_fixed[7] = handleSubComponent7_fixed;\n\n    for (uint8_t i = actual_num_diag_handlers_fixed; i < MAX_DIAG_HANDLERS_FIXED; ++i) {\n        g_diagHandlers_fixed[i] = NULL;\n    }\n\n    automotive_system_log_fixed(\"Diagnostic system initialized (fixed).\");\n}\n\nvoid processDiagnosticEvent_fixed() {\n    DiagnosticEvent_Fixed event = receiveDiagnosticEvent_fixed();\n\n    uint8_t component_index = (uint8_t)(event.raw_event_code & 0xFF);\n    uint16_t error_code = (uint16_t)((event.raw_event_code >> 8) & 0xFFFF);\n    uint8_t module_id = (uint8_t)((event.raw_event_code >> 24) & 0xFF);\n\n    if (component_index < actual_num_diag_handlers_fixed) {\n        DiagnosticHandler_Fixed handler = g_diagHandlers_fixed[component_index];\n        if (handler != NULL) {\n            handler(error_code, module_id);\n            automotive_system_log_fixed(\"Diagnostic event dispatched (fixed).\");\n        } else {\n            automotive_system_log_fixed(\"No handler found for component index (fixed).\");\n        }\n    } else {\n        automotive_system_log_fixed(\"Invalid component index out of actual handler bounds (fixed).\");\n    }\n}\n\nvoid main_diag_fixed() {\n    initializeDiagnosticSystem_fixed();\n    processDiagnosticEvent_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_LIGHTING_ZONES 5\n\ntypedef enum {\n    LIGHT_MODE_OFF = 0,\n    LIGHT_MODE_ON_LOW,\n    LIGHT_MODE_ON_HIGH,\n    LIGHT_MODE_AMBIENT,\n    LIGHT_MODE_COUNT\n} LightingMode;\n\ntypedef struct {\n    LightingMode current_mode;\n    uint8_t brightness;\n    uint16_t color_temp_kelvin;\n} LightingZoneConfig_Vulnerable;\n\nstatic LightingZoneConfig_Vulnerable g_lightingZoneConfigs_vulnerable[MAX_LIGHTING_ZONES];\n\nvoid lightingLog_vulnerable(const char* msg) {\n    printf(\"LIGHT_VULN: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t zone_id;\n    LightingMode new_mode;\n    uint8_t new_brightness;\n    uint16_t new_color_temp;\n} LightingCommand_Vulnerable;\n\nLightingCommand_Vulnerable getSimulatedLightingCommand_vulnerable() {\n    LightingCommand_Vulnerable cmd;\n    cmd.zone_id = MAX_LIGHTING_ZONES; \n    cmd.new_mode = LIGHT_MODE_ON_HIGH;\n    cmd.new_brightness = 85;\n    cmd.new_color_temp = 4500;\n    lightingLog_vulnerable(\"Simulating reception of lighting command (vulnerable).\");\n    return cmd;\n}\n\nvoid initializeLightingSystem_vulnerable() {\n    for (uint8_t i = 0; i < MAX_LIGHTING_ZONES; ++i) {\n        g_lightingZoneConfigs_vulnerable[i].current_mode = LIGHT_MODE_OFF;\n        g_lightingZoneConfigs_vulnerable[i].brightness = 0;\n        g_lightingZoneConfigs_vulnerable[i].color_temp_kelvin = 0;\n    }\n    lightingLog_vulnerable(\"Lighting system initialized (vulnerable).\");\n}\n\nvoid applyLightingCommand_vulnerable(LightingCommand_Vulnerable cmd) {\n    g_lightingZoneConfigs_vulnerable[cmd.zone_id].current_mode = cmd.new_mode;\n    g_lightingZoneConfigs_vulnerable[cmd.zone_id].brightness = cmd.new_brightness;\n    g_lightingZoneConfigs_vulnerable[cmd.zone_id].color_temp_kelvin = cmd.new_color_temp;\n    lightingLog_vulnerable(\"Lighting command applied (vulnerable).\");\n}\n\nvoid renderCurrentLightingState_vulnerable() {\n    lightingLog_vulnerable(\"Rendering current lighting state (vulnerable).\");\n}\n\nvoid lightingControlUnitMain_vulnerable() {\n    initializeLightingSystem_vulnerable();\n    LightingCommand_Vulnerable command = getSimulatedLightingCommand_vulnerable();\n    applyLightingCommand_vulnerable(command);\n    renderCurrentLightingState_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_LIGHTING_ZONES 5\n\ntypedef enum {\n    LIGHT_MODE_OFF = 0,\n    LIGHT_MODE_ON_LOW,\n    LIGHT_MODE_ON_HIGH,\n    LIGHT_MODE_AMBIENT,\n    LIGHT_MODE_COUNT\n} LightingMode;\n\ntypedef struct {\n    LightingMode current_mode;\n    uint8_t brightness;\n    uint16_t color_temp_kelvin;\n} LightingZoneConfig_Fixed;\n\nstatic LightingZoneConfig_Fixed g_lightingZoneConfigs_fixed[MAX_LIGHTING_ZONES];\n\nvoid lightingLog_fixed(const char* msg) {\n    printf(\"LIGHT_FIXED: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t zone_id;\n    LightingMode new_mode;\n    uint8_t new_brightness;\n    uint16_t new_color_temp;\n} LightingCommand_Fixed;\n\nLightingCommand_Fixed getSimulatedLightingCommand_fixed() {\n    LightingCommand_Fixed cmd;\n    cmd.zone_id = MAX_LIGHTING_ZONES; \n    cmd.new_mode = LIGHT_MODE_ON_HIGH;\n    cmd.new_brightness = 85;\n    cmd.new_color_temp = 4500;\n    lightingLog_fixed(\"Simulating reception of lighting command (fixed).\");\n    return cmd;\n}\n\nvoid initializeLightingSystem_fixed() {\n    for (uint8_t i = 0; i < MAX_LIGHTING_ZONES; ++i) {\n        g_lightingZoneConfigs_fixed[i].current_mode = LIGHT_MODE_OFF;\n        g_lightingZoneConfigs_fixed[i].brightness = 0;\n        g_lightingZoneConfigs_fixed[i].color_temp_kelvin = 0;\n    }\n    lightingLog_fixed(\"Lighting system initialized (fixed).\");\n}\n\nvoid applyLightingCommand_fixed(LightingCommand_Fixed cmd) {\n    if (cmd.zone_id < MAX_LIGHTING_ZONES) {\n        g_lightingZoneConfigs_fixed[cmd.zone_id].current_mode = cmd.new_mode;\n        g_lightingZoneConfigs_fixed[cmd.zone_id].brightness = cmd.new_brightness;\n        g_lightingZoneConfigs_fixed[cmd.zone_id].color_temp_kelvin = cmd.new_color_temp;\n        lightingLog_fixed(\"Lighting command applied successfully (fixed).\");\n    } else {\n        lightingLog_fixed(\"Invalid lighting zone ID received. Command ignored (fixed).\");\n    }\n}\n\nvoid renderCurrentLightingState_fixed() {\n    lightingLog_fixed(\"Rendering current lighting state (fixed).\");\n}\n\nvoid lightingControlUnitMain_fixed() {\n    initializeLightingSystem_fixed();\n    LightingCommand_Fixed command = getSimulatedLightingCommand_fixed();\n    applyLightingCommand_fixed(command);\n    renderCurrentLightingState_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRIES_PER_PRIORITY 10\n\ntypedef enum {\n    PRIO_CRITICAL_VULNERABLE = 0,\n    PRIO_MAJOR_VULNERABLE,\n    PRIO_MINOR_VULNERABLE,\n    PRIO_INFO_VULNERABLE,\n    NUM_PRIORITY_LEVELS_VULNERABLE\n} EventPriority_Vulnerable;\n\ntypedef struct {\n    uint32_t event_id;\n    uint32_t timestamp;\n    uint8_t flags;\n} IncomingLogMessage_Vulnerable;\n\ntypedef struct {\n    uint32_t id;\n    uint32_t time;\n} LogEntry_Vulnerable;\n\nstatic LogEntry_Vulnerable g_logBuffer_vulnerable[NUM_PRIORITY_LEVELS_VULNERABLE][MAX_LOG_ENTRIES_PER_PRIORITY];\nstatic uint8_t g_logCounts_vulnerable[NUM_PRIORITY_LEVELS_VULNERABLE];\n\nvoid automotive_system_log_vulnerable(const char* msg) {\n    (void)msg;\n}\n\nIncomingLogMessage_Vulnerable receiveLogMessage_vulnerable() {\n    IncomingLogMessage_Vulnerable msg;\n    msg.event_id = 0xABCD1234;\n    msg.timestamp = 0x567890AB;\n    msg.flags = 0x40;\n    automotive_system_log_vulnerable(\"Simulated incoming log message with potentially malicious flags.\");\n    return msg;\n}\n\nvoid initializeLoggingSystem_vulnerable() {\n    for (uint8_t i = 0; i < NUM_PRIORITY_LEVELS_VULNERABLE; ++i) {\n        g_logCounts_vulnerable[i] = 0;\n        for (uint8_t j = 0; j < MAX_LOG_ENTRIES_PER_PRIORITY; ++j) {\n            g_logBuffer_vulnerable[i][j].id = 0;\n            g_logBuffer_vulnerable[i][j].time = 0;\n        }\n    }\n    automotive_system_log_vulnerable(\"Logging system initialized (vulnerable).\");\n}\n\nvoid processIncomingLog_vulnerable() {\n    IncomingLogMessage_Vulnerable msg = receiveLogMessage_vulnerable();\n\n    uint8_t raw_prio_val = (msg.flags >> 4) & 0x0F;\n\n    EventPriority_Vulnerable actual_priority = (EventPriority_VULNERABLE)raw_prio_val;\n\n    if (g_logCounts_vulnerable[actual_priority] < MAX_LOG_ENTRIES_PER_PRIORITY) {\n        g_logBuffer_vulnerable[actual_priority][g_logCounts_vulnerable[actual_priority]].id = msg.event_id;\n        g_logBuffer_vulnerable[actual_priority][g_logCounts_vulnerable[actual_priority]].time = msg.timestamp;\n        g_logCounts_vulnerable[actual_priority]++;\n        automotive_system_log_vulnerable(\"Log entry stored based on derived priority.\");\n    } else {\n        automotive_system_log_vulnerable(\"Log buffer full for this priority level.\");\n    }\n}\n\nvoid main_logging_vulnerable() {\n    initializeLoggingSystem_vulnerable();\n    processIncomingLog_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRIES_PER_PRIORITY_FIXED 10\n\ntypedef enum {\n    PRIO_CRITICAL_FIXED = 0,\n    PRIO_MAJOR_FIXED,\n    PRIO_MINOR_FIXED,\n    PRIO_INFO_FIXED,\n    NUM_PRIORITY_LEVELS_FIXED\n} EventPriority_Fixed;\n\ntypedef struct {\n    uint32_t event_id;\n    uint32_t timestamp;\n    uint8_t flags;\n} IncomingLogMessage_Fixed;\n\ntypedef struct {\n    uint32_t id;\n    uint32_t time;\n} LogEntry_Fixed;\n\nstatic LogEntry_Fixed g_logBuffer_fixed[NUM_PRIORITY_LEVELS_FIXED][MAX_LOG_ENTRIES_PER_PRIORITY_FIXED];\nstatic uint8_t g_logCounts_fixed[NUM_PRIORITY_LEVELS_FIXED];\n\nvoid automotive_system_log_fixed(const char* msg) {\n    (void)msg;\n}\n\nIncomingLogMessage_Fixed receiveLogMessage_fixed() {\n    IncomingLogMessage_Fixed msg;\n    msg.event_id = 0xABCD1234;\n    msg.timestamp = 0x567890AB;\n    msg.flags = 0x40;\n    automotive_system_log_fixed(\"Simulated incoming log message with potentially malicious flags.\");\n    return msg;\n}\n\nvoid initializeLoggingSystem_fixed() {\n    for (uint8_t i = 0; i < NUM_PRIORITY_LEVELS_FIXED; ++i) {\n        g_logCounts_fixed[i] = 0;\n        for (uint8_t j = 0; j < MAX_LOG_ENTRIES_PER_PRIORITY_FIXED; ++j) {\n            g_logBuffer_fixed[i][j].id = 0;\n            g_logBuffer_fixed[i][j].time = 0;\n        }\n    }\n    automotive_system_log_fixed(\"Logging system initialized (fixed).\");\n}\n\nvoid processIncomingLog_fixed() {\n    IncomingLogMessage_Fixed msg = receiveLogMessage_fixed();\n\n    uint8_t raw_prio_val = (msg.flags >> 4) & 0x0F;\n\n    if (raw_prio_val < NUM_PRIORITY_LEVELS_FIXED) {\n        EventPriority_Fixed actual_priority = (EventPriority_Fixed)raw_prio_val;\n\n        if (g_logCounts_fixed[actual_priority] < MAX_LOG_ENTRIES_PER_PRIORITY_FIXED) {\n            g_logBuffer_fixed[actual_priority][g_logCounts_fixed[actual_priority]].id = msg.event_id;\n            g_logBuffer_fixed[actual_priority][g_logCounts_fixed[actual_priority]].time = msg.timestamp;\n            g_logCounts_fixed[actual_priority]++;\n            automotive_system_log_fixed(\"Log entry stored based on derived priority.\");\n        } else {\n            automotive_system_log_fixed(\"Log buffer full for this priority level. Dropping message.\");\n        }\n    } else {\n        automotive_system_log_fixed(\"Invalid derived priority level from flags. Message dropped.\");\n    }\n}\n\nvoid main_logging_fixed() {\n    initializeLoggingSystem_fixed();\n    processIncomingLog_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_SUPPORTED_SENSOR_TYPES_VULN 3\n\ntypedef struct {\n    uint32_t processing_flags;\n    int16_t offset_calibration;\n    float gain_calibration;\n    bool enable_filter;\n} SensorProcessingConfig_Vulnerable;\n\nstatic SensorProcessingConfig_Vulnerable g_sensorConfigs_vulnerable[MAX_SUPPORTED_SENSOR_TYPES_VULN];\n\nvoid system_log_vulnerable(const char* msg) {\n    fprintf(stdout, \"VULN_LOG: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t sensor_type_id;\n    uint16_t raw_value;\n    uint32_t timestamp;\n} SensorDataPacket_Vulnerable;\n\nSensorDataPacket_Vulnerable getSimulatedSensorData_vulnerable() {\n    SensorDataPacket_Vulnerable packet;\n    packet.sensor_type_id = MAX_SUPPORTED_SENSOR_TYPES_VULN; \n    packet.raw_value = 4096;\n    packet.timestamp = 0x12345678;\n    system_log_vulnerable(\"Simulated incoming sensor data with potentially malicious sensor_type_id.\");\n    return packet;\n}\n\nvoid initializeSensorConfigurations_vulnerable() {\n    g_sensorConfigs_vulnerable[0] = (SensorProcessingConfig_Vulnerable){.processing_flags = 0x01, .offset_calibration = 10, .gain_calibration = 1.0, .enable_filter = true};\n    g_sensorConfigs_vulnerable[1] = (SensorProcessingConfig_Vulnerable){.processing_flags = 0x02, .offset_calibration = 5, .gain_calibration = 0.9, .enable_filter = false};\n    g_sensorConfigs_vulnerable[2] = (SensorProcessingConfig_Vulnerable){.processing_flags = 0x04, .offset_calibration = 0, .gain_calibration = 1.1, .enable_filter = true};\n    system_log_vulnerable(\"Sensor configurations initialized.\");\n}\n\nvoid processSensorData_vulnerable() {\n    SensorDataPacket_Vulnerable packet = getSimulatedSensorData_vulnerable();\n\n    SensorProcessingConfig_Vulnerable current_config = g_sensorConfigs_vulnerable[packet.sensor_type_id];\n\n    float processed_value = (float)packet.raw_value * current_config.gain_calibration + current_config.offset_calibration;\n    system_log_vulnerable(\"Sensor data processed (vulnerable).\");\n}\n\nvoid automotiveSensorProcessingModule_vulnerable() {\n    initializeSensorConfigurations_vulnerable();\n    processSensorData_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_SUPPORTED_SENSOR_TYPES_FIXED 3\n\ntypedef struct {\n    uint32_t processing_flags;\n    int16_t offset_calibration;\n    float gain_calibration;\n    bool enable_filter;\n} SensorProcessingConfig_Fixed;\n\nstatic SensorProcessingConfig_Fixed g_sensorConfigs_fixed[MAX_SUPPORTED_SENSOR_TYPES_FIXED];\n\nvoid system_log_fixed(const char* msg) {\n    fprintf(stdout, \"FIXED_LOG: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t sensor_type_id;\n    uint16_t raw_value;\n    uint32_t timestamp;\n} SensorDataPacket_Fixed;\n\nSensorDataPacket_Fixed getSimulatedSensorData_fixed() {\n    SensorDataPacket_Fixed packet;\n    packet.sensor_type_id = MAX_SUPPORTED_SENSOR_TYPES_FIXED; \n    packet.raw_value = 4096;\n    packet.timestamp = 0x12345678;\n    system_log_fixed(\"Simulated incoming sensor data with potentially malicious sensor_type_id.\");\n    return packet;\n}\n\nvoid initializeSensorConfigurations_fixed() {\n    g_sensorConfigs_fixed[0] = (SensorProcessingConfig_Fixed){.processing_flags = 0x01, .offset_calibration = 10, .gain_calibration = 1.0, .enable_filter = true};\n    g_sensorConfigs_fixed[1] = (SensorProcessingConfig_Fixed){.processing_flags = 0x02, .offset_calibration = 5, .gain_calibration = 0.9, .enable_filter = false};\n    g_sensorConfigs_fixed[2] = (SensorProcessingConfig_Fixed){.processing_flags = 0x04, .offset_calibration = 0, .gain_calibration = 1.1, .enable_filter = true};\n    system_log_fixed(\"Sensor configurations initialized.\");\n}\n\nvoid processSensorData_fixed() {\n    SensorDataPacket_Fixed packet = getSimulatedSensorData_fixed();\n\n    if (packet.sensor_type_id < MAX_SUPPORTED_SENSOR_TYPES_FIXED) {\n        SensorProcessingConfig_Fixed current_config = g_sensorConfigs_fixed[packet.sensor_type_id];\n\n        float processed_value = (float)packet.raw_value * current_config.gain_calibration + current_config.offset_calibration;\n        system_log_fixed(\"Sensor data processed (fixed).\");\n    } else {\n        system_log_fixed(\"ERROR: Invalid sensor type ID received. Ignoring data.\");\n    }\n}\n\nvoid automotiveSensorProcessingModule_fixed() {\n    initializeSensorConfigurations_fixed();\n    processSensorData_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_PARAMETER_GROUPS 3\n#define MAX_PARAMS_PER_GROUP 10\n\ntypedef struct {\n    uint16_t value;\n    uint8_t status;\n} DiagnosticParameter;\n\nDiagnosticParameter g_engineParams[MAX_PARAMS_PER_GROUP];\nDiagnosticParameter g_chassisParams[MAX_PARAMS_PER_GROUP];\nDiagnosticParameter g_batteryParams[MAX_PARAMS_PER_GROUP];\n\ntypedef struct {\n    DiagnosticParameter* data_buffer;\n    uint8_t max_params;\n    uint8_t current_count;\n} ParameterGroupConfig;\n\nstatic ParameterGroupConfig g_paramGroupConfigs_vulnerable[MAX_PARAMETER_GROUPS];\n\nvoid diagnosticLog_vulnerable(const char* msg) {\n    printf(\"DIAG_LOG_VULN: %s\\n\", msg);\n}\n\nvoid initializeDiagnosticSystem_vulnerable() {\n    g_paramGroupConfigs_vulnerable[0] = (ParameterGroupConfig){.data_buffer = g_engineParams, .max_params = MAX_PARAMS_PER_GROUP, .current_count = 0};\n    g_paramGroupConfigs_vulnerable[1] = (ParameterGroupConfig){.data_buffer = g_chassisParams, .max_params = MAX_PARAMS_PER_GROUP, .current_count = 0};\n    g_paramGroupConfigs_vulnerable[2] = (ParameterGroupConfig){.data_buffer = g_batteryParams, .max_params = MAX_PARAMS_PER_GROUP, .current_count = 0};\n    diagnosticLog_vulnerable(\"Diagnostic system initialized (vulnerable).\");\n}\n\ntypedef struct {\n    uint8_t group_id;\n    uint8_t param_idx_to_update;\n    DiagnosticParameter new_value;\n} IncomingDiagnosticUpdate_vulnerable;\n\nIncomingDiagnosticUpdate_vulnerable receiveDiagnosticUpdate_vulnerable() {\n    IncomingDiagnosticUpdate_vulnerable update;\n    update.group_id = 0;\n    update.param_idx_to_update = 10;\n    update.new_value = (DiagnosticParameter){.value = 0xAAAA, .status = 0xFF};\n    return update;\n}\n\nvoid updateDiagnosticParameter_vulnerable(IncomingDiagnosticUpdate_vulnerable update) {\n    if (update.group_id < MAX_PARAMETER_GROUPS) {\n        ParameterGroupConfig* config = &g_paramGroupConfigs_vulnerable[update.group_id];\n        config->data_buffer[update.param_idx_to_update] = update.new_value;\n        diagnosticLog_vulnerable(\"Diagnostic parameter updated (vulnerable).\");\n    } else {\n        diagnosticLog_vulnerable(\"Invalid diagnostic group ID received (vulnerable).\");\n    }\n}\n\nvoid diagnosticManagerLoop_vulnerable() {\n    initializeDiagnosticSystem_vulnerable();\n    IncomingDiagnosticUpdate_vulnerable bad_update = receiveDiagnosticUpdate_vulnerable();\n    updateDiagnosticParameter_vulnerable(bad_update);\n    IncomingDiagnosticUpdate_vulnerable good_update;\n    good_update.group_id = 1;\n    good_update.param_idx_to_update = 2;\n    good_update.new_value = (DiagnosticParameter){.value = 0xBBBB, .status = 0xEE};\n    updateDiagnosticParameter_vulnerable(good_update);\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_PARAMETER_GROUPS 3\n#define MAX_PARAMS_PER_GROUP 10\n\ntypedef struct {\n    uint16_t value;\n    uint8_t status;\n} DiagnosticParameter_Fixed;\n\nDiagnosticParameter_Fixed g_engineParams_fixed[MAX_PARAMS_PER_GROUP];\nDiagnosticParameter_Fixed g_chassisParams_fixed[MAX_PARAMS_PER_GROUP];\nDiagnosticParameter_Fixed g_batteryParams_fixed[MAX_PARAMS_PER_GROUP];\n\ntypedef struct {\n    DiagnosticParameter_Fixed* data_buffer;\n    uint8_t max_params;\n    uint8_t current_count;\n} ParameterGroupConfig_Fixed;\n\nstatic ParameterGroupConfig_Fixed g_paramGroupConfigs_fixed[MAX_PARAMETER_GROUPS];\n\nvoid diagnosticLog_fixed(const char* msg) {\n    printf(\"DIAG_LOG_FIXED: %s\\n\", msg);\n}\n\nvoid initializeDiagnosticSystem_fixed() {\n    g_paramGroupConfigs_fixed[0] = (ParameterGroupConfig_Fixed){.data_buffer = g_engineParams_fixed, .max_params = MAX_PARAMS_PER_GROUP, .current_count = 0};\n    g_paramGroupConfigs_fixed[1] = (ParameterGroupConfig_Fixed){.data_buffer = g_chassisParams_fixed, .max_params = MAX_PARAMS_PER_GROUP, .current_count = 0};\n    g_paramGroupConfigs_fixed[2] = (ParameterGroupConfig_Fixed){.data_buffer = g_batteryParams_fixed, .max_params = MAX_PARAMS_PER_GROUP, .current_count = 0};\n    diagnosticLog_fixed(\"Diagnostic system initialized (fixed).\");\n}\n\ntypedef struct {\n    uint8_t group_id;\n    uint8_t param_idx_to_update;\n    DiagnosticParameter_Fixed new_value;\n} IncomingDiagnosticUpdate_Fixed;\n\nIncomingDiagnosticUpdate_Fixed receiveDiagnosticUpdate_fixed() {\n    IncomingDiagnosticUpdate_Fixed update;\n    update.group_id = 0;\n    update.param_idx_to_update = 10;\n    update.new_value = (DiagnosticParameter_Fixed){.value = 0xAAAA, .status = 0xFF};\n    return update;\n}\n\nvoid updateDiagnosticParameter_fixed(IncomingDiagnosticUpdate_Fixed update) {\n    if (update.group_id < MAX_PARAMETER_GROUPS) {\n        ParameterGroupConfig_Fixed* config = &g_paramGroupConfigs_fixed[update.group_id];\n        if (update.param_idx_to_update < config->max_params) {\n            config->data_buffer[update.param_idx_to_update] = update.new_value;\n            diagnosticLog_fixed(\"Diagnostic parameter updated (fixed).\");\n        } else {\n            diagnosticLog_fixed(\"Parameter index out of bounds for the specified group. Ignoring update (fixed).\");\n        }\n    } else {\n        diagnosticLog_fixed(\"Invalid diagnostic group ID received (fixed).\");\n    }\n}\n\nvoid diagnosticManagerLoop_fixed() {\n    initializeDiagnosticSystem_fixed();\n    IncomingDiagnosticUpdate_Fixed bad_update = receiveDiagnosticUpdate_fixed();\n    updateDiagnosticParameter_fixed(bad_update);\n    IncomingDiagnosticUpdate_Fixed good_update;\n    good_update.group_id = 1;\n    good_update.param_idx_to_update = 2;\n    good_update.new_value = (DiagnosticParameter_Fixed){.value = 0xBBBB, .status = 0xEE};\n    updateDiagnosticParameter_fixed(good_update);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_COMPONENTS 10\n#define MAX_ERROR_CODES_PER_COMPONENT 20\n#define MAX_DTC_SEVERITY_LEVELS 3\n\ntypedef struct {\n    uint32_t handler_id;\n    uint8_t  alert_level;\n    bool     triggers_limp_mode;\n} SeverityHandlerConfig;\n\nstatic SeverityHandlerConfig g_severityHandlers[MAX_DTC_SEVERITY_LEVELS];\n\ntypedef struct {\n    uint16_t code_value;\n    uint32_t timestamp;\n    uint8_t  severity_raw;\n    bool     active;\n} ComponentDTCLogEntry;\n\nstatic ComponentDTCLogEntry g_engineDTCLog[MAX_ERROR_CODES_PER_COMPONENT];\n\nvoid automotiveLogger_vulnerable(const char* message) {\n}\n\nComponentDTCLogEntry getNewDTCReport_vulnerable() {\n    ComponentDTCLogEntry report;\n    report.code_value = 0x01A2;\n    report.timestamp = 0xABCDEFFF;\n    report.severity_raw = 3;\n    report.active = true;\n    return report;\n}\n\nvoid initializeDiagnosticSystem_vulnerable() {\n    g_severityHandlers[0] = (SeverityHandlerConfig){0x1000, 1, false};\n    g_severityHandlers[1] = (SeverityHandlerConfig){0x2000, 5, false};\n    g_severityHandlers[2] = (SeverityHandlerConfig){0x3000, 10, true};\n\n    for (uint8_t i = 0; i < MAX_ERROR_CODES_PER_COMPONENT; ++i) {\n        g_engineDTCLog[i] = (ComponentDTCLogEntry){0, 0, 0, false};\n    }\n    automotiveLogger_vulnerable(\"Diagnostic system initialized (vulnerable).\");\n}\n\nvoid processNewDTCReport_vulnerable(ComponentDTCLogEntry new_dtc) {\n    uint8_t log_idx = new_dtc.code_value % MAX_ERROR_CODES_PER_COMPONENT;\n\n    g_engineDTCLog[log_idx] = new_dtc;\n\n    SeverityHandlerConfig current_handler_config = g_severityHandlers[new_dtc.severity_raw];\n\n    automotiveLogger_vulnerable(\"DTC processed. Attempting to apply handler config.\");\n\n    if (current_handler_config.triggers_limp_mode) {\n        automotiveLogger_vulnerable(\"Limp mode triggered by DTC (vulnerable).\");\n    } else {\n        automotiveLogger_vulnerable(\"DTC handler applied without limp mode (vulnerable).\");\n    }\n}\n\nvoid diagnosticServiceMain_vulnerable() {\n    initializeDiagnosticSystem_vulnerable();\n    ComponentDTCLogEntry report = getNewDTCReport_vulnerable();\n    processNewDTCReport_vulnerable(report);\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_COMPONENTS_FIXED 10\n#define MAX_ERROR_CODES_PER_COMPONENT_FIXED 20\n#define MAX_DTC_SEVERITY_LEVELS_FIXED 3\n\ntypedef struct {\n    uint32_t handler_id;\n    uint8_t  alert_level;\n    bool     triggers_limp_mode;\n} SeverityHandlerConfig_Fixed;\n\nstatic SeverityHandlerConfig_Fixed g_severityHandlers_Fixed[MAX_DTC_SEVERITY_LEVELS_FIXED];\n\ntypedef struct {\n    uint16_t code_value;\n    uint32_t timestamp;\n    uint8_t  severity_raw;\n    bool     active;\n} ComponentDTCLogEntry_Fixed;\n\nstatic ComponentDTCLogEntry_Fixed g_engineDTCLog_Fixed[MAX_ERROR_CODES_PER_COMPONENT_FIXED];\n\nvoid automotiveLogger_fixed(const char* message) {\n}\n\nComponentDTCLogEntry_Fixed getNewDTCReport_fixed() {\n    ComponentDTCLogEntry_Fixed report;\n    report.code_value = 0x01A2;\n    report.timestamp = 0xABCDEFFF;\n    report.severity_raw = 3;\n    report.active = true;\n    return report;\n}\n\nvoid initializeDiagnosticSystem_fixed() {\n    g_severityHandlers_Fixed[0] = (SeverityHandlerConfig_Fixed){0x1000, 1, false};\n    g_severityHandlers_Fixed[1] = (SeverityHandlerConfig_Fixed){0x2000, 5, false};\n    g_severityHandlers_Fixed[2] = (SeverityHandlerConfig_Fixed){0x3000, 10, true};\n\n    for (uint8_t i = 0; i < MAX_ERROR_CODES_PER_COMPONENT_FIXED; ++i) {\n        g_engineDTCLog_Fixed[i] = (ComponentDTCLogEntry_Fixed){0, 0, 0, false};\n    }\n    automotiveLogger_fixed(\"Diagnostic system initialized (fixed).\");\n}\n\nvoid processNewDTCReport_fixed(ComponentDTCLogEntry_Fixed new_dtc) {\n    uint8_t log_idx = new_dtc.code_value % MAX_ERROR_CODES_PER_COMPONENT_FIXED;\n\n    g_engineDTCLog_Fixed[log_idx] = new_dtc;\n\n    automotiveLogger_fixed(\"DTC processed. Attempting to apply handler config (fixed).\");\n\n    if (new_dtc.severity_raw < MAX_DTC_SEVERITY_LEVELS_FIXED) {\n        SeverityHandlerConfig_Fixed current_handler_config = g_severityHandlers_Fixed[new_dtc.severity_raw];\n        if (current_handler_config.triggers_limp_mode) {\n            automotiveLogger_fixed(\"Limp mode triggered by DTC (fixed).\");\n        } else {\n            automotiveLogger_fixed(\"DTC handler applied without limp mode (fixed).\");\n        }\n    } else {\n        automotiveLogger_fixed(\"Invalid severity level received for DTC. Ignoring handler application (fixed).\");\n    }\n}\n\nvoid diagnosticServiceMain_fixed() {\n    initializeDiagnosticSystem_fixed();\n    ComponentDTCLogEntry_Fixed report = getNewDTCReport_fixed();\n    processNewDTCReport_fixed(report);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define NUM_ECU_TYPES 3\n#define MAX_ROUTINES_PER_ECU_TYPE 10\n\ntypedef void (*DiagnosticRoutine_t)(uint32_t);\n\nstatic const uint8_t g_numRoutinesPerEcuType_vulnerable[NUM_ECU_TYPES] = {\n    5, \n    8, \n    3  \n};\n\nstatic DiagnosticRoutine_t g_diagnosticRoutines_vulnerable[NUM_ECU_TYPES][MAX_ROUTINES_PER_ECU_TYPE];\n\ntypedef struct {\n    uint8_t ecu_type_id;\n    uint8_t routine_index;\n    uint32_t routine_param;\n} DiagnosticCommand_vulnerable;\n\nvoid logDiagnosticEvent_vulnerable(const char* msg) {\n}\n\nvoid simulatedDiagnosticRoutine_vulnerable(uint32_t param) {\n    (void)param;\n    logDiagnosticEvent_vulnerable(\"Simulated diagnostic routine executed.\");\n}\n\nDiagnosticCommand_vulnerable receiveDiagnosticCommand_vulnerable() {\n    DiagnosticCommand_vulnerable cmd;\n    cmd.ecu_type_id = 2; \n    cmd.routine_index = 4; \n    cmd.routine_param = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeDiagnosticSystem_vulnerable() {\n    for (uint8_t i = 0; i < NUM_ECU_TYPES; ++i) {\n        for (uint8_t j = 0; j < MAX_ROUTINES_PER_ECU_TYPE; ++j) {\n            g_diagnosticRoutines_vulnerable[i][j] = NULL;\n        }\n        for (uint8_t j = 0; j < g_numRoutinesPerEcuType_vulnerable[i]; ++j) {\n            g_diagnosticRoutines_vulnerable[i][j] = simulatedDiagnosticRoutine_vulnerable;\n        }\n    }\n    logDiagnosticEvent_vulnerable(\"Diagnostic system initialized (vulnerable).\");\n}\n\nvoid executeDiagnosticCommand_vulnerable() {\n    DiagnosticCommand_vulnerable cmd = receiveDiagnosticCommand_vulnerable();\n\n    if (cmd.ecu_type_id < NUM_ECU_TYPES) {\n        if (cmd.routine_index < MAX_ROUTINES_PER_ECU_TYPE) { \n            if (g_diagnosticRoutines_vulnerable[cmd.ecu_type_id][cmd.routine_index] != NULL) {\n                g_diagnosticRoutines_vulnerable[cmd.ecu_type_id][cmd.routine_index](cmd.routine_param);\n            } else {\n                logDiagnosticEvent_vulnerable(\"Requested routine is NULL for this index. (Possible logical OOB)\");\n            }\n        } else {\n            logDiagnosticEvent_vulnerable(\"Routine index out of global allocated bounds.\");\n        }\n    } else {\n        logDiagnosticEvent_vulnerable(\"Invalid ECU type ID.\");\n    }\n}\n\nvoid diagnosticManagerMain_vulnerable() {\n    initializeDiagnosticSystem_vulnerable();\n    executeDiagnosticCommand_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n\n#define NUM_ECU_TYPES 3\n#define MAX_ROUTINES_PER_ECU_TYPE 10\n\ntypedef void (*DiagnosticRoutine_t)(uint32_t);\n\nstatic const uint8_t g_numRoutinesPerEcuType_fixed[NUM_ECU_TYPES] = {\n    5, \n    8, \n    3  \n};\n\nstatic DiagnosticRoutine_t g_diagnosticRoutines_fixed[NUM_ECU_TYPES][MAX_ROUTINES_PER_ECU_TYPE];\n\ntypedef struct {\n    uint8_t ecu_type_id;\n    uint8_t routine_index;\n    uint32_t routine_param;\n} DiagnosticCommand_fixed;\n\nvoid logDiagnosticEvent_fixed(const char* msg) {\n}\n\nvoid simulatedDiagnosticRoutine_fixed(uint32_t param) {\n    (void)param;\n    logDiagnosticEvent_fixed(\"Simulated diagnostic routine executed.\");\n}\n\nDiagnosticCommand_fixed receiveDiagnosticCommand_fixed() {\n    DiagnosticCommand_fixed cmd;\n    cmd.ecu_type_id = 2; \n    cmd.routine_index = 4; \n    cmd.routine_param = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeDiagnosticSystem_fixed() {\n    for (uint8_t i = 0; i < NUM_ECU_TYPES; ++i) {\n        for (uint8_t j = 0; j < MAX_ROUTINES_PER_ECU_TYPE; ++j) {\n            g_diagnosticRoutines_fixed[i][j] = NULL;\n        }\n        for (uint8_t j = 0; j < g_numRoutinesPerEcuType_fixed[i]; ++j) {\n            g_diagnosticRoutines_fixed[i][j] = simulatedDiagnosticRoutine_fixed;\n        }\n    }\n    logDiagnosticEvent_fixed(\"Diagnostic system initialized (fixed).\");\n}\n\nvoid executeDiagnosticCommand_fixed() {\n    DiagnosticCommand_fixed cmd = receiveDiagnosticCommand_fixed();\n\n    if (cmd.ecu_type_id < NUM_ECU_TYPES) {\n        if (cmd.routine_index < g_numRoutinesPerEcuType_fixed[cmd.ecu_type_id]) { \n            if (g_diagnosticRoutines_fixed[cmd.ecu_type_id][cmd.routine_index] != NULL) {\n                g_diagnosticRoutines_fixed[cmd.ecu_type_id][cmd.routine_index](cmd.routine_param);\n            } else {\n                logDiagnosticEvent_fixed(\"Requested routine is NULL for this index. (Internal config error)\");\n            }\n        } else {\n            logDiagnosticEvent_fixed(\"Routine index out of bounds for specified ECU type.\");\n        }\n    } else {\n        logDiagnosticEvent_fixed(\"Invalid ECU type ID.\");\n    }\n}\n\nvoid diagnosticManagerMain_fixed() {\n    initializeDiagnosticSystem_fixed();\n    executeDiagnosticCommand_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n#include <stdbool.h>\n\nvoid automotiveLog_vulnerable(const char* msg) {\n}\n\n#define NUM_SENSOR_CHANNELS_VULNERABLE 3\n#define MAX_PROCESSING_STEPS_PER_CHANNEL_VULNERABLE 8\n\ntypedef enum {\n    SENSOR_CHANNEL_ENGINE_TEMP_VULNERABLE = 0,\n    SENSOR_CHANNEL_BRAKE_PRESSURE_VULNERABLE,\n    SENSOR_CHANNEL_STEERING_ANGLE_VULNERABLE,\n    SENSOR_CHANNEL_COUNT_VULNERABLE\n} SensorChannelID_vulnerable;\n\ntypedef float (*SensorProcessor_vulnerable)(float);\n\nfloat process_identity_vulnerable(float val) {\n    automotiveLog_vulnerable(\"  Identity processing.\");\n    return val;\n}\n\nfloat process_filter_vulnerable(float val) {\n    automotiveLog_vulnerable(\"  Filtering data.\");\n    return val * 0.95f;\n}\n\nfloat process_calibrate_vulnerable(float val) {\n    automotiveLog_vulnerable(\"  Calibrating data.\");\n    return val + 10.0f;\n}\n\nfloat process_transform_vulnerable(float val) {\n    automotiveLog_vulnerable(\"  Transforming data.\");\n    return val * 2.0f - 5.0f;\n}\n\nfloat process_security_critical_vulnerable(float val) {\n    automotiveLog_vulnerable(\"  WARNING: Executed security-critical dummy function!\");\n    return val;\n}\n\ntypedef struct {\n    SensorProcessor_vulnerable steps_vulnerable[MAX_PROCESSING_STEPS_PER_CHANNEL_VULNERABLE];\n    uint8_t num_active_steps_vulnerable;\n} ProcessingPipeline_vulnerable;\n\nstatic ProcessingPipeline_vulnerable g_sensorPipelines_vulnerable[SENSOR_CHANNEL_COUNT_VULNERABLE];\n\ntypedef struct {\n    SensorChannelID_vulnerable channel_id_vulnerable;\n    uint8_t step_index_vulnerable;\n    float input_value_vulnerable;\n} SensorProcessCommand_vulnerable;\n\nSensorProcessCommand_vulnerable receiveSensorProcessCommand_vulnerable() {\n    SensorProcessCommand_vulnerable cmd;\n    cmd.channel_id_vulnerable = SENSOR_CHANNEL_BRAKE_PRESSURE_VULNERABLE;\n    cmd.step_index_vulnerable = 5;\n    cmd.input_value_vulnerable = 50.5f;\n    return cmd;\n}\n\nvoid initializeSensorPipelines_vulnerable() {\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_ENGINE_TEMP_VULNERABLE].steps_vulnerable[0] = process_filter_vulnerable;\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_ENGINE_TEMP_VULNERABLE].steps_vulnerable[1] = process_calibrate_vulnerable;\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_ENGINE_TEMP_VULNERABLE].num_active_steps_vulnerable = 2;\n\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_BRAKE_PRESSURE_VULNERABLE].steps_vulnerable[0] = process_identity_vulnerable;\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_BRAKE_PRESSURE_VULNERABLE].steps_vulnerable[1] = process_filter_vulnerable;\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_BRAKE_PRESSURE_VULNERABLE].num_active_steps_vulnerable = 2;\n\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_STEERING_ANGLE_VULNERABLE].steps_vulnerable[0] = process_calibrate_vulnerable;\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_STEERING_ANGLE_VULNERABLE].steps_vulnerable[1] = process_transform_vulnerable;\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_STEERING_ANGLE_VULNERABLE].steps_vulnerable[2] = process_filter_vulnerable;\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_STEERING_ANGLE_VULNERABLE].num_active_steps_vulnerable = 3;\n\n    for (int i = 0; i < NUM_SENSOR_CHANNELS_VULNERABLE; ++i) {\n        for (int j = g_sensorPipelines_vulnerable[i].num_active_steps_vulnerable; j < MAX_PROCESSING_STEPS_PER_CHANNEL_VULNERABLE; ++j) {\n            g_sensorPipelines_vulnerable[i].steps_vulnerable[j] = process_identity_vulnerable;\n        }\n    }\n\n    g_sensorPipelines_vulnerable[SENSOR_CHANNEL_BRAKE_PRESSURE_VULNERABLE].steps_vulnerable[5] = process_security_critical_vulnerable;\n\n    automotiveLog_vulnerable(\"Sensor processing pipelines initialized (vulnerable).\");\n}\n\nvoid executeSensorProcessingStep_vulnerable(SensorProcessCommand_vulnerable cmd) {\n    automotiveLog_vulnerable(\"Attempting to execute sensor processing step (vulnerable).\");\n\n    if (cmd.channel_id_vulnerable >= SENSOR_CHANNEL_COUNT_VULNERABLE) {\n        automotiveLog_vulnerable(\"Error: Invalid sensor channel ID received.\");\n        return;\n    }\n\n    if (cmd.step_index_vulnerable < MAX_PROCESSING_STEPS_PER_CHANNEL_VULNERABLE) {\n        SensorProcessor_vulnerable processor_func = g_sensorPipelines_vulnerable[cmd.channel_id_vulnerable].steps_vulnerable[cmd.step_index_vulnerable];\n        \n        float result = processor_func(cmd.input_value_vulnerable);\n        (void)result;\n        automotiveLog_vulnerable(\"Sensor processing step executed.\");\n    } else {\n        automotiveLog_vulnerable(\"Error: Requested step index out of global bounds.\");\n    }\n}\n\nvoid automotiveSensorProcessingUnit_vulnerable_main() {\n    initializeSensorPipelines_vulnerable();\n    SensorProcessCommand_vulnerable command = receiveSensorProcessCommand_vulnerable();\n    executeSensorProcessingStep_vulnerable(command);\n    automotiveLog_vulnerable(\"Vulnerable sensor processing unit finished.\");\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n#include <stdbool.h>\n\nvoid automotiveLog_fixed(const char* msg) {\n}\n\n#define NUM_SENSOR_CHANNELS_FIXED 3\n#define MAX_PROCESSING_STEPS_PER_CHANNEL_FIXED 8\n\ntypedef enum {\n    SENSOR_CHANNEL_ENGINE_TEMP_FIXED = 0,\n    SENSOR_CHANNEL_BRAKE_PRESSURE_FIXED,\n    SENSOR_CHANNEL_STEERING_ANGLE_FIXED,\n    SENSOR_CHANNEL_COUNT_FIXED\n} SensorChannelID_fixed;\n\ntypedef float (*SensorProcessor_fixed)(float);\n\nfloat process_identity_fixed(float val) {\n    automotiveLog_fixed(\"  Identity processing.\");\n    return val;\n}\n\nfloat process_filter_fixed(float val) {\n    automotiveLog_fixed(\"  Filtering data.\");\n    return val * 0.95f;\n}\n\nfloat process_calibrate_fixed(float val) {\n    automotiveLog_fixed(\"  Calibrating data.\");\n    return val + 10.0f;\n}\n\nfloat process_transform_fixed(float val) {\n    automotiveLog_fixed(\"  Transforming data.\");\n    return val * 2.0f - 5.0f;\n}\n\nfloat process_security_critical_fixed(float val) {\n    automotiveLog_fixed(\"  WARNING: Executed security-critical dummy function!\");\n    return val;\n}\n\ntypedef struct {\n    SensorProcessor_fixed steps_fixed[MAX_PROCESSING_STEPS_PER_CHANNEL_FIXED];\n    uint8_t num_active_steps_fixed;\n} ProcessingPipeline_fixed;\n\nstatic ProcessingPipeline_fixed g_sensorPipelines_fixed[SENSOR_CHANNEL_COUNT_FIXED];\n\ntypedef struct {\n    SensorChannelID_fixed channel_id_fixed;\n    uint8_t step_index_fixed;\n    float input_value_fixed;\n} SensorProcessCommand_fixed;\n\nSensorProcessCommand_fixed receiveSensorProcessCommand_fixed() {\n    SensorProcessCommand_fixed cmd;\n    cmd.channel_id_fixed = SENSOR_CHANNEL_BRAKE_PRESSURE_FIXED;\n    cmd.step_index_fixed = 5;\n    cmd.input_value_fixed = 50.5f;\n    return cmd;\n}\n\nvoid initializeSensorPipelines_fixed() {\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_ENGINE_TEMP_FIXED].steps_fixed[0] = process_filter_fixed;\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_ENGINE_TEMP_FIXED].steps_fixed[1] = process_calibrate_fixed;\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_ENGINE_TEMP_FIXED].num_active_steps_fixed = 2;\n\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_BRAKE_PRESSURE_FIXED].steps_fixed[0] = process_identity_fixed;\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_BRAKE_PRESSURE_FIXED].steps_fixed[1] = process_filter_fixed;\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_BRAKE_PRESSURE_FIXED].num_active_steps_fixed = 2;\n\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_STEERING_ANGLE_FIXED].steps_fixed[0] = process_calibrate_fixed;\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_STEERING_ANGLE_FIXED].steps_fixed[1] = process_transform_fixed;\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_STEERING_ANGLE_FIXED].steps_fixed[2] = process_filter_fixed;\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_STEERING_ANGLE_FIXED].num_active_steps_fixed = 3;\n\n    for (int i = 0; i < NUM_SENSOR_CHANNELS_FIXED; ++i) {\n        for (int j = g_sensorPipelines_fixed[i].num_active_steps_fixed; j < MAX_PROCESSING_STEPS_PER_CHANNEL_FIXED; ++j) {\n            g_sensorPipelines_fixed[i].steps_fixed[j] = process_identity_fixed;\n        }\n    }\n\n    g_sensorPipelines_fixed[SENSOR_CHANNEL_BRAKE_PRESSURE_FIXED].steps_fixed[5] = process_security_critical_fixed;\n\n    automotiveLog_fixed(\"Sensor processing pipelines initialized (fixed).\");\n}\n\nvoid executeSensorProcessingStep_fixed(SensorProcessCommand_fixed cmd) {\n    automotiveLog_fixed(\"Attempting to execute sensor processing step (fixed).\");\n\n    if (cmd.channel_id_fixed >= SENSOR_CHANNEL_COUNT_FIXED) {\n        automotiveLog_fixed(\"Error: Invalid sensor channel ID received.\");\n        return;\n    }\n\n    ProcessingPipeline_fixed* pipeline = &g_sensorPipelines_fixed[cmd.channel_id_fixed];\n\n    if (cmd.step_index_fixed < pipeline->num_active_steps_fixed) {\n        SensorProcessor_fixed processor_func = pipeline->steps_fixed[cmd.step_index_fixed];\n        \n        float result = processor_func(cmd.input_value_fixed);\n        (void)result;\n        automotiveLog_fixed(\"Sensor processing step executed.\");\n    } else {\n        automotiveLog_fixed(\"Error: Requested step index out of bounds for the specific sensor channel's pipeline.\");\n    }\n}\n\nvoid automotiveSensorProcessingUnit_fixed_main() {\n    initializeSensorPipelines_fixed();\n    SensorProcessCommand_fixed command = receiveSensorProcessCommand_fixed();\n    executeSensorProcessingStep_fixed(command);\n    automotiveLog_fixed(\"Fixed sensor processing unit finished.\");\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_MODES 4\n\ntypedef enum {\n    MODE_ECO = 0,\n    MODE_SPORT,\n    MODE_COMFORT,\n    MODE_OFFROAD,\n    MODE_COUNT\n} VehicleOperatingMode;\n\ntypedef struct {\n    uint16_t engine_power_limit_kW;\n    uint16_t battery_discharge_rate_A;\n    uint8_t throttle_response_curve_idx;\n    bool enable_regenerative_braking;\n} PowerManagementProfile;\n\nstatic PowerManagementProfile g_powerProfiles[MAX_VEHICLE_MODES];\n\nvoid logSystemStatus(const char* message) {\n}\n\ntypedef struct {\n    uint8_t command_type;\n    uint8_t requested_mode_id;\n    uint8_t reserved[6];\n} VehicleModeCommand;\n\nVehicleModeCommand receiveVehicleModeCommand_vulnerable() {\n    VehicleModeCommand cmd;\n    cmd.command_type = 0x01;\n    cmd.requested_mode_id = 5;\n    return cmd;\n}\n\nvoid initializePowerProfiles_vulnerable() {\n    g_powerProfiles[MODE_ECO] = (PowerManagementProfile){80, 50, 1, true};\n    g_powerProfiles[MODE_SPORT] = (PowerManagementProfile){150, 100, 3, true};\n    g_powerProfiles[MODE_COMFORT] = (PowerManagementProfile){100, 70, 2, true};\n    g_powerProfiles[MODE_OFFROAD] = (PowerManagementProfile){120, 80, 2, false};\n    logSystemStatus(\"Power profiles initialized (vulnerable).\");\n}\n\nvoid activateVehicleMode_vulnerable() {\n    VehicleModeCommand cmd = receiveVehicleModeCommand_vulnerable();\n\n    if (cmd.command_type == 0x01) {\n        PowerManagementProfile selectedProfile = g_powerProfiles[cmd.requested_mode_id];\n\n        logSystemStatus(\"Applying selected power profile (vulnerable).\");\n        if (selectedProfile.enable_regenerative_braking) {\n        } else {\n        }\n    } else {\n        logSystemStatus(\"Invalid command type received (vulnerable).\");\n    }\n}\n\nvoid vehicleEMU_vulnerable_main() {\n    initializePowerProfiles_vulnerable();\n    activateVehicleMode_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_MODES 4\n\ntypedef enum {\n    MODE_ECO = 0,\n    MODE_SPORT,\n    MODE_COMFORT,\n    MODE_OFFROAD,\n    MODE_COUNT\n} VehicleOperatingMode;\n\ntypedef struct {\n    uint16_t engine_power_limit_kW;\n    uint16_t battery_discharge_rate_A;\n    uint8_t throttle_response_curve_idx;\n    bool enable_regenerative_braking;\n} PowerManagementProfile;\n\nstatic PowerManagementProfile g_powerProfiles_fixed[MAX_VEHICLE_MODES];\n\nvoid logSystemStatus_fixed(const char* message) {\n}\n\ntypedef struct {\n    uint8_t command_type;\n    uint8_t requested_mode_id;\n    uint8_t reserved[6];\n} VehicleModeCommand;\n\nVehicleModeCommand receiveVehicleModeCommand_fixed() {\n    VehicleModeCommand cmd;\n    cmd.command_type = 0x01;\n    cmd.requested_mode_id = 5;\n    return cmd;\n}\n\nvoid initializePowerProfiles_fixed() {\n    g_powerProfiles_fixed[MODE_ECO] = (PowerManagementProfile){80, 50, 1, true};\n    g_powerProfiles_fixed[MODE_SPORT] = (PowerManagementProfile){150, 100, 3, true};\n    g_powerProfiles_fixed[MODE_COMFORT] = (PowerManagementProfile){100, 70, 2, true};\n    g_powerProfiles_fixed[MODE_OFFROAD] = (PowerManagementProfile){120, 80, 2, false};\n    logSystemStatus_fixed(\"Power profiles initialized (fixed).\");\n}\n\nvoid activateVehicleMode_fixed() {\n    VehicleModeCommand cmd = receiveVehicleModeCommand_fixed();\n\n    if (cmd.command_type == 0x01) {\n        if (cmd.requested_mode_id < MAX_VEHICLE_MODES) {\n            PowerManagementProfile selectedProfile = g_powerProfiles_fixed[cmd.requested_mode_id];\n\n            logSystemStatus_fixed(\"Applying selected power profile (fixed).\");\n            if (selectedProfile.enable_regenerative_braking) {\n            } else {\n            }\n        } else {\n            logSystemStatus_fixed(\"Received requested mode ID out of bounds. Command ignored (fixed).\");\n        }\n    } else {\n        logSystemStatus_fixed(\"Invalid command type received (fixed).\");\n    }\n}\n\nvoid vehicleEMU_fixed_main() {\n    initializePowerProfiles_fixed();\n    activateVehicleMode_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_CAN_MESSAGE_HANDLERS 10\n#define NUM_INITIALIZED_HANDLERS 5\n\ntypedef struct {\n    uint16_t id;\n    uint8_t data[8];\n    uint8_t length;\n} CanFrame;\n\ntypedef void (*CanMessageHandler)(uint16_t message_id, const uint8_t* data, uint8_t length);\n\ntypedef struct {\n    CanMessageHandler func;\n    bool is_active;\n} HandlerEntry;\n\nstatic HandlerEntry g_canMessageDispatchTable[MAX_CAN_MESSAGE_HANDLERS];\n\nvoid logCanEvent(const char* msg) {\n    printf(\"CAN_LOG: %s\\n\", msg);\n}\n\nvoid logCanError(const char* msg) {\n    printf(\"CAN_ERROR: %s\\n\", msg);\n}\n\nvoid handleEngineData(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Engine data processed.\");\n}\n\nvoid handleBrakeStatus(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Brake status processed.\");\n}\n\nvoid handleSteeringAngle(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Steering angle processed.\");\n}\n\nvoid handleVehicleSpeed(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Vehicle speed processed.\");\n}\n\nvoid handleDoorLockStatus(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Door lock status processed.\");\n}\n\nvoid handleCriticalSystemReset(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanError(\"SECURITY ALERT: Critical system reset attempted via CAN message!\");\n}\n\nvoid initializeCanDispatchTable_vulnerable() {\n    g_canMessageDispatchTable[0].func = handleEngineData;\n    g_canMessageDispatchTable[0].is_active = true;\n\n    g_canMessageDispatchTable[1].func = handleBrakeStatus;\n    g_canMessageDispatchTable[1].is_active = true;\n\n    g_canMessageDispatchTable[2].func = handleSteeringAngle;\n    g_canMessageDispatchTable[2].is_active = true;\n\n    g_canMessageDispatchTable[3].func = handleVehicleSpeed;\n    g_canMessageDispatchTable[3].is_active = true;\n\n    g_canMessageDispatchTable[4].func = handleDoorLockStatus;\n    g_canMessageDispatchTable[4].is_active = true;\n\n    g_canMessageDispatchTable[7].func = handleCriticalSystemReset;\n    g_canMessageDispatchTable[7].is_active = false;\n\n    for (int i = NUM_INITIALIZED_HANDLERS; i < MAX_CAN_MESSAGE_HANDLERS; ++i) {\n        if (i != 7) {\n             g_canMessageDispatchTable[i].func = NULL;\n             g_canMessageDispatchTable[i].is_active = false;\n        }\n    }\n    logCanEvent(\"CAN message dispatch table initialized (vulnerable).\");\n}\n\nCanFrame receiveSimulatedCanFrame_vulnerable() {\n    CanFrame frame;\n    frame.id = 7;\n    frame.data[0] = 0xDE;\n    frame.data[1] = 0xAD;\n    frame.length = 2;\n    logCanEvent(\"Simulated CAN frame received for ID 7.\");\n    return frame;\n}\n\nvoid processCanFrame_vulnerable() {\n    CanFrame frame = receiveSimulatedCanFrame_vulnerable();\n\n    if (frame.id < MAX_CAN_MESSAGE_HANDLERS) {\n        CanMessageHandler handler = g_canMessageDispatchTable[frame.id].func;\n        if (handler != NULL) {\n            handler(frame.id, frame.data, frame.length);\n        } else {\n            logCanError(\"Received CAN message for unhandled ID (NULL handler).\");\n        }\n    } else {\n        logCanError(\"Received CAN message with out-of-bounds ID.\");\n    }\n}\n\nvoid canBusManager_vulnerable_main() {\n    initializeCanDispatchTable_vulnerable();\n    processCanFrame_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_CAN_MESSAGE_HANDLERS 10\n#define NUM_INITIALIZED_HANDLERS 5\n\ntypedef struct {\n    uint16_t id;\n    uint8_t data[8];\n    uint8_t length;\n} CanFrame;\n\ntypedef void (*CanMessageHandler)(uint16_t message_id, const uint8_t* data, uint8_t length);\n\ntypedef struct {\n    CanMessageHandler func;\n    bool is_active;\n} HandlerEntry;\n\nstatic HandlerEntry g_canMessageDispatchTable[MAX_CAN_MESSAGE_HANDLERS];\n\nvoid logCanEvent(const char* msg) {\n    printf(\"CAN_LOG: %s\\n\", msg);\n}\n\nvoid logCanError(const char* msg) {\n    printf(\"CAN_ERROR: %s\\n\", msg);\n}\n\nvoid handleEngineData(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Engine data processed.\");\n}\n\nvoid handleBrakeStatus(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Brake status processed.\");\n}\n\nvoid handleSteeringAngle(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Steering angle processed.\");\n}\n\nvoid handleVehicleSpeed(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Vehicle speed processed.\");\n}\n\nvoid handleDoorLockStatus(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanEvent(\"Door lock status processed.\");\n}\n\nvoid handleCriticalSystemReset(uint16_t message_id, const uint8_t* data, uint8_t length) {\n    logCanError(\"SECURITY ALERT: Critical system reset attempted via CAN message!\");\n}\n\nvoid initializeCanDispatchTable_fixed() {\n    g_canMessageDispatchTable[0].func = handleEngineData;\n    g_canMessageDispatchTable[0].is_active = true;\n\n    g_canMessageDispatchTable[1].func = handleBrakeStatus;\n    g_canMessageDispatchTable[1].is_active = true;\n\n    g_canMessageDispatchTable[2].func = handleSteeringAngle;\n    g_canMessageDispatchTable[2].is_active = true;\n\n    g_canMessageDispatchTable[3].func = handleVehicleSpeed;\n    g_canMessageDispatchTable[3].is_active = true;\n\n    g_canMessageDispatchTable[4].func = handleDoorLockStatus;\n    g_canMessageDispatchTable[4].is_active = true;\n\n    g_canMessageDispatchTable[7].func = handleCriticalSystemReset;\n    g_canMessageDispatchTable[7].is_active = false;\n\n    for (int i = NUM_INITIALIZED_HANDLERS; i < MAX_CAN_MESSAGE_HANDLERS; ++i) {\n        if (i != 7) {\n            g_canMessageDispatchTable[i].func = NULL;\n            g_canMessageDispatchTable[i].is_active = false;\n        }\n    }\n    logCanEvent(\"CAN message dispatch table initialized (fixed).\");\n}\n\nCanFrame receiveSimulatedCanFrame_fixed() {\n    CanFrame frame;\n    frame.id = 7;\n    frame.data[0] = 0xDE;\n    frame.data[1] = 0xAD;\n    frame.length = 2;\n    logCanEvent(\"Simulated CAN frame received for ID 7.\");\n    return frame;\n}\n\nvoid processCanFrame_fixed() {\n    CanFrame frame = receiveSimulatedCanFrame_fixed();\n\n    if (frame.id < MAX_CAN_MESSAGE_HANDLERS && g_canMessageDispatchTable[frame.id].is_active) {\n        CanMessageHandler handler = g_canMessageDispatchTable[frame.id].func;\n        if (handler != NULL) {\n            handler(frame.id, frame.data, frame.length);\n        } else {\n            logCanError(\"Received CAN message for unhandled ID (NULL handler, despite being marked active).\");\n        }\n    } else {\n        logCanError(\"Received CAN message with invalid or inactive handler ID.\");\n    }\n}\n\nvoid canBusManager_fixed_main() {\n    initializeCanDispatchTable_fixed();\n    processCanFrame_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define NUM_SENSOR_TYPES        8       \n#define NUM_CALIB_SUBTYPES      4       \n#define TOTAL_CALIBRATION_ENTRIES (NUM_SENSOR_TYPES * NUM_CALIB_SUBTYPES)\n\ntypedef struct {\n    int16_t offset_value;\n    uint16_t gain_factor;\n    uint8_t crc_check;\n} SensorCalibrationData;\n\nstatic SensorCalibrationData g_sensorCalibrationTable[TOTAL_CALIBRATION_ENTRIES];\n\nvoid logSensorError(const char* msg) {\n}\n\nuint8_t receiveSensorConfigPacket_vulnerable() {\n    return 0x74;\n}\n\nvoid initializeCalibrationData_vulnerable() {\n    for (uint8_t i = 0; i < TOTAL_CALIBRATION_ENTRIES; ++i) {\n        g_sensorCalibrationTable[i].offset_value = (int16_t)(i * 10);\n        g_sensorCalibrationTable[i].gain_factor = (uint16_t)(1000 + i);\n        g_sensorCalibrationTable[i].crc_check = (uint8_t)(i % 255);\n    }\n    logSensorError(\"Sensor calibration data initialized.\");\n}\n\nvoid applySensorCalibration_vulnerable() {\n    uint8_t config_byte = receiveSensorConfigPacket_vulnerable();\n\n    uint8_t sensor_id = (config_byte >> 4) & 0x0F;\n\n    uint8_t calibration_subtype = config_byte & 0x0F;\n\n    if (sensor_id < NUM_SENSOR_TYPES) {\n        uint16_t array_index = (uint16_t)(sensor_id * NUM_CALIB_SUBTYPES) + calibration_subtype;\n        \n        SensorCalibrationData current_calib = g_sensorCalibrationTable[array_index];\n        logSensorError(\"Calibration applied from sensor config.\");\n    } else {\n        logSensorError(\"Invalid sensor ID in config packet.\");\n    }\n}\n\nvoid sensorManagementMain_vulnerable() {\n    initializeCalibrationData_vulnerable();\n    applySensorCalibration_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define NUM_SENSOR_TYPES_FIXED        8\n#define NUM_CALIB_SUBTYPES_FIXED      4\n#define TOTAL_CALIBRATION_ENTRIES_FIXED (NUM_SENSOR_TYPES_FIXED * NUM_CALIB_SUBTYPES_FIXED)\n\ntypedef struct {\n    int16_t offset_value;\n    uint16_t gain_factor;\n    uint8_t crc_check;\n} SensorCalibrationData_Fixed;\n\nstatic SensorCalibrationData_Fixed g_sensorCalibrationTable_fixed[TOTAL_CALIBRATION_ENTRIES_FIXED];\n\nvoid logSensorError_fixed(const char* msg) {\n}\n\nuint8_t receiveSensorConfigPacket_fixed() {\n    return 0x74;\n}\n\nvoid initializeCalibrationData_fixed() {\n    for (uint8_t i = 0; i < TOTAL_CALIBRATION_ENTRIES_FIXED; ++i) {\n        g_sensorCalibrationTable_fixed[i].offset_value = (int16_t)(i * 10);\n        g_sensorCalibrationTable_fixed[i].gain_factor = (uint16_t)(1000 + i);\n        g_sensorCalibrationTable_fixed[i].crc_check = (uint8_t)(i % 255);\n    }\n    logSensorError_fixed(\"Sensor calibration data initialized.\");\n}\n\nvoid applySensorCalibration_fixed() {\n    uint8_t config_byte = receiveSensorConfigPacket_fixed();\n\n    uint8_t sensor_id = (config_byte >> 4) & 0x0F;\n    uint8_t calibration_subtype = config_byte & 0x0F;\n\n    if (sensor_id < NUM_SENSOR_TYPES_FIXED) {\n        if (calibration_subtype < NUM_CALIB_SUBTYPES_FIXED) {\n            uint16_t array_index = (uint16_t)(sensor_id * NUM_CALIB_SUBTYPES_FIXED) + calibration_subtype;\n            \n            SensorCalibrationData_Fixed current_calib = g_sensorCalibrationTable_fixed[array_index];\n            logSensorError_fixed(\"Calibration applied from sensor config.\");\n        } else {\n            logSensorError_fixed(\"Invalid calibration subtype in config packet. Subtype out of range.\");\n        }\n    } else {\n        logSensorError_fixed(\"Invalid sensor ID in config packet.\");\n    }\n}\n\nvoid sensorManagementMain_fixed() {\n    initializeCalibrationData_fixed();\n    applySensorCalibration_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n#define SYSTEM_TYPE_ENGINE_VULNERABLE       0\n#define SYSTEM_TYPE_TRANSMISSION_VULNERABLE 1\n#define SYSTEM_TYPE_BRAKES_VULNERABLE       2\n#define MAX_SYSTEM_TYPES_VULNERABLE         3\n\n#define MAX_TESTS_ENGINE_SYS_VULNERABLE        5\n#define MAX_TESTS_TRANSMISSION_SYS_VULNERABLE  8\n#define MAX_TESTS_BRAKES_SYS_VULNERABLE        4\n\ntypedef void (*DiagnosticTestRoutine_Vulnerable)(uint32_t test_param);\n\nvoid diagnosticTestEngine1_vulnerable(uint32_t param) {}\nvoid diagnosticTestEngine2_vulnerable(uint32_t param) {}\nvoid diagnosticTestTrans1_vulnerable(uint32_t param) {}\nvoid diagnosticTestBrakes1_vulnerable(uint32_t param) {}\n\nstatic DiagnosticTestRoutine_Vulnerable g_engineTests_vulnerable[MAX_TESTS_ENGINE_SYS_VULNERABLE];\nstatic DiagnosticTestRoutine_Vulnerable g_transmissionTests_vulnerable[MAX_TESTS_TRANSMISSION_SYS_VULNERABLE];\nstatic DiagnosticTestRoutine_Vulnerable g_brakesTests_vulnerable[MAX_TESTS_BRAKES_SYS_VULNERABLE];\n\ntypedef struct {\n    DiagnosticTestRoutine_Vulnerable* tests_array;\n    uint8_t max_tests;\n} SystemTestInfo_Vulnerable;\n\nstatic SystemTestInfo_Vulnerable g_systemTestInfo_vulnerable[MAX_SYSTEM_TYPES_VULNERABLE];\n\nvoid logDiagnosticSystemError_vulnerable(const char* msg) {}\n\ntypedef struct {\n    uint8_t system_type;\n    uint8_t test_id;\n    uint32_t test_parameter;\n} DiagnosticCommand_Vulnerable;\n\nDiagnosticCommand_Vulnerable receiveDiagnosticCommand_vulnerable() {\n    DiagnosticCommand_Vulnerable cmd;\n    cmd.system_type = SYSTEM_TYPE_BRAKES_VULNERABLE;\n    cmd.test_id = MAX_TESTS_BRAKES_SYS_VULNERABLE;\n    cmd.test_parameter = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeDiagnosticSystem_vulnerable() {\n    g_engineTests_vulnerable[0] = diagnosticTestEngine1_vulnerable;\n    g_engineTests_vulnerable[1] = diagnosticTestEngine2_vulnerable;\n\n    g_transmissionTests_vulnerable[0] = diagnosticTestTrans1_vulnerable;\n\n    g_brakesTests_vulnerable[0] = diagnosticTestBrakes1_vulnerable;\n\n    g_systemTestInfo_vulnerable[SYSTEM_TYPE_ENGINE_VULNERABLE].tests_array = g_engineTests_vulnerable;\n    g_systemTestInfo_vulnerable[SYSTEM_TYPE_ENGINE_VULNERABLE].max_tests = MAX_TESTS_ENGINE_SYS_VULNERABLE;\n\n    g_systemTestInfo_vulnerable[SYSTEM_TYPE_TRANSMISSION_VULNERABLE].tests_array = g_transmissionTests_vulnerable;\n    g_systemTestInfo_vulnerable[SYSTEM_TYPE_TRANSMISSION_VULNERABLE].max_tests = MAX_TESTS_TRANSMISSION_SYS_VULNERABLE;\n\n    g_systemTestInfo_vulnerable[SYSTEM_TYPE_BRAKES_VULNERABLE].tests_array = g_brakesTests_vulnerable;\n    g_systemTestInfo_vulnerable[SYSTEM_TYPE_BRAKES_VULNERABLE].max_tests = MAX_TESTS_BRAKES_SYS_VULNERABLE;\n\n    logDiagnosticSystemError_vulnerable(\"Diagnostic system initialized.\");\n}\n\nvoid executeDiagnosticTest_vulnerable() {\n    DiagnosticCommand_Vulnerable cmd = receiveDiagnosticCommand_vulnerable();\n\n    if (cmd.system_type < MAX_SYSTEM_TYPES_VULNERABLE) {\n        SystemTestInfo_Vulnerable current_sys_info = g_systemTestInfo_vulnerable[cmd.system_type];\n\n        DiagnosticTestRoutine_Vulnerable routine = current_sys_info.tests_array[cmd.test_id];\n\n        if (routine != NULL) {\n            routine(cmd.test_parameter);\n            logDiagnosticSystemError_vulnerable(\"Diagnostic test executed (vulnerable).\");\n        } else {\n            logDiagnosticSystemError_vulnerable(\"Requested diagnostic test routine is NULL.\");\n        }\n    } else {\n        logDiagnosticSystemError_vulnerable(\"Invalid system type in diagnostic command.\");\n    }\n}\n\nvoid diagnosticModuleMain_vulnerable() {\n    initializeDiagnosticSystem_vulnerable();\n    executeDiagnosticTest_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n#define SYSTEM_TYPE_ENGINE_FIXED       0\n#define SYSTEM_TYPE_TRANSMISSION_FIXED 1\n#define SYSTEM_TYPE_BRAKES_FIXED       2\n#define MAX_SYSTEM_TYPES_FIXED         3\n\n#define MAX_TESTS_ENGINE_SYS_FIXED        5\n#define MAX_TESTS_TRANSMISSION_SYS_FIXED  8\n#define MAX_TESTS_BRAKES_SYS_FIXED        4\n\ntypedef void (*DiagnosticTestRoutine_Fixed)(uint32_t test_param);\n\nvoid diagnosticTestEngine1_fixed(uint32_t param) {}\nvoid diagnosticTestEngine2_fixed(uint32_t param) {}\nvoid diagnosticTestTrans1_fixed(uint32_t param) {}\nvoid diagnosticTestBrakes1_fixed(uint32_t param) {}\n\nstatic DiagnosticTestRoutine_Fixed g_engineTests_fixed[MAX_TESTS_ENGINE_SYS_FIXED];\nstatic DiagnosticTestRoutine_Fixed g_transmissionTests_fixed[MAX_TESTS_TRANSMISSION_SYS_FIXED];\nstatic DiagnosticTestRoutine_Fixed g_brakesTests_fixed[MAX_TESTS_BRAKES_SYS_FIXED];\n\ntypedef struct {\n    DiagnosticTestRoutine_Fixed* tests_array;\n    uint8_t max_tests;\n} SystemTestInfo_Fixed;\n\nstatic SystemTestInfo_Fixed g_systemTestInfo_fixed[MAX_SYSTEM_TYPES_FIXED];\n\nvoid logDiagnosticSystemError_fixed(const char* msg) {}\n\ntypedef struct {\n    uint8_t system_type;\n    uint8_t test_id;\n    uint32_t test_parameter;\n} DiagnosticCommand_Fixed;\n\nDiagnosticCommand_Fixed receiveDiagnosticCommand_fixed() {\n    DiagnosticCommand_Fixed cmd;\n    cmd.system_type = SYSTEM_TYPE_BRAKES_FIXED;\n    cmd.test_id = MAX_TESTS_BRAKES_SYS_FIXED;\n    cmd.test_parameter = 0xDEADBEEF;\n    return cmd;\n}\n\nvoid initializeDiagnosticSystem_fixed() {\n    g_engineTests_fixed[0] = diagnosticTestEngine1_fixed;\n    g_engineTests_fixed[1] = diagnosticTestEngine2_fixed;\n\n    g_transmissionTests_fixed[0] = diagnosticTestTrans1_fixed;\n\n    g_brakesTests_fixed[0] = diagnosticTestBrakes1_fixed;\n\n    g_systemTestInfo_fixed[SYSTEM_TYPE_ENGINE_FIXED].tests_array = g_engineTests_fixed;\n    g_systemTestInfo_fixed[SYSTEM_TYPE_ENGINE_FIXED].max_tests = MAX_TESTS_ENGINE_SYS_FIXED;\n\n    g_systemTestInfo_fixed[SYSTEM_TYPE_TRANSMISSION_FIXED].tests_array = g_transmissionTests_fixed;\n    g_systemTestInfo_fixed[SYSTEM_TYPE_TRANSMISSION_FIXED].max_tests = MAX_TESTS_TRANSMISSION_SYS_FIXED;\n\n    g_systemTestInfo_fixed[SYSTEM_TYPE_BRAKES_FIXED].tests_array = g_brakesTests_fixed;\n    g_systemTestInfo_fixed[SYSTEM_TYPE_BRAKES_FIXED].max_tests = MAX_TESTS_BRAKES_SYS_FIXED;\n\n    logDiagnosticSystemError_fixed(\"Diagnostic system initialized (fixed).\");\n}\n\nvoid executeDiagnosticTest_fixed() {\n    DiagnosticCommand_Fixed cmd = receiveDiagnosticCommand_fixed();\n\n    if (cmd.system_type < MAX_SYSTEM_TYPES_FIXED) {\n        SystemTestInfo_Fixed current_sys_info = g_systemTestInfo_fixed[cmd.system_type];\n\n        if (cmd.test_id < current_sys_info.max_tests) {\n            DiagnosticTestRoutine_Fixed routine = current_sys_info.tests_array[cmd.test_id];\n\n            if (routine != NULL) {\n                routine(cmd.test_parameter);\n                logDiagnosticSystemError_fixed(\"Diagnostic test executed (fixed).\");\n            } else {\n                logDiagnosticSystemError_fixed(\"Requested diagnostic test routine is NULL for valid index.\");\n            }\n        } else {\n            logDiagnosticSystemError_fixed(\"Requested test ID out of bounds for the selected system type (fixed).\");\n        }\n    } else {\n        logDiagnosticSystemError_fixed(\"Invalid system type in diagnostic command (fixed).\");\n    }\n}\n\nvoid diagnosticModuleMain_fixed() {\n    initializeDiagnosticSystem_fixed();\n    executeDiagnosticTest_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n\nvoid log_diag_vulnerable(const char* msg) {\n    printf(\"VULN LOG: %s\\n\", msg);\n}\n\n#define MAX_MESSAGE_BUFFER_SIZE_VULNERABLE 256\nstatic uint8_t g_messageBuffer_vulnerable[MAX_MESSAGE_BUFFER_SIZE_VULNERABLE];\nstatic uint16_t g_currentParseOffset_vulnerable = 0;\n\ntypedef struct {\n    uint8_t command_code;\n    int16_t param_length_bytes; \n    uint8_t data[10]; \n} IncomingDiagMessage_vulnerable;\n\nIncomingDiagMessage_vulnerable receiveDiagMessage_vulnerable() {\n    IncomingDiagMessage_vulnerable msg;\n    msg.command_code = 0x01;\n    msg.param_length_bytes = -10; \n    for (int i = 0; i < 10; ++i) {\n        msg.data[i] = (uint8_t)i;\n    }\n    return msg;\n}\n\nvoid initializeParser_vulnerable() {\n    g_currentParseOffset_vulnerable = 5; \n    for (int i = 0; i < MAX_MESSAGE_BUFFER_SIZE_VULNERABLE; ++i) {\n        g_messageBuffer_vulnerable[i] = (uint8_t)(i % 0xFF); \n    }\n    log_diag_vulnerable(\"Parser initialized (vulnerable).\");\n}\n\nvoid parseVariableLengthParameter_vulnerable(int16_t param_length_bytes) {\n    log_diag_vulnerable(\"Attempting to parse variable length parameter (vulnerable).\");\n\n    if (g_currentParseOffset_vulnerable + param_length_bytes < 0) {\n        log_diag_vulnerable(\"Error: Proposed offset would underflow. This check should not be passed.\");\n        return;\n    }\n\n    g_currentParseOffset_vulnerable += param_length_bytes; \n\n    if (g_currentParseOffset_vulnerable < MAX_MESSAGE_BUFFER_SIZE_VULNERABLE) {\n        log_diag_vulnerable(\"Offset updated. Attempting to read a byte at new position.\");\n        uint8_t val = g_messageBuffer_vulnerable[g_currentParseOffset_vulnerable]; \n        printf(\"VULN: Read byte: %02X at offset %u\\n\", val, g_currentParseOffset_vulnerable);\n    } else {\n        log_diag_vulnerable(\"Fatal: Parser offset became out of bounds after update. This path usually indicates a prior issue.\");\n    }\n}\n\nvoid diagParser_vulnerable_main() {\n    initializeParser_vulnerable();\n    IncomingDiagMessage_vulnerable msg = receiveDiagMessage_vulnerable();\n    parseVariableLengthParameter_vulnerable(msg.param_length_bytes);\n    log_diag_vulnerable(\"Vulnerable diagnostic parser finished.\");\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n\nvoid log_diag_fixed(const char* msg) {\n    printf(\"FIXED LOG: %s\\n\", msg);\n}\n\n#define MAX_MESSAGE_BUFFER_SIZE_FIXED 256\nstatic uint8_t g_messageBuffer_fixed[MAX_MESSAGE_BUFFER_SIZE_FIXED];\nstatic uint16_t g_currentParseOffset_fixed = 0;\n\ntypedef struct {\n    uint8_t command_code;\n    int16_t param_length_bytes; \n    uint8_t data[10]; \n} IncomingDiagMessage_fixed;\n\nIncomingDiagMessage_fixed receiveDiagMessage_fixed() {\n    IncomingDiagMessage_fixed msg;\n    msg.command_code = 0x01;\n    msg.param_length_bytes = -10; \n    for (int i = 0; i < 10; ++i) {\n        msg.data[i] = (uint8_t)i;\n    }\n    return msg;\n}\n\nvoid initializeParser_fixed() {\n    g_currentParseOffset_fixed = 5; \n    for (int i = 0; i < MAX_MESSAGE_BUFFER_SIZE_FIXED; ++i) {\n        g_messageBuffer_fixed[i] = (uint8_t)(i % 0xFF); \n    }\n    log_diag_fixed(\"Parser initialized (fixed).\");\n}\n\nvoid parseVariableLengthParameter_fixed(int16_t param_length_bytes) {\n    log_diag_fixed(\"Attempting to parse variable length parameter (fixed).\");\n\n    if (param_length_bytes < 0) {\n        log_diag_fixed(\"Error: Negative parameter length received. Aborting parse step.\");\n        return;\n    }\n\n    uint16_t proposed_new_offset = g_currentParseOffset_fixed + (uint16_t)param_length_bytes; \n\n    if (proposed_new_offset > MAX_MESSAGE_BUFFER_SIZE_FIXED) {\n        log_diag_fixed(\"Error: Parameter length would cause buffer overflow. Aborting parse step.\");\n        return;\n    }\n\n    g_currentParseOffset_fixed = proposed_new_offset; \n\n    if (g_currentParseOffset_fixed < MAX_MESSAGE_BUFFER_SIZE_FIXED) {\n        log_diag_fixed(\"Offset updated. Attempting to read a byte at new position.\");\n        uint8_t val = g_messageBuffer_fixed[g_currentParseOffset_fixed]; \n        printf(\"FIXED: Read byte: %02X at offset %u\\n\", val, g_currentParseOffset_fixed);\n    } else {\n        log_diag_fixed(\"Assertion failed: Parser offset became out of bounds after update. This should not happen with proper checks.\");\n    }\n}\n\nvoid diagParser_fixed_main() {\n    initializeParser_fixed();\n    IncomingDiagMessage_fixed msg = receiveDiagMessage_fixed();\n    parseVariableLengthParameter_fixed(msg.param_length_bytes);\n    log_diag_fixed(\"Fixed diagnostic parser finished.\");\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_MODES 3\n#define MAX_PARAMS_PER_MODE 10\n\ntypedef enum {\n    MODE_ECO = 0,\n    MODE_SPORT,\n    MODE_OFFROAD,\n    MODE_COUNT\n} VehicleMode;\n\ntypedef struct {\n    uint16_t id;\n    uint16_t value;\n    bool configurable;\n} VehicleParameter;\n\nstatic VehicleParameter g_vehicleModeParameters[MAX_VEHICLE_MODES][MAX_PARAMS_PER_MODE];\n\nstatic uint8_t g_activeParamCounts[MAX_VEHICLE_MODES];\n\nvoid vehicle_log_vulnerable(const char* msg) {\n    fprintf(stderr, \"VULN_LOG: %s\\n\", msg);\n}\n\nvoid initializeVehicleParameters_vulnerable() {\n    for (uint8_t i = 0; i < MAX_VEHICLE_MODES; ++i) {\n        for (uint8_t j = 0; j < MAX_PARAMS_PER_MODE; ++j) {\n            g_vehicleModeParameters[i][j] = (VehicleParameter){0, 0, false};\n        }\n        g_activeParamCounts[i] = 0; \n    }\n\n    g_vehicleModeParameters[MODE_ECO][0] = (VehicleParameter){0x0001, 100, true};\n    g_vehicleModeParameters[MODE_ECO][1] = (VehicleParameter){0x0002, 50, true};\n    g_vehicleModeParameters[MODE_ECO][2] = (VehicleParameter){0x0003, 1, false};\n    g_activeParamCounts[MODE_ECO] = 3;\n\n    g_vehicleModeParameters[MODE_SPORT][0] = (VehicleParameter){0x0001, 250, true};\n    g_vehicleModeParameters[MODE_SPORT][1] = (VehicleParameter){0x0002, 90, true};\n    g_vehicleModeParameters[MODE_SPORT][2] = (VehicleParameter){0x0003, 0, false};\n    g_vehicleModeParameters[MODE_SPORT][3] = (VehicleParameter){0x0004, 1, true};\n    g_activeParamCounts[MODE_SPORT] = 4;\n\n    g_vehicleModeParameters[MODE_OFFROAD][0] = (VehicleParameter){0x0001, 80, true};\n    g_vehicleModeParameters[MODE_OFFROAD][1] = (VehicleParameter){0x0002, 70, true};\n    g_vehicleModeParameters[MODE_OFFROAD][2] = (VehicleParameter){0x0005, 1, true};\n    g_activeParamCounts[MODE_OFFROAD] = 3;\n\n    vehicle_log_vulnerable(\"Vehicle parameter system initialized (vulnerable).\");\n}\n\ntypedef struct {\n    uint8_t mode;\n    uint8_t param_idx;\n    uint16_t new_val;\n} RemoteUpdateCommand_Vulnerable;\n\nRemoteUpdateCommand_Vulnerable getRemoteUpdateCommand_vulnerable() {\n    RemoteUpdateCommand_Vulnerable cmd;\n    cmd.mode = MODE_ECO;\n    cmd.param_idx = 5; \n    cmd.new_val = 0xDEAD;\n    return cmd;\n}\n\nvoid processRemoteParameterUpdate_vulnerable() {\n    RemoteUpdateCommand_Vulnerable cmd = getRemoteUpdateCommand_vulnerable();\n\n    if (cmd.mode < MODE_COUNT) {\n        if (cmd.param_idx < MAX_PARAMS_PER_MODE) {\n            if (g_vehicleModeParameters[cmd.mode][cmd.param_idx].configurable) {\n                g_vehicleModeParameters[cmd.mode][cmd.param_idx].value = cmd.new_val;\n                vehicle_log_vulnerable(\"Vehicle parameter updated successfully (vulnerable).\");\n            } else {\n                vehicle_log_vulnerable(\"Attempted to update non-configurable parameter (vulnerable).\");\n            }\n        } else {\n            vehicle_log_vulnerable(\"Parameter index out of global array bounds (vulnerable).\");\n        }\n    } else {\n        vehicle_log_vulnerable(\"Invalid vehicle mode ID (vulnerable).\");\n    }\n}\n\nvoid main_vulnerable_system() {\n    initializeVehicleParameters_vulnerable();\n    processRemoteParameterUpdate_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_VEHICLE_MODES 3\n#define MAX_PARAMS_PER_MODE 10\n\ntypedef enum {\n    MODE_ECO_FIXED = 0,\n    MODE_SPORT_FIXED,\n    MODE_OFFROAD_FIXED,\n    MODE_COUNT_FIXED\n} VehicleMode_Fixed;\n\ntypedef struct {\n    uint16_t id;\n    uint16_t value;\n    bool configurable;\n} VehicleParameter_Fixed;\n\nstatic VehicleParameter_Fixed g_vehicleModeParameters_fixed[MAX_VEHICLE_MODES][MAX_PARAMS_PER_MODE];\n\nstatic uint8_t g_activeParamCounts_fixed[MAX_VEHICLE_MODES];\n\nvoid vehicle_log_fixed(const char* msg) {\n    fprintf(stderr, \"FIXED_LOG: %s\\n\", msg);\n}\n\nvoid initializeVehicleParameters_fixed() {\n    for (uint8_t i = 0; i < MAX_VEHICLE_MODES; ++i) {\n        for (uint8_t j = 0; j < MAX_PARAMS_PER_MODE; ++j) {\n            g_vehicleModeParameters_fixed[i][j] = (VehicleParameter_Fixed){0, 0, false};\n        }\n        g_activeParamCounts_fixed[i] = 0;\n    }\n\n    g_vehicleModeParameters_fixed[MODE_ECO_FIXED][0] = (VehicleParameter_Fixed){0x0001, 100, true};\n    g_vehicleModeParameters_fixed[MODE_ECO_FIXED][1] = (VehicleParameter_Fixed){0x0002, 50, true};\n    g_vehicleModeParameters_fixed[MODE_ECO_FIXED][2] = (VehicleParameter_Fixed){0x0003, 1, false};\n    g_activeParamCounts_fixed[MODE_ECO_FIXED] = 3;\n\n    g_vehicleModeParameters_fixed[MODE_SPORT_FIXED][0] = (VehicleParameter_Fixed){0x0001, 250, true};\n    g_vehicleModeParameters_fixed[MODE_SPORT_FIXED][1] = (VehicleParameter_Fixed){0x0002, 90, true};\n    g_vehicleModeParameters_fixed[MODE_SPORT_FIXED][2] = (VehicleParameter_Fixed){0x0003, 0, false};\n    g_vehicleModeParameters_fixed[MODE_SPORT_FIXED][3] = (VehicleParameter_Fixed){0x0004, 1, true};\n    g_activeParamCounts_fixed[MODE_SPORT_FIXED] = 4;\n\n    g_vehicleModeParameters_fixed[MODE_OFFROAD_FIXED][0] = (VehicleParameter_Fixed){0x0001, 80, true};\n    g_vehicleModeParameters_fixed[MODE_OFFROAD_FIXED][1] = (VehicleParameter_Fixed){0x0002, 70, true};\n    g_vehicleModeParameters_fixed[MODE_OFFROAD_FIXED][2] = (VehicleParameter_Fixed){0x0005, 1, true};\n    g_activeParamCounts_fixed[MODE_OFFROAD_FIXED] = 3;\n\n    vehicle_log_fixed(\"Vehicle parameter system initialized (fixed).\");\n}\n\ntypedef struct {\n    uint8_t mode;\n    uint8_t param_idx;\n    uint16_t new_val;\n} RemoteUpdateCommand_Fixed;\n\nRemoteUpdateCommand_Fixed getRemoteUpdateCommand_fixed() {\n    RemoteUpdateCommand_Fixed cmd;\n    cmd.mode = MODE_ECO_FIXED;\n    cmd.param_idx = 5;\n    cmd.new_val = 0xDEAD;\n    return cmd;\n}\n\nvoid processRemoteParameterUpdate_fixed() {\n    RemoteUpdateCommand_Fixed cmd = getRemoteUpdateCommand_fixed();\n\n    if (cmd.mode < MODE_COUNT_FIXED) {\n        if (cmd.param_idx < g_activeParamCounts_fixed[cmd.mode]) {\n            if (g_vehicleModeParameters_fixed[cmd.mode][cmd.param_idx].configurable) {\n                g_vehicleModeParameters_fixed[cmd.mode][cmd.param_idx].value = cmd.new_val;\n                vehicle_log_fixed(\"Vehicle parameter updated successfully (fixed).\");\n            } else {\n                vehicle_log_fixed(\"Attempted to update non-configurable parameter (fixed).\");\n            }\n        } else {\n            vehicle_log_fixed(\"Parameter index out of active parameters bounds for this mode (fixed).\");\n        }\n    } else {\n        vehicle_log_fixed(\"Invalid vehicle mode ID (fixed).\");\n    }\n}\n\nvoid main_fixed_system() {\n    initializeVehicleParameters_fixed();\n    processRemoteParameterUpdate_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#define MAX_MODES 3\n#define MAX_NORMAL_PARAMS 5\n#define MAX_SPORT_PARAMS 7\n#define MAX_ECO_PARAMS 4\n\ntypedef union {\n    uint16_t u16_val;\n    int16_t  s16_val;\n    float    f_val;\n} ParameterValue_Vulnerable;\n\ntypedef struct {\n    uint8_t      param_type;\n    ParameterValue_Vulnerable value;\n    uint16_t     min_limit;\n    uint16_t     max_limit;\n} ModeParameter_Vulnerable;\n\nstatic ModeParameter_Vulnerable g_normalModeParams_vulnerable[MAX_NORMAL_PARAMS];\nstatic ModeParameter_Vulnerable g_sportModeParams_vulnerable[MAX_SPORT_PARAMS];\nstatic ModeParameter_Vulnerable g_ecoModeParams_vulnerable[MAX_ECO_PARAMS];\n\ntypedef struct {\n    ModeParameter_Vulnerable* params_ptr;\n    uint8_t        max_params_count;\n} ModeConfigTableEntry_Vulnerable;\n\nstatic ModeConfigTableEntry_Vulnerable g_modeConfigs_vulnerable[MAX_MODES];\n\nstatic uint8_t g_currentVehicleMode_vulnerable; \n\nvoid vehicleDebugLog_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t  mode_id;\n    uint8_t  parameter_idx;\n    uint16_t new_uint_value;\n} ParameterAdjustmentCommand_Vulnerable;\n\nParameterAdjustmentCommand_Vulnerable receiveAdjustmentCommand_vulnerable() {\n    ParameterAdjustmentCommand_Vulnerable cmd;\n    cmd.mode_id = 0;\n    cmd.parameter_idx = 5;\n    cmd.new_uint_value = 1234;\n    return cmd;\n}\n\nvoid initializeVehicleModes_vulnerable() {\n    g_modeConfigs_vulnerable[0] = (ModeConfigTableEntry_Vulnerable){g_normalModeParams_vulnerable, MAX_NORMAL_PARAMS};\n    g_modeConfigs_vulnerable[1] = (ModeConfigTableEntry_Vulnerable){g_sportModeParams_vulnerable, MAX_SPORT_PARAMS};\n    g_modeConfigs_vulnerable[2] = (ModeConfigTableEntry_Vulnerable){g_ecoModeParams_vulnerable, MAX_ECO_PARAMS};\n\n    for (uint8_t i = 0; i < MAX_NORMAL_PARAMS; ++i) g_normalModeParams_vulnerable[i].value.u16_val = 100 + i;\n    for (uint8_t i = 0; i < MAX_SPORT_PARAMS; ++i) g_sportModeParams_vulnerable[i].value.u16_val = 200 + i;\n    for (uint8_t i = 0; i < MAX_ECO_PARAMS; ++i) g_ecoModeParams_vulnerable[i].value.u16_val = 300 + i;\n\n    g_currentVehicleMode_vulnerable = 0;\n    vehicleDebugLog_vulnerable(\"Vehicle modes initialized.\");\n}\n\nvoid adjustVehicleParameter_vulnerable() {\n    ParameterAdjustmentCommand_Vulnerable cmd = receiveAdjustmentCommand_vulnerable();\n\n    if (g_currentVehicleMode_vulnerable < MAX_MODES) {\n        ModeParameter_Vulnerable* active_params = g_modeConfigs_vulnerable[g_currentVehicleMode_vulnerable].params_ptr;\n        active_params[cmd.parameter_idx].value.u16_val = cmd.new_uint_value;\n        vehicleDebugLog_vulnerable(\"Vehicle parameter adjusted.\");\n    } else {\n        vehicleDebugLog_vulnerable(\"Invalid vehicle mode specified for adjustment.\");\n    }\n}\n\nvoid vehicleControlMain_vulnerable() {\n    initializeVehicleModes_vulnerable();\n    adjustVehicleParameter_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#define MAX_MODES 3\n#define MAX_NORMAL_PARAMS 5\n#define MAX_SPORT_PARAMS 7\n#define MAX_ECO_PARAMS 4\n\ntypedef union {\n    uint16_t u16_val;\n    int16_t  s16_val;\n    float    f_val;\n} ParameterValue_Fixed;\n\ntypedef struct {\n    uint8_t      param_type;\n    ParameterValue_Fixed value;\n    uint16_t     min_limit;\n    uint16_t     max_limit;\n} ModeParameter_Fixed;\n\nstatic ModeParameter_Fixed g_normalModeParams_fixed[MAX_NORMAL_PARAMS];\nstatic ModeParameter_Fixed g_sportModeParams_fixed[MAX_SPORT_PARAMS];\nstatic ModeParameter_Fixed g_ecoModeParams_fixed[MAX_ECO_PARAMS];\n\ntypedef struct {\n    ModeParameter_Fixed* params_ptr;\n    uint8_t        max_params_count;\n} ModeConfigTableEntry_Fixed;\n\nstatic ModeConfigTableEntry_Fixed g_modeConfigs_fixed[MAX_MODES];\n\nstatic uint8_t g_currentVehicleMode_fixed; \n\nvoid vehicleDebugLog_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t  mode_id;\n    uint8_t  parameter_idx;\n    uint16_t new_uint_value;\n} ParameterAdjustmentCommand_Fixed;\n\nParameterAdjustmentCommand_Fixed receiveAdjustmentCommand_fixed() {\n    ParameterAdjustmentCommand_Fixed cmd;\n    cmd.mode_id = 0;\n    cmd.parameter_idx = 5;\n    cmd.new_uint_value = 1234;\n    return cmd;\n}\n\nvoid initializeVehicleModes_fixed() {\n    g_modeConfigs_fixed[0] = (ModeConfigTableEntry_Fixed){g_normalModeParams_fixed, MAX_NORMAL_PARAMS};\n    g_modeConfigs_fixed[1] = (ModeConfigTableEntry_Fixed){g_sportModeParams_fixed, MAX_SPORT_PARAMS};\n    g_modeConfigs_fixed[2] = (ModeConfigTableEntry_Fixed){g_ecoModeParams_fixed, MAX_ECO_PARAMS};\n\n    for (uint8_t i = 0; i < MAX_NORMAL_PARAMS; ++i) g_normalModeParams_fixed[i].value.u16_val = 100 + i;\n    for (uint8_t i = 0; i < MAX_SPORT_PARAMS; ++i) g_sportModeParams_fixed[i].value.u16_val = 200 + i;\n    for (uint8_t i = 0; i < MAX_ECO_PARAMS; ++i) g_ecoModeParams_fixed[i].value.u16_val = 300 + i;\n\n    g_currentVehicleMode_fixed = 0;\n    vehicleDebugLog_fixed(\"Vehicle modes initialized.\");\n}\n\nvoid adjustVehicleParameter_fixed() {\n    ParameterAdjustmentCommand_Fixed cmd = receiveAdjustmentCommand_fixed();\n\n    if (g_currentVehicleMode_fixed < MAX_MODES) {\n        ModeConfigTableEntry_Fixed mode_entry = g_modeConfigs_fixed[g_currentVehicleMode_fixed];\n        \n        if (cmd.parameter_idx < mode_entry.max_params_count) {\n            ModeParameter_Fixed* active_params = mode_entry.params_ptr;\n            active_params[cmd.parameter_idx].value.u16_val = cmd.new_uint_value;\n            vehicleDebugLog_fixed(\"Vehicle parameter adjusted.\");\n        } else {\n            vehicleDebugLog_fixed(\"Parameter index out of bounds for current vehicle mode.\");\n        }\n    } else {\n        vehicleDebugLog_fixed(\"Invalid current vehicle mode for adjustment.\");\n    }\n}\n\nvoid vehicleControlMain_fixed() {\n    initializeVehicleModes_fixed();\n    adjustVehicleParameter_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_TOTAL_PARAMETERS 100\n#define MAX_SUBSYSTEMS 3 \n\ntypedef uint16_t VehicleParameterValue_Vulnerable;\n\nstatic VehicleParameterValue_Vulnerable g_allVehicleParameters_vulnerable[MAX_TOTAL_PARAMETERS];\n\nstatic uint8_t g_subsystemParameterOffsets_vulnerable[MAX_SUBSYSTEMS]; \nstatic uint8_t g_subsystemParameterCounts_vulnerable[MAX_SUBSYSTEMS];   \n\nvoid logVehicleStatus_vulnerable(const char* msg) {\n    printf(\"STATUS VULN: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t subsystem_id;\n    uint8_t parameter_index;\n} StatusRequest_Vulnerable;\n\nStatusRequest_Vulnerable receiveStatusRequest_vulnerable() {\n    StatusRequest_Vulnerable req;\n    req.subsystem_id = 3; \n    req.parameter_index = 0; \n    return req;\n}\n\nvoid initializeVehicleParameters_vulnerable() {\n    for (int i = 0; i < MAX_TOTAL_PARAMETERS; ++i) {\n        g_allVehicleParameters_vulnerable[i] = (uint16_t)(i * 10);\n    }\n\n    g_subsystemParameterOffsets_vulnerable[0] = 0;  \n    g_subsystemParameterCounts_vulnerable[0] = 20;  \n\n    g_subsystemParameterOffsets_vulnerable[1] = 20; \n    g_subsystemParameterCounts_vulnerable[1] = 15;  \n\n    g_subsystemParameterOffsets_vulnerable[2] = 35; \n    g_subsystemParameterCounts_vulnerable[2] = 10;  \n\n    logVehicleStatus_vulnerable(\"Vehicle parameters initialized.\");\n}\n\nuint16_t getVehicleParameter_vulnerable(uint8_t subsystem_id, uint8_t param_idx) {\n    logVehicleStatus_vulnerable(\"Attempting to get vehicle parameter.\");\n\n    uint8_t base_offset = g_subsystemParameterOffsets_vulnerable[subsystem_id]; \n    uint8_t param_count = g_subsystemParameterCounts_vulnerable[subsystem_id];   \n\n    if (param_idx < param_count) {\n        uint16_t value = g_allVehicleParameters_vulnerable[base_offset + param_idx];\n        printf(\"STATUS VULN: Read parameter [subsystem=%u, index=%u]: %u\\n\", subsystem_id, param_idx, value);\n        return value;\n    } else {\n        logVehicleStatus_vulnerable(\"Parameter index out of bounds for the specified subsystem (or corrupted).\");\n        return 0xFFFF;\n    }\n}\n\nvoid vehicleStatusModule_vulnerable_main() {\n    initializeVehicleParameters_vulnerable();\n    StatusRequest_Vulnerable req = receiveStatusRequest_vulnerable();\n    getVehicleParameter_vulnerable(req.subsystem_id, req.parameter_index);\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_TOTAL_PARAMETERS_FIXED 100\n#define MAX_SUBSYSTEMS_FIXED 3 \n\ntypedef uint16_t VehicleParameterValue_Fixed;\n\nstatic VehicleParameterValue_Fixed g_allVehicleParameters_fixed[MAX_TOTAL_PARAMETERS_FIXED];\n\nstatic uint8_t g_subsystemParameterOffsets_fixed[MAX_SUBSYSTEMS_FIXED];\nstatic uint8_t g_subsystemParameterCounts_fixed[MAX_SUBSYSTEMS_FIXED];\n\nvoid logVehicleStatus_fixed(const char* msg) {\n    printf(\"STATUS FIXED: %s\\n\", msg);\n}\n\ntypedef struct {\n    uint8_t subsystem_id;\n    uint8_t parameter_index;\n} StatusRequest_Fixed;\n\nStatusRequest_Fixed receiveStatusRequest_fixed() {\n    StatusRequest_Fixed req;\n    req.subsystem_id = 3; \n    req.parameter_index = 0; \n    return req;\n}\n\nvoid initializeVehicleParameters_fixed() {\n    for (int i = 0; i < MAX_TOTAL_PARAMETERS_FIXED; ++i) {\n        g_allVehicleParameters_fixed[i] = (uint16_t)(i * 100);\n    }\n\n    g_subsystemParameterOffsets_fixed[0] = 0;\n    g_subsystemParameterCounts_fixed[0] = 20;\n\n    g_subsystemParameterOffsets_fixed[1] = 20;\n    g_subsystemParameterCounts_fixed[1] = 15;\n\n    g_subsystemParameterOffsets_fixed[2] = 35;\n    g_subsystemParameterCounts_fixed[2] = 10;\n\n    logVehicleStatus_fixed(\"Vehicle parameters initialized.\");\n}\n\nuint16_t getVehicleParameter_fixed(uint8_t subsystem_id, uint8_t param_idx) {\n    logVehicleStatus_fixed(\"Attempting to get vehicle parameter.\");\n\n    if (subsystem_id >= MAX_SUBSYSTEMS_FIXED) {\n        logVehicleStatus_fixed(\"Error: Subsystem ID out of bounds. Request rejected.\");\n        return 0xFFFF;\n    }\n\n    uint8_t base_offset = g_subsystemParameterOffsets_fixed[subsystem_id];\n    uint8_t param_count = g_subsystemParameterCounts_fixed[subsystem_id];\n\n    if (param_idx < param_count) {\n        if (base_offset + param_idx < MAX_TOTAL_PARAMETERS_FIXED) {\n            uint16_t value = g_allVehicleParameters_fixed[base_offset + param_idx];\n            printf(\"STATUS FIXED: Read parameter [subsystem=%u, index=%u]: %u\\n\", subsystem_id, param_idx, value);\n            return value;\n        } else {\n            logVehicleStatus_fixed(\"Internal logic error: Calculated parameter index exceeds total capacity.\");\n            return 0xFFFF;\n        }\n    } else {\n        logVehicleStatus_fixed(\"Parameter index out of bounds for the specified subsystem.\");\n        return 0xFFFF;\n    }\n}\n\nvoid vehicleStatusModule_fixed_main() {\n    initializeVehicleParameters_fixed();\n    StatusRequest_Fixed req = receiveStatusRequest_fixed();\n    getVehicleParameter_fixed(req.subsystem_id, req.parameter_index);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_ROUTES 5\n#define MAX_WAYPOINTS_PER_ROUTE 100\n\ntypedef struct {\n    float latitude;\n    float longitude;\n    uint16_t altitude;\n} Waypoint;\n\ntypedef struct {\n    uint8_t route_id;\n    uint8_t current_waypoint_idx; \n    uint16_t total_waypoints;\n    Waypoint waypoints[MAX_WAYPOINTS_PER_ROUTE];\n} RouteData;\n\nstatic RouteData g_vehicleRoutes_vulnerable[MAX_ROUTES];\n\nvoid vehicleLog_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t route_idx;\n    int16_t offset_from_current;\n} WaypointQuery_Vulnerable;\n\nWaypointQuery_Vulnerable receiveWaypointQuery_vulnerable() {\n    WaypointQuery_Vulnerable query;\n    query.route_idx = 0; \n    query.offset_from_current = -1; \n    return query;\n}\n\nvoid initializeRoutes_vulnerable() {\n    for (uint8_t i = 0; i < MAX_ROUTES; ++i) {\n        g_vehicleRoutes_vulnerable[i].route_id = i;\n        g_vehicleRoutes_vulnerable[i].current_waypoint_idx = 0; \n        g_vehicleRoutes_vulnerable[i].total_waypoints = (i + 1) * 10; \n        if (g_vehicleRoutes_vulnerable[i].total_waypoints > MAX_WAYPOINTS_PER_ROUTE) {\n            g_vehicleRoutes_vulnerable[i].total_waypoints = MAX_WAYPOINTS_PER_ROUTE;\n        }\n        for (uint16_t j = 0; j < g_vehicleRoutes_vulnerable[i].total_waypoints; ++j) {\n            g_vehicleRoutes_vulnerable[i].waypoints[j] = (Waypoint){ (float)(10.0 + i + j), (float)(20.0 + i + j), (uint16_t)(100 + j) };\n        }\n    }\n    vehicleLog_vulnerable(\"Vehicle routes initialized (vulnerable).\");\n}\n\nvoid processWaypointQuery_vulnerable() {\n    WaypointQuery_Vulnerable query = receiveWaypointQuery_vulnerable();\n\n    if (query.route_idx < MAX_ROUTES) {\n        RouteData* current_route = &g_vehicleRoutes_vulnerable[query.route_idx];\n\n        uint16_t effective_index = current_route->current_waypoint_idx + query.offset_from_current;\n\n        if (effective_index < current_route->total_waypoints) {\n            Waypoint requested_waypoint = current_route->waypoints[effective_index];\n            vehicleLog_vulnerable(\"Waypoint data retrieved (vulnerable).\");\n        } else {\n            vehicleLog_vulnerable(\"Requested waypoint index out of logical bounds for route (positive check only).\");\n        }\n    } else {\n        vehicleLog_vulnerable(\"Invalid route index received (vulnerable).\");\n    }\n}\n\nvoid navigationSystemMain_vulnerable() {\n    initializeRoutes_vulnerable();\n    processWaypointQuery_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_ROUTES_FIXED 5\n#define MAX_WAYPOINTS_PER_ROUTE_FIXED 100\n\ntypedef struct {\n    float latitude;\n    float longitude;\n    uint16_t altitude;\n} Waypoint_Fixed;\n\ntypedef struct {\n    uint8_t route_id;\n    uint8_t current_waypoint_idx;\n    uint16_t total_waypoints;\n    Waypoint_Fixed waypoints[MAX_WAYPOINTS_PER_ROUTE_FIXED];\n} RouteData_Fixed;\n\nstatic RouteData_Fixed g_vehicleRoutes_fixed[MAX_ROUTES_FIXED];\n\nvoid vehicleLog_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t route_idx;\n    int16_t offset_from_current;\n} WaypointQuery_Fixed;\n\nWaypointQuery_Fixed receiveWaypointQuery_fixed() {\n    WaypointQuery_Fixed query;\n    query.route_idx = 0;\n    query.offset_from_current = -1;\n    return query;\n}\n\nvoid initializeRoutes_fixed() {\n    for (uint8_t i = 0; i < MAX_ROUTES_FIXED; ++i) {\n        g_vehicleRoutes_fixed[i].route_id = i;\n        g_vehicleRoutes_fixed[i].current_waypoint_idx = 0;\n        g_vehicleRoutes_fixed[i].total_waypoints = (i + 1) * 10;\n        if (g_vehicleRoutes_fixed[i].total_waypoints > MAX_WAYPOINTS_PER_ROUTE_FIXED) {\n            g_vehicleRoutes_fixed[i].total_waypoints = MAX_WAYPOINTS_PER_ROUTE_FIXED;\n        }\n        for (uint16_t j = 0; j < g_vehicleRoutes_fixed[i].total_waypoints; ++j) {\n            g_vehicleRoutes_fixed[i].waypoints[j] = (Waypoint_Fixed){ (float)(10.0 + i + j), (float)(20.0 + i + j), (uint16_t)(100 + j) };\n        }\n    }\n    vehicleLog_fixed(\"Vehicle routes initialized (fixed).\");\n}\n\nvoid processWaypointQuery_fixed() {\n    WaypointQuery_Fixed query = receiveWaypointQuery_fixed();\n\n    if (query.route_idx < MAX_ROUTES_FIXED) {\n        RouteData_Fixed* current_route = &g_vehicleRoutes_fixed[query.route_idx];\n\n        int32_t temp_effective_index = current_route->current_waypoint_idx + query.offset_from_current;\n\n        if (temp_effective_index >= 0 && temp_effective_index < current_route->total_waypoints) {\n            uint16_t effective_index = (uint16_t)temp_effective_index;\n            Waypoint_Fixed requested_waypoint = current_route->waypoints[effective_index];\n            vehicleLog_fixed(\"Waypoint data retrieved (fixed).\");\n        } else {\n            vehicleLog_fixed(\"Requested waypoint index out of bounds for route (fixed).\");\n        }\n    } else {\n        vehicleLog_fixed(\"Invalid route index received (fixed).\");\n    }\n}\n\nvoid navigationSystemMain_fixed() {\n    initializeRoutes_fixed();\n    processWaypointQuery_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_VEHICLE_PROFILES_VULNERABLE 10\n\ntypedef struct {\n    uint16_t engine_torque_factor;\n    uint16_t transmission_shift_aggressiveness;\n    uint8_t suspension_damping_level;\n    char profile_name[32];\n} DrivingProfile_Vulnerable;\n\nstatic DrivingProfile_Vulnerable g_allVehicleProfiles_Vulnerable[MAX_VEHICLE_PROFILES_VULNERABLE];\nstatic uint8_t g_configuredProfileCount_Vulnerable;\n\nvoid automotive_log_Vulnerable(const char* msg) {\n    (void)msg;\n}\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t requested_profile_id;\n    uint16_t checksum;\n} VehicleControlCommand_Vulnerable;\n\nVehicleControlCommand_Vulnerable receiveVehicleControlCommand_Vulnerable() {\n    VehicleControlCommand_Vulnerable cmd;\n    cmd.command_id = 0x01;\n    cmd.requested_profile_id = 6;\n    cmd.checksum = 0xAAAA;\n    automotive_log_Vulnerable(\"Simulating incoming vehicle control command.\");\n    return cmd;\n}\n\nvoid initializeVehicleProfiles_Vulnerable() {\n    g_configuredProfileCount_Vulnerable = 5;\n\n    g_allVehicleProfiles_Vulnerable[0] = (DrivingProfile_Vulnerable){100, 50, 10, \"Eco Mode\"};\n    g_allVehicleProfiles_Vulnerable[1] = (DrivingProfile_Vulnerable){120, 70, 20, \"Comfort Mode\"};\n    g_allVehicleProfiles_Vulnerable[2] = (DrivingProfile_Vulnerable){150, 90, 40, \"Normal Mode\"};\n    g_allVehicleProfiles_Vulnerable[3] = (DrivingProfile_Vulnerable){180, 110, 60, \"Sport Mode\"};\n    g_allVehicleProfiles_Vulnerable[4] = (DrivingProfile_Vulnerable){200, 130, 80, \"Race Mode\"};\n\n    automotive_log_Vulnerable(\"Vehicle profiles initialized for variant (vulnerable).\");\n}\n\nvoid activateDrivingProfile_Vulnerable(uint8_t profile_id) {\n    if (profile_id < MAX_VEHICLE_PROFILES_VULNERABLE) {\n        DrivingProfile_Vulnerable active_profile = g_allVehicleProfiles_Vulnerable[profile_id];\n        automotive_log_Vulnerable(\"Attempting to activate driving profile (vulnerable).\");\n        (void)active_profile;\n    } else {\n        automotive_log_Vulnerable(\"Invalid profile ID received (out of max bounds).\");\n    }\n}\n\nvoid vehicleProfileManager_main_Vulnerable() {\n    initializeVehicleProfiles_Vulnerable();\n    VehicleControlCommand_Vulnerable cmd = receiveVehicleControlCommand_Vulnerable();\n\n    if (cmd.command_id == 0x01) {\n        activateDrivingProfile_Vulnerable(cmd.requested_profile_id);\n    } else {\n        automotive_log_Vulnerable(\"Unhandled vehicle control command.\");\n    }\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX_VEHICLE_PROFILES_FIXED 10\n\ntypedef struct {\n    uint16_t engine_torque_factor;\n    uint16_t transmission_shift_aggressiveness;\n    uint8_t suspension_damping_level;\n    char profile_name[32];\n} DrivingProfile_Fixed;\n\nstatic DrivingProfile_Fixed g_allVehicleProfiles_Fixed[MAX_VEHICLE_PROFILES_FIXED];\nstatic uint8_t g_configuredProfileCount_Fixed;\n\nvoid automotive_log_Fixed(const char* msg) {\n    (void)msg;\n}\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t requested_profile_id;\n    uint16_t checksum;\n} VehicleControlCommand_Fixed;\n\nVehicleControlCommand_Fixed receiveVehicleControlCommand_Fixed() {\n    VehicleControlCommand_Fixed cmd;\n    cmd.command_id = 0x01;\n    cmd.requested_profile_id = 6;\n    cmd.checksum = 0xAAAA;\n    automotive_log_Fixed(\"Simulating incoming vehicle control command.\");\n    return cmd;\n}\n\nvoid initializeVehicleProfiles_Fixed() {\n    g_configuredProfileCount_Fixed = 5;\n\n    g_allVehicleProfiles_Fixed[0] = (DrivingProfile_Fixed){100, 50, 10, \"Eco Mode\"};\n    g_allVehicleProfiles_Fixed[1] = (DrivingProfile_Fixed){120, 70, 20, \"Comfort Mode\"};\n    g_allVehicleProfiles_Fixed[2] = (DrivingProfile_Fixed){150, 90, 40, \"Normal Mode\"};\n    g_allVehicleProfiles_Fixed[3] = (DrivingProfile_Fixed){180, 110, 60, \"Sport Mode\"};\n    g_allVehicleProfiles_Fixed[4] = (DrivingProfile_Fixed){200, 130, 80, \"Race Mode\"};\n\n    automotive_log_Fixed(\"Vehicle profiles initialized for variant (fixed).\");\n}\n\nvoid activateDrivingProfile_Fixed(uint8_t profile_id) {\n    if (profile_id < g_configuredProfileCount_Fixed) {\n        DrivingProfile_Fixed active_profile = g_allVehicleProfiles_Fixed[profile_id];\n        automotive_log_Fixed(\"Successfully activated driving profile (fixed).\");\n        (void)active_profile;\n    } else {\n        automotive_log_Fixed(\"Invalid profile ID received (out of configured bounds). Ignoring command.\");\n    }\n}\n\nvoid vehicleProfileManager_main_Fixed() {\n    initializeVehicleProfiles_Fixed();\n    VehicleControlCommand_Fixed cmd = receiveVehicleControlCommand_Fixed();\n\n    if (cmd.command_id == 0x01) {\n        activateDrivingProfile_Fixed(cmd.requested_profile_id);\n    } else {\n        automotive_log_Fixed(\"Unhandled vehicle control command.\");\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define CFG_GROUP_ENGINE_DIAG_VULNERABLE       0\n#define CFG_GROUP_TRANSMISSION_CAL_VULNERABLE  1\n#define CFG_GROUP_ADAS_SETTINGS_VULNERABLE     2\n#define NUM_CFG_GROUPS_VULNERABLE              3\n\n#define MAX_PARAMS_PER_GROUP_VULNERABLE        10\n\ntypedef struct {\n    uint32_t value;\n    uint8_t  type;\n    bool     is_writable;\n} ConfigParameter_Vulnerable;\n\nstatic ConfigParameter_Vulnerable g_config_parameters_vulnerable[NUM_CFG_GROUPS_VULNERABLE][MAX_PARAMS_PER_GROUP_VULNERABLE];\n\nstatic const uint8_t g_actual_params_in_group_vulnerable[NUM_CFG_GROUPS_VULNERABLE] = {\n    5,\n    8,\n    3\n};\n\nvoid log_config_system_error_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t group_id;\n    uint8_t param_index;\n} ConfigReadRequest_Vulnerable;\n\nConfigReadRequest_Vulnerable receive_config_read_request_vulnerable() {\n    ConfigReadRequest_Vulnerable req;\n    req.group_id = CFG_GROUP_ADAS_SETTINGS_VULNERABLE;\n    req.param_index = 3;\n    return req;\n}\n\nvoid initialize_config_data_vulnerable() {\n    for (uint8_t i = 0; i < NUM_CFG_GROUPS_VULNERABLE; ++i) {\n        for (uint8_t j = 0; j < g_actual_params_in_group_vulnerable[i]; ++j) {\n            g_config_parameters_vulnerable[i][j].value = (uint32_t)(i << 16) | j;\n            g_config_parameters_vulnerable[i][j].type = 0x01;\n            g_config_parameters_vulnerable[i][j].is_writable = true;\n        }\n        for (uint8_t j = g_actual_params_in_group_vulnerable[i]; j < MAX_PARAMS_PER_GROUP_VULNERABLE; ++j) {\n             g_config_parameters_vulnerable[i][j].value = 0xFFFFFFFF;\n             g_config_parameters_vulnerable[i][j].type = 0xFF;\n             g_config_parameters_vulnerable[i][j].is_writable = false;\n        }\n    }\n    log_config_system_error_vulnerable(\"Configuration data initialized (vulnerable).\");\n}\n\nvoid read_config_parameter_vulnerable() {\n    ConfigReadRequest_Vulnerable req = receive_config_read_request_vulnerable();\n\n    if (req.group_id < NUM_CFG_GROUPS_VULNERABLE) {\n        if (req.param_index < MAX_PARAMS_PER_GROUP_VULNERABLE) {\n            ConfigParameter_Vulnerable param = g_config_parameters_vulnerable[req.group_id][req.param_index];\n            log_config_system_error_vulnerable(\"Configuration parameter read (vulnerable).\");\n        } else {\n            log_config_system_error_vulnerable(\"Configuration parameter index out of global bounds.\");\n        }\n    } else {\n        log_config_system_error_vulnerable(\"Configuration group ID out of bounds.\");\n    }\n}\n\nvoid config_manager_main_vulnerable() {\n    initialize_config_data_vulnerable();\n    read_config_parameter_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define CFG_GROUP_ENGINE_DIAG_FIXED       0\n#define CFG_GROUP_TRANSMISSION_CAL_FIXED  1\n#define CFG_GROUP_ADAS_SETTINGS_FIXED     2\n#define NUM_CFG_GROUPS_FIXED              3\n\n#define MAX_PARAMS_PER_GROUP_FIXED        10\n\ntypedef struct {\n    uint32_t value;\n    uint8_t  type;\n    bool     is_writable;\n} ConfigParameter_Fixed;\n\nstatic ConfigParameter_Fixed g_config_parameters_fixed[NUM_CFG_GROUPS_FIXED][MAX_PARAMS_PER_GROUP_FIXED];\n\nstatic const uint8_t g_actual_params_in_group_fixed[NUM_CFG_GROUPS_FIXED] = {\n    5,\n    8,\n    3\n};\n\nvoid log_config_system_error_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t group_id;\n    uint8_t param_index;\n} ConfigReadRequest_Fixed;\n\nConfigReadRequest_Fixed receive_config_read_request_fixed() {\n    ConfigReadRequest_Fixed req;\n    req.group_id = CFG_GROUP_ADAS_SETTINGS_FIXED;\n    req.param_index = 3;\n    return req;\n}\n\nvoid initialize_config_data_fixed() {\n    for (uint8_t i = 0; i < NUM_CFG_GROUPS_FIXED; ++i) {\n        for (uint8_t j = 0; j < g_actual_params_in_group_fixed[i]; ++j) {\n            g_config_parameters_fixed[i][j].value = (uint32_t)(i << 16) | j;\n            g_config_parameters_fixed[i][j].type = 0x01;\n            g_config_parameters_fixed[i][j].is_writable = true;\n        }\n        for (uint8_t j = g_actual_params_in_group_fixed[i]; j < MAX_PARAMS_PER_GROUP_FIXED; ++j) {\n             g_config_parameters_fixed[i][j].value = 0xFFFFFFFF;\n             g_config_parameters_fixed[i][j].type = 0xFF;\n             g_config_parameters_fixed[i][j].is_writable = false;\n        }\n    }\n    log_config_system_error_fixed(\"Configuration data initialized (fixed).\");\n}\n\nvoid read_config_parameter_fixed() {\n    ConfigReadRequest_Fixed req = receive_config_read_request_fixed();\n\n    if (req.group_id < NUM_CFG_GROUPS_FIXED) {\n        if (req.param_index < g_actual_params_in_group_fixed[req.group_id]) {\n            ConfigParameter_Fixed param = g_config_parameters_fixed[req.group_id][req.param_index];\n            log_config_system_error_fixed(\"Configuration parameter read successfully (fixed).\");\n        } else {\n            log_config_system_error_fixed(\"Configuration parameter index out of bounds for its specific group (fixed).\");\n        }\n    } else {\n        log_config_system_error_fixed(\"Configuration group ID out of bounds (fixed).\");\n    }\n}\n\nvoid config_manager_main_fixed() {\n    initialize_config_data_fixed();\n    read_config_parameter_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#define GLOBAL_DATA_STORAGE_SIZE_VULNERABLE 256\n#define MAX_DTC_SEGMENTS_VULNERABLE 4\n\ntypedef struct {\n    uint16_t segment_start_offset;\n    uint16_t segment_actual_size;\n    uint16_t segment_max_offset;\n} DTCSegmentConfig_Vulnerable;\n\nstatic uint8_t g_dtcDataStorage_vulnerable[GLOBAL_DATA_STORAGE_SIZE_VULNERABLE];\n\nstatic DTCSegmentConfig_Vulnerable g_dtcConfigs_vulnerable[MAX_DTC_SEGMENTS_VULNERABLE];\n\nvoid logSystemOutput_vulnerable(const char* msg) {\n    printf(\"VULN_LOG: %s\\n\", msg);\n}\n\nvoid initializeDTCSystem_vulnerable() {\n    g_dtcConfigs_vulnerable[0] = (DTCSegmentConfig_Vulnerable){ .segment_start_offset = 0, .segment_actual_size = 20, .segment_max_offset = 50 };\n    g_dtcConfigs_vulnerable[1] = (DTCSegmentConfig_Vulnerable){ .segment_start_offset = 50, .segment_actual_size = 30, .segment_max_offset = 50 };\n    g_dtcConfigs_vulnerable[2] = (DTCSegmentConfig_Vulnerable){ .segment_start_offset = 100, .segment_actual_size = 10, .segment_max_offset = 50 };\n    g_dtcConfigs_vulnerable[3] = (DTCSegmentConfig_Vulnerable){ .segment_start_offset = 150, .segment_actual_size = 40, .segment_max_offset = 50 };\n\n    for (uint16_t i = 0; i < GLOBAL_DATA_STORAGE_SIZE_VULNERABLE; ++i) {\n        g_dtcDataStorage_vulnerable[i] = (uint8_t)(i % 0xFF);\n    }\n\n    memset(&g_dtcDataStorage_vulnerable[g_dtcConfigs_vulnerable[0].segment_start_offset], 0x11, g_dtcConfigs_vulnerable[0].segment_actual_size);\n    memset(&g_dtcDataStorage_vulnerable[g_dtcConfigs_vulnerable[1].segment_start_offset], 0x22, g_dtcConfigs_vulnerable[1].segment_actual_size);\n    memset(&g_dtcDataStorage_vulnerable[g_dtcConfigs_vulnerable[2].segment_start_offset], 0xAA, g_dtcConfigs_vulnerable[2].segment_actual_size);\n    memset(&g_dtcDataStorage_vulnerable[g_dtcConfigs_vulnerable[3].segment_start_offset], 0x44, g_dtcConfigs_vulnerable[3].segment_actual_size);\n\n    g_dtcDataStorage_vulnerable[112] = 0xDD;\n    g_dtcDataStorage_vulnerable[113] = 0xEE;\n\n    logSystemOutput_vulnerable(\"DTC system initialized.\");\n}\n\nuint16_t getRequestedDTCID_vulnerable() {\n    return 0x020C;\n}\n\nuint8_t getDTCFaultValue_vulnerable(uint16_t dtc_id) {\n    uint8_t segment_idx = (uint8_t)((dtc_id >> 8) & 0xFF);\n    uint8_t relative_offset = (uint8_t)(dtc_id & 0xFF);\n\n    if (segment_idx >= MAX_DTC_SEGMENTS_VULNERABLE) {\n        logSystemOutput_vulnerable(\"Error: Invalid DTC segment ID.\");\n        return 0xFF;\n    }\n\n    uint16_t absolute_byte_offset = g_dtcConfigs_vulnerable[segment_idx].segment_start_offset + relative_offset;\n\n    if (absolute_byte_offset >= GLOBAL_DATA_STORAGE_SIZE_VULNERABLE) {\n        logSystemOutput_vulnerable(\"Error: Calculated offset exceeds global data storage bounds.\");\n        return 0xFF;\n    }\n    \n    logSystemOutput_vulnerable(\"Reading DTC fault value.\");\n    return g_dtcDataStorage_vulnerable[absolute_byte_offset];\n}\n\nvoid diagnosticMonitorLoop_vulnerable() {\n    initializeDTCSystem_vulnerable();\n\n    uint16_t requested_dtc_id = getRequestedDTCID_vulnerable();\n    uint8_t fault_value = getDTCFaultValue_vulnerable(requested_dtc_id);\n    \n    char log_msg[64];\n    sprintf(log_msg, \"Retrieved fault value: 0x%02X\", fault_value);\n    logSystemOutput_vulnerable(log_msg);\n}\n\nvoid automotiveDTCManager_vulnerable_main() {\n    diagnosticMonitorLoop_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#define GLOBAL_DATA_STORAGE_SIZE_FIXED 256\n#define MAX_DTC_SEGMENTS_FIXED 4\n\ntypedef struct {\n    uint16_t segment_start_offset;\n    uint16_t segment_actual_size;\n    uint16_t segment_max_offset;\n} DTCSegmentConfig_Fixed;\n\nstatic uint8_t g_dtcDataStorage_fixed[GLOBAL_DATA_STORAGE_SIZE_FIXED];\n\nstatic DTCSegmentConfig_Fixed g_dtcConfigs_fixed[MAX_DTC_SEGMENTS_FIXED];\n\nvoid logSystemOutput_fixed(const char* msg) {\n    printf(\"FIXED_LOG: %s\\n\", msg);\n}\n\nvoid initializeDTCSystem_fixed() {\n    g_dtcConfigs_fixed[0] = (DTCSegmentConfig_Fixed){ .segment_start_offset = 0, .segment_actual_size = 20, .segment_max_offset = 50 };\n    g_dtcConfigs_fixed[1] = (DTCSegmentConfig_Fixed){ .segment_start_offset = 50, .segment_actual_size = 30, .segment_max_offset = 50 };\n    g_dtcConfigs_fixed[2] = (DTCSegmentConfig_Fixed){ .segment_start_offset = 100, .segment_actual_size = 10, .segment_max_offset = 50 };\n    g_dtcConfigs_fixed[3] = (DTCSegmentConfig_Fixed){ .segment_start_offset = 150, .segment_actual_size = 40, .segment_max_offset = 50 };\n\n    for (uint16_t i = 0; i < GLOBAL_DATA_STORAGE_SIZE_FIXED; ++i) {\n        g_dtcDataStorage_fixed[i] = (uint8_t)(i % 0xFF);\n    }\n\n    memset(&g_dtcDataStorage_fixed[g_dtcConfigs_fixed[0].segment_start_offset], 0x11, g_dtcConfigs_fixed[0].segment_actual_size);\n    memset(&g_dtcDataStorage_fixed[g_dtcConfigs_fixed[1].segment_start_offset], 0x22, g_dtcConfigs_fixed[1].segment_actual_size);\n    memset(&g_dtcDataStorage_fixed[g_dtcConfigs_fixed[2].segment_start_offset], 0xAA, g_dtcConfigs_fixed[2].segment_actual_size);\n    memset(&g_dtcDataStorage_fixed[g_dtcConfigs_fixed[3].segment_start_offset], 0x44, g_dtcConfigs_fixed[3].segment_actual_size);\n\n    g_dtcDataStorage_fixed[112] = 0xDD;\n    g_dtcDataStorage_fixed[113] = 0xEE;\n\n    logSystemOutput_fixed(\"DTC system initialized.\");\n}\n\nuint16_t getRequestedDTCID_fixed() {\n    return 0x020C;\n}\n\nuint8_t getDTCFaultValue_fixed(uint16_t dtc_id) {\n    uint8_t segment_idx = (uint8_t)((dtc_id >> 8) & 0xFF);\n    uint8_t relative_offset = (uint8_t)(dtc_id & 0xFF);\n\n    if (segment_idx >= MAX_DTC_SEGMENTS_FIXED) {\n        logSystemOutput_fixed(\"Error: Invalid DTC segment ID (fixed).\\n\");\n        return 0xFF;\n    }\n\n    if (relative_offset >= g_dtcConfigs_fixed[segment_idx].segment_actual_size) {\n        logSystemOutput_fixed(\"Error: Relative offset out of bounds for specified DTC segment (fixed).\\n\");\n        return 0xFF;\n    }\n\n    uint16_t absolute_byte_offset = g_dtcConfigs_fixed[segment_idx].segment_start_offset + relative_offset;\n\n    if (absolute_byte_offset >= GLOBAL_DATA_STORAGE_SIZE_FIXED) {\n        logSystemOutput_fixed(\"Error: Calculated offset exceeds global data storage bounds (fixed).\\n\");\n        return 0xFF;\n    }\n    \n    logSystemOutput_fixed(\"Reading DTC fault value (fixed).\\n\");\n    return g_dtcDataStorage_fixed[absolute_byte_offset];\n}\n\nvoid diagnosticMonitorLoop_fixed() {\n    initializeDTCSystem_fixed();\n\n    uint16_t requested_dtc_id = getRequestedDTCID_fixed();\n    uint8_t fault_value = getDTCFaultValue_fixed(requested_dtc_id);\n    \n    char log_msg[64];\n    sprintf(log_msg, \"Retrieved fault value: 0x%02X (fixed)\", fault_value);\n    logSystemOutput_fixed(log_msg);\n}\n\nvoid automotiveDTCManager_fixed_main() {\n    diagnosticMonitorLoop_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_SUBSYSTEM_PARAMS_VULNERABLE 8\n\ntypedef enum {\n    SUBSYSTEM_ENGINE_VULNERABLE = 0,\n    SUBSYSTEM_TRANSMISSION_VULNERABLE,\n    SUBSYSTEM_BRAKES_VULNERABLE,\n    SUBSYSTEM_HVAC_VULNERABLE,\n    SUBSYSTEM_INFOTAINMENT_VULNERABLE,\n    NUM_VEHICLE_SUBSYSTEMS_VULNERABLE \n} VehicleSubSystem_Vulnerable;\n\ntypedef struct {\n    uint32_t params[MAX_SUBSYSTEM_PARAMS_VULNERABLE];\n    uint8_t  active_param_count;\n} SubsystemConfiguration_Vulnerable;\n\nstatic SubsystemConfiguration_Vulnerable g_vehicle_configs_vulnerable[NUM_VEHICLE_SUBSYSTEMS_VULNERABLE];\n\ntypedef struct {\n    uint8_t  target_subsystem_id;\n    uint8_t  config_param_idx;\n    uint32_t new_value;\n} CanConfigurationCommand_Vulnerable;\n\nvoid log_ecu_event_vulnerable(const char* event) {\n}\n\nCanConfigurationCommand_Vulnerable receive_can_command_vulnerable() {\n    CanConfigurationCommand_Vulnerable cmd;\n    cmd.target_subsystem_id = NUM_VEHICLE_SUBSYSTEMS_VULNERABLE; \n    cmd.config_param_idx = 0;\n    cmd.new_value = 0xAAAA;\n    return cmd;\n}\n\nvoid initialize_vehicle_configs_vulnerable() {\n    for (uint8_t i = 0; i < NUM_VEHICLE_SUBSYSTEMS_VULNERABLE; ++i) {\n        for (uint8_t j = 0; j < MAX_SUBSYSTEM_PARAMS_VULNERABLE; ++j) {\n            g_vehicle_configs_vulnerable[i].params[j] = 0;\n        }\n        g_vehicle_configs_vulnerable[i].active_param_count = MAX_SUBSYSTEM_PARAMS_VULNERABLE;\n    }\n    log_ecu_event_vulnerable(\"Vehicle configurations initialized (vulnerable).\");\n}\n\nvoid update_subsystem_param_vulnerable() {\n    CanConfigurationCommand_Vulnerable cmd = receive_can_command_vulnerable();\n\n    g_vehicle_configs_vulnerable[cmd.target_subsystem_id].params[cmd.config_param_idx] = cmd.new_value;\n    log_ecu_event_vulnerable(\"Subsystem parameter updated (vulnerable).\");\n}\n\nvoid vehicle_configuration_manager_vulnerable_main() {\n    initialize_vehicle_configs_vulnerable();\n    update_subsystem_param_vulnerable();\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n\n#define MAX_SUBSYSTEM_PARAMS_FIXED 8\n\ntypedef enum {\n    SUBSYSTEM_ENGINE_FIXED = 0,\n    SUBSYSTEM_TRANSMISSION_FIXED,\n    SUBSYSTEM_BRAKES_FIXED,\n    SUBSYSTEM_HVAC_FIXED,\n    SUBSYSTEM_INFOTAINMENT_FIXED,\n    NUM_VEHICLE_SUBSYSTEMS_FIXED\n} VehicleSubSystem_Fixed;\n\ntypedef struct {\n    uint32_t params[MAX_SUBSYSTEM_PARAMS_FIXED];\n    uint8_t  active_param_count;\n} SubsystemConfiguration_Fixed;\n\nstatic SubsystemConfiguration_Fixed g_vehicle_configs_fixed[NUM_VEHICLE_SUBSYSTEMS_FIXED];\n\ntypedef struct {\n    uint8_t  target_subsystem_id;\n    uint8_t  config_param_idx;\n    uint32_t new_value;\n} CanConfigurationCommand_Fixed;\n\nvoid log_ecu_event_fixed(const char* event) {\n}\n\nvoid log_ecu_error_fixed(const char* error) {\n}\n\nCanConfigurationCommand_Fixed receive_can_command_fixed() {\n    CanConfigurationCommand_Fixed cmd;\n    cmd.target_subsystem_id = NUM_VEHICLE_SUBSYSTEMS_FIXED;\n    cmd.config_param_idx = 0;\n    cmd.new_value = 0xAAAA;\n    return cmd;\n}\n\nvoid initialize_vehicle_configs_fixed() {\n    for (uint8_t i = 0; i < NUM_VEHICLE_SUBSYSTEMS_FIXED; ++i) {\n        for (uint8_t j = 0; j < MAX_SUBSYSTEM_PARAMS_FIXED; ++j) {\n            g_vehicle_configs_fixed[i].params[j] = 0;\n        }\n        g_vehicle_configs_fixed[i].active_param_count = MAX_SUBSYSTEM_PARAMS_FIXED;\n    }\n    log_ecu_event_fixed(\"Vehicle configurations initialized (fixed).\");\n}\n\nvoid update_subsystem_param_fixed() {\n    CanConfigurationCommand_Fixed cmd = receive_can_command_fixed();\n\n    if (cmd.target_subsystem_id < NUM_VEHICLE_SUBSYSTEMS_FIXED) {\n        if (cmd.config_param_idx < MAX_SUBSYSTEM_PARAMS_FIXED) {\n            g_vehicle_configs_fixed[cmd.target_subsystem_id].params[cmd.config_param_idx] = cmd.new_value;\n            log_ecu_event_fixed(\"Subsystem parameter updated (fixed).\");\n        } else {\n            log_ecu_error_fixed(\"Error: Invalid configuration parameter index received.\");\n        }\n    } else {\n        log_ecu_error_fixed(\"Error: Invalid subsystem ID received for configuration update.\");\n    n}\n}\n\nvoid vehicle_configuration_manager_fixed_main() {\n    initialize_vehicle_configs_fixed();\n    update_subsystem_param_fixed();\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define EVENT_LOG_BUFFER_SIZE 256\n#define MAX_EVENT_CODE 0xFFF\n\ntypedef struct {\n    uint16_t eventCode;\n    uint32_t timestamp;\n    uint8_t  severity;\n    uint8_t  data[4];\n} VehicleEventEntry_Vulnerable;\n\nstatic VehicleEventEntry_Vulnerable g_eventLogBuffer_vulnerable[EVENT_LOG_BUFFER_SIZE];\nstatic uint16_t g_eventLogWriteIndex_vulnerable = 0;\nstatic bool g_eventLogWrapped_vulnerable = false;\n\nvoid logRecorderError_vulnerable(const char* msg) {\n}\n\nVehicleEventEntry_Vulnerable receiveVehicleEvent_vulnerable() {\n    VehicleEventEntry_Vulnerable event;\n    event.eventCode = 0x100;\n    event.timestamp = 0xDEADBEEF;\n    event.severity = 5;\n    event.data[0] = 0xAA; event.data[1] = 0xBB; event.data[2] = 0xCC; event.data[3] = 0xDD;\n    return event;\n}\n\nvoid initializeEventLog_vulnerable() {\n    for (uint16_t i = 0; i < EVENT_LOG_BUFFER_SIZE; ++i) {\n        g_eventLogBuffer_vulnerable[i] = (VehicleEventEntry_Vulnerable){0, 0, 0, {0,0,0,0}};\n    }\n    g_eventLogWriteIndex_vulnerable = EVENT_LOG_BUFFER_SIZE - 1;\n    g_eventLogWrapped_vulnerable = false;\n    logRecorderError_vulnerable(\"Vehicle event log initialized.\");\n}\n\nvoid recordVehicleEvent_vulnerable(VehicleEventEntry_Vulnerable event) {\n    g_eventLogBuffer_vulnerable[g_eventLogWriteIndex_vulnerable] = event;\n\n    g_eventLogWriteIndex_vulnerable++;\n\n    if (g_eventLogWriteIndex_vulnerable >= EVENT_LOG_BUFFER_SIZE) {\n        g_eventLogWriteIndex_vulnerable = EVENT_LOG_BUFFER_SIZE;\n        g_eventLogWrapped_vulnerable = true;\n    }\n    logRecorderError_vulnerable(\"Vehicle event recorded.\");\n}\n\nvoid vehicleEventRecorderMain_vulnerable() {\n    initializeEventLog_vulnerable();\n\n    VehicleEventEntry_Vulnerable receivedEvent = receiveVehicleEvent_vulnerable();\n    recordVehicleEvent_vulnerable(receivedEvent);\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define EVENT_LOG_BUFFER_SIZE 256\n#define MAX_EVENT_CODE 0xFFF\n\ntypedef struct {\n    uint16_t eventCode;\n    uint32_t timestamp;\n    uint8_t  severity;\n    uint8_t  data[4];\n} VehicleEventEntry_Fixed;\n\nstatic VehicleEventEntry_Fixed g_eventLogBuffer_fixed[EVENT_LOG_BUFFER_SIZE];\nstatic uint16_t g_eventLogWriteIndex_fixed = 0;\nstatic bool g_eventLogWrapped_fixed = false;\n\nvoid logRecorderError_fixed(const char* msg) {\n}\n\nVehicleEventEntry_Fixed receiveVehicleEvent_fixed() {\n    VehicleEventEntry_Fixed event;\n    event.eventCode = 0x100;\n    event.timestamp = 0xDEADBEEF;\n    event.severity = 5;\n    event.data[0] = 0xAA; event.data[1] = 0xBB; event.data[2] = 0xCC; event.data[3] = 0xDD;\n    return event;\n}\n\nvoid initializeEventLog_fixed() {\n    for (uint16_t i = 0; i < EVENT_LOG_BUFFER_SIZE; ++i) {\n        g_eventLogBuffer_fixed[i] = (VehicleEventEntry_Fixed){0, 0, 0, {0,0,0,0}};\n    }\n    g_eventLogWriteIndex_fixed = EVENT_LOG_BUFFER_SIZE - 1;\n    g_eventLogWrapped_fixed = false;\n    logRecorderError_fixed(\"Vehicle event log initialized.\");\n}\n\nvoid recordVehicleEvent_fixed(VehicleEventEntry_Fixed event) {\n    g_eventLogBuffer_fixed[g_eventLogWriteIndex_fixed] = event;\n\n    g_eventLogWriteIndex_fixed = (g_eventLogWriteIndex_fixed + 1) % EVENT_LOG_BUFFER_SIZE;\n\n    if (g_eventLogWriteIndex_fixed == 0 && !g_eventLogWrapped_fixed) {\n        g_eventLogWrapped_fixed = true;\n    }\n    logRecorderError_fixed(\"Vehicle event recorded.\");\n}\n\nvoid vehicleEventRecorderMain_fixed() {\n    initializeEventLog_fixed();\n\n    VehicleEventEntry_Fixed receivedEvent = receiveVehicleEvent_fixed();\n    recordVehicleEvent_fixed(receivedEvent);\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_DTC_STORAGE_CAPACITY_VULNERABLE 10\n\ntypedef struct {\n    uint32_t dtc_code;\n    uint8_t  status_byte;\n    uint16_t occurrence_count;\n    bool     is_active;\n} DTC_Entry_Vulnerable;\n\nstatic DTC_Entry_Vulnerable g_dtc_entries_vulnerable[MAX_DTC_STORAGE_CAPACITY_VULNERABLE];\nstatic uint8_t g_current_active_dtc_count_vulnerable = 0;\n\nvoid logDiagnosticMessage_vulnerable(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t requested_dtc_index;\n} DTC_QueryRequest_Vulnerable;\n\nDTC_QueryRequest_Vulnerable receiveDTCQuery_vulnerable() {\n    DTC_QueryRequest_Vulnerable query;\n    query.requested_dtc_index = g_current_active_dtc_count_vulnerable; \n    return query;\n}\n\nvoid initializeDTCStorage_vulnerable() {\n    for (uint8_t i = 0; i < MAX_DTC_STORAGE_CAPACITY_VULNERABLE; ++i) {\n        g_dtc_entries_vulnerable[i] = (DTC_Entry_Vulnerable){0, 0, 0, false};\n    }\n\n    g_dtc_entries_vulnerable[0] = (DTC_Entry_Vulnerable){0xF001, 0x0A, 1, true};\n    g_dtc_entries_vulnerable[1] = (DTC_Entry_Vulnerable){0xF002, 0x0B, 3, true};\n    g_dtc_entries_vulnerable[2] = (DTC_Entry_Vulnerable){0xF003, 0x0C, 1, true};\n    g_current_active_dtc_count_vulnerable = 3;\n\n    logDiagnosticMessage_vulnerable(\"DTC storage initialized (vulnerable).\");\n}\n\nvoid addDTC_vulnerable(uint32_t code, uint8_t status) {\n    if (g_current_active_dtc_count_vulnerable < MAX_DTC_STORAGE_CAPACITY_VULNERABLE) {\n        DTC_Entry_Vulnerable new_dtc = {code, status, 1, true};\n        g_dtc_entries_vulnerable[g_current_active_dtc_count_vulnerable] = new_dtc;\n        g_current_active_dtc_count_vulnerable++;\n        logDiagnosticMessage_vulnerable(\"DTC added.\");\n    } else {\n        logDiagnosticMessage_vulnerable(\"DTC storage full.\");\n    }\n}\n\nDTC_Entry_Vulnerable getDTCDetails_vulnerable(uint8_t index) {\n    if (index < MAX_DTC_STORAGE_CAPACITY_VULNERABLE) {\n        logDiagnosticMessage_vulnerable(\"Accessing DTC entry (vulnerable).\");\n        return g_dtc_entries_vulnerable[index];\n    } else {\n        logDiagnosticMessage_vulnerable(\"DTC query index out of physical array bounds (vulnerable).\");\n        return (DTC_Entry_Vulnerable){0, 0, 0, false};\n    }\n}\n\nvoid diagnosticModuleMain_vulnerable() {\n    initializeDTCStorage_vulnerable();\n    addDTC_vulnerable(0xF004, 0x0D);\n    \n    DTC_QueryRequest_Vulnerable query = receiveDTCQuery_vulnerable();\n    DTC_Entry_Vulnerable retrieved_dtc = getDTCDetails_vulnerable(query.requested_dtc_index);\n    logDiagnosticMessage_vulnerable(\"DTC query processed (vulnerable).\");\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define MAX_DTC_STORAGE_CAPACITY_FIXED 10\n\ntypedef struct {\n    uint32_t dtc_code;\n    uint8_t  status_byte;\n    uint16_t occurrence_count;\n    bool     is_active;\n} DTC_Entry_Fixed;\n\nstatic DTC_Entry_Fixed g_dtc_entries_fixed[MAX_DTC_STORAGE_CAPACITY_FIXED];\nstatic uint8_t g_current_active_dtc_count_fixed = 0;\n\nvoid logDiagnosticMessage_fixed(const char* msg) {\n}\n\ntypedef struct {\n    uint8_t requested_dtc_index;\n} DTC_QueryRequest_Fixed;\n\nDTC_QueryRequest_Fixed receiveDTCQuery_fixed() {\n    DTC_QueryRequest_Fixed query;\n    query.requested_dtc_index = g_current_active_dtc_count_fixed;\n    return query;\n}\n\nvoid initializeDTCStorage_fixed() {\n    for (uint8_t i = 0; i < MAX_DTC_STORAGE_CAPACITY_FIXED; ++i) {\n        g_dtc_entries_fixed[i] = (DTC_Entry_Fixed){0, 0, 0, false};\n    }\n\n    g_dtc_entries_fixed[0] = (DTC_Entry_Fixed){0xF001, 0x0A, 1, true};\n    g_dtc_entries_fixed[1] = (DTC_Entry_Fixed){0xF002, 0x0B, 3, true};\n    g_dtc_entries_fixed[2] = (DTC_Entry_Fixed){0xF003, 0x0C, 1, true};\n    g_current_active_dtc_count_fixed = 3;\n\n    logDiagnosticMessage_fixed(\"DTC storage initialized (fixed).\");\n}\n\nvoid addDTC_fixed(uint32_t code, uint8_t status) {\n    if (g_current_active_dtc_count_fixed < MAX_DTC_STORAGE_CAPACITY_FIXED) {\n        DTC_Entry_Fixed new_dtc = {code, status, 1, true};\n        g_dtc_entries_fixed[g_current_active_dtc_count_fixed] = new_dtc;\n        g_current_active_dtc_count_fixed++;\n        logDiagnosticMessage_fixed(\"DTC added.\");\n    } else {\n        logDiagnosticMessage_fixed(\"DTC storage full.\");\n    }\n}\n\nDTC_Entry_Fixed getDTCDetails_fixed(uint8_t index) {\n    if (index < g_current_active_dtc_count_fixed) {\n        logDiagnosticMessage_fixed(\"Accessing DTC entry (fixed).\");\n        return g_dtc_entries_fixed[index];\n    } else {\n        logDiagnosticMessage_fixed(\"DTC query index out of active DTC count bounds (fixed).\");\n        return (DTC_Entry_Fixed){0, 0, 0, false};\n    }\n}\n\nvoid diagnosticModuleMain_fixed() {\n    initializeDTCStorage_fixed();\n    addDTC_fixed(0xF004, 0x0D);\n    \n    DTC_QueryRequest_Fixed query = receiveDTCQuery_fixed();\n    DTC_Entry_Fixed retrieved_dtc = getDTCDetails_fixed(query.requested_dtc_index);\n    logDiagnosticMessage_fixed(\"DTC query processed (fixed).\");\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-129",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "vulnerable_code": "#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#define CAN_DATA_MAX_LEN 8\n#define CAN_MSG_ID_BASE 0x100\n#define NUM_CAN_HANDLERS 5\n\ntypedef struct {\n    uint16_t message_id;\n    uint8_t data[CAN_DATA_MAX_LEN];\n    uint8_t data_len;\n} CanMessage;\n\nvoid automotiveCanLog_vulnerable(const char* msg) {\n    fprintf(stderr, \"CAN_VULN_LOG: %s\\n\", msg);\n}\n\nvoid handleEngineRPM(const uint8_t* data, uint8_t len) {\n    if (len >= 2) {\n        uint16_t rpm = (data[0] << 8) | data[1];\n        automotiveCanLog_vulnerable(\"Engine RPM handler: RPM processed.\");\n    } else {\n        automotiveCanLog_vulnerable(\"Engine RPM handler: Invalid data length.\");\n    }\n}\n\nvoid handleVehicleSpeed(const uint8_t* data, uint8_t len) {\n    if (len >= 1) {\n        uint8_t speed = data[0];\n        automotiveCanLog_vulnerable(\"Vehicle Speed handler: Speed processed.\");\n    } else {\n        automotiveCanLog_vulnerable(\"Vehicle Speed handler: Invalid data length.\");\n    }\n}\n\nvoid handleBrakePressure(const uint8_t* data, uint8_t len) {\n    if (len >= 4) {\n        int32_t pressure = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | data[3];\n        automotiveCanLog_vulnerable(\"Brake Pressure handler: Pressure processed.\");\n    } else {\n        automotiveCanLog_vulnerable(\"Brake Pressure handler: Invalid data length.\");\n    }\n}\n\nvoid handleSteeringAngle(const uint8_t* data, uint8_t len) {\n    if (len >= 2) {\n        int16_t angle = (data[0] << 8) | data[1];\n        automotiveCanLog_vulnerable(\"Steering Angle handler: Angle processed.\");\n    } else {\n        automotiveCanLog_vulnerable(\"Steering Angle handler: Invalid data length.\");\n    }\n}\n\nvoid handleDoorStatus(const uint8_t* data, uint8_t len) {\n    if (len >= 1) {\n        uint8_t status = data[0];\n        automotiveCanLog_vulnerable(\"Door Status handler: Status processed.\");\n    } else {\n        automotiveCanLog_vulnerable(\"Door Status handler: Invalid data length.\");\n    }\n}\n\ntypedef void (*CanHandlerFunc)(const uint8_t* data, uint8_t len);\n\nstatic CanHandlerFunc g_canHandlers_vulnerable[NUM_CAN_HANDLERS];\n\nvoid initializeCanHandlers_vulnerable() {\n    g_canHandlers_vulnerable[0] = handleEngineRPM;\n    g_canHandlers_vulnerable[1] = handleVehicleSpeed;\n    g_canHandlers_vulnerable[2] = handleBrakePressure;\n    g_canHandlers_vulnerable[3] = handleSteeringAngle;\n    g_canHandlers_vulnerable[4] = handleDoorStatus;\n    automotiveCanLog_vulnerable(\"CAN handlers initialized (Vulnerable).\");\n}\n\nCanMessage receiveCanMessage_vulnerable() {\n    CanMessage msg;\n    msg.message_id = CAN_MSG_ID_BASE - 1;\n    msg.data_len = 2;\n    msg.data[0] = 0xAA;\n    msg.data[1] = 0xBB;\n    automotiveCanLog_vulnerable(\"Simulating reception of malicious CAN message (vulnerable).\");\n    return msg;\n}\n\nvoid processCanMessage_vulnerable(CanMessage msg) {\n    uint16_t handler_index = msg.message_id - CAN_MSG_ID_BASE;\n    g_canHandlers_vulnerable[handler_index](msg.data, msg.data_len);\n    automotiveCanLog_vulnerable(\"CAN message processing attempted (vulnerable).\");\n}\n\nvoid canCommunicationModuleMain_vulnerable() {\n    initializeCanHandlers_vulnerable();\n    CanMessage incoming_msg = receiveCanMessage_vulnerable();\n    processCanMessage_vulnerable(incoming_msg);\n}",
    "fixed_code": "#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#define CAN_DATA_MAX_LEN 8\n#define CAN_MSG_ID_BASE 0x100\n#define NUM_CAN_HANDLERS 5\n\ntypedef struct {\n    uint16_t message_id;\n    uint8_t data[CAN_DATA_MAX_LEN];\n    uint8_t data_len;\n} CanMessage;\n\nvoid automotiveCanLog_fixed(const char* msg) {\n    fprintf(stderr, \"CAN_FIXED_LOG: %s\\n\", msg);\n}\n\nvoid handleEngineRPM_fixed(const uint8_t* data, uint8_t len) {\n    if (len >= 2) {\n        uint16_t rpm = (data[0] << 8) | data[1];\n        automotiveCanLog_fixed(\"Engine RPM handler: RPM processed.\");\n    } else {\n        automotiveCanLog_fixed(\"Engine RPM handler: Invalid data length.\");\n    }\n}\n\nvoid handleVehicleSpeed_fixed(const uint8_t* data, uint8_t len) {\n    if (len >= 1) {\n        uint8_t speed = data[0];\n        automotiveCanLog_fixed(\"Vehicle Speed handler: Speed processed.\");\n    } else {\n        automotiveCanLog_fixed(\"Vehicle Speed handler: Invalid data length.\");\n    }\n}\n\nvoid handleBrakePressure_fixed(const uint8_t* data, uint8_t len) {\n    if (len >= 4) {\n        int32_t pressure = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | data[3];\n        automotiveCanLog_fixed(\"Brake Pressure handler: Pressure processed.\");\n    } else {\n        automotiveCanLog_fixed(\"Brake Pressure handler: Invalid data length.\");\n    }\n}\n\nvoid handleSteeringAngle_fixed(const uint8_t* data, uint8_t len) {\n    if (len >= 2) {\n        int16_t angle = (data[0] << 8) | data[1];\n        automotiveCanLog_fixed(\"Steering Angle handler: Angle processed.\");\n    } else {\n        automotiveCanLog_fixed(\"Steering Angle handler: Invalid data length.\");\n    }\n}\n\nvoid handleDoorStatus_fixed(const uint8_t* data, uint8_t len) {\n    if (len >= 1) {\n        uint8_t status = data[0];\n        automotiveCanLog_fixed(\"Door Status handler: Status processed.\");\n    } else {\n        automotiveCanLog_fixed(\"Door Status handler: Invalid data length.\");\n    }\n}\n\ntypedef void (*CanHandlerFunc)(const uint8_t* data, uint8_t len);\n\nstatic CanHandlerFunc g_canHandlers_fixed[NUM_CAN_HANDLERS];\n\nvoid initializeCanHandlers_fixed() {\n    g_canHandlers_fixed[0] = handleEngineRPM_fixed;\n    g_canHandlers_fixed[1] = handleVehicleSpeed_fixed;\n    g_canHandlers_fixed[2] = handleBrakePressure_fixed;\n    g_canHandlers_fixed[3] = handleSteeringAngle_fixed;\n    g_canHandlers_fixed[4] = handleDoorStatus_fixed;\n    automotiveCanLog_fixed(\"CAN handlers initialized (Fixed).\");\n}\n\nCanMessage receiveCanMessage_fixed() {\n    CanMessage msg;\n    msg.message_id = CAN_MSG_ID_BASE - 1;\n    msg.data_len = 2;\n    msg.data[0] = 0xAA;\n    msg.data[1] = 0xBB;\n    automotiveCanLog_fixed(\"Simulating reception of malicious CAN message (fixed).\");\n    return msg;\n}\n\nvoid processCanMessage_fixed(CanMessage msg) {\n    if (msg.message_id >= CAN_MSG_ID_BASE && msg.message_id < (CAN_MSG_ID_BASE + NUM_CAN_HANDLERS)) {\n        uint16_t handler_index = msg.message_id - CAN_MSG_ID_BASE;\n        if (handler_index < NUM_CAN_HANDLERS) {\n            g_canHandlers_fixed[handler_index](msg.data, msg.data_len);\n            automotiveCanLog_fixed(\"CAN message processed successfully (fixed).\");\n        } else {\n            automotiveCanLog_fixed(\"CAN message processing failed: Calculated handler index out of bounds (fixed).\");\n        }\n    } else {\n        automotiveCanLog_fixed(\"CAN message processing failed: Message ID out of expected range (fixed).\");\n    }\n}\n\nvoid canCommunicationModuleMain_fixed() {\n    initializeCanHandlers_fixed();\n    CanMessage incoming_msg = receiveCanMessage_fixed();\n    processCanMessage_fixed(incoming_msg);\n}",
    "analysis": ""
  }
]